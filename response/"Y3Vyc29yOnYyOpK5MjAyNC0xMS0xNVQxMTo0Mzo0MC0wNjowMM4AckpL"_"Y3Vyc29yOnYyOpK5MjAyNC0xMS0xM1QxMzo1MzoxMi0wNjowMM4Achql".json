{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMS0xM1QxMzo1MzoxMi0wNjowMM4Achql"
    },
    "edges": [
      {
        "node": {
          "title": "Issue with coupledDiv for Hydrogen Embrittlement Governing Equation",
          "author": {
            "login": "AlejandroRiano2023"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello, I hope you are doing great!\nHello,\nI hope you are doing well!\nI am trying to implement the following governing equation for Hydrogen Embrittlement:\n\nThe equation involves the use of divergence. I am attempting to use coupledDiv as suggested in the MOOSE documentation, but I encounter the following error when compiling my application:\n/home/lriaomol/projects/otter/src/kernel/KernelEq1.C:51:19: error: 'coupledDiv' was not declared in this scope; did you mean 'coupledDot'?\n51 |     Real term2 = -coupledDiv((1.0 - _d[_qp]) * (1.0 - _d[_qp]) * _D_L * _grad_C_L[_qp]);\n|                   ^~~~~~~~~~\n|                   coupledDot\nCould you please assist in resolving this issue? Additionally, I am using the article \u201cPhase Field Modeling of Hydrogen Embrittlement\u201d by Huang (2020) as the basis for my model, which you can find here.\nHere is the kernelEq1.c\n#include \"KernelEq1.h\"\n#include \"MooseVariable.h\"\nregisterMooseObject(\"otterApp\", KernelEq1);\nInputParameters\nKernelEq1::validParams()\n{\nInputParameters params = Kernel::validParams();\nparams.addRequiredCoupledVar(\"C_L\", \"Concentration C_L.\");\nparams.addRequiredCoupledVar(\"C_T\", \"Concentration C_T.\");\nparams.addRequiredCoupledVar(\"theta_T\", \"Theta_T variable.\");\nparams.addRequiredCoupledVar(\"d\", \"d variable.\");\nparams.addRequiredCoupledVar(\"hidrostatic_stress\", \"Hydrostatic stress variable.\");\nparams.addRequiredCoupledVar(\"N_T\", \"N_T variable.\");\nparams.addRequiredCoupledVar(\"effective_plastic_strain\", \"Effective plastic strain.\");\nparams.addParam(\"D_L\", 12700.0, \"Diffusion coefficient D_L (micrometers squared per second).\");\nparams.addParam(\"V_H\", 2e12, \"Volume or velocity V_H (micrometers cubed per mole).\");\nparams.addParam(\"R\", 4.1240, \"R value.\");\nparams.addParam(\"Theta\", 554.25, \"Theta value.\");\nreturn params;\n}\nKernelEq1::KernelEq1(const InputParameters & parameters) :\nKernel(parameters),\n_C_L(coupledValue(\"C_L\")),\n_grad_C_L(coupledGradient(\"C_L\")),\n_der_C_L(coupledDot(\"C_L\")),\n_C_T(coupledValue(\"C_T\")),\n_theta_T(coupledValue(\"theta_T\")),\n_d(coupledValue(\"d\")),\n_D_L(getParam(\"D_L\")),  // Get D_L from the parameters\n_V_H(getParam(\"V_H\")),  // Get V_H from the parameters\n_hidrostatic_stress(coupledValue(\"hidrostatic_stress\")),\n_grad_hidrostatic_stress(coupledGradient(\"hidrostatic_stress\")),\n_N_T(coupledValue(\"N_T\")),\n_effective_plastic_strain(coupledValue(\"effective_plastic_strain\")),\n_der_effective_plastic_strain(coupledDot(\"effective_plastic_strain\")),\n_R(getParam(\"R\")),\n_Theta(getParam(\"Theta\"))\n{\n}\nReal\nKernelEq1::computeQpResidual()\n{\n// Term 1: Temporal derivative of C_L multiplied by a factor\nReal term1 = ((_C_L[_qp] + _C_T[_qp] * (1.0 - _theta_T[_qp])) / _C_L[_qp]) * _der_C_L[_qp];\n// Term 2: Divergence of the diffusion term\nReal term2 = -coupledDiv((1.0 - _d[_qp]) * (1.0 - _d[_qp]) * _D_L * _grad_C_L[_qp]);\n\n// Term 3: Divergence of the additional term with concentration, velocity, and gradient of sigma_H\nReal term3 = coupledDiv((1.0 - _d[_qp]) * (1.0 - _d[_qp]) * _D_L * _C_L[_qp] * _V_H * _grad_hidrostatic_stress[_qp] / (_R * _Theta));\n\n// Term 4: Temporal derivative of epsilon multiplied by the derivative of N_T with respect to epsilon\nReal derivative_N_T = 2.30258 * _N_T[_qp] * 12.815 * std::exp(-5.5 * _effective_plastic_strain[_qp]);  // Derivative of N_T with respect to epsilon\nReal term4 = _theta_T[_qp] * derivative_N_T * _der_effective_plastic_strain[_qp];\n\nreturn term1 + term2 + term3 + term4;\n\n}\nReal\nKernelEq1::computeQpJacobian()\n{\n// Here you can calculate the derivative with respect to the variables if necessary\nreturn 1.0; // Simplified Jacobian\n}",
          "url": "https://github.com/idaholab/moose/discussions/29038",
          "updatedAt": "2024-11-15T17:25:33Z",
          "publishedAt": "2024-11-08T22:42:56Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\ncoupledDiv should be used the same way that coupledValue is used, in the constructor intializer's list, and you have to specify the name of a variable, you cannot just specify an entire expression to take the divergence of",
                  "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11193802",
                  "updatedAt": "2024-11-08T22:56:03Z",
                  "publishedAt": "2024-11-08T22:47:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AlejandroRiano2023"
                          },
                          "bodyText": "Hello,\nI hope you're doing well. I followed your advice and created a new kernel to store the value of an entire expression. This will allow me to call the new variable and use coupleDiv. However, when I compile the new kernel, I encounter the following error:\n\nFrom my perception the error means that _grad_hidrostatic_stress[_qp] returns a vector (of type libMesh::TypeVector) and not a scalar value (double), which causes the conversion error. What could I do in this case, is there a way to store a typeVector?\nHere is the new kernel https://drive.google.com/drive/folders/1aox0WKZ9rwITmT6EFYwgvDwzhVbZFhEe?usp=sharing",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11232798",
                          "updatedAt": "2024-11-12T21:50:33Z",
                          "publishedAt": "2024-11-12T21:50:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes exactly.\nIf term3 should be a vector, then use this:\nRealVectorValue term3 = ....\n\nelse you are likely missing a dot-product or a \"take the component of this vector\" operation in the code",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11233220",
                          "updatedAt": "2024-11-12T22:58:49Z",
                          "publishedAt": "2024-11-12T22:58:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AlejandroRiano2023"
                          },
                          "bodyText": "Thank you so much for your response, GiudGiud! It worked perfectly.\nI also have a question regarding the correct way to register the divergence of a variable when working with kernel.h. I was initially tempted to use VariableDiv, but it didn't work as expected.\nHere is the relevant code:\n{\npublic:\nstatic InputParameters validParams();\nCLCalc(const InputParameters & parameters);\nprotected:\n/// ADKernel objects must override precomputeQpResidual\nvirtual ADRealVectorValue precomputeQpResidual() override;\nprivate:\nconst VariableValue & _C_L;                 // Concentration C_L\nconst VariableGradient & _grad_C_L;         // Gradient of C_L\nconst VariableDiv & _div_CLCalc_3;          // Divergence of C_L (Issue here)\n};\nCould you help clarify the correct approach for registering the divergence of a variable?",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11245288",
                          "updatedAt": "2024-11-13T19:19:26Z",
                          "publishedAt": "2024-11-13T19:19:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you look at Coupleable.h you should see the expected type is VectorVariableDivergence\n  /**\n   * Returns divergence of a coupled variable\n   * @param var_name Name of coupled variable\n   * @param comp Component number for vector of coupled variables\n   * @return Reference to a VectorVariableDivergence containing the divergence of the coupled\n   * variable\n   * @see Kernel::_div_u\n   */\n  virtual const VectorVariableDivergence & coupledDiv(const std::string & var_name,\n                                                      unsigned int comp = 0) const;",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11245330",
                          "updatedAt": "2024-11-13T19:22:28Z",
                          "publishedAt": "2024-11-13T19:22:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AlejandroRiano2023"
                          },
                          "bodyText": "Hello GiudGiud, I reviewed the MOOSE documentation for Coupleable.h (https://mooseframework.inl.gov/releases/moose/v1.0.0/doxygen/moose/Coupleable_8h_source.html), but I couldn\u2019t locate the expected type for VectorVariableDivergence. I don\u2019t know if maybe I am overlooking something. Could you please share the link to the Coupleable.h file where this type is defined?",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11270247",
                          "updatedAt": "2024-11-15T16:39:14Z",
                          "publishedAt": "2024-11-15T16:39:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you used the old doco from a release. Use the current one\nhttps://mooseframework.inl.gov/docs/doxygen/moose/Coupleable_8h_source.html",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11271110",
                          "updatedAt": "2024-11-15T17:25:34Z",
                          "publishedAt": "2024-11-15T17:25:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "AlejandroRiano2023"
                  },
                  "bodyText": "Thank you so much for your response, @GiudGiud, I really appreciate it! I just have a quick clarification: In my system of equations, I have 4 unknowns and 4 equations, and I am creating one kernel for each unknown. When I compile the app, will it automatically solve for all 4 unknowns? Is this the correct approach?",
                  "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11193874",
                  "updatedAt": "2024-11-08T23:05:49Z",
                  "publishedAt": "2024-11-08T23:05:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "once you form all 4 equations in the input file, whether using a single kernel per equation or multiple kernels (one per term in the equation). you will be able to run the input file using the app executable.\nNote that time derivative terms need to be separated from the rest of the equation, in their own kernel",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11193889",
                          "updatedAt": "2024-11-08T23:09:08Z",
                          "publishedAt": "2024-11-08T23:09:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AlejandroRiano2023"
                          },
                          "bodyText": "Thank you for the clarification!\nRegarding this, would it be okay to have some terms as auxiliary kernels and others as main kernels, or would that pose any issues? I'm wondering if this would affect the solution process or cause any unintended problems.",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11193916",
                          "updatedAt": "2024-11-08T23:15:43Z",
                          "publishedAt": "2024-11-08T23:15:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it's ok to compute some terms with auxiliary kernels, but very often you end up needing the derivatives of these terms (either using AD or manual Jacobian). And at that point, it's better to use material properties for them",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11193952",
                          "updatedAt": "2024-11-08T23:24:07Z",
                          "publishedAt": "2024-11-08T23:24:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AlejandroRiano2023"
                          },
                          "bodyText": "Thank you so much for all your help, I appreciate it.",
                          "url": "https://github.com/idaholab/moose/discussions/29038#discussioncomment-11194568",
                          "updatedAt": "2024-11-09T02:36:33Z",
                          "publishedAt": "2024-11-09T02:36:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Output or view the variable value at the quadrature point",
          "author": {
            "login": "keassyguang"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi everyone,\nI'd like to know if it's possible to output or view a variable value at the quadrature point through Paraview? Just like in ABAQUS, we can choose where we want to view, for example the element, node, integration point.\nMany thanks.",
          "url": "https://github.com/idaholab/moose/discussions/28912",
          "updatedAt": "2024-11-15T02:19:51Z",
          "publishedAt": "2024-10-23T09:24:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes you need to use the Positions system to pick the locations to compute at.\nThen use this VPP\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/PositionsFunctorValueSampler.html\nA functor can be a variable or a function or a functor material property",
                  "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11027314",
                  "updatedAt": "2024-10-23T09:49:05Z",
                  "publishedAt": "2024-10-23T09:49:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Thanks a lot, I will have try later.",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11027452",
                          "updatedAt": "2024-10-23T10:01:36Z",
                          "publishedAt": "2024-10-23T10:01:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "keassyguang"
                  },
                  "bodyText": "I might find an issue, if the specified output block is \"growing\" over the time during the simulation (element activated with CoupledVarThresholdElementSubdomainModifier method), the output quadrature points are as the initial defined block rather than the updated block.",
                  "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11161172",
                  "updatedAt": "2024-11-06T01:36:20Z",
                  "publishedAt": "2024-11-06T01:36:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "to update positions, specify an \"execute_on\" parameter",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11161291",
                          "updatedAt": "2024-11-06T01:50:25Z",
                          "publishedAt": "2024-11-06T01:50:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "keassyguang"
                  },
                  "bodyText": "to update positions, specify an \"execute_on\" parameter\n\nI specified execute_on = 'TIMESTEP_END', and it works now, thanks a lot",
                  "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11161360",
                  "updatedAt": "2024-11-06T02:03:25Z",
                  "publishedAt": "2024-11-06T02:03:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "It seems that the variable values at the quadrature point are correct. However, I have some problems when viewing the results in Paraview. Here, I defined the light intensity to decay exponentially from the top surface to the bottom inherited from Material class. The top boundary is defined using the CoupledVarThresholdElementSubdomainModifier and moves upwards every 4 seconds with a layer thickness of 1. I got three problems:\n\nThe moving boundary (sideset_top) moves correctly when I set expression = 'y-ceil(t/4.0001)' for the AuxVariable layerY, but it doesn't move correctly when I set expression = 'y-ceil(t/4)'. I know it is a numerical error problem, and that is why I choose 4.0001 instead of 4. However, for the LightIntensityMaterial.C, I also tried to avoid this numerical error problem. As it is implemented below, shen the time comes to 4s, the height of the top surface (domain_height) should be 1, however in the calculation the domain_height is 2. Any good solution to avoid these numerical error issues in the coding?\nThe light intensity on the top surface seems to be wrong except for the last layer. Since we define light_intensity = 100*exp(-(domain_height - y)/Dp), the light intensity for the top surface should always be 100. In the figure below, the light intensity on the upper surface is half of what it should be, even for the one (Time=4s) equals to 30.3 (60.6 = 100*exp(-(2-1)/2)). How can I show the correct value in paraview?\n\n\nheader file\n#pragma once\n\n#include \"ADMaterial.h\"\n\nclass LightIntensityMaterial : public ADMaterial\n{\npublic:\n  static InputParameters validParams();\n  LightIntensityMaterial(const InputParameters & parameters);\n\n  virtual void computeQpProperties() override;\n\nprotected:\n  const Real _I0;\n  const Real _Dp;\n  const Real _period;\n  const Real _I0_on_duration;\n  const Real _layer_thickness;\n  const Real _x_start;\n  const Real _x_end;\n\n  // Light intensity I(x, t)\n  ADMaterialProperty<Real> & _I;                  \n};\n\nsource file\n#include \"LightIntensityMaterial.h\"\n\nregisterMooseObject(\"elementActivationTestApp\", LightIntensityMaterial);\n\nInputParameters\nLightIntensityMaterial::validParams()\n{\n  InputParameters params = ADMaterial::validParams();\n  params.addRequiredParam<Real>(\"I0\", \"Initial light intensity\");\n  params.addRequiredParam<Real>(\"Dp\", \"Penetration depth\");\n  params.addRequiredParam<Real>(\"period\", \"Period over which domain height increases\");\n  params.addRequiredParam<Real>(\"I0_on_duration\", \"Duration during which I0 is on in each period\");\n  params.addRequiredParam<Real>(\"layer_thickness\", \"Domain height increment every period\");\n  params.addRequiredParam<Real>(\"x_start\", \"x_start position\");\n  params.addRequiredParam<Real>(\"x_end\", \"x_end position\");\n  params.addClassDescription(\"Kernel to compute monomer light intensity\");\n\n  return params;\n}\n\nLightIntensityMaterial::LightIntensityMaterial(const InputParameters & parameters)\n  : ADMaterial(parameters),\n    _I0(getParam<Real>(\"I0\")),\n    _Dp(getParam<Real>(\"Dp\")),\n    _period(getParam<Real>(\"period\")),\n    _I0_on_duration(getParam<Real>(\"I0_on_duration\")),\n    _layer_thickness(getParam<Real>(\"layer_thickness\")),\n    _x_start(getParam<Real>(\"x_start\")),\n    _x_end(getParam<Real>(\"x_end\")),\n    _I(declareADProperty<Real>(\"I\"))\n{\n}\n\nvoid LightIntensityMaterial::computeQpProperties()\n{\n  if (_q_point[_qp](0) >= _x_start && _q_point[_qp](0) <= _x_end)\n  {\n    Real n_periods = 0;\n    if (_t == 0){\n      n_periods = 1;\n    }\n    else{\n      // Calculate the number of completed height periods\n      n_periods = std::ceil(_t / _period);\n    }\n    \n    // Calculate the current domain height\n    Real domain_height = n_periods * _layer_thickness;\n\n    // Calculate depth\n    Real depth = domain_height - _q_point[_qp](1); // Assuming y is the vertical coordinate (2D case)\n\n    Real t_mod_period = std::fmod(_t, _period);\n    ADReal I0_t = (t_mod_period < _I0_on_duration) ? _I0 : 0.0;\n    \n    _I[_qp] =  I0_t * std::exp(-depth / _Dp);\n\n    // output for debug\n    if (1.9<_t && _t<2.1 && _q_point[_qp](0) >= 2.9 && _q_point[_qp](0) <= 3.1 && _q_point[_qp](1) >= 0.9){\n      std::cout << \"time = \" << _t<< std::endl;\n      std::cout << \"x = \" << _q_point[_qp](0) << std::endl;\n      std::cout << \"y = \" << _q_point[_qp](1) << std::endl;\n      std::cout << \"domain_height = \" << domain_height << std::endl;\n      std::cout << \"depth = \" << depth << std::endl;\n      std::cout << \"I0_t = \" << I0_t << std::endl;\n      std::cout << \"light intensity = \" << _I[_qp] << \"\\n\" << std::endl;\n    }\n  }\n  else \n  {\n    _I[_qp] = 0.0;\n  }\n}\n\ninput file\n[Problem]\n  kernel_coverage_check = false\n  boundary_restricted_node_integrity_check = false\n  boundary_restricted_elem_integrity_check = false\n  type = FEProblem\n[]\n  \n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 30\n    ny = 20\n    xmax = 6\n    ymax = 4\n  []\n  [active_domain] #the initially active domain\n    type = SubdomainBoundingBoxGenerator\n    input = 'gen'\n    block_id = 1\n    bottom_left = '0 0 0'\n    top_right = '6 1 0'\n  []\n  [inactive_domain] #the initially inactive domain\n    type = SubdomainBoundingBoxGenerator\n    input = 'active_domain'\n    block_id = 2\n    bottom_left = '0 1 0'\n    top_right = '6 4 0'\n  []\n  [sideset_top]\n    type = SideSetsAroundSubdomainGenerator\n    input = inactive_domain\n    normal = '0 1 0'\n    block = 1\n    new_boundary = 'sideset_top' # top boundary of active domain\n  []\n[]\n  \n[Variables]\n  [T]\n    initial_condition = 400 #Kelvin\n    block = 1\n  []\n[]\n\n[AuxVariables]\n  [layerY]\n    [AuxKernel]\n    type = ParsedAux\n    expression = 'y-ceil(t/4.0001)'\n    # expression = 'y-ceil(t/4)'\n    use_xyzt = true\n    execute_on = 'INITIAL TIMESTEP_BEGIN'\n    []\n  []\n  [I_aux]\n    block = 1\n    order = FIRST\n    family = MONOMIAL\n  []\n[] \n  \n[Kernels]\n  [conduction]\n    block = 1\n    type = ADHeatConduction\n    variable = T\n  []\n[]\n\n[AuxKernels]\n  [I_aux]\n    type = ADMaterialRealAux\n    block = 1\n    variable = I_aux\n    property = I\n    execute_on = 'initial timestep_end'\n  []\n[]\n\n[MeshModifiers]\n  [addLayer] \n    type = CoupledVarThresholdElementSubdomainModifier\n    coupled_var = 'layerY'\n    criterion_type = BELOW\n    threshold = 0\n    subdomain_id = 1\n    moving_boundaries = 'sideset_top'\n    moving_boundary_subdomain_pairs = '1 2'\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n[]\n\n[Materials]\n  [thermal]\n    type = ADHeatConductionMaterial\n    block = 1\n    specific_heat = 1e-2\n    thermal_conductivity = 1.0e-3\n  []\n  [density]\n    type = ADGenericConstantMaterial\n    block = 1\n    prop_names = 'density'\n    prop_values = '1'\n  []\n  [dummy_mat_inactive]\n    type = GenericConstantMaterial\n    block = 2\n    prop_names = 'dummy_mat'\n    prop_values = '0.0'\n  []\n  [Light_Intensity_Material]\n    type = LightIntensityMaterial\n    block = 1\n    I0 = 100                      \n    Dp = 2              \n    period = 4                   \n    layer_thickness = 1         \n    I0_on_duration = 3           \n    x_start = 0                \n    x_end = 6                             \n  []\n[]\n\n[BCs]\n  # In 2D, bottom = 0, right = 1, top = 2, left = 3 \n  [bottom_BC]\n    type = ADDirichletBC\n    variable = T\n    boundary = 0\n    value = 400\n  []\n  [side_top_BC]\n    type = ADConvectiveHeatFluxBC\n    variable = T\n    boundary = sideset_top\n    T_infinity = 300.0\n    heat_transfer_coefficient = 10\n  []\n\n  [right_BC]\n    type = ADConvectiveHeatFluxBC\n    variable = T\n    boundary = 'right'\n    T_infinity = 300.0\n    heat_transfer_coefficient = 20\n  []\n\n  [left_BC]\n    type = ADConvectiveHeatFluxBC\n    variable = T\n    boundary = left\n    T_infinity = 300.0\n    heat_transfer_coefficient = 20\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = PJFNK\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = '201                hypre    boomeramg      8'\n  end_time = 16\n  dt = 0.1\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-12\n[]\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11239028",
                          "updatedAt": "2024-11-13T11:37:29Z",
                          "publishedAt": "2024-11-13T11:36:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThere's a lot here. I think you should boil this down to a very simple input so it s more understandable what you want and how it differs from what you get.\nKeep in mind\n  [I_aux]\n    block = 1\n    order = FIRST\n    family = MONOMIAL\n  []\n\nis not output in the expected manner to Exodus. So what you may be looking at could just be visualization artefact.\nThere's a thread on the forum somewhere about how it differs.\nI recommend you switch this one to a constant monomial which are output as expected, to make sure the visualization is not the problem\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11245640",
                          "updatedAt": "2024-11-13T19:58:46Z",
                          "publishedAt": "2024-11-13T19:58:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Sorry for the lack of clarity.\nI have tried setting the variable to order=CONSTANT and family = MONOMIAL. The results seem to be correct, but we lose the gradient inside the element.\nI have two problems:\n\n\nIn my code, I need to use time (_t in the source file and t in the input file) to define the movement of the top surface to simulate the addition of material in additive manufacturing. For example, I've defined an auxiliary variable, layerY, whose value is set to expression = 'y-ceil(t/4)' as I want to move this top boundary every 4 seconds. Based on the current results, it seems that the time (t) sometimes has a numerical error, e.g. if the time is 4s, the value of t is slightly greater (or smaller) than 4, something like 4.0001s (or 3.9999s). It seems difficult to get the exact integer time.\n\n\nI have defined a material property, light intensity, which decreases exponentially from top surface to bottom. The expression is light_intensity = I_0*exp(-(domain_height - y)/Dp), domain_height is the y-coordinate of the top surface (layY), and Dp is a constant. For each period (4 seconds) I_0=100 for 0s<time<3s and I_0=0 for 3s<time<4s. For the nodes (or points) on the top surface, the light intensity should be 100. However, from the figure above, the light intensity of the top surface equal to 50 (half of 100) for t=1.9s, t=4.1s, and t=8.1s while the result for t=12.1s is correct. Since the nodes on the top surface are shared with the inactive elements when time < 12s, the light intensity values on the top surface are always half of what they should be. I am not sure if the MOOSE averages the values of these shared nodes at the interface of the active and inactive domains.",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11252106",
                          "updatedAt": "2024-11-14T09:41:33Z",
                          "publishedAt": "2024-11-14T09:41:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I have tried setting the variable to order=CONSTANT and family = MONOMIAL. The results seem to be correct, but we lose the gradient inside the element.\n\nYes but the visualization works as expected and that seems to be your problem with first order monomials.\n\n, it seems that the time (t) sometimes has a numerical error, e.g. if the time is 4s, the value of t is slightly greater (or smaller) than 4, something like 4.0001s (or 3.9999s). It seems difficult to get the exact integer time.\n\nThat is expected. t is the sum of dts, which are floating point numbers. If you want to hit t = 4s exactly, use 4s as a sync time (in any Outputs object). This will force the time stepper to hit it.\nOR\nuse multiple time steppers, including a TimeSequenceStepper with 4s as a time to hit.\n\nSince the nodes on the top surface are shared with the inactive elements when time < 12s, the light intensity values on the top surface are always half of what they should be. I am not sure if the MOOSE averages the values of these shared nodes at the interface of the active and inactive domains.\n\nIs the light intensity a first order monomial?\nDid you check the variable value or are you just reporting what you saw in paraview?",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11255623",
                          "updatedAt": "2024-11-14T15:01:06Z",
                          "publishedAt": "2024-11-14T15:01:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "That is expected. t is the sum of dts, which are floating point numbers. If you want to hit t = 4s exactly, use 4s as a sync time (in any Outputs object). This will force the time stepper to hit it.\nOR\nuse multiple time steppers, including a TimeSequenceStepper with 4s as a time to hit.\n\nThank you very much. I will try it later.\n\nIs the light intensity a first order monomial?\n\nLight intensity (I) is defined as material property, and I use a auxVariable I_aux for output.\n\nDid you check the variable value or are you just reporting what you saw in paraview?\n\nI didn't check the value, just based on the result shown in the paraview. I think this is the visualization artefact in the paraview as I output the sampled values, they are correct. The picture below shows the result at time=1.9s, all values are correct. The top row is based on FIRST and the second on CONSTANT.\nDo we have any ideas to avoid the paraview visualization artefacts except using the CONSTANT MONOMIAL?\n\n[AuxVariables]\n  [I_aux]\n    block = 1\n    order = FIRST\n    # order = CONSTANT\n    family = MONOMIAL\n  []\n[] \n\n[AuxKernels]\n  [I_aux]\n    type = ADMaterialRealAux\n    block = 1\n    variable = I_aux\n    property = I\n    execute_on = 'initial timestep_end'\n  []\n[]\n\n[Materials]\n  [Light_Intensity_Material]\n    type = LightIntensityMaterial\n    block = 1\n    I0 = 100                      \n    Dp = 2              \n    period = 4                   \n    layer_thickness = 1         \n    I0_on_duration = 3           \n    x_start = 0                \n    x_end = 6                             \n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11261739",
                          "updatedAt": "2024-11-15T02:00:07Z",
                          "publishedAt": "2024-11-15T01:58:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Do we have any ideas to avoid the paraview visualization artefacts except using the CONSTANT MONOMIAL?\n\nYou could use the VTK output to plot it in python, bypassing paraview",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11261803",
                          "updatedAt": "2024-11-15T02:10:25Z",
                          "publishedAt": "2024-11-15T02:10:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/28912#discussioncomment-11261863",
                          "updatedAt": "2024-11-15T02:19:52Z",
                          "publishedAt": "2024-11-15T02:19:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Discrete Nucleation Module inserting nuclei with negative value order parameter in grand potential model",
          "author": {
            "login": "aclin4"
          },
          "bodyText": "Hi all,\nI'm working on a grand potential phase field model to simulate the formation of gas bubbles in a fuel matrix. In my model there are four variables: the matrix phase order parameter, the bubble phase order parameter, chemical potential of gas, and chemical potential of vacancies. The full input file is included at the end of this post.\nI'm inserting the nuclei using the DiscreteNucleationForce kernel acting on the bubble order parameter:\n[nucleation_b]\n    type = DiscreteNucleationForce\n    variable = etab0\n    map = B_map\n    nucleus_value = 100\n    no_nucleus_value = 0\n[]\n\nwhere the nucleation probability is based on the supersaturation of the gas and vacancies in the matrix:\n[G_nuc]\n   type = DerivativeParsedMaterial\n   property_name = G_nuc\n   material_property_names = 'km cveq_m cgeq_m cgeq_b cv(wv) cg(wg)'\n   expression = '(cv - cveq_m) + (cg-cgeq_m)'\n   outputs = exodus\n   output_properties = G_nuc\n []\n [nucl_matl]\n   type = ParsedMaterial\n   property_name = nucl_matl\n   coupled_variables = 'etab0'\n   material_property_names = 'cg(wg) T G_nuc'\n   constant_names = 'k1star k2'\n   constant_expressions = '1e-6 \t10'\n   expression = 'if(cg>1.5e-6,if(etab0<0.0001, k1star * exp(-k2/G_nuc/T), 0),0)'\n   outputs = exodus\n []\n[../]\n\nThe UserObjects for the Discrete Nucleation Module are set up like so:\n[UserObjects]\n  [B_inserter]\n    type = DiscreteNucleationInserter\n    hold_time = 1000\n    probability = nucl_matl\n    radius = 2\n  []\n  [B_map]\n    type = DiscreteNucleationMap\n    periodic = etab0\n    inserter = B_inserter\n    int_width = 0.5\n  []\n[]\n\nHowever, when I run my simulation and a nuclei is inserted, the order parameter for the bubble phase takes a negative value. (case A)\nIn certain instances, if I modify the nucleation rate to be higher at a lower supersaturation, the nuclei will be inserted initially with a positive value, but in the subsequent timestep, the value becomes negative. (case B)\nDoes anyone have any insight as to why this is happening?\nUpdate\nI managed to get a positive value inserted for the nuclei by using the DiscreteNucleationTimeStep to limit the timestep near the nuclei insertion, however, now I get a strange propagating numerical error surrounding the nuclei (see Case C figures below). I'm unsure if this is related to the above issue or is a completely different numerical problem. Any insight into this would be greatly appreciated!\nThanks,\nAlbert\nCase A:\n\nCase B:\n\n\n\nCase C:\n\n\nFull Input File:\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    elem_type = QUAD4\n    nx = 80\n    ny = 80\n    nz = 0\n    xmin = -20\n    xmax = 20\n    ymin = -20\n    ymax = 20\n    zmin = 0\n    zmax = 0\n    #uniform_refine = 2\n  []\n[]\n[GlobalParams]\n  file_base = 'just_nuc'\n[]\n\n[Variables]\n  [./wv]\n  [../]\n  [./wg]\n  [../]\n  [./etam0]\n  [../]\n  [./etab0]\n  [../]\n[]\n\n[AuxVariables]\n  [./n]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n[AuxKernels]\n  [./nucc]\n    type = DiscreteNucleationAux\n    map = B_map\n    variable = n\n    no_nucleus_value = 0\n    nucleus_value = 10\n    execute_on = TIMESTEP_END\n  [../]\n[]\n\n[BCs]\n  [./Periodic]\n    [./all]\n      variable = 'etam0 etab0 wv wg'\n      auto_direction = 'x y'\n    [../]\n  [../]\n\n[]\n\n[ICs]\n  [./IC_etam0]\n    type = SpecifiedSmoothCircleIC\n    variable = etam0\n    invalue = 1\n    outvalue = 1\n    x_positions = '  -8.0   7.0 -10.0   7.0'\n    y_positions = '  -8.0   8.0   6.0  -8.0'\n    z_positions = '   0.0   0.0   0.0   0.0'\n    radii = '   1.0   1.0   1.0   1.0'\n  []\n  [./IC_etab0]\n    type = SpecifiedSmoothCircleIC\n    variable = etab0\n    invalue = 0\n    outvalue = 0\n    x_positions = '  -8.0   7.0 -10.0   7.0'\n    y_positions = '  -8.0   8.0   6.0  -8.0'\n    z_positions = '   0.0   0.0   0.0   0.0'\n    radii = '   1.0   1.0   1.0   1.0'\n  []\n  [./IC_wv]\n    type = RandomIC\n    variable = wv\n    min  = 5\n    max  = 6\n    seed = 349\n  [../]\n  [./IC_wg]\n    type = RandomIC\n    variable = wg\n    min = 5\n    max = 6\n    seed = 234\n  [../]\n[]\n\n[Kernels]\n# Order parameter eta_m0\n  [./em0_dot]\n    type = TimeDerivative\n    variable = etam0\n  [../]\n  [./ACm0_bulk]\n    type = ACGrGrMulti\n    variable = etam0\n    v =           'etab0'\n    gamma_names = 'gmb'\n    mob_name = L\n  [../]\n  [./ACm0_int]\n    type = ACInterface\n    variable = etam0\n    kappa_name = kappa\n  [../]\n  [./ACm0_sw]\n    type = ACSwitching\n    variable = etam0\n    Fj_names  = 'omegam omegab'\n    hj_names  = 'hm     hb'\n    coupled_variables = 'etab0 wv wg'\n  [../]\n  # [nucleation_m]\n  #   type = DiscreteNucleationForce\n  #   variable = etam0\n  #   map = B_map\n  #   nucleus_value = -5\n  #   no_nucleus_value = 0\n  # []\n # Order parameter eta_b0\n  [./eb0_dot]\n    type = TimeDerivative\n    variable = etab0\n  [../]\n  [./ACb0_bulk]\n    type = ACGrGrMulti\n    variable = etab0\n    v =           'etam0'\n    gamma_names = 'gmb'\n    mob_name = L\n  [../]\n  [./ACb0_int]\n    type = ACInterface\n    variable = etab0\n    kappa_name = kappa\n  [../]\n  [./ACb0_sw]\n    type = ACSwitching\n    variable = etab0\n    Fj_names  = 'omegam omegab'\n    hj_names  = 'hm     hb'\n    coupled_variables = 'etam0 wv wg'\n  [../]\n  [nucleation_b]\n    type = DiscreteNucleationForce\n    variable = etab0\n    map = B_map\n    nucleus_value = 100\n    no_nucleus_value = 0\n  []\n#Chemical potential vacancies\n  [./wv_dot]\n    type = SusceptibilityTimeDerivative\n    variable = wv\n    f_name = chiv\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [./wvDiffusion]\n    type = MatDiffusion\n    variable = wv\n    diffusivity = Dchiv\n    args = ''\n  [../]\n  [./wvcoupled_etam0dot]\n    type = CoupledSwitchingTimeDerivative\n    variable = wv\n    v = etam0\n    Fj_names = 'rhovm rhovb'\n    hj_names = 'hm   hb'\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [./wvcoupled_etab0dot]\n    type = CoupledSwitchingTimeDerivative\n    variable = wv\n    v = etab0\n    Fj_names = 'rhovm rhovb'\n    hj_names = 'hm   hb'\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [vac_prod]\n    type = MaskedBodyForce\n    variable = wv\n    mask = prod\n    value = 0.2156\n  []\n#Chemical potential gas\n  [./wg_dot]\n    type = SusceptibilityTimeDerivative\n    variable = wg\n    f_name = chig\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [./wgDiffusion]\n    type = MatDiffusion\n    variable = wg\n    diffusivity = Dchig\n    args = ''\n  [../]\n  [./wgcoupled_etam0dot]\n    type = CoupledSwitchingTimeDerivative\n    variable = wg\n    v = etam0\n    Fj_names = 'rhogm rhogb'\n    hj_names = 'hm   hb'\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [./wgcoupled_etab0dot]\n    type = CoupledSwitchingTimeDerivative\n    variable = wg\n    v = etab0\n    Fj_names = 'rhogm rhogb'\n    hj_names = 'hm   hb'\n    coupled_variables = 'etam0 etab0'\n  [../]\n  [gas_prod]\n    type = MaskedBodyForce\n    variable = wg\n    mask = prod\n    value = 0.2716\n  []\n[]\n\n[Materials]\n[prod]\n  type = ParsedMaterial\n  property_name = prod\n  coupled_variables = 'etab0'\n  material_property_names = 'h_psi F_dot'\n  expression = '(etab0<0.5)*F_dot'\n  outputs = exodus\n  output_properties = prod\n[]\n[./const]\n  type = GenericConstantMaterial\n  prop_names =  'L  kappa_p    mu_p     gmb Vm        Va         Egf Evf   cveq_b cgeq_b T    kbz       F_dot  cv0   l_star t_star E_star'\n  prop_values = '10 1.5e-10    3e10     1.5 2.462e22  4.090e-2    5.6 3.27  0.4425 0.5575 1200 8.617e-5  1e-8   0.005 1e-9   1      1e9'\n[../]\n[hvk_m]\n  type = DerivativeParsedMaterial\n  property_name = hvk_m\n  material_property_names = 'hm(etam0,etab0) Va km'\n  coupled_variables = 'etam0 etab0'\n  expression = 'hm/Va/km'\n[../]\n[hvk_b]\n  type = DerivativeParsedMaterial\n  property_name = hvk_b\n  material_property_names = 'hb(etam0,etab0) Va kb'\n  coupled_variables = 'etam0 etab0'\n  expression = 'hb/Va/kb'\n[../]\n# Switching Functions\n  [./ha_test]\n    type = SwitchingFunctionMultiPhaseMaterial\n    h_name = hm\n    all_etas = 'etam0 etab0'\n    phase_etas = 'etam0'\n  [../]\n  [./hb_test]\n    type = SwitchingFunctionMultiPhaseMaterial\n    h_name = hb\n    all_etas = 'etam0 etab0'\n    phase_etas = 'etab0'\n  [../]\n # Chemical Densities\n  [./rhovm]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wv'\n    property_name = rhovm\n    material_property_names = 'Va km cveq_m'\n    expression = 'wv/Va^2/km + cveq_m/Va'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhovm\n  [../]\n  [./rhovb]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wv'\n    property_name = rhovb\n    material_property_names = 'Va kb cveq_b'\n    expression = 'wv/Va^2/kb + cveq_b/Va'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhovb\n  [../]\n  [./rhogm]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wg'\n    property_name = rhogm\n    material_property_names = 'Va km cgeq_m'\n    expression = 'wg/Va^2/km + cgeq_m/Va'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhogm\n  [../]\n  [./rhogb]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wg'\n    property_name = rhogb\n    material_property_names = 'Va kb cgeq_b'\n    expression = 'wg/Va^2/kb + cgeq_b/Va'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhogb\n  [../]\n  [./rhog]\n    type = DerivativeParsedMaterial\n    property_name = rhog\n    material_property_names = 'rhogm(wg) rhogb(wg) hm(etam0,etab0) hb(etam0,etab0)'\n    expression = 'rhogm*hm + rhogb*hb'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhog\n  [../]\n  [./rhov]\n    type = DerivativeParsedMaterial\n    property_name = rhov\n    material_property_names = 'rhovm(wv) rhovb(wv) hm(etam0,etab0) hb(etam0,etab0)'\n    expression = 'rhovm*hm + rhovb*hb'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = rhov\n  [../]\n  [./cv]\n    type = DerivativeParsedMaterial\n    material_property_names = 'Va rhovm(wv) rhovb(wv) hm(etam0,etab0) hb(etam0,etab0) l_star'\n    expression = 'Va * (hm * rhovm + hb * rhovb)'\n    property_name = cv\n    outputs = exodus\n    output_properties = cv\n  [../]\n  [./cg]\n    type = DerivativeParsedMaterial\n    material_property_names = 'Va rhogm(wg) rhogb(wg) hm(etam0,etab0) hb(etam0,etab0) l_star'\n    expression = 'Va * (hm * rhogm + hb * rhogb)'\n    property_name = cg\n    outputs = exodus\n    output_properties = cg\n  [../]\n  [./cveq_m]\n    property_name = cveq_m\n    type = DerivativeParsedMaterial\n    material_property_names = 'Evf T kbz'\n    expression = '1e-6'#'exp(-Evf/kbz/T)'\n    outputs = exodus\n    output_properties = cveq_m\n  [../]\n  [./cgeq_m]\n    property_name = cgeq_m\n    type = DerivativeParsedMaterial\n    material_property_names = 'Egf T kbz'\n    expression = '1e-6'#'exp(-Egf/kbz/T)'\n    outputs = exodus\n    output_properties = cgeq_m\n  [../]\n\n  [./kappa_nondim]\n    type = DerivativeParsedMaterial\n    property_name = kappa\n    material_property_names = 'kappa_p l_star E_star'\n    expression = 'kappa_p/E_star/(l_star^2)'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = kappa\n  [../]\n  [./mu_nondim]\n    type = DerivativeParsedMaterial\n    property_name = mu\n    material_property_names = 'mu_p E_star'\n    expression = 'mu_p/E_star'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = mu\n  [../]\n # Diffusivity\n  [./vMobility]\n    type = DerivativeParsedMaterial\n    property_name = Dchiv\n    material_property_names = 'Dv chiv'\n    expression = 'Dv*chiv'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = Dchiv\n  [../]\n  [./vchi] #Non-dim\n    type = DerivativeParsedMaterial\n    property_name = chiv\n    material_property_names = 'Va hm(etam0,etab0) km hb(etam0,etab0) kb'\n    expression = '(hm/km + hb/kb) / Va^2'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = chiv\n  [../]\n  [./Dv] #Non-dim\n    type = DerivativeParsedMaterial\n    property_name = Dv\n    material_property_names = 'T kbz F_dot cv0'\n    expression = 10#'8.24e-10*exp(-4.96/kbz/T) + 1.27e-27*exp(-1.73/kbz/T)*sqrt(F_dot) + 4.5e-44*F_dot'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = Dv\n  [../]\n  [./gMobility]\n    type = DerivativeParsedMaterial\n    property_name = Dchig\n    material_property_names = 'Dg chig'\n    expression = 'Dg*chig'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = Dchig\n  [../]\n  [./gchi] #Non-dim\n    type = DerivativeParsedMaterial\n    property_name = chig\n    material_property_names = 'Va hm km hb kb'\n    expression = '(hm/km + hb/kb) / Va^2'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = chig\n  [../]\n  [./Dg]\n    type = DerivativeParsedMaterial\n    property_name = Dg\n    material_property_names = 'T kbz F_dot t_star l_star'\n    expression = 10 #'(1.288e-3*exp(-5.842/kbz/T) + 2.2837e-79*exp(-(1.32271/kbz/T)^2 - (28.425/kbz/T))*sqrt(F_dot) + 2.623e-35*exp(-1.588/kbz/T)*F_dot)'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = Dg\n  [../]\n# Grand Potential Densities\n  [./omegam]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wv wg'\n    property_name = omegam\n    material_property_names = 'Va km cveq_m cgeq_m'\n    expression = '-0.5*wv^2/Va^2/km-wv/Va*cveq_m - 0.5*wg^2/Va^2/km-wg/Va*cgeq_m'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = omegam\n  [../]\n  [./km] #nondim\n    type = ParsedMaterial\n    property_name = km\n    material_property_names = 'cv0 kbz Evf T E_star'\n    constant_names =       'k1        k2'\n    constant_expressions = '-1.787e6  1.287e10'\n    expression = '100*((k1*T + k2)/(cv0 - exp(-Evf/kbz/T))) / E_star'\n    outputs = exodus\n    output_properties = km\n  [../]\n  [./omegab]\n    type = DerivativeParsedMaterial\n    coupled_variables = 'wv wg'\n    property_name = omegab\n    material_property_names = 'Va kb f_0'\n    constant_names = 'cveq_b cgeq_b'\n    constant_expressions = '0.5575 0.4425'\n    expression = '-0.5*wv^2/Va^2/kb - wv/Va*cveq_b - 0.5*wg^2/Va^2/kb - wg/Va*cgeq_b + f_0'\n    derivative_order = 2\n    outputs = exodus\n    output_properties = omegab\n  [../]\n  [./kb]\n    type = ParsedMaterial\n    property_name = kb\n    material_property_names = 'T E_star'\n    expression = '(2.320e8*T + 8.6e7)/E_star'\n    outputs = exodus\n    output_properties = kb\n  [../]\n  [./f_0]\n    type = ParsedMaterial\n    property_name = f_0\n    material_property_names = 'T E_star'\n    expression = '(-6.28976e3*T + 1.28704e8)/E_star'\n  [../]\n  [isbubble]\n    type = ParsedMaterial\n    property_name = isbubble\n    coupled_variables = 'etab0'\n    expression = '(etab0>0.5)'\n  []\n  [f_chem]\n    type = ParsedMaterial\n    property_name = f_chem\n    material_property_names = 'hb hm omegab omegam'\n    expression = 'hb*omegab + hm*omegam'\n    outputs = exodus\n    output_properties = f_chem\n  []\n\n  ##############################################################################\n  # Nucleation Parameters                        ###############################\n  ##############################################################################\n  [G_nuc]\n    type = DerivativeParsedMaterial\n    property_name = G_nuc\n    material_property_names = 'km cveq_m cgeq_m cgeq_b cv(wv) cg(wg)'\n    expression = '(cv - cveq_m) + (cg-cgeq_m)'\n    outputs = exodus\n    output_properties = G_nuc\n  []\n  [nucl_matl]\n    type = ParsedMaterial\n    property_name = nucl_matl\n    coupled_variables = 'etab0'\n    material_property_names = 'cg(wg) T G_nuc'\n    constant_names = 'k1star k2'\n    constant_expressions = '1e-6 \t0.005'\n    expression = 'if(cg>1.5e-6,if(etab0<0.0001, k1star * exp(-k2/G_nuc/T), 0),0)'\n    outputs = exodus\n  []\n[../]\n[UserObjects]\n  [B_inserter]\n    type = DiscreteNucleationInserter\n    hold_time = 1000\n    probability = nucl_matl\n    radius = 2\n  []\n  [B_map]\n    type = DiscreteNucleationMap\n    periodic = etab0\n    inserter = B_inserter\n    int_width = 0.5\n  []\n[]\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Postprocessors]\n  [./dt]\n    type = TimestepSize\n  [../]\n  [./DOF]\n    type = NumDOFs\n  [../]\n  [./rhov_total]\n    type = ElementIntegralMaterialProperty\n    mat_prop = rhov\n    execute_on = 'initial timestep_end'\n  [../]\n  [./rhog_total]\n    type = ElementIntegralMaterialProperty\n    mat_prop = rhog\n    execute_on = 'initial timestep_end'\n  [../]\n  [./cgtotal]\n    type = ElementIntegralMaterialProperty\n    mat_prop = cg\n  [../]\n  [./cvtotal]\n    type = ElementIntegralMaterialProperty\n    mat_prop = cv\n  [../]\n  [bubblearea]\n    type = ElementIntegralMaterialProperty\n    mat_prop = isbubble\n  []\n  [bubblepresence]\n    type = ElementIntegralVariablePostprocessor\n    variable = etab0\n  []\n  [num_bubbles]\n    type = FeatureFloodCount\n    variable = etab0\n    threshold = 0.9\n  []\n  [nuc_rate]\n    type = DiscreteNucleationData\n    inserter = B_inserter\n    value = RATE\n  []\n  [nuc_insertions]\n    type = DiscreteNucleationData\n    inserter = B_inserter\n    value = INSERTIONS\n  []\n  [nuc_count]\n    type = DiscreteNucleationData\n    inserter = B_inserter\n    value = COUNT\n  []\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'#'-pc_type -ksp_gmres_restart -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'lu       superlu_dist'#'asm      31                 lu           1'\n  line_search = 'none'\n  automatic_scaling = true\n  nl_max_its = 15\n  l_max_its = 50\n  l_tol = 1e-3\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-12\n  end_time = 1e7\n  dtmin = 2e-20\n  dtmax = 50\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 0.1\n    cutback_factor = 0.5\n    growth_factor = 1.5\n    optimal_iterations = 15\n  [../]\n[]\n\n[Adaptivity]\n  marker = combo\n  max_h_level = 3\n  [Indicators]\n    [etaind]\n      type = GradientJumpIndicator\n      variable = etab0\n    []\n  []\n  [Markers]\n    [combo]\n      type = ComboMarker\n      markers = 'etaerror nuc'\n    []\n    [etaerror]\n      type = ErrorFractionMarker\n      coarsen = 0.2\n      indicator = etaind\n      refine = 0.7\n    []\n    [nuc]\n      type = DiscreteNucleationMarker\n      map = B_map\n    []\n  []\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\n[Outputs]\n  [./exodus]\n    type = Exodus\n    execute_on = 'initial timestep_end final'\n    min_simulation_time_interval = 0\n  [../]\n  [./csv]\n    type = CSV\n  [../]\n  print_linear_residuals = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/29081",
          "updatedAt": "2024-11-15T00:27:54Z",
          "publishedAt": "2024-11-14T20:01:45Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe results seem very oscillatory. Is the mesh sufficiently discretized? Are the time steps small enough?\nI think you are supposed to resolve the interface of the grain with the mesh size, which is not happening here. I think adaptivity is trying to address it but it's not clear to me that it is doing enough",
                  "url": "https://github.com/idaholab/moose/discussions/29081#discussioncomment-11261248",
                  "updatedAt": "2024-11-15T00:27:54Z",
                  "publishedAt": "2024-11-15T00:27:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Modified smeared cracking model but damage variable exceeds range",
          "author": {
            "login": "chunhuizhao478"
          },
          "bodyText": "Hi all, I wrote a modified nonlocal damage model based on ComputeSmearedCrackingStress, inside it updates crack_damage and constrain its value between 0 and 1. And it modifies the elasticity tensor accordingly. I allow the RadialAverage  to execute LINEAR at each iteration, take in a local equivalent strain and compute the nonlocal equivalent strain eqstrain_nonlocal to be fed in this material to guide the damage evolution. However, the crack_damage in the simulation could be greater than 1 or less than 0, I wonder what causes the issue since I update it in the material object only and constrain its value, thanks!\nvoid\nElkComputeSmearedCrackingStressModifiedMazars::computeQpStress()\n{\n  bool force_elasticity_rotation = false;\n\n  //get nonlocal equivalent strain\n  Real eqstrain_nonlocal = 0.0; \n\n  //Switch between local or nonlocal model\n  switch (_model_type)\n  {\n    case ModelType::LOCAL:\n      eqstrain_nonlocal = _eqstrain_local_old[_qp];\n      break;\n\n    case ModelType::NONLOCAL:\n      eqstrain_nonlocal = _eqstrain_nonlocal[_qp];\n      break;\n  }\n\n  // Ensure nonlocal equivalent strain is non-negative\n  eqstrain_nonlocal = std::max(eqstrain_nonlocal, 0.0);\n\n  //get strain at onset of strength criterion\n  const Real youngs_modulus =\n  ElasticityTensorTools::getIsotropicYoungsModulus(_elasticity_tensor[_qp]);\n  Real cracking_strain = _cracking_stress[_qp] / youngs_modulus;\n\n  //get flag: meet criterion\n  const bool meet_criterion = (eqstrain_nonlocal > cracking_strain);\n\n  //get flag: keep loading\n  const bool loading_existing_crack = (eqstrain_nonlocal > _eqstrain_max_old[_qp]);\n\n  //get flag: pre-existing crack\n  const bool pre_existing_crack = (_crack_damage_old[_qp] > 0.0);\n\n  //if (new crack) or (loading on pre-existing)\n  if ((meet_criterion && !pre_existing_crack) || (loading_existing_crack && pre_existing_crack)){\n\n    // const Real exp_term = std::exp(_paramB * (eqstrain_nonlocal - cracking_strain));\n\n    //update damage variable\n    // Real crack_damage = 1.0\n    //                   - cracking_strain * ( 1.0 - _paramA ) / eqstrain_nonlocal \n    //                   - _paramA / exp_term;\n\n    Real crack_damage = 1.0 - cracking_strain / eqstrain_nonlocal * std::exp(-(eqstrain_nonlocal - cracking_strain)/(0.25*cracking_strain));\n    \n    // Ensure damage stays within [0,1]\n    crack_damage = std::min(std::max(crack_damage, 0.0), 1.0);\n    \n    // Enforce non-decreasing damage\n    _crack_damage[_qp] = std::max(_crack_damage_old[_qp], crack_damage);\n\n  }\n  //else\n  else{\n\n    //keep damage variable as it is\n    _crack_damage[_qp] = _crack_damage_old[_qp];\n\n  }\n\n  //constrain damage variable ScalarDamageBase.C\n  _crack_damage[_qp] = std::min(std::max(_crack_damage[_qp], 0.0), 1.0);\n\n  if (MooseUtils::absoluteFuzzyLessThan(_crack_damage[_qp], 0.0) ||\n        MooseUtils::absoluteFuzzyGreaterThan(_crack_damage[_qp], 1.0))\n      mooseError(_base_name + \"damage_index \",\n                \"must be between 0 and 1. Current value is: \",\n                _crack_damage[_qp]);  \n\n  //update elasticity tensor\n  updateLocalElasticityTensor();\n\n  //update strain tensor\n  _elastic_strain[_qp] = _elastic_strain_old[_qp] + _strain_increment[_qp];\n\n  //update stress tensor\n  // if (_crack_damage[_qp] == 1.0){\n  //   _stress[_qp] = 1e-8 * _elastic_strain[_qp];\n  // }\n  // else{\n    _stress[_qp] = _local_elasticity_tensor * _elastic_strain[_qp];\n  // }\n\n  //update maximum equivalent strain\n  Real eqstrain_max = std::max(_eqstrain_max_old[_qp], eqstrain_nonlocal);\n  _eqstrain_max[_qp] = eqstrain_max;\n\n  //update equivalent strain \n  RealVectorValue strain_in_crack_dir;\n  computeCrackStrainAndOrientation(strain_in_crack_dir);\n  Real strain_dir0_positive = std::max(strain_in_crack_dir(0), 0.0);\n  Real strain_dir1_positive = std::max(strain_in_crack_dir(1), 0.0);\n  Real strain_dir2_positive = std::max(strain_in_crack_dir(2), 0.0);\n  Real eqstrain_local = std::sqrt(strain_dir0_positive*strain_dir0_positive+strain_dir1_positive*strain_dir1_positive+strain_dir2_positive*strain_dir2_positive);\n  _eqstrain_local[_qp] = eqstrain_local;\n\n  //update jacobian\n  _Jacobian_mult[_qp] = _local_elasticity_tensor;\n  force_elasticity_rotation = true;\n\n  if (_perform_finite_strain_rotations)\n  {\n    finiteStrainRotation(force_elasticity_rotation);\n    _crack_rotation[_qp] = _rotation_increment[_qp] * _crack_rotation[_qp];\n  }\n}",
          "url": "https://github.com/idaholab/moose/discussions/29073",
          "updatedAt": "2024-11-14T18:07:09Z",
          "publishedAt": "2024-11-14T04:56:30Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "However, the crack_damage in the simulation could be greater than 1 or less than 0\n\nAre you seeing that from the material property output? Or from min/max postprocessors?",
                  "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11254292",
                  "updatedAt": "2024-11-14T13:23:07Z",
                  "publishedAt": "2024-11-14T13:23:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi @GiudGiud, previously I'm visualizing the damage in paraview (material property output), I checked the postprocesser, it appears to have the same value (less than 0), I had a hard time trying a lot of options but no luck so far.\nPostprocessor Values:\n+----------------+----------------+----------------+\n| time           | max_damage     | min_damage     |\n+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n|   2.000000e-07 |   0.000000e+00 |   0.000000e+00 |\n|   4.000000e-07 |   8.596478e-01 |   0.000000e+00 |\n|   6.000000e-07 |   9.938583e-01 |   0.000000e+00 |\n|   8.000000e-07 |   9.998492e-01 |  -9.171160e-03 |\n|   1.000000e-06 |   9.999994e-01 |   0.000000e+00 |\n|   1.200000e-06 |   1.000000e+00 |  -8.715458e-02 |\n|   1.400000e-06 |   1.000000e+00 |  -8.715458e-02 |\n|   1.600000e-06 |   1.000000e+00 |  -7.931467e-01 |\n|   1.800000e-06 |   1.000000e+00 |  -7.999849e-01 |\n|   2.000000e-06 |   1.070128e+00 |  -7.999849e-01 |\n|   2.200000e-06 |   1.091257e+00 |  -7.999849e-01 |\n|   2.400000e-06 |   1.008070e+00 |  -7.999849e-01 |\n|   2.600000e-06 |   1.008070e+00 |  -7.999849e-01 |\n|   2.800000e-06 |   1.008070e+00 |  -8.000000e-01 |\n+----------------+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11256424",
                          "updatedAt": "2024-11-14T15:54:37Z",
                          "publishedAt": "2024-11-14T15:53:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "I also attach the input file here:\n[Mesh]\n    [./msh]\n        type = FileMeshGenerator\n        file =  '../../mesh/uniform_mesh/cylinder_uniform_short.msh'\n    []\n    displacements = 'disp_x disp_y disp_z'\n[]\n\n[GlobalParams]\n    displacements = 'disp_x disp_y disp_z'\n[]\n\n[Variables]\n    [disp_x]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [disp_y]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [disp_z]\n        order = FIRST\n        family = LAGRANGE\n    []\n[]\n\n[AuxVariables]\n    [vel_x]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [accel_x]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [vel_y]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [accel_y]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [vel_z]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [accel_z]\n        order = FIRST\n        family = LAGRANGE\n    []\n    [./strength]\n        order = CONSTANT\n        family = MONOMIAL\n    [../]\n[]\n\n[Functions]\n    [func_tri_pulse]\n        type = ElkPulseLoadExp\n        peak_magnitude = 30e6\n        single_pulse_duration = 10\n        number_of_pulses = 5\n    []\n[]\n\n[Kernels]\n    [dispkernel_x]\n        type = DynamicStressDivergenceTensors\n        displacements = 'disp_x disp_y disp_z'\n        variable = disp_x\n        component = 0\n        use_displaced_mesh = true\n    []\n    [dispkernel_y]\n        type = DynamicStressDivergenceTensors\n        displacements = 'disp_x disp_y disp_z'\n        variable = disp_y\n        component = 1\n        use_displaced_mesh = true\n    []\n    [dispkernel_z]\n        type = DynamicStressDivergenceTensors\n        displacements = 'disp_x disp_y disp_z'\n        variable = disp_z\n        component = 2\n        use_displaced_mesh = true\n    []\n    [inertia_x]\n        type = InertialForce\n        variable = disp_x\n        velocity = vel_x\n        acceleration = accel_x\n        beta = 0.25\n        gamma = 0.5\n        use_displaced_mesh = true\n    []\n    [inertia_y]\n        type = InertialForce\n        variable = disp_y\n        velocity = vel_y\n        acceleration = accel_y\n        beta = 0.25\n        gamma = 0.5\n        use_displaced_mesh = true\n    []\n    [inertia_z]\n        type = InertialForce\n        variable = disp_z\n        velocity = vel_z\n        acceleration = accel_z\n        beta = 0.25\n        gamma = 0.5\n        use_displaced_mesh = true\n    []\n[]\n\n[AuxKernels]\n    [accel_x]\n        type = NewmarkAccelAux\n        variable = accel_x\n        displacement = disp_x\n        velocity = vel_x\n        beta = 0.25\n        execute_on = timestep_end\n    []\n    [vel_x]\n        type = NewmarkVelAux\n        variable = vel_x\n        acceleration = accel_x\n        gamma = 0.5\n        execute_on = timestep_end\n    []\n    [accel_y]\n        type = NewmarkAccelAux\n        variable = accel_y\n        displacement = disp_y\n        velocity = vel_y\n        beta = 0.25\n        execute_on = timestep_end\n    []\n    [vel_y]\n        type = NewmarkVelAux\n        variable = vel_y\n        acceleration = accel_y\n        gamma = 0.5\n        execute_on = timestep_end\n    []\n    [accel_z]\n        type = NewmarkAccelAux\n        variable = accel_z\n        displacement = disp_z\n        velocity = vel_z\n        beta = 0.25\n        execute_on = timestep_end\n    []\n    [vel_z]\n        type = NewmarkVelAux\n        variable = vel_z\n        acceleration = accel_z\n        gamma = 0.5\n        execute_on = timestep_end\n    []\n[]\n\n[BCs]\n    [./Pressure]\n        [pulsepower_load]\n            boundary = 4\n            function = func_tri_pulse\n            displacements = 'disp_x disp_y'\n        []\n    []\n[]\n\n#this user object must contain for porous flow\n[UserObjects]\n    #length_scale = 0.027 #2.7 times maximum aggregate size for granite\n    #radius = 2 * length_scale\n    [eqstrain_averaging]\n        type = ElkRadialAverage\n        length_scale = 0.0005\n        prop_name = eqstrain_local\n        radius = 0.0005\n        weights = BAZANT\n        execute_on = LINEAR\n        # force_preaux = true\n    []\n[]\n\n[Materials]\n    [./elasticity_tensor]\n        type = ComputeIsotropicElasticityTensor\n        youngs_modulus = 40e9\n        poissons_ratio = 0.25\n    [../]\n    [./elastic_stress]\n        type = ElkComputeSmearedCrackingStressModifiedMazars\n        cracking_stress = strength\n        # paramA = 0.99\n        # paramB = 10000\n        model = 'NONLOCAL'\n        output_properties = 'crack_damage stress eqstrain_local'\n        outputs = nemesis\n    [../]\n    [strain]\n        type = ComputeFiniteStrain\n        displacements = 'disp_x disp_y disp_z'\n    []\n    [density]\n        type = GenericConstantMaterial\n        prop_names = 'density'\n        prop_values = '2600'\n    []\n    [nonlocal_eqstrain]\n        type = ElkNonlocalEqstrain\n        average_UO = eqstrain_averaging\n        output_properties = 'eqstrain_nonlocal'\n        outputs = nemesis\n    []\n[]\n\n[Preconditioning]\n    [smp]\n    type = SMP\n    full = true\n    []\n[]\n\n[Distributions]\n    #typically for granite\n    #Shape Parameter (k): 5 to 15, commonly around 8 to 12.\n    #Scale Parameter (\u03bb): 5 to 30 MPa, commonly around 10 to 20 MPa.\n    [weibull]\n      type = Weibull\n      shape = 12.0 #k\n      scale = 20e6 #lambda\n      location = 0 \n    []\n  [] \n\n[ICs]\n    # [./strength]\n    #   type = VolumeWeightedWeibull\n    #   variable = strength\n    #   reference_volume = 1e-7\n    #   weibull_modulus = 12.0\n    #   median = 30e6\n    # [../]\n    [./strength]\n        type =  RandomIC\n        variable = strength\n        distribution = weibull\n    []\n[]\n\n[Postprocessors]\n    [./max_damage]\n        type = ElementExtremeValue\n        variable = crack_damage\n        value_type = max\n    []\n    [./min_damage]\n        type = ElementExtremeValue\n        variable = crack_damage\n        value_type = min\n    []    \n[]\n\n[Executioner]\n    type = Transient\n    solve_type = Newton\n    petsc_options_iname = '-ksp_gmres_restart -pc_type -sub_pc_type'\n    petsc_options_value = '101                asm      lu'\n\n    line_search = 'none'\n    # num_steps = 1\n    l_max_its = 100\n    nl_max_its = 10\n    nl_rel_tol = 1e-8\n    nl_abs_tol = 1e-8\n    l_tol = 1e-5\n    start_time = 0.0\n    end_time = 30e-6\n    dt = 1e-8\n    [./TimeIntegrator]\n        type = NewmarkBeta\n        beta = 0.25\n        gamma = 0.5\n    [../]\n[]\n\n[Outputs]\n    exodus = false\n    nemesis = true\n    time_step_interval = 20\n    csv = true\n[]\n\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#pragma once\n\n#include \"ColumnMajorMatrix.h\"\n#include \"ComputeMultipleInelasticStress.h\"\n#include \"SmearedCrackSofteningBase.h\"\n#include \"Function.h\"\n\n/*\nElk Compute Smeared Cracking Stress Model\nCreated by Chunhui Zhao, Oct 15th, 2024\nRewrite the smeared crack model, add energy regularization\nRegularization takes place on equivalent strain\n\n- Pure Solid Mechanics\n- Take regularizated equivalent strain as input\n\n*/\n\n/**\n * ElkComputeSmearedCrackingStressModifiedMazars computes the stress for a finite strain\n * material with smeared cracking\n */\nclass ElkComputeSmearedCrackingStressModifiedMazars : public ComputeMultipleInelasticStress\n{\npublic:\n  static InputParameters validParams();\n\n  ElkComputeSmearedCrackingStressModifiedMazars(const InputParameters & parameters);\n\n  virtual void initQpStatefulProperties() override;\n  virtual void computeQpStress() override;\n\nprotected:\n\n  /**\n   * Compute the crack strain in the crack coordinate system. Also\n   * computes the crack orientations, and stores in _crack_rotation.\n   * @param strain_in_crack_dir Computed strains in crack directions\n   */\n  void computeCrackStrainAndOrientation(RealVectorValue & strain_in_crack_dir);\n\n  /**\n   * Update the local elasticity tensor (_local_elasticity_tensor)\n   * due to the effects of cracking.\n   */\n  void updateLocalElasticityTensor();\n\n  ///@{ Input parameters for smeared crack models\n\n  /// Threshold at which cracking initiates if tensile stress exceeds it\n  const VariableValue & _cracking_stress;\n\n  //@{ Damage (goes from 0 to 1) in crack directions\n  //Damage is treated as a scalar variable\n  MaterialProperty<Real> & _crack_damage;\n  const MaterialProperty<Real> & _crack_damage_old;\n  ///@}\n\n  /// Nonlocal equivalent strain value\n  const MaterialProperty<Real> & _eqstrain_nonlocal;\n\n  ///@{local equivalent strain value\n  MaterialProperty<Real> & _eqstrain_local;\n  const MaterialProperty<Real> & _eqstrain_local_old;\n  ///@}\n\n  ///@{maximum equivalent strain value\n  MaterialProperty<Real> & _eqstrain_max;\n  const MaterialProperty<Real> & _eqstrain_max_old;\n  ///@}\n\n  //@{ Rotation tensor used to rotate tensors into crack local coordinates\n  MaterialProperty<RankTwoTensor> & _crack_rotation;\n  const MaterialProperty<RankTwoTensor> & _crack_rotation_old;\n  ///@}\n\n  ///@{parameters for damage evolution law\n  Real _paramA;\n  Real _paramB;\n  ///@}\n\n  //@{ Variables used by multiple methods within the calculation for a single material point\n  RankFourTensor _local_elasticity_tensor;\n  /// Vector helper to update local elasticity tensor\n  std::vector<Real> _local_elastic_vector;\n  ///@}\n\n  /// the model type\n  enum class ModelType\n  {\n    LOCAL,\n    NONLOCAL\n  } _model_type;\n\n};\n\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n/*\nElk Compute Smeared Cracking Stress Model\nCreated by Chunhui Zhao, Oct 15th, 2024\nRewrite the smeared crack model, add energy regularization\nRegularization takes place on equvalent strain\n\n- Pure Solid Mechanics\n- Take regularizated equvalent strain as input\n\n*/\n\n#include \"ElkComputeSmearedCrackingStressModifiedMazars.h\"\n#include \"ElasticityTensorTools.h\"\n#include \"StressUpdateBase.h\"\n#include \"Conversion.h\"\n\nregisterMooseObject(\"elkApp\", ElkComputeSmearedCrackingStressModifiedMazars);\n\nInputParameters\nElkComputeSmearedCrackingStressModifiedMazars::validParams()\n{\n  InputParameters params = ComputeMultipleInelasticStress::validParams();\n  params.addClassDescription(\"Compute stress using a fixed smeared cracking model\");\n  params.addRequiredCoupledVar(\n      \"cracking_stress\",\n      \"The stress threshold beyond which cracking occurs. Negative values prevent cracking.\");\n  params.addRequiredParam<Real>(\"paramA\", \"parameter used in the damage evolution law\");\n  params.addRequiredParam<Real>(\"paramB\", \"parameter used in the damage evolution law\");\n  params.set<std::vector<MaterialName>>(\"inelastic_models\") = {};\n  MooseEnum model_type(\"local nonlocal\");\n  params.addRequiredParam<MooseEnum>(\"model\", model_type, \"Model type: LOCAL or NONLOCAL\");\n  return params;\n}\n\nElkComputeSmearedCrackingStressModifiedMazars::ElkComputeSmearedCrackingStressModifiedMazars(const InputParameters & parameters)\n  : ComputeMultipleInelasticStress(parameters),\n    _cracking_stress(coupledValue(\"cracking_stress\")),\n    _crack_damage(declareProperty<Real>(_base_name + \"crack_damage\")),\n    _crack_damage_old(getMaterialPropertyOld<Real>(_base_name + \"crack_damage\")),\n    _eqstrain_nonlocal(getMaterialProperty<Real>(\"eqstrain_nonlocal\")),\n    _eqstrain_local(declareProperty<Real>(\"eqstrain_local\")),\n    _eqstrain_local_old(getMaterialPropertyOld<Real>(\"eqstrain_local\")),\n    _eqstrain_max(declareProperty<Real>(\"eqstrain_max\")),\n    _eqstrain_max_old(getMaterialPropertyOld<Real>(\"eqstrain_max\")),\n    _crack_rotation(declareProperty<RankTwoTensor>(_base_name + \"crack_rotation\")),\n    _crack_rotation_old(getMaterialPropertyOld<RankTwoTensor>(_base_name + \"crack_rotation\")),\n    _paramA(getParam<Real>(\"paramA\")),\n    _paramB(getParam<Real>(\"paramB\")),\n    _model_type(getParam<MooseEnum>(\"model\").getEnum<ModelType>())\n{\n}\n\nvoid\nElkComputeSmearedCrackingStressModifiedMazars::initQpStatefulProperties()\n{\n  _crack_damage[_qp] = 0.0;\n  _eqstrain_local[_qp] = 0.0;\n  _eqstrain_max[_qp] = 0.0;\n  _crack_rotation[_qp] = RankTwoTensor::Identity();\n}\n\nvoid\nElkComputeSmearedCrackingStressModifiedMazars::computeQpStress()\n{\n  bool force_elasticity_rotation = false;\n\n  //get nonlocal equivalent strain\n  Real eqstrain_nonlocal = 0.0; \n\n  //Switch between local or nonlocal model\n  switch (_model_type)\n  {\n    case ModelType::LOCAL:\n      eqstrain_nonlocal = _eqstrain_local_old[_qp];\n      break;\n\n    case ModelType::NONLOCAL:\n      eqstrain_nonlocal = _eqstrain_nonlocal[_qp];\n      break;\n  }\n\n  // Ensure nonlocal equivalent strain is non-negative\n  eqstrain_nonlocal = std::max(eqstrain_nonlocal, 0.0);\n\n  //get strain at onset of strength criterion\n  const Real youngs_modulus =\n  ElasticityTensorTools::getIsotropicYoungsModulus(_elasticity_tensor[_qp]);\n  Real cracking_strain = _cracking_stress[_qp] / youngs_modulus;\n\n  //get flag: meet criterion\n  const bool meet_criterion = (eqstrain_nonlocal > cracking_strain);\n\n  //get flag: keep loading\n  const bool loading_existing_crack = (eqstrain_nonlocal > _eqstrain_max_old[_qp]);\n\n  //get flag: pre-existing crack\n  const bool pre_existing_crack = (_crack_damage_old[_qp] > 0.0);\n\n  //if (new crack) or (loading on pre-existing)\n  if ((meet_criterion && !pre_existing_crack) || (loading_existing_crack && pre_existing_crack)){\n\n    // const Real exp_term = std::exp(_paramB * (eqstrain_nonlocal - cracking_strain));\n\n    //update damage variable\n    // Real crack_damage = 1.0\n    //                   - cracking_strain * ( 1.0 - _paramA ) / eqstrain_nonlocal \n    //                   - _paramA / exp_term;\n\n    Real crack_damage = 1.0 - cracking_strain / eqstrain_nonlocal * std::exp(-(eqstrain_nonlocal - cracking_strain)/(0.25*cracking_strain));\n    \n    // Ensure damage stays within [0,1]\n    crack_damage = std::min(std::max(crack_damage, 0.0), 1.0);\n    \n    // Enforce non-decreasing damage\n    _crack_damage[_qp] = std::max(_crack_damage_old[_qp], crack_damage);\n\n  }\n  //else\n  else{\n\n    //keep damage variable as it is\n    _crack_damage[_qp] = _crack_damage_old[_qp];\n\n  }\n\n  //constrain damage variable ScalarDamageBase.C\n  _crack_damage[_qp] = std::min(std::max(_crack_damage[_qp], 0.0), 1.0);\n\n  if (MooseUtils::absoluteFuzzyLessThan(_crack_damage[_qp], 0.0) ||\n        MooseUtils::absoluteFuzzyGreaterThan(_crack_damage[_qp], 1.0))\n      mooseError(_base_name + \"damage_index \",\n                \"must be between 0 and 1. Current value is: \",\n                _crack_damage[_qp]);  \n\n  //update elasticity tensor\n  updateLocalElasticityTensor();\n\n  //update strain tensor\n  _elastic_strain[_qp] = _elastic_strain_old[_qp] + _strain_increment[_qp];\n\n  //update stress tensor\n  // if (_crack_damage[_qp] == 1.0){\n  //   _stress[_qp] = 1e-8 * _elastic_strain[_qp];\n  // }\n  // else{\n    _stress[_qp] = _local_elasticity_tensor * _elastic_strain[_qp];\n  // }\n\n  //update maximum equivalent strain\n  Real eqstrain_max = std::max(_eqstrain_max_old[_qp], eqstrain_nonlocal);\n  _eqstrain_max[_qp] = eqstrain_max;\n\n  //update equivalent strain \n  RealVectorValue strain_in_crack_dir;\n  computeCrackStrainAndOrientation(strain_in_crack_dir);\n  Real strain_dir0_positive = std::max(strain_in_crack_dir(0), 0.0);\n  Real strain_dir1_positive = std::max(strain_in_crack_dir(1), 0.0);\n  Real strain_dir2_positive = std::max(strain_in_crack_dir(2), 0.0);\n  Real eqstrain_local = std::sqrt(strain_dir0_positive*strain_dir0_positive+strain_dir1_positive*strain_dir1_positive+strain_dir2_positive*strain_dir2_positive);\n  _eqstrain_local[_qp] = eqstrain_local;\n\n  //update jacobian\n  _Jacobian_mult[_qp] = _local_elasticity_tensor;\n  force_elasticity_rotation = true;\n\n  if (_perform_finite_strain_rotations)\n  {\n    finiteStrainRotation(force_elasticity_rotation);\n    _crack_rotation[_qp] = _rotation_increment[_qp] * _crack_rotation[_qp];\n  }\n}\n\nvoid\nElkComputeSmearedCrackingStressModifiedMazars::computeCrackStrainAndOrientation(\n    RealVectorValue & strain_in_crack_dir)\n{\n  // The rotation tensor is ordered such that directions for pre-existing cracks appear first\n  // in the list of columns.  For example, if there is one existing crack, its direction is in the\n  // first column in the rotation tensor.\n\n  std::vector<Real> eigval(3, 0.0);\n  RankTwoTensor eigvec;\n\n  _elastic_strain[_qp].symmetricEigenvaluesEigenvectors(eigval, eigvec);\n\n  // If the elastic strain is beyond the cracking strain, save the eigen vectors as\n  // the rotation tensor. Reverse their order so that the third principal strain\n  // (most tensile) will correspond to the first crack.\n  _crack_rotation[_qp].fillColumn(0, eigvec.column(2));\n  _crack_rotation[_qp].fillColumn(1, eigvec.column(1));\n  _crack_rotation[_qp].fillColumn(2, eigvec.column(0));\n\n  strain_in_crack_dir(0) = eigval[2];\n  strain_in_crack_dir(1) = eigval[1];\n  strain_in_crack_dir(2) = eigval[0];\n}\n\nvoid\nElkComputeSmearedCrackingStressModifiedMazars::updateLocalElasticityTensor()\n{\n  RealVectorValue stiffness_ratio_local(1.0, 1.0, 1.0);\n  _local_elastic_vector.resize(9);\n  const RankTwoTensor & R = _crack_rotation_old[_qp];\n  RankTwoTensor ePrime(_elastic_strain_old[_qp]);\n  ePrime.rotate(R.transpose());\n\n  /*\n  ePrime: pricipal elastic strain \n  stiffness_ratio_local: a stiffness reduction factor that is used to modify _elasticity_tensor\n  _cracking_neg_fraction: The fraction of the cracking strain at which a transition begins during decreasing strain to the original stiffness.\n  */\n  for (unsigned int i = 0; i < 3; ++i)\n  {\n    /*\n    absoluteFuzzyLessThan: Function to check whether a variable is less than another variable within an absolute tolerance\n    return true if var1 < var2 and var1 != var2 within tol\n    absoluteFuzzyLessThan(ePrime(i, i), 0.0): compare whether ePrime(i, i) < 0.0\n    This criterion represents all prinicipal strains are compressive, restore the elasticity\n    */\n    if (MooseUtils::absoluteFuzzyLessThan(ePrime(i, i), 0.0)){\n      stiffness_ratio_local(i) = 1.0;\n    }\n    else\n    {\n      if ( ePrime(i, i) > 0 ){ //the degradation of stiffness along this direction only active if the principal strain along this direction is positive\n        Real crack_damage_along_this_dir = _crack_damage_old[_qp] * ePrime(i, i) / _eqstrain_local_old[_qp];\n        stiffness_ratio_local(i) = (1.0 - crack_damage_along_this_dir);\n      }\n      else{ //else, restore the stiffness considering crack closure effect\n        stiffness_ratio_local(i) = 1.0;\n      }\n    }\n\n    //add a bound on stiffness ratio local\n    stiffness_ratio_local(i) = std::max(1e-8, stiffness_ratio_local(i));\n\n  }\n\n    \n  const Real & c0 = stiffness_ratio_local(0);\n  const Real & c1 = stiffness_ratio_local(1);\n  const Real & c2 = stiffness_ratio_local(2);\n\n  const Real c01 = c0 * c1;\n  const Real c02 = c0 * c2;\n  const Real c12 = c1 * c2;\n\n  const Real c01_shear_retention = std::max(c01, 0.0);\n  const Real c02_shear_retention = std::max(c02, 0.0);\n  const Real c12_shear_retention = std::max(c12, 0.0);\n\n  _local_elastic_vector[0] = _elasticity_tensor[_qp](0, 0, 0, 0) * c0;\n  _local_elastic_vector[1] = _elasticity_tensor[_qp](0, 0, 1, 1) * c01;\n  _local_elastic_vector[2] = _elasticity_tensor[_qp](0, 0, 2, 2) * c02;\n  _local_elastic_vector[3] = _elasticity_tensor[_qp](1, 1, 1, 1) * c1;\n  _local_elastic_vector[4] = _elasticity_tensor[_qp](1, 1, 2, 2) * c12;\n  _local_elastic_vector[5] = _elasticity_tensor[_qp](2, 2, 2, 2) * c2;\n  _local_elastic_vector[6] = _elasticity_tensor[_qp](1, 2, 1, 2) * c12_shear_retention;\n  _local_elastic_vector[7] = _elasticity_tensor[_qp](0, 2, 0, 2) * c02_shear_retention;\n  _local_elastic_vector[8] = _elasticity_tensor[_qp](0, 1, 0, 1) * c01_shear_retention;\n\n  // Filling with 9 components is sufficient because these are the only nonzero entries\n  // for isotropic or orthotropic materials.\n  _local_elasticity_tensor.fillFromInputVector(_local_elastic_vector,\n                                                RankFourTensor::symmetric9);\n\n  // Rotate the modified elasticity tensor back into global coordinates\n  _local_elasticity_tensor.rotate(R);\n\n}",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11256471",
                          "updatedAt": "2024-11-14T15:58:03Z",
                          "publishedAt": "2024-11-14T15:58:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "do you ever see this warning?\n  if (MooseUtils::absoluteFuzzyLessThan(_crack_damage[_qp], 0.0) ||\n        MooseUtils::absoluteFuzzyGreaterThan(_crack_damage[_qp], 1.0))\n      mooseError(_base_name + \"damage_index \",\n                \"must be between 0 and 1. Current value is: \",\n                _crack_damage[_qp]); \n\nyou are looking the variable (which imo should be within the bounds of the property, but maybe not?), not the material property",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11256633",
                          "updatedAt": "2024-11-14T16:11:22Z",
                          "publishedAt": "2024-11-14T16:11:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi @GiudGiud, no I didn't see this warning at all (mooseError should stop the simulation), which makes me confused as well, I wonder is there a way to debug such issue",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11256690",
                          "updatedAt": "2024-11-14T16:16:22Z",
                          "publishedAt": "2024-11-14T16:16:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Very odd indeed then.\nI m going to blame it on the projection to the variable then.\nIf you can reduce the problem to a simpler case still showing the issue, let's create an issue and investigate the reduced case",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11256877",
                          "updatedAt": "2024-11-14T16:36:14Z",
                          "publishedAt": "2024-11-14T16:36:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi @GiudGiud, thanks for your help! Yes I was able to reproduce the issue in a mini-example, I have created the issue ticket #29080, it should be able to reproduce the same error within minute. I will be really appreciated if you or other experts from material system group could take a look at it, it is a fairly simple and commonly used technique in continuum damage model community, thanks a lot!",
                          "url": "https://github.com/idaholab/moose/discussions/29073#discussioncomment-11258118",
                          "updatedAt": "2024-11-14T18:07:41Z",
                          "publishedAt": "2024-11-14T18:07:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Some questions about the use of pump components and gas properties",
          "author": {
            "login": "LGQ199810"
          },
          "bodyText": "Hello, I am currently conducting calculations for a heat exchange circuit based on thermal hydraulic modules (the node diagram of the circuit is shown in the attached figure). During the calculation process, I found that the temperature difference between the pump components before and after exceeded a reasonable range, and the temperature difference between the pump components can reach about 50 \u2103. Is there any adjustment method to reduce or even eliminate this difference.\nIn addition, in my previous calculations, when I used a custom gas property code, the cooling capacity of the cooling system col_sys was not as high as expected. After inspection, it was found that the reason was that the thermal conductivity calculated through my own code (about 0.033W/m \u00b7 K) was lower than the constant value given by the ideal gas property package (about 0.041W/m \u00b7 K). However, the thermal conductivity calculated by my own developed property code matched well with the properties in the REFPROP property package. Is there any way to solve this problem.\n\nthe pump component used in my model\n` [pump]\ntype = Pump1Phase\nposition = '-${col_connect} 0 -${fparse 2 * col_length2}'\nconnections = 'col_sys/gcol_connect:out up_pipe:in'\nvolume = 1e-4\nA_ref = '${fparse pi * col_gas_dia * col_gas_dia / 4.}'\nhead = 5.\n\n[]\n`",
          "url": "https://github.com/idaholab/moose/discussions/29053",
          "updatedAt": "2024-11-14T17:03:17Z",
          "publishedAt": "2024-11-12T13:45:46Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Which fluid properties are you currently using?\n@joshuahansel",
                  "url": "https://github.com/idaholab/moose/discussions/29053#discussioncomment-11227700",
                  "updatedAt": "2024-11-12T14:54:55Z",
                  "publishedAt": "2024-11-12T14:54:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "LGQ199810"
                          },
                          "bodyText": "The working fluid gas I am currently using is argon\uff0cand the input card I'm using as followed\npump_test-upload.txt",
                          "url": "https://github.com/idaholab/moose/discussions/29053#discussioncomment-11227817",
                          "updatedAt": "2024-11-12T15:04:57Z",
                          "publishedAt": "2024-11-12T15:04:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "You mention \"pumps\". I see only one pump in your diagram. Do you just mean the difference across the one pump? Have you checked that the pressure change across your pump matches your supplied head value of 5 m? Remember that dp = density*g*head. Other pump formulation options for you are:\n\nhttps://mooseframework.inl.gov/source/components/ShaftConnectedPump1Phase.html\nhttps://mooseframework.inl.gov/source/components/ShaftConnectedCompressor1Phase.html\n\nbut these will be a bit more involved because you must specify performance curves and include a Shaft component (and other component(s)) on the shaft to power the pump. The one you are using is the simplest one, if you just want to match a certain pressure rise.\nRegarding your thermal conductivity, you specified the value of 0.04071 W/(m-K) in your input file - you can change k to your desired value of 0.033 W/(m-K). That equation of state corresponds to an ideal gas formulation, which says nothing about transport properties like conductivity and viscosity, so the user must supply those, and they cannot have temperature dependence (though developers could change that part at some point). As far as I know, we do not have any specialized properties for argon, so you would need to implement your own FluidProperties class if you want something more accurate than the ideal gas equation of state.",
                  "url": "https://github.com/idaholab/moose/discussions/29053#discussioncomment-11229008",
                  "updatedAt": "2024-11-12T16:30:48Z",
                  "publishedAt": "2024-11-12T16:30:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "LGQ199810"
                          },
                          "bodyText": "Thank you very much for providing the verification idea. Currently, I only use a single pump component to drive the gas in the circuit, so that the gas can flow and exchange heat in the circuit at a specific flow rate. I have not considered the shaft and other components. This is similar to the setting of pump components in the single_phase_flow chapter of the thermal hydraulic module tutorial. However, in my current circuit, the temperature difference between the pump components can reach about 50 \u2103 (the temperature of col_stys/gcol_comnect: out is about 300K, and the temperature of uo_pipe: in is about 346K), which is contrary to common sense.\nIn addition, I have calculated the pressure difference before and after the pump, which is about 9.35e4 Pa. However, at this time, I have set the pump head to 0.0 m. There are also some issues with this calculation result that need to be corrected, so I would like to ask how to correct these two problems. Thank you very much.",
                          "url": "https://github.com/idaholab/moose/discussions/29053#discussioncomment-11234954",
                          "updatedAt": "2024-11-13T03:59:45Z",
                          "publishedAt": "2024-11-13T03:59:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "You say\n\nHowever, at this time, I have set the pump head to 0.0 m\n\nI don't know if you've changed your input file since, but in the one you attached, you're using a PID control to control the head parameter of the pump. And it appears that the PID controller is functioning correctly, and you've achieved the target mass flow rate. I ran your input, and it seems the head input signal to the pump is 850 m. For the pressure rise that you have across the pump, I am not convinced that a ~50 K difference is unreasonable. The pump pressure rise does not match this head (although it's quite a bit closer), but this is a compressible fluid, so I wouldn't necessarily expect it.",
                          "url": "https://github.com/idaholab/moose/discussions/29053#discussioncomment-11240869",
                          "updatedAt": "2024-11-13T14:17:45Z",
                          "publishedAt": "2024-11-13T14:17:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LGQ199810"
                          },
                          "bodyText": "I am very sorry for not stating in the previous question that I changed the head parameter filled in the pump component in the attachment input card from 5.0 to 0.0, but this seems to have no impact on the calculation results.\nMeanwhile, in the previous calculations, I set the parameters of the pump to be completely consistent with the PID control of the pump in the single_phase_flow chapter of the thermal hydraulic module tutorial, and found that the pump components needed to be calculated for over 10000 seconds to achieve the desired loop flow rate. Is it necessary to adjust the PID parameters accordingly because the pressure and working fluid of the circuit I calculated are different from those in the tutorial.\nIn addition, in the circuit I am currently calculating, how to reduce the pressure head value of the pump to reduce the pressure changes at the inlet and outlet of the pump? I just want to achieve forced circulation of gas in the circuit, and do not need the boost provided by the pump; Also, if possible, could you teach me how to display the real-time head parameter of the pump in the output? Thank you very much.",
                          "url": "https://github.com/idaholab/moose/discussions/29053#discussioncomment-11241486",
                          "updatedAt": "2024-11-13T14:52:18Z",
                          "publishedAt": "2024-11-13T14:52:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Is it necessary to adjust the PID parameters\n\nI recommend that you select your own. Unfortunately, it's a bit of trial and error. The coefficients in that tutorial may not work well for your situation. By the way, I usually set the derivative coefficient to 0.\n\nhow to reduce the pressure head value of the pump to reduce the pressure changes at the inlet and outlet of the pump?\n\nFor a given mass flow rate, you would need to examine the pressure drops in the rest of the system. The pump head will need to counteract those.\n\nI just want to achieve forced circulation of gas in the circuit, and do not need the boost provided by the pump\n\nI don't understand. To me, \"forced circulation\" means that you require the boost provided by the pump. Otherwise you rely on natural convection effects.\n\nhow to display the real-time head parameter of the pump in the output?\n\n  [pump_head]\n    type = RealControlDataValuePostprocessor\n    control_data_name = pid:output\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/29053#discussioncomment-11244124",
                          "updatedAt": "2024-11-13T18:01:31Z",
                          "publishedAt": "2024-11-13T18:01:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LGQ199810"
                          },
                          "bodyText": "Thank you very much for your previous answer. I have indeed fallen into a common sense misconception, which is to consider driving gas flow and boosting gas separately. I have checked the main pressure drop in my circuit and would like to ask you the following questions:\n\n\nIn my circuit, the flow area of the pipes is not consistent, and there may be a situation as shown in the figure below (this is a part of my calculation of the circuit, which is similar to the previous node diagram and uses a pump for driving), where the middle pipe is thin (with a diameter of 16mm) and the two sides of the pipe are thick (with a diameter of 30mm). However, the pressure drop in these areas is very obvious. Is there any method or special component (such as a tapered pipe or a tapered pipe) that can minimize the pressure drop of nearly 20.0 kPa caused by sudden changes in area as much as possible;\n\n\n\nIn addition, in the above model, when I expand the area of inlet_pipe and outlet_pipe to the flow area of down_pipe, the calculation will not converge due to being less than the minimum time step, and the calculation failure time is mostly around 0.0006s. What strategies do you have to adjust the input card to make the calculation converge for this type of calculation failure; Meanwhile, when I only change the area of one of inlet_pipe and outlet_pipe, the calculation can still converge, but the location where a significant pressure drop occurs will shift from jct3 to jct1;\n\n\nBesides, when reading the temperature and pressure of each pipeline in the circuit, I found that for down_pipe, gas flowing through this area will cause a slight temperature rise (from 622K to 624K without heating). I speculate that this is due to friction and other reasons. However, there is no such phenomenon in outlet_pipe with the same input parameters. May I ask about the possible reasons for this phenomenon and if there are any solutions; Currently, I have not specified the wall roughness for any pipeline (the input card for down_pipe is as follows)\n\n\n[down_pipe_3]\n    type = FlowChannel1Phase\n    position = '${fparse connect_length * 2 + exp_length} 0 0'\n    orientation = '0 0 -1'\n    length = ${down_pipe_length}\n    n_elems = ${down_pipe_n_elems}\n    A = '${fparse pi * down_pipe_dia * down_pipe_dia / 4.}'\n    D_h = ${down_pipe_dia}\n    initial_p = 1.0e6\n    initial_T = 600.0\n    initial_vel = 3.0\n    fp = ar\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/29053#discussioncomment-11254123",
                          "updatedAt": "2024-11-14T13:06:57Z",
                          "publishedAt": "2024-11-14T13:06:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "FlowChannel1Phase can be tapered to your liking; the parameter A takes the name of a Function, so you can make one that linear interpolates the area from A1 to A2.\nThis is a general convergence criteria, so there's no specific recommendation. Smoothing out discontinuities (both in space and time) is helpful. Otherwise you may want to play with tolerances and scaling factors to make sure you're not trying to over-solve. I typically use scaling_factor_1phase = '1 1 1e-5' for FlowChannel1Phase, scaling_factor_rhoEV = 1e-5 for the junction/junction-like (e.g., pump) components, scaling_factor_temperature = 1e-5 for the heat structures.\nFriction would cause it, as well as the area change at jct3 since that'll compress it.",
                          "url": "https://github.com/idaholab/moose/discussions/29053#discussioncomment-11254503",
                          "updatedAt": "2024-11-14T13:42:49Z",
                          "publishedAt": "2024-11-14T13:42:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LGQ199810"
                          },
                          "bodyText": "Thank you for your answer. Based on your answer to question 1, when I attempting to interpolate the area of Flowchannel1Phase using a function, the program reported an error: 'The desired parameter' component/gas_inlet_pipe/A 'was not located for the' gas_inlet_pipe_area_ctl 'object, It either does not exist or has not been declared as controllable. 'If possible, could you provide a relatively correct usage method.\nMy initial goal for this function is to reduce the diameter of the gas_inlet_pipe component from down_pipe_dia (i.e. 30mm) to exp_gas_dia (i.e. 16mm) within the range of 0.0m to 0.3m on the component. I referred to the definition method of the secondary side flow rate in the single_phase_flow chapter of the thermal hydraulic module tutorial to write the control module and function. The main input cards are as follows:\nexp_gas_dia = '${units 16.0 mm -> m}'\ndown_pipe_dia = '${units 30.0 mm -> m}'\n\n[Functions]\n  [area_ctl]\n    type = PiecewiseLinear\n    xy_data = '\n      0.0   ${down_pipe_dia}\n      0.3   ${exp_gas_dia}'\n  []\n[]\n\n[Components]\n  [gas_inlet_pipe]\n    type = FlowChannel1Phase\n    position = '0 0 0'\n    orientation = '1 0 0'\n    length = ${connect_length}\n    n_elems = ${connect_n_elems}\n    A = ${fparse pi * exp_gas_dia * exp_gas_dia / 4.}'\n    D_h = ${exp_gast_dia}\n    initial_p = 1.0e6\n    initial_T = 1100.0\n    initial_vel = 3.0\n    fp = ar\n  []\n[]\n\n[ControlLogic]\n  [gas_inlet_pipe_area]\n    type = GetFunctionValueControl\n    function = area_ctl\n  []\n\n  [gas_inlet_pipe_area_ctl]\n    type = SetComponentRealValueControl\n    component = gas_inlet_pipe\n    parameter = A\n    value = gas_inlet_pipe_area:value\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/29053#discussioncomment-11256143",
                          "updatedAt": "2024-11-14T15:28:26Z",
                          "publishedAt": "2024-11-14T15:28:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Delete the gas_inlet_pipe_area_ctl block and replace A = ${fparse pi * exp_gas_dia * exp_gas_dia / 4.}' with A = area_ctl.\nThere are some parameters that accept Function names directly. Others just take a floating point value, and some of these can be controlled. Check the documentation page for the class if you're ever unsure - it has tables of the input parameters and their types and whether they're controllable.",
                          "url": "https://github.com/idaholab/moose/discussions/29053#discussioncomment-11257193",
                          "updatedAt": "2024-11-14T17:03:18Z",
                          "publishedAt": "2024-11-14T17:03:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Doubts regarding Explicit Time Integrators.",
          "author": {
            "login": "zuckarm"
          },
          "bodyText": "hi all,\ni had a question about explicit midpoint scheme, which is for first order odes. is there a specific way to specify this time integrator system, as i am not seeing the desired solution when i use this scheme.\nwhen i use central difference scheme, i am getting the desired solution.",
          "url": "https://github.com/idaholab/moose/discussions/29044",
          "updatedAt": "2024-11-14T14:56:17Z",
          "publishedAt": "2024-11-11T11:40:09Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "which is for first order odes. is there a specific way to specify this time integrator system, as i am not seeing the desired solution when i use this scheme.\n\nI dont think so. There are a few options you can select, notably for preconditioning\nhttps://mooseframework.inl.gov/source/timeintegrators/ActuallyExplicitEuler.html\n\nwhen i use central difference scheme, i am getting the desired solution.\n\nThat one is second order. But you have to set solve_type = LINEAR",
                  "url": "https://github.com/idaholab/moose/discussions/29044#discussioncomment-11214531",
                  "updatedAt": "2024-11-11T13:08:34Z",
                  "publishedAt": "2024-11-11T13:08:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zuckarm"
                          },
                          "bodyText": "i tried using ActuallyExplicitEuler, but i am facing the following error:\n*** ERROR ***\nThe following error occurred in the TimeStepper 'ConstantDT' of type ConstantDT.\n\nSolve failed and timestep already at or below dtmin, cannot continue!\n\ni have reduced dtmin to 1e-50, still the same error.\ni have solved dynamic problem using both implicit and explicit methods. following are the plots of displacement vs time for different methods. i am not able to figure what parameters need to changed in the code for first-order methods.\nthis plot is using implicit methods:\n\n\n\nthis plot is using explicit methods:",
                          "url": "https://github.com/idaholab/moose/discussions/29044#discussioncomment-11249421",
                          "updatedAt": "2024-11-14T05:02:37Z",
                          "publishedAt": "2024-11-14T05:02:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "i tried using ActuallyExplicitEuler, but i am facing the following error:\n\nThis error means the solve did not converge. You can try these techniques to make it converge:\nhttps://mooseframework.inl.gov//application_usage/failed_solves.html\n\ni have solved dynamic problem using both implicit and explicit methods. following are the plots of displacement vs time for different methods. i am not able to figure what parameters need to changed in the code for first-order methods.\n\nYou mostly need to reduce the time step for 1st order methods. 2nd order can use larger time steps to get the right solution.\nNot every time integration method will work for every problem as I am sure you are aware. Central difference for example is unstable for advection problems with higher Peclet numbers",
                          "url": "https://github.com/idaholab/moose/discussions/29044#discussioncomment-11255552",
                          "updatedAt": "2024-11-14T14:56:18Z",
                          "publishedAt": "2024-11-14T14:56:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Initialize variable value of newly activated element",
          "author": {
            "login": "keassyguang"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello everyone,\nI am currently working on a additive manufacturing process simulation project using the MOOSE. I got some problems when I tried to initialize/reinitialize variable value of newly activated elements.\nAccording to the MOOSE documentation on ElementSubdomainModifier: https://mooseframework.inl.gov/source/meshmodifiers/ElementSubdomainModifier.html\n\nBy default, all elements that change subdomain ID are reinitialized to the new subdomain's initial condition.\n\nThe left part of the below picture shows a temperature initialization result of a newly added layer (Layer 2) within the ABAQUS software. For the newly added layer, Layer 2, the bottom nodes of this layer are shared with Layer 1 (top nodes of layer 1). ABAQUS initializes the temperature of Layer 2 by setting the specified value, except for these shared nodes, as the temperature of these nodes is kept the same as the value at the end of Layer 1.\nAs for MOOSE, based on my observations, since all elements move from the inactivated domain to the activated domain, all the nodes are initialized. For those shared nodes, it seems that MOOSE overrides their previous/existing values directly with the specified value. (If I am wrong, please correct me).\nI know there might be physical meaningful for both these two initializtion methods. But what should I do if I want to achieve the same initialization as in ABAQUS?",
          "url": "https://github.com/idaholab/moose/discussions/29015",
          "updatedAt": "2024-11-14T02:12:14Z",
          "publishedAt": "2024-11-06T09:24:19Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@hugary1995\nWe have not implemented this behavior afaik.\nWe can use the IC object to initialize, and can skip reinitialization based on the new and old subdomains these elements get assigned to.\nIn the current setup, I dont think this is hard to implement. I would do it with a NeighborElementsFunctorIC, which would be an IC that looks at the neighbor element values, possibly with a multi-layer stencil, and computes the average of neighbor values within the same subdomain (the new subdomain of the element being switched)",
                  "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11167124",
                  "updatedAt": "2024-11-06T14:01:14Z",
                  "publishedAt": "2024-11-06T14:01:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Do you mean that I create a new IC object since I didn't find an existing IC object named \"NeighborElementsFunctorIC\"?",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11172481",
                          "updatedAt": "2024-11-07T02:03:34Z",
                          "publishedAt": "2024-11-07T02:03:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11172501",
                          "updatedAt": "2024-11-07T02:07:48Z",
                          "publishedAt": "2024-11-07T02:07:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You are right about variables being initialized to their initial conditions. You can selectively initialize certain subdomains using the reinitialize_subdomains parameter. Quoting the parameter description\n\nBy default, any element which changes subdomain is reinitialized. If a list of subdomains (IDs or names) is provided, then only elements whose new subdomain is in the list will be reinitialized. If an empty list is set, then no elements will be reinitialized.\n\nAs to your second question:\n\nAs for MOOSE, based on my observations, since all elements move from the inactivated domain to the activated domain, all the nodes are initialized. For those shared nodes, it seems that MOOSE overrides their previous/existing values directly with the specified value. (If I am wrong, please correct me).\n\nI don't believe that's the case, at least your observation is not the intended behavior. However, I see a potential issue when inspecting the source code. In ElementSubdomainModifierBase::applyIC method, we have the following call\n  _fe_problem.projectInitialConditionOnCustomRange(reinitializedElemRange(displaced),\n                                                   reinitializedBndNodeRange(displaced));\nIt calls the projectInitialConditionOnCustomRange provided by the framework on the newly reinitialized elements and boundary nodes. However, in your case where you are interested in reinitializing nodal variables, this might be forcibly reinitializing the \"shared\" nodes (in your original description).\nI agree this is an issue, and we should at least allow users to control the behavior on shared nodes.",
                  "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11227267",
                  "updatedAt": "2024-11-12T14:21:44Z",
                  "publishedAt": "2024-11-12T14:21:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I created #29054 to keep track of this issue. I can work on this in the coming months.",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11227305",
                          "updatedAt": "2024-11-12T14:25:20Z",
                          "publishedAt": "2024-11-12T14:25:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Thanks for the detailed explanation @hugary1995 and also thanks for the help so far @GiudGiud\n\nThings could get even weirder when I further checked the value of the variable at the quadrature point. As shown in the figure above, I think the current initialisation strategy might also affect the already activated elements connected to the shared nodes. Here the qp_id = 9 belongs to layer 1. The initial value of CM is around 4418, it reduces to 2323.55 after 4 seconds. However, as soon as the second layer is activated, its value changes to 4062, which should not happen as it should gradually reduce to a certain value. I also checked the InitialConditionTempl.h, it says:\n\n/** This is a template class that implements the workhorse compute and computeNodal methods. The former method is used for setting block initial conditions. It first projects the initial condition field to nodes, then to edges, then to faces, then to interior dofs. The latter computeNodal method sets dof values for boundary restricted initial conditions */\n\nI'm not sure if this is also caused by shared nodes.\n\nI created #29054 to keep track of this issue. I can work on this in the coming months.\n\nHope to see this feature soon!",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11238597",
                          "updatedAt": "2024-11-13T10:52:00Z",
                          "publishedAt": "2024-11-13T10:51:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm not sure if this is also caused by shared nodes.\n\nIn a way. The value of a variable at a Qp is not what we actually solve for. We solve for values of variables at degrees of freedom, which can be at nodes, on sides, etc. It depends on the variable type.\nThen the variable value at Qps is computed by evaluating the shape function there. If the shape function is affected by a changed nodal value, then that could be what is happening.\nWhich variable type is this?\nCould you please sample the variable on the boundary instead of Qps? Before and after the subdomain change.",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11241708",
                          "updatedAt": "2024-11-13T15:09:34Z",
                          "publishedAt": "2024-11-13T15:09:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "Which variable type is this?\n\nI think the variable type should be\norder = FIRST\nfamily = LAGRANGE\n\n\nCould you please sample the variable on the boundary instead of Qps? Before and after the subdomain change.\n\nI can sample the variable on the top boundary tomorrow.",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11241846",
                          "updatedAt": "2024-11-13T15:18:48Z",
                          "publishedAt": "2024-11-13T15:18:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok so these will all be nodal DoFs.",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11242080",
                          "updatedAt": "2024-11-13T15:35:54Z",
                          "publishedAt": "2024-11-13T15:35:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "The upper right curve shows the evolution of this variable over time. There is a sudden increase when the time equal to 4s.",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11242168",
                          "updatedAt": "2024-11-13T15:41:50Z",
                          "publishedAt": "2024-11-13T15:41:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "where is the \"point used to plot\"? Is that a node? Or a Qp? or a point on a side?",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11242299",
                          "updatedAt": "2024-11-13T15:50:14Z",
                          "publishedAt": "2024-11-13T15:50:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "keassyguang"
                          },
                          "bodyText": "where is the \"point used to plot\"? Is that a node? Or a Qp? or a point on a side?\n\nIt is a point on the top surface of layer 1, and I think it is also a node. A point on the top side of layer 1.",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11242377",
                          "updatedAt": "2024-11-13T15:56:40Z",
                          "publishedAt": "2024-11-13T15:56:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@hugary1995 Is there an option to get the ICs to apply (when triggered by a subdomain change) on the new elements but not on the boundary nodes?\nOr maybe this is already the default behavior?",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11242439",
                          "updatedAt": "2024-11-13T16:02:39Z",
                          "publishedAt": "2024-11-13T16:02:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "That is the intended behavior, but it is not happening. That's exactly what I want to fix.",
                          "url": "https://github.com/idaholab/moose/discussions/29015#discussioncomment-11242476",
                          "updatedAt": "2024-11-13T16:05:37Z",
                          "publishedAt": "2024-11-13T16:05:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "I cannot run the heat transfer module",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "All,\nI cannot run the heat transfer module. Pease see the attached error message and attached the Makefile in which the heat transfer module is set to be \"yes.\" Please help.\nS. Thomas",
          "url": "https://github.com/idaholab/moose/discussions/29026",
          "updatedAt": "2024-11-14T00:19:01Z",
          "publishedAt": "2024-11-07T20:38:11Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nwhen adding a new module you need to make clobberall then recompile. Sometimes you also need to clean moose as well",
                  "url": "https://github.com/idaholab/moose/discussions/29026#discussioncomment-11182238",
                  "updatedAt": "2024-11-07T20:47:06Z",
                  "publishedAt": "2024-11-07T20:47:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you very much.\nI am using the Heat Transfer module included in MOOSE and I make clobberall before compile.\nPlease help.",
                          "url": "https://github.com/idaholab/moose/discussions/29026#discussioncomment-11183584",
                          "updatedAt": "2024-11-08T00:23:57Z",
                          "publishedAt": "2024-11-08T00:23:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Go in moose/modules and make clobberall there\nIf it s still not working, save all your work in both folders using git commit, then use git clean -xfD to clean them",
                          "url": "https://github.com/idaholab/moose/discussions/29026#discussioncomment-11183653",
                          "updatedAt": "2024-11-08T00:40:20Z",
                          "publishedAt": "2024-11-08T00:40:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "After \"make clobberall\" in moose/module, am I suppose to compile (make -j 10) in moose/module?\nPlease help.",
                          "url": "https://github.com/idaholab/moose/discussions/29026#discussioncomment-11184071",
                          "updatedAt": "2024-11-08T01:53:51Z",
                          "publishedAt": "2024-11-08T01:53:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No go compile in your application.",
                          "url": "https://github.com/idaholab/moose/discussions/29026#discussioncomment-11184132",
                          "updatedAt": "2024-11-08T02:03:20Z",
                          "publishedAt": "2024-11-08T02:03:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "\"make clobberall\" in the moose/module directory did not help ... sorry.",
                          "url": "https://github.com/idaholab/moose/discussions/29026#discussioncomment-11184188",
                          "updatedAt": "2024-11-08T02:16:10Z",
                          "publishedAt": "2024-11-08T02:16:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "time to switch to git clean -Xfd in moose/ and in your_app/ folders",
                          "url": "https://github.com/idaholab/moose/discussions/29026#discussioncomment-11184245",
                          "updatedAt": "2024-11-08T02:27:00Z",
                          "publishedAt": "2024-11-08T02:26:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so\ncd ~/project/moose\ngit add .\ngit commit -am \"Save everything\"\ngit clean -Xfd\ncd ../my_app\ngit add .\ngit commit -am \"Save everything\"\ngit clean -Xfd\n\nif you know what you want to save specifically, you can change the git add / git commit part",
                          "url": "https://github.com/idaholab/moose/discussions/29026#discussioncomment-11190426",
                          "updatedAt": "2024-11-08T15:29:05Z",
                          "publishedAt": "2024-11-08T15:29:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "I did all of these git runs but it is still not working. It is seemingly caused by other things.",
                          "url": "https://github.com/idaholab/moose/discussions/29026#discussioncomment-11192724",
                          "updatedAt": "2024-11-08T19:31:30Z",
                          "publishedAt": "2024-11-08T19:31:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok you should git clone your app your app again and change the Makefile to see if it works that way",
                          "url": "https://github.com/idaholab/moose/discussions/29026#discussioncomment-11193784",
                          "updatedAt": "2024-11-08T22:43:01Z",
                          "publishedAt": "2024-11-08T22:43:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you, GiudGiud!\nSo, I am going to do re-installation. I am going to move the current projects directory to a new name.\nAlso, do I have to delete any files before the re-installation?\nPlease help.",
                          "url": "https://github.com/idaholab/moose/discussions/29026#discussioncomment-11217093",
                          "updatedAt": "2024-11-11T17:08:58Z",
                          "publishedAt": "2024-11-11T17:08:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Film rupture, dissolution and repassivation",
          "author": {
            "login": "engrmessi"
          },
          "bodyText": "I modelled a diffusion controlled stress corrosion cracking for film rupture dissolution mechanism\n\nNow I want to add Repassivation to the model. i.e. I want to developed Film Rupture, Dissolution and Repassivation FRDR cycle. Please how do I modify the attached material block.\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/29070",
          "updatedAt": "2024-11-13T22:31:34Z",
          "publishedAt": "2024-11-13T22:31:33Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "PoroFullSatTimeDerivative is not a registered object",
          "author": {
            "login": "ihernandezimbert"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI am trying to run the borehole_lowres.i file in in the combined modules under poro_mechanics, however I am getting an error that PoroFullSatTimeDerivative is not a registered object.\nI have both solid mechanics and richards loaded in my Makefile, so I am not sure what I am missing.\nALL_MODULES         := no\n\nCHEMICAL_REACTIONS  := no\nCONTACT             := no\nFLUID_PROPERTIES    := yes\nHEAT_TRANSFER       := yes\nMISC                := no\nNAVIER_STOKES       := no\nPHASE_FIELD         := yes\nRDG                 := no\nRICHARDS            := yes\nSOLID_MECHANICS     := yes\nSTOCHASTIC_TOOLS    := no\nXFEM                := no\nPOROUS_FLOW         := yes\n\nAny help is appreciated - thank you very much!",
          "url": "https://github.com/idaholab/moose/discussions/29067",
          "updatedAt": "2024-11-13T19:53:12Z",
          "publishedAt": "2024-11-13T16:43:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nIf you just added the new modules, you need to recompile before they are available.\nUnfortunately you often need to also deep clean the app and moose before the modules are built in properly",
                  "url": "https://github.com/idaholab/moose/discussions/29067#discussioncomment-11245598",
                  "updatedAt": "2024-11-13T19:53:13Z",
                  "publishedAt": "2024-11-13T19:53:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}