{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0xMC0wMlQxNjowOToyMi0wNTowMM4AVuVx"
    },
    "edges": [
      {
        "node": {
          "title": "Seeking Guidance on Incorporating Back Stress into Crystal Plasticity Constitutive Model",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear Moose Experts,\nI hope this message finds you well. I am currently working on the integration of back stress into a crystal plasticity constitutive model within the Moose framework. I have been referencing the work done by @ngrilli  in the c_pfor_am::FiniteStrainCrystalPlasticityBackstress class to achieve this.\nTo provide some context, the FiniteStrainCrystalPlasticityBackstress class is constructed based on UserObjects classes. I am attempting to derive from CrystalPlasticityKalidindiBackstress to incorporate back stress into the the CrystalPlasticityKalidindiUpdate class. So far, I have overridden functions such as calculateSlipRate() and calculateConstitutiveSlipDerivative() to achieve this goal.\nHowever, I am uncertain whether I should also make modifications to the updateSubstepConstitutiveVariableValues and cacheStateVariablesBeforeUpdate functions. Additionally, I would appreciate guidance on any other aspects that I might be overlooking in this process.\nAs part of my project, I need to modify the constitutive equations as follows:\n\n\nFor shear strain rate:\n$\\dot{\\gamma}^\\alpha=\\dot{\\gamma}_o\\left|\\frac{\\tau^\\alpha-\\chi^\\alpha}{g^\\alpha}\\right|^M {sgn}\\left(\\tau^\\alpha-\\chi^\\alpha\\right)$\n\n\nFor back stress evolution:\n$(\\dot{\\chi}^\\alpha = h \\dot{\\gamma}^\\alpha - r \\chi^\\alpha\\left|\\dot{\\gamma}^\\alpha\\right|)$\n\n\nI would be immensely grateful for any expert guidance or suggestions on how to effectively incorporate these changes and ensure the accurate implementation of the back stress concept into the crystal plasticity constitutive model within Moose.\nThank you in advance for your time and assistance. Your expertise is highly valued.\nBest regards,\nWei Peng",
          "url": "https://github.com/idaholab/moose/discussions/25557",
          "updatedAt": "2023-10-05T07:44:32Z",
          "publishedAt": "2023-09-22T15:54:21Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "https://github.com/idaholab/blackbear can already do this with the NEML plugin.",
                  "url": "https://github.com/idaholab/moose/discussions/25557#discussioncomment-7083907",
                  "updatedAt": "2023-09-22T16:47:04Z",
                  "publishedAt": "2023-09-22T16:47:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you very much for providing me with another solution, but through the tips you gave me, I did not find a crystal plasticity model that considers back stress in the NEML documentation. So, can you provide me with a more specific link or test example?",
                          "url": "https://github.com/idaholab/moose/discussions/25557#discussioncomment-7086865",
                          "updatedAt": "2023-09-23T01:59:08Z",
                          "publishedAt": "2023-09-23T01:59:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "https://github.com/Argonne-National-Laboratory/neml/blob/dev/examples/cp/cpmodel.xml",
                          "url": "https://github.com/idaholab/moose/discussions/25557#discussioncomment-7087597",
                          "updatedAt": "2023-09-23T06:55:33Z",
                          "publishedAt": "2023-09-23T06:55:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Hi @hugary1995. Thank you for your prompt response and suggestions. Unfortunately, I couldn't find the required content in the link you provided. Additionally, when I explored the \"Frederick-Armstrong\" back stress evolution model in the NEML repository, I found that the documentation in neml/doc/manual/manual.lyx only contained the following information:\nA Frederick-Armstrong model has\n\\begin_inset Formula $n=1$\n\\end_inset\nConsidering my goal is to incorporate the back stress term into the existing crystal plasticity model CrystalPlasticityKalidindiUpdate, as indicated in my initial equations, I am still seeking guidance on the implementation of this specific back stress model.\nWhile I appreciate the alternative approach you suggested, it's worth mentioning that my ultimate objective is to couple the crystal plasticity module with a phase-field module. Hence, it seems that building upon the current Kalidindi model and adding an Armstrong-Frederick back stress term would be the most suitable choice.\nI genuinely appreciate your assistance and insights on this matter. If you have any further suggestions or resources that could aid in this endeavor, please do share.",
                          "url": "https://github.com/idaholab/moose/discussions/25557#discussioncomment-7092439",
                          "updatedAt": "2023-09-24T08:32:29Z",
                          "publishedAt": "2023-09-24T08:32:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "PengWei97"
                  },
                  "bodyText": "Dear @ngrilli, @sapitts, and @hugary1995,\nI hope this message finds you well. I wanted to provide an update on my recent progress and the new problems I've encountered in my endeavor to incorporate backstress into the crystal plasticity model.\nTo begin with, I have successfully created the CrystalPlasticityKalidindiBackstress class based on CrystalPlasticityKalidindiUpdate. Specifically, I added the backstress term _tau_b to the calculateSlipRate() and calculateConstitutiveSlipDerivative() functions. Additionally, I implemented the updateBackstress() function to calculate the evolution of back stress.\nFollowing this, I created Case 1, where c_backstress = 1.0e1 and d_backstress = 1.0e-1. Case 1 appears to compute without issues; however, it does generate some warnings to the terminal during each linear solve, such as:\n*** Warning ***\nThe following warning occurred in the object \"trial_xtalpl,\" of type \"CrystalPlasticityKalidindiBackstress.\"\n\nMaximum allowable slip increment exceeded 0.130827\nSubsequently, I created Case 2 with c_backstress = 1.0e2 and d_backstress = 1.0. However, during the calculation, it proceeds until Time Step 12, time = 1.9333, dt = 1.90735e-07, after which it fails to converge. Furthermore, at Time Step 10, it outputs \"NAN\" values to the terminal, as shown below:\n*** Warning ***\nTime Step 10, time = 1.93359, dt = 0.00078125\n 0 Nonlinear |R| = 1.506118e+02\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nIn summary, while I have made progress in constructing CrystalPlasticityKalidindiBackstress, it still exhibits issues, and I am uncertain about the root cause. I believe your expertise in this area would be invaluable in resolving these challenges and ensuring the accurate implementation of the backstress concept into the crystal plasticity model.\nI sincerely appreciate your time and assistance on this matter. Your guidance and insights would be greatly appreciated.\nBest regards,\nWei Peng",
                  "url": "https://github.com/idaholab/moose/discussions/25557#discussioncomment-7093525",
                  "updatedAt": "2023-09-24T12:39:10Z",
                  "publishedAt": "2023-09-24T12:38:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Hi @PengWei97,\nI'm glad to see that you are using the Update based crystal plasticity classes because those are the classes we are currently maintaining. I am not familiar with @ngrilli's implementation nor the NEML implementation, so I will focus my response solely on the CrystalPlasticityKalidindiUpdate.\nI would recommend inheriting your new CrystalPlasticityKalidindiBackstress class from the existing CrystalPlasticityKalidindiUpdate class. In the new CrystalPlasticityKalidindiBackstress class overwrite (to modify) the methods calculateSlipRate and calculateConstitutiveSlipDerivative to use the shear strain rate given by eqn 1 in your original post.\nAdd a new method in calculateStateVariableEvolutionRateComponent to calculate the back stress evolution with the updateBackStress method you mentioned in this latest post. (Make sure to also call the CrystalPlasticityKalidindiUpdate::calculateStateVariableEvolutionRateComponent() method first to keep that functionality in your new class.\nYou will also need to manage the total value updating and substep caching for the back stress variable; see the treatment of the forest dislocation variables in CrystalPlasticityHCPDislocationSlipBeyerleinUpdate. In particular pay attention to the following methods:\n\nupdateStateVariables\nareConstitutiveStateVariablesConverged\nsetInitialConstitutiveVariableValues\nsetSubstepConstitutiveVariableValues\nupdateSubstepConstitutiveVariableValues\n\nThe warning you copied about the maximum slip increment in your Case 1 may be related to the size of the timestep or the associated slip increment tolerance. The appearance of NANs in Case 2 may also indicated that the slip increment tolerance is too tight, or, more likely, that the incrementing of the back stress isn't handled properly. As a first step I would recommend adding print statements to monitor the back stress and slip increment values calculated by your code.\nHope this helps,\nStephanie",
                          "url": "https://github.com/idaholab/moose/discussions/25557#discussioncomment-7115695",
                          "updatedAt": "2023-09-26T18:06:05Z",
                          "publishedAt": "2023-09-26T18:06:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@PengWei97  the FiniteStrainCrystalPlasticityBackstress in my repository is based on the old monolithic code.\nI have included the backstress with Armstrong-Frederick evolution also in a class derived from the new \"stress_update_material_based\" material class.\nSee here:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/CrystalPlasticityDislocationUpdate.C\nThe backstress is simply updated in updateStateVariables()\nI recommend you use this newer code.",
                  "url": "https://github.com/idaholab/moose/discussions/25557#discussioncomment-7166926",
                  "updatedAt": "2023-10-02T15:59:58Z",
                  "publishedAt": "2023-10-02T15:59:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Dear @sapitts and @ngrilli,\nI trust this message finds you both well. I wanted to express my sincere gratitude for your invaluable assistance and guidance in addressing the challenges I encountered while incorporating backstress into the crystal plasticity model. With your help, I'm delighted to report that the issues mentioned earlier have been successfully resolved.\nTaking into account the suggestions provided, as well as Ngrilli's reference to the CrystalPlasticityDislocationUpdate, I made the necessary modifications to the existing CrystalPlasticityKalidindiBackstress class. These adjustments have proven effective, and I have now achieved successful results in a uniaxial tension simulation. Below, you will find the results as well as the updated version of the CrystalPlasticityKalidindiBackstress:\n\nThank you once again for your invaluable help. I look forward to your continued guidance as we move forward.\nBest regards,\nwei peng",
                          "url": "https://github.com/idaholab/moose/discussions/25557#discussioncomment-7184713",
                          "updatedAt": "2023-10-04T09:29:53Z",
                          "publishedAt": "2023-10-04T09:29:52Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Please consider submitting a PR with this class to the MOOSE repository--we'd be glad to help you through the process and even more glad to have a broader set of crystal plasticity capabilities for the wider crystal-plasticity-MOOSE community!",
                          "url": "https://github.com/idaholab/moose/discussions/25557#discussioncomment-7188085",
                          "updatedAt": "2023-10-04T14:46:11Z",
                          "publishedAt": "2023-10-04T14:46:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Dear @sapitts,\nI want to express my sincere gratitude for extending the invitation to contribute the CrystalPlasticityKalidindiBackstress class to the MOOSE repository. I am truly honored and excited to be a part of this collaborative effort to enhance the crystal plasticity capabilities within the broader crystal-plasticity-MOOSE community.\nAs per your suggestion, I have taken the necessary steps to move CrystalPlasticityKalidindiBackstress to the moose-backstressCPKa2023 branch. Furthermore, I have created an initial version of the CrystalPlasticityKalidindiBackstress.md documentation and relevant test cases in exception_backstress.m. These materials are admittedly a work in progress, and I'm committed to refining and expanding them to ensure clarity and usability.\nI have also initiated a pull request (#25669) to facilitate the merging process, making this contribution available for review and further development.\nOnce again, I want to thank you and the entire MOOSE community for your warm welcome and support throughout this journey. I'm looking forward to collaborating closely and contributing to the growth of the MOOSE framework's crystal plasticity capabilities.\nPlease feel free to provide any further guidance or recommendations as we move forward. Your expertise and mentorship are highly appreciated.\nBest regards,\nwei peng",
                          "url": "https://github.com/idaholab/moose/discussions/25557#discussioncomment-7194971",
                          "updatedAt": "2023-10-05T07:44:33Z",
                          "publishedAt": "2023-10-05T07:44:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Contact with explicit time integrator",
          "author": {
            "login": "lyyc199586"
          },
          "bodyText": "Can we use contact with explicit time integrator (e.g. CentralDifference)?\nI tried with the example in introduction of contact modules (https://mooseframework.inl.gov/modules/contact/tutorials/introduction/step01.html), with\n[Executioner]\n  type = Transient\n  end_time = 5\n  dt = 0.5\n  [TimeIntegrator]\n    type = CentralDifference\n  []\n[]\n\nbut only get\n*** ERROR ***\nNeed a system matrix",
          "url": "https://github.com/idaholab/moose/discussions/25401",
          "updatedAt": "2023-10-04T20:40:27Z",
          "publishedAt": "2023-09-05T14:49:02Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCentralDifference is implemented a little differently. Do you mind trying the other explicit time integrators?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-6916464",
                  "updatedAt": "2023-09-05T16:23:43Z",
                  "publishedAt": "2023-09-05T16:23:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "If you are interested in doing dynamics, I believe NewmarkBeta is often used. @recuero might want to comment more",
                  "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-6917470",
                  "updatedAt": "2023-09-05T18:26:55Z",
                  "publishedAt": "2023-09-05T18:26:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "Contact has not been implemented/tested for explicit dynamics (we will hopefully get to that). For implicit dynamics, use of contact objects is limited, but we do have examples or tests that use Newmark beta.",
                  "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-6917532",
                  "updatedAt": "2023-09-05T18:34:49Z",
                  "publishedAt": "2023-09-05T18:34:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lyyc199586"
                  },
                  "bodyText": "got it, thanks",
                  "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-6917569",
                  "updatedAt": "2023-09-05T18:39:28Z",
                  "publishedAt": "2023-09-05T18:39:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "FYI: We are going to be looking into explicit dynamics contact this year: #25666",
                          "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-7191102",
                          "updatedAt": "2023-10-04T20:12:40Z",
                          "publishedAt": "2023-10-04T20:12:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "great!",
                          "url": "https://github.com/idaholab/moose/discussions/25401#discussioncomment-7191291",
                          "updatedAt": "2023-10-04T20:40:28Z",
                          "publishedAt": "2023-10-04T20:40:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "module command not found",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "I am trying to run my first job. Below is my sbatch file.\n#!/bin/bash                                                                     \n#SBATCH --job-name kks_multiphase_largescale_large                                                 \n#SBATCH --out  kks_multiphase_largescale_large.out        \n#SBATCH --nodes 1                                                               \n#SBATCH --ntasks 2\n#SBATCH --cpus-per-task 8\n#SBATCH --account amcorrosion                                                  \n##SBATCH --partition normal_q                                                   \n#SBATCH --time=100:00:00    \n##SBATCH --mem=gpu:pascal:4                                                     \n#SBATCH --export=NONE # this makes sure the compute environment is clean        \n#SBATCH --mail-user emmanuel324@vt.edu\n#SBATCH --mail-type=begin\n#SBATCH --mail-type=end\n\n\nsource /home/emmanuel324/.moose_profile\nmodule load apps site/tinkercliffs/easybuild/setup\nmodule load apps site/tinkercliffs-rome/easybuild/setup\nmodule load OpenMPI/4.1.1-GCC-10.3.0\nmodule load CMake/3.20.1-GCCcore-10.3.0\nmodule load Anaconda3/2020.11\n\n\ncd \"${submitdir}\"\n\n#rm kks_multiphase_largescale_large_csv*\n#rm kks_multiphase_largescale_large_out.e*\nmpirun --mca orte_base_help_aggregate 0 -np 2 /home/emmanuel324/projects/belson/belson-opt  -i  kks_multiphase_largescale_large.i\n\nAlso below is the .out file. A colleague used similar sbatch file with exception of job name and application and it works fine for them.\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 17: source: /home/emmanuel324/.moose_profile: is a directory\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 18: module: command not found\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 19: module: command not found\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 20: module: command not found\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 21: module: command not found\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 22: module: command not found\nrm: cannot remove 'kks_multiphase_largescale_large_out.e*': No such file or directory\n/cm/local/apps/slurm/var/spool/job1688181/slurm_script: line 29: mpirun: command not found\n\nHow do I resolve this?",
          "url": "https://github.com/idaholab/moose/discussions/25664",
          "updatedAt": "2023-10-04T16:06:37Z",
          "publishedAt": "2023-10-04T14:30:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis .moose_profile file, does it exist? Is it at this path?\nIt starts erroring there. Similarly it fails to run module on every command, so the conseuqnece is that there's no mpirun available?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25664#discussioncomment-7188218",
                  "updatedAt": "2023-10-04T14:58:22Z",
                  "publishedAt": "2023-10-04T14:58:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "I created the .moose_profile directory. How do i create or enable the mpirun",
                          "url": "https://github.com/idaholab/moose/discussions/25664#discussioncomment-7188547",
                          "updatedAt": "2023-10-04T15:28:08Z",
                          "publishedAt": "2023-10-04T15:28:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "You should really seek help from the administrators of the HPC cluster you are on. All HPC clusters are different. If this was Lemhi or Sawtooth (two clusters here at INL), I would say:\nIn order to obtain MPI, load up the following modules:\nmodule load use.moose moose-dev",
                          "url": "https://github.com/idaholab/moose/discussions/25664#discussioncomment-7188772",
                          "updatedAt": "2023-10-04T15:49:22Z",
                          "publishedAt": "2023-10-04T15:49:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I created the .moose_profile directory\n\nIt should be a file, and it should contain whatever is needed to run moose on your machine",
                          "url": "https://github.com/idaholab/moose/discussions/25664#discussioncomment-7188948",
                          "updatedAt": "2023-10-04T16:06:37Z",
                          "publishedAt": "2023-10-04T16:06:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "adCoupledScalarDot problem in ADScalarTimeKernel",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nI would like to develop a CoupledADScalarTimeDerivative which inherits ADScalarTimeKernel.\nBut ADScalarTimeKernel doesn't have the adCoupledScalarDot function. I can not define the variable like:\n_v_dot(adCoupledScalarDot(\"v\"))\nI also find CoupledODETimeDerivative defining _v_dot(coupledScalarDot(\"v\")), but it is not AD type. How to define an adCoupledScalarDot variable in ADScalarTimeKernel?\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/25655",
          "updatedAt": "2023-10-04T12:11:25Z",
          "publishedAt": "2023-10-03T15:09:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@joshuahansel do you remember why we dont have that one",
                  "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7177477",
                  "updatedAt": "2023-10-03T15:56:36Z",
                  "publishedAt": "2023-10-03T15:56:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "I don't believe there is any reason - we just need to add adCoupledScalarDot to ScalarCoupleable.",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7178399",
                          "updatedAt": "2023-10-03T17:22:52Z",
                          "publishedAt": "2023-10-03T17:22:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "So, could you please tell me what should I do?",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7178911",
                          "updatedAt": "2023-10-03T18:24:52Z",
                          "publishedAt": "2023-10-03T18:24:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You ll need to edit the ScalarCoupleable.C/.h files in the src/include / interfaces folder(s) to add this new routine",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7179379",
                          "updatedAt": "2023-10-03T19:12:17Z",
                          "publishedAt": "2023-10-03T19:12:17Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Ok, I'll have a try. Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7183097",
                          "updatedAt": "2023-10-04T06:37:27Z",
                          "publishedAt": "2023-10-04T06:37:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Hi,\nI have added the function to ScalarCoupleable:\nScalarCoupleable.h:\nconst ADVariableValue & adCoupledScalarDot(const std::string & var_name, unsigned int comp = 0) const;\nScalarCoupleable.C:\nconst ADVariableValue &\nScalarCoupleable::adCoupledScalarDot(const std::string & var_name, unsigned int comp) const\n{\n  checkVar(var_name);\n  validateExecutionerType(var_name, \"adCoupledScalarDot\");\n  return getScalarVar(var_name, comp)->adUDot();\n}\n\nThe compilation is passed. But I'm not sure if it is OK. Is there anything I still need to add? or that is enough?",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7183864",
                          "updatedAt": "2023-10-04T08:04:50Z",
                          "publishedAt": "2023-10-04T08:04:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "looks good to me",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7186074",
                          "updatedAt": "2023-10-04T11:54:31Z",
                          "publishedAt": "2023-10-04T11:54:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/25655#discussioncomment-7186242",
                          "updatedAt": "2023-10-04T12:11:17Z",
                          "publishedAt": "2023-10-04T12:11:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Water97FluidProperty problem",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nI would like to calculate pressure using enthalpy and entropy (p_from_h_s)[h and s are known variables].\nBut Water97FluidProperty does not contain this function. What should I do? Should I use an iteration (assume p and T)?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/25651",
          "updatedAt": "2023-10-04T06:40:39Z",
          "publishedAt": "2023-10-03T06:54:45Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes you should try to implement it.\nAn iterative method would work\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7174401",
                  "updatedAt": "2023-10-03T10:59:59Z",
                  "publishedAt": "2023-10-03T10:59:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Do you have any idea how to implement the iteration method?",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7174599",
                          "updatedAt": "2023-10-03T11:24:20Z",
                          "publishedAt": "2023-10-03T11:24:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Use the Newton1Dsolve method. See TabulatedFP for examples\nThe idea is that as long as you have s(p,h) or h(p,s) defined, or if you can compute it in several steps, you can use that to compute the other one from a Newton Raphson solve",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7174867",
                          "updatedAt": "2023-10-03T11:54:19Z",
                          "publishedAt": "2023-10-03T11:54:18Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Thank you very much! I find a function in SinglePhaseFluidProperties:\nvoid\nSinglePhaseFluidProperties::p_T_from_h_s(const T & h,     // h value\n                                         const T & s,     // s value\n                                         const Real p0,   // initial guess\n                                         const Real T0,   // initial guess\n                                         T & pressure,    // returned pressure\n                                         T & temperature, // returned temperature\n                                         bool & conversion_succeeded) const\n\nI think I can use it directly to calculate pressure.",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7175037",
                          "updatedAt": "2023-10-03T13:03:00Z",
                          "publishedAt": "2023-10-03T12:12:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this should be all you need indeed. It s iterative iirc so it might be a bit slow\nThe other alternative is to math it out, solve analytically for the property you need in the different regions of IAPWS IF 97",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7175524",
                          "updatedAt": "2023-10-03T13:04:19Z",
                          "publishedAt": "2023-10-03T13:04:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "However, I think the analytical expressions (p_from_h_s) in the different regions of IAPWS-IF97 are difficult for me to construct. Do you have the exact expressions, or where can I find the exact expressions? If yes, I could have a try.",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7175588",
                          "updatedAt": "2023-10-03T13:11:11Z",
                          "publishedAt": "2023-10-03T13:11:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can check the papers listed in the documentation.\nhttps://mooseframework.inl.gov/source/fluidproperties/Water97FluidProperties.html\nI think it will be difficult unless it's already written there fand you just need to implement",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7175662",
                          "updatedAt": "2023-10-03T13:16:43Z",
                          "publishedAt": "2023-10-03T13:16:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Ok, thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7175685",
                          "updatedAt": "2023-10-03T13:18:42Z",
                          "publishedAt": "2023-10-03T13:18:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "There are backward equations for p(h,s) for some of the regions given by IAPWS - see http://www.iapws.org/release.html. These are much faster than iteration, but would require some hours of coding to add them. It isn't difficult, just time consuming, if you want to have a go at adding them.",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7181448",
                          "updatedAt": "2023-10-04T01:14:16Z",
                          "publishedAt": "2023-10-04T01:14:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/25651#discussioncomment-7183124",
                          "updatedAt": "2023-10-04T06:40:40Z",
                          "publishedAt": "2023-10-04T06:40:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Postprocessor for arbitrary linear equation",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "I'd like to do something like a NodalSum Postprocessor, except I'd like the coefficients to be artibrary, ie. Ax + By + Cz +.... It would be boundary-restricted, so in theory the coefficients would correspond to the order of the nodes in my nodeset. I'm thinking of inhereting from the NodalSum PPS and overriding the execute method like so:\nvoid\nNodalSum::execute()\n{\n  _sum += _coef * _u[_qp];\n}\n\nI'm just not sure how to make sure I'm getting the right coeff for the particular node. Any ideas?",
          "url": "https://github.com/idaholab/moose/discussions/25616",
          "updatedAt": "2023-10-03T19:10:30Z",
          "publishedAt": "2023-09-28T13:57:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "If it s as simple as Ax + By + Cz you can use a function for the coefficient, and do this:\n_sum += _coef.value(_t, *_current_node);",
                  "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7134813",
                  "updatedAt": "2023-09-28T14:10:39Z",
                  "publishedAt": "2023-09-28T14:05:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Sorry, maybe I should be more specific. The x, y, and z are _u at different nodes. The equation reads more like:\n$A_0 u_0 + A_1 u_1 + A_2 u_2 + ...$\nWhere $A_i$'s are coefficients and $u_i$'s are my variables at nodes in my nodeset",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7134881",
                          "updatedAt": "2023-09-28T14:31:03Z",
                          "publishedAt": "2023-09-28T14:11:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah ok then what does A depend on?",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135171",
                          "updatedAt": "2023-09-28T14:34:24Z",
                          "publishedAt": "2023-09-28T14:34:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "It's a constant coefficient particular to the node.",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135209",
                          "updatedAt": "2023-09-28T14:36:57Z",
                          "publishedAt": "2023-09-28T14:36:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "So each node in the node set gets a different coefficient.",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135240",
                          "updatedAt": "2023-09-28T14:39:40Z",
                          "publishedAt": "2023-09-28T14:39:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "where do you know them?\nare they in a file?",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135316",
                          "updatedAt": "2023-09-28T14:46:26Z",
                          "publishedAt": "2023-09-28T14:46:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "For my case there will only be just a few, so I'm thinking about inputting them as parameters in the input file",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135347",
                          "updatedAt": "2023-09-28T14:47:48Z",
                          "publishedAt": "2023-09-28T14:47:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think a function makes sense here. And it has plenty of flexibility for the input.\nyou can bake in a space dependence fairly easily.\nwhat does that variation depend on? Are they different coefficients per subdomain?",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135656",
                          "updatedAt": "2023-09-28T15:16:06Z",
                          "publishedAt": "2023-09-28T15:16:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "I'm thinking if, since the pps will be boundary-restricted, getting the current node id (_current_node->id()), find its position in the nodeset, then apply the coefficient at the same position in the input vector of values. Does that make sense?",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135675",
                          "updatedAt": "2023-09-28T15:18:18Z",
                          "publishedAt": "2023-09-28T15:18:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "No variation in the coefficients, they would be constant in space and time.",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135690",
                          "updatedAt": "2023-09-28T15:19:22Z",
                          "publishedAt": "2023-09-28T15:19:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I don\u2019t think nodes are ordered within a node set. How are you ordering them?\nIf the coefficient depends on the node, it depends on space right?",
                          "url": "https://github.com/idaholab/moose/discussions/25616#discussioncomment-7135783",
                          "updatedAt": "2023-09-28T15:30:07Z",
                          "publishedAt": "2023-09-28T15:30:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "HeatConduction",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "All,\nMy input includes;\n[./heat_conduction]\ntype = HeatConduction # The declaration of heat conduction model\nvariable = temperature\nblock = 1\n[../]\nThen, I got an error message;\nA 'HeatConduction' is not a registered object.\nIf you are trying to find this object in a dynamically loaded library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\nIn Makefile, I set as\nHEAT_CONDUCTION     := yes\nPlease help,\nS. Thomas",
          "url": "https://github.com/idaholab/moose/discussions/25649",
          "updatedAt": "2023-10-03T15:55:48Z",
          "publishedAt": "2023-10-03T01:21:55Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "did you recompile after enabling the heat_conduction module?\nyou may have to clean the repo before recompiling too (make clobberall)",
                  "url": "https://github.com/idaholab/moose/discussions/25649#discussioncomment-7171005",
                  "updatedAt": "2023-10-03T02:34:13Z",
                  "publishedAt": "2023-10-03T02:34:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you, Guillaume.\nI did \"clobberall\" and \"make -j 6.\" But it still does not work.\nI got a warning of\n*** Warning, This code is deprecated and will be removed in future versions:\n\"registerAll\" in Modules is deprecated. Please update your *App.C file(s) to call the new templated \"registerAllObjects\" method (e.g. ModulesApp::registerAllObjects<MyApp>(...))\n\nI am ignoring it now but does it matter?\nPlease help. S. Thomas",
                          "url": "https://github.com/idaholab/moose/discussions/25649#discussioncomment-7177458",
                          "updatedAt": "2023-10-03T15:54:58Z",
                          "publishedAt": "2023-10-03T15:54:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this warning can be ignored for now. But you'll have to fix it one day.\nThe message is fairly explicit, you need to change that registerAll call to a registerAllObject<.  your app name >",
                          "url": "https://github.com/idaholab/moose/discussions/25649#discussioncomment-7177468",
                          "updatedAt": "2023-10-03T15:55:49Z",
                          "publishedAt": "2023-10-03T15:55:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Implementing a set of equations",
          "author": {
            "login": "gj19866"
          },
          "bodyText": "Hi all,\nI would just like to check that my understanding of how MOOSE works is correct before I get really stuck into debugging my code.\nI am trying to solve a rather nasty set of equations, for variables $\\psi_R$, $\\psi_I$, $\\Phi$, and $\\underline{j}$:\n\n\n$$0=-u \\sqrt{1+\\gamma^2\\left(\\psi_R^2+\\psi_I^2\\right)}\\left(\\frac{\\partial}{\\partial t} \\psi_R-\\varphi \\psi_I\\right)+\\nabla^2 \\psi_R-\\gamma^2 \\psi_I \\nabla^2 \\varphi+\\left(1-\\psi_R^2-\\psi_I^2\\right) \\psi_R$$\n\n\n$$0=-u \\sqrt{1+\\gamma^2\\left(\\psi_R^2+\\psi_I^2\\right)}\\left(\\frac{\\partial}{\\partial t} \\psi_I+\\varphi \\psi_R\\right)+\\nabla^2 \\psi_I+\\gamma^2 \\psi_R \\nabla^2 \\varphi+\\left(1-\\psi_R^2-\\psi_I^2\\right) \\psi_I$$\n\n\n$$0=\\nabla^2 \\varphi-\\psi_R \\nabla^2 \\psi_I+\\psi_I \\nabla^2 \\psi_R$$\n\n\n$$0=\\underline{j}+\\nabla \\varphi-\\psi_R \\nabla \\psi_I+\\psi_I \\nabla \\psi_R$$\n\n\nTo do this I have written one kernel for each equation to solve them.\nAs I have 4 variables, I have to pick a variable for each equation to solve for, but it is arbitrary which I choose, as long as each variable has at least one active kernel. (is this correct?)\nThe other variables in the equation need to be coupled in as adCoupledValue etc. (is this correct?)\nFor example, the kernel for equation two is:\n#include \"eq66Im.h\"\n#include <cmath>\n\nregisterMooseObject(\"SCResApp\", eq66Im);\n\nInputParameters\neq66Im::validParams()\n{\n  InputParameters params = ADKernel::validParams();\n  params.addClassDescription(\n      \"Kernel representing Im component of eq66 of bible. Variable is Psi_Re.\");\n  params.addCoupledVar(\"Psi_Im\",\n                       \"Imaginary component of Psi\");\n  params.addCoupledVar(\"Phi\",\n                       \"Phi\");\n  params.addParam<MaterialPropertyName>(\n      \"ucon\", \"ucon\", \"u from eq66\");\n  params.addParam<MaterialPropertyName>(\n      \"gamma\", \"gamma\", \"gamma from eq66\");\n  return params;\n}\n\neq66Im::eq66Im(const InputParameters & parameters)\n  : ADKernel(parameters),\n    _Psi_Im(adCoupledValue(\"Psi_Im\")),\n    _grad_Psi_Im(adCoupledGradient(\"Psi_Im\")),\n    _Psi_Im_dot(adCoupledDot(\"Psi_Im\")),\n    _Phi(adCoupledValue(\"Phi\")),\n    _grad_Phi(adCoupledGradient(\"Phi\")),\n    _ucon(getADMaterialProperty<Real>(\"ucon\")),\n    _gamma(getADMaterialProperty<Real>(\"gamma\"))\n{\n}\n\nADReal\neq66Im::computeQpResidual()\n{\n\n//    part1 = (_test[_i][_qp] * (-_ucon[_qp] * sqrt(1+ _gamma[_qp] * _gamma[_qp] * (_u[_qp] * _u[_qp] + _Psi_Im[_qp] * _Psi_Im[_qp])) ) * (_Psi_Im_dot[_qp] + _Phi[_qp] * _u[_qp]));\n\n//    part2 = (_grad_test[_i][_qp] * (- _grad_Psi_Im[_qp]));\n\n//    part3 = (_grad_test[_i][_qp] * (- _gamma[_qp] * _gamma[_qp] *  _u[_qp] * _grad_Phi[_qp]));\n\n//    part4 = (_test[_i][_qp] * (1 - _u[_qp] * _u[_qp] - _Psi_Im[_qp] * _Psi_Im[_qp]) * _Psi_Im[_qp]);\n\n  return  (_test[_i][_qp] * (-_ucon[_qp] * sqrt(1+ _gamma[_qp] * _gamma[_qp] * (_u[_qp] * _u[_qp] + _Psi_Im[_qp] * _Psi_Im[_qp])) ) * (_Psi_Im_dot[_qp] + _Phi[_qp] * _u[_qp])) + (_grad_test[_i][_qp] * (- _grad_Psi_Im[_qp])) + (_grad_test[_i][_qp] * (- _gamma[_qp] * _gamma[_qp] *  _u[_qp] * _grad_Phi[_qp])) +  (_test[_i][_qp] * (1 - _u[_qp] * _u[_qp] - _Psi_Im[_qp] * _Psi_Im[_qp]) * _Psi_Im[_qp]);\n\n}\n\nDoes this look like I'm doing the right thing?\nIs this the correct way to approach the problem?\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/25639",
          "updatedAt": "2023-10-03T13:02:37Z",
          "publishedAt": "2023-10-02T12:49:59Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nAs I have 4 variables, I have to pick a variable for each equation to solve for, but it is arbitrary which I choose, as long as each variable has at least one active kernel. (is this correct?)\n\nYes, but this choice is consequential. This will determine what is on-diagonal and off-diagonal in the linearized system matrices that you solve during the linear steps of the nonlinear solve.\nA good idea is to make sure to have big diagonals for every variable.\n\nThe other variables in the equation need to be coupled in as adCoupledValue etc. (is this correct?)\n\ncorrect.\n\nDoes this look like I'm doing the right thing?\n\nI think the idea is right, though:\n\ni think the integration by parts for term 3 is not correct\nwe usually split each term on a per-kernel basis. It just improves the code re-use.\n\nTo verify your implementation, I would set 3 of the 4 variables to known functions, and solve for the 4th by hand. Then make sure the solver can solve each of these single equations.\nTo set a variable, use an auxiliary variable and a FunctionIC",
                  "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7165740",
                  "updatedAt": "2023-10-02T14:20:12Z",
                  "publishedAt": "2023-10-02T14:20:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "Amazing thank you GiudGiud! What is wrong with the 3rd term in the equation, please?\nThank you for all the help!",
                          "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7166935",
                          "updatedAt": "2023-10-02T16:01:02Z",
                          "publishedAt": "2023-10-02T16:01:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "integration by parts of\npsi_r div_grad_phi test\nleads to\ngrad_phi * (grad_psi_r test + grad_test * psi_r)\nand you only have\n_grad_test[_i][_qp] * _u[_qp] * _grad_Phi[_qp])\nso missing one term?",
                          "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7170041",
                          "updatedAt": "2023-10-02T23:23:35Z",
                          "publishedAt": "2023-10-02T23:23:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "Ah yes, I understand now.\nI had tried implementing the weak form as in https://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial01_app_development/step04_weak_form.html#:~:text=Procedure%20for%20Generating%20Weak%20Forms&text=Write%20down%20the%20strong%20form,rule%20to%20separate%20the%20terms but I see that I was performing the product rule incorrectly!\nThank you very much GiudGiud, you have made a really big difference for me! I really appreciate all your help!",
                          "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7173416",
                          "updatedAt": "2023-10-03T09:00:31Z",
                          "publishedAt": "2023-10-03T09:00:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "I have now corrected and implemented all of these, but it's really struggling to converge.\nWhat is the best plan of attack to fix the convergence issues?",
                          "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7175324",
                          "updatedAt": "2023-10-03T12:47:48Z",
                          "publishedAt": "2023-10-03T12:47:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This plan\nhttps://mooseframework.inl.gov/moose/application_usage/failed_solves.html",
                          "url": "https://github.com/idaholab/moose/discussions/25639#discussioncomment-7175507",
                          "updatedAt": "2023-10-03T13:02:38Z",
                          "publishedAt": "2023-10-03T13:02:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Moving precipitates at grain boundaries",
          "author": {
            "login": "mdh23rct"
          },
          "bodyText": "Dear MOOSE experts,\nHope you are doing great! Currently, I am trying to simulate moving spherical precipitates in grain boundaries. For that I have to include:\n\nMultiple precipitates moving along the grain boundaries.\nprecipitate-precipitate interaction and precipitate-grain boundary interaction.\n\nI am planning to use the phase-field module for that. Would you be kind to advice me any particular tutorials I could follow.\nAlso do I need to combine any other module for that!\nI would appreciate your advice.\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/25563",
          "updatedAt": "2023-10-02T21:18:58Z",
          "publishedAt": "2023-09-23T17:22:14Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen",
                  "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7091534",
                  "updatedAt": "2023-09-24T01:45:29Z",
                  "publishedAt": "2023-09-24T01:45:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "Dear Dr. Guillaume,\nI am currently trying to simulate random formation of precipitates in a polycrystal using phase field. However, when I run the random formation code, I am seeing some boundary problems. The nucleation is happening at the outer boundaries (not the grain boundaries) of the computational domain, specially at the junction between grains. This seems to be some sort of computational error. For your convenience, I have attached the image of boundary problem and mesh in this mail.\n\n\nI am also attaching the random nucleation code I am using.\n[Modules]\n    [./PhaseField]\n      [./Conserved]\n        [./c]\n          free_energy = F\n          mobility = M\n          kappa = kappa_c\n          solve_type = REVERSE_SPLIT\n        [../]\n      [../]\n    [../]\n  []\n  \n  [ICs]\n    [./c_IC]\n      type = ConstantIC\n      variable = c\n      value = 0.2\n    [../]\n  []\n  \n  [Materials]\n    [./pfmobility]\n      type = GenericConstantMaterial\n      prop_names  = 'M kappa_c'\n      prop_values = '1 25'\n    [../]\n    [./chemical_free_energy]\n      # simple double well free energy\n      type = DerivativeParsedMaterial\n      property_name = Fc\n      coupled_variables = 'c'\n      constant_names       = 'barr_height  cv_eq'\n      constant_expressions = '0.1          0'\n      expression = 16*barr_height*c^2*(1-c)^2 #+0.01*(c*plog(c,0.005)+(1-c)*plog(1-c,0.005))\n      derivative_order = 2\n      outputs = exodus\n    [../]\n    [./probability]\n      # This is a made up toy nucleation rate it should be replaced by\n      # classical nucleation theory in a real simulation.\n      type = ParsedMaterial\n      property_name = P\n      coupled_variables = c\n      expression = 'if(c<0.21,c*1e-8,0)'\n      outputs = exodus\n    [../]\n    [./nucleation]\n      # The nucleation material is configured to insert nuclei into the free energy\n      # tht force the concentration to go to 0.95, and holds this enforcement for 500\n      # time units.\n      type = DiscreteNucleation\n      property_name = Fn\n      op_names  = c\n      op_values = 0.90\n      penalty = 5\n      penalty_mode = MIN\n      map = map\n      outputs = exodus\n    [../]\n    [./free_energy]\n      # add the chemical and nucleation free energy contributions together\n      type = DerivativeSumMaterial\n      derivative_order = 2\n      coupled_variables = c\n      sum_materials = 'Fc Fn'\n    [../]\n  []\n  \n  [UserObjects]\n    [./inserter]\n      # The inserter runs at the end of each time step to add nucleation events\n      # that happened during the timestep (if it converged) to the list of nuclei\n      type = DiscreteNucleationInserter\n      hold_time = 50\n      probability = P\n      radius = 1\n    [../]\n    [./map]\n      # The map UO runs at the beginning of a timestep and generates a per-element/qp\n      # map of nucleus locations. The map is only regenerated if the mesh changed or\n      # the list of nuclei was modified.\n      # The map converts the nucleation points into finite area objects with a given radius.\n      type = DiscreteNucleationMap\n      periodic = c\n      inserter = inserter\n    [../]\n  []\n  \n  [Preconditioning]\n    [./SMP]\n      type = SMP\n      full = true\n    [../]\n  []\n  \n  [BCs]\n    [./Periodic]\n      [./all]\n        auto_direction = 'x y'\n      [../]\n    [../]\n  []\n  \n  [Postprocessors]\n    [./dt]\n      type = TimestepSize\n    [../]\n    [./ndof]\n      type = NumDOFs\n    [../]\n    [./rate]\n      type = DiscreteNucleationData\n      value = RATE\n      inserter = inserter\n    [../]\n    [./dtnuc]\n      type = DiscreteNucleationTimeStep\n      inserter = inserter\n      p2nucleus = 0.0005\n      dt_max = 10\n    [../]\n    [./update]\n      type = DiscreteNucleationData\n      value = UPDATE\n      inserter = inserter\n    [../]\n    [./count]\n      type = DiscreteNucleationData\n      value = COUNT\n      inserter = inserter\n    [../]\n  []\n  \n  [Adaptivity]\n    [./Indicators]\n      [./jump]\n        type = GradientJumpIndicator\n        variable = c\n      [../]\n    [../]\n    [./Markers]\n      [./nuc]\n        type = DiscreteNucleationMarker\n        map = map\n      [../]\n      [./grad]\n        type = ValueThresholdMarker\n        variable = jump\n        coarsen = 0.1\n        refine = 0.2\n      [../]\n      [./combo]\n        type = ComboMarker\n        markers = 'nuc grad'\n      [../]\n    [../]\n    marker = combo\n    cycles_per_step = 3\n    recompute_markers_during_cycles = true\n    max_h_level = 3\n  []\n  \n  [Executioner]\n    type = Transient\n    scheme = bdf2\n    solve_type = 'PJFNK'\n    petsc_options_iname = '-pc_type -sub_pc_type'\n    petsc_options_value = 'asm      lu          '\n  \n    nl_max_its = 100\n    l_tol = 1.0e-4\n    nl_rel_tol = 1.0e-9\n    nl_abs_tol = 1.0e-9\n    start_time = 0.0\n    end_time = 4000\n  \n    [./TimeStepper]\n      type = IterationAdaptiveDT\n      dt = 10\n      growth_factor = 1.5\n      cutback_factor = 0.5\n      optimal_iterations = 8\n      iteration_window = 2\n      timestep_limiting_postprocessor = dtnuc\n    [../]\n  []\n  \n  [Outputs]\n    exodus = true\n    csv = true\n    print_linear_residuals = false\n  []\n\nWould you be kind to let me know if I am missing something in the code to remove this boundary issues? Or the definition of the BCs is wrong in these code? I would appreciate your advice.\nBest regards.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7147498",
                          "updatedAt": "2023-09-29T18:44:17Z",
                          "publishedAt": "2023-09-29T18:42:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This looks like a poor interaction between adaptivity and periodic boundary conditions.\nCan you try to run the code in debug module (recompile with METHOD=debug make -j4) to see if you get an error?\nElse would you consider turning off adaptivity near the borders? You d have to make a custom indicator probably",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7147522",
                          "updatedAt": "2023-09-29T18:46:10Z",
                          "publishedAt": "2023-09-29T18:46:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "Dear Dr. Guillaume,\nThank you for your reply. Since I am a newbie in MOOSE, please don't be annoyed by my questions:\n\nHow I can turn off adaptivity near the borders? As far as I guess, I have to generate a specific block (excluding the border regions), for which the adaptivity will be applied. Maybe you know better ways to do it? Please be aware that the mesh is irregular and not symmetric. Therefore, I exactly don't know how I can generate this mesh block!!\nHow to make a custom indicator for the border region? The same way as it is done for the whole domain??\n\nIf you have any tutorials regarding these, I would be happy if you can forward.\nI would appreciate your reply. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7147737",
                          "updatedAt": "2023-09-29T19:18:18Z",
                          "publishedAt": "2023-09-29T19:18:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the mesh is irregular and not symmetric\n\nit s periodic though right? If it s not periodic, the periodic BCs will fail",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7147762",
                          "updatedAt": "2023-09-29T19:21:52Z",
                          "publishedAt": "2023-09-29T19:21:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "Yes, the mesh is periodic. However, mesh adaptivity has some issue with the periodic boundary condition. If I turn off the periodic boundary condition, the border problem disappears.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7158708",
                          "updatedAt": "2023-10-01T17:21:03Z",
                          "publishedAt": "2023-10-01T17:21:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@roystgnr do we support adaptivity with a periodic mesh that becomes non-periodic with adaptivity?",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7158905",
                          "updatedAt": "2023-10-01T18:04:26Z",
                          "publishedAt": "2023-10-01T18:04:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "We definitely should support consistently combined constraints when using adaptivity with a periodic mesh.  git grep -l auto_direction | xargs grep -l Adaptivity shows a few dozen test files (mostly in the phase field module) using both.\nThe results here are obviously a non-physical bug, and almost certainly due to some adaptivity+periodicity interaction, but I don't understand what \"extra\" is going on that we're not covering in regression tests.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7165984",
                          "updatedAt": "2023-10-02T14:41:56Z",
                          "publishedAt": "2023-10-02T14:41:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Hi @mdh23rct , if you want to insert nuclei at grain boundaries, you are going to need to modify this example- right now you are setting c = 0.2 everywhere in the initial conditions, and then making the nucleation probability uniformly high everywhere c < 0.21. So, there is nothing that makes the nucleation localized to GBs as far as I can tell. I am not sure why it seems to be happening at the domain boundaries first, but the problem is not set up to capture the physics you want so I would start by trying to correct that. How are the grain boundaries represented in your simulation? It seems that you are running on a mesh that is refined near GBs, but that is not enough to represent the grain boundaries in the simulation. Normally we do this by adding some additional order parameters to represent the presence of the grains.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7166124",
                          "updatedAt": "2023-10-02T14:54:04Z",
                          "publishedAt": "2023-10-02T14:54:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "Dear Dr. Larry,\nI appreciate your reply.\n\nWe did SEM on the specimens. We are seeing carbide formation predominantly at the grain boundaries. That means carbon is diffusing to the grain boundaries.\nOk, I will modify the file as you adviced, and keep you updated.\n\nThanks for your time and support. I appreciate.",
                          "url": "https://github.com/idaholab/moose/discussions/25563#discussioncomment-7169456",
                          "updatedAt": "2023-10-02T21:19:00Z",
                          "publishedAt": "2023-10-02T21:18:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ValidParams error",
          "author": {
            "login": "zahidhasan83"
          },
          "bodyText": "Dear MOOSE people,\nHope you are doing great! I am currently building a new app based on an old app coded by one of my colleagues three years back.\nWhile running the make file, it shows me the error:\nLinking Executable /home/user/projects/plasma/plasma-opt...\n/home/user/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.4.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/user/projects/plasma/lib/libplasma-opt.so: undefined reference to `InputParameters validParams<Material>()'\n/home/user/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.4.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/user/projects/plasma/lib/libplasma-opt.so: undefined reference to `InputParameters validParams<Kernel>()'\ncollect2: error: ld returned 1 exit status\nmake: *** [/home/user/projects/moose/framework/app.mk:445: /home/user/projects/plasma/plasma-opt] Error 1\n\n\nI believe, the code is using out-of-date style, or something is missing in the material and kernel of the source file. Do you have any suggestion, how I could solve this problem? For you convenience, I am adding part of the source file:\n#include \"PhaseFieldMaterial.h\"\n\nregisterMooseObject(\"plasmaApp\", PhaseFieldMaterial);\n\ntemplate <>\nInputParameters\nvalidParams<PhaseFieldMaterial>()\n{\n  InputParameters params = validParams<Kernel>();\n  params.addClassDescription(\n      \"Transforms a material property into a kernel value (including off-diagonal terms.\");\n  params.addRequiredParam<MaterialPropertyName>(\"mat_function\",\"The material property name\");\n  params.addCoupledVar(\"args\", \"Vector of arguments that the material property depends on.\");\n  return params;\n}\n\nPhaseFieldMaterial::PhaseFieldMaterial(const InputParameters & parameters)\n  : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n    _K(getMaterialProperty<Real>(\"mat_function\")),\n    _dKdu(getMaterialPropertyDerivative<Real>(\"mat_function\", _var.name())),\n    _nvar(_coupled_moose_vars.size()),\n    _dKdarg(_nvar)\n{\n  // Get rate derivatives wrt args\n  for (unsigned int i = 0; i < _nvar; ++i)\n    _dKdarg[i] = &getMaterialPropertyDerivative<Real>(\"mat_function\", _coupled_moose_vars[i]->name());\n}\n\nBest regards.",
          "url": "https://github.com/idaholab/moose/discussions/25645",
          "updatedAt": "2023-10-02T21:09:22Z",
          "publishedAt": "2023-10-02T20:57:11Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSee this annoucement for this hard deprecation we performed over a couple years\nhttps://mooseframework.inl.gov/newsletter/2021/2021_11.html#legacy-input-parameter-deprecation\nYou ll need to update all the objects that use the old declaration / definition for parameters\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25645#discussioncomment-7169362",
                  "updatedAt": "2023-10-02T21:02:26Z",
                  "publishedAt": "2023-10-02T21:02:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zahidhasan83"
                          },
                          "bodyText": "Dear Dr. Guillaume,\nThanks. I will update the objects as you advised. If still I find any issue, your advice will be appreciated.\nUntil then, all the very best.",
                          "url": "https://github.com/idaholab/moose/discussions/25645#discussioncomment-7169401",
                          "updatedAt": "2023-10-02T21:09:22Z",
                          "publishedAt": "2023-10-02T21:09:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}