{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNC0yM1QwMzoyOTowMS0wNTowMM4AMpzG"
    },
    "edges": [
      {
        "node": {
          "title": "Proper use of InterfaceKernels",
          "author": {
            "login": "ke7kto"
          },
          "bodyText": "I'm modeling a diffusion process with a vapor-solid interface and a temperature gradient in one dimension. This seems like a very good fit for InterfaceKernels, but I cannot obtain a steady-state solve using InterfaceDiffusionBoundaryTerm, InterfaceDiffusionFluxMatch or a combination of the two in any event such that concentrations are greater than zero at the interface.\nTaking out the interface and setting making the variable representing molar quantity the same in each subdomain allows for a solve. The reaction_1D_steady test solves successfully on my installation.\nI hate asking \"what am I doing wrong?\" questions, but I'm really stuck here. How do I use the InterfaceKernels properly? I have attached the input file I'm using.\nsimple.txt",
          "url": "https://github.com/idaholab/moose/discussions/17628",
          "updatedAt": "2022-08-10T00:39:34Z",
          "publishedAt": "2021-04-16T20:59:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad Can you help with this question?",
                  "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-640541",
                  "updatedAt": "2022-08-10T00:39:45Z",
                  "publishedAt": "2021-04-21T15:03:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "It turns out that I have an issue which seems to be unrelated to InterfaceKernels. I'll update when I've isolated the root of the problem.",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-641063",
                          "updatedAt": "2022-08-10T00:39:45Z",
                          "publishedAt": "2021-04-21T16:56:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "There are four issues with the input file that prevent convergence\n\nThe initial condition for temperature was not close enough to the solution\nline 173 uses an expression that evaluates to log(0) at x=0\nThe boundary condition for line 122 is set to the wrong variable\nThere seems to be an issue with using 'exp' in parsedFunction to generate a material property. I can get convergence when I use a custom Material class using the same function",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-641176",
                          "updatedAt": "2022-08-10T00:39:45Z",
                          "publishedAt": "2021-04-21T17:18:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "So are the InterfaceKernels you're using working as desired with the resolution of your issues 1-4?",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-641283",
                          "updatedAt": "2022-08-10T00:39:46Z",
                          "publishedAt": "2021-04-21T17:41:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "Good question. They're not working as I would have expected them to, but I could be misinterpreting the way that they are supposed to work. Is the InterfaceDiffusionBoundaryTerm supposed to apply to diffusion within the interface, across the boundary, or both?\nWhat I find most puzzling is that the observed concentration difference across the interface changes direction when I switch between radial and cartesian coordinates. I've made a new input file without the previous problems (and removing the temperature dependence), which is attached.\nsimplenoT.txt",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-641676",
                          "updatedAt": "2023-04-28T20:20:11Z",
                          "publishedAt": "2021-04-21T19:18:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "I'm not sure I was very clear. I do not think that the InterfaceKernels are working properly. Here's why:\nThe file I've attached has Dirichlet boundary conditions as follows:\n\nConcentration 0.16 @ x=0\nConcentration 0 @ x=0.031782\n\nThere is an interface at x=0.0061625. Everything is in 1D. I'm using InterfaceDiffusionBoundaryTerm and InterfaceDiffusionFluxMatch.\n\n\nDiffusivity is set to 10\u207b\u2075 throughout both subdomains. If D or D_neighbor are set to any value other than the diffusivity of the bulk, a no-flux solution is obtained.\n\n\nFor cartesian coordinates and boundary diffusivities of 10\u207b\u2075, there is a jump to a concentration of ~0.65 on the right-hand side of the interface, which seems to be in error.\n\n\nWith coord_type = RZ and rz_coord_axis = Y (radially symmetric 1D diffusion) the results are more believable, with a concentration drop from ~0.055 to ~0.027 across the interface - though if I understand correctly, the concentrations on either side should be equal for this situation.",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-646942",
                          "updatedAt": "2023-04-28T20:20:11Z",
                          "publishedAt": "2021-04-22T20:34:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "The solution is also dependent on the number of elements",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-647003",
                          "updatedAt": "2022-10-03T02:53:32Z",
                          "publishedAt": "2021-04-22T20:55:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Sorry for being slow to respond @ke7kto. I have to say that I've looked at this pair of interface kernels before and it took me a fair while to understand what they are doing in a finite element sense. And it's been long enough since then that I've forgotten again. @dschwen is the author of those objects so maybe he can explain them.\nI will say that I am a fan of PenaltyInterfaceDiffusion which is actually a test object for the framework. I think we should probably move it into the framework so users have access to that object. But you are welcome to copy those sources for your own app. PenaltyInterfaceDiffusion simultaneously enforces equal flux across an interface and solution continuity as well. It also preserves the optimal convergence rate of your finite element method, e.g. second order if you are using first order Lagrange bases, given an appropriate choice of penalty parameter (for well scaled problems something like 1e6 is a good choice).",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-666785",
                          "updatedAt": "2022-10-03T02:53:32Z",
                          "publishedAt": "2021-04-27T22:16:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "@lindsayad Thanks for the reply! Using PenaltyInterfaceDiffusion, I get a good solve, the results are in line with expectations. For my specific problem 1e6 was too large a penalty, values from 1.0-1e5 worked well. Is there a straightforward way I could check the matrix properties to get an idea of the appropriate scale for the penalty parameter in general?\nAlso, looking at PenaltyInterfaceDiffusion, It seems I can specify a material property to calculate what the discontinuity should be. Is there a way to define a material on an interface, especially as dependent on the difference of some variable on either side of the interface? I would need some functionality like that for the non-toy version of this problem.",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-666898",
                          "updatedAt": "2022-10-03T02:53:32Z",
                          "publishedAt": "2021-04-27T22:58:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@lindsayad Thanks for the reply! Using PenaltyInterfaceDiffusion, I get a good solve, the results are in line with expectations. For my specific problem 1e6 was too large a penalty, values from 1.0-1e5 worked well. Is there a straightforward way I could check the matrix properties to get an idea of the appropriate scale for the penalty parameter in general?\n\nIt should at least be as large as your other diagonals, probably larger. It's a balance between how close to continuous you want the solution to be and how well conditioned you want your matrix to be. Matching the diagonals will give you the best conditioning but may not make your solution as close to continuous as you want (or maybe it does!). You can always inspect your matrix using the -ksp_view_pmat command line option (this is consumed by PETSc). You probably only want to use that option if your problem is reasonably small.\n\nAlso, looking at PenaltyInterfaceDiffusion, It seems I can specify a material property to calculate what the discontinuity should be. Is there a way to define a material on an interface, especially as dependent on the difference of some variable on either side of the interface? I would need some functionality like that for the non-toy version of this problem.\n\nYou are looking for an InterfaceMaterial. You can find an example of just your use case in moose/test/src/materials/JumpInterfaceMaterial.C",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-672212",
                          "updatedAt": "2022-10-03T02:53:33Z",
                          "publishedAt": "2021-04-28T21:29:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "This is exactly what I needed. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/17628#discussioncomment-672350",
                          "updatedAt": "2022-10-03T02:53:40Z",
                          "publishedAt": "2021-04-28T21:54:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Grain growth from existing mesh file",
          "author": {
            "login": "aashiquear"
          },
          "bodyText": "I like to initialize a grain growth model from an existing mesh file (exodus format), that is already run a grain growth simulation for a while. I found there is an option in the PolycrystalVariables action \"initial_from_file = true\". Using that option I have setup a FileMeshGenerator Mesh and input the mesh file that I have already run for a while. This runs quite well for the first few steps but failed with an exit code 6 and a comment \"Refinement flags were not consistent between processors!\". Upon looking into the output I found, it initializes the grains from the previous file but once it started running there is instability around the four borders. Is there any example out there where it uses the \"initial_from_file = true\" in PolycrystalVariable action? Here is the file I am trying to run:\ngrain_growth.txt",
          "url": "https://github.com/idaholab/moose/discussions/17695",
          "updatedAt": "2022-10-06T16:19:36Z",
          "publishedAt": "2021-04-27T23:40:27Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "There are known issues with reading in a solution from an exodus file where adaptivity has been used. Generally we prefer to restart from either a checkpoint file or one of the libMesh formats (XDA/XDR). You might try outputting those and see if you can get it going (start with a small test case to avoid wasting time). Is this a restart case or are you creating a whole new simulation and just hoping to import some data from your previous simulation?",
                  "url": "https://github.com/idaholab/moose/discussions/17695#discussioncomment-670214",
                  "updatedAt": "2022-10-06T16:19:36Z",
                  "publishedAt": "2021-04-28T14:18:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aashiquear"
                          },
                          "bodyText": "Right now I am trying a restart case, but eventually what I required is to run a whole new grain growth simulation using the grain structure generated from the previous file. I am running a simultaneous grain growth and another physics using a multiapp to see the effect of the other physics when grain migrated. If I start from voronoi IC the grain growth starts slow as it equilibrates to the GB width first and I failed to capture the initial effect as my other physics thinking the grain structure as static in the beginning. So, what I am trying to capture here is that both the script in multiapp calibrated in such that the initial GB width equilibration doesn't require and grain migration starts right away. After yesterday, I have run the same file I submit here using a single processor and can run the full simulation without failing. I get what I was looking for but there is instability (like the order parameter fluctuates) around the domain border still present. I am going to check with outputting in XDA format and re-reading the file in the new simulation. Please share your idea if there is a better (and easy) way of doing the same. Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/17695#discussioncomment-670357",
                          "updatedAt": "2022-10-06T16:19:57Z",
                          "publishedAt": "2021-04-28T14:44:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "There is some low hanging fruit in terms of optimizing and fixing some of the initial condition behavior of simulations with large numbers of variables. We already have this on our todo list, however being aware that others are needing this may help to bump priority.\n@fdkong",
                          "url": "https://github.com/idaholab/moose/discussions/17695#discussioncomment-670370",
                          "updatedAt": "2022-10-06T16:19:59Z",
                          "publishedAt": "2021-04-28T14:45:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Applying constraints",
          "author": {
            "login": "KhaledNabilSharafeldin"
          },
          "bodyText": "Hello,\nI am quite new to MOOSE and I have a lot of questions, but I will start with these here.\n\nIs there a way that I can access and manipulate the stiffness matrix before solving for the unknowns?\nHow are the constraints are enforced? Do you use penalty method?\nIs there an implementation for lagrange multiplier that relates the unknown variables to each other? If not, do you have recommendation where to start implementing it?\n\nWhat I am trying to do is to apply some constraint relations between the unknown variables (displacement), for instance, if I\u2019m solving for u, then I want u^1=u^2+u^3, where the numbers are node numbers. As you can see, this should decrease the problem DOF, but I am not sure exactly how to do so in MOOSE. Some of these constraints are in relation to the face nodes (up and down) and edges nodes and so on.\nThank you in advance\nKhaled",
          "url": "https://github.com/idaholab/moose/discussions/17455",
          "updatedAt": "2022-06-02T08:45:11Z",
          "publishedAt": "2021-03-29T21:35:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "How are the constraints are enforced? Do you use penalty method?\n\nThe most typical forms of constraints (periodic boundary conditions, hanging nodes on adaptively refined meshes, and Dirichlet boundary conditions) are almost always enforced directly; we have a constraint matrix C that turns a Jacobian K into C^T*K*C (and consistently modifies the residual, and may add terms corresponding to heterogeneous offsets for non-zero Dirichlet conditions).\nThat's not as easy to do with nonlinear constraints, though.  For those we typically use a penalty term or a Lagrange multiplier.  For a penalty method, there might be some classes in include/constraints/ that would be helpful - e.g. although the TiedValueConstraint only does a simple equality constraint (made less simple by the fact that it can enforce equality in contact problems that don't line up precisely node to node), the kernel is straightforward enough and you could try adding your own subclass with a nonlinear kernel.  For a Lagrange multiplier method, perhaps the mortar method code would be the best example?",
                  "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-640767",
                  "updatedAt": "2022-06-02T08:45:11Z",
                  "publishedAt": "2021-04-21T15:50:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "As you can see, this should decrease the problem DOF\n\nAlmost forgot - I'm afraid this isn't the case for us.  Not only does a penalty method leave DoF count the same and a Lagrange multiplier add additional DoFs, but even with direct enforcement of constraints we don't currently \"condense\" the linear system afterwards, we typically either leave constraint equations in the matrix rows corresponding to constrained DoFs, or we leave a 1 on the diagonal to keep those DoFs from causing solvers any difficulty and then we calculate the constrained DoF values directly after the solve is done.",
                          "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-640788",
                          "updatedAt": "2022-06-02T08:46:35Z",
                          "publishedAt": "2021-04-21T15:53:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "KhaledNabilSharafeldin"
                  },
                  "bodyText": "Hello @roystgnr Thank you for your reply! Since the time I have posted this I arrived at these questions:\n\nI started using LinearNodalConstraint for setting up these constraints using penalty method, but I have quite a few questions.\n\nThis constraint function inherits from NodalConstraint which has a formulation type parameter that is either penalty or kinematic. The kinematic one seems to be deleting the original residual for the secondary node, then adding in the new QpJacobian provided by the LinearNodalConstraint. So, I wanted to verify if this is the case; that it is possible to implement the direct method using this parameter while setting the _penalty to 1 and using the weight as a sign indicator. The total DoF number does not change since I am adding constraint functions in their place.\nThe way I am setting up these constraints is by passing 2 vectors; the secondary_nodes vector has only ONE node ID, while the primary has multiple node IDs corresponding to it. Is this the correct way to go through it? I just want to confirm this.\nFor the equation of the constraint itself, do all the variables should be on the RHS of the equation i.e., secondary-primary=0 (u^1-[ u^2+u^3]=0), or in the form of secondary=primary (u^1=u^2+u^3). This will affect the equation signs and I just would like to confirm it. From what I have seen in the NodalConstraint and LinearNodalConstraint, there\u2019s no sign switching going on, so I think it should be secondary-primary=0.\n\n\nDo node IDs numbering start from zero or 1? Because when visualizing the results, the global ID number starts from 1, but it seems like my Dirichlet BC are applied on a node ID 1 off from what I set it to. I am planning on using mesh pointers in the future, but it seems like it is going to take some time to get familiar with it and I have more questions about it, so I am not making it a priority right now. I am using mesh_renumbering flag to false to avoid any problems for now.\n\nThank you so much for taking the time to read this! Really appreciate your help!",
                  "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-660795",
                  "updatedAt": "2022-06-16T19:06:52Z",
                  "publishedAt": "2021-04-26T16:28:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "I'm afraid I'm going to have to punt on the NodalConstraint questions - I'm not personally familiar with those classes, and looking at https://mooseframework.inl.gov/source/constraints/LinearNodalConstraint.html is a bit dismaying; it looks like it was written by someone so deep in a solid mechanics rabbit hole that they weren't even thinking about the existence of a wider variety of variables.\nBut for the more libMesh-specific question:\n\nDo node IDs numbering start from zero or 1?\n\nYes!  Your node IDs can in general be zero-based, or one-based, or zero-based but with big gaps from adaptive mesh coarsening removing nodes, or sparse from communication-free parallel creation of new nodes ... libMesh supports all of that, which is nice if you want to use such capability but less nice if you wish you could assume nobody else is using that support.  Most commonly we use zero-based numbering, initially contiguous from most mesh generators (or from any mesh generator if you hadn't disabled node renumbering, which does a sweep at init/reinit times to eliminate any numbering gaps), but some output formats don't support zero as an ID (or don't support gaps in node numbers, or both) so we have to translate node numbers back and forth, and the node number you see in your debugger might not match the one you see in your viz program.",
                          "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-665368",
                          "updatedAt": "2022-06-16T19:07:07Z",
                          "publishedAt": "2021-04-27T16:33:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Just a quick comment here: the NodalConstraint works for general variables not just displacements in mechanics. I won't comment on whether the original developer is deep in the solid mechanics rabbit hole \ud83d\ude02",
                          "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-665500",
                          "updatedAt": "2022-06-16T19:07:07Z",
                          "publishedAt": "2021-04-27T17:05:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "But I agree -- some words in the documentation page might be misleading.",
                          "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-665504",
                          "updatedAt": "2022-06-16T19:07:07Z",
                          "publishedAt": "2021-04-27T17:06:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "well thank you both @roystgnr and @hugary1995 for the quick responses!\nWhat I am trying to actually do is to apply the minimal kinematic boundary condition... which seemed like a reasonable thing to do using those classes. I already did this but the \"results\" seems off, when using the penalty method the solution doesn't really converge, and for the kinematic, it doesn't even solve linearly giving off DIVERGED_NANORINF error.\nI can see that there is currently ongoing development for this by averaging either the microscopic P or F depending on the applied macroscopic quantities in this #17475\nI am still not sure exactly why the approach mentioned in this question wouldn't work, but I am looking forward for #17475 to be merged.",
                          "url": "https://github.com/idaholab/moose/discussions/17455#discussioncomment-668670",
                          "updatedAt": "2022-07-30T17:00:53Z",
                          "publishedAt": "2021-04-28T10:48:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "2021 March and April News",
          "author": {
            "login": "aeslaughter"
          },
          "bodyText": "We finally were able to get the updates to our newsletter merged, hopefully we will be back on track for more regular updates.\nMarch 2021 News\nApril 2021 News",
          "url": "https://github.com/idaholab/moose/discussions/17690",
          "updatedAt": "2021-04-27T15:03:39Z",
          "publishedAt": "2021-04-27T15:03:18Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Postprocessing Kernel Variables",
          "author": {
            "login": "prajwalka"
          },
          "bodyText": "Hi,\nI'm fairly new to Moose and had this question.\nIs there an equivalent of \"Material Property\" for kernels? I wanted to use \"declareProperty\" for a kernel variable and postprocess it using something like MaterialRankTwoAux kernel. I also wanted the value of this variable at the previous time step.\nFor example, in enhanced strain methods, the value of stress and strain obtained from the linear elastic material need to be modified at the kernel level using tensors depending on the quadrature point. Is there any way of outputting these modified stress and strain values which are stored in my kernel? Or is it preferred that this modification is done using a User Object or any other method?\nThanks a lot!",
          "url": "https://github.com/idaholab/moose/discussions/17681",
          "updatedAt": "2023-04-21T17:17:30Z",
          "publishedAt": "2021-04-26T18:46:07Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I would recommend you to write a material property that calculates the modified stress/strain.",
                  "url": "https://github.com/idaholab/moose/discussions/17681#discussioncomment-663714",
                  "updatedAt": "2023-04-21T17:17:34Z",
                  "publishedAt": "2021-04-27T10:02:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "You can also create a custom AuxKernel to perform a calculation that uses coupled in the solution variable. We have an example of this in our workshop presentation:\n\nThe slides are here https://mooseframework.inl.gov/workshop/#/28\nOur discussion about it is here: https://www.youtube.com/watch?v=2tJwBsYaLaI",
                          "url": "https://github.com/idaholab/moose/discussions/17681#discussioncomment-664824",
                          "updatedAt": "2023-04-21T17:17:34Z",
                          "publishedAt": "2021-04-27T14:59:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "New version of MOOSE computationally slower than older version",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Dear all,\nI was facing performance issues with current version of MOOSE as it seems to be slower than the older versions dated about an year ago. My plasticity model with ~5000 Dof's took nearly an hour of computational time, while the legacy code ran in roughly around 35mins. The related discussion can be traced back to [https://github.com//discussions/16372]. Unfortunately the compilers here are upgraded and hence i am unable to build the legacy sources now, which might have given a chance for me to check and re-confirm their time. Probably somebody there in the team could test the attached files (with older versions ranging around May 2020) and check if these can be run under an hour. Any insights on the possible reasons for the slower performance will be appreciated, as this may lead to a huge savings in time while conduting the iterative simulation that i am currently working upon.\n23042021.zip",
          "url": "https://github.com/idaholab/moose/discussions/17671",
          "updatedAt": "2022-06-15T15:08:21Z",
          "publishedAt": "2021-04-23T15:09:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Couple of questions:\n\ncould you let us the commit hash of the old MOOSE you referred to?\nare you running exactly the same input file and using the same number of processors?\nSince you use AD, you should set 'solve_type = Newton' instead of 'PJFNK'. Could you change the solver type and rerun it?",
                  "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-650687",
                  "updatedAt": "2022-06-15T15:08:21Z",
                  "publishedAt": "2021-04-23T16:00:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abarun22"
                  },
                  "bodyText": "Dear Wen,\nHere are my answers.\n              1) Could you let us the commit hash of the old MOOSE you\nreferred to?\n git log -1\n                commit 1cc6b7e\n                Merge: 314e8b9 6fd9c7f\n               Author: moosetest ***@***.***>\n               Date:   Mon May 18 17:31:13 2020 -0600\n              Merge commit '6fd9c7f846a43385430795ac9e971716d2218d1c'\n\n             2) Are you running exactly the same input file and using the\nsame number of processors?\n                 Yes the same input file and the same number of processors\n(#10)\n\n              3) Since you use AD, you should set 'solve_type = Newton'\ninstead of 'PJFNK'. Could you change the solver type and rerun it?\n                  I did try with Newton, but for some reasons it wouldn't\nrun at that time. Will give a try again and let you know.\n\nThe functional filename is different in the inputfile and so request you to\nset the actuals while running the computation.\n\n\nKind regards,\nArun\n\u2026\nOn Fri, Apr 23, 2021 at 5:00 PM Wen Jiang ***@***.***> wrote:\n Couple of questions:\n\n    1. could you let us the commit hash of the old MOOSE you referred to?\n    2. are you running exactly the same input file and using the same\n    number of processors?\n    3. Since you use AD, you should set 'solve_type = Newton' instead of\n    'PJFNK'. Could you change the solver type and rerun it?\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#17671 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AJSA254IZSIE55IBI25IRC3TKGKTLANCNFSM43O2KVQQ>\n .",
                  "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-651031",
                  "updatedAt": "2022-06-15T15:08:27Z",
                  "publishedAt": "2021-04-23T17:26:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I can reproduce @abarun22 's results.\nI slightly modified his input file to simplify things:\n[Mesh]\n  type = FileMesh\n  file = Specimen_QtrModel.e\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  volumetric_locking_correction = true\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    strain = FINITE\n    incremental = true\n    add_variables = true\n    use_automatic_differentiation = true\n  []\n[]\n\n[BCs]\n  [Load_RE]\n    type = FunctionDirichletBC\n    variable = disp_x\n    function = '0.0226*t'\n    boundary = \"Right_end\"\n    preset = false\n  []\n  [Symm_LE]\n    type = DirichletBC\n    variable = disp_x\n    value = 0\n    boundary = \"Left_end\"\n  []\n  [Symm_BY]\n    type = DirichletBC\n    variable = disp_y\n    value = 0.0\n    boundary = \"Bottom\"\n  []\n  [Symm_LZ]\n    type = DirichletBC\n    variable = disp_z\n    value = 0.0\n    boundary = \"Lateral_face\"\n  []\n  [Const_RY]\n    type = DirichletBC\n    variable = disp_y\n    value = 0.0\n    boundary = \"Right_end\"\n  []\n  [Const_RZ]\n    type = DirichletBC\n    variable = disp_z\n    value = 0.0\n    boundary = \"Right_end\"\n  []\n[]\n\n[Functions]\n  [hf]\n    type = PiecewiseLinear\n    data_file = PW_last_iter.csv\n    scale_factor = 1\n    format = columns\n  []\n[]\n\n[Materials]\n  [elasticity_tensor]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 2.02E+11\n    poissons_ratio = 0.315\n  []\n  [isotropic_plasticity]\n    type = ADIsotropicPlasticityStressUpdate\n    yield_stress = 554146341.5\n    hardening_function = hf\n  []\n  [radial_return_stress]\n    type = ADComputeMultipleInelasticStress\n    inelastic_models = 'isotropic_plasticity'\n  []\n[]\n\n[Postprocessors]\n  [nl_its]\n    type = NumNonlinearIterations\n  []\n  [time]\n    type = PerfGraphData\n    section_name = Root\n    data_type = TOTAL\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu       superlu_dist'\n\n  dt = 0.1\n  end_time = 25\n\n  nl_rel_tol = 1e-6\n  nl_max_its = 20\n\n  automatic_scaling = true\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  print_linear_residuals = false\n[]\n\nI use the same conda env to make a more fair comparison. Most important versions are:\nmoose-mpich               3.3.2                   build_5    idaholab\nmoose-petsc               3.14.2                  build_4    idaholab\nmoose-tools               2021.01.06                 py_0    idaholab\n\nNew moose (c7126c8) total run time: 449.5038 seconds\nOld moose (1cc6b7e) total run time: 296.3510 seconds\nThis may well be due to a simple config change or default option change. But I think there is value in tracking it down.",
                  "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652421",
                  "updatedAt": "2022-06-15T15:08:32Z",
                  "publishedAt": "2021-04-24T00:53:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "BTW, this is using 8 processors on my Ubuntu.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652424",
                          "updatedAt": "2022-06-15T15:08:27Z",
                          "publishedAt": "2021-04-24T00:55:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Which commit is causing this?",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652447",
                          "updatedAt": "2022-06-15T15:08:31Z",
                          "publishedAt": "2021-04-24T01:13:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I don't know. I haven't run any bisect nor any profiling yet.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652448",
                          "updatedAt": "2022-06-15T15:08:27Z",
                          "publishedAt": "2021-04-24T01:15:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Gary can you see whether changing to nonsparse changes things? (I\u2019m guessing you were running with default sparse crowd config?)",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652574",
                          "updatedAt": "2022-09-22T08:48:45Z",
                          "publishedAt": "2021-04-24T03:12:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "I don't know. I haven't run any bisect nor any profiling yet.\n\n@hugary1995 There are definitely some changes inADComputeMultipleInelasticStress, which also might cause this issue.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652582",
                          "updatedAt": "2022-09-22T08:48:45Z",
                          "publishedAt": "2021-04-24T03:19:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "@lindsayad Yeah I was running with default config. When I try to switch to nonsparse local indexing I get the following error:\n$> ./configure --with-ad-indexing-type=local                                                                                             \u2500\u256f\n---------------------------------------------\n----------- Configuring MOOSE ---------------\n---------------------------------------------\nconfiguring with derivative backing array size of 50\nconfiguring with AD indexing type local\nconfiguring with derivative type sparse\nchecking for x86_64-conda-linux-gnu-pkg-config... no\nchecking for pkg-config... /usr/bin/pkg-config\nconfigure: checking system for libpng\nconfiguring with libpng support\nconfigure: creating ./config.status\nconfig.status: creating conf_vars.mk\nconfig.status: creating framework/include/base/MooseConfig.h.tmp\nconfig.status: executing framework/include/base/MooseConfig.h commands\nconfig.status: creating framework/include/base/MooseConfig.h - prefix MOOSE for framework/include/base/MooseConfig.h.tmp defines\n---------------------------------------------\n--------- Done Configuring MOOSE ------------\n---------------------------------------------\n\n$> ./configure --with-derivative-type=nonsparse                                                                                          \u2500\u256f\n---------------------------------------------\n----------- Configuring MOOSE ---------------\n---------------------------------------------\nconfiguring with derivative backing array size of 50\nconfigure: error: cannot use global AD indexing with a nonsparse derivative container\n\nDo you have any clue?",
                  "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652586",
                  "updatedAt": "2022-06-15T15:08:33Z",
                  "publishedAt": "2021-04-24T03:21:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Nvmd, I need to do ./configure --with-derivative-type=nonsparse --with-ad-indexing-type=local . I thought the configure script knows about the current config status.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652593",
                          "updatedAt": "2022-06-15T15:08:27Z",
                          "publishedAt": "2021-04-24T03:22:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@lindsayad  Good news for me: I don't need to run any bisects :)\nBad news for you: with AD local indexing nonsparse the run time is 287.7488, with AD global indexing sparse the run time is 440.2642 (Yes, the number is different from the one in my original post because I re-ran it to make sure.)",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652614",
                          "updatedAt": "2022-06-15T15:08:27Z",
                          "publishedAt": "2021-04-24T03:45:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@abarun22 Could you try to run ./configure --with-derivative-type=nonsparse --with-ad-indexing-type=local in your moose root directory, then recompile and see if it speeds up your calculations?",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652617",
                          "updatedAt": "2022-06-15T15:08:33Z",
                          "publishedAt": "2021-04-24T03:51:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Ok I\u2019m glad we figured out the issue straightaway. I will have to profile this to figure out the differences and whether there are any potential remedies. In the meantime the user should definitely work with local nonsparse. Gary could you create a ticket and tag me please?",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-652658",
                          "updatedAt": "2022-07-12T04:12:16Z",
                          "publishedAt": "2021-04-24T04:25:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Thanks! No problem, I just tagged you.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-653392",
                          "updatedAt": "2022-07-12T04:12:16Z",
                          "publishedAt": "2021-04-24T12:39:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Dear Gary,\nThe configure options for non-sparse indexing does not seem to impact the computational time. I ran your version of the input file which took 462s and 466s before and after configuring the options. It is still taking the same one hour for my version of input file.\nFYI, i did the configuration as suggested by you, which it did successfully - then moved to test directory (moose/test), recompiled the sources with new options and recompiled my application eventully.\nKind regards,\nArun",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-660963",
                          "updatedAt": "2022-07-12T04:12:16Z",
                          "publishedAt": "2021-04-26T17:10:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You made me unconfident... I triple checked just now, and global sparse gave me 434 seconds and local nonsparse gave me 290 seconds. It is really making a difference on my machine. Either one of us did something wrong, or something is machine-dependent. We probably need a third person to confirm.\nJust to make sure, you first ran the ./configure --with-derivative-type=nonsparse --with-ad-indexing-type=local command, then recompiled your application, and finally ran my input file, right? Is it possible you have multiple moose on your machine and your application didn't pick up the right one?",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-661940",
                          "updatedAt": "2022-07-12T04:12:18Z",
                          "publishedAt": "2021-04-26T21:52:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Dear Gary,\nYes exactly the same. Here is the configure log for your reference\n(base) abalasub@freia013> ./configure --with-derivative-type=nonsparse --with-ad-indexing-type=local\n----------- Configuring MOOSE ---------------\nconfiguring with derivative backing array size of 50\nconfiguring with AD indexing type local\nconfiguring with derivative type nonsparse\nchecking for pkg-config... /usr/bin/pkg-config\nconfigure: checking system for libpng\nconfiguring with libpng support\nconfigure: creating ./config.status\nconfig.status: creating conf_vars.mk\nconfig.status: creating framework/include/base/MooseConfig.h.tmp\nconfig.status: executing framework/include/base/MooseConfig.h commands\nconfig.status: creating framework/include/base/MooseConfig.h - prefix MOOSE for framework/include/base/MooseConfig.h.tmp defines\n--------- Done Configuring MOOSE ------------\nAfter that i re-compiled my application and ran your inputfile. I am sure the application is linking with the correct version of moose uniquely. No problems here i guess. I will try and run this nonsparse configured moose in other clusters and see if it speeds up the computation.",
                          "url": "https://github.com/idaholab/moose/discussions/17671#discussioncomment-663955",
                          "updatedAt": "2022-07-12T04:12:19Z",
                          "publishedAt": "2021-04-27T11:33:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Distortion of mesh on adding plasticity with hardening",
          "author": {
            "login": "Bala-1005"
          },
          "bodyText": "Hello everyone,\nI am working on coupling phase field and plasticity modeling. I am using Isotropic plasticity with power hardening rule. But for some reason, the mesh gets distorted as shown in the figure. I have tried different boundary conditions but all the simulation runs show distortion and then stops converging. What could be the reason for this? The simulation runs perfectly when no plasticity is involved.\nI use a SMALL strain definition with incremental strain for tensor mechanics.\n\nThanks,\nBala",
          "url": "https://github.com/idaholab/moose/discussions/17590",
          "updatedAt": "2022-06-16T18:59:14Z",
          "publishedAt": "2021-04-13T01:02:46Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "That is a cool looking result, @Bala-1005 .   Could it be the usual mesh-dependence of strain-softening/hardening ?  Eg, with a coarse mesh, no quadpoints yield, but with a fine mesh a quadpoint yields, which then causes another quadpoint to yield, etc, leading to a substantially different result.",
                  "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602755",
                  "updatedAt": "2022-06-16T18:59:21Z",
                  "publishedAt": "2021-04-13T01:14:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "Thank you @WilkAndy . I am not familiar with the concept of mesh-dependence of strain hardening. I might have to read up on it. In the mean time, would removing adaptivity of the mesh help in reducing the distortion?",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602839",
                          "updatedAt": "2022-06-16T18:59:25Z",
                          "publishedAt": "2021-04-13T01:54:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Give it a try!",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602845",
                          "updatedAt": "2022-06-16T18:59:22Z",
                          "publishedAt": "2021-04-13T01:56:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "That does not seem to work as the solve stops converging really fast.",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602869",
                          "updatedAt": "2022-06-16T18:59:22Z",
                          "publishedAt": "2021-04-13T02:09:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Oh well - it was just an idea - i don't know about phase-field, so will leave this problem to an expert.",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602882",
                          "updatedAt": "2022-09-14T12:42:59Z",
                          "publishedAt": "2021-04-13T02:18:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Can you let us know why you don't want the distortion (or why you think it's nonphysical)? Also can you post contour plots of displacements and effective inelastic strain?",
                  "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-602962",
                  "updatedAt": "2022-06-16T18:59:24Z",
                  "publishedAt": "2021-04-13T03:04:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "The problem is a solidification problem. The red part is solid and the blue part is the liquid. Therefore a distorted mesh does not seem to make a lot of sense in the liquid part. If that were the case, then I believe my elastic simulations also would have shown such a distortion which was not the case. I hope I make sense.\nHere are the displacements, and effective strain plots.",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-603244",
                          "updatedAt": "2022-06-16T18:59:24Z",
                          "publishedAt": "2021-04-13T06:04:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I think it'd be useful to defined \"distorted\".  Eg, do you mean:\n\nasymmetric (there isn't exact 8-fold symmetry in your results), or\nshould-be-circular-but-isn't, or\nshould-be-square-but-isn't, or\nshould not have the inwards-pointing fingers, or\nsomething else?",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-603369",
                          "updatedAt": "2022-06-16T18:59:33Z",
                          "publishedAt": "2021-04-13T06:55:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "I mean I expected the mesh to stay square-shaped but close to the interface, the mesh does not seem to be that way. In contrast, the results with only elasticity as shown below, shows very little to no change in shape.",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-604860",
                          "updatedAt": "2022-06-16T18:59:30Z",
                          "publishedAt": "2021-04-13T13:33:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Thanks @Bala-1005 .  Before quitting this discussion (due to my ignorance), i want to ask: are you sure the result isn't correct?  More specifically: are you sure your physics with hardening has a unique solution?\nAn example of a system with a non-unique solution is the stretching of a 1D material that is governed by a strain-softening law.  As you stretch the material, you'll get closer to the yield strength.  When you hit the yield strength, the whole material won't suddenly fail: just some \"random\" part of it will fail.  In real life, the \"random\" part is the part that, for whatever reason, was slightly weaker than the rest.  In a numerical model, the \"random\" part will be a quadpoint that was under slightly more stress, due to roundoff error (or other precision-related artifacts).  Then, because of the strain softening, that \"random\" part will keep deforming plastically while you continue to stretch the material, while the remainder of the 1D bar will behave elastically.\nTo me, your situation looks analogous to this.  There are a few \"random\" quadpoints that behave a little differently from the others, causing the \"distortion\".  You'll be able to determine whether your situation falls has this type of non-unique solution by doing a similar thought experiment to the previous paragraph.  Then, follow through the consequences of the \"random\" quadpoints failing: does that mean their neighbours then preferentially fail?  If so, then your \"distortion\" is mostly likely caused by non-uniqueness, in my opinion.\nJust throwing this to you for consideration, not because i know anything about your physics or numerics!!",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-606818",
                          "updatedAt": "2022-09-14T12:43:38Z",
                          "publishedAt": "2021-04-13T21:18:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "Thank you for the analysis @WilkAndy .  It has helped me understand my problem better. I have been thinking in the same lines for my problem. The only point where I am not able to physically explain is the fact that the red phase is the solid part and the blue phase is the liquid part. Mesh \"distortion\" occurs only in the liquid phase. This can be seen better with some user defined anisotropy in the problem as shown below in the figure. Here there is a mesh \"distortion\" in the liquid phase between two solid phases. There are no stresses in the liquid phase as their young's modulus is several orders lower than the solids. Say, for example one of the quad points in the solid phase yields, it does not make physical sense for me to say that a neighboring quad point in the liquid has yielded as well. In other words, my question would be, Is it proper to use plasticity modeling for the entire domain or does it make more sense to use plasticity modeling only for the solid part?\n\nThank you so much for the explanation.\nBala",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-648121",
                          "updatedAt": "2022-09-14T12:43:45Z",
                          "publishedAt": "2021-04-23T06:23:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "So, just checking - the \"distortion\" you're referring to is in the blue elements between the tips of the red regions.  If so, then i would look at numerical problems such as shear (or volumetric) locking, since those strangely shaped elements should be more square according to my eyes.\nSecondly, when you have a large contrast in young's modulus, you'll get a large contrast in residuals.  So the contribution to the overall residual from the \"blue\" region could be much smaller than from the \"red\" region, meaning the blue region might not have converged as well as the red region.  Put another way: it doesn't \"cost\" much (energy or force) to move a blue node compared with a \"red\" node.\nI don't know anything about your model, but generally liquids are not governed by solid-mechanics plasticity (J2).  Plasticity means that, for example, pulling a material past its yield point and then releasing it again results in a permanently extended material - it does not return to its original shape.  I'm not aware of any fluids that act like that, or when you say \"plastic fluid\" are you meaning a non-Newtonian fluid?  I've obviously exceeded the limit of my knowledge in this question!",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-649098",
                          "updatedAt": "2022-09-14T12:43:59Z",
                          "publishedAt": "2021-04-23T11:03:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @Bala-1005\nWhat is the difference between the mechanical properties of the solid and liquid?\nI get this kind of problems when one region has a stiffness which is much smaller than the other.\nCould you share the input file?\nBest Regards,\nNicol\u00f2 Grilli",
                  "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-603529",
                  "updatedAt": "2022-09-14T12:44:20Z",
                  "publishedAt": "2021-04-13T07:48:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "Hi @ngrilli ,\nThe young's moduli of the solid and liquid phases have a difference in the order of around ~10e9. Did you get these kinds of problems with plasticity or with elasticity?\nHere is the input file.\nThanks,\nBala\nkks_anisotropic_plastic.txt",
                          "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-604919",
                          "updatedAt": "2022-09-14T12:44:25Z",
                          "publishedAt": "2021-04-13T13:45:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Let me tell you a tangential issue here. When you use a plastic model (with stateful properties), you'd better not use adaptivity. It does not guarantee the stress state is always admissible before and after refinement/coarsening, i.e. remain at yield surface.\nI agree with @ngrilli , the issue seems to be related to the large material contrast.",
                  "url": "https://github.com/idaholab/moose/discussions/17590#discussioncomment-652601",
                  "updatedAt": "2022-09-14T12:44:22Z",
                  "publishedAt": "2021-04-24T03:27:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "History variables in a kernel",
          "author": {
            "login": "etauq"
          },
          "bodyText": "Hi,\nI was wondering if we can require history variables in a kernel. If possible, how can we do that?\nThanks,\nJack",
          "url": "https://github.com/idaholab/moose/discussions/17644",
          "updatedAt": "2023-06-29T08:46:06Z",
          "publishedAt": "2021-04-19T18:49:29Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "If you want your kernel to couple old solutions of variables in a transient calculation, you can add implicit = false in the kernel parameters in the input.",
                  "url": "https://github.com/idaholab/moose/discussions/17644#discussioncomment-631854",
                  "updatedAt": "2023-06-29T08:46:06Z",
                  "publishedAt": "2021-04-19T19:15:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "If you want to access old solution in additional to the current solution, you can use coupledValueOld(var_name)",
                  "url": "https://github.com/idaholab/moose/discussions/17644#discussioncomment-650716",
                  "updatedAt": "2023-06-29T08:46:20Z",
                  "publishedAt": "2021-04-23T16:07:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Some problems in crytatl.i material module, regarding crystal plasticity",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nIn order to complete the #17577  job, I have some doubts about the elastic modulus and crystal plastic constitutive part of the material in crystal.i. I hope to get your guidance.\nAccording to my understanding, FiniteStrainCrystalPlasticityis responsible for the constitutive part of crystal plasticity,in the materials module of crystal.i.\nAnd ComputeElasticityTensorCP is responsible for inputting Euler angles and rotation matrix to the FiniteStrainCrystalPlasticity sub-module. I have the following questions and hope to get your answers,\nFirst, does FiniteStrainCrystalPlasticity only need to input _elasticity_tensor and ComputeElasticityTensorCP from ComputeElasticityTensorCP at initial time? and these two variables are already included in the MaterialProperty variable at timestep_begin, I don\u2019t know if my understanding is correct?\nSecond, the material rotation annotated in MaterialProperty<RankTwoTensor>&_update_rot refers to the rotation caused by the entire material deformation process during the loading process, that is,\n\nrot = get_current_rotation(_deformation_gradient[_qp]); // Calculate material rotation\n_update_rot[_qp] = rot * _crysrot[_qp];\n\nThe crystal orientation refers to the rotation tensor, _crysrot, calculated after the material initially gives the crystal grain Euler angles. If my understanding is wrong, please give me more guidance.\nAny suggestions or recommendations would be greatly appreciated.\nThank you\nWei Peng",
          "url": "https://github.com/idaholab/moose/discussions/17592",
          "updatedAt": "2022-06-06T12:17:29Z",
          "publishedAt": "2021-04-13T14:39:10Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "PengWei97"
                  },
                  "bodyText": "@jiangwen84\uff0cCould you give me some guidance?",
                  "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-610145",
                  "updatedAt": "2022-06-06T12:17:32Z",
                  "publishedAt": "2021-04-14T13:53:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Dear MOOSE experts,\nIn order to complete the #17577 job, I have some doubts about the elastic modulus and crystal plastic constitutive part of the material in crystal.i. I hope to get your guidance.\nAccording to my understanding, FiniteStrainCrystalPlasticityis responsible for the constitutive part of crystal plasticity,in the materials module of crystal.i.\nAnd ComputeElasticityTensorCP is responsible for inputting Euler angles and rotation matrix to the FiniteStrainCrystalPlasticity sub-module. I have the following questions and hope to get your answers,\nFirst, does FiniteStrainCrystalPlasticity only need to input _elasticity_tensor and ComputeElasticityTensorCP from ComputeElasticityTensorCP at initial time? and these two variables are already included in the MaterialProperty variable at timestep_begin, I don\u2019t know if my understanding is correct?\n\n_elasticity_tensor is initial rotated elasticity tensor. If the Euler angles do not change, its value remains the same during  every linear residual calculation.\n\nSecond, the material rotation annotated in MaterialProperty<RankTwoTensor>&_update_rot refers to the rotation caused by the entire material deformation process during the loading process, that is,\n\nrot = get_current_rotation(_deformation_gradient[_qp]); // Calculate material rotation\n_update_rot[_qp] = rot * _crysrot[_qp];\n\nThe crystal orientation refers to the rotation tensor, _crysrot, calculated after the material initially gives the crystal grain Euler angles. If my understanding is wrong, please give me more guidance.\n\n_crysrot is the initial grain orientation. The rot is the incremental rotation due to deformation.\n\nAny suggestions or recommendations would be greatly appreciated.\nThank you\nWei Peng",
                  "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-611722",
                  "updatedAt": "2022-06-06T12:17:32Z",
                  "publishedAt": "2021-04-14T19:32:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you very much @jiangwen84  for your patient reply.\nAccording to my understanding, ComputeElasticityTensorCP is responsible for outputting the elasticity modulus after rotation, namely _elasticity_tensor .\nAnd the rotation matrix, namely _crysrot ,  for update slip direction and normal with crystal orientation.\nIs this correct?\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-615934",
                          "updatedAt": "2022-06-29T07:43:29Z",
                          "publishedAt": "2021-04-15T14:41:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Thank you very much @jiangwen84 for your patient reply.\nAccording to my understanding, ComputeElasticityTensorCP is responsible for outputting the elasticity modulus after rotation, namely _elasticity_tensor .\n\nComputeElasticityTensorCP calculates the elasticity tensor _elasticity_tensor based on grain orientation (Euler angles). The _elasticity_tensor will be used in CrystalPlasticity Stress Calculation to compute the stress at intermediate configuration. You can also visualize the component of _elasticity_tensor using a AuxVariable.\n\nAnd the rotation matrix, namely _crysrot , for update slip direction and normal with crystal orientation.\n\n_crysrot is basically the rotation matrix for grain orientation. It is used to rotate the slip system. The rotation due to deformation is calculated by _update_rotation.\n\nIs this correct?\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-616155",
                          "updatedAt": "2022-06-29T07:43:34Z",
                          "publishedAt": "2021-04-15T15:19:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you @jiangwen84  very much for your guidance. I have understood the role of two material parameters.\nPlease forgive me for repeatedly determining whether my understanding is correct, because I need to develop a model that couples crystal plasticity and phase field to study the mechanical field, especially the influence of plasticity on the behavior of grain growth. So I need to confirm that only two MaterialPropertys in ComputeElasticityTensorCP: _elasticity_tensor and _crysrot are output as the input parameters of FiniteStrainCrystalPlasticity.\nBased on the existing coupling model of moose, it is the corresponding coupled linear elastic force field, and the file is bicrystal.i. The current thinking about crystal plasticity and phase-field coupled simulation is to replace the method of Element property read user object in ComputeElasticityTensorCP with GrainDataTracker to assign elastic modulus and Euler angles. I wonder if it is reasonable? I hope you can give me some suggestions.\nThanks for the help,\nBest,\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-621052",
                          "updatedAt": "2022-06-29T07:43:35Z",
                          "publishedAt": "2021-04-16T15:28:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "hi @jiangwen84\uff0c\nThank you very much for your careful guidance. Through reading the tensor module on the moose official website, I understand that the module that calculates the elastic tensor needs to output two material parameters: elastic modulus and rotation matrix.\nFinally, if you have any suggestions for issue #17577, your guidance is welcome.\nBest,\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/17592#discussioncomment-648564",
                          "updatedAt": "2023-03-06T14:00:24Z",
                          "publishedAt": "2021-04-23T08:33:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Develop a coupled model of grain plasticity and phase field grain growth",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nI am trying to couple crystal plasticity and phase field to simulate grain growth. I read modules\\combined\\test\\tests\\ACGrGrElasticDrivingForce\\bicrystal.i and modules\\tensor_mechanics\\test\\tests\\cp_user_object\\crysp.i carefully. And I also read the Elastic Driving Force for Grain Growth webpage.\n\nIn the model where the linear elastic force field and the phase field are coupled, bicrystal.i, Kernels\\PolycrystalElasticDrivingForce acts as a bridge.\nInput the elastic_strain calculated in the Materials\\stress submodule and the D_elastic_tensor calculated in the Materials\\elasticity_tensor submodule.\nIn ACGrGrElasticDrivingForce kernels, it is used to calculate the deformation energy part of the Allen-Cahn equation because of the elastic driving force.\n\nMoreover, I also tried to change the strain calculation type in the Materials module from ComputeSmallStrain to ComputeFiniteStrain, and the stress calculation type from ComputeLinearElasticStress to ComputeFiniteStrainElasticStress, and the verification is feasible.\nThe comparison found that if I want to complete this work, I think it is mainly to modify the Materials\\elasticity_tensor part, and I need to refer to ComputeElasticityTensorCP in crystal.i to modify ComputePolycrystalElasticityTensor in bicrystal.i. I think it is necessary to add the rotation matrix srysrot_ij in ComputePolycrystalElasticityTensor. I don\u2019t know if my understanding is correct?\nFinally, when only considering the elastic energy, if I want to complete the establishment of the crystal plasticity and phase-field coupled grain growth model, What else do I need to consider?\nAny suggestions or recommendations would be greatly appreciated.\nThank you\nWei Peng",
          "url": "https://github.com/idaholab/moose/discussions/17577",
          "updatedAt": "2022-06-29T18:26:10Z",
          "publishedAt": "2021-04-12T09:14:35Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "PengWei97"
                  },
                  "bodyText": "Hi everyone,\nThe first idea to develop this paradigm was to write another UserObjects named GrainTrackerRotation, used to input the rotation matrix, similar to GrainTrackerElasticity used to output the elastic modulus after rotation.\nBased on this, two major modifications have been made,\nFirst, create a UserObjects named GrainTrackerRotation to output the rotation matrix.\nSecond, modify the ComputeElasticityTensorCP to become ComputePolyElasticityTensorCP, which is used to accept the elastic modulus after the rotation in the UserObjects module and the rotation matrix derived from the known Euler angle.\nAfter compiling the application I created, there are no bugs.\nBut in the debugging stage, using the modified bicrystal_2.i as input, the terminal displays the bug as follows,\nAssertion `grain_id <_grain_data.size()' failed\nRequested data for invalid grain index.\nat /home/xia/projects/moose/modules/phase_field/build/header_symlinks/GrainDataTracker.h, line 46\nI don't know what stupid I did that caused such a problem. Could anyone answer me in this regard?\nAny suggestions or recommendations would be greatly appreciated.\nThank you\nWei Peng",
                  "url": "https://github.com/idaholab/moose/discussions/17577#discussioncomment-648547",
                  "updatedAt": "2022-06-29T18:26:10Z",
                  "publishedAt": "2021-04-23T08:29:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}