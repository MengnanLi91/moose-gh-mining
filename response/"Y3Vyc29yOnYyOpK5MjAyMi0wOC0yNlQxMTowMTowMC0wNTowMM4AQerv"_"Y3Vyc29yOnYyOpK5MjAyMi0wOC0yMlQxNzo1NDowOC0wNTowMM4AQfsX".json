{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wOC0yMlQxNzo1NDowOC0wNTowMM4AQfsX"
    },
    "edges": [
      {
        "node": {
          "title": "Error in compiling Moose Application",
          "author": {
            "login": "Salma-Mao"
          },
          "bodyText": "Hello everyone,\nThere are two problems.\n\nThe core of my computer is 18  and he running memory is 64g. If the number of cores selected  exceeds 10, the calculation cannot be performed. I get the error.\n\n===================================================================================\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   PID 5191 RUNNING AT 940a54af5dff\n=   EXIT CODE: 7\n=   CLEANING UP REMAINING PROCESSES\n=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Bus error (signal 7)\nThis typically refers to a problem with your application.\nPlease see the FAQ page for debugging suggestions\n\nThe blocks of my case are 4. When I only output the mesh, it  displays 4 blocks. However,  the number of blocks in the output after the calculation  is 2.",
          "url": "https://github.com/idaholab/moose/discussions/21934",
          "updatedAt": "2022-09-02T19:53:03Z",
          "publishedAt": "2022-08-25T15:18:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you try running with a distributed mesh?\nThat's weird. Are you running something that deletes elements?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3475871",
                  "updatedAt": "2022-08-25T15:32:42Z",
                  "publishedAt": "2022-08-25T15:32:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Salma-Mao"
                          },
                          "bodyText": "https://mooseframework.inl.gov/source/userobject/CoupledVarThresholdElementSubdomainModifier.html is used. I donot know how to run with a distributed mesh. Could you give me an example\uff1f",
                          "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3476074",
                          "updatedAt": "2022-08-25T15:55:28Z",
                          "publishedAt": "2022-08-25T15:54:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if all the objects in your simulation are good for distributed meshes, just add --distributed-mesh on the command line\nsee this docs\nReplicated and Distributed Mesh",
                          "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3476084",
                          "updatedAt": "2022-08-25T15:55:35Z",
                          "publishedAt": "2022-08-25T15:55:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Salma-Mao"
                          },
                          "bodyText": "Do you know why  the number of cores selected exceeds 10, the calculation cannot be performed?  The cores of  my computer are 18.",
                          "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3476119",
                          "updatedAt": "2022-08-25T15:59:47Z",
                          "publishedAt": "2022-08-25T15:59:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it could be that you are running out of memory. That s why we should try the distributed mesh.\nYou could add a postprocessor to report on memory usage",
                          "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3476385",
                          "updatedAt": "2022-08-25T16:31:01Z",
                          "publishedAt": "2022-08-25T16:31:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Salma-Mao"
                  },
                  "bodyText": "I only used 30% of the running memory. That's so  weird.",
                  "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3481471",
                  "updatedAt": "2022-08-26T08:48:04Z",
                  "publishedAt": "2022-08-26T08:48:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the memory can spike at times. You d want to run that postprocessor that captures all spikes\nhttps://mooseframework.inl.gov/source/postprocessors/MemoryUsage.html",
                          "url": "https://github.com/idaholab/moose/discussions/21934#discussioncomment-3485093",
                          "updatedAt": "2022-08-26T15:55:20Z",
                          "publishedAt": "2022-08-26T15:55:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "libMesh Update 2022.08.23",
          "author": {
            "login": "milljm"
          },
          "bodyText": "A new libMesh made its way to the MOOSE master branch yesterday. For those using the conda packages, please perform\nmamba update --all\n\nin your MOOSE conda environment. The appropriate moose-libmesh package version should be 2022.08.23. For those using the the libMesh submodule, please run in the moose/scripts directory\n./update_and_rebuild_libmesh.sh\n\nafter updating your copy of MOOSE.",
          "url": "https://github.com/idaholab/moose/discussions/21936",
          "updatedAt": "2022-08-25T15:51:13Z",
          "publishedAt": "2022-08-25T15:51:12Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Convergence impact of volumetric locking correction",
          "author": {
            "login": "Flolaffel"
          },
          "bodyText": "Hello,\nI already opened a similar discussion once but I'm still having trouble with the volumetric locking correction in my frictional contact problems. The input I'm using is:\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  volumetric_locking_correction = true\n[]\n\n[Mesh]\n  [rad]\n    type = AnnularMeshGenerator\n    nt = 16\n    nr = 12\n    rmin = 17.5\n    rmax = 40\n    dmin = 225\n    dmax = 315\n  []\n  [extrude]\n    type = MeshExtruderGenerator\n    input = rad\n    extrusion_vector = '0 0 18'\n    num_layers = 7\n  []\n  [transform]\n    type = TransformGenerator\n    input = extrude\n    transform = translate\n    vector_value = '0 40 0'\n  []\n  [rad_id]\n    type = SubdomainIDGenerator\n    input = transform\n    subdomain_id = 1\n  []\n  [boden]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 8\n    ny = 1\n    nz = 5\n    xmin = -35\n    xmax = 35\n    ymin = -1\n    ymax = 0\n    zmin = -7\n    zmax = 25\n    boundary_id_offset = 100\n  []\n  [boden_id]\n    type = SubdomainIDGenerator\n    input = boden\n    subdomain_id = 2\n  []\n  [collect_meshes]\n    type = MeshCollectionGenerator\n    inputs = 'rad_id boden_id'\n  []  \n  patch_update_strategy = iteration\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = FINITE\n    block = '1 2'\n  []\n[]\n\n[Contact]\n  [kontakt]\n    primary = top\n    secondary = rmax\n    formulation = penalty\n    penalty = 1e4 \n    model = coulomb\n    friction_coefficient = 0.6\n    normal_smoothing_distance = 0.1\n  []\n[]\n\n[Dampers]\n  [contact_slip]\n    type = ContactSlipDamper\n    primary = top\n    secondary = rmax\n  []\n[]\n\n[Functions]\n  [load_disp]\n    type = ParsedFunction\n    value = '-3.7 * t'\n  []\n[]\n\n[BCs]\n  [load_disp]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = rmin\n    function = load_disp\n  []\n  [ground_fixed_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = bottom\n    value = 0\n  []\n  [ground_fixed_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0\n  []\n  [ground_fixed_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = bottom\n    value = 0\n  []\n  [wheel_fixed_z] \n    type = DirichletBC\n    variable = disp_z\n    boundary = rmin\n    value = 0\n  []\n  [wheel_fixed_x] \n    type = DirichletBC\n    variable = disp_x\n    boundary = rmin\n    value = 0\n  []\n[]\n\n[Materials]\n  [rad_elasticity]\n    type = ComputeIsotropicElasticityTensor\n    bulk_modulus = 320\n    shear_modulus = 0.5\n    block = '1'\n  []\n  [rad_stress]\n    type = ComputeFiniteStrainElasticStress\n    block = '1'\n  []    \n  [boden_elasticity]\n    type = ComputeIsotropicElasticityTensor\n    block = '2'\n    youngs_modulus = 1e3\n    poissons_ratio = 0.35\n  []\n  [boden_stress]\n    type = ComputeFiniteStrainElasticStress\n    block = '2'\n  []\n[]\n\n[Preconditioning]\n  [SMP]\n    solve_type = 'PJFNK'\n    type = SMP\n    full = true\n    petsc_options_iname = '-pc_type -pc_factor_mat_solver_type'\n    petsc_options_value = 'lu       superlu_dist'\n  []\n[]\n\n\n[Executioner]\n   type = Transient\n   start_time = 0.0\n   dt = 0.0125\n   end_time = 1.0\n   nl_abs_tol = 1e-6\n   nl_rel_tol = 1e-6\n   line_search = none\n   [Predictor]\n     type = SimplePredictor\n     scale = 1.0\n   []\n    l_tol = 1e-3\n   nl_max_its = 50\n []\n\n[Outputs]\n  exodus = true\n  csv = true\n[]\n\n[Postprocessors]\n  [nonlin_it]\n    type = NumNonlinearIterations\n  []\n  [cumulative_nonlin_it]\n    type = CumulativeValuePostprocessor\n    postprocessor = nonlin_it\n  []\n  [lin_it]\n    type = NumLinearIterations\n  []\n  [cumulative_lin_it]\n    type = CumulativeValuePostprocessor\n    postprocessor = lin_it\n  []\n  [time_sum]\n    type = PerfGraphData\n    section_name = \"Root\"\n    data_type = total\n    execute_on = 'initial nonlinear timestep_end'\n  []\n[]\n\nIt is meant to represent a segment of a rubber wheel getting pressed onto the ground. When not using locking correction there is locking which leads to incorrect contact behavior to the ground (the material in the contact zone is forced to expand to side in z direction instead of a more frictional sticky behaviour). I ran the simulation with two different shear moduli mu: 5 MPa and 0.5 MPa. The locking is worse for 0.5 MPa since the material is closer to incompressibility there. Then I ran both these simulations again but with locking correction activated.\nWhat I observed regarding convergence:\n\n0.5 MPa: 189 nonlinear iterations (nl it), 4182 linear iterations (l it)\n5 MPa: 222 nl it, 10775 l it\n0.5 MPa with locking correction: convergence so bad I aborted the simulation, would've taken too long\n5 MPa with locking correction: 199 nl it, 6297 l it\n\nWhat confuses me is the impact of the locking correction. Since there shouldn't be any locking regardless of the used shear modulus I'd expect the simulations that use the locking correction to behave similarily. But when mu = 0.5 MPa the locking correction has a harsh negative impact on convergence while with mu = 5 MPa it actually benefits convergence.\nIs there any known impact on convergence for locking correction? Or does anyone have an idea what causes this behaviour?",
          "url": "https://github.com/idaholab/moose/discussions/21730",
          "updatedAt": "2022-09-02T19:53:35Z",
          "publishedAt": "2022-07-30T12:39:38Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@recuero @jiangwen84 @bwspenc any suggestions for this user?",
                  "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3380503",
                  "updatedAt": "2022-08-12T02:30:39Z",
                  "publishedAt": "2022-08-12T02:30:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "It may be that the Jacobian, when volumetric locking is used, is not as accurate as without locking correction. Any numerical impediment when using frictional contact will tend to hinder convergence noticeably. I agree that, in many problems, locking correction can be enabled and its practical impact on the results still be negligible, but, with contact, I wonder if the additional modes of deformation enabled by locking correction make the contact interface problem more challenging (i.e. can the combination of frictional and internal forces excite volumetric modes?).\nBelow an input file that uses automatic differentiation with your problem. I halved the time step. It solves in 4/5 nonlinear iterations and the number of linear iterations per nonlinear iteration is no more than 12/13.\nThat said, I do not fully understand these statements:\n\nSince there shouldn't be any locking regardless of the used shear modulus\n\nand\n\nWhen not using locking correction there is locking which leads to incorrect contact behavior to the ground (the material in the contact zone is forced to expand to side in z direction instead of a more frictional sticky behaviour)\n\nDo you expect locking correction to be relevant for the problem above? Are you using a different material model for your own testing?\n\n  displacements = 'disp_x disp_y disp_z'\n  volumetric_locking_correction = true\n[]\n\n[Mesh]\n  [rad]\n    type = AnnularMeshGenerator\n    nt = 16\n    nr = 12\n    rmin = 17.5\n    rmax = 40\n    dmin = 225\n    dmax = 315\n  []\n  [extrude]\n    type = MeshExtruderGenerator\n    input = rad\n    extrusion_vector = '0 0 18'\n    num_layers = 7\n  []\n  [transform]\n    type = TransformGenerator\n    input = extrude\n    transform = translate\n    vector_value = '0 40 0'\n  []\n  [rad_id]\n    type = SubdomainIDGenerator\n    input = transform\n    subdomain_id = 1\n  []\n  [boden]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 8\n    ny = 1\n    nz = 5\n    xmin = -35\n    xmax = 35\n    ymin = -1\n    ymax = 0\n    zmin = -7\n    zmax = 25\n    boundary_id_offset = 100\n  []\n  [boden_id]\n    type = SubdomainIDGenerator\n    input = boden\n    subdomain_id = 2\n  []\n  [collect_meshes]\n    type = MeshCollectionGenerator\n    inputs = 'rad_id boden_id'\n  []\n  patch_update_strategy = iteration\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = FINITE\n    block = '1 2'\n    use_automatic_differentiation = true\n  []\n[]\n\n[Contact]\n  [kontakt]\n    primary = top\n    secondary = rmax\n    formulation = penalty\n    penalty = 1e1\n    normalize_penalty = true\n    model = coulomb\n    friction_coefficient = 0.6\n    normal_smoothing_distance = 0.1\n  []\n[]\n\n[Dampers]\n  [contact_slip]\n    type = ContactSlipDamper\n    primary = top\n    secondary = rmax\n  []\n[]\n\n[Functions]\n  [load_disp]\n    type = ParsedFunction\n    value = '-3.7 * t'\n  []\n[]\n\n[BCs]\n  [load_disp]\n    type = ADFunctionDirichletBC\n    variable = disp_y\n    boundary = rmin\n    function = load_disp\n  []\n  [ground_fixed_x]\n    type = ADDirichletBC\n    variable = disp_x\n    boundary = bottom\n    value = 0\n  []\n  [ground_fixed_y]\n    type = ADDirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0\n  []\n  [ground_fixed_z]\n    type = ADDirichletBC\n    variable = disp_z\n    boundary = bottom\n    value = 0\n  []\n  [wheel_fixed_z]\n    type = ADDirichletBC\n    variable = disp_z\n    boundary = rmin\n    value = 0\n  []\n  [wheel_fixed_x]\n    type = ADDirichletBC\n    variable = disp_x\n    boundary = rmin\n    value = 0\n  []\n[]\n\n[Materials]\n  [rad_elasticity]\n    type = ADComputeIsotropicElasticityTensor\n    bulk_modulus = 320\n    shear_modulus = 0.5\n    block = '1'\n  []\n  [rad_stress]\n    type = ADComputeFiniteStrainElasticStress\n    block = '1'\n  []\n  [boden_elasticity]\n    type = ADComputeIsotropicElasticityTensor\n    block = '2'\n    youngs_modulus = 1e3\n    poissons_ratio = 0.35\n  []\n  [boden_stress]\n    type = ADComputeFiniteStrainElasticStress\n    block = '2'\n  []\n[]\n\n[Preconditioning]\n  [SMP]\n    solve_type = 'PJFNK'\n    type = SMP\n    full = true\n\n  []\n[]\n\n[Executioner]\n  type = Transient\n  start_time = 0.0\n  dt = 0.00625\n  end_time = 1.0\n  nl_abs_tol = 1e-6\n  nl_rel_tol = 1e-6\n  line_search = none\n\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_type'\n  petsc_options_value = 'lu       superlu_dist'\n  #[Predictor]\n  #  type = SimplePredictor\n  #  scale = 1.0\n  #[]\n  l_tol = 1e-3\n  nl_max_its = 50\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n[]\n\n[Postprocessors]\n  [nonlin_it]\n    type = NumNonlinearIterations\n  []\n  [cumulative_nonlin_it]\n    type = CumulativeValuePostprocessor\n    postprocessor = nonlin_it\n  []\n  [lin_it]\n    type = NumLinearIterations\n  []\n  [cumulative_lin_it]\n    type = CumulativeValuePostprocessor\n    postprocessor = lin_it\n  []\n  [time_sum]\n    type = PerfGraphData\n    section_name = \"Root\"\n    data_type = total\n    execute_on = 'initial nonlinear timestep_end'\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3386226",
                  "updatedAt": "2022-08-12T17:30:06Z",
                  "publishedAt": "2022-08-12T17:30:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "I wonder if the additional modes of deformation enabled by locking correction make the contact interface problem more challenging (i.e. can the combination of frictional and internal forces excite volumetric modes?).\n\nSadly, I'm not able to answer this question. But assuming it was true that the enabled deformation modes make the problem more challenging, then why would locking correction improve convergence for mu = 5 and hinder it for mu = 0.5?\n\nBelow an input file that uses automatic differentiation with your problem. I halved the time step. It solves in 4/5 nonlinear iterations and the number of linear iterations per nonlinear iteration is no more than 12/13.\n\nIs the picture you attached from said input? Because while you're right that the linear convergence improves massively with AD, running the input still results in a lot of failed time steps for me (negative Jacobian entries).\nIs there any specific reason you commented out the predictor? Because in my experience it's quite a helpful tool for contact convergence in MOOSE which is also true for your provided input (it runs seemingly without failed time steps with predictor enabled).\n\nDo you expect locking correction to be relevant for the problem above? Are you using a different material model for your own testing?\n\nYes, volumetric locking seems to be a significant problem in the presented simulation. I just worded myself poorly. What I intented to say, was:\n\nSince there shouldn't be any locking regardless of the used shear modulus when using locking correction\n\nSo the quintessence of my statement was: I would expect the simulations that use locking correction to behave similarly regarding convergence impact, regardless of the shear modulus since volumetric locking should be non existent anymore. Problem is: they don't which is part of my confusion.\nFurthermore, I used different material models for testing. The plan is to use UMAT as the final material model. There, the behavioral problems are similar to the built-in material model which is why I provided that one for the forum discussion.\nUnluckily though your AD solution isn't compatible with the MOOSE UMAT class AFAIK.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3388949",
                          "updatedAt": "2022-08-13T11:20:03Z",
                          "publishedAt": "2022-08-13T09:46:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "why would locking correction improve convergence for mu = 5 and hinder it for mu = 0.5?\n\nI'd speculate, given the AD results, we can improve the Jacobian in that case. For mu = 0.5, Poisson's ratio is closer to incompressibility so the action of volumetric locking correction would be more relevant.\n\nIs the picture you attached from said input? Because while you're right that the linear convergence improves massively with AD, running the input still results in a lot of failed time steps for me (negative Jacobian entries).\n\n\nIs there any specific reason you commented out the predictor? Because in my experience it's quite a helpful tool for contact convergence in MOOSE which is also true for your provided input (it runs seemingly without failed time steps with predictor enabled).\n\nYeah, the picture is from that AD input file, which runs until the end of your simulation. There are a number of failed time steps in the simulation, especially as deformation becomes larger. Honestly, I didn't look too much into it, but it seemed to me that it was mostly cutting the time step once, or twice at the very end. You can certainly add the predictor for this problem, and I'd think it would help, just like you said. The only reason I removed the predictor was to assess convergence behavior without it.\n\nregardless of the shear modulus since volumetric locking should be non existent anymore\n\nTrue. And AD seems to show that the Jacobian can be improved, because the more we need the locking correction, the more its Jacobian contribution will be relevant.\n\nUnluckily though your AD solution isn't compatible with the MOOSE UMAT class AFAIK.\n\nAs things stand right now, you are right. We could potentially support a version of user subroutines that leverages AD objects for C++. Alternatively, you could take a stab at implementing your models within MOOSE's design, but this latter option is less appealing to you as far as I understand.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3390022",
                          "updatedAt": "2022-08-13T15:38:11Z",
                          "publishedAt": "2022-08-13T15:38:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "I'd speculate, given the AD results, we can improve the Jacobian in that case. For mu = 0.5, Poisson's ratio is closer to incompressibility so the action of volumetric locking correction would be more relevant.\n\nWell then I guess I'll just have to deal with it for now. Thanks for opening the issue though.\n\nAlternatively, you could take a stab at implementing your models within MOOSE's design, but this latter option is less appealing to you as far as I understand.\n\nI already have an AD version of the UMAT implemented (Neo Hooke). But you are right that using this implementation is less appealing than the UMAT right now since using the UMAT serves as a proof of concept for possible future projects with more complex UMATs. I guess I'll use both for now for comparison.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3394204",
                          "updatedAt": "2022-08-14T20:14:57Z",
                          "publishedAt": "2022-08-14T20:14:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The new kernels in tensor mechanics + NEML could give you exact Jacobian using UMAT without AD.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3394275",
                          "updatedAt": "2022-08-14T20:34:13Z",
                          "publishedAt": "2022-08-14T20:34:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "What is NEML?",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3396354",
                          "updatedAt": "2022-08-15T07:58:04Z",
                          "publishedAt": "2022-08-15T07:58:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I take it back, you don't need NEML here (NEML is another material library). So we've been developing this new system in tensor mechanics that gives you exact Jacobian without using AD. But an Abaqus UMAT interface is still missing in the new system. I can add that interface for UMAT and you should be able to get exact Jacobian (with volumetric locking correction) without AD. I should be able to do it this month. That being said, I don't guarantee an exact Jacobian will solve your convergence issue with contact.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3415198",
                          "updatedAt": "2022-08-17T14:04:38Z",
                          "publishedAt": "2022-08-17T14:04:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay, so the PR is up: #21871\nYou can checkout the PR and test to see if it improves the convergence with VLC. Mind that your DDSDDE in the UMAT has to be exact in order for the overall Jacobian to be exact.\nYou can also be patient and wait for this PR to be merged. It's up to you.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3417294",
                          "updatedAt": "2022-08-17T19:10:53Z",
                          "publishedAt": "2022-08-17T19:10:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Thanks a lot! I was on holiday, but I'll check it out in the following days.",
                          "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3473105",
                          "updatedAt": "2022-08-25T10:02:43Z",
                          "publishedAt": "2022-08-25T10:02:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "Issue on @Flolaffel's investigation: #21842.",
                  "url": "https://github.com/idaholab/moose/discussions/21730#discussioncomment-3390030",
                  "updatedAt": "2022-08-13T15:43:49Z",
                  "publishedAt": "2022-08-13T15:43:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "a problem of multivariable",
          "author": {
            "login": "dingqiushi"
          },
          "bodyText": "I want to write a kernel for multivariable, but I have some problems with the data type when calculating the residuals and Jacobi.\n\nIn a kernel suitable for single variable, I know that the component of the data type RealVectorValue is of type Real, so in a kernel suitable for multiple variables, what component of the data type is of type RealEigenVector? In other words, what is the data type of a variable consisting of the RealEigenVector type?\nBecause of the member function type requirement, the data type of the return value must be RealEigenVector. By testing I know that the data type of _grad_test[_i][_qp] is RealGradient, and I want to know what data type can be multiplied with the RealGradient type and the result of the multiplication is RealEigenVector type. I tried the RealVectorArrayValue type and the RealEigenMatrix type ,the following errors were reported at compile time.\n\uff081)\n\nerror: no match for operator* (operand types are \u2019libMesh::RealVectorArrayValue {aka Eigen::Matrix<double,-1,3>}\u201d and 'const value_type {aka const libMesh::VectorValue<double>}') \nreturn flux * _test[_i][_qp] + (lift*_grad_test[_i][_qp]);\n\n\uff082\uff09\nerror: no match for operator* (operand types are \u2019libMesh::RealEigenMatrix {aka Eigen::Matrix<double,-1,-1>}\u201d and 'const value_type {aka const libMesh::VectorValue<double>}') \nreturn flux * _test[_i][_qp] + (lift*_grad_test[_i][_qp]);\n\n\nIn my attempts to pass values, I found that it actually compiles when the left side of the equal sign is of type RealGradient and the right side is of type Real, does this make sense?",
          "url": "https://github.com/idaholab/moose/discussions/21922",
          "updatedAt": "2022-09-02T19:53:59Z",
          "publishedAt": "2022-08-23T12:16:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo you want a kernel that contributes to the residual for multiple variables? Is this an array variable or multiple regular variables?\nVariables with the RealEigenVector type are array variables.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3457205",
                  "updatedAt": "2022-08-23T14:20:27Z",
                  "publishedAt": "2022-08-23T14:20:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dingqiushi"
                          },
                          "bodyText": "Yes, the variables I use are array variables. The kernel inherit from ArrayKernel.C.",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3461222",
                          "updatedAt": "2022-08-24T00:55:03Z",
                          "publishedAt": "2022-08-24T00:55:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "All definitions are in moose/framework/include/utils/MooseTypes.h including the following:\ntypedef Eigen::Matrix<Real, Eigen::Dynamic, 1> RealEigenVector;\n\nYou also want to take a look at ArrayDiffusion.C.",
                  "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3460654",
                  "updatedAt": "2022-08-23T22:26:54Z",
                  "publishedAt": "2022-08-23T22:25:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dingqiushi"
                          },
                          "bodyText": "Thanks for the replies, I noticed ArrayDiffusion.C but I didn't see anything similar to what I did and didn't find any variables to multiply with _grad_test[_i][_qp].\nI have one more question for you all here, what is the difference between _array_grad_test and _grad_test?",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3461422",
                          "updatedAt": "2022-08-24T01:40:31Z",
                          "publishedAt": "2022-08-24T01:40:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Regular variables multiply with grad_test when doing integration by parts on a laplacian for example.\narray_grad_test is the equivalent for array variables",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3461845",
                          "updatedAt": "2022-08-24T03:33:02Z",
                          "publishedAt": "2022-08-24T03:33:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dingqiushi"
                          },
                          "bodyText": "Is there a data type which can fit multiple variables and at the same time represent a four-dimensional matrix?\nTip: The four-dimensional matrix I want to construct (size 5533) can be understood as a large matrix (55) with many small matrices (25 small 3*3 matrices in total) nested inside it.",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3463721",
                          "updatedAt": "2022-08-24T08:48:52Z",
                          "publishedAt": "2022-08-24T08:48:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no there are no tensor variables in moose. You may use a very large array if it's convenient with regards to the equations",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3465234",
                          "updatedAt": "2022-08-24T12:17:58Z",
                          "publishedAt": "2022-08-24T12:17:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dingqiushi"
                          },
                          "bodyText": "Thanks for your reply, I saw this definition in the Eigen library and it seems to represent a four dimensional variable, is there a similar expression in moose?\n\nhttp://eigen.tuxfamily.org/dox/classEigen_1_1Array.html#title4",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3470374",
                          "updatedAt": "2022-08-25T02:01:19Z",
                          "publishedAt": "2022-08-25T02:01:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can use these constructs but not for variables currently. You could create tensor material properties for example",
                          "url": "https://github.com/idaholab/moose/discussions/21922#discussioncomment-3470649",
                          "updatedAt": "2022-08-25T03:02:36Z",
                          "publishedAt": "2022-08-25T03:02:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem while using HEX20 elements with AD",
          "author": {
            "login": "Sina-av"
          },
          "bodyText": "Hi all!\nI try to run a simple 3D example of a solid. The body consists of a single cube fixed at one end and pulled from the other end. I use Moose to generate the mesh, and set\nelem_type = HEX20\n\nand accordingly set the order of displacements to second.\nFor all kernels and materials I use the AD version available in the TensorMechanics module.\nI get a Libmesh error massage\n.../libmesh/include/metaphysicl/dynamic_std_array_wrapper.h, line 125, compiled Aug 23 2022 at 15:50:25\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\n\nHowever, the simulation runs without a problem when I set the element type to Hex8.\nBelow is the input file:\nE = 35000.\nnu = 0.2\n\nK = '${fparse E/3/(1-2*nu)}'\nG = '${fparse E/2/(1+nu)}'\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  order = second\n[]\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 1\n    ny = 1\n    nz = 1\n    elem_type = HEX20\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n[]\n\n[Kernels]\n  [solid_x]\n    type = ADStressDivergenceTensors\n    variable = disp_x\n    component = 0\n  []\n  [solid_y]\n    type = ADStressDivergenceTensors\n    variable = disp_y\n    component = 1\n  []\n  [solid_z]\n    type = ADStressDivergenceTensors\n    variable = disp_z\n    component = 2\n  []\n[]\n\n[BCs]\n  [xfix]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom'\n    value = 0\n  []\n  [yfix]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0\n  []\n  [zfix]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom'\n    value = 0\n  []\n  [pull]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = 'top'\n    function = t\n  []\n[]\n\n[Materials]\n  [strain]\n    type = ADComputeSmallStrain\n  []\n  [elasticity]\n    type = ADComputeIsotropicElasticityTensor\n    shear_modulus = ${G}\n    bulk_modulus = ${K}\n  []\n  [stress]\n    type = ADComputeLinearElasticStress\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu       superlu_dist                 '\n\n  line_search = none\n  automatic_scaling = true\n\n  dt = 0.1\n  end_time = 0.1\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-8\n[]\n\nThanks a lot.",
          "url": "https://github.com/idaholab/moose/discussions/21929",
          "updatedAt": "2022-08-24T23:46:54Z",
          "publishedAt": "2022-08-24T22:16:31Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis error is typical from having an AD derivative container that is too small.\nYou will need to recompile with a larger container size in moose/ with\n./configure --with-derivative-size=100 to roughly double that size (it may not be enough).\nThen recompile and try again.\nIt's not very gracious but dynamically sizing these containers comes at a very high performance cost so we have statically sized them\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21929#discussioncomment-3469609",
                  "updatedAt": "2022-08-24T22:19:04Z",
                  "publishedAt": "2022-08-24T22:19:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Sina-av"
                          },
                          "bodyText": "Thank you so much, it worked!",
                          "url": "https://github.com/idaholab/moose/discussions/21929#discussioncomment-3469882",
                          "updatedAt": "2022-08-24T23:46:55Z",
                          "publishedAt": "2022-08-24T23:46:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Finite discrete element method in MOOSE",
          "author": {
            "login": "caowen1510957"
          },
          "bodyText": "Hello,\n\n\nIs there a Module for the Finite discrete element method in MOOSE?\nhttps://en.wikipedia.org/wiki/Discrete_element_method\n\n\nFor fracturing modeling, phase-field, and discrete element method, can anyone provide a good Pro and Con for these two methods?\n\n\nOr is there a \"better (advanced)\" method adapted in MOOSE for fracturing induced by dynamic loading?",
          "url": "https://github.com/idaholab/moose/discussions/21898",
          "updatedAt": "2022-09-02T19:55:55Z",
          "publishedAt": "2022-08-19T14:20:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@recuero",
                  "url": "https://github.com/idaholab/moose/discussions/21898#discussioncomment-3432134",
                  "updatedAt": "2022-08-19T14:47:00Z",
                  "publishedAt": "2022-08-19T14:47:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "We do not have DEM implemented in MOOSE.  For fracture modeling,  we have XFEM, PF and Peridynamics.  You should be able to find literatures to discuss their pro and cons in details.",
                  "url": "https://github.com/idaholab/moose/discussions/21898#discussioncomment-3432238",
                  "updatedAt": "2022-08-19T14:58:40Z",
                  "publishedAt": "2022-08-19T14:58:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "caowen1510957"
                          },
                          "bodyText": "We do not have DEM implemented in MOOSE. For fracture modeling, we have XFEM, PF and Peridynamics. You should be able to find literatures to discuss their pro and cons in details.\n\nThanks, the following question, for the boundary, is there an option to add an absorbing boundary?",
                          "url": "https://github.com/idaholab/moose/discussions/21898#discussioncomment-3432454",
                          "updatedAt": "2022-08-19T15:24:53Z",
                          "publishedAt": "2022-08-19T15:24:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "We do not have DEM implemented in MOOSE. For fracture modeling, we have XFEM, PF and Peridynamics. You should be able to find literatures to discuss their pro and cons in details.\n\nThanks, the following question, for the boundary, is there an option to add an absorbing boundary?\n\nThere is a way to apply simple absorbing boundary conditions, check this  #20850. Also, a Robin-kind boundary conditions is available for electromagnetics, but I think - I have not tried it though- it may be easily extended to elastodynamics, check this https://mooseframework.inl.gov/moose/source/bcs/EMRobinBC.html and https://mooseframework.inl.gov/moose/source/bcs/VectorTransientAbsorbingBC.html.",
                          "url": "https://github.com/idaholab/moose/discussions/21898#discussioncomment-3465273",
                          "updatedAt": "2022-08-24T12:22:46Z",
                          "publishedAt": "2022-08-24T12:22:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "gap boundary sequence influenced GapHeatTransfer result",
          "author": {
            "login": "BoZeng1997"
          },
          "bodyText": "Hi,\nI am doing a 2d steady thermal diffusion simulation with gap radiation on a two separated quarter annuluses. I found that the sequence I specify the primary and secondary boundary has an influence on the resulting temperature field. gap_surface_0 as primary the simulation did not converge. Specifying two GapHeatTransfer for 0-1 and 1-0  respectively resulted in low temperature at the corners as shown in the figure. However, if I only specify 1 as primary and 0 as secondary (which matches the direction of heat flux across the gap), no corner temperature issue.\nFrom my shallow understanding of the code, this object is written to consider heat transfer from both sides. So something was not right about my implementation. Please help me on it.",
          "url": "https://github.com/idaholab/moose/discussions/21759",
          "updatedAt": "2022-09-02T19:56:24Z",
          "publishedAt": "2022-08-02T21:25:52Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "BoZeng1997"
                  },
                  "bodyText": "[GlobalParams]\n  temperature = T\n[]\n\n[Mesh]\n  [ori]\n    type = FileMeshGenerator\n    file = 'radiation_2d.msh'\n  []\n  [drl]\n    type = BlockDeletionGenerator\n    input = ori\n    block = 'void_center void_pellet'\n  []\n[]\n\n[Variables]\n  [T]\n    [InitialCondition]\n      type = ConstantIC\n      value = 23.0\n    []\n  []\n[]\n\n[Kernels]\n  [diff]\n    type = ADHeatConduction #ADHeatConduction\n    variable = 'T'\n    thermal_conductivity = thermal_conductivity\n    block = 'pellet_inner pellet_outer'\n  []\n[]\n\n[BCs]\n  [outer_temperature]\n    type = ADDirichletBC\n    variable = T\n    boundary = void_nb_0\n    value = 1304.2 # (C)\n  []\n  [inner_temperature]\n    type = ADDirichletBC\n    variable = T\n    boundary = void_center\n    value = 1001.2 # (C)\n  []\n[]\n\n[ThermalContact]\n  # [gap_pellet_01]\n  #   type = GapHeatTransfer\n  #   variable = T\n  #   primary = void_pellet_0\n  #   secondary = void_pellet_1\n  #   emissivity_primary = 0.37\n  #   emissivity_secondary = 0.37\n  #   gap_conductivity = 0.151e-3\n  #   gap_geometry_type = CYLINDER\n  #   cylinder_axis_point_1 = '0 0 0'\n  #   cylinder_axis_point_2 = '0 0 1'\n  # []\n  [gap_pellet_10]\n    type = GapHeatTransfer\n    variable = T\n    primary = void_pellet_1\n    secondary = void_pellet_0\n    emissivity_primary = 0.37\n    emissivity_secondary = 0.37\n    gap_conductivity = 0.151e-3\n    gap_geometry_type = CYLINDER\n    cylinder_axis_point_1 = '0 0 0'\n    cylinder_axis_point_2 = '0 0 1'\n  []\n[]\n\n\n[Materials]\n  [pellet_thermal_conductivity]\n    type = ADParsedMaterial\n    args = 'T'\n    f_name = 'thermal_conductivity'\n    function = '250.6e-2' #HELP CONVERGE\n    block = 'pellet_inner pellet_outer'\n  []\n[]\n\n[Postprocessors]\n  [void_1_temp]\n    type = SideAverageValue\n    variable = T\n    boundary = void_pellet_1\n  []\n  [void_0_temp]\n    type = SideAverageValue\n    variable = T\n    boundary = void_pellet_0\n  []\n  [void_1_flux]\n    type = ADSideDiffusiveFluxIntegral\n    variable = T\n    boundary = void_pellet_1\n    diffusivity = thermal_conductivity\n  []\n  [void_0_flux]\n    type = ADSideDiffusiveFluxIntegral\n    variable = T\n    boundary = void_pellet_0\n    diffusivity = thermal_conductivity\n  []\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n  automatic_scaling = true\n\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-8\n[]\n\n[Outputs]\n  [exodus]\n    type = Exodus\n    file_base = 2pellet_gap_10_noTdt_cylinder\n  []\n  print_linear_residuals = false\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3311425",
                  "updatedAt": "2022-08-02T21:30:35Z",
                  "publishedAt": "2022-08-02T21:30:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@jasondhales do you have any suggestions for this question?",
                          "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3380496",
                          "updatedAt": "2022-08-12T02:28:07Z",
                          "publishedAt": "2022-08-12T02:28:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jasondhales"
                          },
                          "bodyText": "Without quadrature = true, this will be a one way (secondary to primary, if I recall correctly) contact constraint.  With quadrature = true, the primary and secondary surfaces are used twice, swapped the second time.  This is what we recommend.\nThat being said, the mortar approach is better.",
                          "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3423571",
                          "updatedAt": "2022-08-18T14:36:03Z",
                          "publishedAt": "2022-08-18T14:36:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "By mortar approach, do you mean ModularGapConductanceConstraint together with GapFluxModelRadiation as mentioned in page\nhttps://mooseframework.inl.gov/source/constraints/ModularGapConductanceConstraint.html\nand example input deck\nhttps://github.com/idaholab/moose/blob/b3df9cac31d90926bc845ad48628b9b8e0bbb115/modules/heat_conduction/test/tests/gap_heat_transfer_mortar/large_gap_heat_transfer_test_cylinder_mortar.i\n?",
                          "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3462939",
                          "updatedAt": "2022-08-24T07:21:15Z",
                          "publishedAt": "2022-08-24T07:21:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "yes ModularGapConductanceConstraint used with various options for gap flux models (including the radiation one you mentioned) are MOOSE's thermal mortar contact objects",
                          "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3465179",
                          "updatedAt": "2022-08-24T12:09:21Z",
                          "publishedAt": "2022-08-24T12:09:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "BoZeng1997"
                  },
                  "bodyText": "Hi @jasondhales ,\nI have another question about simulation gap radiation heat transfer in MOOSE. Does GapHeatTransfer or the mortar approach work well for gaps with changing distance? Like the gaps on both sides of the green region in the image. Is this shape fine with the code or the theory of gap radiation?",
                  "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3463027",
                  "updatedAt": "2022-08-24T07:31:27Z",
                  "publishedAt": "2022-08-24T07:31:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "thermal contact is generally used in conjunction with mechanics modeling and mesh deformation, so the answer is that MOOSE's thermal models should work fine with changing gaps",
                          "url": "https://github.com/idaholab/moose/discussions/21759#discussioncomment-3465167",
                          "updatedAt": "2022-08-24T12:08:05Z",
                          "publishedAt": "2022-08-24T12:08:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Negative Jacobian From inverted Elements",
          "author": {
            "login": "kevin-wandke"
          },
          "bodyText": "I am running a simulation of a pneumatically driven soft actuator using Moose's Tensor Mechanics and contact Modules. Despite my best efforts my simulation continually fails to converge and I routinely get \"negative Jacobian\" error from libmesh.\nA quick search of previous forum posts would indicate that this type of error occurs when an element becomes inverted.\nI have attempted using a shorter timestep, as well as using hex8 elements instead of tet4 ones. Additionally, if I view the element in question, it does not appear to deform much at all over the course of the simulation. However, the element does undergo large translations and rotations. Could this be causing the difficulties, or is it possible that the solver is making a bad iteration that is inverting an element temporarily?\nPlease let me know if there is any other information I can provide that could be helpful in solving this issue!\nI have included the error message I have received below\n\nLocation of failed element 554 within mesh\n\nElement 554 on timestep 0 (right) and timestep 40 (left). It appears that while the element was rotated and translated, there was very little actual deformation.\n\nSome parts of my input file that may be helpful in diagnosing the issue:\n[Functions]\n  [rampLinear]\n    type = ParsedFunction\n    value=1e5*t\n []\n[]\n[BCs]\n     [Pressure]\n        [stress]\n        boundary = 'Inner_cavity'\n        function=rampLinear\n        use_automatic_differentiation = true\n        use_displaced_mesh = true\n        hht_alpha=-.25\n        []\n    []\n[]\n[Contact]\n  [b1]\n    primary = 'Body1 Body2 Body3 Body4 Body5 Body6 Body7 Body8'\n    secondary = 'Body1C Body2C Body3C Body4C Body5C Body6C Body7C Body8C'\n    model = frictionless\n    penalty = 0.1e5\n    formulation=penalty\n    normalize_penalty=True\n    normal_smoothing_distance = 0.1\n    newmark_beta = 0.4\n    newmark_gamma = 0.75\n    []\n   [superglue1]\n    primary = 'SG1 SG2 SG3 SG4'\n    secondary = 'SG1C SG2C SG3C  SG4C'\n    model = glued\n    penalty = 8e5\n    formulation=penalty\n    normalize_penalty=True\n    normal_smoothing_distance = 0.1\n    newmark_beta = 0.4\n    newmark_gamma = 0.75\n    []\n[]\n[Materials]\n  [strain]\n    type=ADComputeFiniteStrain\n    decomposition_method=EigenSolution  \n   []\n  [elasticity_tensor]\n    type = ADComputeElasticityTensor\n    C_ijkl = '1.684e5 0.176e5 0.176e5 1.684e5 0.176e5 1.684e5 0.754e5 0.754e5 0.754e5'\n    fill_method = symmetric9\n  []\n  [elasitc_stress]\n    type = ADComputeFiniteStrainElasticStress\n    mu=1e1\n    kappa=1e7\n  []\n    [density1]\n    type = GenericConstantMaterial\n    prop_names = density\n    prop_values = 1000e-9\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type=PJFNK\n  nl_rel_tol = 1e-4\n  nl_abs_tol =5e-4\n  l_max_its = 5\n  l_tol = 1e-7\n  nl_max_its = 20\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-pc_type -sub_pc_type -pc_asm_overlap -ksp_gmres_restart'\n  petsc_options_value = 'asm lu 20 151\n  line_search='none'\n  nl_forced_its=2\n  automatic_scaling=true\n  compute_scaling_once=false\n  start_time=0.0\n  end_time=1\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    growth_factor=1.41\n    optimal_iterations = 8\n    dt = .001\n  []\n  [TimeIntegrator]\n  \ttype=ImplicitEuler\n  []\n  dtmin=.001\n[]",
          "url": "https://github.com/idaholab/moose/discussions/21890",
          "updatedAt": "2022-09-02T19:56:31Z",
          "publishedAt": "2022-08-18T21:47:48Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "For starters, I have two suggestions:\n\nMake sure that there aren't any rigid body modes.\nTry adding a damper, e.g. https://mooseframework.inl.gov/source/dampers/ElementJacobianDamper.html\n\nRegarding the visualization you showed for the inverted element: an inverted element typically happens between nonlinear iterations, after the solution is updated by Newton/PJFNK, and that is not the final converged solution that is being output at TIMESTEP_END. If you really want to visualize the inverted element, you could try to output the exodus file at NONLINEAR.",
                  "url": "https://github.com/idaholab/moose/discussions/21890#discussioncomment-3427924",
                  "updatedAt": "2022-08-19T02:31:02Z",
                  "publishedAt": "2022-08-19T02:31:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "For the visualization, I think in the Outputs block additional_execute_on = FAILED will output the final Exodus file with the inverted element without having to write every NONLINEAR iteration.",
                          "url": "https://github.com/idaholab/moose/discussions/21890#discussioncomment-3430835",
                          "updatedAt": "2022-08-19T11:50:03Z",
                          "publishedAt": "2022-08-19T11:50:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you check the coordinates of that element? It definitely doesnt look deformed in the picture. Is it involved in contact?",
                          "url": "https://github.com/idaholab/moose/discussions/21890#discussioncomment-3432241",
                          "updatedAt": "2022-08-19T14:58:47Z",
                          "publishedAt": "2022-08-19T14:58:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "kevin-wandke"
                          },
                          "bodyText": "My apologies for the late response.\nI am confident that there are not any rigid body modes as if that is the case I usually see solves fail in the first timestep or two, as opposed to later in the simulation. Furthermore, I did check and there are DirichletBC's constraining the motion in the X, Y and Z directions.\nRegarding the coordinates of the deformed element, I used the thresholding operation in paraview in order to identify the proper element ID , so I am confident that the proper element is displayed.\nIn addition to implementing a damper, are there any other solver parameters that might prevent this type of error?",
                          "url": "https://github.com/idaholab/moose/discussions/21890#discussioncomment-3458867",
                          "updatedAt": "2022-08-23T17:27:16Z",
                          "publishedAt": "2022-08-23T17:27:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Small time steps are usually how we deal with this.\nThe element IDs are offset by one in Paraview (starts at 1 we start at 0) so maybe the element was not the right one?",
                          "url": "https://github.com/idaholab/moose/discussions/21890#discussioncomment-3458924",
                          "updatedAt": "2022-08-23T17:35:53Z",
                          "publishedAt": "2022-08-23T17:35:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Domain decomposition method",
          "author": {
            "login": "liangLL888"
          },
          "bodyText": "How to use non overlapping domain decomposition method to solve problems in MOOSE? Are there any examples?",
          "url": "https://github.com/idaholab/moose/discussions/21896",
          "updatedAt": "2022-09-02T19:56:51Z",
          "publishedAt": "2022-08-19T05:10:29Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nMost domain decomposition in MOOSE is non-overlapping. Overlapping is done as necessary (ghosting) when information is needed from neighbor domains.\nAny example or simulation in MOOSE may be run in parallel by running:\nmpirun -n <number of parallel processes> <application_executable> -i <input_file.i>\nI could not locate the mpi tutorial. You may find one online though\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21896#discussioncomment-3432288",
                  "updatedAt": "2022-08-19T15:05:48Z",
                  "publishedAt": "2022-08-19T15:05:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "The default preconditioning type used by PETSc and MOOSE when you run in parallel is bjacobi which is not overlapping. If you wanted a domain decomposition preconditioning type with overlap then you would use -pc_type asm and then you can specify different amounts of overlap with \u2018-pc_asm_overlap\u2018. The default value for that option is 1. A value of 0 would be equivalent to bjacobi (block Jacobi).",
                  "url": "https://github.com/idaholab/moose/discussions/21896#discussioncomment-3455818",
                  "updatedAt": "2022-08-23T11:43:27Z",
                  "publishedAt": "2022-08-23T11:42:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "kernel help",
          "author": {
            "login": "Gallasd"
          },
          "bodyText": "Hello, I want to carry out thermal topology optimization research based on moose. The optimized design variable is the thermal conductivity of each element.\nSince my c++ level is very poor, I would like to ask if it is possible to give the thermal conductivity in the form of a vector in the .i file without modifying the source code. For example, a model with N elements is given a thermal conductivity vector of N \u00d7 1.",
          "url": "https://github.com/idaholab/moose/discussions/21913",
          "updatedAt": "2022-09-02T19:49:42Z",
          "publishedAt": "2022-08-22T14:02:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Yeah, you can use https://mooseframework.inl.gov/source/functions/PiecewiseConstantFromCSV.html together with https://mooseframework.inl.gov/source/userobject/PropertyReadFile.html",
                  "url": "https://github.com/idaholab/moose/discussions/21913#discussioncomment-3451558",
                  "updatedAt": "2022-08-22T22:54:08Z",
                  "publishedAt": "2022-08-22T22:54:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}