{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wMy0xNVQxNzoxNjoxMi0wNTowMM4AS3mG"
    },
    "edges": [
      {
        "node": {
          "title": "Multiple input files for single sub-app",
          "author": {
            "login": "maxposchmann"
          },
          "bodyText": "Sometimes it is handy to collect common inputs in one input file, then add on some other stuff in another input file. On the command line, I frequently use syntax like\n./moose-opt -i common_input.i additional_input.i\n\nI'd like to be able to use similar syntax to run a sub-app (in particular using stochastic tools with SamplerFullSolveMultiApp), but entering multiple input files in the input_files parameter does something else entirely.\nI thought maybe I could use cli_args to do what I wanted like:\n[MultiApps]\n  [sub]\n    type = SamplerFullSolveMultiApp\n    sampler = sampler\n    input_files = 'common_input.i'\n    cli_args = '-i additional_input.i'\n  []\n[]\n\nHowever, that doesn't get parsed the way I want, and MOOSE complains: The number of items supplied must be 1 or equal to the number of sub apps.\nAm I missing something that will make one of these options work? Is there another option?",
          "url": "https://github.com/idaholab/moose/discussions/23762",
          "updatedAt": "2023-04-29T03:42:49Z",
          "publishedAt": "2023-03-16T18:30:29Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont think we've made that work inside MultiApps. But can you try this? without the -i\n[MultiApps]\n  [sub]\n    type = SamplerFullSolveMultiApp\n    sampler = sampler\n    input_files = 'common_input.i'\n    cli_args = 'additional_input.i'\n  []\n[]\n\nWe'd be interested in the contribution if not\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23762#discussioncomment-5339507",
                  "updatedAt": "2023-03-16T22:51:15Z",
                  "publishedAt": "2023-03-16T22:51:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "maxposchmann"
                          },
                          "bodyText": "Thanks for the suggestion. When I tried that, I got Number of command line arguments does not match number of sampler columns.",
                          "url": "https://github.com/idaholab/moose/discussions/23762#discussioncomment-5345250",
                          "updatedAt": "2023-03-17T12:12:17Z",
                          "publishedAt": "2023-03-17T12:12:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxposchmann"
                          },
                          "bodyText": "I'm not sure what to suggest as the \"correct\" way to handle this. Maybe input_files could support some sort of grouping (either like {} or separated by ;). This can easily get messy since it is already a vector.\nAnother thought is that a way to achieve equivalent (but not identical) behavior would be to use input file include directives as mentioned in #20125 and #9755. Looking at those threads, it's not clear if that will eventually be implemented or not.",
                          "url": "https://github.com/idaholab/moose/discussions/23762#discussioncomment-5345707",
                          "updatedAt": "2023-03-17T13:03:12Z",
                          "publishedAt": "2023-03-17T13:03:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxposchmann"
                          },
                          "bodyText": "For other readers, in MooseApp.C there is a comment:\nfor now we only permit single input to be set for multiapps",
                          "url": "https://github.com/idaholab/moose/discussions/23762#discussioncomment-5345948",
                          "updatedAt": "2023-03-17T13:27:45Z",
                          "publishedAt": "2023-03-17T13:27:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The logic handling this parameter just needs to be adapted\n    input_files = 'common_input.i'\n\nRight now we consider 1 input per app, but we'd need some sort of vector syntax indeed",
                          "url": "https://github.com/idaholab/moose/discussions/23762#discussioncomment-5347202",
                          "updatedAt": "2023-03-17T15:32:13Z",
                          "publishedAt": "2023-03-17T15:32:12Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to generate a cylinder and gridding?",
          "author": {
            "login": "lipxisi"
          },
          "bodyText": "I want to generate a simple cylinder using mesh generators, but haven't find the specialized generator.\nWhich generator should I use and  what`s the code?\nThanks for your answer!",
          "url": "https://github.com/idaholab/moose/discussions/23773",
          "updatedAt": "2023-03-20T15:32:52Z",
          "publishedAt": "2023-03-17T15:04:00Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou ll want to use this one\nhttps://mooseframework.inl.gov/docs/site/source/meshgenerators/ConcentricCircleMeshGenerator.html\nthen this one\nhttps://mooseframework.inl.gov/docs/site/source/meshgenerators/MeshExtruderGenerator.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23773#discussioncomment-5347175",
                  "updatedAt": "2023-03-17T15:30:18Z",
                  "publishedAt": "2023-03-17T15:30:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Postprocessing",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Hello,\nI wanted to export animation for my results. When I use adaptive mesh multiple .e files are created. I can see the animation with peacock, but do not know how to export it. What is the best way to export movie file when adaptive mesh is used and multiple .e files are created?\nThanks,\nAli",
          "url": "https://github.com/idaholab/moose/discussions/23765",
          "updatedAt": "2023-04-29T03:43:24Z",
          "publishedAt": "2023-03-16T22:11:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you load it all in paraview? Peacock is great for getting things to work but not really for postprocessing\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23765#discussioncomment-5339361",
                  "updatedAt": "2023-03-16T22:18:46Z",
                  "publishedAt": "2023-03-16T22:18:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "alimostafavi24"
                  },
                  "bodyText": "Yes, ParaView works well. Thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/23765#discussioncomment-5341289",
                  "updatedAt": "2023-03-17T04:09:49Z",
                  "publishedAt": "2023-03-17T04:09:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to handle grain merging for grains with same crystal orientation in `GrainTracker` \uff1f",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nRecently, I wanted to perform grain merging based on GrainTracker, when two grains have the same crystallographic orientation, or their misorientation is below a very small value. But I'm not sure how such a merge operation should be performed in GrainTracker.\nSpecifically, when I was performing my EBSD microstructural grain growth simulation, I found that there was a twin that split the matrix grain into two grains, as shown in the image below.\n\nWhen I use the novel feature extraction and remapping algorithm developed by @permcody, due to the order parameter remapping operation, even if the twin disappears, there are still two grains left. Instead of merging into a complete grain under the same orientation as in the experiment. So I want to perform the operation of merging grains in GrainTracker based on the direct orientation relationship of the two grains.\nAny suggestions or recommendations to fix the problem would be greatly appreciated.\nThank you\nWei",
          "url": "https://github.com/idaholab/moose/discussions/22853",
          "updatedAt": "2023-03-17T01:32:57Z",
          "publishedAt": "2022-12-02T08:11:19Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi\nThere s documentation on the grain tracker on this\nhttps://mooseframework.inl.gov/moose/source/postprocessors/GrainTracker.html\nwhich part in particular would you want more information on?\nAre you planning to modify the GrainTracker?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-4293217",
                  "updatedAt": "2022-12-02T15:00:27Z",
                  "publishedAt": "2022-12-02T15:00:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Oh, yeah. Thank you very much for your reply. I have read all the public information about GrainTracker, including web, cody's two papers and graduation thesis. Of course, please forgive me for still having a lot of confusion here.\n\nAre you planning to modify the GrainTracker?\n\nYes, in order to accomplish the purpose mentioned above, I plan to further build a class based on GrainTracker to determine whether the grain needs to be merged according to the orientation relationship of adjacent grains (from the input EBSD data).\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-4298773",
                          "updatedAt": "2022-12-03T13:55:12Z",
                          "publishedAt": "2022-12-03T13:55:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "Hi Wei,\nReally happy to see this capability being exercised. It's not something I really had to work with much when I was working on this problem, but it did pop up in a few of our data sets. Briefly, there are two edge cases that have to be dealt with when working with \"twins\" (grains with the same crystallographic orientation). There's the merge case when they come together during evolution (is this even physical?) and the case where they are created due to the right combination of an odd grain shape and the right kinds of physics (again, I can't comment too much on how physical this is or not). I attempted to handle both in the snippet linked below. The way this is handled is by making sure the grains really are a twins (see the criteria starting on line 721). Ultimately, they should be represented by the same grain ID even though you have two (or more) physically disconnected features. Once two features are marked with the same ID, the GrainTracker should not attempt to remap either one of them if they get close enough to coalesce during a simulation. That's really all there is too of it from a logical point of view. I'm not sure I understand the rest of your inquiry about \"one disappearing\" but having \"two left\". It's true that the grain tracker never removes an inactive grain from the data structure, but anything that shrinks or joins together does get marked as \"INACTIVE\" and ignored by the GrainTracker for the remainder of the simulation.\n\n  \n    \n      moose/modules/phase_field/src/postprocessors/GrainTracker.C\n    \n    \n        Lines 663 to 738\n      in\n      6099fe5\n    \n  \n  \n    \n\n        \n          \n               /** \n        \n\n        \n          \n                * At this point we have should have only two cases left to handle: \n        \n\n        \n          \n                * Case 1: A grain in the new set who has an unset status (These are new grains, previously \n        \n\n        \n          \n                *         untracked) This case is easy to understand. Since we are matching up grains by \n        \n\n        \n          \n                *         looking at the old set and finding closest matches in the new set, any grain in \n        \n\n        \n          \n                *         the new set that isn't matched up is simply new since some other grain satisfied \n        \n\n        \n          \n                *         each and every request from the old set. \n        \n\n        \n          \n                * \n        \n\n        \n          \n                * Case 2: A grain in the old set who has an unset status (These are inactive grains that \n        \n\n        \n          \n                *         haven't been marked) We can only fall into this case when the very last grain on \n        \n\n        \n          \n                *         a given variable disappears during the current time step. In that case we never have \n        \n\n        \n          \n                *         a matching _var_index in the comparison loop above so that old grain never competes \n        \n\n        \n          \n                *         for any new grain which means it can't be marked inactive in the loop above. \n        \n\n        \n          \n                */ \n        \n\n        \n          \n               // Case 1 (new grains in _feature_sets): \n        \n\n        \n          \n               for (const auto grain_num : index_range(_feature_sets)) \n        \n\n        \n          \n               { \n        \n\n        \n          \n                 auto & grain = _feature_sets[grain_num]; \n        \n\n        \n          \n            \n        \n\n        \n          \n                 // New Grain \n        \n\n        \n          \n                 if (grain._status == Status::CLEAR) \n        \n\n        \n          \n                 { \n        \n\n        \n          \n                   /** \n        \n\n        \n          \n                    * Now we need to figure out what kind of \"new\" grain this is. Is it a nucleating grain that \n        \n\n        \n          \n                    * we're just barely seeing for the first time or is it a \"splitting\" grain. A grain that \n        \n\n        \n          \n                    * gets pinched into two or more pieces usually as it is being absorbed by other grains or \n        \n\n        \n          \n                    * possibly due to external forces. We have to handle splitting grains this way so as to \n        \n\n        \n          \n                    * no confuse them with regular grains that just happen to be in contact in this step. \n        \n\n        \n          \n                    * \n        \n\n        \n          \n                    * Splitting Grain: An grain that is unmatched by any old grain \n        \n\n        \n          \n                    *                  on the same order parameter with touching halos. \n        \n\n        \n          \n                    * \n        \n\n        \n          \n                    * Nucleating Grain: A completely new grain appearing somewhere in the domain \n        \n\n        \n          \n                    *                   not overlapping any other grain's halo. \n        \n\n        \n          \n                    * \n        \n\n        \n          \n                    * To figure out which case we are dealing with, we have to make another pass over all of \n        \n\n        \n          \n                    * the existing grains with matching variable indices to see if any of them have overlapping \n        \n\n        \n          \n                    * halos. \n        \n\n        \n          \n                    */ \n        \n\n        \n          \n            \n        \n\n        \n          \n                   // clang-format off \n        \n\n        \n          \n                   auto start_it = \n        \n\n        \n          \n                       std::lower_bound(_feature_sets.begin(), _feature_sets.end(), grain._var_index, \n        \n\n        \n          \n                                        [](const FeatureData & item, std::size_t var_index) \n        \n\n        \n          \n                                        { \n        \n\n        \n          \n                                          return item._var_index < var_index; \n        \n\n        \n          \n                                        }); \n        \n\n        \n          \n                   // clang-format on \n        \n\n        \n          \n            \n        \n\n        \n          \n                   // Loop over matching variable indices \n        \n\n        \n          \n                   for (MooseIndex(_feature_sets) \n        \n\n        \n          \n                            new_grain_index = std::distance(_feature_sets.begin(), start_it); \n        \n\n        \n          \n                        new_grain_index < _feature_sets.size() && \n        \n\n        \n          \n                        _feature_sets[new_grain_index]._var_index == grain._var_index; \n        \n\n        \n          \n                        ++new_grain_index) \n        \n\n        \n          \n                   { \n        \n\n        \n          \n                     auto & other_grain = _feature_sets[new_grain_index]; \n        \n\n        \n          \n            \n        \n\n        \n          \n                     // Splitting grain? \n        \n\n        \n          \n                     if (grain_num != new_grain_index && // Make sure indices aren't pointing at the same grain \n        \n\n        \n          \n                         other_grain._status == Status::MARKED && // and that the other grain is indeed marked \n        \n\n        \n          \n                         other_grain.boundingBoxesIntersect(grain) && // and the bboxes intersect \n        \n\n        \n          \n                         other_grain.halosIntersect(grain))           // and the halos also intersect \n        \n\n        \n          \n                     // TODO: Inspect combined volume and see if it's \"close\" to the expected value \n        \n\n        \n          \n                     { \n        \n\n        \n          \n                       grain._id = other_grain._id;    // Set the duplicate ID \n        \n\n        \n          \n                       grain._status = Status::MARKED; // Mark it \n        \n\n        \n          \n            \n        \n\n        \n          \n                       if (_verbosity_level > 0) \n        \n\n        \n          \n                         _console << COLOR_YELLOW << \"Split Grain Detected #\" << grain._id \n        \n\n        \n          \n                                  << \" (variable index: \" << grain._var_index << \")\\n\" \n        \n\n        \n          \n                                  << COLOR_DEFAULT; \n        \n\n        \n          \n                       if (_verbosity_level > 1) \n        \n\n        \n          \n                         _console << grain << other_grain; \n        \n\n        \n          \n                     } \n        \n\n        \n          \n                   } \n        \n    \n  \n\n\nThere is also a test you can look at here:\nhttps://github.com/idaholab/moose/blob/next/modules/phase_field/test/tests/grain_tracker_test/split_grain.i\nI'm not sure if I've answered your question, but take a look at the logic and the test and see if that's helpful. It's possible that this may not work exactly as you need it to, but we can discuss possible modifications to make it work for your needs.\nCody",
                  "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-4294782",
                  "updatedAt": "2022-12-02T18:00:31Z",
                  "publishedAt": "2022-12-02T18:00:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Hi Cody,\nI really appreciate your kind and detailed advice. Today I carefully read your suggestion, but I has some confusion about your reply, and I hope to get your further advice.\n\nThere's the merge case when they come together during evolution (is this even physical?)\n\nWe can find from the above figure that the merging of two substrate  grains is physical, when the intermediate twin disappears. I would like to ask whether  they come together here refers to the merger of twins or the merger of two substrate grains?\n\nthe case where they are created due to the right combination of an odd grain shape and the right kinds of physics (again, I can't comment too much on how physical this is or not).\n\nAlso what does they refer to here? And my current processing method is to directly import the initial EBSD structure into moose and use GrainTracker to track grains, in which the shape and type of twins are determined based on Euler angles.\n\nI'm not sure I understand the rest of your inquiry about \"one disappearing\" but having \"two left\".\n\nYes, your understanding is correct.\nHere's what I want to do based on your suggestion to accomplish grain merging\uff0cconsidering the difficulty of accurately identifying twins, I think the calculation of misorientation (based on the Euler angles of EBSD) can be performed for each grain and its adjacent grains. When their misorientation is lower than a very low value, the operation of grain._id = other_grain._id is executed to make the two grains merge. (Such merging also has physical meaning, because when the orientation difference between two grains is 0, they should be the same grain).\nThe above is my confusion about your enthusiastic suggestion and the operation I want to perform with reference to the code you gave, and I look forward to your next suggestion.\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-4298685",
                          "updatedAt": "2022-12-03T13:30:48Z",
                          "publishedAt": "2022-12-03T13:30:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Again, thank you very much for recommending such an important code block to me, considering that I need to add some new code on top of GrainTracker, so I feel that it is necessary to understand this code completely correctly, the following is my understanding of this code Understood, hope to get your affirmative answer or correction of misunderstanding,\nFor Case 1, traverse _feature_sets in the new set, and perform the following operations when grain._status == Status::CLEAR\n\n\nIf it is determined as Splitting grain, then set grain._id = other_grain._id. Among them, grain is the first part split from a mother grain in the old set, called grain A, and it does not match the new set; the other part of the split is called other_grain or grain B, and its state in the new set is set to Status::MARKED,  grain B is the same as the parent grain in the old set. Referring to the picture in your article, according to my understanding, I made the following annotations\uff0c\n\n\n\nIf (grain._var_index < _reserve_op_index),\n\nIf only one old_grain in _feature_sets_old matches the current grain, then grain._id = _feature_sets_old[old_grain_indices[0]]._id;\nIf there are more than one, Need more information to find correct candidate - contact a developer!\n\n\n\nIf the above conditions are met, then grain must be a nucleating grain.\n\n\nFor Case 2, I don\u2019t think there is much to explain. Its purpose is to make the state of Status::CLEAR in _feature_sets_old change to Status::INACTIVE in _feature_sets_old.\nThe above is my understanding of this code, looking forward to your guidance.\nHappy weekend.\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-4298746",
                          "updatedAt": "2022-12-03T14:01:21Z",
                          "publishedAt": "2022-12-03T13:48:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Hi Wei,\n\n\nThis is mostly correct. However, rather than discarding the \"mother grain\" and replacing it with two new grains (\"A\" and \"B\"), what happens with the algorithm as written is that both \"Grain A\" and \"Grain B\" will attempt to \"match up\" with the \"Mother Grain\" from the previous step. This is because at the point where they physically separate in a time step, they'll both have the same order parameter at the start of that time step, as as the middle picture of the figure indicates, they \"should\" have halos that touch. In that case, we'll allow one of the two grains to match up to the mother grain (doesn't really matter which one), and then the remaining grain will be \"detected as a split grain\" due to the criteria that I just explained. What's important though is that this isn't a case of merging twins, this is the opposite, this is a potential mechanism for creating twins (splitting)!\n\n\ni. This is exactly the case I just mentioned, the slow splitting of a grain into two child grains.\nii. This is a case where we have more than two child grains (with overlapping halos) in a single time step. This would be something like a 3-way split. I didn't think this was likely to happen so I just punted and decided to print out a message to contact the developer. I don't think you will hit this case.\n\n\nNucleation - you aren't dealing with that at all in your current sim. All of that logic only kicks in if you start using the \"reserve OP\" variables.\n\n\nSo back to your original question. Who to deal with twins merging?\nI was just reviewing the code again and realized that I specifically setup the GrainTracker to NOT treat twins in any special way (e.g. I made sure to remap one of them so that if they \"got too close\", one of them would be remapped to a new order parameter preventing them from re-merging. So you are correct, you (we) will need to adjust the grain tracker if you do indeed want to handle this case. So first order of business. I don't believe any of the logic in the \"trackGrains\" routine will need to change. Once we get the code to a place where twins re-merge, it'll be equivalent to a grain disappearing as it shrinks. Essentially in one time step, we'll have two child grains that move together to form one new grain, triggering the logic to handle the \"inactive\" grain case. Instead what needs to specifically change is how we handle twins in the remapping phase. Take a look at the logic here:\n\n  \n    \n      moose/modules/phase_field/src/postprocessors/GrainTracker.C\n    \n    \n        Lines 956 to 976\n      in\n      af38e9f\n    \n  \n  \n    \n\n        \n          \n                   // The first condition below is there to prevent symmetric checks (duplicate values) \n        \n\n        \n          \n                   if (i < j && grain1._id == grain2._id) \n        \n\n        \n          \n                   { \n        \n\n        \n          \n                     split_pairs.push_front(std::make_pair(i, j)); \n        \n\n        \n          \n                     if (grain1._var_index != grain2._var_index) \n        \n\n        \n          \n                     { \n        \n\n        \n          \n                       if (_verbosity_level > 0) \n        \n\n        \n          \n                         _console << COLOR_YELLOW << \"Split Grain (#\" << grain1._id \n        \n\n        \n          \n                                  << \") detected on unmatched OPs (\" << grain1._var_index << \", \" \n        \n\n        \n          \n                                  << grain2._var_index << \") attempting to remap to \" << grain1._var_index \n        \n\n        \n          \n                                  << \".\\n\" \n        \n\n        \n          \n                                  << COLOR_DEFAULT; \n        \n\n        \n          \n            \n        \n\n        \n          \n                       /** \n        \n\n        \n          \n                        * We're not going to try very hard to look for a suitable remapping. Just set it to \n        \n\n        \n          \n                        * what we want and hope it all works out. Make the GrainTracker great again! \n        \n\n        \n          \n                        */ \n        \n\n        \n          \n                       grain1._var_index = grain2._var_index; \n        \n\n        \n          \n                       grain1._status |= Status::DIRTY; \n        \n\n        \n          \n                     } \n        \n\n        \n          \n                   } \n        \n    \n  \n\n\nIn this logic, we are specifically dealing with twins (we know this because they share an id), but we are still remapping one of them to a new order parameter. I think the easiest thing to do would be to add a new Boolean to the GrainTracker (GrainTrackerInterface) that would prevent twins from getting remapped. Something likeremap_twins = false, then in the lines above, we simply don't remap one twin if the grain that's intersecting is the other twin.\nThe tricky bits: Implementing and testing out that new logic should be pretty easy if you have the right data set. The problem is that once you allow twins to not remap you open up several new edge cases. The first being that if you end up needing to remap a twin due to being close to an unrelated grain sharing the same order parameter, you'll need to remap the twin too and make sure there aren't any conflicts. You'll also have to add new logic to the \"trackGrains\" routine to essentially ignore messages that you may otherwise encounter from twins being close in subsequent time steps.\nMy suggestion is that you start with the Boolean and ignore the remap and see what happens. Even with the new edge cases this should be mostly working just with the new Boolean!",
                          "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-4316943",
                          "updatedAt": "2022-12-05T20:35:29Z",
                          "publishedAt": "2022-12-05T20:35:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Ok... Rereading that code block again for the third time... I'm still not getting this right. Look at the console message on line 963. It's explicitly trying to make sure the twins are on the same order parameter. This will allow them to merge if they get close enough. So, I'm again thinking that the merging case you are looking at really should be working already. I think I'll need to see a counter-example to provide better feedback.",
                          "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-4317007",
                          "updatedAt": "2022-12-05T20:44:51Z",
                          "publishedAt": "2022-12-05T20:44:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Hi Cody,\n\n... this is a potential mechanism for creating twins (splitting)!\n\n\nI totally agree with you. Case1 (for Splitting Grain) is the potential function with splitting twins.\n\n\nOnce we get the code to a place where twins re-merge, it'll be equivalent to a grain disappearing as it shrinks.\n\nYes, when it is determined that two grains (such as grain_i and grain_j) need to be merged, it is essentially to merge grain_j into grain_j (as you said one grain disappears), even if the order parameter indexes of the two grains are different.\n\nEssentially in one time step, we'll have two child grains that move together to form one new grain, triggering the logic to handle the \"inactive\" grain case.\n\nYeah, I think it is important to note that we are performing a merge operation and the new big grain has the same grain ID and _var_index as some child grain.\n\nThe problem is that once you allow twins to not remap you open up several new edge cases.\n\nYes, there may be some unexpected situations, such as merging grains to the same order parameter, this new large grain may have the same order parameter as the surrounding grains, this is what I think of the possible situation.\n\nOk, I tried to focus the Key problem on solving the merging of two grains, even though they have different order parameters. Specifically, when two grains (e.g. grain_i and grain_j) are identified and their order parameter indexes (e.g. gr1 and gr5) are different, how to realize the re-merger operation of these two grains?\nNext, based on your suggestion, the mergeGrainsMisorientation() function was created to do this in GrainTracker::trackGrains(), but it didn't meet our expectations, that is, Creating new unique grain in the next timestep. The core code in mergeGrainsMisorientation() is as follows,\nvoid \nGrainTracker::mergeGrainsMisorientation()\n{\n  // The simplest example: focus on specifying the merging of two grains to test how to re-merge grains\n  // For example, specifying to merge grain_i (_id == 0) and grain_j (_id == 2), and they have different order parameter indexs. Then, set `grain_j._id = grain_i._id` and `grain_j._id = grain_i._id`\n  for (const auto i : index_range(_feature_sets))\n  {\n    for (const auto j : index_range(_feature_sets))\n      if (_feature_sets[i]._id == 0 && _feature_sets[j]._id == 2)\n      {\n        // only make the Grain id of grain_j become the Grain id of grain_i,\n        // And the order parameter index modification operation is executed in remap algorithm;\n        std::cout << \"merging grain_i \" << _feature_sets[i]._id << \" and grain_j \" << _feature_sets[j]._id << std::endl;     \n        std::cout << \"merging grain_i._var_index \" << _feature_sets[i]._var_index << \" and grain_j._var_index \" << _feature_sets[j]._var_index << std::endl;   \n\n        _feature_sets[j]._id =  _feature_sets[i]._id;\n        _feature_sets[j]._var_index =  _feature_sets[i]._var_index;\n        std::cout << \"the grain_j._id \" << _feature_sets[j]._id << std::endl;\n        std::cout << \"the grain_j._var_index \" << _feature_sets[j]._var_index << std::endl;\n        break;\n\n        // grain_adj._status = Status::INACTIVE;     \n      }\n  }  \n}\nAnd the terminal outputs the following information, indicating that the merging of grains is not successful,\n...\nTime Step 0, time = 0\n...\n\nTime Step 1, time = 0\n...\nmerging grain_i 0 and grain_j 2\nmerging grain_i._var_index 1 and grain_j._var_index 5\nthe grain_j._id 0\nthe grain_j._var_index 1\nFinished inside of GrainTracker\n...\n\nTime Step 2, time = 10.5, dt = 5.5\n...\n\ufffd[32mMarking Grain 0 as INACTIVE (variable index: 1)\n\ufffd[39m\ufffd[33mNucleating Grain Detected  (variable index: 5)\n\ufffd[39m\ufffd[33m\n*****************************************************************************\nCouldn't find a matching grain while working on variable index: 5\nCreating new unique grain: 10\nGrain ID: 10\n...\n\nFinished Executing    \n\nSo, in general, I have tried to achieve the simplest grain merging function these days, without considering the remap algorithm. However, even though the merge operation was performed at Time Step 1, it was recognized as a new grain at Time Step 2, or because grain_j._var_index has not changed.  In addition, I also provide the complete code modification for GrainTrack and input file (vt_10.i) to prevent me from missing key information.\nFinally, my question is how to modify the operation of merging grains. And it seems that even if _feature_sets[j]._var_index =  _feature_sets[i]._var_index; is executed, _feature_sets[j]._var_index is still 5 at Time Step 2;\nThank you very much for your enthusiastic guidance and look forward to your next feedback.\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-4323983",
                          "updatedAt": "2022-12-06T15:03:57Z",
                          "publishedAt": "2022-12-06T15:00:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Wei,\nSorry it's taken me so long to get back to you. I still need to think about this a bit more, but I want to at least communicate the purpose and intent of a few of these function to suggest what you can look at to resolve this behavior.\nYou mention here at the bottom of your thread that the twin is recognized as a new grain in time step 2. That piece of information is critical because once the GrainTracker \"thinks\" it's a separate grain, it'll certainly make sure that it stays apart from every other grain so things will not re-merge as you've tried here. You can't force the re-merge outcome in the GrainTracker at all, it acts more like a Postprocessor than a \"Kernel\". Instead, the key to getting this to work properly is to setup the right conditions so that remerging will occur naturally during the solution phase. Essentially this will happen automatically if any two grains with the same order parameter get \"too close\".\nAgain, without looking at the code, what needs to happen is that information about twins is preserved so that we can force them to be on the same order parameter all the time. This means that any time any twin gets remapped to a different order parameter, we'll want to make the twin follow as well. In my opinion, this is all that needs to happen.\nI need to find some time to look at the code as I was pretty sure that I had already done this. It's possible the algorithm just has a bug, or perhaps I just didn't finish? I thought about these cases back when I implemented these algorithms, but I only had a single test case that I created. The same ones that I used to generate those images for the splitting and remerging cases.\nI'll let you know if I see anything that should be investigated further.\nBest Regards,\nCody",
                          "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-4402396",
                          "updatedAt": "2022-12-14T17:12:36Z",
                          "publishedAt": "2022-12-14T17:12:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Hi permcody,\nI believe that the grain merging problem has now been successfully resolved, with some modifications made to GrainTrack. Below is my approach and code for addressing the issue, although it may not be perfect. I would appreciate any feedback or comments you may have.\n\nYou can't force the re-merge outcome in the GrainTracker at all, it acts more like a Postprocessor than a \"Kernel\". Instead, the key to getting this to work properly is to setup the right conditions so that remerging will occur naturally during the solution phase.\n\nYes, I customized the GrainTrackerGG2 to handle grain merging operations only when certain conditions are met, such as when the misorientation angle is less than 1\u00b0.\nBelow are the three steps or stages involved in accomplishing the merging process:\n\nInitially, I created GrainTrackerGG by building upon GrainTracker. Then, I developed the createAdjacentIDVector() function to obtain the vector of each grain and its adjacent grain ID;\nAfterwards, I created GrainTrackerGG2, which inherits from GrainTrackerGG, and I overrode the trackGrains and remapGrains methods.\nFinally, I added the merging functionality to GrainTrackerGG2.\n\nThe following code is primarily responsible for handling the merging operation in GrainTrackerGG2:\nvoid\nGrainTrackerGG2::remapGrains()\n{\n  ...\n     // Case 2 (inactive grains in _feature_sets_old)\n    for (auto & grain : _feature_sets_old)\n    {\n       ...\n            /**\n             * We're not going to try very hard to look for a suitable remapping. Just set it to\n             * what we want and hope it all works out. Make the GrainTrackerGG great again!\n             */\n            grain1._var_index = grain2._var_index;\n            grain1._status |= Status::DIRTY;\n\n            if (_remerge_grains)  // by weipeng\n              grain_id_to_new_var.emplace_hint(\n                  grain_id_to_new_var.end(),\n                  std::pair<unsigned int, std::size_t>(grain1._id, grain1._var_index));\n       ...\n     }\n  ...\n}\n\nvoid \nGrainTrackerGG2::mergeGrainsBasedMisorientation()\n{\n  ...\n      if (misor_angle < threshold_merge)\n      {\n        _console << COLOR_YELLOW << \"Grain #\" << grain_i._id << \" and Grain #\" << grain_j._id\n                 << \" was merged (misor: \" << misor_angle << \").\\n\"\n                 << COLOR_DEFAULT;\n\n        grain_j._id = grain_i._id;\n      }\n  ...\n}\nThe result of the execution is as follows,\n\nFinally, I would like to express my sincere gratitude for your generous assistance, which helped me to successfully complete this task. I would greatly appreciate any feedback or suggestions you may have regarding this aspect. Additionally, I would be more than happy to merge this functionality into GrainTracker if it would be useful.\nBest Regards,\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-5316856",
                          "updatedAt": "2023-03-15T03:53:25Z",
                          "publishedAt": "2023-03-15T03:53:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@permcody",
                          "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-5317222",
                          "updatedAt": "2023-03-15T05:09:26Z",
                          "publishedAt": "2023-03-15T05:09:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Wei,\nThis is fantastic work! I'm very happy to see that you've managed to enhance the capabilities for your need. If you are interested, I would invite you to add your contributions to the MOOSE repository. I believe that the code above is reasonable to add to the existing GrainTracker class. Provided it be activated with appropriate input parameters, which it appears you have already done. I would also entertain adding a new inherited class provided we minimize copying from the existing class, even if that means we need to add additional hooks in the existing class to support your implementation. In either case, we are interested in this work.\nI would ask for the following:\n\nYour new and modified code changes\nOne or more regression tests that exercise your new logic\nDocumentation: Either added to the existing GrainTracker.md markdown, or a new Markdown file if you decide to contribute a new class.\n\nWe can assist you throughout the process!\nBest Regards,\nCody",
                          "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-5326164",
                          "updatedAt": "2023-03-15T19:48:10Z",
                          "publishedAt": "2023-03-15T19:48:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Permcody,\nIt is a great honor to receive your approval, and I am excited about merging my code into Moose. Thank you for the opportunity. I would also appreciate your guidance on the standard process of code development. As a Moose rookie, I am eager to learn and improve.\nNext, I will provide a detailed explanation of the additions and modifications I made to FeatureFloodCount and GrainTracker. And I also created PR #23757 to merge this part of the code.\nFirst, I added adjacent_id to the FeatureData class in FeatureFloodCount. This is used to store the grain ID of each adjacent grain for each feature or grain. It should be noted that the storage of the vector of adjacent grain IDs is done in GrainTracker. Additionally, I created three functions, getFeatureID, getAdjacentID, and getAdjacentGrainNum, to extract relevant information.\nBut here there are some warnings, and I don't know how to eliminate them,\n/home/pw-moose/projects/moose/modules/phase_field/build/header_symlinks/FeatureFloodCount.h:324:26: warning: 'FeatureFloodCount::FeatureData::_boundary_intersection' will be initialized after [-Wreorder]\n  324 |     BoundaryIntersection _boundary_intersection;\n      |                          ^~~~~~~~~~~~~~~~~~~~~~\n/home/pw-moose/projects/moose/modules/phase_field/build/header_symlinks/FeatureFloodCount.h:305:31: warning:   'std::vector<unsigned int> FeatureFloodCount::FeatureData::_adjacent_id' [-Wreorder]\n  305 |     std::vector<unsigned int> _adjacent_id;\n      |                               ^~~~~~~~~~~~\n/home/pw-moose/projects/moose/modules/phase_field/build/header_symlinks/FeatureFloodCount.h:171:5: warning:   when initialized here [-Wreorder]\n  171 |     FeatureData(std::size_t var_index,\nSecond, add createAdjacentIDVector() in GrainTracker.h to complete the purpose of creating adjacent grain vector;\nThird,  we need to add an interface for grain merging by creating a virtual function called \"mergeGrainsBasedMisorientation\" in the GrainTracker. I am planning to create a derived class, GrainTrackerMerge, which will be responsible for performing the detailed operations of grain merging based on the calculation of misorientation.\nFourth, add the function of grain merging to the derived class GrainTrackerMerge, based on the calculation of misorientation. But after the creation is complete, I run a test and it shows an error like this,\n===================================================================================\n= \u00a0 BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n= \u00a0 PID 2945348 RUNNING AT pwmoose-PowerEdge-T640\n= \u00a0 EXIT CODE: 11\n= \u00a0 CLEANING UP REMAINING PROCESSES\n= \u00a0 YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\n===================================================================================\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Segmentation fault (signal 11)\nThis typically refers to a problem with your application.\nPlease see the FAQ page for debugging suggestions\nI suspect that the error may be related to creating the derived class GrainTrackerMerge based on GrainTracker. Although it may seem like a simple mistake, I would appreciate your guidance on this issue.\nFifthly, as I was unable to resolve the aforementioned bug, I added the function of grain merging directly to GrainTracker. Although I recognize that this may not be the wisest decision, I intend to move the last part of the code to the derived class GrainTrackerMerge once the bug is resolved\uff1b\nSixthly, I created a test to verify the newly modified GrainTracker, which I named \"test_GrainTrackerMerge.i\", and placed it in the directory \"./modules/phase_field/test/tests/GrainTrackerMerge\". However, when I attempted to run the test, I encountered the following error:\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 21\n\n*** ERROR ***\nA 'EulerAngleFileReader' is not a registered object.\n\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\nAfterwards, I copied the \"test_GrainTrackerMerge.i\" file to my own APP-yinglong directory and ran the test, which passed successfully. The results of the operation are shown below:\n\nOverall, I believe that I have successfully added the misorientation-based grain merging functionality to the grain tracker algorithm. I made some modifications and additions to the FeatureFloodCount and GrainTracker classes, and created a derived class, GrainTrackerMerge, for specific implementation. However, I hope to get your assistance in resolving the two bugs mentioned above.\nBest Regards,\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/22853#discussioncomment-5333357",
                          "updatedAt": "2023-03-16T13:43:12Z",
                          "publishedAt": "2023-03-16T12:40:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PETSc check error and libMesh compiling error",
          "author": {
            "login": "RWTHLHK"
          },
          "bodyText": "Hello guys, I need to install moose on a HPC cluster, but after compiling and check if PETSc works, I got the following error:\nRunning check examples to verify correct installation\nUsing PETSC_DIR=/home/../projects/moose/scripts/../petsc and PETSC_ARCH=arch-moose\nC/C++ example src/snes/tutorials/ex19 run successfully with 1 MPI process\nC/C++ example src/snes/tutorials/ex19 run successfully with 2 MPI processes\nC/C++ example src/snes/tutorials/ex19 run successfully with hypre\nC/C++ example src/snes/tutorials/ex19 run successfully with mumps\nC/C++ example src/snes/tutorials/ex19 run successfully with superlu_dist\n0a1,45\n> HDF5-DIAG: Error detected in HDF5 (1.12.1) MPI-process 0:\n>   #000: H5F.c line 532 in H5Fcreate(): unable to create file\n>     major: File accessibility\n>     minor: Unable to open file\n>   #001: H5VLcallback.c line 3282 in H5VL_file_create(): file create failed\n>     major: Virtual Object Layer\n>     minor: Unable to create file\n>   #002: H5VLcallback.c line 3248 in H5VL__file_create(): file create failed\n>     major: Virtual Object Layer\n>     minor: Unable to create file\n>   #003: H5VLnative_file.c line 63 in H5VL__native_file_create(): unable to create file\n>     major: File accessibility\n>     minor: Unable to open file\n>   #004: H5Fint.c line 1834 in H5F_open(): unable to open file: name = '/tmp/bq407628/login_19195/petsc.vJ5tzR.h5', tent_flags = 13\n>     major: File accessibility\n>     minor: Unable to open file\n>   #005: H5FD.c line 723 in H5FD_open(): open failed\n>     major: Virtual File Layer\n>     minor: Unable to initialize object\n>   #006: H5FDmpio.c line 850 in H5FD__mpio_open(): MPI_File_open failed: MPI error string is 'MPI_ERR_NO_SUCH_FILE: no such file or directory'\n>     major: Internal error (too specific to document in detail)\n>     minor: Some MPI function failed\n> [0]PETSC ERROR: --------------------- Error Message --------------------------------------------------------------\n> [0]PETSC ERROR: Error in external library\n> [0]PETSC ERROR: Error in HDF5 call H5Fcreate() Status -1\n> [0]PETSC ERROR: See https://petsc.org/release/faq/ for trouble shooting.\n> [0]PETSC ERROR: Petsc Release Version 3.16.6, unknown \n> [0]PETSC ERROR: /rwthfs/rz/cluster/home/bq407628/projects/moose/petsc/src/vec/vec/tests/ex47 on a arch-moose named nrm215.hpc.itc.rwth-aachen.de by bq407628 Fri Mar 17 00:39:18 2023\n> [0]PETSC ERROR: Configure options --download-hypre=1 --with-shared-libraries=1 --download-hdf5=1 --download-hdf5-fortran-bindings=0   --with-debugging=no --download-fblaslapack=1 --download-metis=1 --download-ptscotch=1 --download-parmetis=1 --download-superlu_dist=1 --download-mumps=1 --download-strumpack=1 --download-scalapack=1 --download-slepc=1 --with-mpi=1 --with-openmp=1 --with-cxx-dialect=C++11 --with-fortran-bindings=0 --with-sowing=0 --with-64-bit-indices \n> [0]PETSC ERROR: #1 PetscViewerFileSetName_HDF5() at /rwthfs/rz/cluster/home/bq407628/projects/moose/petsc/src/sys/classes/viewer/impls/hdf5/hdf5v.c:409\n> [0]PETSC ERROR: #2 PetscViewerFileSetName() at /rwthfs/rz/cluster/home/bq407628/projects/moose/petsc/src/sys/classes/viewer/impls/ascii/filev.c:649\n> [0]PETSC ERROR: #3 PetscViewerHDF5Open() at /rwthfs/rz/cluster/home/bq407628/projects/moose/petsc/src/sys/classes/viewer/impls/hdf5/hdf5v.c:534\n> [0]PETSC ERROR: #4 main() at ex47.c:25\n> [0]PETSC ERROR: PETSc Option Table entries:\n> [0]PETSC ERROR: -filename /tmp/bq407628/login_19195/petsc.vJ5tzR.h5\n> [0]PETSC ERROR: ----------------End of Error Message -------send entire error message to petsc-maint@mcs.anl.gov----------\n> --------------------------------------------------------------------------\n> MPI_ABORT was invoked on rank 0 in communicator MPI_COMM_WORLD\n> with errorcode 76.\n> \n> NOTE: invoking MPI_ABORT causes Open MPI to kill all MPI processes.\n> You may or may not see output from other processes, depending on\n> exactly when Open MPI kills them.\n> --------------------------------------------------------------------------\n> Failure executing command /opt/MPI/openmpi-3.1.3/linux/gcc_10.1.0/bin/mpiexec -x  MPI_NAME -x  OMP_NUM_THREADS -x  LD_LIBRARY_PATH -x  PATH --hostfile /tmp/bq407628/login_19195/hostfile-711970 -np 1 /rwthfs/rz/cluster/home/bq407628/projects/moose/petsc/src/vec/vec/tests/ex47 -filename /tmp/bq407628/login_19195/petsc.vJ5tzR.h5\n/home/bq407628/projects/moose/petsc/src/vec/vec/tests\nPossible problem with ex47 running with hdf5, diffs above\n\nAnd then when I compile libMesh, the following error occurs:\n<<< Found PETSc 3.16.6 installation in /home/../projects/moose/scripts/../petsc ... >>>\nchecking whether we can compile a trivial PETSc program... no\nchecking for TAO support via PETSc... no\nconfigure: error: *** PETSc was not found, but --enable-petsc-required was specified.",
          "url": "https://github.com/idaholab/moose/discussions/23767",
          "updatedAt": "2023-04-29T03:43:30Z",
          "publishedAt": "2023-03-16T23:47:27Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSeems like HDF5 is broken.\nWhat does the diagnosiic script return in moose/scripts\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23767#discussioncomment-5340001",
                  "updatedAt": "2023-03-17T00:22:57Z",
                  "publishedAt": "2023-03-17T00:22:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Impact of CPU numbers",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Hello,\nI faced a weird problem. When I run my simulation on my linux system and on hpc with 8 CPUs, my solution will converge.\nBut when I increase the number of CPUs to 28 and 94, my simulation will diverge.\nI wanted to know whether this is a common problem and how I can resolve the convergence problem with increasing number of CPUs.\nThank you,\nAli",
          "url": "https://github.com/idaholab/moose/discussions/23764",
          "updatedAt": "2023-04-29T03:44:03Z",
          "publishedAt": "2023-03-16T22:07:19Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe preconditioning is affected by the number of CPUs. You should look at designing preconditioning that is more resilient in parallel.\nWhat does your preconditioning block look right now?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23764#discussioncomment-5339299",
                  "updatedAt": "2023-03-16T22:10:55Z",
                  "publishedAt": "2023-03-16T22:10:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "alimostafavi24"
                  },
                  "bodyText": "[Preconditioning]\n  [./SMP_PJFNK]\n    type = SMP\n    full = true\n    solve_type = Newton\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  petsc_options_iname = '-pc_type -sub_pc_type -sub_pc_factor_levels'\n  petsc_options_value = 'bjacobi  ilu          4'\n\n  nl_rel_tol  = 1e-3\n  nl_abs_tol  = 1e-3\n  nl_max_its  = 70\n  l_tol       = 1e-3\n  l_max_its   = 70\n\n  #end_time    = 200\n\n # dt = 0.001\n end_time = 10\n\n\n#adaptive time stepping\n[./TimeStepper]\n   type = IterationAdaptiveDT\n\t    dt = 0.0005\n [../]\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/23764#discussioncomment-5339314",
                  "updatedAt": "2023-03-16T22:13:06Z",
                  "publishedAt": "2023-03-16T22:13:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think the block in block jacobi depend on the partition of the problem.\nMaybe try to use the overlap parameters to sooth this?",
                          "url": "https://github.com/idaholab/moose/discussions/23764#discussioncomment-5339344",
                          "updatedAt": "2023-03-16T22:17:26Z",
                          "publishedAt": "2023-03-16T22:17:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A negative test",
          "author": {
            "login": "doquang"
          },
          "bodyText": "Hi,\nIs there any way I can determine a negative test for the TestHarness? I mean, with a particular input file, the simulation will fail. And the test will say OK, if this simulation fails.\nThanks a lot,\n/ Minh",
          "url": "https://github.com/idaholab/moose/discussions/23759",
          "updatedAt": "2023-03-16T15:35:28Z",
          "publishedAt": "2023-03-16T15:30:11Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Yes it's the runexception test",
                  "url": "https://github.com/idaholab/moose/discussions/23759#discussioncomment-5335899",
                  "updatedAt": "2023-03-16T15:31:01Z",
                  "publishedAt": "2023-03-16T15:31:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "https://mooseframework.inl.gov/python/testers/RunException.html",
                          "url": "https://github.com/idaholab/moose/discussions/23759#discussioncomment-5335903",
                          "updatedAt": "2023-03-16T15:31:18Z",
                          "publishedAt": "2023-03-16T15:31:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "doquang"
                          },
                          "bodyText": "Thank you, @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/23759#discussioncomment-5335941",
                          "updatedAt": "2023-03-16T15:35:23Z",
                          "publishedAt": "2023-03-16T15:35:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Exporting mesh generated by MOOSE",
          "author": {
            "login": "tannhorn"
          },
          "bodyText": "Hello, is it possible to export the mesh generated in MOOSE into e.g. the gmsh format? I have been looking through the documentation and the forum and haven't found anything, except for \"MOOSE supports reading and writing a large number of formats and could be extended to read more.\" in https://mooseframework.inl.gov/application_usage/mesh_block_type.html\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/23730",
          "updatedAt": "2023-03-16T08:06:05Z",
          "publishedAt": "2023-03-15T09:18:50Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo we do not have this writing capability, though we would be interested in the contribution.\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23730#discussioncomment-5322111",
                  "updatedAt": "2023-03-15T13:55:35Z",
                  "publishedAt": "2023-03-15T13:55:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "If the mesh isn't too complex I've had success using meshio, but it only does the mesh and not any associated variables etc.",
                          "url": "https://github.com/idaholab/moose/discussions/23730#discussioncomment-5326545",
                          "updatedAt": "2023-03-15T20:35:13Z",
                          "publishedAt": "2023-03-15T20:35:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tannhorn"
                          },
                          "bodyText": "Thanks, I will check it out",
                          "url": "https://github.com/idaholab/moose/discussions/23730#discussioncomment-5330604",
                          "updatedAt": "2023-03-16T08:06:05Z",
                          "publishedAt": "2023-03-16T08:06:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Time integration scheme",
          "author": {
            "login": "Richard-happy"
          },
          "bodyText": "Hello,I wonder know if there is any way to  solve PDEs with different Time integration schemes within a coupled problem.\nFor example, solving a heat conduction model with implicit-euler and  solving a linear elastic model with bdf2.",
          "url": "https://github.com/idaholab/moose/discussions/23732",
          "updatedAt": "2023-03-15T23:52:56Z",
          "publishedAt": "2023-03-15T14:23:58Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "We dont support that within the same solve (eg coupling everything in the same matrix)\nbut you could use a multiapps for this\nhttps://mooseframework.inl.gov/moose/syntax/MultiApps/index.html",
                  "url": "https://github.com/idaholab/moose/discussions/23732#discussioncomment-5322620",
                  "updatedAt": "2023-03-15T14:38:01Z",
                  "publishedAt": "2023-03-15T14:38:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Richard-happy"
                          },
                          "bodyText": "Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/23732#discussioncomment-5327688",
                          "updatedAt": "2023-03-15T23:52:55Z",
                          "publishedAt": "2023-03-15T23:52:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Installing MOOSE on windows with MSYS2",
          "author": {
            "login": "starkekr"
          },
          "bodyText": "I have been able to install libmesh and petsc with msys2 but run into trouble when trying to build MOOSE. Specifically, when linking with pcre I get the following error after running make in the test folder:\nLinking Executable /home/stark/projects/moose/test/moose_test-opt...\nC:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/12.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: C:/msys64/home/stark/projects/moose/framework/libmoose-opt.a(mesh_Unity.x86_64-w64-mingw32.opt.o):mesh_Unity.C:(.text+0xbd0d): undefined reference to `__imp__ZN7pcrecpp2RE4InitERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKNS_10RE_OptionsE'\nI realize that a native windows build is not fully supported in MOOSE (outside of WSL) but nevertheless I am trying. Any thoughts would be greatly appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/23681",
          "updatedAt": "2023-04-29T03:44:19Z",
          "publishedAt": "2023-03-09T18:24:13Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I'm surprised you got this far.\n@dschwen do you know who can help",
                  "url": "https://github.com/idaholab/moose/discussions/23681#discussioncomment-5257870",
                  "updatedAt": "2023-03-09T18:32:53Z",
                  "publishedAt": "2023-03-09T18:32:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So I talked to Daniel and while it s possible to get it to compile and to pass some of the test suite, the dynamic linking works differently so you wont be able to create an application from this MOOSE, which limits the usefulness quite a bit\nWe recommend you switch to WSL2 which has been satisfactory for many",
                          "url": "https://github.com/idaholab/moose/discussions/23681#discussioncomment-5310342",
                          "updatedAt": "2023-03-14T15:24:02Z",
                          "publishedAt": "2023-03-14T15:24:02Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "Could I just put my code into one of the modules of MOOSE and build it locally rather than using stork to build an application? I think there would be no need to build my application dynamically in that case right?",
                          "url": "https://github.com/idaholab/moose/discussions/23681#discussioncomment-5326609",
                          "updatedAt": "2023-03-15T20:46:55Z",
                          "publishedAt": "2023-03-15T20:46:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@permcody correct me if I m wrong but I think modules are linked dynamically too",
                          "url": "https://github.com/idaholab/moose/discussions/23681#discussioncomment-5326630",
                          "updatedAt": "2023-03-15T20:49:46Z",
                          "publishedAt": "2023-03-15T20:49:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "No, modules are compiled in, but yes, they each have their own library file.",
                          "url": "https://github.com/idaholab/moose/discussions/23681#discussioncomment-5327196",
                          "updatedAt": "2023-03-15T22:16:13Z",
                          "publishedAt": "2023-03-15T22:16:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}