{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wNy0yMFQwMTo0MDo1Ni0wNTowMM4AabzJ"
    },
    "edges": [
      {
        "node": {
          "title": "Nonlinear solve did not converge due to DIVERGED_FNORM_NAN.",
          "author": {
            "login": "RbmIjpb"
          },
          "bodyText": "Hello,\nI'm hoping someone can help me with my problem.\nI have a recurrent error from this code coming from\n195       double _d_phi_d_J1 = theta * theta / (2 * phi * std::pow(_Y1[_qp] * _Y1[_qp] - theta, 2)) ;\nthe intermediate messages i added to the code show the following :\nBefore solveForTheta - J1: 0, J2: 0, _Y1[_qp]: 3e+06, _Y2[_qp]: 2e+06, _h[_qp]: 300\nAfter solveForTheta - theta: 9e+12\nWarning: theta exceeded maximum allowed value. Capping at 3.96e+12\nf_dev calculation: 0\nf_dev calculation: 0\nBefore solveForTheta - J1: 0, J2: 0, _Y1[_qp]: 3e+06, _Y2[_qp]: 2e+06, _h[_qp]: 300\nAfter solveForTheta - theta: 9e+12\nWarning: theta exceeded maximum allowed value. Capping at 3.96e+12\nf_dev calculation: 0\nf_dev calculation: 0\n\nand i'm still getting\n Nonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0\nthe dbg message is this :\nThread 1 \"lollipop-dbg\" received signal SIGFPE, Arithmetic exception. 0x00007ffff38f9fb0 in NoGrowthCW::computeQpPK1Stress (this=0x555555c4a280) at /home/antilope/projects/lollipop/src/kernels/NoGrowthCW.C:195 195       double _d_phi_d_J1 = theta * theta / (2 * phi * std::pow(_Y1[_qp] * _Y1[_qp] - theta, 2)) ;\nIt seems also that all the vectors created with multiply_vector_tensor have memory allocation problem, even after initializing std::vector<double> a_bar(3) :\na_bar = {<std::_Vector_base<double, std::allocator<double> >> = {\n    _M_impl = {<std::allocator<double>> = {<__gnu_cxx::new_allocator<double>> = {<No data fields>}, <No data fields>}, <std::_Vector_base<double, std::allocator<double> >::_Vector_impl_data> = {_M_start = 0x555555d98f40,\n        _M_finish = 0x555555d98f58, _M_end_of_storage = 0x555555d98f58}, <No data fields>}}, <No data fields>}\n\nAny help will be more than welcome and greately appreciated !!\nI added the header and source file here, in .txt.\nNoGrowthCWh.txt\nNoGrowthCW .txt",
          "url": "https://github.com/idaholab/moose/discussions/28192",
          "updatedAt": "2024-07-22T19:03:00Z",
          "publishedAt": "2024-07-22T18:49:22Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou could follow these instructions\nhttps://mooseframework.inl.gov/application_development/debugging.html\nand in the debugger print to screen each variable in\n double _d_phi_d_J1 = theta * theta / (2 * phi * std::pow(_Y1[_qp] * _Y1[_qp] - theta, 2)) ;\nuntil you find the one causing the exception\nThe debugger can use a breakpoint on that exception\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28192#discussioncomment-10118206",
                  "updatedAt": "2024-07-22T19:03:01Z",
                  "publishedAt": "2024-07-22T19:03:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlowFullySaturated seems to ignore block parameter?",
          "author": {
            "login": "jmeier"
          },
          "bodyText": "Dear Moose Community,\nI've setup a Moose model with [Physics/SolidMechanics/QuasiStatic] and [PorousFlowFullySaturated]. The Model works until I start to add additional subdomains using add_subdomain_names and try to block-restrict my physis. If I understand the error I get correctly, Moose tries to assign PorousFlowFullySaturated_1PhaseP_qp to my added subdomains.\n*** ERROR ***\nThe 'block' parameter of the object 'PorousFlowFullySaturated_1PhaseP_qp' must be a subset of the 'block' parameter of the variable 'porepressure':\n    Object 'PorousFlowFullySaturated_1PhaseP_qp': 0, 1, 2, 3, 4\n    Variable 'porepressure': 0, 1, 2\n\n\nDid I understand the error correctly? If yes, how to restrict PorousFlowFullySaturated properly?\nThis is my PorousFlowFullySaturated block:\n[PorousFlowFullySaturated]\n  coupling_type = HydroMechanical\n  porepressure = porepressure\n  biot_coefficient = 1\n  fp = simple_fluid\n  stabilization = FULL\n  gravity = '0 0 0'\n  add_darcy_aux = false\n  dictator_name = ${PorousFlowDictatorName}\n  block =  '${active_block_names}'\n[]\n\nMy full input file reads:\nPorousFlowDictatorName = 'dictator'\n\n[GlobalParams]\n  time_unit = days\n  displacements = 'disp_x disp_y disp_z'\n  use_displaced_mesh = false\n[]\n\ninactive_block_names = 'Box1_Inactive Box2_Inactive'\n\n[Mesh]\n  [BaseMesh]\n    type = GeneratedMeshGenerator\n    subdomain_id = 0\n    subdomain_name = \"BaseMesh\"\n    elem_type = \"TET10\"\n    dim = 3\n    nx = 20\n    ny = 20\n    nz = 2\n    xmin = -10\n    xmax = +10\n    ymin = -10\n    ymax = +10\n    zmin = -2\n    zmax = +2\n  []\n\n  [Box1]\n    type = SubdomainBoundingBoxGenerator\n    input = \"BaseMesh\"\n    block_id = 1\n    block_name = \"Box1\"\n    location = \"INSIDE\"\n    bottom_left = \"-2 -2 +2\"\n    top_right   = \"0 +2 0\"\n  []\n\n  [Box2]\n    type = SubdomainBoundingBoxGenerator\n    input = \"Box1\"\n    block_id = 2\n    block_name = \"Box2\"\n    location = \"INSIDE\"\n    bottom_left = \"0 -2 +2\"\n    top_right   = \"+2 +2 0\"\n  []\n\n  add_subdomain_names = '${inactive_block_names}'\n[]\n\nactive_block_names = 'BaseMesh Box1 Box2'\n\n[Physics]\n  [SolidMechanics]\n    [QuasiStatic]\n      [./all]\n        strain = SMALL\n        incremental = true\n        add_variables = true\n        generate_output = 'stress_xx stress_yy stress_zz'\n        block = ${active_block_names}\n      []\n    []\n  []\n[]\n\n[PorousFlowFullySaturated]\n  coupling_type = HydroMechanical\n  porepressure = porepressure\n  biot_coefficient = 1\n  fp = simple_fluid\n  stabilization = FULL\n  gravity = '0 0 0'\n  add_darcy_aux = false\n  dictator_name = ${PorousFlowDictatorName}\n  block =  '${active_block_names}'\n[]\n\n[Variables]\n  [porepressure]\n    order = SECOND\n    family = LAGRANGE\n    scaling = 1e-5\n    block =  '${active_block_names}'\n  []\n[]\n\n# ===== Kernels: Inactive Domains =====\n[Kernels]\n  [./inactive_x]\n    type = MatDiffusion\n    block = ${inactive_block_names}\n    variable = disp_x\n    diffusivity = 1e-7\n  []\n  [./inactive_y]\n    type = MatDiffusion\n    block = ${inactive_block_names}\n    variable = disp_y\n    diffusivity = 1e-7\n  []\n  [./inactive_z]\n    type = MatDiffusion\n    block = ${inactive_block_names}\n    variable = disp_z\n    diffusivity = 1e-7\n  []\n[]\n\n[ICs]\n  [porepressure]\n    type = FunctionIC\n    variable = porepressure\n    function = '2'\n    block = ${active_block_names}\n  []\n[]\n\n[AuxVariables]\n  [p]\n    order = CONSTANT\n    family = MONOMIAL\n    block = ${active_block_names}\n  []\n  [q]\n    order = CONSTANT\n    family = MONOMIAL\n    block = ${active_block_names}\n  []\n[]\n\n[AuxKernels]\n  [p]\n    type = RankTwoScalarAux\n    rank_two_tensor = stress\n    variable = p\n    scalar_type = Hydrostatic\n    block = ${active_block_names}\n  []\n  [q]\n    type = RankTwoScalarAux\n    rank_two_tensor = stress\n    variable = q\n    scalar_type = VonMisesStress\n    block = ${active_block_names}\n  []\n[]\n\n[BCs]\n\n  [fix_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left right'\n    value = 0.0\n  []\n\n  [fix_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'front back'\n    value = 0.0\n  []\n\n  [fix_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom'\n    value = 0.0\n  []\n\n  # Pressure applied on the top surface\n  [Pressure]\n    [pressure_zmax]\n      boundary = 'top'\n      function = 1000    #Newtons\n    []\n  []\n[]\n\n[Functions]\n  [inner_pressure_method1]\n    type = ParsedFunction\n    symbol_names = 'ymin ymax v'\n    symbol_values = '-2 15 1'\n    expression = 'if(y<ymin+v*t,1e5,0)'\n  []\n  [permeability_prefactor_method1]\n    type = ParsedFunction\n    symbol_names = 'ymin ymax v'\n    symbol_values = '-2   15   1'\n    expression = 'if(y<ymin+v*t, 1e5, 1)'\n  []\n[]\n\n[FluidProperties]\n  [simple_fluid]\n    type = SimpleFluidProperties\n    bulk_modulus = 2E3\n    density0 = 1000\n    thermal_expansion = 0\n    viscosity = 9.0E-10\n    block = ${active_block_names}\n  []\n[]\n\n[Materials]\n\n  [porosity_bulk]\n    type = PorousFlowPorosityConst\n    block = ${active_block_names}\n    porosity = 0.15\n    PorousFlowDictator = ${PorousFlowDictatorName}\n  []\n\n  [undrained_density_0]\n    type = GenericConstantMaterial\n    block = ${active_block_names}\n    prop_names = density\n    prop_values = 2500\n  []\n\n  [BaseMesh_permeability_bulk]\n    type = PorousFlowPermeabilityConst\n    block = 'BaseMesh'\n    permeability = '1e-19 0 0 0 1e-19 0 0 0 1e-19'\n    PorousFlowDictator = ${PorousFlowDictatorName}\n  []\n\n  [BaseMesh_elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    block = 'BaseMesh'\n    youngs_modulus = 2500\n    poissons_ratio = 0.15\n  []\n\n\n  [Box1_permeability_bulk]\n    type = PorousFlowPermeabilityConst\n    block = 'Box1'\n    permeability = '1e-19 0 0 0 1e-19 0 0 0 1e-19'\n    PorousFlowDictator = ${PorousFlowDictatorName}\n  []\n\n  [Box1_elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    block = 'Box1'\n    youngs_modulus = 2500\n    poissons_ratio = 0.15\n  []\n\n  [BoxXX_permeability_bulk]\n    type = PorousFlowPermeabilityConst\n    block = 'Box2'\n    permeability = '1e-19 0 0 0 1e-19 0 0 0 1e-19'\n    PorousFlowDictator = ${PorousFlowDictatorName}\n  []\n\n  [BoxXX_elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    block = 'Box2'\n    youngs_modulus = 2500\n    poissons_ratio = 0.15\n  []\n\n[]\n\n\n[Preconditioning]\n  [.\\SMP]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = PJFNK\n\n  petsc_options = '-snes_converged_reason'\n\n  # best overall\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = ' lu       mumps'\n\n  line_search = none\n\n  nl_abs_tol = 1e-4\n  nl_rel_tol = 1e-6\n\n  l_max_its = 20\n  nl_max_its = 8\n\n  start_time = 0.0\n  end_time = 1.0 #17\n  [TimeSteppers]\n    [ConstantDT1]\n      type = ConstantDT\n      dt = 0.25\n    []\n  []\n\n  [Quadrature]\n    type = SIMPSON\n    order = SECOND\n  []\n[]\n\n[Outputs]\n  perf_graph = true\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/28030",
          "updatedAt": "2024-07-22T17:19:01Z",
          "publishedAt": "2024-07-01T07:40:53Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou did not block restrict the porous media action so it includes the subdomains in add_subdomain_names.\nHowever you did block restrict the porepressure Variable so it does not include them.\nThey must match. Either increase the block restriction of the Variable or block-restrict the porous media action\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9926717",
                  "updatedAt": "2024-07-01T15:00:37Z",
                  "publishedAt": "2024-07-01T15:00:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Guillaume,\nThanks for your answer. I tried to block-restrict my porous media action [PorousFlowFullySaturated] by block =  '${active_block_names}'. What else is needed to block-restrict the porous media action? Using _active = 'porepressure'_ in my [PorousFlowFullySaturated] does not help either.\nKind regards,\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9927993",
                          "updatedAt": "2024-07-01T17:04:24Z",
                          "publishedAt": "2024-07-01T17:04:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "there is no block parameters in PorousFlowFullySaturated\nhttps://mooseframework.inl.gov/source/actions/PorousFlowFullySaturated.html\nI think this might have been an omission when making these actions.",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9928430",
                          "updatedAt": "2024-07-01T17:52:32Z",
                          "publishedAt": "2024-07-01T17:52:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "there is no block parameters in PorousFlowFullySaturated\nhttps://mooseframework.inl.gov/source/actions/PorousFlowFullySaturated.html\n\nOk. Good point.\nFrom the description, the parameter \"active\" seems to do a block-restriction?\n\nIf specified only the blocks named will be visited and made active\n\nBut I get an error using active = '${active_block_names}':\nvariables listed as active (${active_block_names}) in section 'PorousFlowFullySaturated' not found in input\nSo Moose seems to expect an variable name in \"active\". But using active = 'porepressure' seems to have no effect: I'm back with my initial error message.\nSo do I understand this correctly and Moose does currently not support a block-restriction for [PorousFlowFullySaturated]?",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9928625",
                          "updatedAt": "2024-07-01T18:13:09Z",
                          "publishedAt": "2024-07-01T18:13:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok I re-read the thread. You were right! It ignores it. It is not a parameter of that action.\nIt should not be too hard to add.\nIn fact if that action was derived from PhysicsBase like we prefer now, you would not have to do it individually ;)\nbut that's a larger rework",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9928655",
                          "updatedAt": "2024-07-01T18:15:26Z",
                          "publishedAt": "2024-07-01T18:15:26Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "'active' and 'inactive' are for the parser btw, to decide which objects to create or not create in a simulation. this is mostly for debugging purposes",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9928806",
                          "updatedAt": "2024-07-01T18:26:40Z",
                          "publishedAt": "2024-07-01T18:26:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Guillaume,\nThanks for your answer and your time. If I'm reading the code correctly, PorousFlowFullySaturated is currently not inheriting from PhysicsBase. So I have to abandon PorousFlowFullySaturated for now.\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9928866",
                          "updatedAt": "2024-07-01T18:33:04Z",
                          "publishedAt": "2024-07-01T18:33:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Thanks for your answer and your time. If I'm reading the code correctly, PorousFlowFullySaturated is currently not inheriting from PhysicsBase. So I have to abandon PorousFlowFullySaturated for now.\n\nwhy is that exactly?\nYou could add the 'block' parameter without inheriting from PhysicsBase. You were very capable at modifying moose on your previous PRs :)",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9929039",
                          "updatedAt": "2024-07-01T18:53:24Z",
                          "publishedAt": "2024-07-01T18:53:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Guillaume,\nI'll have a look. But I can't promise anything.\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9932264",
                          "updatedAt": "2024-07-02T05:41:09Z",
                          "publishedAt": "2024-07-02T05:41:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "You can add all of the kernels by hand, and these will respect the block parameter in the meantime.",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9962971",
                          "updatedAt": "2024-07-05T00:01:05Z",
                          "publishedAt": "2024-07-05T00:01:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Also, thanks for finding this out! I'll fix it when I get a chance",
                          "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-9962976",
                          "updatedAt": "2024-07-05T00:01:54Z",
                          "publishedAt": "2024-07-05T00:01:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jmeier"
                  },
                  "bodyText": "If this discussion is found in the future: With #28070 the PorousFlow actions now allow block-restriction.",
                  "url": "https://github.com/idaholab/moose/discussions/28030#discussioncomment-10117395",
                  "updatedAt": "2024-07-22T17:19:02Z",
                  "publishedAt": "2024-07-22T17:19:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Dynamics/ActuallyExplicitEuler/LUMPED] is much slower than Abaqus due to computeJacobianTag and computeResidual?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi guys,\nI know that MOOSE explicit isnt optimised, but is there a way to make computeJacobianTag and computeResidual faster for lumped case? where it is just solved by direct inversion\nI looked into ActuallyExplicitEuler.C and ExplicitTimeIntegrator.C\nActuallyExplicitEuler::solve() prepares matrix into solver for all cases and feed to ExplicitTimeIntegrator::performExplicitSolve() (CONSISTENT/LUMPED/LUMP_PRECONDITIONED) via computeJacobianTag and computeResidual\nvoid\nActuallyExplicitEuler::solve()\n{\n\n  // Reset iteration counts\n  _n_nonlinear_iterations = 0;\n  _n_linear_iterations = 0;\n\n  _current_time = _fe_problem.time();\n\n  // Set time to the time at which to evaluate the residual\n  _fe_problem.time() = _fe_problem.timeOld();\n  _nonlinear_implicit_system->update();\n\n  // Compute the residual\n  _explicit_residual.zero();\n  _fe_problem.computeResidual(\n      *_nonlinear_implicit_system->current_local_solution, _explicit_residual, _nl.number());\n\n  // Move the residual to the RHS\n  _explicit_residual *= -1.0;\n\n  // Compute the mass matrix\n  auto & mass_matrix = _nonlinear_implicit_system->get_system_matrix();\n  if (!_constant_mass || (_constant_mass && _t_step == 1))\n    _fe_problem.computeJacobianTag(\n        *_nonlinear_implicit_system->current_local_solution, mass_matrix, _Ke_time_tag);\n\n  // Perform the linear solve\n  bool converged = performExplicitSolve(mass_matrix);\n\nI just wondering, is it necessary for LUMPED? Note that, i checked ExplicitTimeIntegrator::performExplicitSolve() , it's very fast, i dont think this is a problem at all.\nAt the moment, from our comparison, MOOSE explicit is 10x slower than Abaqus with the same number of cores for exactly the same case (LUMPED), I think if we make computeJacobianTag and computeResidual more efficient, MOOSE will be much faster.\nbelow are all the kernels i am currently using (which will be more complicated in the future), it should be fast and simple\n  [Kernels]\n    [./DynamicSolidMechanics] # zeta*K*vel + K * disp\n      displacements = 'disp_x disp_y disp_z'\n      use_displaced_mesh=false\n      eigenstrain_names = ini_stress\n      strain = SMALL\n      incremental = true\n      # decomposition_method = HughesWinget\n    [../]\n\n    [./inertia_x]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_x\n      density_scaling = density_scaling\n    [../]\n    [./inertia_y]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_y\n      density_scaling = density_scaling\n    [../]\n    [./inertia_z]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_z\n      density_scaling = density_scaling\n    [../]\n\n    [./gravity]\n        type = Gravity\n        use_displaced_mesh=false\n        variable = disp_z\n        function = '-9.81*if(t=0, 0, if(t>=30, 1, (t) / 30))'\n        value = 1\n    [../]\n  []\n\nThank you!\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/28105",
          "updatedAt": "2024-07-22T15:36:50Z",
          "publishedAt": "2024-07-11T14:02:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPlease follow these instructions to get us a profile of your simulation\nhttps://mooseframework.inl.gov/application_development/profiling.html\nFrom there can see if there is a hot spot we should look to improve\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10022016",
                  "updatedAt": "2024-07-11T14:30:38Z",
                  "publishedAt": "2024-07-11T14:30:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "Hey @Traiwit sorry I haven't responded in the previous discussion. If performance is the main concern, I think Derek Gaston looked at this very comparison a while ago (don't think he went too deep) and AFAIK the conclusion was that there were several little optimizations required to compete with ABAQUS or LS-DYNA. Note that these commercial codes are extremely optimized for this problem. Whereas MOOSE wasn't originally envisioned for even implicit dynamics; explicit is even newer. Given this I don't think it's a quick solution to increase the speed. It might take a consistent effort to optimize at multiple levels in the system. @recuero @dschwen are you guys planning to improve performance of the explicit solver in any of your projects?",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10023865",
                          "updatedAt": "2024-07-11T17:41:36Z",
                          "publishedAt": "2024-07-11T17:41:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @cbolisetti,\nI feel like for ActuallyExplicitEuler + LUMPED case we are close as we don't even need to use solver. we probs just need to change the way that we build matrix for this particular case before feeding into performExplicitSolve(mass_matrix).\nI can start looking into this, but not exactly sure where.\nI see @friedmud and @hugary1995 have also involved with Explicit quite a fair bit as well.\nThank you guys! we got this :)",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10030993",
                          "updatedAt": "2024-07-12T11:42:47Z",
                          "publishedAt": "2024-07-12T11:42:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Hi @GiudGiud\ni'm having hard time following the instruction there, first stupid question: do I do all that profiling inside conda moose environment or outside?\nat the moment, i cannot run\nscripts/update_and_rebuild_petsc.sh --CFLAGS=-fno-omit-frame-pointer --CXX_CXXFLAGS=-fno-omit-frame-pointer outside conda\nand I cannot run scripts/update_and_rebuild_libmesh.sh inside conda",
                  "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10027064",
                  "updatedAt": "2024-07-12T03:54:22Z",
                  "publishedAt": "2024-07-12T03:23:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "for now let's just profile moose so start from inside a conda environment, and build the oprof version of moose\nif needed you can try to profile the whole stack. in that case, why cannot you run this outside of conda?\n\nscripts/update_and_rebuild_petsc.sh --CFLAGS=-fno-omit-frame-pointer --CXX_CXXFLAGS=-fno-omit-frame-pointer outside conda",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10027491",
                          "updatedAt": "2024-07-12T05:02:14Z",
                          "publishedAt": "2024-07-12T05:02:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud\ni'm pushing it through this part now\nexport GPERF_DIR=$HOME/gperftools/installed\nexport METHOD=oprof\ncd [your-moose-app-repository]\nmake -j$MOOSE_JOBS\n\nand got this error\nLinking Library /home/moose/project/moose/framework/contrib/pcre/libpcre-oprof.la...\nLinking Library /home/moose/project/moose/framework/contrib/gtest/libgtest.la...\n/usr/bin/ld: cannot find -lmesh_oprof: No such file or directory\n/usr/bin/ld: cannot find -ltimpi_oprof: No such file or directory\ncollect2: error: ld returned 1 exit status\nmake: *** [/home/moose/project/moose/framework/moose.mk:404: /home/moose/project/moose/framework/contrib/pcre/libpcre-oprof.la] Error 1\nmake: *** Waiting for unfinished jobs....\nmake[1]: Entering directory '/home/moose/project/moose/framework/contrib/hit'\nBuilding hit for python with python3-config\nmake[1]: 'hit' is up to date.\nmake[1]: Leaving directory '/home/moose/project/moose/framework/contrib/hit'\n(base) moose@moose-AS-5014A-TT:~/project/mech_be$ \n\nI will try again on Monday, otherwise, my input file is very simple, if you have time could you please do the profiling for me?\nat the moment 1 timestep take ~5-10 sec for full scale problem, but the problem is that we need to run more than 100k steps for each run, and this will take days\n# mpiexec -n 4 ./mech_be-opt -i ./mech_be/BE_EXAMPLE/central_diff_massscaling.i\n\n# Test for the central difference time integrator in 3D.\n[GlobalParams]\nuse_displaced_mesh=false\n[]\n\n[Mesh]\n  parallel_type = distributed\n[gen]\n  type = GeneratedMeshGenerator\n  dim = 3 # Dimension of the mesh\n  nx = 10 # Number of elements in the x direction\n  ny = 10 # Number of elements in the y direction\n  nz = 20 # Number of elements in the z direction\n  xmin = 0.0\n  xmax = 1000\n  ymin = 0.0\n  ymax = 1000\n  zmin = 0.0\n  zmax = 1000\n  # allow_renumbering = false # So NodalVariableValue can index by id\n  show_info = true\n  # elem_type = HEX8\n  elem_type = TET10\n[]\n[]\n\n  \n  [Variables]\n    [./disp_x]\n    [../]\n    [./disp_y]\n    [../]\n    [./disp_z]\n    [../]\n  []\n  \n  [AuxVariables]\n    [./vel_x]\n    [../]\n    [./accel_x]\n    [../]\n    [./vel_y]\n    [../]\n    [./accel_y]\n    [../]\n    [./vel_z]\n    [../]\n    [./accel_z]\n    [../]\n  []\n  \n  [AuxKernels]\n    [./accel_x]\n      type = TestNewmarkTI\n      variable = accel_x\n      displacement = disp_x\n      first = true\n    [../]\n    [./vel_x]\n      type = TestNewmarkTI\n      variable = vel_x\n      displacement = disp_x\n      first = true\n    [../]\n\n    [./accel_y]\n      type = TestNewmarkTI\n      variable = accel_y\n      displacement = disp_y\n      first = true\n    [../]\n    [./vel_y]\n      type = TestNewmarkTI\n      variable = vel_y\n      displacement = disp_y\n      first = true\n    [../]\n\n    [./accel_z]\n      type = TestNewmarkTI\n      variable = accel_z\n      displacement = disp_z\n      first = true\n    [../]\n    [./vel_z]\n      type = TestNewmarkTI\n      variable = vel_z\n      displacement = disp_z\n      first = true\n    [../]\n  []\n\n  [Kernels]\n    [./DynamicSolidMechanics] # zeta*K*vel + K * disp\n      displacements = 'disp_x disp_y disp_z'\n      use_displaced_mesh=false\n      eigenstrain_names = ini_stress\n      strain = SMALL\n      incremental = true\n      # decomposition_method = HughesWinget\n    [../]\n\n    [./inertia_x]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_x\n      density_scaling = density_scaling\n    [../]\n    [./inertia_y]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_y\n      density_scaling = density_scaling\n    [../]\n    [./inertia_z]\n      type = InertialForce\n      use_displaced_mesh=false\n      variable = disp_z\n      density_scaling = density_scaling\n    [../]\n\n    [./gravity]\n        type = Gravity\n        use_displaced_mesh=false\n        variable = disp_z\n        function = '-9.81*if(t=0, 0, if(t>=30, 1, (t) / 30))'\n        value = 1\n    [../]\n  []\n\n\n  \n  [BCs]\n\n    [./no_x_back]\n      type = DirichletBC\n          preset = false\n      variable = disp_x\n      boundary = 'back'\n      value = 0.0\n    [../]\n    [./no_y_back]\n      type = DirichletBC\n          preset = false\n      variable = disp_y\n      boundary = 'back'\n      value = 0.0\n    [../]\n    [./no_z_back]\n      type = DirichletBC\n          preset = false\n      variable = disp_z\n      boundary = 'back'\n      value = 0.0\n    [../]\n\n   # fixed x left\n    [./no_x_left]\n      type = DirichletBC\n          preset = false\n      variable = disp_x\n      boundary = 'left'\n      value = 0.0\n    [../]\n    [./no_y_left]\n      type = DirichletBC\n          preset = false\n      variable = disp_y\n      boundary = 'left'\n      value = 0.0\n    [../]\n      \n\n    # fixed x right\n     [./no_x_right]\n       type = DirichletBC\n          preset = false\n       variable = disp_x\n       boundary = 'right'\n       value = 0.0\n     [../]\n     [./no_y_right]\n       type = DirichletBC\n          preset = false\n       variable = disp_y\n       boundary = 'right'\n       value = 0.0\n     [../]\n\n     # fixed y top\n      [./no_x_top]\n        type = DirichletBC\n          preset = false\n        variable = disp_x\n        boundary = 'top'\n        value = 0.0\n      [../]\n      [./no_y_top]\n        type = DirichletBC\n          preset = false\n        variable = disp_y\n        boundary = 'top'\n        value = 0.0\n      [../]\n\n      # fixed y bottom\n       [./no_x_bottom]\n         type = DirichletBC\n          preset = false\n         variable = disp_x\n         boundary = 'bottom'\n         value = 0.0\n       [../]\n       [./no_y_bottom]\n         type = DirichletBC\n          preset = false\n         variable = disp_y\n         boundary = 'bottom'\n         value = 0.0\n       [../]\n  []\n\n  \n   # * if(t=0, 0, if(t>=(target_time), 1, (t) / (target_time) ))\n  [Functions]\n    [./ini_xx]\n        type = ParsedFunction\n        expression = '-1.5*9.81*2700*(1000-z)*if(t=0, 0, if(t>=30, 1, (t) / 305))'\n      [../]\n      [./ini_yy]\n        type = ParsedFunction\n        expression = '-1.5*9.81*2700*(1000-z)*if(t=0, 0, if(t>=30, 1, (t) / 30))'\n      [../]\n      [./ini_zz]\n        type = ParsedFunction\n        expression = '-9.81*2700*(1000-z)*if(t=0, 0, if(t>=30, 1, (t) / 30))'\n      [../]\n  []\n  \n  [Materials]\n    [./elasticity_tensor]\n      youngs_modulus = 20e9 #Pa\n      poissons_ratio = 0.25\n      type = ComputeIsotropicElasticityTensor\n    [../]\n    [./strain]\n    #   type = ComputeFiniteStrain\n      type = ComputeIncrementalStrain\n      eigenstrain_names = ini_stress\n      displacements = 'disp_x disp_y disp_z'\n      implicit = false\n    [../]\n    [./stress]\n      type = ComputeFiniteStrainElasticStress\n    #   type = ComputeLinearElasticStress\n    [../]\n    [./density]\n      type = GenericConstantMaterial\n      prop_names = density\n      prop_values = 2700 #kg/m3\n    [../]\n    [./ini_stress]\n      type = ComputeEigenstrainFromInitialStress\n      eigenstrain_name = ini_stress\n      initial_stress = 'ini_xx 0 0 0 ini_yy 0 0 0 ini_zz'\n    [../]\n    [density_scaling]\n      type = DensityScaling\n      density = density\n      desired_time_step = 0.0005\n      output_properties = density_scaling\n      # outputs = 'exodus'\n      factor = 0.2\n    []\n  []\n  \n  [Executioner]\n    type = Transient\n    start_time = 0\n    end_time = 40\n    num_steps = 20\n    dt = 0.0005\n    [./TimeIntegrator]\n      type = CentralDifference\n      use_constant_mass = true\n      solve_type = lumped\n    [../]\n    # [TimeStepper]\n    #   type = PostprocessorDT\n    #   postprocessor = time_step\n    # []\n  []\n  \n  \n  [Outputs]\n    # exodus = true\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10028071",
                          "updatedAt": "2024-07-12T06:36:42Z",
                          "publishedAt": "2024-07-12T06:36:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "/usr/bin/ld: cannot find -lmesh_oprof: No such file or directory\n/usr/bin/ld: cannot find -ltimpi_oprof: No such file or directory\n\nok the conda path is not going to work. I thought we were shipping oprof libraries too.\nMaybe try conda info moose to see if there is a 'prof' named package",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10032607",
                          "updatedAt": "2024-07-12T14:38:17Z",
                          "publishedAt": "2024-07-12T14:38:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I won't have time to look this weekend, it looks like building from source outside the conda environment, or inside a reduced conda environment with just moose-mpich is going to be the way to build this",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10032616",
                          "updatedAt": "2024-07-12T14:39:12Z",
                          "publishedAt": "2024-07-12T14:39:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Hi guys, a quick update:\nI tried to optimise MOOSE source code today (mostly all cleaned up the kernels)\na mesh with 5,873,043 nodes and 4,361,842 elements 2nd order,  40s (dt = 0.005) took ~ 24 hrs before now down to ~15 hrs (this is for 32 cores pc)\nI still think the major issue is where they put together all the kernels and build the matrix via computeResidual() - I still couldnt understand this part of their code, very complicated\nI tried to have all the kernels off (commented all of them out and run with kernel_coverage_check = false), the simulation run super fast, and when i tried to have a fake kernel, for example\nGravityTempl<is_ad>::computeQpResidual()\n{\n  return 0;\n}\n\nthe simulation become as slow as before, so i guess the problem is pretty much come down to the way MOOSE put together the kernels and build the matrix",
                  "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10050594",
                  "updatedAt": "2024-07-15T12:16:28Z",
                  "publishedAt": "2024-07-15T12:16:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think your intuition is correct. Here's my suggestion as I think you are basically doing profiling the hard way, i.e., by recording wall time from huge runs with different configurations. Here is the easy way, as @GiudGiud suggested at the beginning:\n\nCompile your MOOSE with gperftools following the instructions.\nRun a small-ish problem and with gperftools cpuprofiler. Only a few thousand dofs is fine, just make sure the total wall time is at least a few seconds (the longer the better, apparently, as the cpuprofiler is a sampling based profiler).\nUse pprof to list hot spots, from where we can identify code regions that could be optimized.",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10050953",
                          "updatedAt": "2024-07-15T12:59:39Z",
                          "publishedAt": "2024-07-15T12:59:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Regardless, the last time I looked at this, I noticed a few ways of speeding things up at the framework level:\n\nMatrix contribution from linear kernels can be entirely skipped. We just need to compute them once at the beginning of the entire simulation. These kernels include inertial force, gravity, linear damping, and even the stress-divergence kernel in the case of linear elasticity. This will result in huge savings. Implementing this would require the tagging system, which wasn't mature at the time we looked at this issue, but this should be doable nowadays.\nMOOSE materials are evaluated on-the-fly -- meaning that they are computed along with the element loop. Ideally, we only need to reinit materials that are consumed by the kernels (together with the first bullet point, we can skip many material evaluations), but currently we always reinit all materials. This wasn't a big issue for implicit (which is what MOOSE was originally designed for), but this dominates explicit dynamics wall time.\nThe auxkernels for accelerations and velocities only need to be executed at LINEAR.\n\nIIRC, we have a constant_mass option which is basically a specialized case for the first bullet point.",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10051106",
                          "updatedAt": "2024-07-15T13:17:15Z",
                          "publishedAt": "2024-07-15T13:17:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'd also like to add that resolving the second bullet point also benefits MOOSE implicit.",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10051129",
                          "updatedAt": "2024-07-15T13:18:49Z",
                          "publishedAt": "2024-07-15T13:18:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @hugary1995\nThank you for you suggestions! they are very helpful.\nI will try to do the profiling again, then I will look into the 2nd bullet point, and the 3rd point should be as simple as just fixing the input file I assume.\nI will keep you guys updated :)",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10051248",
                          "updatedAt": "2024-07-15T13:29:10Z",
                          "publishedAt": "2024-07-15T13:29:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "1 should be the easiest to do.\nFor porous flow you have quite a few linear terms right?\nBUT as you mentioned adding a single term already slows it down too much so 1) is not enough for your case UNLESS all your kernels are linear",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10053358",
                          "updatedAt": "2024-07-15T16:32:12Z",
                          "publishedAt": "2024-07-15T16:32:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi guys\nI've been working on 2) now the run time is ~30% faster\nI have a few questions to ask:\n@GiudGiud\nwhat is FEProblem::outputStep why does it take so long?\neven i turned off the whole [Outputs] block, it's still there, is this related to data exchange after the matrix is solved?\n\nvoid\nFEProblemBase::outputStep(ExecFlagType type)\n{\n  TIME_SECTION(\"outputStep\", 1, \"Outputting\");\n\n  setCurrentExecuteOnFlag(type);\n\n  for (auto & sys : _solver_systems)\n    sys->update();\n  _aux->update();\n  if (_displaced_problem)\n    _displaced_problem->syncSolutions();\n  _app.getOutputWarehouse().outputStep(type);\n\n  setCurrentExecuteOnFlag(EXEC_NONE);\n}\n\n@hugary1995 @cbolisetti I have a question regarding constant_mass, I checked, so when we have that equal to true, we only computeQpJacobian() once at _t_step ==1\nfor example below is InertialForceTempl<false>::computeQpJacobian(), it has _du_dotdot_du and _du_dot_du terms which are updated at every timestep (right?), i'm not sure if this is the right way to do it, shouldnt it be updated at every timestep, or I missed something important here? I remember @recuero mentioned this before, but I didn't understand it back then.\n      return _test[_i][_qp] * _density[_qp] * (*_du_dotdot_du)[_qp] * _phi[this->_j][_qp] +\n             _eta[_qp] * (1 + _alpha) * _test[_i][_qp] * _density[_qp] * (*_du_dot_du)[_qp] *\n                 _phi[this->_j][_qp];\n\nThank you guys!",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10079531",
                          "updatedAt": "2024-07-18T03:15:54Z",
                          "publishedAt": "2024-07-18T03:14:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Even when you turn everything off there is still the automated checkpoint\nset wall_time_checkpoint = false\nhttps://mooseframework.inl.gov/source/outputs/Checkpoint.html\nDid you end up profiling with a profiler?",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10079558",
                          "updatedAt": "2024-07-18T03:23:51Z",
                          "publishedAt": "2024-07-18T03:22:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud\n\nabove is 20 steps version, dont think it helps much, i already set that to false before I posted it. not sure why outputStep is as big as 1/4 of the solver time.\nhere is my [Outputs]\n  [Outputs]\n    checkpoint = false\n    perf_graph = true\n    wall_time_checkpoint = false\n    # console = false\n    # exodus = true\n    # [console]\n    #   type = Console\n    #   output_screen = false\n    # []\n    [Checkpoint_out]\n      type = Checkpoint\n      num_files = 0\n      wall_time_checkpoint = false\n      enable = false\n      execute_on = FINAL\n    []\n  []\n\nRE: profiling, not yet, I can try it again (but i dont have much hope for this)",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10079850",
                          "updatedAt": "2024-07-18T04:15:37Z",
                          "publishedAt": "2024-07-18T04:15:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "void\nFEProblemBase::outputStep(ExecFlagType type)\n{\n  TIME_SECTION(\"outputStep\", 1, \"Outputting\");\n\n  setCurrentExecuteOnFlag(type);\n\n  for (auto & sys : _solver_systems)\n    sys->update();\n  _aux->update();\n  if (_displaced_problem)\n    _displaced_problem->syncSolutions();\n\nthis is probably the slow part (though a profiler will tell you for sure) (or comment them out and see if it gets out of the perf_graph)\nthese sync operations will cost you in parallel and when using the displaced mesh. We would need to detect whether the need is real (probably let the outputWarehouse make that determination based on what outputs have been created)",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10080309",
                          "updatedAt": "2024-07-18T05:47:01Z",
                          "publishedAt": "2024-07-18T05:46:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "RE:  _du_dotdot_du and _du_dot_du\ni just realised they are a constant from CentralDifference::computeTimeDerivatives()\n // used for Jacobian calculations\n  _du_dot_du = 1.0 / (2 * _dt);\n  _du_dotdot_du = 1.0 / (_dt * _dt);\n\n@GiudGiud the problem is from\n_app.getOutputWarehouse().outputStep(type); under FEProblemBase::outputStep(ExecFlagType type)\nyeh not sure what to do, maybe i should call it at a certain interval of time (like every 200 steps something like this) as I guess, it is important to output .e and other stuff",
                          "url": "https://github.com/idaholab/moose/discussions/28105#discussioncomment-10084657",
                          "updatedAt": "2024-07-18T13:13:06Z",
                          "publishedAt": "2024-07-18T13:13:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Primary helium to secondary air system (brayton) turbine not working",
          "author": {
            "login": "oh304"
          },
          "bodyText": "Hi there! I hope you are well.\nI have been using some components in moose to create a system where a heat source from some power heats up a primary system with a pressuriser, pump and heat exchanger. This primary system works fine, and I can see a nice heat up through the pipes, and eventually passing through the heat exchanger.\nThe heat exchanger is modelled using the HeatTransferFromHeatStructure1Phase component, connecting the primary and secondary pipes through a cylindrical heat structure:\n[hx]\n        [p_hx_pipe]\n            type = FlowChannel1Phase\n            position = ${p_pos_6}\n            orientation = ${down}\n            length = ${p_L6}\n            n_elems = ${p_n_elems6}\n            A = ${p_A_pipe}\n            D_h = ${p_D_pipe}\n            \n            fp = helium\n            initial_p = ${p_pressure}\n            initial_T = ${temp_out_at_hx}\n            initial_vel = ${p_initial_vel}\n        []\n        [ht1]\n            type = HeatTransferFromHeatStructure1Phase\n            hs = 'hx/heat_structure'\n            hs_side = OUTER\n            flow_channel = 'hx/p_hx_pipe'\n            Hw = 2e3\n            P_hf = ${p_L6}\n        []\n\n        [heat_structure]\n            type = HeatStructureCylindrical\n            position = ${p_pos_6_hs}\n            orientation = ${down}\n            length = ${p_L6}\n            n_elems = ${p_n_elems6}\n            names = 'region1'\n            n_part_elems = 20\n            num_rods = 10000\n            solid_properties = 'region1-mat'\n            solid_properties_T_ref = '300'\n            inner_radius = ${inner_radius}\n            widths = ${fparse s_x1 - 1}\n        []\n\n        [ht2]\n            type = HeatTransferFromHeatStructure1Phase\n            hs = 'hx/heat_structure'\n            hs_side = INNER\n            flow_channel = 'hx/s_hx_pipe'\n            Hw = 2e3\n            P_hf = ${s_L5}\n        []\n\n        [s_hx_pipe]\n            type = FlowChannel1Phase\n            position = '${s_pos_5}'\n            length = ${s_L5}\n            orientation = ${up}\n            n_elems = ${s_n_elems5}\n            A = ${s_A_pipe}\n        []\n    []\n\nThe secondary loop is then almost entirely copied from the closed brayton example in MOOSE:\nhttps://mooseframework.inl.gov/moose/modules/thermal_hydraulics/examples/brayton_cycle/brayton_cycle.html\nI then model the shaft, motor compressor and turbine as in the example above:\n    [shaft]\n        type = Shaft\n        connected_components = 'motor compressor turbine generator'\n        initial_speed = ${speed_initial}\n    [] \n    [motor]\n        type = ShaftConnectedMotor\n        inertia = ${I_motor}\n        torque = 0 # controlled\n    []\n    [generator]\n        type = ShaftConnectedMotor\n        inertia = ${I_generator}\n        torque = generator_torque_fn\n    []\n    [compressor]\n        type = ShaftConnectedCompressor1Phase\n        position = '${s_pos_3}'\n        inlet = 's/pipe2:out'\n        outlet = 's/pipe3:in'\n        A_ref = ${A_ref_comp}\n        volume = ${V_comp}\n        omega_rated = ${speed_rated}\n        mdot_rated = ${rated_mfr}\n        c0_rated = ${c0_rated_comp}\n        rho0_rated = ${rho0_rated_comp}\n        speeds = '0.5208 0.6250 0.7292 0.8333 0.9375'\n        Rp_functions = 'rp_comp1 rp_comp2 rp_comp3 rp_comp4 rp_comp5'\n        eff_functions = 'eff_comp1 eff_comp2 eff_comp3 eff_comp4 eff_comp5'\n        min_pressure_ratio = 1\n        speed_cr_I = 0\n        inertia_const = ${I_comp}\n        inertia_coeff = '${I_comp} 0 0 0'\n        speed_cr_fr = 0\n        tau_fr_const = 0\n        tau_fr_coeff = '0 0 0 0'\n    []\n    [turbine]\n        type = ShaftConnectedCompressor1Phase\n        position = '${s_pos_7}'\n        inlet = 's/pipe6:out'\n        outlet = 's/pipe7:in'\n        A_ref = ${A_ref_turb}\n        volume = ${V_turb}\n        treat_as_turbine = true\n        omega_rated = ${speed_rated}\n        mdot_rated = ${rated_mfr}\n        c0_rated = ${c0_t_rated_comp}\n        rho0_rated = ${rho0_t_rated_comp}\n        speeds = '0 0.5208 0.6250 0.7292 0.8333 0.9375'\n        Rp_functions = 'rp_turb0 rp_turb1 rp_turb2 rp_turb3 rp_turb4 rp_turb5'\n        eff_functions = 'eff_turb1 eff_turb1 eff_turb2 eff_turb3 eff_turb4 eff_turb5'\n        min_pressure_ratio = 1\n        speed_cr_I = 0\n        inertia_const = ${I_turb}\n        inertia_coeff = '${I_turb} 0 0 0'\n        speed_cr_fr = 0\n        tau_fr_const = 0\n        tau_fr_coeff = '0 0 0 0'\n    []\n\nMy issue is, the turbine doesn't seem to be working. The system is initialised through a motor powering the compressor. The motor then rampsdown, however the shaft speed falls with it. The pressure ratio in the turbine increases whilst the motor is on, but as it falls, the turbine then stops working and the pressure ratio returns to 1 for the rest of the simulation. This is not what I expect of course, but cannot understand what I am missing to get past this.\nPlease let me know if I'm missing anything obvious, and thank you for your time! :)\nOscar",
          "url": "https://github.com/idaholab/moose/discussions/28108",
          "updatedAt": "2024-07-22T14:07:22Z",
          "publishedAt": "2024-07-11T15:53:25Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@joshuahansel",
                  "url": "https://github.com/idaholab/moose/discussions/28108#discussioncomment-10024392",
                  "updatedAt": "2024-07-11T18:50:05Z",
                  "publishedAt": "2024-07-11T18:50:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "Can you summarize what you've changed from the example?",
                  "url": "https://github.com/idaholab/moose/discussions/28108#discussioncomment-10115513",
                  "updatedAt": "2024-07-22T14:07:24Z",
                  "publishedAt": "2024-07-22T14:07:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error in NearestNodeThread",
          "author": {
            "login": "jin0123456"
          },
          "bodyText": "Hello,\nI met this when I simulate about gap heat transfer based mortar,\nFailure in NearestNodeThread because solution contains inf or not-a-number entries.  This is likely due to a failed factorization of the Jacobian matrix.\n\nI found it in NearestNodeThread.C,\nif (closest_distance == std::numeric_limits<Real>::max())\n    {\n      for (unsigned int k = 0; k < n_neighbor_nodes; k++)\n      {\n        const Node * cur_node = &_mesh.nodeRef(neighbor_nodes[k]);\n        if (std::isnan((*cur_node)(0)) || std::isinf((*cur_node)(0)) ||\n            std::isnan((*cur_node)(1)) || std::isinf((*cur_node)(1)) ||\n            std::isnan((*cur_node)(2)) || std::isinf((*cur_node)(2)))\n          throw MooseException(\n              \"Failure in NearestNodeThread because solution contains inf or not-a-number \"\n              \"entries.  This is likely due to a failed factorization of the Jacobian \"\n              \"matrix.\");\n      }\n      mooseError(\"Unable to find nearest node!\");\n    }\n\nIf i use Thermalcontact to calculate gap heat transfer it would be ok but went wrong in this way.\nWhat's my problem and why would my coordinate value be nan or inf?\nI'd be grateful to the advice.",
          "url": "https://github.com/idaholab/moose/discussions/28182",
          "updatedAt": "2024-07-22T13:11:01Z",
          "publishedAt": "2024-07-19T06:08:07Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is likely a mesh issue. What do the two surfaces set for the gap heat transfer look like?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28182#discussioncomment-10097493",
                  "updatedAt": "2024-07-19T16:18:24Z",
                  "publishedAt": "2024-07-19T16:18:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "I know where I went wrong,\nI didn't define the constraint related varible lm in specific block.\nIt went well after I changed it.",
                          "url": "https://github.com/idaholab/moose/discussions/28182#discussioncomment-10114908",
                          "updatedAt": "2024-07-22T13:11:02Z",
                          "publishedAt": "2024-07-22T13:11:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "LinearFluidProperties Error",
          "author": {
            "login": "Jake-HW-Miles"
          },
          "bodyText": "Hi there,\nI am experimenting with the thermal hydraulics functionality to hopefully do some system analysis. I have made an input file that seems to work with the fluid properties in simplefluidproperties, so wanted to implement more realistic properties using the linearfluidproperties instead.\nThe implementation is as follows:\n[FluidProperties]\n    # Placeholder fluid property\n    [secondary_loop_fluid]\n        type = LinearFluidProperties\n        T_0 = ${temp_ref}\n        p_0 = ${RTP_pressure}\n        rho_0 = ${rho}\n        cv = ${salt_specific_heat}\n        a2 = 1e7 # Treat as incompressible hence dp/drho approaches infinity:\n        beta = ${coeff_of_thermal_expansion}\n        e_0 = 1.254e10\n        k = ${k}\n        mu = ${mu}\n    []\n[]\n\nHowever am met with the following error:\n*** ERROR ***\nThe following error occurred in the object \"secondary_loop_fluid\", of type \"LinearFluidProperties\".\n\nsecondary_loop_fluid: virtual void SinglePhaseFluidProperties::cv_from_v_e(libMesh::Real, libMesh::Real, libMesh::Real&, libMesh::Real&, libMesh::Real&) const derivatives not implemented.\n\nAt this stage, I require a work around - any suggestions or known fixes?",
          "url": "https://github.com/idaholab/moose/discussions/28010",
          "updatedAt": "2024-07-22T11:45:05Z",
          "publishedAt": "2024-06-27T16:30:56Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe known fixes are:\n\nto implement this routine\nto use a different fluid property UO, for example SimpleFP (I saw you used that already) or one of the generic ones, or one of the specific ones if your field is in the list of the pre-implemented ones already. Which fluid are you using?\n\nHow comfortable are you with C++? For implementing\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9896500",
                  "updatedAt": "2024-06-27T17:06:05Z",
                  "publishedAt": "2024-06-27T16:33:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nI ended up taking a look and finding some mistakes in LinearFP.\nThe missing routine and the routine you needed can be found in this pull request\n#28026\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9920264",
                          "updatedAt": "2024-07-01T01:43:01Z",
                          "publishedAt": "2024-07-01T01:43:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "Thank you very much Guillaume! I will keep an eye out for this",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9923767",
                          "updatedAt": "2024-07-01T09:50:00Z",
                          "publishedAt": "2024-07-01T09:49:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Hi Jake, I'm also interested in which fluid you're using. You say you want to use a more realistic equation of state, but LinearFluidProperties might not fit that description. We've considered removing this class.",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9927301",
                          "updatedAt": "2024-07-01T15:54:01Z",
                          "publishedAt": "2024-07-01T15:54:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "I was originally going to use NaClFluidProperties\nBut the range of validity concerned me, as I want liquid phase, so decided to define it another way. This does not need to perfect at this stage.",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9927355",
                          "updatedAt": "2024-07-01T15:59:31Z",
                          "publishedAt": "2024-07-01T15:59:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes NaClFluidProperties is not designed for THM or the NS module. It s for porous flow applications",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-9928772",
                          "updatedAt": "2024-07-01T18:21:26Z",
                          "publishedAt": "2024-07-01T18:21:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "Hi both! I see that #28026 has been merged now! Thank you, this is good to have.\nThe desire to use this FP in the first instance was to get some variation in the FP with temperature. For achieving a more realistic equation of state, I considered using the tabulated approach or TemperaturePressureFunctionFluidProperties. Are both of these available? Should I prioritise one over the other?",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-10113617",
                          "updatedAt": "2024-07-22T10:54:34Z",
                          "publishedAt": "2024-07-22T10:54:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nBoth TabulatedFluidProperties and PressureTemperature...Fp are available\nPlease let me if there are missing properties for either for your application if you try them\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/28010#discussioncomment-10114068",
                          "updatedAt": "2024-07-22T11:45:06Z",
                          "publishedAt": "2024-07-22T11:45:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiple CSV files  for different time instances to impose boundary conditions",
          "author": {
            "login": "deepakbiitk"
          },
          "bodyText": "Dear MOOSE users,\nI am solving heat equation in which I have measured temperature data at  few spatial locations on a  boundary for different times in a csv format. Multiple csv files i.e., a single measurement have a csv file. The geometry is not structured.  Is there a way I could read multiple csv files to impose boundary conditions? The boundary conditions for times between two csv, I plan to use linear interpolation.  I tried to figure out using the MOOSE site but no success yet. I appreciate your suggestions.\nBest,\nDeepak",
          "url": "https://github.com/idaholab/moose/discussions/25953",
          "updatedAt": "2024-07-22T10:40:56Z",
          "publishedAt": "2023-11-02T20:22:10Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou ll want to use one CSV file per function, and use one function per boundary.\nThis is for a heat flux or a fixed temperature value?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25953#discussioncomment-7461055",
                  "updatedAt": "2023-11-02T20:56:02Z",
                  "publishedAt": "2023-11-02T20:56:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "deepakbiitk"
                          },
                          "bodyText": "Hi Guillaume,\nIts fixed temperature problem. In a particular boundary, I have around 15 points where I have measured temperatures. I was thinking of using Piecewaise_multilinear, but it seems it requires a structured data.\nDeepak",
                          "url": "https://github.com/idaholab/moose/discussions/25953#discussioncomment-7461133",
                          "updatedAt": "2023-11-02T21:06:00Z",
                          "publishedAt": "2023-11-02T21:05:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Use PiecewiseConstantFromCSV.\nThere's a few options for the data input but I suspect voronoi is the one to use here",
                          "url": "https://github.com/idaholab/moose/discussions/25953#discussioncomment-7461145",
                          "updatedAt": "2023-11-02T21:07:53Z",
                          "publishedAt": "2023-11-02T21:07:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "deepakbiitk"
                          },
                          "bodyText": "Thanks for the suggestion. Does it also work if we have time as variable of the function, f(x,y,z,t)? Let me look into it again.",
                          "url": "https://github.com/idaholab/moose/discussions/25953#discussioncomment-7461180",
                          "updatedAt": "2023-11-02T21:12:14Z",
                          "publishedAt": "2023-11-02T21:11:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m afraid not. We have not coded in time dependence yet.\nFor structured data there is something I think in Piecewisemultidimensial",
                          "url": "https://github.com/idaholab/moose/discussions/25953#discussioncomment-7461231",
                          "updatedAt": "2023-11-02T21:19:38Z",
                          "publishedAt": "2023-11-02T21:19:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I could see a change in the PropertyReadFile to enable reading time dependence. There would be a little bit of coding work involved.\nI would recommend maybe making a derived class instead tht reads the file differently\nhttps://mooseframework.inl.gov/source/userobjects/PropertyReadFile.html",
                          "url": "https://github.com/idaholab/moose/discussions/25953#discussioncomment-7461475",
                          "updatedAt": "2023-11-02T21:46:10Z",
                          "publishedAt": "2023-11-02T21:46:09Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "caolwec"
                          },
                          "bodyText": "I could see a change in the PropertyReadFile to enable reading time dependence. There would be a little bit of coding work involved. I would recommend maybe making a derived class instead tht reads the file differently https://mooseframework.inl.gov/source/userobjects/PropertyReadFile.html\n\nMay I suggest a change to the PropertyReadFile for more convenience? - The 'prop_file_name' is for a list of property file names now, it would be better in case there are many property files if it allows a CSV file where all the property files names are listed in a column.",
                          "url": "https://github.com/idaholab/moose/discussions/25953#discussioncomment-10107035",
                          "updatedAt": "2024-07-21T14:24:34Z",
                          "publishedAt": "2024-07-21T14:24:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "That's a good idea. Could you please create an issue for the feature request?",
                          "url": "https://github.com/idaholab/moose/discussions/25953#discussioncomment-10107609",
                          "updatedAt": "2024-07-21T16:35:38Z",
                          "publishedAt": "2024-07-21T16:35:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "caolwec"
                          },
                          "bodyText": "Absolutely! Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/25953#discussioncomment-10113506",
                          "updatedAt": "2024-07-22T10:40:57Z",
                          "publishedAt": "2024-07-22T10:40:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@deepakbiitk I dont know how you made it work but I am adding what you need in this pull request\n#26395",
                  "url": "https://github.com/idaholab/moose/discussions/25953#discussioncomment-7922882",
                  "updatedAt": "2023-12-21T23:07:38Z",
                  "publishedAt": "2023-12-21T23:07:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "deepakbiitk"
                          },
                          "bodyText": "Hi Guillaume,\nThanks for setting this up. I am relooking to solve the problem again in MOOSE.\nThanks,\nDeepak",
                          "url": "https://github.com/idaholab/moose/discussions/25953#discussioncomment-8560951",
                          "updatedAt": "2024-02-22T19:35:00Z",
                          "publishedAt": "2024-02-22T19:34:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unable to Adopt Code for Physics/SolidMechanics/QuasiStatic",
          "author": {
            "login": "shrituntunroy"
          },
          "bodyText": "Hi Moose Team,\nI am a new MOOSE user and am encountering some errors in my MOOSE input file that I can't figure out.\nHere is my input file:\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n\n[Mesh]\n  #displacements = 'x_disp y_disp z_disp'\n  [b1]\n    type = GeneratedMeshGenerator\n    elem_type = HEX8\n    dim = 3\n    nx = 1\n    ny = 1\n    nz = 1\n    xmin = 0.0\n    xmax = 1.0\n    ymin = 0.0\n    ymax = 1.0\n    zmin = 0.0\n    zmax = 1.0\n    block_id = 1\n  []\n  [cnode]\n    type = ExtraNodesetGenerator\n    coord = '0.0 0.0 0.0'\n    new_boundary = 6\n    input = b1\n  []\n  [snode]\n    type = ExtraNodesetGenerator\n    coord = '1.0 0.0 0.0'\n    new_boundary = 7\n    input = cnode\n  []\n  [block1]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 1\n    bottom_left = '0 0 0'\n    top_right = '1 1 1'\n    input = snode\n  []\n[]\n\n\n[Variables]\n  [./disp_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_y]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_z]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n\n\n[Physics/SolidMechanics/QuasiStatic]\n  [all]\n    strain = FINITE\n    add_variables = true\n    block = 1\n  [../]\n[]\n\n[Materials]\n  [./fplastic]\n    type = FiniteStrainPlasticMaterial\n    block = 1\n    yield_stress='0. 445. 0.05 610. 0.1 680. 0.38 810. 0.95 920. 2. 950.'\n  [../]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensor\n    block = 1\n    C_ijkl = '2.827e5 1.21e5 1.21e5 2.827e5 1.21e5 2.827e5 0.808e5 0.808e5 0.808e5'\n    fill_method = symmetric9\n  [../]\n  [./strain]\n    type = ComputeFiniteStrain\n    block = 1\n    displacements = 'disp_x disp_y disp_z'\n  [../]\n[]\n\n\n[Functions]\n  [./topfunc]\n    type = ParsedFunction\n    expression = 't'\n  [../]\n[]\n\n[BCs]\n  [./bottom3]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 0\n    value = 0.0\n  [../]\n  [./top]\n    type = FunctionDirichletBC\n    variable = disp_z\n    boundary = 5\n    function = topfunc\n  [../]\n  [./corner1]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 6\n    value = 0.0\n  [../]\n  [./corner2]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 6\n    value = 0.0\n  [../]\n  [./corner3]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 6\n    value = 0.0\n  [../]\n  [./side1]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 7\n    value = 0.0\n  [../]\n  [./side2]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 7\n    value = 0.0\n  [../]\n[]\n\n[AuxVariables]\n  [./stress_zz]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./peeq]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pe11]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pe22]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pe33]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n\n[AuxKernels]\n  [./stress_zz]\n    type = RankTwoAux\n    rank_two_tensor = stress\n    variable = stress_zz\n    index_i = 2\n    index_j = 2\n  [../]\n  [./pe11]\n    type = RankTwoAux\n    rank_two_tensor = plastic_strain\n    variable = pe11\n    index_i = 0\n    index_j = 0\n  [../]\n    [./pe22]\n    type = RankTwoAux\n    rank_two_tensor = plastic_strain\n    variable = pe22\n    index_i = 1\n    index_j = 1\n  [../]\n  [./pe33]\n    type = RankTwoAux\n    rank_two_tensor = plastic_strain\n    variable = pe33\n    index_i = 2\n    index_j = 2\n  [../]\n  [./eqv_plastic_strain]\n    type = MaterialRealAux\n    property = eqv_plastic_strain\n    variable = peeq\n  [../]\n[]\n\n[Preconditioning]\n  [./SMP]\n   type = SMP\n   full=true\n  [../]\n[]\n\n\n\n\n\n[Executioner]\n  type = Transient\n\n  dt=0.1\n  dtmax=1\n  dtmin=0.1\n  end_time=1.0\n\n  nl_abs_tol = 1e-10\n[]\n\n\n[Outputs]\n  file_base = out\n  exodus = true\n[]\n\n\n\nWhen I run the input file, I get the following error:\n*** ERROR ***\nThe following error occurred in the Problem 'MOOSE Problem' of type FEProblem.\n\nThe following material properties are declared on block 1 by multiple materials:\n  Material Property             Material Objects\n  deformation_gradient          all_strain strain \n  mechanical_strain             all_strain strain \n  rotation_increment            all_strain strain \n  strain_increment              all_strain strain \n  strain_rate                   all_strain strain \n  total_strain                  all_strain strain \nI am unable to figure out the reason for this error. Kindly help me with this issue.\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/28188",
          "updatedAt": "2024-07-22T07:04:54Z",
          "publishedAt": "2024-07-22T03:44:29Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think you can delete the ComputeFiniteStrain material it s already defined by the Physics\nUse Debug/show_material_props=true\nto see all the materials defining which material properties\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28188#discussioncomment-10110914",
                  "updatedAt": "2024-07-22T05:53:57Z",
                  "publishedAt": "2024-07-22T05:53:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "shrituntunroy"
                  },
                  "bodyText": "Thankyou Guillaume.\nNow it works.",
                  "url": "https://github.com/idaholab/moose/discussions/28188#discussioncomment-10111412",
                  "updatedAt": "2024-07-22T07:04:55Z",
                  "publishedAt": "2024-07-22T07:04:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "question about why params.addRangeCheckedParam<Real> and isParamValid()=ture",
          "author": {
            "login": "wangzhaohao"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello, I want to expand GapFluxModelRadiation with emissivity is of temperature function. so I inherit the GapFluxModelRadiationBase and the code is following\npragma once\n\n#include \"GapFluxModelRadiationBase.h\"\n\nclass FunctionGapFluxRadiation : public GapFluxModelRadiationBase\n{\n  public:\n    static InputParameters validParams();\n\n    FunctionGapFluxRadiation(const InputParameters & parameters);\n\n    ADReal computeFlux() const override;\n    Real emissivity() const;\n\n  protected:\n    const ADVariableValue & _primary_T;\n    const ADVariableValue & _secondary_T;\n    const Function * const _eps_primary_temperature_function;\n    const Function * const _eps_secondary_temperature_function;\n};\nand the corresponding source file\n# include \"FunctionGapFluxRadiation.h\"\n# include \"Function.h\"\n\nregisterMooseObject(\"MiracleApp\", FunctionGapFluxRadiation);\n\nInputParameters\nFunctionGapFluxRadiation::validParams()\n{\n  InputParameters params = GapFluxModelRadiationBase::validParams();\n\n  params.addRequiredCoupledVar(\"temperature\", \"The name of the temperature\");\n  params.addParam<FunctionName>(\"primary_emissivity_temperature_function\",\n                                \"\",\n                                \"the primary surface emissivity as a function of temperature\");\n  params.addParam<FunctionName>(\"secondary_emissivity_temperature_function\",\n                                \"\",\n                                \"the secondary surface emissivity as a function of temperature\");\n\n  params.addClassDescription(\n      \"same like GapFluxRadiation, but the emissivity is a function fo temperature\");\n  return params;\n}\n\nFunctionGapFluxRadiation::FunctionGapFluxRadiation(const InputParameters & parameters)\n  : GapFluxModelRadiationBase(parameters),\n    _primary_T(adCoupledNeighborValue(\"temperature\")),\n    _secondary_T(adCoupledValue(\"temperature\")),\n    _eps_primary_temperature_function(getParam<FunctionName>(\"primary_emissivity_temperature_function\") != \"\"\n                                          ? &getFunction(\"primary_emissivity_temperature_function\")\n                                          : nullptr),\n    _eps_secondary_temperature_function(getParam<FunctionName>(\"secondary_emissivity_temperature_function\") != \"\"\n                                          ? &getFunction(\"secondary_emissivity_temperature_function\")\n                                          : nullptr)\n{\n  if (isParamValid(\"primary_emissivity\") && _eps_primary_temperature_function)\n    mooseError(\n        \"Cannot specify both primary emissivity and primary emissivity temperature function\");\n  if (isParamValid(\"secondary_emissivity\") && _eps_secondary_temperature_function)\n    mooseError(\n        \"Cannot specify both secondary emissivity and secondary emissivity temperature function\");\n}\n\nReal\nFunctionGapFluxRadiation::emissivity() const\n{\n  GapFluxModelRadiationBase::emissivity();\n  if (_eps_primary_temperature_function && _eps_secondary_temperature_function)\n  {\n    const Real qp_primary_T = MetaPhysicL::raw_value(_primary_T[_qp]);\n    const Real qp_secondary_T = MetaPhysicL::raw_value(_secondary_T[_qp]);\n    if (_eps_primary_temperature_function->value(qp_primary_T) == 0 &&\n        _eps_secondary_temperature_function->value(qp_secondary_T) == 0)\n      return 0;\n\n    switch (_coord_system)\n    {\n      case Moose::COORD_XYZ:\n        return 1 / (1.0 / _eps_primary_temperature_function->value(qp_primary_T) +\n                    1.0 / _eps_secondary_temperature_function->value(qp_secondary_T) - 1);\n\n      case Moose::COORD_RZ:\n      {\n        Real eps_primary = _eps_primary_temperature_function->value(qp_primary_T);\n        Real eps_secondary = _eps_secondary_temperature_function->value(qp_secondary_T);\n        const auto primary_r = _primary_point.point(_radial_coord);\n        const auto secondary_r = _secondary_point.point(_radial_coord);\n        const bool primary_is_inner = primary_r < secondary_r;\n        const auto inner_r = primary_is_inner ? primary_r : secondary_r;\n        const auto outer_r = primary_is_inner ? secondary_r : primary_r;\n        const auto inner_eps = primary_is_inner ? eps_primary : eps_secondary;\n        const auto outer_eps = primary_is_inner ? eps_secondary : eps_primary;\n\n        // Taken from our documentation of FVInfiniteCylinderRadiativeBC\n        return inner_eps * outer_eps * outer_r /\n               (outer_eps * outer_r + inner_eps * inner_r * (1 - outer_eps));\n      }\n\n      default:\n        mooseError(\"spherical coordinates not yet supported for this object\");\n    }\n  }\n  return 0;\n}\n\nADReal\nFunctionGapFluxRadiation::computeFlux() const\n{\n  return computeRadiationFlux(_secondary_T[_qp], _primary_T[_qp]);\n}\nWhen i test there is wrong about\nCannot specify both primary emissivity and primary emissivity temperature function\nMy input is\n[UserObjects]\n  [radiation]\n    type = FunctionGapFluxRadiation\n    temperature = temp\n    boundary = 100\n    primary_emissivity_temperature_function = 1.0\n    secondary_emissivity_temperature_function = 1.0\n    use_displaced_mesh = true\n  []\n[]\n\n[Functions]\n  [primary_emissivity_temperature_function]\n    type = ParsedFunction\n    expression = 1\n  []\n  [secondary_emissivity_temperature_function]\n    type = ParsedFunction\n    expression = 1\n  []\n[]\n\n[Constraints]\n  [ced]\n    type = ModularGapConductanceConstraint\n    variable = lm\n    secondary_variable = temp\n    use_displaced_mesh = true\n    primary_boundary = 100\n    primary_subdomain = 10000\n    secondary_boundary = 101\n    secondary_subdomain = 10001\n    gap_flux_models = radiation\n  []\n[]\nI think is maybe the defult of emissivity? But I don't want to destroy the integrity of the MOOSE( GapFluxModelRadiationBase) code, Can you give me some advice?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/28187",
          "updatedAt": "2024-07-21T14:52:20Z",
          "publishedAt": "2024-07-20T08:51:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere is indeed a default to the Real-value emissivity\n  params.addRangeCheckedParam<Real>(\"primary_emissivity\",\n                                    1,\n                                    \"primary_emissivity>=0 & primary_emissivity<=1\",\n                                    \"The emissivity of the primary surface\");\n\nso you need to rework this error message and the one next to it\n  if (isParamValid(\"primary_emissivity\") && _eps_primary_temperature_function)\n    mooseError(\n        \"Cannot specify both primary emissivity and primary emissivity temperature function\");\n\ninstead of 'isParamValid' use isParamSetByUser and disallow setting a constant emissivity.\nI dont see why you do not disallow it currently. This call you do to the base class is supposed to return a value and you do not capture it in a variable, let alone use it for the return value of the derived class\nFunctionGapFluxRadiation::emissivity() const\n{\n  GapFluxModelRadiationBase::emissivity();\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28187#discussioncomment-10104905",
                  "updatedAt": "2024-07-21T03:00:22Z",
                  "publishedAt": "2024-07-21T03:00:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "Thanks, yes the isParamSetByUser is what I really need.\n\nI dont see why you do not disallow it currently. This call you do to the base class is supposed to return a value and you do not capture it in a variable, let alone use it for the return value of the derived class\n\nI don't konw how to disallow the emissivity, so i allow both, first the Real emissivty, secondary emissivity_function.\nReal\nFunctionGapFluxRadiation::emissivity() const\n{\n  if (isParamSetByUser(\"primary_emissivity\") && isParamSetByUser(\"secondary_emissivity\"))\n    {\n      GapFluxModelRadiationBase::emissivity();\n    }\n  if (_eps_primary_temperature_function && _eps_secondary_temperature_function)\n  {\n    const Real qp_primary_T = MetaPhysicL::raw_value(_primary_T[_qp]);\n    const Real qp_secondary_T = MetaPhysicL::raw_value(_secondary_T[_qp]);\n    if (_eps_primary_temperature_function->value(qp_primary_T) == 0 &&\n        _eps_secondary_temperature_function->value(qp_secondary_T) == 0)\n      return 0;\n......\nIf I want to disallow the Real emissivity,  I just need to delete this?\n  if (isParamSetByUser(\"primary_emissivity\") && isParamSetByUser(\"secondary_emissivity\"))\n    {\n      GapFluxModelRadiationBase::emissivity();\n    }\nThanks you help again.\nZhaohao Wang",
                          "url": "https://github.com/idaholab/moose/discussions/28187#discussioncomment-10105799",
                          "updatedAt": "2024-07-21T08:37:51Z",
                          "publishedAt": "2024-07-21T08:37:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "Sorry, I made a mistake. The emissivity function is not virtual. so when I use the computRadiationFlux in which it still call GapFluxModelRadiationBase::emissivity(). so I must write the another computeRadiationFlux, which is same with the GapFluxModelRadiationBase::computeRadiationFlux. There is modified code.\n# include \"FunctionGapFluxRadiation.h\"\n# include \"Function.h\"\n\nregisterMooseObject(\"MiracleApp\", FunctionGapFluxRadiation);\n\nInputParameters\nFunctionGapFluxRadiation::validParams()\n{\n  InputParameters params = GapFluxModelRadiationBase::validParams();\n\n  params.addRequiredCoupledVar(\"temperature\", \"The name of the temperature\");\n  params.addParam<FunctionName>(\"primary_emissivity_temperature_function\",\n                                \"\",\n                                \"the primary surface emissivity as a function of temperature\");\n  params.addParam<FunctionName>(\"secondary_emissivity_temperature_function\",\n                                \"\",\n                                \"the secondary surface emissivity as a function of temperature\");\n\n  params.addClassDescription(\n      \"same like GapFluxRadiation, but the emissivity is a function fo temperature\");\n  return params;\n}\n\nFunctionGapFluxRadiation::FunctionGapFluxRadiation(const InputParameters & parameters)\n  : GapFluxModelRadiationBase(parameters),\n    _primary_T(adCoupledNeighborValue(\"temperature\")),\n    _secondary_T(adCoupledValue(\"temperature\")),\n    _eps_primary_temperature_function(getParam<FunctionName>(\"primary_emissivity_temperature_function\") != \"\"\n                                          ? &getFunction(\"primary_emissivity_temperature_function\")\n                                          : nullptr),\n    _eps_secondary_temperature_function(getParam<FunctionName>(\"secondary_emissivity_temperature_function\") != \"\"\n                                          ? &getFunction(\"secondary_emissivity_temperature_function\")\n                                          : nullptr)\n{\n  if (isParamSetByUser(\"primary_emissivity\") && _eps_primary_temperature_function)\n    mooseError(\n        \"Cannot specify both primary emissivity and primary emissivity temperature function\");\n  if (isParamSetByUser(\"secondary_emissivity\") && _eps_secondary_temperature_function)\n    mooseError(\n        \"Cannot specify both secondary emissivity and secondary emissivity temperature function\");\n}\n\nReal\nFunctionGapFluxRadiation::emissivity() const\n{\n  /*\n  if (isParamSetByUser(\"primary_emissivity\") && isParamSetByUser(\"secondary_emissivity\"))\n    {\n      std::cout<<\"pont1\"<<std::endl;\n      GapFluxModelRadiationBase::emissivity();\n    }\n  if (_eps_primary_temperature_function && _eps_secondary_temperature_function)\n  {\n  */\n    const Real qp_primary_T = MetaPhysicL::raw_value(_primary_T[_qp]);\n    const Real qp_secondary_T = MetaPhysicL::raw_value(_secondary_T[_qp]);\n    if (_eps_primary_temperature_function->value(qp_primary_T) == 0 &&\n        _eps_secondary_temperature_function->value(qp_secondary_T) == 0)\n      return 0;\n\n    switch (_coord_system)\n    {\n      case Moose::COORD_XYZ:\n        return 1 / (1.0 / _eps_primary_temperature_function->value(qp_primary_T) +\n                    1.0 / _eps_secondary_temperature_function->value(qp_secondary_T) - 1);\n\n      case Moose::COORD_RZ:\n      {\n        Real eps_primary = _eps_primary_temperature_function->value(qp_primary_T);\n        Real eps_secondary = _eps_secondary_temperature_function->value(qp_secondary_T);\n        const auto primary_r = _primary_point.point(_radial_coord);\n        const auto secondary_r = _secondary_point.point(_radial_coord);\n        const bool primary_is_inner = primary_r < secondary_r;\n        const auto inner_r = primary_is_inner ? primary_r : secondary_r;\n        const auto outer_r = primary_is_inner ? secondary_r : primary_r;\n        const auto inner_eps = primary_is_inner ? eps_primary : eps_secondary;\n        const auto outer_eps = primary_is_inner ? eps_secondary : eps_primary;\n\n        // Taken from our documentation of FVInfiniteCylinderRadiativeBC\n        return inner_eps * outer_eps * outer_r /\n               (outer_eps * outer_r + inner_eps * inner_r * (1 - outer_eps));\n      }\n\n      default:\n        mooseError(\"spherical coordinates not yet supported for this object\");\n    }\n  //}\n  //return 0;\n}\n\nADReal\nFunctionGapFluxRadiation::computeFlux() const\n{\n  return computeRadiationFlux(_secondary_T[_qp], _primary_T[_qp]);\n}\n\nADReal\nFunctionGapFluxRadiation::computeRadiationFlux(const ADReal & secondary_T,\n                                                const ADReal & primary_T) const\n{\n  // We add 'surface_integration_factor' to account for the surface integration of the conductance\n  // due to radiation.\n  const ADReal temp_func =\n      (primary_T * primary_T + secondary_T * secondary_T) * (primary_T + secondary_T);\n\n  return (primary_T - secondary_T) * _stefan_boltzmann * temp_func * emissivity() *\n         _surface_integration_factor;\n}\nI don't know if there is a more convenient way here, if there is please let me know.",
                          "url": "https://github.com/idaholab/moose/discussions/28187#discussioncomment-10106027",
                          "updatedAt": "2024-07-21T09:52:31Z",
                          "publishedAt": "2024-07-21T09:52:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you can make emissivity() virtual in your local branch\nisParamSetByUSer is a slow routine (it compares strings). so you dont want to call it during emissivity. Instead save the result of this call in the constructor in a class attribute boolean, and use that in emissivity()",
                          "url": "https://github.com/idaholab/moose/discussions/28187#discussioncomment-10107143",
                          "updatedAt": "2024-07-21T14:52:20Z",
                          "publishedAt": "2024-07-21T14:52:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get the VectorPostprocessor value in the [Problem] system?",
          "author": {
            "login": "Wang-Yihu"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI have tried getVectorPostprocessorValueByName and getVectorPostprocessorValue, but they do not work...\nI want to write a derived class from ExternalProblem, to couple my self-developed program.\nFirst I use getVectorPostprocessorValueByName function:\nMy code is:\nExternalZidingyiQiujieqiChuanshuShujuProblem.C\n#include \"ExternalZidingyiQiujieqiChuanshuShujuProblem.h\"\n#include \"VectorPostprocessorInterface.h\"\n#include \"SystemBase.h\"\nusing namespace std;\n\nregisterMooseObject(\"lianxi_jiaoxueApp\", ExternalZidingyiQiujieqiChuanshuShujuProblem);\n\nInputParameters\nExternalZidingyiQiujieqiChuanshuShujuProblem::validParams()\n{\n  InputParameters params = ExternalProblem::validParams();                        \n  return params;\n}\n\nExternalZidingyiQiujieqiChuanshuShujuProblem::ExternalZidingyiQiujieqiChuanshuShujuProblem(const InputParameters & params)\n  : ExternalProblem(params),\n  _values_a(FEProblemBase::getVectorPostprocessorValueByName(\"a_name\",\"a_vector_name\"))/*I WANT TO IMPORT THIS VPP!*/\n{\n}\n\nExternalZidingyiQiujieqiChuanshuShujuProblem::~ExternalZidingyiQiujieqiChuanshuShujuProblem()\n{\n}\n\n\nvoid\nExternalZidingyiQiujieqiChuanshuShujuProblem::externalSolve()\n{\n}\n\nvoid\nExternalZidingyiQiujieqiChuanshuShujuProblem::syncSolutions(Direction direction)\n{\n  if (direction == Direction::FROM_EXTERNAL_APP)\n    {\n    }\n  else if (direction == Direction::TO_EXTERNAL_APP)  \n  {\n  }\n}\nand\nExternalZidingyiQiujieqiChuanshuShujuProblem.h\n#pragma once\n#include \"ExternalProblem.h\"\n\nclass ExternalZidingyiQiujieqiChuanshuShujuProblem : public ExternalProblem\n{\npublic:\n  static InputParameters validParams();\n\n\n  ExternalZidingyiQiujieqiChuanshuShujuProblem(const InputParameters & params);\n  ~ExternalZidingyiQiujieqiChuanshuShujuProblem();\n\n  virtual void externalSolve() override;\n  virtual bool converged() { return 1; }\n  virtual void syncSolutions(Direction /*direction*/) override;\n\nprotected:\n  const VectorPostprocessorValue & _values_a;\n};\nHowever, I try to run my test input file:\n[Mesh/generate]\n  type = GeneratedMeshGenerator\n  dim = 1\n[]\n\n[Problem]\n  type = ExternalZidingyiQiujieqiChuanshuShujuProblem\n  solve = false\n[]\n#THE SAME NAME IN THE CODE\n[VectorPostprocessors]\n  [a_name]\n    type = ConstantVectorPostprocessor\n    vector_names = 'a_vector_name' \n    value = '10 10 10'\n  []\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 5\n[]\n\n[Outputs]\n[]\n\nIt returns errors:\n*** ERROR ***\nReporter name \"a_name/a_vector_name\" with type \"std::vector<double>\" is not declared.\n\nSo how to solve this problem? How to get the VectorPostprocessor value in a derived class from ExternalProblem?\nI also try\nExternalZidingyiQiujieqiChuanshuShujuProblem::ExternalZidingyiQiujieqiChuanshuShujuProblem(const InputParameters & params)\n  : ExternalProblem(params),\n  _values_a(getVectorPostprocessorValue(\"a_name\",\"a_vector_name\"))/*I WANT TO IMPORT THIS VPP!*/\n{\n}\nin the C++ code. But it cannot make. It throws error:\nerror: 'getVectorPostprocessorValue' was not declared in this scope;\n\nAnd when I read #25063\nI find this:\n\nSo can I retrieve a value from [VectorPostprocessor] in the [Problem]?\nAnd I also find this\n#21369\nI try\nExternalZidingyiQiujieqiChuanshuShujuProblem::ExternalZidingyiQiujieqiChuanshuShujuProblem(const InputParameters & params)\n  : ExternalProblem(params),\n  _values_a(_fe_problem.getVectorPostprocessorValueByName(\"a_name\",\"a_vector_name\"))/*I WANT TO IMPORT THIS VPP!*/\n{\n}\nBut it cannot make. It throws errors:\nerror: '_fe_problem' was not declared in this scope",
          "url": "https://github.com/idaholab/moose/discussions/28126",
          "updatedAt": "2024-07-20T06:41:41Z",
          "publishedAt": "2024-07-13T12:16:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Wang-Yihu"
                  },
                  "bodyText": "Hey guys now I have a method to solve my problem, but it is not perfect.\nThat is: using a global variable to transfer the vector from [VectorPostprocessors] system to [Problems] system.\nMy code files are following: (/====================================================/ to mark the modified part.)\n#include \"ConstantVectorPostprocessor2.h\"\nstd::vector<VectorPostprocessorValue *> my_vpp;\n\nregisterMooseObject(\"lianxi_jiaoxueApp\", ConstantVectorPostprocessor2);\n\nInputParameters\nConstantVectorPostprocessor2::validParams()\n{\n  InputParameters params = GeneralVectorPostprocessor::validParams();\n  params.addClassDescription(\n      \"Populate constant VectorPostprocessorValue directly from input file.\");\n  params.addParam<std::vector<std::string>>(\"vector_names\",\n                                            std::vector<std::string>(1, \"value\"),\n                                            \"Names of the column vectors in this object\");\n  params.addRequiredParam<std::vector<std::vector<Real>>>(\n      \"value\",\n      \"Vector values this object will have. Leading dimension must be equal to leading dimension \"\n      \"of vector_names parameter.\");\n\n  return params;\n}\n\nConstantVectorPostprocessor2::ConstantVectorPostprocessor2(const InputParameters & parameters)\n  : GeneralVectorPostprocessor(parameters)\n{\n  std::vector<std::string> names = getParam<std::vector<std::string>>(\"vector_names\");\n  unsigned int nvec = names.size();\n\n  _value.resize(nvec);\n  for (unsigned int j = 0; j < nvec; ++j)\n    _value[j] = &declareVector(names[j]);\n\n  std::vector<std::vector<Real>> v = getParam<std::vector<std::vector<Real>>>(\"value\");\n  if (v.size() != nvec)\n    paramError(\"value\",\n               \"Leading dimension must be equal to leading dimension of vector_names parameter.\");\n\n  if (processor_id() == 0)\n  {\n    for (unsigned int j = 0; j < nvec; ++j)\n    {\n      unsigned int ne = v[j].size();\n      _value[j]->resize(ne);\n      for (unsigned int l = 0; l < ne; ++l)\n        (*_value[j])[l] = v[j][l];\n    }\n    \n  }\n}\n\nvoid\nConstantVectorPostprocessor2::initialize()\n{\n}\n\nvoid\nConstantVectorPostprocessor2::execute()\n{\n/*====================================================*/\n  for(int i=0; i < _value.size(); i++)\n  {\n    for(int j=0; j<(*_value[i]).size(); j++)\n    {\n      std::cout << (*_value[i])[j] << std::endl;\n    }    \n  }\n  my_vpp = _value; /*Transfer the vector to a global variable!*/\n/*====================================================*/\n}\nand\nextern std::vector<VectorPostprocessorValue *> my_vpp;\nregisterMooseObject(\"lianxi_jiaoxueApp\", ExternalZidingyiQiujieqiChuanshuShujuProblem2);\n\nInputParameters\nExternalZidingyiQiujieqiChuanshuShujuProblem2::validParams()\n{\n  InputParameters params = ExternalProblem::validParams();                      \n  return params;\n}\n\nExternalZidingyiQiujieqiChuanshuShujuProblem2::ExternalZidingyiQiujieqiChuanshuShujuProblem2(const InputParameters & params)\n  : ExternalProblem(params)\n{\n}\n\nExternalZidingyiQiujieqiChuanshuShujuProblem2::~ExternalZidingyiQiujieqiChuanshuShujuProblem2()\n{\n}\n\n\nvoid\nExternalZidingyiQiujieqiChuanshuShujuProblem2::externalSolve()\n{\n}\n\nvoid\nExternalZidingyiQiujieqiChuanshuShujuProblem2::syncSolutions(Direction direction)\n{\n  if (direction == Direction::FROM_EXTERNAL_APP)\n  {\n  }\n  else if (direction == Direction::TO_EXTERNAL_APP)  \n  {\n/*====================================================*/\n    for(int i=0; i < my_vpp.size(); i++)\n    {\n      for(int j=0; j<(*my_vpp[i]).size(); j++)\n      {\n        std::cout << \"(*my_vpp[\"<<i<<\"])[\"<<j<<\"]) = \" << (*my_vpp[i])[j] << std::endl;\n        /*[VectorPostprocessors] -> globalvariable -> [Problems]*/\n      }    \n    }\n/*====================================================*/\n  }\n}\nhead files are omitted in this part. They can transfer the vector from  [VectorPostprocessors] system to [Problems] system.\nBut this is certainly not a perfect method. Using the global variable and change the member function of class in MOOSE are not encouraged I think.  So how to use the member function in MOOSE like getVectorPostprocessorValueByName to get VPPs in [Problems] system?",
                  "url": "https://github.com/idaholab/moose/discussions/28126#discussioncomment-10043648",
                  "updatedAt": "2024-07-14T13:12:12Z",
                  "publishedAt": "2024-07-14T13:12:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n  _values_a(getVectorPostprocessorValue(\"a_name\",\"a_vector_name\"))/*I WANT TO IMPORT THIS VPP!*/\n\nin the constructor is too early.\nIf you use Debug/show_actions you will see that the order of construction does not let you do that\nInstead retrieve the reference in an initial_setup phase or right before you need it\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28126#discussioncomment-10052944",
                  "updatedAt": "2024-07-15T15:46:33Z",
                  "publishedAt": "2024-07-15T15:46:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Wang-Yihu"
                          },
                          "bodyText": "Thanks for your help, GiudGiud!\nI try\n[Debug]\n  show_actions = true\n[]\n\nin the input file.\nIt will return\n(base) sjtu@sjtu:~/projects/lianxi_jiaoxue/shuruka10_layer_pps$ ../lianxi_jiaoxue-opt -i sub0.i\n[DBG][ACT] TASK (               no_action) TYPE (                     EmptyAction) NAME (                ) Memory usage 136MB\n[DBG][ACT] TASK (finish_input_file_output) TYPE (                     EmptyAction) NAME (                ) Memory usage 136MB\n[DBG][ACT] TASK (             meta_action) TYPE (AddIterationCountPostprocessorsAction) NAME (           Debug) Memory usage 136MB\n[DBG][ACT] TASK (          ns_meta_action) TYPE (                     INSFVAction) NAME (                ) Memory usage 136MB\n[DBG][ACT] TASK (dynamic_object_registration) TYPE ( DynamicObjectRegistrationAction) NAME (         Problem) Memory usage 136MB\n[DBG][ACT] TASK (           common_output) TYPE (              CommonOutputAction) NAME (         Outputs) Memory usage 136MB\n[DBG][ACT] TASK ( setup_recover_file_base) TYPE (      SetupRecoverFileBaseAction) NAME (                ) Memory usage 137MB\n[DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (                ) Memory usage 137MB\n[DBG][ACT] TASK (              setup_mesh) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 137MB\n[DBG][ACT] TASK (        add_geometric_rm) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 137MB\n[DBG][ACT] TASK (        add_geometric_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 137MB\n[DBG][ACT] TASK (THM:add_relationship_managers) TYPE (THMAddRelationshipManagersAction) NAME (                ) Memory usage 137MB\n[DBG][ACT] TASK (     THM:init_simulation) TYPE (         THMInitSimulationAction) NAME (                ) Memory usage 137MB\n[DBG][ACT] TASK (          THM:build_mesh) TYPE (              THMBuildMeshAction) NAME (                ) Memory usage 137MB\n[DBG][ACT] TASK (      add_mesh_generator) TYPE (          AddMeshGeneratorAction) NAME (        generate) Memory usage 137MB\n[DBG][ACT] TASK (create_added_mesh_generators) TYPE (       CreateAddedMeshGenerators) NAME (                ) Memory usage 138MB\n[DBG][ACT] TASK ( execute_mesh_generators) TYPE (           ExecuteMeshGenerators) NAME (                ) Memory usage 138MB\n[DBG][ACT] TASK (       recover_meta_data) TYPE (      SetupRecoverFileBaseAction) NAME (                ) Memory usage 140MB\n[DBG][ACT] TASK (           set_mesh_base) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 140MB\n[DBG][ACT] TASK (     attach_geometric_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 140MB\n[DBG][ACT] TASK (               init_mesh) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 140MB\n[DBG][ACT] TASK (            prepare_mesh) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 140MB\n[DBG][ACT] TASK (     uniform_refine_mesh) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 140MB\n[DBG][ACT] TASK (     setup_mesh_complete) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 140MB\n[DBG][ACT] TASK (   determine_system_type) TYPE (      CreateProblemDefaultAction) NAME (                ) Memory usage 140MB\n[DBG][ACT] TASK (          create_problem) TYPE (             CreateProblemAction) NAME (         Problem) Memory usage 140MB\n[DBG][ACT] TASK (  create_problem_default) TYPE (      CreateProblemDefaultAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (       setup_executioner) TYPE (         CreateExecutionerAction) NAME (     Executioner) Memory usage 144MB\n[DBG][ACT] TASK (            add_executor) TYPE (               AddExecutorAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (   check_integrity_early) TYPE (            CheckIntegrityAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (  init_displaced_problem) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 144MB\n[DBG][ACT] TASK (          THM:setup_mesh) TYPE (              THMSetupMeshAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (        add_aux_variable) TYPE (           DisplayGhostingAction) NAME (            Mesh) Memory usage 144MB\n[DBG][ACT] TASK (add_external_aux_variables) TYPE (    AddExternalAuxVariableAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (        setup_quadrature) TYPE (           SetupQuadratureAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (        setup_quadrature) TYPE (        THMSetupQuadratureAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (THM:output_vector_velocity) TYPE (   THMOutputVectorVelocityAction) NAME (         Outputs) Memory usage 144MB\n[DBG][ACT] TASK (     THM:init_components) TYPE (         THMInitComponentsAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (      THM:identify_loops) TYPE (             IdentifyLoopsAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (        THM:debug_action) TYPE (                  THMDebugAction) NAME (           Debug) Memory usage 144MB\n[DBG][ACT] TASK (     THM:integrity_check) TYPE (            IntegrityCheckAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (       THM:add_variables) TYPE (           THMAddVariablesAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (         add_user_object) TYPE (           DisplayGhostingAction) NAME (            Mesh) Memory usage 144MB\n[DBG][ACT] TASK (     load_surrogate_data) TYPE (         LoadSurrogateDataAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (    load_covariance_data) TYPE (        LoadCovarianceDataAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (    compose_time_stepper) TYPE (        ComposeTimeStepperAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (     setup_time_steppers) TYPE (          SetupTimeStepperAction) NAME (                ) Memory usage 144MB\n[DBG][ACT] TASK (           ready_to_init) TYPE (                     EmptyAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (           setup_dampers) TYPE (              SetupDampersAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (    setup_residual_debug) TYPE (        SetupResidualDebugAction) NAME (           Debug) Memory usage 145MB\n[DBG][ACT] TASK (         copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (     copy_nodal_aux_vars) TYPE (             CopyNodalVarsAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (THM:add_component_moose_objects) TYPE (  AddComponentMooseObjectsAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (add_output_aux_variables) TYPE (            MaterialOutputAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (              add_output) TYPE (                SetupDebugAction) NAME (           Debug) Memory usage 145MB\n[DBG][ACT] TASK (              add_output) TYPE (              CommonOutputAction) NAME (         Outputs) Memory usage 145MB\n[DBG][ACT] TASK (              add_output) TYPE (                 AddOutputAction) NAME (         console) Memory usage 145MB\n[DBG][ACT] TASK (  auto_checkpoint_action) TYPE (            AutoCheckpointAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (add_vector_postprocessor) TYPE (    AddVectorPostprocessorAction) NAME (          nameee) Memory usage 145MB\n==================Helloworld!================\n[DBG][ACT] TASK (declare_stochastic_results_vectors) TYPE (         StochasticResultsAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (  declare_late_reporters) TYPE (      DeclareLateReportersAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (        THM:setup_output) TYPE (            THMSetupOutputAction) NAME (         Outputs) Memory usage 145MB\n[DBG][ACT] TASK (          add_aux_kernel) TYPE (           DisplayGhostingAction) NAME (            Mesh) Memory usage 145MB\n[DBG][ACT] TASK (          add_aux_kernel) TYPE (           ElementIDOutputAction) NAME (            Mesh) Memory usage 145MB\n[DBG][ACT] TASK (          add_aux_kernel) TYPE (            MaterialOutputAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (resolve_optional_materials) TYPE (ResolveOptionalMaterialPropertiesAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (        add_algebraic_rm) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 145MB\n[DBG][ACT] TASK (        add_algebraic_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (         add_coupling_rm) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 145MB\n[DBG][ACT] TASK (         add_coupling_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (attach_geometric_rm_final) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (     attach_algebraic_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (      attach_coupling_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (  coupling_functor_check) TYPE (      CouplingFunctorCheckAction) NAME (coupling_functor_check) Memory usage 145MB\n[DBG][ACT] TASK (delete_remote_elements_after_late_geometric_ghosting) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 145MB\n[DBG][ACT] TASK (            init_problem) TYPE (               InitProblemAction) NAME (                ) Memory usage 145MB\n[DBG][ACT] TASK (            check_output) TYPE (               CheckOutputAction) NAME (                ) Memory usage 147MB\n[DBG][ACT] TASK (         check_integrity) TYPE (            CheckIntegrityAction) NAME (                ) Memory usage 147MB\n[DBG][ACT] TASK (THM:preconditioning_integrity_check) TYPE (THMPreconditioningIntegrityCheckAction) NAME (                ) Memory usage 147MB\n[DBG][ACT] TASK (THM:control_data_integrity_check) TYPE ( ControlDataIntegrityCheckAction) NAME (                ) Memory usage 147MB\n[DBG][ACT] TASK (THM:print_component_loops) TYPE (    THMPrintComponentLoopsAction) NAME (           Debug) Memory usage 147MB\n[DBG][ACT] TASK (       load_mapping_data) TYPE (           LoadMappingDataAction) NAME (                ) Memory usage 147MB\n[DBG][ACT] Finished executing all actions with memory usage 147MB\n\nThe CreateProblemAction is before the  AddVectorPostprocessorAction, so the function in VectorPostprocessor cannot be used in the constructor function initializer list of Problem class and its derived class, is that right?\nAnd what do you mean by \"Instead retrieve the reference in an initial_setup phase\"?\nI'm looking forward to your reply...",
                          "url": "https://github.com/idaholab/moose/discussions/28126#discussioncomment-10085713",
                          "updatedAt": "2024-07-18T14:45:45Z",
                          "publishedAt": "2024-07-18T14:45:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you dont have to call getVectorPostprocessor in the constructor\nyou can call it anytime, you can call it right before you need it for example",
                          "url": "https://github.com/idaholab/moose/discussions/28126#discussioncomment-10086058",
                          "updatedAt": "2024-07-18T15:13:09Z",
                          "publishedAt": "2024-07-18T15:13:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wang-Yihu"
                          },
                          "bodyText": "You are right, sir, thanks! Putting functions in the constructor function initializer list of  Problem class and its derived class is not a good idea.\nI put my example which can run successfully\n*.C file\n#include \"ExternalZidingyiQiujieqiChuanshuShujuProblem3.h\"\n#include \"VectorPostprocessorInterface.h\"\n#include \"SystemBase.h\"\nusing namespace std;\n\nregisterMooseObject(\"lianxi_jiaoxueApp\", ExternalZidingyiQiujieqiChuanshuShujuProblem3);\n\nInputParameters\nExternalZidingyiQiujieqiChuanshuShujuProblem3::validParams()\n{\n  InputParameters params = ExternalProblem::validParams();\n  params.addRequiredParam<VectorPostprocessorName>(\"vpp\", \"The name of the VectorPostprocessor to pull the data from.\");\n  params.addRequiredParam<std::string>(\"vector_name\",\"The name of the vector to use from the VectorPostprocessor\");\n                          \n  return params;\n}\n\nExternalZidingyiQiujieqiChuanshuShujuProblem3::ExternalZidingyiQiujieqiChuanshuShujuProblem3(const InputParameters & params)\n  : ExternalProblem(params)\n{\n}\n\nExternalZidingyiQiujieqiChuanshuShujuProblem3::~ExternalZidingyiQiujieqiChuanshuShujuProblem3()\n{\n}\n\n\nvoid\nExternalZidingyiQiujieqiChuanshuShujuProblem3::externalSolve()\n{\n  VectorPostprocessorValue myvalue = getVectorPostprocessorValueByName(getParam<VectorPostprocessorName>(\"vpp\"),getParam<std::string>(\"vector_name\"));\n  for(int i=0; i < myvalue.size(); i++)\n  {\n    std::cout << \"myvalue[\" << i << \"] = \" << myvalue[i] << std::endl;\n  }\n  \n}\n\nvoid\nExternalZidingyiQiujieqiChuanshuShujuProblem3::syncSolutions(Direction direction)\n{\n  if (direction == Direction::FROM_EXTERNAL_APP)\n  {\n  }\n  else if (direction == Direction::TO_EXTERNAL_APP)  \n  {\n  }\n}\n*.h file\n#pragma once\n#include \"ExternalProblem.h\"\n\nclass ExternalZidingyiQiujieqiChuanshuShujuProblem3 : public ExternalProblem\n{\npublic:\n  static InputParameters validParams();\n\n\n  ExternalZidingyiQiujieqiChuanshuShujuProblem3(const InputParameters & params);\n  ~ExternalZidingyiQiujieqiChuanshuShujuProblem3();\n\n  virtual void externalSolve() override;\n  virtual bool converged() { return 1; }\n  virtual void syncSolutions(Direction /*direction*/) override;\n};\nand *.i file\n[Mesh/generate]\n  type = GeneratedMeshGenerator\n  dim = 1\n[]\n\n[VectorPostprocessors]\n  [a_vpp]\n    type = ConstantVectorPostprocessor\n    vector_names = 'a_vector_name'\n    value = '5.0 12.0 13.0'\n  []\n[]\n\n[Problem]\n  type = ExternalZidingyiQiujieqiChuanshuShujuProblem3\n  solve = false\n  vpp = 'a_vpp'\n  vector_name = 'a_vector_name'\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 1\n[]\n\n[Outputs]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28126#discussioncomment-10100920",
                          "updatedAt": "2024-07-20T06:40:57Z",
                          "publishedAt": "2024-07-20T06:40:56Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}