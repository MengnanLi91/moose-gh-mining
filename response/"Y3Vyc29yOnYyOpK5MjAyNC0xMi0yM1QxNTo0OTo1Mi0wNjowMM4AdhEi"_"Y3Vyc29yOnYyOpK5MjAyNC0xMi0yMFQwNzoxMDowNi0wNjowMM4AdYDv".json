{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMi0yMFQwNzoxMDowNi0wNjowMM4AdYDv"
    },
    "edges": [
      {
        "node": {
          "title": "Distribution of material properties",
          "author": {
            "login": "rnpratoori"
          },
          "bodyText": "Hello team,\nI want to create a material property where I know the domain average and I want to create a distribution of the value with a maximum and a minimum value (similar to how its done in RandomIC). Also, I want to use this value to calculate another material property, maybe using DerivativeParsedMaterial. What is the best way to approach this? I did look at Example 08, but I am not sure if it will fit my use case.\nBest,\nRaghunandan.",
          "url": "https://github.com/idaholab/moose/discussions/29592",
          "updatedAt": "2024-12-23T20:05:44Z",
          "publishedAt": "2024-12-20T16:46:05Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nThis is a \"non local\" material because the initialization depends on values which are not local. This wont be possible on-the-fly, you will need an initial step where you sample the value of the material (using a distribution) then compute its integral, then renormalize\nI would compute the integral of the material in a ElementUserObject and set the local values of the material there, then the Material only uses a pointer to the user object to retrieve the value at each quadrature point.",
                  "url": "https://github.com/idaholab/moose/discussions/29592#discussioncomment-11631162",
                  "updatedAt": "2024-12-20T17:09:19Z",
                  "publishedAt": "2024-12-20T17:08:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rnpratoori"
                          },
                          "bodyText": "Hello @GiudGiud. Thank you for your response.\nI am not sure I quite understand what you mentioned. Is there an example for something similar or some documentation? I could not find anything in the documentation regarding ElementUserObject.",
                          "url": "https://github.com/idaholab/moose/discussions/29592#discussioncomment-11631484",
                          "updatedAt": "2024-12-20T17:32:25Z",
                          "publishedAt": "2024-12-20T17:32:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont think there's an example.\n@lynnmunday you just made some nonlocal coupling material iirc did you have a good example?",
                          "url": "https://github.com/idaholab/moose/discussions/29592#discussioncomment-11631880",
                          "updatedAt": "2024-12-20T18:25:45Z",
                          "publishedAt": "2024-12-20T18:25:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lynnmunday"
                  },
                  "bodyText": "@GiudGiud I don't remember doing this.\n@rnpratoori Something you could try is create random initial conditions for an auxvariable using RandomIC and then rescale and turn this auxVariable into a material using CoupledValueFunctionMaterial.  I'm assuming you already know your maximum and minimum values.  There are also some other RandomIC's you can look at if you don't want a uniform sampling form 0 to 1 like the VolumeWeightedWeibull",
                  "url": "https://github.com/idaholab/moose/discussions/29592#discussioncomment-11652276",
                  "updatedAt": "2024-12-23T17:47:02Z",
                  "publishedAt": "2024-12-23T17:47:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I was thinking about this work #29576 for considering nonlocal dependencies in a material but I did not dive into it either so maybe it's different",
                          "url": "https://github.com/idaholab/moose/discussions/29592#discussioncomment-11652448",
                          "updatedAt": "2024-12-23T18:11:27Z",
                          "publishedAt": "2024-12-23T18:11:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "I see.  If @rnpratoori needs to compute some kind of correlated nonlocal distribution then they could use some of the averaging from that PR you mentioned to create the element userObject like you recommended.  That PR is using a vectorpostprocessor but that should be similar to what is needed for a userObject.  RandomMaterial might also do what they want.",
                          "url": "https://github.com/idaholab/moose/discussions/29592#discussioncomment-11653111",
                          "updatedAt": "2024-12-23T20:05:45Z",
                          "publishedAt": "2024-12-23T20:05:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MOOSE Team Curtailment Dec 25th - Jan 1st",
          "author": {
            "login": "milljm"
          },
          "bodyText": "It is that time of year again when the MOOSE development team will be unavailable December 25th through Jan 1st.\nA skeleton crew will be available to keep the CI/CD services healthy (Pull Requests will continue to function).",
          "url": "https://github.com/idaholab/moose/discussions/29606",
          "updatedAt": "2024-12-23T13:14:06Z",
          "publishedAt": "2024-12-23T13:13:49Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "How to control the start time of \"Pressure BC\"?",
          "author": {
            "login": "PEI0214"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello,\nI'm using Pressure boundary conditions. When I tried to control the start time of 'Pressure BC' using the Controls module. It has the following error:\nThe following error occurred in the Control 'c1' of type TimePeriod.\n\nThe desired parameter 'BCs::Pressure::load1/enable' was not located for the 'c1' object, it either does not exist or has not been declared as controllable.\n\nThe Settings of BCs and Controls are as follows:\n# ===== Boundary Conditions =====\n[BCs]\n  [archor_x]\n    type = DirichletBC\n    boundary = '3'\n    variable = disp_x\n    value = 0\n  []\n\n  [archor_y]\n    type = DirichletBC\n    boundary = '3'\n    variable = disp_y\n    value = 0\n  []\n\n  [archor_z]\n    type = DirichletBC\n    boundary = '3'\n    variable = disp_z\n    value = 0\n  []\n\n  [Pressure]\n    [load1]\n      boundary = '4'\n      function = '-1e6'\n      displacements = 'disp_x disp_y disp_z'\n    []\n  []\n[]\n\n[Controls]\n  [c1]\n    type = TimePeriod\n    enable_objects = 'BCs::Pressure::load1'\n    start_time = '400'\n  []\n[]\n\nIs there a good way to control the start time of Pressure boundary conditions?",
          "url": "https://github.com/idaholab/moose/discussions/29078",
          "updatedAt": "2024-12-23T00:35:45Z",
          "publishedAt": "2024-11-14T15:59:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCOuld you use the function parameter to apply a 0 load then the expected load at the desired time?\nYou could use a PiecewiseConstant function for that",
                  "url": "https://github.com/idaholab/moose/discussions/29078#discussioncomment-11256609",
                  "updatedAt": "2024-11-14T16:09:32Z",
                  "publishedAt": "2024-11-14T16:09:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "I tried to do that. But because I used MeshModifiers, an error will occur.\n*** ERROR ***\n'Pressure_load1_0' of type 'Pressure' depends on variable(s) 'disp_x,disp_y,disp_z'. However, that variable does not appear to be defined on (all of) boundary 'top'.\n\nIf I set \u2019boundary_restricted_elem_integrity_check = false\u2018.\nTime Step 0, time = 0\n\nTime Step 1, time = 100, dt = 100\n\nPerforming automatic scaling calculation\n\nSegmentation fault (core dumped)\n\nThis is my input file.\nmesh.zip\n\ninput\n[Problem]\n  kernel_coverage_check = false\n  material_coverage_check = false\n  boundary_restricted_node_integrity_check = false\n  # boundary_restricted_elem_integrity_check = false\n[]\n\nnew_domain_blocks = '1001    1002'\n\n[Mesh]\n  [box]\n    type = FileMeshGenerator\n    file = mesh4.msh\n  []\n\n  [refine]\n    type = RefineBlockGenerator\n    input = box\n    block = '2'\n    refinement = '1'\n    enable_neighbor_refinement = false\n  []\n\n  add_subdomain_ids = '${new_domain_blocks}'\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Variables]\n  [disp_x]\n    block = '${new_domain_blocks}'\n  []\n  [disp_y]\n    block = '${new_domain_blocks}'\n  []\n  [disp_z]\n    block = '${new_domain_blocks}'\n  []\n[]\n\n# ===== Tensor mechanics for all active domain blocks =====\n[Physics]\n  [SolidMechanics]\n    [QuasiStatic]\n      [all]\n        strain = finite\n        add_variables = false\n        block = '${new_domain_blocks}'\n      []\n    []\n  []\n[]\n\n# ===== Gravity =====\n[Kernels]\n  [Gravity1]\n    type = Gravity\n    block = '${new_domain_blocks}'\n    use_displaced_mesh = false\n    variable = disp_z\n    value = -10\n  []\n[]\n\n# ===== Boundary Conditions =====\n[BCs]\n  [archor_x]\n    type = DirichletBC\n    boundary = '3'\n    variable = disp_x\n    value = 0\n  []\n\n  [archor_y]\n    type = DirichletBC\n    boundary = '3'\n    variable = disp_y\n    value = 0\n  []\n\n  [archor_z]\n    type = DirichletBC\n    boundary = '3'\n    variable = disp_z\n    value = 0\n  []\n\n  [Pressure]\n    [load1]\n      boundary = '4'\n      function = 'if(t <= 200, 0, -2e3 * (t - 200))'\n      displacements = 'disp_x disp_y disp_z'\n    []\n  []\n[]\n\n# ===== Materials (linear-elastic to keep it simple) =====\n[Materials]\n  [elasticity_tensor1]\n    type = ComputeIsotropicElasticityTensor\n    block = '${new_domain_blocks}'\n    youngs_modulus = 50E6 # 50 MPa\n    poissons_ratio = 0.3\n  []\n\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n    block = '${new_domain_blocks}'\n  []\n\n  [density1]\n    type = GenericConstantMaterial\n    block = '${new_domain_blocks}'\n    prop_names = density\n    prop_values = 2000\n  []\n[]\n\n[MeshModifiers]\n  [m1]\n    type = TimedSubdomainModifier\n    times = '100 200'\n    blocks_from = '1 2'\n    blocks_to = '1001    1002'\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n[]\n\n# ===== Executioner =====\n[Executioner]\n  type = Transient\n  automatic_scaling = true\n\n  end_time = 500\n  dt = 100\n\n  solve_type = 'PJFNK'\n  petsc_options = '-snes_converged_reason'\n  # petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  # petsc_options_value = ' lu       mumps'\n\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = '  201               hypre    boomeramg      10'\n\n  nl_abs_tol = 1E-5\n  nl_max_its = 400\n\n  l_tol = 1E-8\n  l_max_its = 200\n[]\n\n[Outputs]\n  exodus = true\n  # checkpoint = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/29078#discussioncomment-11262385",
                          "updatedAt": "2024-11-15T03:41:37Z",
                          "publishedAt": "2024-11-15T03:40:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "That's because the boundary is defined at this point but the variable is not defined next to the boundary.\nYou could try using a different mesh modifier to create the boundary right when it's needed, rather than having it defined from the beginning.\nThis mesh modifier can look a lot like the existing mesh generators for defining sidesets.",
                          "url": "https://github.com/idaholab/moose/discussions/29078#discussioncomment-11262601",
                          "updatedAt": "2024-11-15T04:33:45Z",
                          "publishedAt": "2024-11-15T04:33:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "Do you have a good method for this situation?",
                          "url": "https://github.com/idaholab/moose/discussions/29078#discussioncomment-11263027",
                          "updatedAt": "2024-11-15T05:50:54Z",
                          "publishedAt": "2024-11-15T05:50:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can look at ParsedGenerateSideset and transcribe it to a meshmodifier",
                          "url": "https://github.com/idaholab/moose/discussions/29078#discussioncomment-11265258",
                          "updatedAt": "2024-11-15T10:19:55Z",
                          "publishedAt": "2024-11-15T10:19:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "This seems to be inconvenient for the simulation of construction process using pressure boundary conditions. Is it possible to control the Pressure boundary conditions using 'control_tags'?",
                          "url": "https://github.com/idaholab/moose/discussions/29078#discussioncomment-11266698",
                          "updatedAt": "2024-11-15T12:58:45Z",
                          "publishedAt": "2024-11-15T12:55:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Possibly.\nTry using Problem/verbose_setup to get the exact name of the boundary condition. I have a feeling you tried using the wrong name.\nIf not try using the show_parser debug option to see if you can find an alternative name there",
                          "url": "https://github.com/idaholab/moose/discussions/29078#discussioncomment-11267183",
                          "updatedAt": "2024-11-15T13:22:01Z",
                          "publishedAt": "2024-11-15T13:21:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "I got the following report as you suggested.\n\nDBG\n~~~\n[DBG] Adding TimeIntegrator 'ImplicitEuler' of type ImplicitEuler\nName\t Type\t Value\n---------------------\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t TimeIntegrator\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n enable\t bool\t 1\n\n[DBG] Adding AuxVariable 'stress_xx' of type MooseVariableConstMonomial\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0x5556d19e9950\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MooseVariableBase\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0\n _sys\t SystemBase*\t 0\n _system_base\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _var_kind\t Moose::VarKindType\t 1\n _var_num\t unsigned int\t 0\n array\t bool\t 0\n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t \n components\t unsigned int\t 1\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n eigen\t bool\t 0\n enable\t bool\t 1\n family\t MooseEnum\t MONOMIAL\n fv\t bool\t 0\n order\t MooseEnum\t CONSTANT\n outputs\t std::vector<OutputName, std::allocator<OutputName> >\t \n scaling\t std::vector<double, std::allocator<double> >\t \n solver_sys\t SolverSystemName\t nl0\n tid\t unsigned int\t 0\n use_dual\t bool\t 0\n\n[DBG] Adding AuxVariable 'stress_zz' of type MooseVariableConstMonomial\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0x5556d19e9950\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MooseVariableBase\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0\n _sys\t SystemBase*\t 0\n _system_base\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _var_kind\t Moose::VarKindType\t 1\n _var_num\t unsigned int\t 0\n array\t bool\t 0\n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t \n components\t unsigned int\t 1\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n eigen\t bool\t 0\n enable\t bool\t 1\n family\t MooseEnum\t MONOMIAL\n fv\t bool\t 0\n order\t MooseEnum\t CONSTANT\n outputs\t std::vector<OutputName, std::allocator<OutputName> >\t \n scaling\t std::vector<double, std::allocator<double> >\t \n solver_sys\t SolverSystemName\t nl0\n tid\t unsigned int\t 0\n use_dual\t bool\t 0\n\n[DBG] Adding Variable 'disp_x' of type MooseVariable\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0x5556d19e9950\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MooseVariableBase\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0\n _sys\t SystemBase*\t 0\n _system_base\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _var_kind\t Moose::VarKindType\t 0\n _var_num\t unsigned int\t 0\n array\t bool\t 0\n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n components\t unsigned int\t 1\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Variables \n eigen\t bool\t 0\n enable\t bool\t 1\n family\t MooseEnum\t LAGRANGE\n fv\t bool\t 0\n order\t MooseEnum\t FIRST\n outputs\t std::vector<OutputName, std::allocator<OutputName> >\t \n scaling\t std::vector<double, std::allocator<double> >\t \n solver_sys\t SolverSystemName\t nl0\n tid\t unsigned int\t 0\n use_dual\t bool\t 0\n\n[DBG] Adding Variable 'disp_y' of type MooseVariable\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0x5556d19e9950\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MooseVariableBase\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0\n _sys\t SystemBase*\t 0\n _system_base\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _var_kind\t Moose::VarKindType\t 0\n _var_num\t unsigned int\t 0\n array\t bool\t 0\n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n components\t unsigned int\t 1\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Variables \n eigen\t bool\t 0\n enable\t bool\t 1\n family\t MooseEnum\t LAGRANGE\n fv\t bool\t 0\n order\t MooseEnum\t FIRST\n outputs\t std::vector<OutputName, std::allocator<OutputName> >\t \n scaling\t std::vector<double, std::allocator<double> >\t \n solver_sys\t SolverSystemName\t nl0\n tid\t unsigned int\t 0\n use_dual\t bool\t 0\n\n[DBG] Adding Variable 'disp_z' of type MooseVariable\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0x5556d19e9950\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MooseVariableBase\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0\n _sys\t SystemBase*\t 0\n _system_base\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _var_kind\t Moose::VarKindType\t 0\n _var_num\t unsigned int\t 0\n array\t bool\t 0\n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n components\t unsigned int\t 1\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Variables \n eigen\t bool\t 0\n enable\t bool\t 1\n family\t MooseEnum\t LAGRANGE\n fv\t bool\t 0\n order\t MooseEnum\t FIRST\n outputs\t std::vector<OutputName, std::allocator<OutputName> >\t \n scaling\t std::vector<double, std::allocator<double> >\t \n solver_sys\t SolverSystemName\t nl0\n tid\t unsigned int\t 0\n use_dual\t bool\t 0\n\n[DBG] Adding UserObject 'm1' of type TimedSubdomainModifier\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MeshModifier\n _moose_warehouse_system_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t UserObject\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0x5556d1a0b080\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n allow_duplicate_execution_on_initial\t bool\t 0\n apply_initial_conditions\t bool\t 1\n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t \n blocks_from\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1 2 \n blocks_from_column_index\t unsigned long\t 1\n blocks_from_column_text\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n blocks_to\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n blocks_to_column_index\t unsigned long\t 2\n blocks_to_column_text\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n comment\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t ;\n complement_moving_boundary_name\t BoundaryName\t \n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t MeshModifiers \n data_file\t FileName\t \n delimiter\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t ,\n enable\t bool\t 1\n execute_on\t ExecFlagEnum\t TIMESTEP_BEGIN\n execution_order_group\t int\t 0\n force_postaux\t bool\t 0\n force_preaux\t bool\t 0\n force_preic\t bool\t 0\n header\t bool\t 0\n implicit\t bool\t 1\n moving_boundaries\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t \n moving_boundary_name\t BoundaryName\t \n moving_boundary_subdomain_pairs\t std::vector<std::vector<SubdomainName, std::allocator<SubdomainName> >, std::allocator<std::vector<SubdomainName, std::allocator<SubdomainName> > > >\t \n old_subdomain_reinitialized\t bool\t 1\n prop_getter_suffix\t MaterialPropertyName\t \n reinitialize_subdomains\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t ANY_BLOCK_ID \n seed\t unsigned int\t 0\n time_column_index\t unsigned long\t 0\n time_column_text\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n times\t std::vector<double, std::allocator<double> >\t 100 200 \n use_displaced_mesh\t bool\t 0\n use_interpolated_state\t bool\t 0\n\n[DBG] Adding TimeStepper 'ConstantDT' of type ConstantDT\nName\t Type\t Value\n---------------------\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0x5556d1a59960\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t TimeStepper\n _moose_warehouse_system_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t TimeStepper\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n cutback_factor_at_failure\t double\t 0.5\n dt\t double\t 100\n enable\t bool\t 1\n growth_factor\t double\t 2\n reset_dt\t bool\t 0\n\n[DBG] Adding Material 'stress_xx_all' of type RankTwoCartesianComponent\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _force_stateful_init\t bool\t 0\n _interface\t bool\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MaterialBase\n _neighbor\t bool\t 0\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t \n compute\t bool\t 1\n constant_on\t MooseEnum\t NONE\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Physics/SolidMechanics/QuasiStatic \n declare_suffix\t MaterialPropertyName\t \n enable\t bool\t 1\n implicit\t bool\t 1\n index_i\t unsigned int\t 0\n index_j\t unsigned int\t 0\n output_properties\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n outputs\t std::vector<OutputName, std::allocator<OutputName> >\t none \n prop_getter_suffix\t MaterialPropertyName\t \n property_name\t MaterialPropertyName\t stress_xx\n rank_two_tensor\t MaterialPropertyName\t stress\n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 0\n use_interpolated_state\t bool\t 0\n\n[DBG] Adding Material 'stress_zz_all' of type RankTwoCartesianComponent\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _force_stateful_init\t bool\t 0\n _interface\t bool\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MaterialBase\n _neighbor\t bool\t 0\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t \n compute\t bool\t 1\n constant_on\t MooseEnum\t NONE\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Physics/SolidMechanics/QuasiStatic \n declare_suffix\t MaterialPropertyName\t \n enable\t bool\t 1\n implicit\t bool\t 1\n index_i\t unsigned int\t 2\n index_j\t unsigned int\t 2\n output_properties\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n outputs\t std::vector<OutputName, std::allocator<OutputName> >\t none \n prop_getter_suffix\t MaterialPropertyName\t \n property_name\t MaterialPropertyName\t stress_zz\n rank_two_tensor\t MaterialPropertyName\t stress\n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 0\n use_interpolated_state\t bool\t 0\n\n[DBG] Adding Material 'elasticity_tensor1' of type ComputeIsotropicElasticityTensor\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _force_stateful_init\t bool\t 0\n _interface\t bool\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MaterialBase\n _neighbor\t bool\t 0\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n base_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t \n bulk_modulus\t double\t -1\n compute\t bool\t 1\n constant_on\t MooseEnum\t NONE\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Materials \n declare_suffix\t MaterialPropertyName\t \n elasticity_tensor_prefactor\t FunctionName\t \n enable\t bool\t 1\n implicit\t bool\t 1\n lambda\t double\t -1\n output_properties\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n outputs\t std::vector<OutputName, std::allocator<OutputName> >\t none \n poissons_ratio\t double\t 0.3\n prop_getter_suffix\t MaterialPropertyName\t \n seed\t unsigned int\t 0\n shear_modulus\t double\t -1\n use_displaced_mesh\t bool\t 0\n use_interpolated_state\t bool\t 0\n youngs_modulus\t double\t 5e+07\n\n[DBG] Adding Material 'stress' of type ComputeFiniteStrainElasticStress\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _force_stateful_init\t bool\t 0\n _interface\t bool\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MaterialBase\n _neighbor\t bool\t 0\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n base_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t \n compute\t bool\t 1\n constant_on\t MooseEnum\t NONE\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Materials \n declare_suffix\t MaterialPropertyName\t \n enable\t bool\t 1\n implicit\t bool\t 1\n output_properties\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n outputs\t std::vector<OutputName, std::allocator<OutputName> >\t none \n prop_getter_suffix\t MaterialPropertyName\t \n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 0\n use_interpolated_state\t bool\t 0\n\n[DBG] Adding Material 'density1' of type GenericConstantMaterial\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _force_stateful_init\t bool\t 0\n _interface\t bool\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MaterialBase\n _neighbor\t bool\t 0\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t \n compute\t bool\t 1\n constant_on\t MooseEnum\t SUBDOMAIN\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Materials \n declare_suffix\t MaterialPropertyName\t \n enable\t bool\t 1\n implicit\t bool\t 1\n output_properties\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n outputs\t std::vector<OutputName, std::allocator<OutputName> >\t none \n prop_getter_suffix\t MaterialPropertyName\t \n prop_names\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t density \n prop_values\t std::vector<double, std::allocator<double> >\t 2000 \n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 0\n use_interpolated_state\t bool\t 0\n\n[DBG] Adding Material 'all_strain' of type ComputeFiniteStrain\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _force_stateful_init\t bool\t 0\n _interface\t bool\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t MaterialBase\n _neighbor\t bool\t 0\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n base_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t \n compute\t bool\t 1\n constant_on\t MooseEnum\t NONE\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Physics/SolidMechanics/QuasiStatic \n declare_suffix\t MaterialPropertyName\t \n decomposition_method\t MooseEnum\t TaylorExpansion\n displacements\t std::vector<VariableName, std::allocator<VariableName> >\t disp_x disp_y disp_z \n eigenstrain_names\t std::vector<MaterialPropertyName, std::allocator<MaterialPropertyName> >\t \n enable\t bool\t 1\n global_strain\t MaterialPropertyName\t \n implicit\t bool\t 1\n output_properties\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n outputs\t std::vector<OutputName, std::allocator<OutputName> >\t none \n prop_getter_suffix\t MaterialPropertyName\t \n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 0\n use_interpolated_state\t bool\t 0\n volumetric_locking_correction\t bool\t 0\n\n[DBG] Adding Output 'exodus' of type Exodus\nName\t Type\t Value\n---------------------\n _built_by_moose\t bool\t 1\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0x5556d19e9950\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t Output\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n additional_execute_on\t ExecFlagEnum\t \n append_date\t bool\t 0\n append_date_format\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n append_oversample\t bool\t 0\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t  \n discontinuous\t bool\t 0\n elemental_as_nodal\t bool\t 0\n enable\t bool\t 1\n end_step\t int\t 0\n end_time\t double\t 0\n execute_elemental_on\t ExecFlagEnum\t \n execute_elemental_variables\t bool\t 1\n execute_input\t bool\t 1\n execute_input_on\t ExecFlagEnum\t INITIAL\n execute_nodal_on\t ExecFlagEnum\t \n execute_nodal_variables\t bool\t 1\n execute_on\t ExecFlagEnum\t INITIAL TIMESTEP_END\n execute_postprocessors_on\t ExecFlagEnum\t \n execute_reporters_on\t ExecFlagEnum\t \n execute_scalar_variables\t bool\t 1\n execute_scalars_on\t ExecFlagEnum\t \n execute_system_information\t bool\t 1\n execute_vector_postprocessors\t bool\t 1\n extra_element_ids_to_output\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n file\t MeshFileName\t \n file_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n hide\t std::vector<VariableName, std::allocator<VariableName> >\t \n linear_residual_dt_divisor\t double\t 1000\n linear_residual_end_time\t double\t 0\n linear_residual_start_time\t double\t 0\n min_simulation_time_interval\t double\t 0\n nonlinear_residual_dt_divisor\t double\t 1000\n nonlinear_residual_end_time\t double\t 0\n nonlinear_residual_start_time\t double\t 0\n output_dimension\t MooseEnum\t default\n output_extra_element_ids\t bool\t 0\n output_if_base_contains\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n output_limiting_function\t FunctionName\t \n output_linear\t bool\t 0\n output_material_properties\t bool\t 0\n output_nonlinear\t bool\t 0\n output_postprocessors\t bool\t 1\n oversample\t bool\t 0\n overwrite\t bool\t 0\n padding\t unsigned int\t 3\n position\t libMesh::Point\t (x,y,z)=(       0,        0,        0)\n postprocessors_as_reporters\t bool\t 0\n refinements\t unsigned int\t 0\n scalar_as_nodal\t bool\t 0\n sequence\t bool\t 0\n show\t std::vector<VariableName, std::allocator<VariableName> >\t \n show_material_properties\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n side_discontinuous\t bool\t 0\n simulation_time_interval\t double\t 1.79769e+308\n start_step\t int\t 0\n start_time\t double\t 0\n sync_only\t bool\t 0\n sync_times\t std::vector<double, std::allocator<double> >\t \n sync_times_object\t TimesName\t \n time_step_interval\t unsigned int\t 1\n time_tolerance\t double\t 1e-14\n use_displaced\t bool\t 0\n use_problem_dimension\t bool\t 0\n vectorpostprocessors_as_reporters\t bool\t 0\n wall_time_interval\t double\t 1.79769e+308\n write_hdf5\t bool\t 0\n\n[DBG] Adding Output 'console' of type Console\nName\t Type\t Value\n---------------------\n _built_by_moose\t bool\t 1\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0x5556d19e9950\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t Output\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n additional_execute_on\t ExecFlagEnum\t \n all_variable_norms\t bool\t 0\n append_date\t bool\t 0\n append_date_format\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n append_restart\t bool\t 0\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t  \n enable\t bool\t 1\n end_step\t int\t 0\n end_time\t double\t 0\n execute_elemental_variables\t bool\t 1\n execute_input\t bool\t 1\n execute_input_on\t ExecFlagEnum\t \n execute_nodal_variables\t bool\t 1\n execute_on\t ExecFlagEnum\t INITIAL TIMESTEP_BEGIN LINEAR NONLINEAR FAILED\n execute_postprocessors_on\t ExecFlagEnum\t INITIAL TIMESTEP_END\n execute_reporters_on\t ExecFlagEnum\t INITIAL TIMESTEP_END\n execute_scalar_variables\t bool\t 1\n execute_scalars_on\t ExecFlagEnum\t INITIAL TIMESTEP_END\n execute_system_information\t bool\t 1\n execute_system_information_on\t ExecFlagEnum\t INITIAL\n execute_vector_postprocessors\t bool\t 1\n execute_vector_postprocessors_on\t ExecFlagEnum\t INITIAL TIMESTEP_END\n file_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n fit_mode\t MooseEnum\t ENVIRONMENT\n hide\t std::vector<VariableName, std::allocator<VariableName> >\t \n libmesh_log\t bool\t 1\n linear_residual_dt_divisor\t double\t 1000\n linear_residual_end_time\t double\t 0\n linear_residual_start_time\t double\t 0\n max_rows\t unsigned int\t 15\n min_simulation_time_interval\t double\t 0\n new_row_tolerance\t double\t 1e-12\n nonlinear_residual_dt_divisor\t double\t 1000\n nonlinear_residual_end_time\t double\t 0\n nonlinear_residual_start_time\t double\t 0\n outlier_multiplier\t std::vector<double, std::allocator<double> >\t 0.8 2 \n outlier_variable_norms\t bool\t 1\n output_file\t bool\t 0\n output_if_base_contains\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n output_limiting_function\t FunctionName\t \n output_linear\t bool\t 0\n output_nonlinear\t bool\t 0\n output_postprocessors\t bool\t 1\n output_screen\t bool\t 1\n padding\t unsigned int\t 4\n perf_header\t bool\t 0\n perf_log\t bool\t 0\n perf_log_interval\t unsigned int\t 0\n postprocessors_as_reporters\t bool\t 0\n print_mesh_changed_info\t bool\t 0\n scientific_time\t bool\t 0\n show\t std::vector<VariableName, std::allocator<VariableName> >\t \n show_multiapp_name\t bool\t 0\n simulation_time_interval\t double\t 1.79769e+308\n solve_log\t bool\t 0\n start_step\t int\t 0\n start_time\t double\t 0\n sync_only\t bool\t 0\n sync_times\t std::vector<double, std::allocator<double> >\t \n sync_times_object\t TimesName\t \n system_info\t MultiMooseEnum\t framework mesh aux nonlinear execution\n time_column\t bool\t 1\n time_data\t bool\t 0\n time_format\t MooseEnum\t plain\n time_precision\t unsigned int\t 0\n time_step_interval\t unsigned int\t 1\n time_tolerance\t double\t 1e-14\n use_displaced\t bool\t 0\n vectorpostprocessors_as_reporters\t bool\t 0\n verbose\t bool\t 0\n wall_time_interval\t double\t 1.79769e+308\n\n[DBG] Adding Output 'checkpoint' of type Checkpoint\nName\t Type\t Value\n---------------------\n _built_by_moose\t bool\t 1\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0x5556d19e9950\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t Output\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n additional_execute_on\t ExecFlagEnum\t \n append_date\t bool\t 0\n append_date_format\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n checkpoint_type\t CheckpointType\t 0\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t  \n enable\t bool\t 1\n end_step\t int\t 0\n end_time\t double\t 0\n execute_on\t ExecFlagEnum\t TIMESTEP_END\n file_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n linear_residual_dt_divisor\t double\t 1000\n linear_residual_end_time\t double\t 0\n linear_residual_start_time\t double\t 0\n min_simulation_time_interval\t double\t 0\n nonlinear_residual_dt_divisor\t double\t 1000\n nonlinear_residual_end_time\t double\t 0\n nonlinear_residual_start_time\t double\t 0\n num_files\t unsigned int\t 2\n output_if_base_contains\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n output_limiting_function\t FunctionName\t \n output_linear\t bool\t 0\n output_nonlinear\t bool\t 0\n padding\t unsigned int\t 4\n simulation_time_interval\t double\t 1.79769e+308\n start_step\t int\t 0\n start_time\t double\t 0\n suffix\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t cp\n sync_only\t bool\t 0\n sync_times\t std::vector<double, std::allocator<double> >\t \n sync_times_object\t TimesName\t \n time_step_interval\t unsigned int\t 1\n time_tolerance\t double\t 1e-14\n use_displaced\t bool\t 0\n wall_time_checkpoint\t bool\t 1\n wall_time_interval\t double\t 3600\n\n[DBG] Adding AuxKernel 'stress_xx_all' of type MaterialRealAux\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t AuxKernel\n _nl_sys\t SystemBase*\t 0x5556d1a0b080\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _on_boundary\t bool\t 0\n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0x5556d1a10810\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t \n check_boundary_restricted\t bool\t 1\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Physics/SolidMechanics/QuasiStatic \n enable\t bool\t 1\n execute_on\t ExecFlagEnum\t TIMESTEP_END\n factor\t double\t 1\n offset\t double\t 0\n prop_getter_suffix\t MaterialPropertyName\t \n property\t MaterialPropertyName\t stress_xx\n seed\t unsigned int\t 0\n selected_qp\t unsigned int\t 0\n use_displaced_mesh\t bool\t 0\n use_interpolated_state\t bool\t 0\n variable\t AuxVariableName\t stress_xx\n\n[DBG] Adding AuxKernel 'stress_zz_all' of type MaterialRealAux\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t AuxKernel\n _nl_sys\t SystemBase*\t 0x5556d1a0b080\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _on_boundary\t bool\t 0\n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0x5556d1a10810\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t \n check_boundary_restricted\t bool\t 1\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Physics/SolidMechanics/QuasiStatic \n enable\t bool\t 1\n execute_on\t ExecFlagEnum\t TIMESTEP_END\n factor\t double\t 1\n offset\t double\t 0\n prop_getter_suffix\t MaterialPropertyName\t \n property\t MaterialPropertyName\t stress_zz\n seed\t unsigned int\t 0\n selected_qp\t unsigned int\t 0\n use_displaced_mesh\t bool\t 0\n use_interpolated_state\t bool\t 0\n variable\t AuxVariableName\t stress_zz\n\n[DBG] Adding BoundaryCondition 'archor_x' of type DirichletBC\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t BoundaryCondition\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 1\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0x5556d1a0b080\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n absolute_value_vector_tags\t std::vector<TagName, std::allocator<TagName> > \n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t 3 \n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t BCs \n diag_save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n displacements\t std::vector<VariableName, std::allocator<VariableName> >\t disp_x disp_y disp_z \n enable\t bool\t 1\n extra_matrix_tags\t std::vector<TagName, std::allocator<TagName> >\t \n extra_vector_tags\t std::vector<TagName, std::allocator<TagName> >\t \n implicit\t bool\t 1\n matrix_only\t bool\t 0\n matrix_tags\t MultiMooseEnum\t system time\n preset\t bool\t 1\n save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 0\n value\t double\t 0\n variable\t NonlinearVariableName\t disp_x\n vector_tags\t MultiMooseEnum\t residual\n\n[DBG] Adding BoundaryCondition 'archor_y' of type DirichletBC\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t BoundaryCondition\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 1\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0x5556d1a0b080\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n absolute_value_vector_tags\t std::vector<TagName, std::allocator<TagName> > \n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t 3 \n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t BCs \n diag_save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n displacements\t std::vector<VariableName, std::allocator<VariableName> >\t disp_x disp_y disp_z \n enable\t bool\t 1\n extra_matrix_tags\t std::vector<TagName, std::allocator<TagName> >\t \n extra_vector_tags\t std::vector<TagName, std::allocator<TagName> >\t \n implicit\t bool\t 1\n matrix_only\t bool\t 0\n matrix_tags\t MultiMooseEnum\t system time\n preset\t bool\t 1\n save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 0\n value\t double\t 0\n variable\t NonlinearVariableName\t disp_y\n vector_tags\t MultiMooseEnum\t residual\n\n[DBG] Adding BoundaryCondition 'archor_z' of type DirichletBC\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t BoundaryCondition\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 1\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0x5556d1a0b080\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n absolute_value_vector_tags\t std::vector<TagName, std::allocator<TagName> > \n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t 3 \n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t BCs \n diag_save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n displacements\t std::vector<VariableName, std::allocator<VariableName> >\t disp_x disp_y disp_z \n enable\t bool\t 1\n extra_matrix_tags\t std::vector<TagName, std::allocator<TagName> >\t \n extra_vector_tags\t std::vector<TagName, std::allocator<TagName> >\t \n implicit\t bool\t 1\n matrix_only\t bool\t 0\n matrix_tags\t MultiMooseEnum\t system time\n preset\t bool\t 1\n save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 0\n value\t double\t 0\n variable\t NonlinearVariableName\t disp_z\n vector_tags\t MultiMooseEnum\t residual\n\n[DBG] Adding BoundaryCondition 'Pressure_load1_0' of type Pressure\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _material_data_type\t Moose::MaterialDataType\t 1\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t BoundaryCondition\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 1\n _subproblem\t SubProblem*\t 0x5556d1a45150\n _sys\t SystemBase*\t 0x5556d15f5650\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n absolute_value_vector_tags\t std::vector<TagName, std::allocator<TagName> > \n alpha\t double\t 0\n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t 4 \n component\t unsigned int\t 0\n constant\t double\t 0\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t BCs/Pressure \n diag_save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n displacements\t std::vector<VariableName, std::allocator<VariableName> >\t disp_x disp_y disp_z \n enable\t bool\t 1\n extra_matrix_tags\t std::vector<TagName, std::allocator<TagName> >\t \n extra_vector_tags\t std::vector<TagName, std::allocator<TagName> >\t \n factor\t double\t 1\n function\t FunctionName\t if(t < 200, 0, -2e3 * (t - 200))\n implicit\t bool\t 1\n matrix_only\t bool\t 0\n matrix_tags\t MultiMooseEnum\t system\n postprocessor\t PostprocessorName\t \n prop_getter_suffix\t MaterialPropertyName\t \n save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 1\n use_interpolated_state\t bool\t 0\n variable\t NonlinearVariableName\t disp_x\n vector_tags\t MultiMooseEnum\t nontime\n\n[DBG] Adding Function 'if(t < 200, 0, -2e3 * (t - 200))' of type ParsedFunction\nName\t Type\t Value\n---------------------\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t Function\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n enable\t bool\t 1\n execute_on\t ExecFlagEnum\t LINEAR\n expression\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t if(t < 200, 0, -2e3 * (t - 200))\n symbol_names\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n symbol_values\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n vals\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n value\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n vars\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n\n[DBG] Adding BoundaryCondition 'Pressure_load1_1' of type Pressure\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _material_data_type\t Moose::MaterialDataType\t 1\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t BoundaryCondition\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 1\n _subproblem\t SubProblem*\t 0x5556d1a45150\n _sys\t SystemBase*\t 0x5556d15f5650\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n absolute_value_vector_tags\t std::vector<TagName, std::allocator<TagName> > \n alpha\t double\t 0\n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t 4 \n component\t unsigned int\t 0\n constant\t double\t 0\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t BCs/Pressure \n diag_save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n displacements\t std::vector<VariableName, std::allocator<VariableName> >\t disp_x disp_y disp_z \n enable\t bool\t 1\n extra_matrix_tags\t std::vector<TagName, std::allocator<TagName> >\t \n extra_vector_tags\t std::vector<TagName, std::allocator<TagName> >\t \n factor\t double\t 1\n function\t FunctionName\t if(t < 200, 0, -2e3 * (t - 200))\n implicit\t bool\t 1\n matrix_only\t bool\t 0\n matrix_tags\t MultiMooseEnum\t system\n postprocessor\t PostprocessorName\t \n prop_getter_suffix\t MaterialPropertyName\t \n save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 1\n use_interpolated_state\t bool\t 0\n variable\t NonlinearVariableName\t disp_y\n vector_tags\t MultiMooseEnum\t nontime\n\n[DBG] Adding BoundaryCondition 'Pressure_load1_2' of type Pressure\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _material_data_type\t Moose::MaterialDataType\t 1\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t BoundaryCondition\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 1\n _subproblem\t SubProblem*\t 0x5556d1a45150\n _sys\t SystemBase*\t 0x5556d15f5650\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n absolute_value_vector_tags\t std::vector<TagName, std::allocator<TagName> > \n alpha\t double\t 0\n boundary\t std::vector<BoundaryName, std::allocator<BoundaryName> >\t 4 \n component\t unsigned int\t 0\n constant\t double\t 0\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t BCs/Pressure \n diag_save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n displacements\t std::vector<VariableName, std::allocator<VariableName> >\t disp_x disp_y disp_z \n enable\t bool\t 1\n extra_matrix_tags\t std::vector<TagName, std::allocator<TagName> >\t \n extra_vector_tags\t std::vector<TagName, std::allocator<TagName> >\t \n factor\t double\t 1\n function\t FunctionName\t if(t < 200, 0, -2e3 * (t - 200))\n implicit\t bool\t 1\n matrix_only\t bool\t 0\n matrix_tags\t MultiMooseEnum\t system\n postprocessor\t PostprocessorName\t \n prop_getter_suffix\t MaterialPropertyName\t \n save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 1\n use_interpolated_state\t bool\t 0\n variable\t NonlinearVariableName\t disp_z\n vector_tags\t MultiMooseEnum\t nontime\n\n[DBG] Adding Kernel 'TM_all0' of type StressDivergenceTensors\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t Kernel\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 1\n _subproblem\t SubProblem*\t 0x5556d1a45150\n _sys\t SystemBase*\t 0x5556d15f5650\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n absolute_value_vector_tags\t std::vector<TagName, std::allocator<TagName> > \n base_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n component\t unsigned int\t 0\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Physics/SolidMechanics/QuasiStatic \n coupled_variables\t std::vector<VariableName, std::allocator<VariableName> >\t \n diag_save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n displacements\t std::vector<VariableName, std::allocator<VariableName> >\t disp_x disp_y disp_z \n eigenstrain_names\t std::vector<MaterialPropertyName, std::allocator<MaterialPropertyName> >\t \n enable\t bool\t 1\n extra_matrix_tags\t std::vector<TagName, std::allocator<TagName> >\t \n extra_vector_tags\t std::vector<TagName, std::allocator<TagName> >\t \n implicit\t bool\t 1\n matrix_only\t bool\t 0\n matrix_tags\t MultiMooseEnum\t system\n out_of_plane_direction\t MooseEnum\t z\n out_of_plane_strain\t std::vector<VariableName, std::allocator<VariableName> >\t \n prop_getter_suffix\t MaterialPropertyName\t \n save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n seed\t unsigned int\t 0\n temperature\t std::vector<VariableName, std::allocator<VariableName> >\t \n use_displaced_mesh\t bool\t 1\n use_finite_deform_jacobian\t bool\t 0\n use_interpolated_state\t bool\t 0\n variable\t NonlinearVariableName\t disp_x\n vector_tags\t MultiMooseEnum\t nontime\n volumetric_locking_correction\t bool\t 0\n\n[DBG] Adding Kernel 'TM_all1' of type StressDivergenceTensors\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t Kernel\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 1\n _subproblem\t SubProblem*\t 0x5556d1a45150\n _sys\t SystemBase*\t 0x5556d15f5650\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n absolute_value_vector_tags\t std::vector<TagName, std::allocator<TagName> > \n base_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n component\t unsigned int\t 1\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Physics/SolidMechanics/QuasiStatic \n coupled_variables\t std::vector<VariableName, std::allocator<VariableName> >\t \n diag_save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n displacements\t std::vector<VariableName, std::allocator<VariableName> >\t disp_x disp_y disp_z \n eigenstrain_names\t std::vector<MaterialPropertyName, std::allocator<MaterialPropertyName> >\t \n enable\t bool\t 1\n extra_matrix_tags\t std::vector<TagName, std::allocator<TagName> >\t \n extra_vector_tags\t std::vector<TagName, std::allocator<TagName> >\t \n implicit\t bool\t 1\n matrix_only\t bool\t 0\n matrix_tags\t MultiMooseEnum\t system\n out_of_plane_direction\t MooseEnum\t z\n out_of_plane_strain\t std::vector<VariableName, std::allocator<VariableName> >\t \n prop_getter_suffix\t MaterialPropertyName\t \n save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n seed\t unsigned int\t 0\n temperature\t std::vector<VariableName, std::allocator<VariableName> >\t \n use_displaced_mesh\t bool\t 1\n use_finite_deform_jacobian\t bool\t 0\n use_interpolated_state\t bool\t 0\n variable\t NonlinearVariableName\t disp_y\n vector_tags\t MultiMooseEnum\t nontime\n volumetric_locking_correction\t bool\t 0\n\n[DBG] Adding Kernel 'TM_all2' of type StressDivergenceTensors\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t Kernel\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 1\n _subproblem\t SubProblem*\t 0x5556d1a45150\n _sys\t SystemBase*\t 0x5556d15f5650\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n absolute_value_vector_tags\t std::vector<TagName, std::allocator<TagName> > \n base_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n component\t unsigned int\t 2\n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Physics/SolidMechanics/QuasiStatic \n coupled_variables\t std::vector<VariableName, std::allocator<VariableName> >\t \n diag_save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n displacements\t std::vector<VariableName, std::allocator<VariableName> >\t disp_x disp_y disp_z \n eigenstrain_names\t std::vector<MaterialPropertyName, std::allocator<MaterialPropertyName> >\t \n enable\t bool\t 1\n extra_matrix_tags\t std::vector<TagName, std::allocator<TagName> >\t \n extra_vector_tags\t std::vector<TagName, std::allocator<TagName> >\t \n implicit\t bool\t 1\n matrix_only\t bool\t 0\n matrix_tags\t MultiMooseEnum\t system\n out_of_plane_direction\t MooseEnum\t z\n out_of_plane_strain\t std::vector<VariableName, std::allocator<VariableName> >\t \n prop_getter_suffix\t MaterialPropertyName\t \n save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n seed\t unsigned int\t 0\n temperature\t std::vector<VariableName, std::allocator<VariableName> >\t \n use_displaced_mesh\t bool\t 1\n use_finite_deform_jacobian\t bool\t 0\n use_interpolated_state\t bool\t 0\n variable\t NonlinearVariableName\t disp_z\n vector_tags\t MultiMooseEnum\t nontime\n volumetric_locking_correction\t bool\t 0\n\n[DBG] Adding Kernel 'Gravity1' of type Gravity\nName\t Type\t Value\n---------------------\n _dual_restrictable\t bool\t 0\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _material_data_type\t Moose::MaterialDataType\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t Kernel\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 1\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0x5556d1a0b080\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n absolute_value_vector_tags\t std::vector<TagName, std::allocator<TagName> > \n alpha\t double\t 0\n block\t std::vector<SubdomainName, std::allocator<SubdomainName> >\t 1001 1002 \n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t Kernels \n density\t MaterialPropertyName\t density\n diag_save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n displacements\t std::vector<VariableName, std::allocator<VariableName> >\t disp_x disp_y disp_z \n enable\t bool\t 1\n extra_matrix_tags\t std::vector<TagName, std::allocator<TagName> >\t \n extra_vector_tags\t std::vector<TagName, std::allocator<TagName> >\t \n function\t FunctionName\t 1\n implicit\t bool\t 1\n matrix_only\t bool\t 0\n matrix_tags\t MultiMooseEnum\t system\n prop_getter_suffix\t MaterialPropertyName\t \n save_in\t std::vector<AuxVariableName, std::allocator<AuxVariableName> > \n seed\t unsigned int\t 0\n use_displaced_mesh\t bool\t 0\n use_interpolated_state\t bool\t 0\n value\t double\t -10\n variable\t NonlinearVariableName\t disp_z\n vector_tags\t MultiMooseEnum\t nontime\n\n[DBG] Adding Function '1' of type ConstantFunction\nName\t Type\t Value\n---------------------\n _eigen_problem\t EigenProblem*\t 0\n _executioner\t Transient*\t 0\n _fe_problem\t FEProblem*\t 0\n _fe_problem_base\t FEProblemBase*\t 0\n _moose_app\t MooseApp*\t 0x5556d169bb30\n _moose_base\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t Function\n _nl_sys\t SystemBase*\t 0\n _object_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _residual_object\t bool\t 0\n _subproblem\t SubProblem*\t 0x5556d19e9950\n _sys\t SystemBase*\t 0\n _tid\t unsigned int\t 0\n _type\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n _unique_name\t std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >\t \n control_tags\t std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > >\t \n enable\t bool\t 1\n execute_on\t ExecFlagEnum\t LINEAR\n value\t double\t 1\n\n\n\nshow_parser\nParsing Syntax:        Debug\nBuilding Action:       SetupDebugAction\nRegistered Identifier: Debug\nSpecific Task:         \nAdding Action:         SetupDebugAction (add_output)\n\nParsing Syntax:        Debug\nBuilding Action:       SetupResidualDebugAction\nRegistered Identifier: Debug\nSpecific Task:         \nAdding Action:         SetupResidualDebugAction (setup_residual_debug)\n\nParsing Syntax:        GlobalParams\nBuilding Action:       GlobalParamsAction\nRegistered Identifier: GlobalParams\nSpecific Task:         \nAdding Action:         GlobalParamsAction (set_global_params)\n\nParsing Syntax:        Problem\nBuilding Action:       CreateProblemAction\nRegistered Identifier: Problem\nSpecific Task:         \nAdding Action:         CreateProblemAction (create_problem)\n\nParsing Syntax:        Problem\nBuilding Action:       DynamicObjectRegistrationAction\nRegistered Identifier: Problem\nSpecific Task:         \nAdding Action:         DynamicObjectRegistrationAction (dynamic_object_registration)\n\nParsing Syntax:        Mesh\nBuilding Action:       SetupMeshAction\nRegistered Identifier: Mesh\nSpecific Task:         \nAdding Action:         SetupMeshAction (init_mesh)\nAdding Action:         SetupMeshAction (set_mesh_base)\nAdding Action:         SetupMeshAction (setup_mesh)\n\nParsing Syntax:        Mesh\nBuilding Action:       SetupMeshCompleteAction\nRegistered Identifier: Mesh\nSpecific Task:         \nAdding Action:         SetupMeshCompleteAction (delete_remote_elements_after_late_geometric_ghosting)\nAdding Action:         SetupMeshCompleteAction (prepare_mesh)\nAdding Action:         SetupMeshCompleteAction (setup_mesh_complete)\nAdding Action:         SetupMeshCompleteAction (uniform_refine_mesh)\n\nParsing Syntax:        Mesh\nBuilding Action:       CreateDisplacedProblemAction\nRegistered Identifier: Mesh\nSpecific Task:         \nAdding Action:         CreateDisplacedProblemAction (add_algebraic_rm)\nAdding Action:         CreateDisplacedProblemAction (add_coupling_rm)\nAdding Action:         CreateDisplacedProblemAction (add_geometric_rm)\nAdding Action:         CreateDisplacedProblemAction (init_displaced_problem)\n\nParsing Syntax:        Mesh\nBuilding Action:       DisplayGhostingAction\nRegistered Identifier: Mesh\nSpecific Task:         \nAdding Action:         DisplayGhostingAction (add_aux_kernel)\nAdding Action:         DisplayGhostingAction (add_aux_variable)\nAdding Action:         DisplayGhostingAction (add_user_object)\n\nParsing Syntax:        Mesh\nBuilding Action:       ElementIDOutputAction\nRegistered Identifier: Mesh\nSpecific Task:         \nAdding Action:         ElementIDOutputAction (add_aux_kernel)\n\nParsing Syntax:        box\nBuilding Action:       AddMeshGeneratorAction\nRegistered Identifier: Mesh/*\nSpecific Task:         \nAdding Action:         AddMeshGeneratorAction (add_mesh_generator)\n\nParsing Syntax:        refine\nBuilding Action:       AddMeshGeneratorAction\nRegistered Identifier: Mesh/*\nSpecific Task:         \nAdding Action:         AddMeshGeneratorAction (add_mesh_generator)\n\nParsing Syntax:        disp_x\nBuilding Action:       CopyNodalVarsAction\nRegistered Identifier: Variables/*\nSpecific Task:         check_copy_nodal_vars\nAdding Action:         CopyNodalVarsAction (check_copy_nodal_vars)\n\nParsing Syntax:        disp_x\nBuilding Action:       CopyNodalVarsAction\nRegistered Identifier: Variables/*\nSpecific Task:         copy_nodal_vars\nAdding Action:         CopyNodalVarsAction (copy_nodal_vars)\n\nParsing Syntax:        disp_x\nBuilding Action:       AddVariableAction\nRegistered Identifier: Variables/*\nSpecific Task:         \nAdding Action:         AddVariableAction (add_variable)\n\nParsing Syntax:        disp_y\nBuilding Action:       CopyNodalVarsAction\nRegistered Identifier: Variables/*\nSpecific Task:         check_copy_nodal_vars\nAdding Action:         CopyNodalVarsAction (check_copy_nodal_vars)\n\nParsing Syntax:        disp_y\nBuilding Action:       CopyNodalVarsAction\nRegistered Identifier: Variables/*\nSpecific Task:         copy_nodal_vars\nAdding Action:         CopyNodalVarsAction (copy_nodal_vars)\n\nParsing Syntax:        disp_y\nBuilding Action:       AddVariableAction\nRegistered Identifier: Variables/*\nSpecific Task:         \nAdding Action:         AddVariableAction (add_variable)\n\nParsing Syntax:        disp_z\nBuilding Action:       CopyNodalVarsAction\nRegistered Identifier: Variables/*\nSpecific Task:         check_copy_nodal_vars\nAdding Action:         CopyNodalVarsAction (check_copy_nodal_vars)\n\nParsing Syntax:        disp_z\nBuilding Action:       CopyNodalVarsAction\nRegistered Identifier: Variables/*\nSpecific Task:         copy_nodal_vars\nAdding Action:         CopyNodalVarsAction (copy_nodal_vars)\n\nParsing Syntax:        disp_z\nBuilding Action:       AddVariableAction\nRegistered Identifier: Variables/*\nSpecific Task:         \nAdding Action:         AddVariableAction (add_variable)\n\nParsing Syntax:        QuasiStatic\nBuilding Action:       CommonSolidMechanicsAction\nRegistered Identifier: Physics/SolidMechanics/QuasiStatic\nSpecific Task:         \nAdding Action:         CommonSolidMechanicsAction (meta_action)\n\n\n\n*** Info ***\nSolidMechanics Action: selecting 'incremental finite strain' formulation.\nParsing Syntax:        all\nBuilding Action:       QuasiStaticSolidMechanicsPhysics\nRegistered Identifier: Physics/SolidMechanics/QuasiStatic/*\nSpecific Task:         \nAdding Action:         QuasiStaticSolidMechanicsPhysics (add_aux_kernel)\nAdding Action:         QuasiStaticSolidMechanicsPhysics (add_aux_variable)\nAdding Action:         QuasiStaticSolidMechanicsPhysics (add_kernel)\nAdding Action:         QuasiStaticSolidMechanicsPhysics (add_master_action_material)\nAdding Action:         QuasiStaticSolidMechanicsPhysics (add_material)\nAdding Action:         QuasiStaticSolidMechanicsPhysics (add_scalar_kernel)\nAdding Action:         QuasiStaticSolidMechanicsPhysics (add_user_object)\nAdding Action:         QuasiStaticSolidMechanicsPhysics (add_variable)\nAdding Action:         QuasiStaticSolidMechanicsPhysics (meta_action)\nAdding Action:         QuasiStaticSolidMechanicsPhysics (setup_mesh_complete)\nAdding Action:         QuasiStaticSolidMechanicsPhysics (validate_coordinate_systems)\n\nParsing Syntax:        Gravity1\nBuilding Action:       AddKernelAction\nRegistered Identifier: Kernels/*\nSpecific Task:         add_kernel\nAdding Action:         AddKernelAction (add_kernel)\n\nParsing Syntax:        archor_x\nBuilding Action:       AddBCAction\nRegistered Identifier: BCs/*\nSpecific Task:         add_bc\nAdding Action:         AddBCAction (add_bc)\n\nParsing Syntax:        archor_y\nBuilding Action:       AddBCAction\nRegistered Identifier: BCs/*\nSpecific Task:         add_bc\nAdding Action:         AddBCAction (add_bc)\n\nParsing Syntax:        archor_z\nBuilding Action:       AddBCAction\nRegistered Identifier: BCs/*\nSpecific Task:         add_bc\nAdding Action:         AddBCAction (add_bc)\n\nParsing Syntax:        Pressure\nBuilding Action:       EmptyAction\nRegistered Identifier: BCs/Pressure\nSpecific Task:         \nAdding Action:         EmptyAction (finish_input_file_output)\nAdding Action:         EmptyAction (no_action)\nAdding Action:         EmptyAction (ready_to_init)\n\nParsing Syntax:        load1\nBuilding Action:       PressureAction\nRegistered Identifier: BCs/Pressure/*\nSpecific Task:         \nAdding Action:         PressureAction (add_bc)\n\nParsing Syntax:        elasticity_tensor1\nBuilding Action:       AddMaterialAction\nRegistered Identifier: Materials/*\nSpecific Task:         \nAdding Action:         AddMaterialAction (add_material)\n\nParsing Syntax:        stress\nBuilding Action:       AddMaterialAction\nRegistered Identifier: Materials/*\nSpecific Task:         \nAdding Action:         AddMaterialAction (add_material)\n\nParsing Syntax:        density1\nBuilding Action:       AddMaterialAction\nRegistered Identifier: Materials/*\nSpecific Task:         \nAdding Action:         AddMaterialAction (add_material)\n\nParsing Syntax:        m1\nBuilding Action:       AddMeshModifiersAction\nRegistered Identifier: MeshModifiers/*\nSpecific Task:         \nAdding Action:         AddMeshModifiersAction (add_mesh_modifier)\n\nParsing Syntax:        Executioner\nBuilding Action:       CreateExecutionerAction\nRegistered Identifier: Executioner\nSpecific Task:         \nAdding Action:         CreateExecutionerAction (setup_executioner)\n\nParsing Syntax:        Outputs\nBuilding Action:       CommonOutputAction\nRegistered Identifier: Outputs\nSpecific Task:         \nAdding Action:         CommonOutputAction (add_output)\nAdding Action:         CommonOutputAction (common_output)\n\nParsing Syntax:        Outputs\nBuilding Action:       AutoCheckpointAction\nRegistered Identifier: Outputs\nSpecific Task:         \nAdding Action:         AutoCheckpointAction (auto_checkpoint_action)\n\nParsing Syntax:        \nBuilding Action:       SetupRecoverFileBaseAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         SetupRecoverFileBaseAction (recover_meta_data)\nAdding Action:         SetupRecoverFileBaseAction (setup_recover_file_base)\n\nParsing Syntax:        \nBuilding Action:       CreateAddedMeshGenerators\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         CreateAddedMeshGenerators (create_added_mesh_generators)\n\nParsing Syntax:        \nBuilding Action:       ExecuteMeshGenerators\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         ExecuteMeshGenerators (execute_mesh_generators)\n\nParsing Syntax:        \nBuilding Action:       AddRelationshipManager\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         AddRelationshipManager (add_algebraic_rm)\nAdding Action:         AddRelationshipManager (add_coupling_rm)\nAdding Action:         AddRelationshipManager (add_geometric_rm)\nAdding Action:         AddRelationshipManager (attach_algebraic_rm)\nAdding Action:         AddRelationshipManager (attach_coupling_rm)\nAdding Action:         AddRelationshipManager (attach_geometric_rm)\nAdding Action:         AddRelationshipManager (attach_geometric_rm_final)\n\nParsing Syntax:        \nBuilding Action:       CreateProblemDefaultAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         CreateProblemDefaultAction (create_problem_default)\nAdding Action:         CreateProblemDefaultAction (determine_system_type)\n\nParsing Syntax:        \nBuilding Action:       AddExecutorAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         AddExecutorAction (add_executor)\n\nParsing Syntax:        \nBuilding Action:       CheckIntegrityAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         CheckIntegrityAction (check_integrity)\nAdding Action:         CheckIntegrityAction (check_integrity_early)\n\nParsing Syntax:        \nBuilding Action:       AddExternalAuxVariableAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         AddExternalAuxVariableAction (add_external_aux_variables)\n\nParsing Syntax:        \nBuilding Action:       SetupQuadratureAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         SetupQuadratureAction (setup_quadrature)\n\nParsing Syntax:        \nBuilding Action:       ComposeTimeStepperAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         ComposeTimeStepperAction (compose_time_stepper)\n\nParsing Syntax:        \nBuilding Action:       SetupTimeStepperAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         SetupTimeStepperAction (setup_time_steppers)\n\nParsing Syntax:        \nBuilding Action:       SetupDampersAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         SetupDampersAction (setup_dampers)\n\nParsing Syntax:        \nBuilding Action:       CopyNodalVarsAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         CopyNodalVarsAction (check_copy_nodal_vars)\nAdding Action:         CopyNodalVarsAction (copy_nodal_aux_vars)\nAdding Action:         CopyNodalVarsAction (copy_nodal_vars)\n\nParsing Syntax:        \nBuilding Action:       MaterialOutputAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         MaterialOutputAction (add_aux_kernel)\nAdding Action:         MaterialOutputAction (add_output_aux_variables)\n\nParsing Syntax:        \nBuilding Action:       DeclareLateReportersAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         DeclareLateReportersAction (declare_late_reporters)\n\nParsing Syntax:        \nBuilding Action:       ResolveOptionalMaterialPropertiesAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         ResolveOptionalMaterialPropertiesAction (resolve_optional_materials)\n\nParsing Syntax:        \nBuilding Action:       CouplingFunctorCheckAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         CouplingFunctorCheckAction (coupling_functor_check)\n\nParsing Syntax:        \nBuilding Action:       InitProblemAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         InitProblemAction (init_problem)\n\nParsing Syntax:        \nBuilding Action:       CheckOutputAction\nRegistered Identifier: (AutoBuilt)\nSpecific Task:         \nAdding Action:         CheckOutputAction (check_output)\n\nParsing Syntax:        exodus\nBuilding Action:       AddOutputAction\nRegistered Identifier: \nSpecific Task:         \nAdding Action:         AddOutputAction (add_output)\n\nParsing Syntax:        console\nBuilding Action:       AddOutputAction\nRegistered Identifier: \nSpecific Task:         \nAdding Action:         AddOutputAction (add_output)\n\n\n\nCan you see what the problem is? I see the Pressure Building Action is EmptyAction.\nParsing Syntax:        Pressure\nBuilding Action:       EmptyAction\nRegistered Identifier: BCs/Pressure\nSpecific Task:         \nAdding Action:         EmptyAction (finish_input_file_output)\nAdding Action:         EmptyAction (no_action)\nAdding Action:         EmptyAction (ready_to_init)",
                          "url": "https://github.com/idaholab/moose/discussions/29078#discussioncomment-11267577",
                          "updatedAt": "2024-11-15T13:59:44Z",
                          "publishedAt": "2024-11-15T13:59:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Try controlling BCs::Pressure::load1_0, BCs::Pressure::load1_1, BCs::Pressure::load1_2\nand if it does not work, try BCs::Pressure_load1_0, BCs::Pressure_load1_1, BCs::Pressure_load1_2",
                          "url": "https://github.com/idaholab/moose/discussions/29078#discussioncomment-11267635",
                          "updatedAt": "2024-11-15T14:05:17Z",
                          "publishedAt": "2024-11-15T14:05:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "There was still an error.\n*** ERROR ***\n'Pressure_load1_0' of type 'Pressure' depends on variable(s) 'disp_x,disp_y,disp_z'. However, that variable does not appear to be defined on (all of) boundary 'top'.\n\nStack frames: 13\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)\n2: boundaryIntegrityCheckError(MooseObject const&, std::set<MooseVariableFieldBase*, std::less<MooseVariableFieldBase*>, std::allocator<MooseVariableFieldBase*> > const&, BoundaryName const&)\n3: BoundaryElemIntegrityCheckThread::operator()(libMesh::StoredRange<MooseMesh::const_bnd_elem_iterator, BndElement const*> const&)\n4: /home/pdd/projects4/moose/framework/libmoose-opt.so.0(+0x1381fbc) [0x7efd1d85cfbc]\n5: FEProblemBase::initialSetup()\n6: Transient::init()\n7: MooseApp::executeExecutioner()\n8: MooseApp::run()\n9: ../../../solid_mechanics-opt(+0x20e8) [0x5624df4f10e8]\n10: main\n11: __libc_start_main\n12: ../../../solid_mechanics-opt(+0x238b) [0x5624df4f138b]\nAbort(1) on node 0 (rank 0 in comm 0): application called MPI_Abort(MPI_COMM_WORLD, 1) - process 0",
                          "url": "https://github.com/idaholab/moose/discussions/29078#discussioncomment-11267784",
                          "updatedAt": "2024-11-15T14:13:43Z",
                          "publishedAt": "2024-11-15T14:13:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is from the integrity check. Can you disable that? We know it should be fine since it's not active",
                          "url": "https://github.com/idaholab/moose/discussions/29078#discussioncomment-11267959",
                          "updatedAt": "2024-11-15T14:18:48Z",
                          "publishedAt": "2024-11-15T14:18:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using Joule Heating Source to simulate heat amount (power loss) of a cable",
          "author": {
            "login": "AgentKTU"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello everyone,\nI am trying to use the JouleHeatingSource to Calculate the heat source term corresponding to electrostatic Joule heating for an underground power cable. The given example Inputfile on the Moose-website runs with a given voltage value (BC) for the left and right boundary of a simple 2d copperplate geometry.\n(https://mooseframework.inl.gov/source/kernels/JouleHeatingSource.html)\nIn general:\nIs it possible to use a given current value instead of a voltage value for the elec variable, to calculate the heat source term?\nWhat is the output unit of the Joule Heating Source or the variable elec --> I assumed [W] ???\nI tried applying the example Inputfile on to my cable geometry (simple 2D circle, generated with Gmsh) where I defined a physical point as a point-source (e.g. 0.1 V) and an outer boundary circle with 0 V. The material properties are assigned to the created surface, see mesh & Inputfile below. (Pleas let me know if the Link doesn't work.)\nhttps://github.com/AgentKTU/JH-Power-cable.git\nUsing this approach I get a calculated temperature of 700 K at the outer boundary, that doesn't seem realistic.\nI tried saving the output of the JouleHeatingSource with   save_in = var. (see AuxVariable in input file) but the results aren't reasonable. The var values are all negativ.\nWhat is the assumed unit or value of the JouleHeatingModule???\nMy goal is to export the value of the Power loss (the heat source term) and implement it to my PorousFlow soil model where I added a heat source boundary.\nAt the end I want to simulate the temperature distribution in the soil by defining realistic boundary conditions and see how the cable temperature reacts.\nI am happy about any help!\nKonstantin",
          "url": "https://github.com/idaholab/moose/discussions/29588",
          "updatedAt": "2024-12-22T19:35:38Z",
          "publishedAt": "2024-12-20T11:42:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I tried saving the output of the JouleHeatingSource with save_in = var. (see AuxVariable in input file) but the results aren't reasonable.\n\nNote that this option gave you the contribution to the residual of that kernel. This can be a little obscure.\nThey are negative because all terms get moved to the left hand side of the equation, so \"sources\" are negative, while losses are positive\n\nIs it possible to use a given current value instead of a voltage value for the elec variable, to calculate the heat source term?\n\n@cticenhour can we do this?\n\nWhat is the output unit of the Joule Heating Source or the variable elec --> I assumed [W] ???\n\nif the mesh and all quantities are in SI units, then the units of the variables and any input to the kernel should also be in SI units",
                  "url": "https://github.com/idaholab/moose/discussions/29588#discussioncomment-11628572",
                  "updatedAt": "2024-12-20T13:09:38Z",
                  "publishedAt": "2024-12-20T13:09:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "Not as-designed with the JouleHeatingSource object as it is, as we make an assumption that the current $\\mathbf{J} = \\sigma \\cdot \\mathbf{E}$, where $\\sigma$ is the electrical conductivity and $\\mathbf{E}$ is the electrostatic electric field, which can be defined as $\\mathbf{E} = - \\nabla \\phi$ where $\\phi$ is the electrostatic potential. So, the heat source $q$ that we're adding to the PDE using JouleHeatingSource is:\n$q = \\mathbf{J} \\cdot \\mathbf{E} = \\sigma \\cdot \\mathbf{E} \\cdot \\mathbf{E} = \\sigma \\cdot \\nabla \\phi \\cdot \\nabla \\phi$\nwith standard SI units of Watts per meters-cubed. The variable elec used in the object would normally be in units of Volts. We don't make explicit assumptions on units in many MOOSE objects, so as long as you are consistent in your input file, we don't impose a specific unit system on you.\nTo go back to the question of whether we can use a current value or not, I cannot think of an alternative off the top of my head that you could use with the right mathematical form. @GiudGiud do you have a thought on this? Maybe we're lucky, and I missed it in the EM module and the framework when I looked through just now. In any case, your residual comtribution (in computeQpResidual) for such an object would need to be something like:\n-_current[_qp] * (-_grad_elec[_qp]) * _test[_i][_qp];\n\nWhere you have a new object parameter to represent your coupled current value (if a variable), or the function / material property form that you might use to compute it otherwise.",
                          "url": "https://github.com/idaholab/moose/discussions/29588#discussioncomment-11631036",
                          "updatedAt": "2024-12-20T16:57:02Z",
                          "publishedAt": "2024-12-20T16:57:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think this makes sense. If current is the main variable you solve for, then use a variable for it. Else I would recommend using an AD material property.\n\nIn any case, your residual comtribution (in computeQpResidual) for such an object would need to be something like:\n\nThis should be all you need to create a new AD kernel tbh so you might as well do that.",
                          "url": "https://github.com/idaholab/moose/discussions/29588#discussioncomment-11644499",
                          "updatedAt": "2024-12-22T19:35:39Z",
                          "publishedAt": "2024-12-22T19:35:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Some questions about calculating time steps",
          "author": {
            "login": "HPL001"
          },
          "bodyText": "Hello moose community,\nI have a problem. The adaptive time interval of the compute step suddenly increases at 5000. This is my compute setting.\n[Executioner]\n  type = Transient\n  # scheme = BDF2\n  # solve_type = PJFNK\n  # petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_ksp_type\n  #                       -sub_pc_type -pc_asm_overla'\n  # petsc_options_value = 'asm      31       preonly\n  #                        ilu      2'\n  solve_type = 'NEWTON'\n  l_tol = 1e-04\n  l_max_its = 30\n  nl_max_its = 15\n  nl_rel_tol = 1e-03\n  nl_abs_tol = 1e-03\n  start_time = 0.0\n  end_time = 20000.0\n  # dt = 0.00125\n\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    cutback_factor = 0.9\n    dt = 0.001\n    growth_factor = 1.2\n    optimal_iterations = 15\n  []\n\n  # [Adaptivity]\n  #   interval = 2\n  #   refine_fraction = 0.2\n  #   coarsen_fraction = 0.3\n  #   max_h_level = 4\n  # []\n[]\n\nand then, Here are the time steps I monitored.",
          "url": "https://github.com/idaholab/moose/discussions/29599",
          "updatedAt": "2024-12-22T19:12:17Z",
          "publishedAt": "2024-12-21T00:24:12Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "HPL001"
                  },
                  "bodyText": "By the way, how should I output my initial condition? Below is my output, but it only outputs the data after the first time step, not the initial situation.",
                  "url": "https://github.com/idaholab/moose/discussions/29599#discussioncomment-11636244",
                  "updatedAt": "2024-12-21T08:33:32Z",
                  "publishedAt": "2024-12-21T08:33:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "HPL001"
                          },
                          "bodyText": "[Outputs]\n  exodus = true\n  print_linear_residuals = true\n  execute_on = timestep_end\n  checkpoint = true\n  solution_history = true\n  # [out]\n  #   type = VTK\n  #   file_base = Sintering_output\n  #   enable = true\n  #   execute_on = timestep_begin\n  # []\n  # [out]\n  #   type = Tecplot\n  #   ascii_append = true\n  # []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/29599#discussioncomment-11636245",
                          "updatedAt": "2024-12-21T08:34:08Z",
                          "publishedAt": "2024-12-21T08:34:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Change execute_on = timestep_end to \"initial timestep_end\"",
                          "url": "https://github.com/idaholab/moose/discussions/29599#discussioncomment-11636868",
                          "updatedAt": "2024-12-21T11:25:32Z",
                          "publishedAt": "2024-12-21T11:25:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "HPL001"
                  },
                  "bodyText": "In addition, I have another question to learn. I used the phase field method and these kernels in the simulation of particle sintering. If I want to see changes in particle shape, should I use the variable bnds or c?\n[Variables]\n  [c] # \u5b9a\u4e49\u9897\u7c92\u6d53\u5ea6\u53d8\u91cf\uff08\u5b88\u6052\u53d8\u91cf\uff09\n    order = FIRST\n    family = LAGRANGE\n  []\n\n  [w] # \u5b9a\u4e49\u603b\u81ea\u7531\u80fd\u7684\u51fd\u6570\u503c\u53d8\u91cf\n    order = FIRST\n    family = LAGRANGE\n  []\n\n  [PolycrystalVariables]\n  []\n[]\n\n[Kernels]\n  [c_res]\n    type = SplitCHParsed\n    f_name = F\n    kappa_name = kappa_c\n    variable = c\n    coupled_variables = 'eta0 eta1'\n    w = w\n  []\n\n  [w_res]\n    type = SplitCHWRes\n    variable = w\n    mob_name = M\n  []\n\n  [time]\n    type = CoupledTimeDerivative\n    v = c\n    variable = w\n  []\n[]\n\n[AuxVariables]\n  [bnds]\n  []\n[]\n\n[AuxKernels]\n  [bnds]\n    type = BndsCalcAux\n    v = 'eta0 eta1'\n    variable = bnds\n    var_name_base = eta\n    op_num = 2\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/29599#discussioncomment-11636772",
                  "updatedAt": "2024-12-21T11:05:11Z",
                  "publishedAt": "2024-12-21T11:03:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "The time stepping behavior is expected. That s what the IterativeDtTimestepper does\nIf you want a different time stepping behavior, pick another one in the Executioner/TimeStepper block",
                  "url": "https://github.com/idaholab/moose/discussions/29599#discussioncomment-11636874",
                  "updatedAt": "2024-12-21T11:27:35Z",
                  "publishedAt": "2024-12-21T11:27:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "HPL001"
                          },
                          "bodyText": "However, this time step, from less than one instant to thousands, is not normal?",
                          "url": "https://github.com/idaholab/moose/discussions/29599#discussioncomment-11636883",
                          "updatedAt": "2024-12-21T11:31:15Z",
                          "publishedAt": "2024-12-21T11:31:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Should be gradual. I ll check this out.\nI d still change the TimeStepper if you don't want it to change",
                          "url": "https://github.com/idaholab/moose/discussions/29599#discussioncomment-11636998",
                          "updatedAt": "2024-12-21T11:56:38Z",
                          "publishedAt": "2024-12-21T11:56:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "HPL001"
                          },
                          "bodyText": "Thank you for your help in checking. I wonder if this phenomenon is normal. Also, is there any way I can limit his maximum time step?",
                          "url": "https://github.com/idaholab/moose/discussions/29599#discussioncomment-11637063",
                          "updatedAt": "2024-12-21T12:09:28Z",
                          "publishedAt": "2024-12-21T12:09:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes you can set dtmax and you can set multiple timesteppers in the TimeSteppers block (notice the s) and the smallest step there by any of the steppers limits the step",
                          "url": "https://github.com/idaholab/moose/discussions/29599#discussioncomment-11637151",
                          "updatedAt": "2024-12-21T12:23:29Z",
                          "publishedAt": "2024-12-21T12:23:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "HPL001"
                          },
                          "bodyText": "I set the maximum time step as you suggested, but something seems to be wrong\n[Executioner]\n  type = Transient\n  # scheme = BDF2\n  # solve_type = PJFNK\n  # petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_ksp_type\n  #                       -sub_pc_type -pc_asm_overla'\n  # petsc_options_value = 'asm      31       preonly\n  #                        ilu      2'\n  solve_type = 'NEWTON'\n  l_tol = 1e-04\n  l_max_its = 30\n  nl_max_its = 15\n  nl_rel_tol = 1e-03\n  nl_abs_tol = 1e-03\n  start_time = 0.0\n  end_time = 20000.0\n  # dt = 0.00125\n\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    cutback_factor = 0.8\n    dt = 0.00001\n    growth_factor = 1.5\n    optimal_iterations = 10\n    iteration_window = 5\n    dtmax = 1.0\n  []\n\n  # [Adaptivity]\n  #   interval = 2\n  #   refine_fraction = 0.2\n  #   coarsen_fraction = 0.3\n  #   max_h_level = 4\n  # []\n[]\n\nerror\uff1a\n*** ERROR ***\n/mnt/d/projects/moose/modules/combined/sintering_datas/02_04_06/peacock_run_exe_tmp_MySintering02_04.i:485.5: unused parameter 'Executioner/TimeStepper/dtmax'\n\nThere seems to be no maximum time step in adaptive step size, and I looked in the manual and couldn't find it.",
                          "url": "https://github.com/idaholab/moose/discussions/29599#discussioncomment-11637294",
                          "updatedAt": "2024-12-21T12:51:20Z",
                          "publishedAt": "2024-12-21T12:51:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you'll have to use two timesteppers to do this then.",
                          "url": "https://github.com/idaholab/moose/discussions/29599#discussioncomment-11644364",
                          "updatedAt": "2024-12-22T19:12:18Z",
                          "publishedAt": "2024-12-22T19:12:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "BreakMeshByBlockGenerator: how to split inner node among subdomains?",
          "author": {
            "login": "favinom"
          },
          "bodyText": "Hi all,\nI am trying to use BreakMeshByBlockGenerator.\nI have four blocks which are included in the domain. See picture.\nIf I call the BreakMeshByBlockGenerator the mid node is not split, which I understand from how it implemented.\nIs there a way to also split that node?\n\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/29585",
          "updatedAt": "2024-12-22T17:59:16Z",
          "publishedAt": "2024-12-19T21:51:43Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nyes you can join up two domains at the top or bottom, then split. (using a RenameBlockGenerator before the BreakMeshBYBlock)\nThen split that domain again (using a ParsedSubdomainGenerator for example)",
                  "url": "https://github.com/idaholab/moose/discussions/29585#discussioncomment-11622434",
                  "updatedAt": "2024-12-19T22:02:28Z",
                  "publishedAt": "2024-12-19T22:02:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "favinom"
                          },
                          "bodyText": "Many thanks for your answer.\nActually, this is what I tried\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    nx = 8\n    ny = 8\n    dim = 2\n  []\n  [block1]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 1\n    bottom_left = '0.25 0.25 0.0'\n    top_right =   '0.75  0.5  0.0'\n    input = gen\n  []\n  [block2]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 2\n    bottom_left = '0.25 0.5 0.0'\n    top_right =   '0.75 0.75  0.0'\n    input = block1\n  []\n  [breakmesh]\n    input = block2\n    type = BreakMeshByBlockGenerator\n    block_pairs = '1 2'\n    split_interface = true\n    #add_interface_on_two_sides = true\n  []\n  [block3]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 3\n    bottom_left = '0.25 0.25 0.0'\n    top_right =   '0.5 0.75  0.0'\n    input = breakmesh\n  []\n  [block4]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 4\n    bottom_left = '0.5 0.25 0.0'\n    top_right =   '0.75 0.75  0.0'\n    input = block3\n  []\n  [breakmesh2]\n    input = block4\n    type = BreakMeshByBlockGenerator\n    block_pairs = '3 4'\n    split_interface = true\n    #add_interface_on_two_sides = true\n  []\n[]\n\nbut unfortunately after I rename the blocks, information of adjacent elements is lost and I cannot apply interface kernels.\nIs there a way not to lose it?",
                          "url": "https://github.com/idaholab/moose/discussions/29585#discussioncomment-11626809",
                          "updatedAt": "2024-12-20T13:05:03Z",
                          "publishedAt": "2024-12-20T09:37:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I cannot apply interface kernels.\n\nIf you use the BreakMeshByBLock you cannot use interface kernels anymore. Interface kernels require a contiguous mesh. Breaking the mesh at boundaries is used for mortar / contact approaches\nAre you just trying to get the interfaces added to the mesh? If so, you just need to use this:\nhttps://mooseframework.inl.gov/source/meshgenerators/SideSetsBetweenSubdomainsGenerator.html",
                          "url": "https://github.com/idaholab/moose/discussions/29585#discussioncomment-11628540",
                          "updatedAt": "2024-12-20T13:06:51Z",
                          "publishedAt": "2024-12-20T13:06:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "favinom"
                          },
                          "bodyText": "I understand. I am trying to apply interface kernels to a jump operator between a broken mesh.\nI would need duplicated nodes in the mesh and discontinuous basis functions. Is there a way to do this in moose?",
                          "url": "https://github.com/idaholab/moose/discussions/29585#discussioncomment-11634024",
                          "updatedAt": "2024-12-20T22:19:42Z",
                          "publishedAt": "2024-12-20T22:19:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nWe do support discontinuous galerkin.\nDo you really need the mesh to be broken? If it is going to be broken, InterfaceKernel is the wrong system to look at",
                          "url": "https://github.com/idaholab/moose/discussions/29585#discussioncomment-11634317",
                          "updatedAt": "2024-12-20T23:29:26Z",
                          "publishedAt": "2024-12-20T23:29:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We can do DG with a contiguous mesh, and without duplicating the nodes. The nodal values can be different on each element",
                          "url": "https://github.com/idaholab/moose/discussions/29585#discussioncomment-11634321",
                          "updatedAt": "2024-12-20T23:30:22Z",
                          "publishedAt": "2024-12-20T23:30:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "favinom"
                          },
                          "bodyText": "I would need the same structure of DG but just along some interfaces. I would need the interface integrals over \\gamma in the formula at the beginning of page 19 of https://arxiv.org/pdf/2412.00443 .\nActually breaking the mesh and using interface kernels was a perfect combination.\nHow would you suggest to do it?",
                          "url": "https://github.com/idaholab/moose/discussions/29585#discussioncomment-11636153",
                          "updatedAt": "2024-12-21T08:03:23Z",
                          "publishedAt": "2024-12-21T08:03:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "In how many places do you need to do this?\nIf not too many I would recommend using two variables, a non broken mesh and an interface kernel. Having two variables makes it easy to have a discontinuity",
                          "url": "https://github.com/idaholab/moose/discussions/29585#discussioncomment-11636884",
                          "updatedAt": "2024-12-21T11:31:30Z",
                          "publishedAt": "2024-12-21T11:31:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "favinom"
                          },
                          "bodyText": "Ideally, we would like to go for 100  interfaces.\nThe approach with two variables is doable if the interface cuts the whole domain, but I do not know if it is possible if the interface is included in the domain, as in the picture I posted above.\nMaybe I can try with constraints?\nHowever, I think the feature I need could be of interest also for someone else.\nWhat is BreakBoundaryOnSubdomainGenerator doing?\nMany thanks",
                          "url": "https://github.com/idaholab/moose/discussions/29585#discussioncomment-11638366",
                          "updatedAt": "2024-12-21T16:34:42Z",
                          "publishedAt": "2024-12-21T16:34:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are they ordered very regularly (like all aligned in 1D so you could alternate just two sets of variables) ?\nOr is it somewhat random?\n\nbut I do not know if it is possible if the interface is included in the domain, as in the picture I posted above.\n\nIt is possible to block restrict in parts of the mesh, even if it's an inclusion and not spanning the entire domain.\n\nMaybe I can try with constraints?\n\nMortar constraints are definitely a solution here. If you split the domain (e.g. use the BreakXYZMeshGenerator, that creates a non-conformal mesh)\n\nWhat is BreakBoundaryOnSubdomainGenerator doing?\n\nIt does what the BreakMeshByBlock does but only along a given boundary, and creating different breakages (the breaks have non-broken nodes at each end) for each subdomain along that boundary",
                          "url": "https://github.com/idaholab/moose/discussions/29585#discussioncomment-11643970",
                          "updatedAt": "2024-12-22T17:59:16Z",
                          "publishedAt": "2024-12-22T17:59:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to nucleate at grain boundaries instead of random locations",
          "author": {
            "login": "Sabalei"
          },
          "bodyText": "Hi moose community,\nI am trying to simulate static recrystallization.\nI am trying to follow the https://mooseframework.inl.gov/modules/phase_field/Nucleation/DiscreteNucleation.html instructions below:\n\"Direct order parameter modification\n...\nI want to know how to control nucleation at grain boundaries rather than random locations",
          "url": "https://github.com/idaholab/moose/discussions/29600",
          "updatedAt": "2024-12-21T11:29:51Z",
          "publishedAt": "2024-12-21T10:24:56Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think you'll want to modify DiscreteNucleation. You can create a new object called GrainBoundaryDiscreteNucleation.\nThe first step there will be to detect grain boundaries, which you can do by analyzing the order parameters",
                  "url": "https://github.com/idaholab/moose/discussions/29600#discussioncomment-11636877",
                  "updatedAt": "2024-12-21T11:29:52Z",
                  "publishedAt": "2024-12-21T11:29:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Spatial initial condition from file",
          "author": {
            "login": "Khaksarkn"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi,\nI was wondering if there is a way of specifying the initial distribution of a variable based on grid data. Say the data is available on a grid from a csv file like this (as a function of space; but it's not an expression function, it more like data collected from measurement):\nx, y, z, temperature\n0.0, 0.0, 0.0, 5.0\n10.0, 0.0, 0.0, 4.0\n10.0, 10.0, 0.0, 3.0\n0.0, 10.0, 0.0, 6.0\n\nand if it can interpolate on the nodes like a scattered interpolant?\nI searched the functions for a function that reads from a file to use a Function IC (something like a ParsedFileFunction). but I didn't find one.\nOr if there is a way to specify on the mesh (in the mesh module)\nI would appreciate it if you could guide me with this.\nThis is a sample input file I was trying to modify for this:\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 5\n  ny = 5\n  xmin = 0\n  xmax = 10\n  ymin = 0\n  ymax = 10\n[]\n\n[Variables]\n  [temperature]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[Kernels]\n  [diff]\n    type = Diffusion\n    variable = temperature\n  []\n  [timederiv]\n    type = TimeDerivative\n    variable = temperature\n  []\n[]\n\n[BCs]\n  [bottomofthesample]\n    type = DirichletBC\n    variable = temperature\n    boundary = bottom\n    value = 1\n  []\n  \n  [topofthesample]\n    type = DirichletBC\n    variable = temperature\n    boundary = top\n    value = 0\n  []\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 100\n  dt = 1\n  solve_type = 'NEWTON'\n[]\n\n[Outputs]\n  execute_on = 'TIMESTEP_BEGIN'\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/29595",
          "updatedAt": "2024-12-23T16:58:06Z",
          "publishedAt": "2024-12-20T18:47:33Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf the grid is regular the Piecewise(Multi)Constant Piecewise(Multi)Linear functions can read it, and the FunctionIC can be used:\nhttps://mooseframework.inl.gov/source/functions/PiecewiseMultiConstant.html\nhttps://mooseframework.inl.gov/source/functions/PiecewiseMultiLinear.html\nthen this\nhttps://mooseframework.inl.gov/source/ics/FunctionIC.html\nIf not, use a PropertyReadFile user object to read the file (using the \"voronoi\" mode), then a PiecewiseConstantFromCSV function and a FunctionIC\nhttps://mooseframework.inl.gov/source/userobjects/PropertyReadFile.html\nhttps://mooseframework.inl.gov/source/functions/PiecewiseConstantFromCSV.html",
                  "url": "https://github.com/idaholab/moose/discussions/29595#discussioncomment-11634943",
                  "updatedAt": "2024-12-22T19:27:42Z",
                  "publishedAt": "2024-12-21T03:20:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "WASP not available error",
          "author": {
            "login": "charlotte-b8086"
          },
          "bodyText": "Hello,\nI am a novice to MOOSE and have been working through various tutorials. I successfully completed Steps 1 - 4 of the Tutorial 1 App Development available on MOOSE's website. Today as I was working on Step 5, I kept getting an error when I tried to compile with make -j 4.\nI kept getting an error about the system not knowing WASP and lib mesh.\nAfter getting this error multiple times I attempted to erase my MOOSE directory from my laptop, uninstall MOOSE, and re-install it. That has not fixed the problem- I am now getting the following error message\nprojects/moose/tutorials/darcy_thermo_mech/../..//framework/contrib/wasp/install/lib: No such file or directory\nNot compiling MOOSE with NEML2 because NEML2_DIR is not a valid NEML2 checkout and/or libtorch is not enabled.\nERROR\nWASP does not seem to be available.\nMake sure to either run scripts/update_and_rebuild_wasp.sh in your MOOSE directory,\nor set WASP_DIR to a valid WASP install\nmake: *** [wasp_submodule_status] Error 1\nmake: *** Waiting for unfinished jobs....\nAny suggestions on how to approach?",
          "url": "https://github.com/idaholab/moose/discussions/26928",
          "updatedAt": "2024-12-20T13:18:07Z",
          "publishedAt": "2024-02-29T01:30:53Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid you use the conda based installation method?\nIf so, did you remember to activate the moose environment before compiling? You need to do that every time, or just put the command conda activate moose in your .bashrc file\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8625878",
                  "updatedAt": "2024-02-29T05:59:48Z",
                  "publishedAt": "2024-02-29T04:38:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "charlotte-b8086"
                          },
                          "bodyText": "Hello,\nThank you for your response.\nYes, I used the conda based installation method and activated the environment by running\nconda activate mambaforge3/envs/moose\nbefore compiling.",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8630824",
                          "updatedAt": "2024-02-29T13:25:07Z",
                          "publishedAt": "2024-02-29T13:25:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Can you activate moose, and then run the following commands:\necho $WASP_DIR $LIBMESH_DIR $MOOSE_DIR\nls $LIBMESH_DIR\nls $WASP_DIR\nI want to see if they are set, and that the location they are set to is populated correctly. In the past, and I am not so sure if this behavior still exists, it was possible to be using the Conda packages, and then run update_and_rebuild_$$$$$ scripts, and that would delete the Conda package location holding these libraries.",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8631132",
                          "updatedAt": "2024-02-29T13:51:21Z",
                          "publishedAt": "2024-02-29T13:51:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "charlotte-b8086"
                          },
                          "bodyText": "This is what that returned:\n(base) beckford@BeckforathMBPro projects % echo $WASP_DIR $LIBMESH_DIR $MOOSE_DIR\n(base) beckford@BeckforathMBPro projects % ls $LIBMESH_DIR\nmoose\n(base) beckford@BeckforathMBPro projects % ls $WASP_DIR\nmoose",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8631740",
                          "updatedAt": "2024-02-29T14:36:23Z",
                          "publishedAt": "2024-02-29T14:36:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Can you activate moose before you run those commands?",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8631816",
                          "updatedAt": "2024-02-29T14:42:05Z",
                          "publishedAt": "2024-02-29T14:42:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "charlotte-b8086"
                          },
                          "bodyText": "Sorry I thought MOOSE was activated but it wasn't!\n(base) beckford@BeckforathMBPro ~ % conda activate mambaforge3/envs/moose\n(moose) beckford@BeckforathMBPro ~ % echo $WASP_DIR $LIBMESH_DIR $MOOSE_DIR\n/Users/beckford/mambaforge3/envs/moose/wasp /Users/beckford/mambaforge3/envs/moose/libmesh\n(moose) beckford@BeckforathMBPro ~ % ls $LIBMESH_DIR\nMake.common\tcontrib\t\texamples\tlib\nbin\t\tetc\t\tinclude\t\tshare\n(moose) beckford@BeckforathMBPro ~ % ls $WASP_DIR\nLICENSE\t\tWASP_README.md\tbin\t\tinclude\t\tlib\t\tscripts\n(moose) beckford@BeckforathMBPro ~ %",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8631891",
                          "updatedAt": "2024-02-29T14:47:21Z",
                          "publishedAt": "2024-02-29T14:47:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "charlotte-b8086"
                          },
                          "bodyText": "Do I just need to run conda update --all?",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8631925",
                          "updatedAt": "2024-02-29T15:56:31Z",
                          "publishedAt": "2024-02-29T14:49:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "You probably do not need to perform an update. You just need to return to what you were doing before :)\nIf you happen to have performed any git fetch or git pull commands recently, then yes, you should also perform conda update --all while the moose environment is activated (so as to update that environment).",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8632310",
                          "updatedAt": "2024-02-29T15:22:55Z",
                          "publishedAt": "2024-02-29T15:22:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "charlotte-b8086"
                          },
                          "bodyText": "What do you mean I need to return to what I was doing before?",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8632765",
                          "updatedAt": "2024-02-29T15:56:16Z",
                          "publishedAt": "2024-02-29T15:56:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Try to make moose again and see if the situation improved",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8632892",
                          "updatedAt": "2024-02-29T16:04:54Z",
                          "publishedAt": "2024-02-29T16:04:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "charlotte-b8086"
                          },
                          "bodyText": "It has not\n(moose) beckford@BeckforathMBPro step01_diffusion % make -j4\nNot compiling MOOSE with NEML2 because NEML2_DIR is not a valid NEML2 checkout and/or libtorch is not enabled.\nCompiling C++ (in opt mode) /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/mesh_Unity.C...\nCompiling C++ (in opt mode) /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/fvics_Unity.C...\nCompiling C++ (in opt mode) /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/auxkernels_Unity.C...\nCompiling C++ (in opt mode) /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/kernels_Unity.C...\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/kernels_Unity.C:2:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/src/kernels/ADConservativeAdvection.C:10:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/ADConservativeAdvection.h:12:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/ADKernel.h:12:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/KernelBase.h:12:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/ResidualObject.h:23:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/TaggingInterface.h:15:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/Assembly.h:16:\n/Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/ArbitraryQuadrature.h:50:34: error: 'clone' marked 'override' but does not override any member functions\n  virtual std::unique_ptr<QBase> clone() const override;\n                                 ^\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/auxkernels_Unity.C:2:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/src/auxkernels/AdvectiveFluxAux.C:11:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/Assembly.h:16:\n/Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/ArbitraryQuadrature.h:50:34: error: 'clone' marked 'override' but does not override any member functions\n  virtual std::unique_ptr<QBase> clone() const override;\n                                 ^\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/fvics_Unity.C:5:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/src/fvics/FVInitialConditionTempl.C:12:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/Assembly.h:16:\n/Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/ArbitraryQuadrature.h:50:34: error: 'clone' marked 'override' but does not override any member functions\n  virtual std::unique_ptr<QBase> clone() const override;\n                                 ^\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/mesh_Unity.C:10:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/src/mesh/MooseMesh.C:20:\nIn file included from /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/Assembly.h:16:\n/Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/header_symlinks/ArbitraryQuadrature.h:50:34: error: 'clone' marked 'override' but does not override any member functions\n  virtual std::unique_ptr<QBase> clone() const override;\n                                 ^\n1 error generated.\nmake: *** [/Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build.mk:151: /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/fvics_Unity.x86_64-apple-darwin13.4.0.opt.lo] Error 1\nmake: *** Waiting for unfinished jobs....\n1 error generated.\nmake: *** [/Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build.mk:151: /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/kernels_Unity.x86_64-apple-darwin13.4.0.opt.lo] Error 1\n1 error generated.\nmake: *** [/Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build.mk:151: /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/mesh_Unity.x86_64-apple-darwin13.4.0.opt.lo] Error 1\n1 error generated.\nmake: *** [/Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build.mk:151: /Users/beckford/projects/moose/tutorials/darcy_thermo_mech/../..//framework/build/unity_src/auxkernels_Unity.x86_64-apple-darwin13.4.0.opt.lo] Error 1\n(moose) beckford@BeckforathMBPro step01_diffusion %",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8632933",
                          "updatedAt": "2024-02-29T16:07:59Z",
                          "publishedAt": "2024-02-29T16:07:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "@milljm why is it lagging? conda update moose-dev maybe instead of conda install\n\nIt might have been lagging because the instructions were not 100% followed to the letter. For example:\n\nSince I don't use Conda for anything else, I did delete it and reinstalled miniconda.\nI then was trying to follow the MOOSE installation instructions. I came upon one error that said there was no livereload channel, so I downloaded that.\n\n\nWe don't have anything among our documentation that says \"miniconda\" anymore.\nlivereload comes with modern moose-dev, because moose-dev installs moose-tools. And moose-tools contains livereload\n\nMy guess is that the instructions @charlotte-b8086 are not precisely the ones found at: https://mooseframework.inl.gov/getting_started/installation/conda.html",
                  "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8635266",
                  "updatedAt": "2024-02-29T20:06:13Z",
                  "publishedAt": "2024-02-29T20:06:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "charlotte-b8086"
                          },
                          "bodyText": "So it is actually working now (yay!), but do you recommend I uninstall MOOSE once again, maybe delete my miniconda, install just conda not miniconda, and reinstall MOOSE again? I see from running conda --info  in the MOOSE environment that the active environment location is in my miniconda3 folder, so I am not sure if that will cause future issues.\nAlso thank you both so much for all of your assistance. Was the original problem that my WASP/libmesh packages were not synced up so I had to make those synced? It would be good to know how to recognize this issue in the future and prevent it from happening.\nIn general, do you have any recommendations on how one gets better at MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8635660",
                          "updatedAt": "2024-02-29T20:53:19Z",
                          "publishedAt": "2024-02-29T20:53:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If your miniconda is working you can use it for now. If it stops working using our conda is best.\n\nIn general, do you have any recommendations on how one gets better at MOOSE?\n\nthere are tutorials. But probably just practice and reach out when you hit issues",
                          "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-8635848",
                          "updatedAt": "2024-02-29T21:17:18Z",
                          "publishedAt": "2024-02-29T21:17:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "yangdianxi"
                  },
                  "bodyText": "Hello, have you solved this problem? Now I have made the same mistake as you in the process of installing moose, but I can't solve it. I hope to get your help\uff0cThe following is also my problem.\nWASP does not seem to be available.\nMake sure to either run scripts/update_and_rebuild_wasp.sh in your MOOSE directory,\nor set WASP_DIR to a valid WASP install",
                  "url": "https://github.com/idaholab/moose/discussions/26928#discussioncomment-11628648",
                  "updatedAt": "2024-12-20T13:18:08Z",
                  "publishedAt": "2024-12-20T13:18:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "LibMambaUnsatisfiableError: Encountered problems while solving:",
          "author": {
            "login": "yangdianxi"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\nconda create -n moose moose-dev=2024.12.02=mpich\nafter\uff1a\nChannels:\n\nhttps://conda.software.inl.gov/public\nconda-forge\nPlatform: linux-64\nCollecting package metadata (repodata.json): done\nSolving environment: failed\n\nLibMambaUnsatisfiableError: Encountered problems while solving:\n\nnothing provides __glibc >=2.28,<3.0.a0 needed by c-ares-1.34.3-heb4867d_0\n\nCould not solve for environment specs\nThe following package could not be installed\n\u2514\u2500 moose-dev ==2024.12.2 mpich is not installable because it requires\n\u2514\u2500 moose-libmesh ==2024.12.2 mpich_0, which requires\n\u2514\u2500 moose-petsc ==3.22.1.193.0g72c1e49ee3d mpich_0, which requires\n\u2514\u2500 moose-mpi =2024.11.13 *, which requires\n\u2514\u2500 moose-mpi-base [==2024.11.13 mpich|==2024.11.13 openmpi], which requires\n\u2514\u2500 c-ares ==1.34.3 heb4867d_0, which requires\n\u2514\u2500 __glibc >=2.28,<3.0.0a0 *, which is missing on the system.\ndonot find resolve approach\n(Optional) code in question / simulation log / errors\nNo response\nEncountering Errors? Please include diagnostic output\nNo response",
          "url": "https://github.com/idaholab/moose/discussions/29564",
          "updatedAt": "2024-12-20T13:15:26Z",
          "publishedAt": "2024-12-17T12:19:43Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you please paste the output of the diagnostics script in moose/scripts?",
                  "url": "https://github.com/idaholab/moose/discussions/29564#discussioncomment-11592606",
                  "updatedAt": "2024-12-17T12:22:38Z",
                  "publishedAt": "2024-12-17T12:22:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "yangdianxi"
                          },
                          "bodyText": "yes\uff0cthank you\uff0cI will send you the screenshot of the wrong picture",
                          "url": "https://github.com/idaholab/moose/discussions/29564#discussioncomment-11593015",
                          "updatedAt": "2024-12-17T12:55:49Z",
                          "publishedAt": "2024-12-17T12:55:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It looks like the upload did not work.\nIf you can copy paste instead of screenshot, it's better for searching",
                          "url": "https://github.com/idaholab/moose/discussions/29564#discussioncomment-11595431",
                          "updatedAt": "2024-12-17T16:12:07Z",
                          "publishedAt": "2024-12-17T16:12:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "yangdianxi"
                  },
                  "bodyText": "(base) user@user-virtual-machine:~$ conda create -n moose moose-dev=2024.12.02=mpich\nChannels:\n - https://conda.software.inl.gov/public\n - conda-forge\nPlatform: linux-64\nCollecting package metadata (repodata.json): done\nSolving environment: failed\n\nLibMambaUnsatisfiableError: Encountered problems while solving:\n  - nothing provides __glibc >=2.28,<3.0.a0 needed by c-ares-1.34.3-heb4867d_0\n\nCould not solve for environment specs\nThe following package could not be installed\n\u2514\u2500  moose-dev ==2024.12.2 mpich is not installable because it requires\n   \u2514\u2500 moose-libmesh ==2024.12.2 mpich_0, which requires\n      \u2514\u2500 moose-petsc ==3.22.1.193.0g72c1e49ee3d mpich_0, which requires\n         \u2514\u2500 moose-mpi =2024.11.13 *, which requires\n\nI'm sorry. I don't know why it didn't go up. This is the content of the error, I have pasted it all down, hope it helps\n            \u2514\u2500 moose-mpi-base [==2024.11.13 mpich|==2024.11.13 openmpi], which requires\n               \u2514\u2500 c-ares ==1.34.3 heb4867d_0, which requires\n                  \u2514\u2500 __glibc >=2.28,<3.0.0a0 *, which is missing on the system.\n\n(base) user@user-virtual-machine:~$",
                  "url": "https://github.com/idaholab/moose/discussions/29564#discussioncomment-11602991",
                  "updatedAt": "2024-12-18T16:19:55Z",
                  "publishedAt": "2024-12-18T09:18:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what version of linux are you running? Seems to not be supported by our conda build",
                          "url": "https://github.com/idaholab/moose/discussions/29564#discussioncomment-11607678",
                          "updatedAt": "2024-12-18T16:20:19Z",
                          "publishedAt": "2024-12-18T16:20:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "We might have had a bad set of packages that round. When I look into this a bit, it seems newly created packages (which are in the works) do not exhibit this issue.\nCan you try the following?\nconda create -n moose moose-dev mpich --channel https://conda.software.inl.gov/moose/pr-29104\nRef PR that fixes this issue: #29104",
                          "url": "https://github.com/idaholab/moose/discussions/29564#discussioncomment-11608210",
                          "updatedAt": "2024-12-18T17:09:00Z",
                          "publishedAt": "2024-12-18T17:08:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "yangdianxi"
                          },
                          "bodyText": "I am using Wmware Ubuntu system.",
                          "url": "https://github.com/idaholab/moose/discussions/29564#discussioncomment-11613501",
                          "updatedAt": "2024-12-19T06:27:58Z",
                          "publishedAt": "2024-12-19T06:27:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "yangdianxi"
                          },
                          "bodyText": "(base) user@user-virtual-machine:~$ conda create -n moose moose-dev mpich --channel https://conda.software.inl.gov/moose/pr-29104\nRetrieving notices: done\nChannels:\n\nhttps://conda.software.inl.gov/moose/pr-29104\nhttps://conda.software.inl.gov/public\nconda-forge\nPlatform: linux-64\nCollecting package metadata (repodata.json): failed\n\nUnavailableInvalidChannel: HTTP 403 FORBIDDEN for channel moose/pr-29104 https://conda.software.inl.gov/moose/pr-29104\nThe channel is not accessible or is invalid.\nYou will need to adjust your conda configuration to proceed.\nUse conda config --show channels to view your configuration's current state,\nand use conda config --show-sources to view config file locations.\nOh,still report an error,that does not seem like a good idea.Dependent libraries do not match?.I do not  know what to do.",
                          "url": "https://github.com/idaholab/moose/discussions/29564#discussioncomment-11613517",
                          "updatedAt": "2024-12-19T06:32:33Z",
                          "publishedAt": "2024-12-19T06:32:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I am not sure why you can't peruse to that location... can you click on the link?\nhttps://conda.software.inl.gov/moose/pr-29104\nIf you can navigate there using your web browser, but not when using terminal:\n$ curl https://conda.software.inl.gov/moose/pr-29104/index.html\n<trimmed>\n\n\n<td>X</td><td>X</td><td></td>      <td class=\"summary\">The Workbench Analysis Sequence Processor (WASP) was developed to...</td>\n    </tr>  </table>\n  <address>Updated: 2024-12-18 20:16:05 +0000 - Files: 14</address>\n</body>\n</html>%  \nThen this will indicate you are using some sort of Government/Corporate proxy preventing you access.",
                          "url": "https://github.com/idaholab/moose/discussions/29564#discussioncomment-11617682",
                          "updatedAt": "2024-12-19T13:47:24Z",
                          "publishedAt": "2024-12-19T13:47:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "yangdianxi"
                          },
                          "bodyText": "WASP does not seem to be available.\nMake sure to either run scripts/update_and_rebuild_wasp.sh in your MOOSE directory,\nor set WASP_DIR to a valid WASP install\nI think I have installed it, the link is ready to use, the installation package is ready to download, but there are some problems when testing again, I don't know what this WASP means?The above error occurred",
                          "url": "https://github.com/idaholab/moose/discussions/29564#discussioncomment-11628576",
                          "updatedAt": "2024-12-20T13:10:06Z",
                          "publishedAt": "2024-12-20T13:10:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}