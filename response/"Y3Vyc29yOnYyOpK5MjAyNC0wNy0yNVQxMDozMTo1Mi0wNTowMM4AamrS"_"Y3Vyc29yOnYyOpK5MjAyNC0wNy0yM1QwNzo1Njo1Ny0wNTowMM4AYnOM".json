{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wNy0yM1QwNzo1Njo1Ny0wNTowMM4AYnOM"
    },
    "edges": [
      {
        "node": {
          "title": "Error during build: ld: library not found for -lvtkIOCore-9.1",
          "author": {
            "login": "hsheldon"
          },
          "bodyText": "I'm getting this error during a build of porous_flow or combined:\nld: library not found for -lvtkIOCore-9.1\nclang-12: error: linker command failed with exit code 1 (use -v to see invocation)\nAny ideas?",
          "url": "https://github.com/idaholab/moose/discussions/24305",
          "updatedAt": "2024-07-25T14:16:20Z",
          "publishedAt": "2023-05-09T05:54:55Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hsheldon"
                  },
                  "bodyText": "Ignore that, problem resolved by deleting everything and starting over",
                  "url": "https://github.com/idaholab/moose/discussions/24305#discussioncomment-5845106",
                  "updatedAt": "2023-05-09T06:16:06Z",
                  "publishedAt": "2023-05-09T06:16:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Bigdogcat"
                          },
                          "bodyText": "Hi, may I know how you solve this problem? I also ran into the same issue:\nld: library not found for -lvtkParallelMPI-9.2\nclang-16: error: linker command failed with exit code 1 (use -v to see invocation)\nThanks very much",
                          "url": "https://github.com/idaholab/moose/discussions/24305#discussioncomment-10149730",
                          "updatedAt": "2024-07-25T14:16:21Z",
                          "publishedAt": "2024-07-25T14:16:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "GenericFunctionMaterial: add and multiply?",
          "author": {
            "login": "jmeier"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nDear Moose-Community,\nWith this post, I would like to discuss with you whether we should add four new (optional) parameters to GenericFunctionMaterial. I am somewhat undecided here: On the one hand, it would make input files shorter and easier to read and require fewer function objects. On the other hand, it would double functionality.\nInitial situation\nFor models in which different material parameters have to be multiplied by the same factor, several functions often have to be defined per material parameter and per element group (e.g. subdomain). In the simplest case, two functions per parameter and subdomain: at least one function with the \"original\" (non-multiplied) distribution and one for the multiplied distribution. The same applies in the case of addition (parameter value offset).\nPossible Solution\nThe definition of the second function could be omitted if GenericFunctionMaterial could take over this multiplication/addition directly.\nThis could look like this in the input file:\n[./gfm]\n  type = GenericFunctionMaterial\n  block = 'ThisBlockOverThere'\n  prop_names = density\n  prop_values = dens_func\n  multiply_by_const = 3.9  # constant values to multiply prop_values by (before add)\n  multiply_by = 'MyRampFunction1'  # functions to multiply prop_values by (before add)\n  add_const = 85.7  # constant values to add to prop_values (after multiplication)\n  add = 'MyRampFunction2'  # functions to add to prop_values (after multiplication)\n[]\n\nAdvantages:\n\nFewer functions, as the addition/multiplication takes place directly in GenericFunctionMaterial\nShorter input files (easier to read, reduced potential for input errors)\n\nDisadvantages:\n\nDuplication of functionality (the GenericFunctionMaterial can now calculate)\nMore complexity in GenericFunctionMaterial\n\nPlease let me know what you think about this extension to the GenericFunctionMaterial. If this addition makes sense from your point of view, I can try to program it and then submit a PR.\nJ\u00f6rg",
          "url": "https://github.com/idaholab/moose/discussions/28027",
          "updatedAt": "2024-07-25T07:20:32Z",
          "publishedAt": "2024-07-01T05:50:27Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo these four hard-coded operations wont be needed\nCan you use a ParsedMaterial preferrably?\nIf it does not support all you need then we'll need to add that\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-9930670",
                  "updatedAt": "2024-07-02T00:20:32Z",
                  "publishedAt": "2024-07-02T00:20:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Guillaume,\nThank you for your answer and ponting to ParsedMaterial.\nAs good as ParsedMaterial looks to me, it doesn't seem to be able to multiply by another function value.\nIn the spirit of your answer I would like to explore all possibilities before proposing new code:\nQuestion 1:\nAs far I understood ParsedMaterial, it can use variables (coupled_variables) and a user-defined FParser-function. But is there a way to use another Moose-Function as input?\nQuestion 2:\nI know I can use t to make the function in ParsedMaterial dependent on time. But is there a way to make a Moose variable dependent on time?\nThis is not working: bla = '${fparse (34 + t)*0}'\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-9932256",
                          "updatedAt": "2024-07-02T05:38:46Z",
                          "publishedAt": "2024-07-02T05:38:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nOk I was semi expecting this.\nParsedMaterial doesn't support functions directly.\nHowever it supports auxiliary variables, and ParsedAux supports functions through the use of the functor_names arguments\nYou should be able to forward things that way into a material property\nIt would be good to simplify this if you have development time\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-9936367",
                          "updatedAt": "2024-07-02T12:35:34Z",
                          "publishedAt": "2024-07-02T12:35:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Guillaume,\nIn this case, perhaps I should adapt my request? Wouldn't it make more sense to extend ParsedMaterial with the option to access Moose functions and leave GenericFunctionMaterial as it is? (Disclaimer: I haven't looked at the code of ParsedMaterial yet. I have no idea whether this suggestion makes sense).\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-9936900",
                          "updatedAt": "2024-07-02T13:23:44Z",
                          "publishedAt": "2024-07-02T13:23:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This makes sense.\nHappy to support that.\nYou may want to add functor support instead, this adds support for functions, variables, pps and functor materials.\nAnd this list is bound to expand",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-9936969",
                          "updatedAt": "2024-07-02T13:29:38Z",
                          "publishedAt": "2024-07-02T13:29:38Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Now we have a whish list! When I have time, I'll have a look through the code. I'll close this thread due to fact, the initial question has been answerd. Once again, thanks for your support!",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-9937072",
                          "updatedAt": "2024-07-02T13:37:56Z",
                          "publishedAt": "2024-07-02T13:37:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "https://mooseframework.inl.gov/source/materials/MaterialFunctorConverter.html this should be a good example to look at to create a functor argument\nthen ParsedAux should show how to add functors to the parsed expression, with all the nice checks",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-9937384",
                          "updatedAt": "2024-07-02T14:03:34Z",
                          "publishedAt": "2024-07-02T14:03:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "I'm now looking into extending ParsedMaterial with functor support. Here I need some advice: My first approach was to add the parameters \"functor_names\" and \"functor_symbols\" to ParsedMaterialBase. While adding the parameters itself is not a probem, I like to check them and call paramError in case something is not right. Due to the fact, ParsedMaterialBase seems not to derive from MooseObject, I cannot call paramError . Shall I move these two parameters to ParsedMaterialHelper (what feels \"wrong\")? Or shall I make ParsedMaterialBase derive from MooseObject? Or I'm overlooking something?",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-10130143",
                          "updatedAt": "2024-07-23T19:05:54Z",
                          "publishedAt": "2024-07-23T19:05:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can use a pointer to the object (in the code: this), which you can cast as well, to call paramError",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-10130233",
                          "updatedAt": "2024-07-23T19:16:36Z",
                          "publishedAt": "2024-07-23T19:16:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "I'm sorry, I need more help.\nMooseObject * mo_ptr = dynamic_cast<MooseObject *>(this);\ngives an compiler error:\nerror: cannot 'dynamic_cast' '(ParsedMaterialBase*)this' (of type 'class ParsedMaterialBase*') to type 'class MooseObject*' (source type is not polymorphic)",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-10133496",
                          "updatedAt": "2024-07-24T05:36:52Z",
                          "publishedAt": "2024-07-24T05:36:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "ah too bad.\nOk in the constructor of ParsedMaterialBase, could you start passing a pointer to the class which is building it?\nIs ParsedMaterialBase only created as a base class of classes that derive from MooseObjects?  This would let you do a constructor like:\nParsedMaterialBase::ParsedMaterialBase(const InputParameters & parameters, MooseObject * derived_class)\nthen we could do something like\n_derived_class->paramError(",
                  "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-10137964",
                  "updatedAt": "2024-07-24T13:40:15Z",
                  "publishedAt": "2024-07-24T13:40:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Thank you! This is how I implemented this now.\nWhile advancing with my code, I hit some more problems. I would like to coordinate how best to proceed here. Is it better to ask my questions here in this discussion, or should I better create a PR (as a draft?). Obviosly, this PR will initially be incomplete.",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-10144896",
                          "updatedAt": "2024-07-25T05:47:01Z",
                          "publishedAt": "2024-07-25T05:47:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Draft PR is a good idea",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-10145414",
                          "updatedAt": "2024-07-25T06:52:36Z",
                          "publishedAt": "2024-07-25T06:52:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Issue: #28220\nPR (draft for now): #28221",
                          "url": "https://github.com/idaholab/moose/discussions/28027#discussioncomment-10145671",
                          "updatedAt": "2024-07-25T07:20:33Z",
                          "publishedAt": "2024-07-25T07:20:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Resuming simulation from previous starting point",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "Hi,\nI wanted to know if I can resume a simulation with the deformed mesh of an initial simulation (simple stretching of a plate). From this page (https://mooseframework.inl.gov/modules/porous_flow/restart.html) it mentioned the meshes need to be the same. But after finite biaxial stretching the mesh in the first simulation is a bit different from its original configuration.\nSecondly, I wanted to know if it is possible to restart the aux variables instead of the regular variables. The reason for this is that my first simulation is a simple stretching problem, so my variables are just disp_x and disp_y, but the second one is a frequency domain problem where displacements are split into real and imaginary parts like the last example on this page (https://mooseframework.inl.gov/modules/solid_mechanics/1d_elastic_waves.html).\nThe other idea I was thinking of is to also split the stretching displacement variables into real and imaginary parts, which would mean applying the displacement BC on the real part only (and setting the imaginary part to 0 on that boundary)? Would that be equivalent?",
          "url": "https://github.com/idaholab/moose/discussions/28206",
          "updatedAt": "2024-07-24T18:03:15Z",
          "publishedAt": "2024-07-24T12:00:49Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Secondly, I wanted to know if it is possible to restart the aux variables instead of the regular variables.\n\nit is possible to do this, but you need to use either:\n\nexodus restart\na solutionUO and several solutionIC (for each auxvariable)\n\nI recommend to use Checkpoint restart + the solution UO route\n\nThe other idea I was thinking of is to also split the stretching displacement variables into real and imaginary parts,\n\nand solving the fully coupled problem? Both displacements and frequency domain at the same time?",
                  "url": "https://github.com/idaholab/moose/discussions/28206#discussioncomment-10138032",
                  "updatedAt": "2024-07-24T13:46:59Z",
                  "publishedAt": "2024-07-24T13:46:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "For the solutionUserObject route, the syntax is:\n[UserObjects]\n  [./soln]\n    type = SolutionUserObject\n    mesh = cubesource.e\n    system_variables = source_nodal\n  [../]\n[]\n\nIs the system_variables the name of the new variable you want to save it in, or the name of the variable from the previous simulation in the exodus file? Or are they supposed to be the same? If so then I might need to rename my displacement variables from the first simulation so I don't mix them up.\nAlso, the execute_on set to TIMESTEP_END means that it'll use the last (deformed) shape of the exodus, correct?\nThen just to confirm, when I set the solutionIC, it will only use it for the initial condition? I'm asking because in the frequency domain problem, disp_x (and disp_y) are aux variables calculated as sqrt(disp_x_real^2 + disp_x_imag^2). The real and imaginary displacement variables are the ones calculated from the kernel.\n\nThe other option I was thinking was to split the disp_x (and disp_y) in the first simulation to disp_x_real and disp_x_imag. Then, on the zero boundary I'd also set both to zero, and on the boundary with a prescribed displacement I'd set disp_x_real to the prescribed value and set disp_x_imag to zero, since that should be equivalent?\nThen, for the frequency domain problem that follows it, I would use\n\tuse_for_exodus_restart = true\nin the mesh block, and then use\n [disp_x_real]\n    order = SECOND\n    family = LAGRANGE\n    initial_from_file_var = disp_x_real\n    initial_from_file_timestep = LATEST\n []\n\nin my variables block (and same for the imaginary and y variables). I was wondering if this approach would be equivalent.",
                          "url": "https://github.com/idaholab/moose/discussions/28206#discussioncomment-10140731",
                          "updatedAt": "2024-07-24T17:22:00Z",
                          "publishedAt": "2024-07-24T17:20:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "system_variables in the UO is just the variables you want to load. So it's from the previous simulation.\nThe names do not have to match, the solutionIC / solutionAux take care of mapping\n\nAlso, the execute_on set to TIMESTEP_END means that it'll use the last (deformed) shape of the exodus, correct?\n\ndo you really need to execute the user object multiple times? I feel like you just need it for initialization?\nYour second option seems fine to me.\nI would recommend doing both and weeding out any potential error by comparing the two results",
                          "url": "https://github.com/idaholab/moose/discussions/28206#discussioncomment-10141045",
                          "updatedAt": "2024-07-24T17:58:57Z",
                          "publishedAt": "2024-07-24T17:58:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Yes you're right, what I meant to say was to set\ntimestep = LATEST\nin the UserObject. Thank you, I'll try them out!",
                          "url": "https://github.com/idaholab/moose/discussions/28206#discussioncomment-10141078",
                          "updatedAt": "2024-07-24T18:03:14Z",
                          "publishedAt": "2024-07-24T18:03:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to reduce integration points",
          "author": {
            "login": "MScKarl"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi!\nI am interested in investigating the impact of Gauss points in my simulation. To do this I need to change the number of integration points in a 2D simulation, with  QUAD4 elements. Is the code below the way to do it, and how do I know the number of Gauss points?\n[./Quadrature]\n    type = GAUSS_LOBATTO \n    order = FIFTH\n  [../]\n\nIf its not, is there an easy way to set the number of integration points in the MOOSE code?\nBest regards,\nKarl",
          "url": "https://github.com/idaholab/moose/discussions/28210",
          "updatedAt": "2024-07-24T18:01:25Z",
          "publishedAt": "2024-07-24T16:16:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou ll have to look at the quadrature definition in libmesh\nSetting the type and order is the way to do this in moose\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28210#discussioncomment-10140119",
                  "updatedAt": "2024-07-24T16:20:53Z",
                  "publishedAt": "2024-07-24T16:20:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "Hi @GiudGiud!\nThank you for your answer.\nWhere can I access this in my moose program? I've found this link:\nhttps://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1QMonomial.html\nBut I don't quite understand it. It looks like some sort of header file in C programming (which I understand MOOSE is written in)?\nIs there some instruction page with steps to follow or something? This to show where the correct header file is, and where to change?\n/Karl",
                          "url": "https://github.com/idaholab/moose/discussions/28210#discussioncomment-10140263",
                          "updatedAt": "2024-07-24T17:45:47Z",
                          "publishedAt": "2024-07-24T16:33:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes pick a quadrature from this page\nhttps://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1QBase.html\nthen look at the source code, in C++ or the header.\nThere is no instruction page afaik. You may find something in the libmesh theory documentation, I've never looked there\n\nand where to change?\n\nyou already know where to change in the input file, this is the block you were modifying in MOOSE",
                          "url": "https://github.com/idaholab/moose/discussions/28210#discussioncomment-10141056",
                          "updatedAt": "2024-07-24T18:00:59Z",
                          "publishedAt": "2024-07-24T18:00:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "otherwise there is this page that I wrote a year ago\nhttps://mooseframework.inl.gov/syntax/Executioner/Quadrature/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/28210#discussioncomment-10141061",
                          "updatedAt": "2024-07-24T18:01:25Z",
                          "publishedAt": "2024-07-24T18:01:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The result of a steady free thermal expansion is so weird...",
          "author": {
            "login": "Wang-Yihu"
          },
          "bodyText": "Let's consider a beam, with a d = 0.2 side length square cross section, and l = 10.0 axial length. Thermal expansion coefficient is \u03b1 = 2.0e-5. Stress free temperature and reference temperature is T_r = 300. Temperature is T = 500. All boundaries are free. There are no loads except thermal expansion. It's a very easy question...\n\nSo we have this input file\nd = 200.0e-3\nl = 10.0\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh]\n  [gmg]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 10\n    ny = 10\n    xmin = ${fparse -d/2}\n    xmax = ${fparse d/2}\n    ymin = ${fparse -d/2}\n    ymax = ${fparse d/2}\n  []\n  \n  [extrude1]\n    type = AdvancedExtruderGenerator\n    input = gmg\n    heights = ${fparse l}\n    num_layers = 100\n    direction = '0 0 1'\n    bottom_boundary = '99'\n    top_boundary = '66'\n  []\n[]\n\n[Materials]\n  [./elasticity_tensor_steel]\n    youngs_modulus = 210e9\n    poissons_ratio = 0.28\n    type = ComputeIsotropicElasticityTensor\n  [../]\n  [expansion_steel]\n    type = ComputeMeanThermalExpansionFunctionEigenstrain\n    thermal_expansion_function = 2e-5\n    thermal_expansion_function_reference_temperature = 300.0\n    stress_free_temperature = 300.0\n    temperature = temp_jiegou\n    eigenstrain_name = thermal\n  []\n  [./stress]\n    type = ComputeFiniteStrainElasticStress\n  [../]\n[]\n\n[AuxVariables]\n  [temp_jiegou]\n    family = LAGRANGE\n    order = FIRST\n  []\n[]\n\n[AuxKernels]\n  [changshu_wendu]\n    type = ConstantAux\n    variable = temp_jiegou\n    value = 500.0\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    eigenstrain_names = thermal\n    generate_output = 'vonmises_stress stress_zz'\n    strain = FINITE\n    temperature = temp_jiegou\n  []\n[]\n\n[BCs]\n[]\n\n\n[Executioner]\n  type = Steady\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n  nl_max_its = 50000\n[]\n\n[Postprocessors]\n  [max_x]\n    type = NodalMaxValue\n    variable = disp_x\n  []\n  [max_y]\n    type = NodalMaxValue\n    variable = disp_y\n  []\n  [max_z]\n    type = NodalMaxValue\n    variable = disp_z\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nHowever, the result is...\n\nThe result is so weird, right? The displacement from MOOSE is so huge...In my problem, \u0394T = T - T_r = 200. Thermal expansion strain \u03b5_th = \u03b1\u0394T = 0.004. It seems that max disp is only \u03b5_th*l = 0.04...The magnitude disp result from MOOSE is e+01, e+02...\nMaybe in MOOSE steady solid mechanics calculation, there must be at least a BC to prevent the rigid body movement...So at least I need to set a disp = 0 in the centroid node of the model??\nLooking forward to your reply...",
          "url": "https://github.com/idaholab/moose/discussions/28205",
          "updatedAt": "2024-07-24T13:55:21Z",
          "publishedAt": "2024-07-24T05:48:37Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere is nothing holding the beam. So it is just moving around, in the nullspace of all the allowed solutions (moving the beam by 1m to the left does not make the residual increase at all!)\nYou were on the right track with preventing rigid body movement.\nyou have to add a bunch of dirichlet BCs (in x y z) to kill translational and rotational modes which you do not care about\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28205#discussioncomment-10138015",
                  "updatedAt": "2024-07-24T13:45:17Z",
                  "publishedAt": "2024-07-24T13:45:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Exporting StateVariables in Exodus Output File",
          "author": {
            "login": "shrituntunroy"
          },
          "bodyText": "Hi Moose Team,\nI am a new MOOSE user and currently learning to use the software. I have a question regarding the export of state variables in the Exodus output file.\nI am aware of the technique using the AuxKernel system in MOOSE, which involves defining an AuxVariable and exporting this variable with the following syntax:\n  [./Ep_eff]\n    type = StateVariable\n    variable = Ep_eff\n    sdv_id = 47\n    execute_on = timestep_end\n  [../]\nHowever, my problem involves around 100 state variables. Defining 100 AuxVariables and 100 AuxKernels would be very cumbersome. Is there any way to export all the state variables using a more concise syntax in the Exodus output file?\nThank you for considering my query.",
          "url": "https://github.com/idaholab/moose/discussions/28199",
          "updatedAt": "2024-07-24T09:06:47Z",
          "publishedAt": "2024-07-23T15:16:36Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can create an action with a reduced syntax that programmatically performs this operation for you.\nhttps://mooseframework.inl.gov/source/actions/Action.html\nIf you don't want to modify the code, then simply create this length input file with 100x auxkernels and separate it from the main input input.\nin the main input file you can do\n!include other_input.i\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28199#discussioncomment-10128655",
                  "updatedAt": "2024-07-23T16:07:45Z",
                  "publishedAt": "2024-07-23T16:07:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "shrituntunroy"
                  },
                  "bodyText": "Thankyou Guillaume for your help",
                  "url": "https://github.com/idaholab/moose/discussions/28199#discussioncomment-10135386",
                  "updatedAt": "2024-07-24T09:06:48Z",
                  "publishedAt": "2024-07-24T09:06:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "SplitCHCRes",
          "author": {
            "login": "rnpratoori"
          },
          "bodyText": "Hello team,\nI am looking at the source file of the kernel SplitCHCRes and want to know what are the equations based on which it was modeled. I could not find any documentation for it. Can anyone give me these equations?",
          "url": "https://github.com/idaholab/moose/discussions/28197",
          "updatedAt": "2024-07-23T20:13:51Z",
          "publishedAt": "2024-07-23T14:17:28Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sourabhkadambi"
                  },
                  "bodyText": "Have a look at this documentation page: https://mooseframework.inl.gov/modules/phase_field/Phase_Field_Equations.html",
                  "url": "https://github.com/idaholab/moose/discussions/28197#discussioncomment-10130311",
                  "updatedAt": "2024-07-23T19:26:51Z",
                  "publishedAt": "2024-07-23T19:26:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rnpratoori"
                          },
                          "bodyText": "@sourabhkadambi I did have a look at it, but it only shows for SplitCHWRes and not for SplitCHCRes.",
                          "url": "https://github.com/idaholab/moose/discussions/28197#discussioncomment-10130624",
                          "updatedAt": "2024-07-23T20:13:51Z",
                          "publishedAt": "2024-07-23T20:13:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cannot get visualizer installed onto school HPC",
          "author": {
            "login": "jackeggemeyer"
          },
          "bodyText": "",
          "url": "https://github.com/idaholab/moose/discussions/28198",
          "updatedAt": "2024-07-23T17:02:03Z",
          "publishedAt": "2024-07-23T14:35:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "List of RankTwoTensors for AuxKernal Calculations",
          "author": {
            "login": "shrituntunroy"
          },
          "bodyText": "Hi MOOSE Team,\nI am a new MOOSE user and am currently learning to use MOOSE.\nI have a question regarding the RankTwoAux auxkernel calculations. According to the documentation (Ref: https://mooseframework.inl.gov/source/auxkernels/RankTwoAux.html), the valid symbols for Rank Two Aux are given below:\n[./stress_xy]\n  type = RankTwoAux\n  rank_two_tensor = stress\n  variable = stress_xy\n  index_i = 0\n  index_j = 1\n[../]\nMy question is: where can I find the valid names for different rank two tensors, such as plastic strain and total strain, for these auxkernel calculations? Is there a link or resource that provides a full list?\nThank you for your help.",
          "url": "https://github.com/idaholab/moose/discussions/28194",
          "updatedAt": "2024-07-23T13:44:19Z",
          "publishedAt": "2024-07-23T12:23:19Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUse Debug/show_material_props=true to show all material properties, and then you should know which ones are tensors\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28194#discussioncomment-10126041",
                  "updatedAt": "2024-07-23T12:27:20Z",
                  "publishedAt": "2024-07-23T12:27:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The following error occurred in the Problem 'MOOSE Problem' of type FEProblem.",
          "author": {
            "login": "engrmessi"
          },
          "bodyText": "my scripts was running very well untill i updated my moose. I encounter this challange. Can anyone help me fix it\n*** ERROR ***\nThe following error occurred in the Problem 'MOOSE Problem' of type FEProblem.\nMaterial property 'acc_slip', requested by 'accslip' is not defined on block 0\nMaterial property 'lage', requested by 'e_xx' is not defined on block 0\nMaterial property 'fp', requested by 'fp_xx' is not defined on block 0\nMaterial property 'gss', requested by 'gss1' is not defined on block 0\n\ufffd[39m\n\ufffd[31m\n*** ERROR ***\nThe following error occurred in the Problem 'MOOSE Problem' of type FEProblem.\nMaterial property 'acc_slip', requested by 'accslip' is not defined on block 0\nMaterial property 'lage', requested by 'e_xx' is not defined on block 0\nMaterial property 'fp', requested by 'fp_xx' is not defined on block 0\nMaterial property 'gss', requested by 'gss1' is not defined on block 0\n\ufffd[39m\n** here is my script which was working before the update\n[GlobalParams]\ndisplacements = 'disp_x disp_y'\n[]\n[Mesh]\ntype = GeneratedMesh\ndim = 2\nnx = 40\nny = 20\nxmin = 0\nxmax = 20\nymin = 0\nymax = 10\n[]\n[Variables]\n[./eta1]\norder = FIRST\nfamily = LAGRANGE\n[../]\n[./disp_x]\nblock = 0\n[../]\n[./disp_y]\nblock = 0\n[../]\n[]\n[AuxVariables]\n[./bounds_dummy]\norder = FIRST\nfamily = LAGRANGE\n[../]\n[./accslip]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./vonmises]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./stress_xx]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./fp_xx]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./e_xx]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./gss1]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[]\n[Bounds]\n[./eta_upper_bound]\ntype = ConstantBoundsAux\nvariable = bounds_dummy\nbounded_variable = eta1\nbound_type = upper\nbound_value = 1\n[../]\n[./eta_lower_bound]\ntype = ConstantBoundsAux\nvariable = bounds_dummy\nbounded_variable = eta1\nbound_type = lower\nbound_value = 0\n[../]\n[]\n[ICs]\n[./eta1]\nvariable = eta1\ntype = SmoothCircleIC\nx1 = 10\ny1 = 10\nint_width = 0.05\nradius = 0.5\ninvalue = 0\noutvalue = 1\n#int_width = 1\n[../]\n[]\n[Functions]\n[./tdisp]\ntype = ParsedFunction\nexpression = 0.005*t\n[../]\n[]\n[Modules/TensorMechanics/Master/all]\nstrain = FINITE\nadd_variables = true\nplanar_formulation = PLANE_STRAIN\ngenerate_output = stress_zz\nstrain_base_name = uncracked\n[]\n[Kernels]\nAllen-Cahn Equation for eta1\n[./detadt_eta1]\ntype = TimeDerivative\nvariable = eta1\n[../]\n[./ACinterface_eta1]\ntype = ACInterface\nvariable = eta1\nmob_name = L_inf\nkappa_name = kappa\n[../]\n[./ACBulkF_eta1]\ntype = AllenCahn\nvariable  = eta1\nf_name = g1\nmob_name = L_inf\nargs = T\n[../]\n[./AllenCahn1]\ntype = AllenCahn\nvariable = eta1\nmob_name = L_pot\nf_name = f1\nargs = T\n[../]\n[]\n[AuxKernels]\n[./accslip]\ntype = MaterialRealAux\nvariable = accslip\nproperty = acc_slip\nexecute_on = timestep_end\nblock = 0\n[../]\n[./vonmises]\ntype = RankTwoScalarAux\nrank_two_tensor = stress\nvariable = vonmises\nscalar_type = VonMisesStress\nexecute_on = timestep_end\nblock = 0\n[../]\n[./stress_xx]\ntype = RankTwoAux\nrank_two_tensor = stress\nvariable = stress_xx\nindex_j = 0\nindex_i = 0\nexecute_on = timestep_end\nblock = 0\n[../]\n[./fp_xx]\ntype = RankTwoAux\nvariable = fp_xx\nrank_two_tensor = fp\nindex_j = 0\nindex_i = 0\nexecute_on = timestep_end\nblock = 0\n[../]\n[./e_xx]\ntype = RankTwoAux\nvariable = e_xx\nrank_two_tensor = lage\nindex_j = 0\nindex_i = 0\nexecute_on = timestep_end\nblock = 0\n[../]\n[./gss1]\ntype = MaterialStdVectorAux\nvariable = gss1\nproperty = gss\nindex = 0\nexecute_on = timestep_end\nblock = 0\n[../]\n[]\n[BCs]\n[./eta_bottom]\ntype =  DirichletBC\nvariable = 'eta1'\nboundary = 'bottom'\nvalue = 1.0\n[../]\n[./eta_lr]\ntype =  NeumannBC\nvariable = 'eta1'\nboundary = 'top left right'\nvalue = 0.0\n[../]\n[./Pressure]\n[./stressfree_boundary]\n#Applies the pressure\nboundary = top\nfactor = 0.0\ndisp_x = disp_x\ndisp_y = disp_y\n[../]\n\n[../]\n[./dispy]\ntype = DirichletBC\nvariable = disp_y\nboundary = bottom\nvalue = 0\n[../]\n[./dispx]\ntype = DirichletBC\nvariable = disp_x\nboundary = left\nvalue = 0\n[../]\n[./tdisp]\ntype = FunctionDirichletBC\nvariable = disp_x\nboundary = right\nfunction = tdisp\n[../]\n[]\n[Materials]\n[./crysp]\ntype = FiniteStrainCPSlipRateRes\nblock = 0\nslip_sys_file_name = input_slip_sys.txt\nnss = 12\nnum_slip_sys_flowrate_props = 2 #Number of properties in a slip system\nflowprops = '1 4 0.5 0.05 5 8 0.5 0.05 9 12 0.5 0.05'\nhprops = '1.0 215 78.6 200.0 1.75'\ngprops = '1 4 78.6 5 8 78.6 9 12 78.6'\ntan_mod_type = exact\nslip_incr_tol = 1\nmaximum_substep_iteration = 12\n\nuse_line_search = true\nline_search_method = 'BISECTION'\nrtol = 1e-7\nabs_tol = 1e-8\nbase_name = uncracked\n\n[../]\n[./elasticity_tensor]\ntype = ComputeElasticityTensorCP\nblock = 0\nC_ijkl = '2.04e5 1.37e5 1.37e5 2.044e5 1.37e5 2.04e5 1.26e5 1.26e5 1.26e5'\nfill_method = symmetric9\nread_prop_user_object = prop_read\neuler_angle_1 = 0\neuler_angle_2 = 0\neuler_angle_3 = 0\noutput_properties = 'Euler_angles'\noutputs = exodus\nbase_name = uncracked\n\n[../]\n[./cracked_stress]\ntype = ComputeCrackedStressmod\nc = eta1\nproperty_name = E_el\nuse_current_history_variable = false\nuncracked_base_name = uncracked\nfinite_strain_model = false\n\n[../]\n[./degradation]\ntype = DerivativeParsedMaterial\nproperty_name = degradation\ncoupled_variables = 'eta1'\nfunction = '1'\nexpression = 'eta1^3*(6*eta1^2-15*eta1+10)*(1.0 - c) + c'\nconstant_names       = 'c'\nconstant_expressions = '1e-6'\nderivative_order = 2\n\n[../]\n[./f1]\ntype = DerivativeParsedMaterial\nproperty_name = f1\ncoupled_variables = 'eta1'\nmaterial_property_names = 'h0'\ndiff_factor:=if(c>c_b,exp(alpha*log(c/c_b)),1);\nconstant_names = 'overpotential  R     z     alpha beta F_const T '\nconstant_expressions = '0.1    8.31    2.19  0.65  0.35  96485.33 298'\nexpression = 'h1:=eta1^3*(6*eta1^2-15*eta1+10);\nh1*(exp(z*alpha*F_const*overpotential/(R*T))-exp(-z*beta*F_const*overpotential/(R*T)))'\n\noutputs = exodus\nderivative_order = 1\n\n[../]\n[./h1]\ntype = SwitchingFunctionMaterial\nh_order = HIGH\neta = 'eta1'\nfunction_name = h1\n[../]\n[./g1]\ntype = BarrierFunctionMaterial\ng_order = SIMPLE\neta = 'eta1'\nfunction_name = g1\n[../]\n[./constants]\ntype = GenericConstantMaterial\nprop_names  = 'kappa     L_inf0    L_pot0      W'\nprop_values = '0.05      0.0009   0.00415      1.0'  #0.99e-4  4.15e-4\n[../]\n[./reaction_mob]\ntype = ParsedMaterial\nproperty_name = L_inf\ncoupled_variables = 'accslip'\nmaterial_property_names = 'L_inf0'\nfunction = 'L_inf0'\nexpression = 'L_inf0*(1+accslip/0.001)'\n\n[../]\n[./reaction_mob2]\ntype = ParsedMaterial\nproperty_name = L_pot\ncoupled_variables = 'accslip'\nmaterial_property_names = 'L_pot0'\nfunction = 'L_pot0'\nexpression = 'L_pot0*(1+accslip/0.001)'\n\n[../]\n[]\n[Postprocessors]\n[./vonmises]\ntype = ElementAverageValue\nvariable = vonmises\nblock = 'ANY_BLOCK_ID 0'\n[../]\n[./stress_xx]\ntype = ElementAverageValue\nvariable = stress_xx\nblock = 'ANY_BLOCK_ID 0'\n[../]\n[./fp_xx]\ntype = ElementAverageValue\nvariable = fp_xx\nblock = 'ANY_BLOCK_ID 0'\n[../]\n[./e_xx]\ntype = ElementAverageValue\nvariable = e_xx\nblock = 'ANY_BLOCK_ID 0'\n[../]\n[./gss1]\ntype = ElementAverageValue\nvariable = gss1\nblock = 'ANY_BLOCK_ID 0'\n[../]\n[]\n[Preconditioning]\n[./smp]\ntype = SMP\nfull = true\n[../]\n[]\n[Executioner]\ntype = Transient\n#Preconditioned JFNK (default)\nsolve_type = 'PJFNK'\npetsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\npetsc_options_value = 'lu            superlu_dist            vinewtonrsls'\nautomatic_scaling = true\nl_max_its = 20\nnl_max_its = 10\nnl_abs_tol = 1e-9\npetsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -ksp_type -ksp_gmres_restart'\npetsc_options_value = ' asm      1              lu            gmres     200'\ndt = 0.0025\ndtmax = 0.01\n[./TimeStepper]\ntype = IterationAdaptiveDT\ndt = 0.0025 # Initial time step.  In this simulation it changes.\noptimal_iterations = 8 # Time step will adapt to maintain this number of nonlinear# iterations\n[../]\n[./Adaptivity]\ninitial_adaptivity = 2 # Number of times mesh is adapted to initial condition\nrefine_fraction = 0.6 # Fraction of high error that will be refined\ncoarsen_fraction = 0.2 # Fraction of low error that will coarsened\nmax_h_level = 2 # Max number of refinements used, starting from initial mesh (befo# uniform refinement)\n[../]\nend_time = 5\n[]\n[VectorPostprocessors]\n[eta1]\ntype = LineValueSampler\nstart_point = '10 0 0'\nend_point = '10 10 0'\nnum_points = 200\nsort_by = y\nvariable = eta1\n[]\n[]\n[Outputs]\nexodus = true\ninterval = 2\n[./console]\ntype = Console\ninterval = 2\n[../]\n[./csv]\ntype = CSV\ninterval = 2\n[../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/27266",
          "updatedAt": "2024-07-23T13:12:38Z",
          "publishedAt": "2024-04-02T20:01:52Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nplease use Debug/show_material_props to see a summary of producers and consumers of material properties and make sure they match\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27266#discussioncomment-8989810",
                  "updatedAt": "2024-04-02T21:57:05Z",
                  "publishedAt": "2024-04-02T21:57:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "engrmessi"
                  },
                  "bodyText": "sorry, i did not understand what you mean. where should implement this \" Debug/show_material_props\"? in my input script or bash file?\nBest!",
                  "url": "https://github.com/idaholab/moose/discussions/27266#discussioncomment-8989862",
                  "updatedAt": "2024-04-02T22:01:24Z",
                  "publishedAt": "2024-04-02T22:01:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The Debug block is a block you can add to the input file\nsee the SetupDebugAction documentation for more info on the parameters",
                          "url": "https://github.com/idaholab/moose/discussions/27266#discussioncomment-8989901",
                          "updatedAt": "2024-04-02T22:05:31Z",
                          "publishedAt": "2024-04-02T22:05:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}