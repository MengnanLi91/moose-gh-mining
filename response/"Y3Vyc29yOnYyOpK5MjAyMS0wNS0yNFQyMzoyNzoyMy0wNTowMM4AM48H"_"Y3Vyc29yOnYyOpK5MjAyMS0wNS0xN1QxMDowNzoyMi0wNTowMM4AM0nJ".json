{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNS0xN1QxMDowNzoyMi0wNTowMM4AM0nJ"
    },
    "edges": [
      {
        "node": {
          "title": "Help with autocomplete-moose",
          "author": {
            "login": "marinasessim"
          },
          "bodyText": "Hello,\nThis is related to the autocomplete-moose atom package. First, I do not think there is an issue with the package, it just does not work for my application. It works properly inside the moose directory, for instance, within the phase-field module. But it does not work for input files in my moose-based app.\nI am wondering if there is anything I could have done to a makefile or something that would prevent autocomplete-moose from working. It does not return any errors, it just does not autocomplete. The last version that worked for me was v0.23.3. I got away using that one until now, but I just performed some updates and unfortunately, that version no longer works (neither does the newest one). I am just trying to get some advice from the community because I do not know what else to try.\nCurrent macOS BigSur 11.3.1; CommandLine Tools for Xcode 12.4; Atom v1.56.0.\nMy application runs normally otherwise. I have tried generating a syntax.txt, pointing the opt directory, everything that I could think of.\nI appreciate any help! Thanks!",
          "url": "https://github.com/idaholab/moose/discussions/17778",
          "updatedAt": "2022-06-23T15:15:43Z",
          "publishedAt": "2021-05-08T21:36:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@dschwen Can you help?",
                  "url": "https://github.com/idaholab/moose/discussions/17778#discussioncomment-729553",
                  "updatedAt": "2022-06-23T15:15:56Z",
                  "publishedAt": "2021-05-12T14:40:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Before @dschwen gets to this, can you try yourApp-opt --json and tell us the output? Meanwhile, you should create an issue at https://github.com/dschwen/autocomplete-moose.",
                  "url": "https://github.com/idaholab/moose/discussions/17778#discussioncomment-733727",
                  "updatedAt": "2022-06-23T15:16:11Z",
                  "publishedAt": "2021-05-13T13:07:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "marinasessim"
                          },
                          "bodyText": "Hello, thanks for your attention. I am attaching the --json output.\nsyntax.txt",
                          "url": "https://github.com/idaholab/moose/discussions/17778#discussioncomment-738781",
                          "updatedAt": "2022-06-23T15:16:07Z",
                          "publishedAt": "2021-05-14T14:40:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "marinasessim"
                  },
                  "bodyText": "Hello, just sharing the resolution to this problem. The input file was in the old format. The file was updated to the moose hit format using the moose-hit-format package, and now autocomplete-moose works well. Thanks!!",
                  "url": "https://github.com/idaholab/moose/discussions/17778#discussioncomment-769969",
                  "updatedAt": "2022-06-23T15:16:15Z",
                  "publishedAt": "2021-05-21T20:05:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "3D interpolation for unordered points - performance",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nI am facing some performance issues while trying to implement a function to interpolate a scalar value from 3D unordered sampling points to set up an initial condition for a primary variable. The basic structure is simple.\nI am reading upon the constructor call of the function the sampling points and store their values in vectors (I found they are faster than unordered maps). Based on that I do perform the interpolation at the call of the value() function.  This is where my pain starts. Given that I have no topological ordering in the sample and target data, I have to rely on a global interpolation - currently this is done as a global search weighted by the distance of the sampling points to the targeted one restricted over a searching sphere of a given radius and provides (really!) terrible scalability. This comes with no surprise (looping through global search is anything but clever), but the performance is way lower than I could foresee. As an example, running it over 2 millions of dofs and for a similar size of the sampling points, the initialization phase runs for more than 3 hours on a cluster. I have been looking at the framework but it does seem that all interpolation routines available are either based on  2D cases, or required some degree of ordering for the sampling points (though I might be wrong here).\nBefore trying to port a 3D NN interpolation algorithm I have been using in an external application to the framework (which would require extensive coding), I was wondering if anyone could point me to a possible (easier and faster) solution.\nAs always, any help is highly appreciated.\nThanks, Mauro",
          "url": "https://github.com/idaholab/moose/discussions/17878",
          "updatedAt": "2022-08-09T15:44:50Z",
          "publishedAt": "2021-05-18T22:25:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ABallisat"
                  },
                  "bodyText": "Take a look at a k-d tree for some very fast nearest neighbour lookup. I have been using the SciPy implementation to do high dimensional interpolation with millions of points using inverse distance weighted interpolation in Python and it is very quick to do on a standard laptop. You can probably dig into the source code of that as an example of how to implement it.",
                  "url": "https://github.com/idaholab/moose/discussions/17878#discussioncomment-758153",
                  "updatedAt": "2022-08-09T15:46:58Z",
                  "publishedAt": "2021-05-19T12:42:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@ABallisat, thanks for the hint. I see that there is some implementation of kd-tree and neighbour search in libmesh. Will give it a try and see whether it could help. Again, thanks",
                          "url": "https://github.com/idaholab/moose/discussions/17878#discussioncomment-760785",
                          "updatedAt": "2022-08-09T15:47:00Z",
                          "publishedAt": "2021-05-19T22:11:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lynnmunday"
                  },
                  "bodyText": "Could you try something like what @hugary1995 suggested in this discussion: #17806 (comment)\nwe're going to try to use this method to do something similar to what you're doing.  If you had your point value data in csv format, you could read it in with a csv value postprocessor and then interpolate it to the nodes with the reaction kernel.\nI would be really interested in finding out if this would work for you because we've only tried this with small problems.  If this is really slow we'll need to find ways to speed it up.",
                  "url": "https://github.com/idaholab/moose/discussions/17878#discussioncomment-760744",
                  "updatedAt": "2022-08-09T15:47:01Z",
                  "publishedAt": "2021-05-19T21:52:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@lynnmunday, not sure I did understand all from the discussion you posted (lost myself in trying to relate an IC action to a Dirac Kernel action, and how to organize the reading and passing of information from a post processor that reads an external file to initialize a variable - late hours here in Berlin), but will give it some more thoughts in the next days. Thanks for your help",
                          "url": "https://github.com/idaholab/moose/discussions/17878#discussioncomment-760804",
                          "updatedAt": "2022-08-09T15:47:01Z",
                          "publishedAt": "2021-05-19T22:18:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "You're right, the dirac kernel would not work for IC's.  I got that all wrong.",
                          "url": "https://github.com/idaholab/moose/discussions/17878#discussioncomment-760876",
                          "updatedAt": "2022-08-09T15:47:01Z",
                          "publishedAt": "2021-05-19T22:50:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "Dear all,\nI would like to thanks again for your hints. I implemented an interpolation based on a kdtree neighbour search and for what I tested so far it works nice - 2 millions points runs over few seconds on my laptop. I will do some more tests (by increasing the sampling points dimensions) to see whether all works fine (not sure if there is a limit size for initializing the kdtree), but I would now consider this post as closed.",
                  "url": "https://github.com/idaholab/moose/discussions/17878#discussioncomment-768424",
                  "updatedAt": "2022-08-09T15:47:01Z",
                  "publishedAt": "2021-05-21T14:06:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "glad it worked, could you report back on your findings so we know if it does scale or not and what the limits are please. Thanks in advance!",
                          "url": "https://github.com/idaholab/moose/discussions/17878#discussioncomment-768471",
                          "updatedAt": "2022-08-09T15:47:01Z",
                          "publishedAt": "2021-05-21T14:13:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Just checked on a real case examples. sampling points size is something more than 2 millions points, and target points size almost the same. It runs within few second. Attached a picture of the final results - the (close not to be seen points are the sampling points on top of the interpolated values. This said, I do think that the kd-tree has no memory limits for realistic applications...",
                          "url": "https://github.com/idaholab/moose/discussions/17878#discussioncomment-768585",
                          "updatedAt": "2022-08-09T15:47:01Z",
                          "publishedAt": "2021-05-21T14:30:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "CAD model import",
          "author": {
            "login": "Bayarbadrakh"
          },
          "bodyText": "Did anyone tried to import the mesh generated from the CAD software (Solidworks etc.) to MOOSE? Could share your experience on that?",
          "url": "https://github.com/idaholab/moose/discussions/17884",
          "updatedAt": "2022-06-18T18:50:14Z",
          "publishedAt": "2021-05-19T20:25:22Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "I know we've had a few on the team import from Solidworks in the past. Maybe one or two will chime in. I've imported into Cubit myself and worked from CAD. What's nice about starting with CAD is that as you mesh you don't lose the underlying geometry (so if you change the resolution of your mesh, you'll continue to better capture curvature from your original CAD geometry.\nThe one issue that many run into is that you may need to de-feature your CAD so that you can more easily mesh it. Very detailed geometry can be problematic for meshers. Cubit is one of the best packages available if you have access to it. I personally have no experience with other packages.",
                  "url": "https://github.com/idaholab/moose/discussions/17884#discussioncomment-763631",
                  "updatedAt": "2022-06-18T18:50:14Z",
                  "publishedAt": "2021-05-20T14:24:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "+1 for Cubit - https://www.coreform.com/ - if you're doing academic things its free too. Nothing else I've tried really compares in terms of fixing and meshing. If your CAD is complex, you may want to consider ANSYS SpaceClaim which is literally unparalleled in its defeaturing and CAD repair. If you can get your geometry into a BREP form, then GMSH can pretty reliably produce meshes. However, if you've got complex CAD, then Cubit would be my go to too.",
                          "url": "https://github.com/idaholab/moose/discussions/17884#discussioncomment-766813",
                          "updatedAt": "2022-08-29T23:40:03Z",
                          "publishedAt": "2021-05-21T06:41:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Linear solver stopped? or Unfinised]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Dear moose users,\nI am currently trying to simulate my numerical model and find a reason for unfinished calculations.\nMy problem is like the below picture.\nIn a certain time step, it seems like linear residual calculation does not end.\nIt just stuck in there like the below. (Timestep 2200...)\nI am trying to figure the reason for over two weeks but I can't find any clue.\nSo, if you had a similar problem or solution please let me know.\nBest regards,\nQ",
          "url": "https://github.com/idaholab/moose/discussions/17883",
          "updatedAt": "2023-06-13T10:00:55Z",
          "publishedAt": "2021-05-19T15:27:40Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAt 10^-17 your solve is very much converged for that timestep. You should set nl_rel_tol and nl_abs_tol so that the code does not try to converge that further. Numerical floating point precision is not that far.\nCould you please print the linear solve history, see SolutionHistory.\nThe default is max 10,000 linear iterations, which can take a while if convergence is not reached.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17883#discussioncomment-760379",
                  "updatedAt": "2023-06-13T10:01:04Z",
                  "publishedAt": "2021-05-19T20:09:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "coskrrb2002"
                          },
                          "bodyText": "Dear GiudGiud,\nThank you for your comment.\nThis morning, I finally found the error and fixed it!\nThe error was originated from my material kernel which takes a lot of time to calculate...\nBut your comment will be helped me a lot!\nSincerely,\nQ",
                          "url": "https://github.com/idaholab/moose/discussions/17883#discussioncomment-761317",
                          "updatedAt": "2023-06-13T10:01:10Z",
                          "publishedAt": "2021-05-20T03:22:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "DGEMM error when turning on adaptivity",
          "author": {
            "login": "souzanha"
          },
          "bodyText": "Hi!\nI have a code that converges and runs quite well using the phase-field module. However, when I turn on adaptivity I get an error at the 3rd timestep that I'm not sure how to deal with:\n** On entry to DGEMM parameter number  8 had an illegal value\nConda and moose is updated.\nThis is my block:\n  type = Transient\n  scheme = 'BDF2'\n\n  solve_type = 'NEWTON'\n\n  petsc_options_iname = '-pc_type -sub_pc_type'\n  petsc_options_value = 'asm       ilu'\n\n  l_tol = 1.0e-4\n  nl_rel_tol = 1.0e-10\n  nl_abs_tol = 1.0e-10\n\n  dt = 1e-3\n  end_time = 1\n\n  [./Adaptivity]\n   interval = 2\n   refine_fraction = 0.2\n   coarsen_fraction = 0.3\n   max_h_level = 4\n  [../]\n\n[]\n\nAny suggestions would be helpful!\nThanks,\nSouzan",
          "url": "https://github.com/idaholab/moose/discussions/17432",
          "updatedAt": "2022-10-24T16:31:04Z",
          "publishedAt": "2021-03-26T10:33:23Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "souzanha"
                  },
                  "bodyText": "So when setting  refine_fraction = 1.0 the simulation is able to run.\nBut it refines the whole mesh in the system, and does not coarsen the areas of low error.\nThis of course makes everything unnecessary slow. Any ideas for why I get this type of error and how to go around it?",
                  "url": "https://github.com/idaholab/moose/discussions/17432#discussioncomment-590769",
                  "updatedAt": "2022-10-24T16:31:04Z",
                  "publishedAt": "2021-04-09T16:52:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AngeloCass"
                          },
                          "bodyText": "Did you ever figure out a solution to this issue? I appear to be having the same problem in my simulations. When I disable adaptivity, the problem goes away. I am hoping to not have to do that, so if you figured out a way to resolve the error and keep adaptivity, please let me know! Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/17432#discussioncomment-668817",
                          "updatedAt": "2022-10-24T16:31:04Z",
                          "publishedAt": "2021-04-28T11:29:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Very interesting, can either one of you push up a PR with a test case for us to take a look at?",
                          "url": "https://github.com/idaholab/moose/discussions/17432#discussioncomment-670205",
                          "updatedAt": "2022-10-24T16:31:04Z",
                          "publishedAt": "2021-04-28T14:14:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "I have not been able to solve the issue sadly. It does not matter how fine the initial mesh, I always get this error. So what I do now is to disable adaptivity completely, which is quite inefficient.\nI have used adaptivity with the Allen Cahn equation before, when I use an order parameter and the adaptivity runs well with no problems. The interface mesh gets finer, and the inner phases get coarser which is exactly as expected.\nAt the moment, I'm only using Cahn-Hilliard. The concentration variable is the one that changes in the system. I will try to create a simplified and stripped down version of my Cahn-Hilliard model and post it here.\nHere it is!\nhttps://github.com/souzanha/cahn_hilliard_test",
                          "url": "https://github.com/idaholab/moose/discussions/17432#discussioncomment-671158",
                          "updatedAt": "2022-10-24T16:31:04Z",
                          "publishedAt": "2021-04-28T17:11:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "souzanha"
                  },
                  "bodyText": "This seems now to be solved!",
                  "url": "https://github.com/idaholab/moose/discussions/17432#discussioncomment-758526",
                  "updatedAt": "2022-10-24T16:31:05Z",
                  "publishedAt": "2021-05-19T14:00:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AngeloCass"
                          },
                          "bodyText": "I just saw some discussion posts saying it has been solved as well!",
                          "url": "https://github.com/idaholab/moose/discussions/17432#discussioncomment-759123",
                          "updatedAt": "2022-10-24T16:31:08Z",
                          "publishedAt": "2021-05-19T15:37:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error after convergence of first transient step",
          "author": {
            "login": "AngeloCass"
          },
          "bodyText": "Hi,\nI am currently working with a graduate student who is using MOOSE to build and run some model simulations. He is currently unavailable to answer questions about an error that I am getting, and I have a limited knowledge on the framework. The error occurs once the first transient step converges and the second step begins.\nThe error message (last 2 lines) with some surrounding terminal output is as follows:\n    120 Nonlinear |R| = 1.029252e-06\n          0 Linear |R| = 1.029252e-06\n          1 Linear |R| = 3.706443e-09\n          2 Linear |R| = 1.795191e-11\n          3 Linear |R| = 4.848944e-14\n      Linear solve converged due to CONVERGED_RTOL iterations 3\n    121 Nonlinear |R| = 8.804651e-08\n    Nonlinear solve converged due to CONVERGED_FNORM_ABS iterations 121\n     Solve Converged!\n    \n    Time Step 2, time = 0.2, dt = 0.1\n     0 Nonlinear |R| = 3.808426e-02\n     ** On entry to DGEMM parameter number  8 had an illegal value\n     ** On entry to DGEMM parameter number  8 had an illegal value\n\nIf anyone knows why this may be happening, it would be a great help to me.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/17686",
          "updatedAt": "2021-05-19T15:35:38Z",
          "publishedAt": "2021-04-27T12:30:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@fdkong Can you help with this? My googling indicates that it might be coming from BLAS.",
                  "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-664797",
                  "updatedAt": "2021-04-27T14:55:02Z",
                  "publishedAt": "2021-04-27T14:54:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AngeloCass"
                          },
                          "bodyText": "I did some further testing and it appears that this issue is related to adaptivity. When disabling adaptivity in the input file, the simulation runs completely. Since it is desired to use the adaptivity function, I am hoping to solve this issue without completely disabling adaptivity.",
                          "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-668805",
                          "updatedAt": "2021-04-28T11:26:38Z",
                          "publishedAt": "2021-04-28T11:26:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "It might be related to a direct solver you are using. Are you using super_dist? What does the executioner block look like?",
                  "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-670763",
                  "updatedAt": "2021-04-28T15:49:03Z",
                  "publishedAt": "2021-04-28T15:48:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AngeloCass"
                          },
                          "bodyText": "Here's the executioner block.\nExecutionerBlock.txt",
                          "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-689706",
                          "updatedAt": "2021-05-03T17:58:04Z",
                          "publishedAt": "2021-05-03T17:58:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "It looks normal to me.",
                          "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-690018",
                          "updatedAt": "2021-05-03T19:20:57Z",
                          "publishedAt": "2021-05-03T19:20:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "@hugary1995 @lindsayad\nHere is a similar case. Did you guys dig into the global AD indexing things?",
                  "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-690017",
                  "updatedAt": "2021-05-03T19:20:57Z",
                  "publishedAt": "2021-05-03T19:20:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "No @hugary1995 suggested he might be able to make a MOOSE input at which point I could dig into it",
                          "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-690822",
                          "updatedAt": "2021-05-03T23:59:17Z",
                          "publishedAt": "2021-05-03T23:59:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I just need an input file I can run to reproduce",
                          "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-690824",
                          "updatedAt": "2021-05-03T23:59:36Z",
                          "publishedAt": "2021-05-03T23:59:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Sorry I got distracted by other stuff. I am working on this right now.",
                          "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-700801",
                          "updatedAt": "2021-05-05T18:40:32Z",
                          "publishedAt": "2021-05-05T18:40:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I created the issue #17755\n@AngeloCass See the issue above. I have a hunch that your error was due to the same issue. If you could also simplify your input file with MOOSE-only objects and create an issue, it might help @lindsayad fixing the bug.",
                          "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-701144",
                          "updatedAt": "2021-05-05T19:46:55Z",
                          "publishedAt": "2021-05-05T19:46:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "@lindsayad has fixed the issue. If you grab the newest version of moose, your issue should be fixed.",
                  "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-733757",
                  "updatedAt": "2021-05-13T13:16:27Z",
                  "publishedAt": "2021-05-13T13:16:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AngeloCass"
                          },
                          "bodyText": "Thank you very much! I'll pull down the newest version.",
                          "url": "https://github.com/idaholab/moose/discussions/17686#discussioncomment-759115",
                          "updatedAt": "2021-05-19T15:35:13Z",
                          "publishedAt": "2021-05-19T15:35:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to take temperature into consideration in ComputeCrystalPlasticityStress and study the effect of temperature on stress-strain curve",
          "author": {
            "login": "xchengood"
          },
          "bodyText": "Hi Moose experts/users,\nI am looking through the materials module and hope to use ComputeCrystalPlasticityStress class to calculate the response of a FCC crystalline solid. The example file given by Moose is https://mooseframework.inl.gov/source/materials/crystal_plasticity/CrystalPlasticityKalidindiUpdate.html.\nWith the help of some moose experts or users, I succeed in obtaining the stress-strain curve. But this result is for room temperature. The questions are below.\n(1) How to take temperature as a factor and study the effect of temperature on the stress-strain curve.\n(2) I am confused about what material is used in the example file (https://github.com/PengWei97/monkey/blob/main/problem/poly_cp/prop_grain_read_cp_03.i) and how to define my own material property.\n(3) how to obtain an input file with a set of Euler angles like this one https://github.com/idaholab/moose/files/6316215/input_file.txt.\nThe example files above are provided by @PengWei97. Would you or others like to share any good experiences/tips with me? Thanks for your help in advance.",
          "url": "https://github.com/idaholab/moose/discussions/17691",
          "updatedAt": "2022-06-06T12:17:40Z",
          "publishedAt": "2021-04-27T15:32:29Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dewenyushu"
                  },
                  "bodyText": "Hi @xchengood\nTo answer part your questions:\n(1) I am recently working on crystal plasticity code development which involves adding temperature effects. I will be working on a PR in the next week or so and will share with you the link here when the PR is up.\n(2) The example input that you are sharing is using the FiniteStrainUObasedCP base class. So the material state variables are actually defined and calculated in the UserObjects block. From there, it looks like you are using the Kalidindi model, which is documented in the documentation page that you are referencing. For some detailed descriptions of the constitutive law of the material and default values, I would recommend you to look into the individual user object's documentation page. Also, maybe it is helpful to go through the following paper as well:\nSurya R Kalidindi, Curt A Bronkhorst, and Lallit Anand. Crystallographic texture evolution in bulk deformation processing of fcc metals. Journal of the Mechanics and Physics of Solids, 40(3):537\u2013569, 1992.\nOne thing I want you to be aware of is that we are migrating the FiniteStrainUObasedCP base class to ComputeMultipleCrystalPlasticityStress (see #17405), which should be on the devel branch soon. The Kalidindi model is also transformed with the new design, which only includes one material class and should make more sense for you to understand the material model.\n(3) The Euler angles seems to be generated as random numbers ranging between 0 and 360, I guess?  The number of rows depends on the read type, i.e., number of elements, blocks, or grains, see https://mooseframework.inl.gov/source/userobjects/ElementPropertyReadFile.html\nHope this is helpful!\n@jiangwen84 @sapitts please feel free to add if I miss something",
                  "url": "https://github.com/idaholab/moose/discussions/17691#discussioncomment-665572",
                  "updatedAt": "2022-06-16T19:27:12Z",
                  "publishedAt": "2021-04-27T17:24:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @dewenyushu. Thank you for your information indeed. I would like to ask you how is your working on crystal plasticity code development adding temperature effects. Hope you can finish it soon. In addition, could you please take time to look through and try to run this input file?\nhttps://github.com/ngrilli/c_pfor_am/blob/main/test/tests/TempDepCRSS/TempDepCRSS.i\nI am not able to get an output file with csv format. what is outlier variable residual norms in terminal below\n\nI have no idea where goes wrong and how to improve it. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/17691#discussioncomment-705220",
                          "updatedAt": "2022-06-16T19:27:20Z",
                          "publishedAt": "2021-05-06T16:19:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Hi @xchengood ,\nGood to know that you've made some progress on your CP simulation. To answer your questions:\n\n\nAn initial implementation for adding temperature effects is close to be merged, see #17735\n\n\nTo output a csv file. You will need to define the desired output variables in the\n\n\n[Postprocessors]\n\n[]\n\nblock. There are many Postprocessor and Vectorpostprocessor types you can choose from, based on the variables that you would like to output. See all the types on the source documentation page here",
                          "url": "https://github.com/idaholab/moose/discussions/17691#discussioncomment-706066",
                          "updatedAt": "2022-06-16T19:27:18Z",
                          "publishedAt": "2021-05-06T19:25:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @dewenyushu. I am appreciative of your information. Could you tell me which is the specific input file that you add temperature effect in the #17735.  In addition, could you share good experiences or tips for creating and developing a custom application?  Although I repeatedly look through the example and tutorial as well as the development section, I still have no idea how to create my application, like which syntax I should use, which object class I should utilize. For .c and .h file, what programming rules should I take when writing them? I know c++ is the basis but it looks more complicated.",
                          "url": "https://github.com/idaholab/moose/discussions/17691#discussioncomment-729778",
                          "updatedAt": "2022-06-16T19:27:34Z",
                          "publishedAt": "2021-05-12T15:30:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "@xchengood\n\nIn #17735, I have a test input where I added an AuxVariable to mimic a linearly increasing temperature, please see:\n\nmodules/tensor_mechanics/test/tests/crystal_plasticity/stress_update_material_based/thermal_eigenstrain_test.i\nIf you would like to solve a thermomechanical problem with crystal plasticity, simply declare a temperature variable and add the heat conduction kernels for the temperature variable in your input. You may refer to some existing inputs, such as:\n/Users/yushd/projects/moose/modules/combined/test/tests/power_law_creep/power_law_creep.i\n\nI remember MOOSE's training session provides sufficient info about creating an application (see https://mooseframework.inl.gov/). Would you mind being more specific about what kind of application you are creating? what specific difficulties that you are seeing so far?",
                          "url": "https://github.com/idaholab/moose/discussions/17691#discussioncomment-731118",
                          "updatedAt": "2022-09-12T17:11:42Z",
                          "publishedAt": "2021-05-12T21:19:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @dewenyushu. Thank you for giving me good instructions.\n\n\nI am not clear about what is the right way to take your input file that you mentioned in 1 in last reply for my use. I just copy this input file to my moose corresponding folder or download your whole files. For the second way, I try to use 'make -j4' to compile it after it goes into tensor_mechanics, I got the following error.\n\n\n\nwhat is 'fth_xx', 'fth_yy' and 'fth_zz' in your input file?\n\n\nThank you for your help again.",
                          "url": "https://github.com/idaholab/moose/discussions/17691#discussioncomment-753797",
                          "updatedAt": "2022-09-12T17:11:44Z",
                          "publishedAt": "2021-05-18T16:10:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Hi @xchengood\n\nFrom the error message you posted above, the error from libmesh does not seem to be related to the crystal plasticity codes that we are working on. You may need to update your repo by conda update --all and try again\n\nNevertheless, copying/downloading the files from the PR does not sound ideal - especially after my recent change of the code to account for multiple thermal eigenstrains.\n\n\nIf you are not in a hurry, the easiest for you would be to wait for the PR to be merged, then you can just update your local MOOSE repo based on the next or devel branch.\n\n\nIf you are comfortable with git, the other approach is to pull my https://github.com/dewenyushu/moose/tree/add_thermal_eigenstrain_for_CP branch from my github repo. I am sure there are many ways to do so. Need a bit search and exercise on the git commands.\n\n\n\nThe 'fth_xx', 'fth_yy' and 'fth_zz' are the components in the thermal deformation gradient tensors.",
                          "url": "https://github.com/idaholab/moose/discussions/17691#discussioncomment-755314",
                          "updatedAt": "2022-09-12T17:11:45Z",
                          "publishedAt": "2021-05-18T21:40:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @xchengood\nTo add the effect of temperature, you will need to write your own child material class and add temperature as a coupled variable.\nYou can find an example in my repository:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainCrystalPlasticityThermal.C\nThis material model includes the thermal eigenstrain to model thermal expansion,\ntemperature dependence of the critical resolved shear stress,\ntemperature dependence of the thermal expansion coefficient.\nThis other material:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/ComputeElasticityTensorCPGrain.C\nis for the temperature dependence of the elasticity tensor.\nThe equations of the crystal plasticity model in MOOSE are reported in section 2.1 of:\nhttps://www.sciencedirect.com/science/article/abs/pii/S0927025618305883\nThe meaning of the parameters in the input file:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/test/tests/TempDepCRSS/TempDepCRSS.i\nit is, for instance:\nflowprops = '1 12 0.001 0.1' # slip rate equations parameters \nhprops = '1.0 541.5 136.0 200.0 2.5' # hardening properties\ngprops = '1 12 136.0' # initial values of slip system resistances (start_slip_sys, end_slip_sys, value)\n\n0.001 is \\dot{\\gamma}0 (equation 4)\n0.1 is m (equation 4)\n541.5 is h{s_i s_j} (equation 6)\n136.0 is g_{s_j} at time 0 (equation 6)\n200.0 is g_{sat} (equation 6)\n2.5 is a (equation 6)\nTrust this helps.\nBest Regards,\nNicol\u00f2 Grilli",
                  "url": "https://github.com/idaholab/moose/discussions/17691#discussioncomment-666178",
                  "updatedAt": "2022-06-16T19:27:41Z",
                  "publishedAt": "2021-04-27T19:29:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Dear @ngrilli\n\n\nTo add the effect of temperature, you will need to write your own child material class and add temperature as a coupled variable.\nYou can find an example in my repository:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainCrystalPlasticityThermal.C\nThis material model includes the thermal eigenstrain to model thermal expansion,\ntemperature dependence of the critical resolved shear stress,\ntemperature dependence of the thermal expansion coefficient.\nThis other material:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/ComputeElasticityTensorCPGrain.C\nis for the temperature dependence of the elasticity tensor.\nThe equations of the crystal plasticity model in MOOSE are reported in section 2.1 of:\nhttps://www.sciencedirect.com/science/article/abs/pii/S0927025618305883\nThe meaning of the parameters in the input file:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/test/tests/TempDepCRSS/TempDepCRSS.i\nit is, for instance:\nflowprops = '1 12 0.001 0.1' # slip rate equations parameters \nhprops = '1.0 541.5 136.0 200.0 2.5' # hardening properties\ngprops = '1 12 136.0' # initial values of slip system resistances (start_slip_sys, end_slip_sys, value)\n\n0.001 is \\dot{\\gamma}0 (equation 4) 0.1 is m (equation 4) 541.5 is h{s_i s_j} (equation 6)\n136.0 is g_{s_j} at time 0 (equation 6)\n200.0 is g_{sat} (equation 6)\n2.5 is a (equation 6)\n\nFirst, thanks for your help indeed. I try to understand all your provided. But there is still some confusion in my head. Based on this input file,\n\n\ncould you explain more about this one in [Functions] block? I guess this is to set compression force, right? Usually, for uniaxial tension or compression test, the rate of compression/tension like 0.1mm/min is set. So what is the meaning of '0.1*t'?\n\n\n\nIn [AuxVariables] or [AuxKernels] block, what is meaning of [./fp_xx], [./fp_yy], [./fp_zz] and [./crysrot11]?\n\n\nIn [UserObjects] block, the file you used is called  'euler_ang_test.inp'. How can I get one file like this for my own materials?\n\n\nYou did great work in that published paper. I saw the material you studied is \u03b2-HMX, right? How do you define the properties of this material in the input file? Usually, I just know we can define one material by something like Young's modulus and Poisson's ratio. I do not see any places regarding these aspects in your input file.\n\n\nAgain, I appreciate your help.\n\nTrust this helps.\nBest Regards,\nNicol\u00f2 Grilli",
                          "url": "https://github.com/idaholab/moose/discussions/17691#discussioncomment-675598",
                          "updatedAt": "2022-06-16T19:29:50Z",
                          "publishedAt": "2021-04-29T15:52:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @ngrilli, the information you provided is much helpful for me to study the effect of temperature on uniaxial tension/compression. But I have some confusion about some points. Could you look at my questions in the last reply and help me figure them out? Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/17691#discussioncomment-698981",
                          "updatedAt": "2022-06-16T19:30:23Z",
                          "publishedAt": "2021-05-05T14:14:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ADMatDiffusion vs MatDiffusion",
          "author": {
            "login": "rtaylo45"
          },
          "bodyText": "Hello,\nI am new to moose and a little confused with the differences between ADMatDiffusion and MatDiffusion. ADMatDiffusion uses the automatic differentiation system to calculate the Jacobian and MatDiffusion calculates the Jacobian directly inside the kernel. In both systems you can very the diffusivity as a function of args a, b, c, ... but what about u? My guess is that if you wanted the diffusitivity to very with u or a coupled variable such as temperature you would need to use ADMatDiffusion, is this correct?",
          "url": "https://github.com/idaholab/moose/discussions/17864",
          "updatedAt": "2023-02-03T00:17:50Z",
          "publishedAt": "2021-05-17T22:13:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think for MatDiffusion, the derivative with respect to u or the non-linear variables of the diffusivity are actually already included in the kernel definition. You can have a look at MatDiffusionBase.h for the Jacobian computation.\nSo with MatDiffusion, as long as you define the derivatives of the diffusivities in your materials, you could still get the perfect Jacobian.\nIf you don't want to work on implementing the derivatives of your material properties, just use the AD version.\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17864#discussioncomment-750356",
                  "updatedAt": "2023-02-03T00:17:50Z",
                  "publishedAt": "2021-05-17T23:17:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Phase field (crystal) question",
          "author": {
            "login": "mangerij"
          },
          "bodyText": "I have a request from some colleagues to model something, but I am unsure where to look for the tools:\nThe system starts initially amorphous and has some small perhaps randomly placed nucleation centers that form a specific (cubic) crystalline phase. In the interface region, there may be some pyrochlore crystallites that comprise an \"intermediate\" phase.\nThe nucleation centers essentially grow until they fill the computational domain and we get a number of different grains/grain sizes based on the temperature profile the evolution sees.\nIs such a model implemented in MOOSE, the modules, or any external apps? Is this \"phase field crystal\"?",
          "url": "https://github.com/idaholab/moose/discussions/17794",
          "updatedAt": "2022-06-14T14:01:37Z",
          "publishedAt": "2021-05-11T07:28:43Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@SudiptaBiswas Can you please help?",
                  "url": "https://github.com/idaholab/moose/discussions/17794#discussioncomment-729378",
                  "updatedAt": "2022-06-14T14:01:36Z",
                  "publishedAt": "2021-05-12T14:11:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "I wouldn't call this phase-field crystal. PFC models represent the local atomic structure with a continuous order parameter that is analogous to local density. The length scale is much smaller than typical phase-field models because PFC attempts to resolve the local atomic structure, whereas in phase-field modeling we coarse-grain the atomic structure.\nWhat you are describing sounds more like a phase transformation problem. It seems similar to a solidification problem, except that rather than transforming from the liquid phase to multiple grains of a solid phase, you are transforming from an amorphous phase to multiple grains of a crystalline (solid) phase. In both situations, there is a driving force in the free energy that is causing the phase transformation. I'm not sure offhand how the intermediate phase in the interface would affect things.\nSo setting aside the intermediate phase for the moment, to model this you would want to be able to represent the amorphous phase (a single order parameter for this should suffice) and multiple grains of the crystalline phase. One question I have is whether there is any difference in chemical composition between the amorphous and crystalline phases? (I am guessing not but just thought I would double check.)",
                  "url": "https://github.com/idaholab/moose/discussions/17794#discussioncomment-740671",
                  "updatedAt": "2022-06-14T14:01:37Z",
                  "publishedAt": "2021-05-14T23:36:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "Yeah, there is no difference in chemical composition, the material just has three different phases that evolve from amorphous to a full grain structure via small nucleation centers. The tertiary phase can be ignored for now.\nSo where are these \"phase transformation\" models in the modules? Is there an input file I can work off of?\nthanks!",
                          "url": "https://github.com/idaholab/moose/discussions/17794#discussioncomment-748731",
                          "updatedAt": "2022-06-14T14:01:38Z",
                          "publishedAt": "2021-05-17T15:48:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "SudiptaBiswas"
                  },
                  "bodyText": "I don't think we have the capability to set up the interface as a third material. I agree with Larry, the two-phase problem can be handled with existing phase transformation models.",
                  "url": "https://github.com/idaholab/moose/discussions/17794#discussioncomment-740692",
                  "updatedAt": "2022-06-14T14:01:41Z",
                  "publishedAt": "2021-05-14T23:49:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "So we don't have any examples that do exactly this situation in the repo now. It is probably closest to the solidification examples here:\nhttps://github.com/idaholab/moose/tree/next/modules/phase_field/examples/anisotropic_interfaces\nI would probably start with the grand potential formulation for a binary alloy here:\nhttps://github.com/idaholab/moose/blob/next/modules/phase_field/examples/anisotropic_interfaces/GrandPotentialSolidification.i\nSo for this problem, you won't need the evolution equations for chemical potential, since you aren't tracking a solute species. You also likely don't need interfacial energy anisotropy. What you are wanting to do is actually pretty similar to a grain growth model, except that there is an energetic driving force that makes the crystalline phase more energetically favorable than the amorphous phase. So from this example, you would need to add multiple order parameters for the crystalline phase rather than the single phase as in this example.\nFor more details on the formulation of the models described above please see:\nhttps://journals.aps.org/pre/abstract/10.1103/PhysRevE.98.023309\nAgain you won't need solute species evolution so there is a lot of stuff you won't need, but I think this is the most straightforward way to go from what is currently in the MOOSE repo. You may be better off writing your own evolutions equations by simplifying what is in the paper, then using existing kernels and materials to implement it. That should be doable with no new code.",
                  "url": "https://github.com/idaholab/moose/discussions/17794#discussioncomment-749007",
                  "updatedAt": "2022-06-14T14:01:41Z",
                  "publishedAt": "2021-05-17T16:54:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Thermal contact",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi All\nHopefully a quick one, I'm busy putting together some MOOSE examples, and I'm trying a thermo-mechanical example. In my case I have two steel bodies close to one another, which eventually do get into quite a lot of contact, but weirdly heat is not conducted across this contact. This is contrary to my expectation, my kernels are as follows\n[Kernels]\n  [heat-conduction]\n    type = ADHeatConduction\n    variable = temperature\n  []\n  [heat-conduction-dt]\n    type = ADHeatConductionTimeDerivative\n    variable = temperature\n  []\n  [TensorMechanics]\n     displacements = 'disp_x disp_y disp_z'\n     generate_output = 'strain_xx strain_yy strain_zz vonmises_stress'\n     eigenstrain_names = 'steel-eigenstrain'\n     use_automatic_differentiation = true\n   []\n[]\n\nand my materials\n[Materials]\n  [steel]\n    type = ADGenericConstantMaterial\n    prop_names = 'density'\n    prop_values = '7800'\n  []\n  [steel-conduction]\n    type = ADHeatConductionMaterial\n    specific_heat = 420.0\n    thermal_conductivity = 45.0\n  []\n  [steel-elasticity]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 210e9\n    poissons_ratio = 0.33\n  []\n  [steel-thermal-expansion]\n    type = ADComputeThermalExpansionEigenstrain\n    stress_free_temperature = 293.15\n    thermal_expansion_coeff = 1.8e-3 # K^-1\n    temperature = temperature\n    eigenstrain_name = 'steel-eigenstrain'\n  []\n  [steel-strain] #We use small deformation mechanics\n    type = ADComputeSmallStrain\n    displacements = 'disp_x disp_y disp_z'\n    eigenstrain_names = 'steel-eigenstrain'\n  []\n  [steel-stress] #We use linear elasticity\n    type = ADComputeLinearElasticStress\n  []\n[]\n\nThe documentation states that ADHeatConduction uses the displaced mesh by default, as does ADHeatConductionTimeDerivative, is there another non-obvious thing I'm missing? I had presumed, perhaps wrongly that using the displaced mesh means that this would include the impact of contact to heat transfer.",
          "url": "https://github.com/idaholab/moose/discussions/17804",
          "updatedAt": "2022-06-11T10:33:31Z",
          "publishedAt": "2021-05-11T20:15:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "Might not be what you're looking for, but have you looked at ThermalContactAction? The source documentation linked within isn't complete, but there should be plenty of gap_heat_transfer tests in the Heat Conduction module that use the ThermalContact block to look at how to use it. I believe it sets up the objects you need to model the heat across the gap and as the spheres come into contact.",
                  "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-725831",
                  "updatedAt": "2022-06-11T10:34:07Z",
                  "publishedAt": "2021-05-11T20:33:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "I will second the recommendation to use the ThermalContact action; without this additional action your simulation will not have the boundary conditions, auxvariables, etc necessary to model the heat transfer between the two surfaces. The following input file snippet should give you an idea of what to look for in the examples Casey mentioned:\n[ThermalContact]\n  [upper_plunger_powder_thermal]\n    type = GapHeatTransfer\n    primary = plunger_bottom\n    secondary = compact_top\n    variable = temperature\n    quadrature = true\n    emissivity_primary = 0.85\n    emissivity_secondary = 0.85\n    gap_conductivity = 5\n    normal_smoothing_distance = 0.1 # as with mechanical contact this is a normalized distance. A value between 0-0.5 is recommended\n  []\n[]\n\nThe values for emissivity and gap conductivity should be adjusted for your metal and surrounding medium (air?), respectively",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-726209",
                          "updatedAt": "2022-06-11T10:34:08Z",
                          "publishedAt": "2021-05-11T22:10:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Here are two screenshots of the paired_temperature variable, weirdly I get something paired on the wrong side of the left hand cup.\n\n\nI presume thats not meant to happen?",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-729690",
                          "updatedAt": "2022-06-11T10:34:25Z",
                          "publishedAt": "2021-05-12T15:12:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Do you have the entire outer side of the left cup set as a single sideset? If yes, I'd recommend splitting the front (or non handle) and back (or handle) into two separate sidesets and then using only the front sideset as the secondary boundary in the thermal contact action",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-729777",
                          "updatedAt": "2022-06-11T10:34:34Z",
                          "publishedAt": "2021-05-12T15:30:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "I think I can report a bug here, in serial it runs more or less fine, but in parallel it does the first iteration and hangs (presumably forever?) my patience only lasted an hour.",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-730029",
                          "updatedAt": "2022-06-11T10:34:45Z",
                          "publishedAt": "2021-05-12T16:03:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "Seeking some clarification, Andy - so you're making it past the first nonlinear iteration, but it never starts the linear iterations? Do you have print_linear_residuals = true in your Output block? I'm curious if you're even making it to the linear solve, or if the linear iterations are just heinously slow (the limit on those before failure is 10000 by default...).\nTagging @bwspenc and @recuero as well since they have more experience with contact in general than I do.",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-730238",
                          "updatedAt": "2022-06-11T10:34:45Z",
                          "publishedAt": "2021-05-12T16:44:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Sorry that wasn't particularly clear, it does one complete non-linear iteration cycle and decides it can't converge, there's the usual stuff about reasons in this case -ve element jacobians, a picture paints a thousand words;\nime Step 1, time = 5, dt = 5\nComputing initial residual ..                                                              [  3.55 s]\n 0 Nonlinear |R| = 1.364630e+08\n      0 Linear |R| = 1.364630e+08\n      1 Linear |R| = 6.148194e+07\n      2 Linear |R| = 1.916627e+07\n 1 Nonlinear |R| = 1.916615e+07\n      0 Linear |R| = 1.916615e+07\n      1 Linear |R| = 1.905225e+07\n      2 Linear |R| = 1.887285e+07\n      3 Linear |R| = 1.473170e+07\n      4 Linear |R| = 1.126639e+07\n      5 Linear |R| = 8.901916e+06\n      6 Linear |R| = 8.599173e+06\n      7 Linear |R| = 6.498452e+06\n      8 Linear |R| = 4.120288e+06\n      9 Linear |R| = 2.986503e+06\n     10 Linear |R| = 2.380091e+06\n  Elem Information\n   id()=233, unique_id()=54803, processor_id()=2\n   type()=TET4\n   dim()=3\n   n_nodes()=4\n    0  Node id()=35, processor_id()=2, Point=(x,y,z)=(-0.0238769, 0.153157, 0.0277344)\n    DoFs=(0/0/55564) (0/1/55565) (0/2/55566) (0/3/55567) (1/0/1395796) (1/6/2011928) (1/7/2011929) (1/8/2011930) \n    1  Node id()=52, processor_id()=2, Point=(x,y,z)=(-0.0282003, 0.0764364, 0.0211529)\n    DoFs=(0/0/55572) (0/1/55573) (0/2/55574) (0/3/55575) (1/0/1395798) (1/6/2011934) (1/7/2011935) (1/8/2011936) \n    2  Node id()=238, processor_id()=2, Point=(x,y,z)=(-0.0160709, 0.218499, 0.0311491)\n    DoFs=(0/0/55992) (0/1/55993) (0/2/55994) (0/3/55995) (1/0/1395903) (1/6/2012249) (1/7/2012250) (1/8/2012251) \n    3  Node id()=22, processor_id()=2, Point=(x,y,z)=(-0.0247321, 0.191576, 0.0145954)\n    DoFs=(0/0/55528) (0/1/55529) (0/2/55530) (0/3/55531) (1/0/1395787) (1/6/2011901) (1/7/2011902) (1/8/2011903) \n   n_sides()=4\n    neighbor(0)=nullptr\n    neighbor(1)=77\n    neighbor(2)=751\n    neighbor(3)=487\n   hmin()=0.0327698, hmax()=0.142929\n   volume()=-9.51207e-07\n   active()=1, ancestor()=0, subactive()=0, has_children()=0\n   parent()=nullptr\n   level()=0, p_level()=0\n   refinement_flag()=DO_NOTHING\n   p_refinement_flag()=DO_NOTHING\n   DoFs=(1/1/1405118) (1/1/1405119) (1/1/1405120) (1/1/1405121) (1/2/1405122) (1/2/1405123) (1/2/1405124) (1/2/1405125) (1/3/1405126) (1/3/1405127) (1/3/1405128) (1/3/1405129) (1/4/1405130) (1/4/1405131) (1/4/1405132) (1/4/1405133) (1/5/1405134) (1/5/1405135) (1/5/1405136) (1/5/1405137) (1/9/2032876) (1/10/2032877) \nERROR: negative Jacobian -5.70724e-06 at point (x,y,z)=(-0.0234386, 0.149589, 0.0270887) in element 233\n[2] /home/adavis/opt/moose/scripts/../libmesh/src/fe/fe_map.C, line 1172, compiled Apr 29 2021 at 15:01:50\n  Elem Information\n   id()=894, unique_id()=55464, processor_id()=3\n   type()=TET4\n   dim()=3\n   n_nodes()=4\n    0  Node id()=68, processor_id()=3, Point=(x,y,z)=(-0.00571363, 0.174668, -0.013127)\n    DoFs=(0/0/83352) (0/1/83353) (0/2/83354) (0/3/83355) (1/0/2093599) (1/6/2709401) (1/7/2709402) (1/8/2709403) \n    1  Node id()=87, processor_id()=3, Point=(x,y,z)=(-0.00487295,  0.16173, -0.0150198)\n    DoFs=(0/0/83404) (0/1/83405) (0/2/83406) (0/3/83407) (1/0/2093612) (1/6/2709440) (1/7/2709441) (1/8/2709442) \n    2  Node id()=37, processor_id()=3, Point=(x,y,z)=(-0.0114475, 0.160955, -0.0171646)\n    DoFs=(0/0/83272) (0/1/83273) (0/2/83274) (0/3/83275) (1/0/2093579) (1/6/2709341) (1/7/2709342) (1/8/2709343) \n    3  Node id()=38, processor_id()=3, Point=(x,y,z)=(-0.00870645, 0.163973, -0.0108696)\n    DoFs=(0/0/83276) (0/1/83277) (0/2/83278) (0/3/83279) (1/0/2093580) (1/6/2709344) (1/7/2709345) (1/8/2709346) \n   n_sides()=4\n    neighbor(0)=nullptr\n    neighbor(1)=928\n    neighbor(2)=140\n    neighbor(3)=800\n   hmin()=0.00607842, hmax()=0.0154024\n   volume()=-7.07529e-08\n   active()=1, ancestor()=0, subactive()=0, has_children()=0\n   parent()=nullptr\n   level()=0, p_level()=0\n   refinement_flag()=DO_NOTHING\n   p_refinement_flag()=DO_NOTHING\n   DoFs=(1/1/2109006) (1/1/2109007) (1/1/2109008) (1/1/2109009) (1/2/2109010) (1/2/2109011) (1/2/2109012) (1/2/2109013) (1/3/2109014) (1/3/2109015) (1/3/2109016) (1/3/2109017) (1/4/2109018) (1/4/2109019) (1/4/2109020) (1/4/2109021) (1/5/2109022) (1/5/2109023) (1/5/2109024) (1/5/2109025) (1/9/2729638) (1/10/2729639) \nERROR: negative Jacobian -4.24518e-07 at point (x,y,z)=(-0.00645255, 0.170232, -0.014091) in element 894\n[3] /home/adavis/opt/moose/scripts/../libmesh/src/fe/fe_map.C, line 1172, compiled Apr 29 2021 at 15:01:50\n  Elem Information\n   id()=176653, unique_id()=231223, processor_id()=6\n   type()=TET4\n   dim()=3\n   n_nodes()=4\n    0  Node id()=49493, processor_id()=6, Point=(x,y,z)=(0.00223491, 0.141798, 0.0260217)\n    DoFs=(0/0/187964) (0/1/187965) (0/2/187966) (0/3/187967) (1/0/4191506) (1/6/4818997) (1/7/4818998) (1/8/4818999) \n    1  Node id()=43886, processor_id()=6, Point=(x,y,z)=(-0.000790227, 0.155327, 0.0271245)\n    DoFs=(0/0/183072) (0/1/183073) (0/2/183074) (0/3/183075) (1/0/4190283) (1/6/4815328) (1/7/4815329) (1/8/4815330) \n    2  Node id()=43889, processor_id()=6, Point=(x,y,z)=(-0.0153427, 0.193478, 0.0226232)\n    DoFs=(0/0/183084) (0/1/183085) (0/2/183086) (0/3/183087) (1/0/4190286) (1/6/4815337) (1/7/4815338) (1/8/4815339) \n    3  Node id()=43887, processor_id()=6, Point=(x,y,z)=(0.000263416,  0.15793, 0.029059)\n    DoFs=(0/0/183076) (0/1/183077) (0/2/183078) (0/3/183079) (1/0/4190284) (1/6/4815331) (1/7/4815332) (1/8/4815333) \n   n_sides()=4\n    neighbor(0)=nullptr\n    neighbor(1)=201467\n    neighbor(2)=201461\n    neighbor(3)=186463\n   hmin()=0.00340966, hmax()=0.0546935\n   volume()=-4.67776e-09\n   active()=1, ancestor()=0, subactive()=0, has_children()=0\n   parent()=nullptr\n   level()=0, p_level()=0\n   refinement_flag()=DO_NOTHING\n   p_refinement_flag()=DO_NOTHING\n   DoFs=(1/1/4509593) (1/1/4509594) (1/1/4509595) (1/1/4509596) (1/2/4509597) (1/2/4509598) (1/2/4509599) (1/2/4509600) (1/3/4509601) (1/3/4509602) (1/3/4509603) (1/3/4509604) (1/4/4509605) (1/4/4509606) (1/4/4509607) (1/4/4509608) (1/5/4509609) (1/5/4509610) (1/5/4509611) (1/5/4509612) (1/9/4853784) (1/10/4853785) \nERROR: negative Jacobian -2.80666e-08 at point (x,y,z)=(-0.00103069, 0.152227, 0.0256917) in element 176653\n[6] /home/adavis/opt/moose/scripts/../libmesh/src/fe/fe_map.C, line 1172, compiled Apr 29 2021 at 15:01:50\n\nthen it just sits. Before adding thermal contact, this calculations would do this -ve Jacobian, but it would just move on to the next iteration with a smaller timestep. This one just sits. Here is the example in serial\nOutputting exodus \n.                                                                                          [  2.55 s]\n\nTime Step 1, time = 5, dt = 5\nComputing initial residual ......................                                          [ 23.46 s]\nUpdating displaced mesh                                                                    [  1.08 s]\n 0 Nonlinear |R| = 1.364630e+08\nUpdating displaced mesh \n\n*** Warning ***\nWarning in PenetrationLocator. Penetration is not detected for one or more secondary nodes. This could be because those secondary nodes simply do not project to faces on the primary surface. However, this could also be because contact should be enforced on those nodes, but the faces that they project to are outside the contact patch, which will give an erroneous result. Use appropriate options for 'patch_size' and 'patch_update_strategy' in the Mesh block to avoid this issue. Setting 'patch_update_strategy=iteration' is recommended because it completely avoids this potential issue. Also note that this warning is printed only once, so a similar situation could occur multiple times during the simulation but this warning is printed only at the first occurrence.\n                                                                   [  1.53 s]\n      0 Linear |R| = 1.364630e+08\n      1 Linear |R| = 1.422522e-05\nUpdating displaced mesh                                                                    [  1.06 s]\n 1 Nonlinear |R| = 2.373806e+03\nUpdating displaced mesh                                                                    [  1.42 s]\n      0 Linear |R| = 2.373806e+03\n      1 Linear |R| = 9.458785e-04\n  Elem Information\n   id()=154587, unique_id()=209157, processor_id()=0\n   type()=TET4\n   dim()=3\n   n_nodes()=4\n    0  Node id()=35972, processor_id()=0, Point=(x,y,z)=(0.00256496, -0.0720505, 0.00114209)\n    DoFs=(0/0/143888) (0/1/143889) (0/2/143890) (0/3/143891) (1/0/35972) (1/6/5036166) (1/7/5036167) (1/8/5036168) \n    1  Node id()=41084, processor_id()=0, Point=(x,y,z)=(-0.0127279, -0.0697743, -0.00545712)\n    DoFs=(0/0/164336) (0/1/164337) (0/2/164338) (0/3/164339) (1/0/41084) (1/6/5051502) (1/7/5051503) (1/8/5051504) \n    2  Node id()=36174, processor_id()=0, Point=(x,y,z)=(-0.0127669, -0.0696714, 0.00706641)\n    DoFs=(0/0/144696) (0/1/144697) (0/2/144698) (0/3/144699) (1/0/36174) (1/6/5036772) (1/7/5036773) (1/8/5036774) \n    3  Node id()=36176, processor_id()=0, Point=(x,y,z)=(-0.00637909, -0.0725568, 0.00348699)\n    DoFs=(0/0/144704) (0/1/144705) (0/2/144706) (0/3/144707) (1/0/36176) (1/6/5036778) (1/7/5036779) (1/8/5036780) \n   n_sides()=4\n    neighbor(0)=nullptr\n    neighbor(1)=159289\n    neighbor(2)=179480\n    neighbor(3)=203799\n   hmin()=0.00787029, hmax()=0.0168108\n   volume()=-6.02689e-08\n   active()=1, ancestor()=0, subactive()=0, has_children()=0\n   parent()=nullptr\n   level()=0, p_level()=0\n   refinement_flag()=DO_NOTHING\n   p_refinement_flag()=DO_NOTHING\n   DoFs=(1/1/3146310) (1/1/3146311) (1/1/3146312) (1/1/3146313) (1/2/3146314) (1/2/3146315) (1/2/3146316) (1/2/3146317) (1/3/3146318) (1/3/3146319) (1/3/3146320) (1/3/3146321) (1/4/3146322) (1/4/3146323) (1/4/3146324) (1/4/3146325) (1/5/3146326) (1/5/3146327) (1/5/3146328) (1/5/3146329) (1/9/5401134) (1/10/5401135) \nERROR: negative Jacobian -3.61613e-07 at point (x,y,z)=(-0.00254292, -0.0712752, 0.000882316) in element 154587\nStack frames: 37\n0: libMesh::print_trace(std::ostream&)\n1: libMesh::MacroFunctions::report_error(char const*, int, char const*, char const*)\n2: libMesh::FEMap::compute_single_point_map(unsigned int, std::vector<double, std::allocator<double> > const&, libMesh::Elem const*, unsigned int, std::vector<libMesh::Node const*, std::allocator<libMesh::Node const*> > const&, bool)\n3: libMesh::FEMap::compute_affine_map(unsigned int, std::vector<double, std::allocator<double> > const&, libMesh::Elem const*)\n4: libMesh::FE<3u, (libMesh::FEFamily)2>::reinit(libMesh::Elem const*, std::vector<libMesh::Point, std::allocator<libMesh::Point> > const*, std::vector<double, std::allocator<double> > const*)\n5: libMesh::FE<3u, (libMesh::FEFamily)2>::reinit(libMesh::Elem const*, unsigned int, double, std::vector<libMesh::Point, std::allocator<libMesh::Point> > const*, std::vector<double, std::allocator<double> > const*)\n6: Assembly::reinitFEFace(libMesh::Elem const*, unsigned int)\n7: Assembly::reinit(libMesh::Elem const*, unsigned int)\n8: GeometricSearchData::updateQuadratureNodes(unsigned int)\n9: GeometricSearchData::update(GeometricSearchData::GeometricSearchType)\n10: DisplacedProblem::updateMesh(bool)\n11: FEProblemBase::computeResidualTags(std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n12: FEProblemBase::computeResidualInternal(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n13: FEProblemBase::computeResidualSys(libMesh::NonlinearImplicitSystem&, libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&)\n14: ComputeResidualFunctor::residual(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, libMesh::NonlinearImplicitSystem&)\n15: libmesh_petsc_snes_residual\n16: SNESComputeFunction\n17: /home/adavis/opt/moose/petsc/arch-moose/lib/libpetsc.so.3.14(+0xbd87b2) [0x7f59f8db67b2]\n18: SNESLineSearchApply\n19: /home/adavis/opt/moose/petsc/arch-moose/lib/libpetsc.so.3.14(+0xc3c908) [0x7f59f8e1a908]\n20: SNESSolve\n21: libMesh::PetscNonlinearSolver<double>::solve(libMesh::SparseMatrix<double>&, libMesh::NumericVector<double>&, libMesh::NumericVector<double>&, double, unsigned int)\n22: libMesh::NonlinearImplicitSystem::solve()\n23: TimeIntegrator::solve()\n24: NonlinearSystem::solve()\n25: FEProblemBase::solve()\n26: FEProblemSolve::solve()\n27: PicardSolve::solveStep(double, double&, double, double&, bool, std::set<unsigned long, std::less<unsigned long>, std::allocator<unsigned long> > const&)\n28: PicardSolve::solve()\n29: TimeStepper::step()\n30: Transient::takeStep(double)\n31: Transient::execute()\n32: MooseApp::executeExecutioner()\n33: MooseApp::run()\n34: /home/adavis/opt/moose/modules/combined/combined-opt() [0x4032ab]\n35: __libc_start_main\n36: /home/adavis/opt/moose/modules/combined/combined-opt() [0x4034ee]\n[0] /home/adavis/opt/moose/scripts/../libmesh/src/fe/fe_map.C, line 1172, compiled Apr 29 2021 at 15:01:50\nWe caught a libMesh error in FEProblemBase\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 1\n Solve Did NOT Converge!\nAborting as solve did not converge\nUpdating displaced mesh                                 [  1.18 s]\nUpdating displaced mesh                                                                    [  1.13 s]\n\n\nNotice this time we got the warning about penetration that we didn't get in the serial run, and we got an extra bit of stack trace. Maybe in the parallel run it gets stuck generating the stack trace?",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-732535",
                          "updatedAt": "2022-06-11T10:34:52Z",
                          "publishedAt": "2021-05-13T07:47:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "That might be what's happening, so we should work on getting the serial run as good as we can before going back to parallel. If it's doing this without thermal contact, let's remove that and try a couple things:\n\nWhat happens when you apply the suggestion in the warning? patch_update_strategy=iteration I'm curious if the system thinking it should have made contact when it hasn't is causing the issue.\nHave you tried running this in a debugger to run a stack trace that way?",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-734060",
                          "updatedAt": "2022-06-11T10:35:23Z",
                          "publishedAt": "2021-05-13T14:20:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "So in serial it runs 'fine' we get through a number of failed step due to -ve jacbobians, then then timestep is small enough for the simulation to take 3 or 4 successful complete non-linear iterations. Either way, in parallel, the simulation just stops after the first time step.",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-737827",
                          "updatedAt": "2022-06-11T10:35:23Z",
                          "publishedAt": "2021-05-14T10:26:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "The negative Jacobians are a little bit troublesome, and do think it could be contributing to your parallel problems (stalling or getting hung up while doing the reporting and attempting to deal with it). Did you try either of the suggestions I gave? I'd really want to see if we could get a GDB/LLDB stack trace on that to supplement the info the standard trace is giving.",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-738806",
                          "updatedAt": "2022-06-11T10:35:23Z",
                          "publishedAt": "2021-05-14T14:46:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Maybe, but in other problems its worked absolutely fine",
                          "url": "https://github.com/idaholab/moose/discussions/17804#discussioncomment-748035",
                          "updatedAt": "2022-06-11T10:35:23Z",
                          "publishedAt": "2021-05-17T13:12:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}