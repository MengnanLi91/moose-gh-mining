{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMC0xMi0wMlQwMzoyODoyNy0wNjowMM2WDw=="
    },
    "edges": [
      {
        "node": {
          "title": "share adaptive mesh from master app to sub app",
          "author": {
            "login": "BoZeng1997"
          },
          "bodyText": "I am trying to clone the adaptive mesh from master app to sub app. I have set the clone_master_app=true  in block [Multiapps] for the sub app in the master.i file.  What should I do for the [Mesh] block in sub.i? I tried leaving it empty or add the original mesh file as  FileMesh to read. Either way returned with error: Use either FileMesh with an Exodus mesh file or FileMeshGenerator with an Exodus mesh file and with use_for_exodus_restart equal to true",
          "url": "https://github.com/idaholab/moose/discussions/16389",
          "updatedAt": "2023-05-25T20:13:37Z",
          "publishedAt": "2020-12-04T16:39:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Hi Bo, see the discussion here .",
                  "url": "https://github.com/idaholab/moose/discussions/16389#discussioncomment-148048",
                  "updatedAt": "2023-05-25T20:13:37Z",
                  "publishedAt": "2020-12-05T23:51:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "We have some basic capability in the level set module for doing this. Check out the tests here: https://github.com/idaholab/moose/tree/next/modules/level_set/test/tests/transfers/markers",
                  "url": "https://github.com/idaholab/moose/discussions/16389#discussioncomment-149057",
                  "updatedAt": "2023-05-25T20:13:37Z",
                  "publishedAt": "2020-12-07T15:54:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error from file mesh transform",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi\nI have the following mesh block\n[Mesh]\n  [div_mesh]\n    type = FileMesh\n    file = 'divertor-monoblock-htc.e'\n    use_displaced_mesh = false\n  []\n  [rotate]\n    type = TransformGenerator\n    input = div_mesh\n    transform = SCALE\n    vector_value = '0.01 0.01 0.01'\n  []\n[]\n\nHowever, moose complains that\n*** ERROR ***\nTask add_mesh_generator is not registered to build MooseMesh derived objects\n\nBut as far as I can tell its no different to this from example test/tests/mesh_modifiers/transform/rotate_and_scale.i\n[Mesh]\n  [file]\n    type = FileMeshGenerator\n    file = cylinder.e\n  []\n\n  [rotate]\n    type = TransformGenerator\n    input = file\n    transform = ROTATE\n    vector_value = '0 90 0'\n  []\n\n  [scale]\n    type = TransformGenerator\n    input = rotate\n    transform = SCALE\n    vector_value = '1e2 1e2 1e2'\n  []\n[]\n\nAny ideas?",
          "url": "https://github.com/idaholab/moose/discussions/16400",
          "updatedAt": "2022-08-16T01:18:46Z",
          "publishedAt": "2020-12-05T17:16:24Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear makeclean,\nI just had the same problem, you need to use FileMeshGenerator instead of FileMesh in the first block.\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/16400#discussioncomment-148683",
                  "updatedAt": "2022-08-16T01:19:10Z",
                  "publishedAt": "2020-12-07T10:10:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Increase the number of grains to simulate grain growth",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Recently I learned an example of grain growth in the phase field module, \"grain_growth_2D_graintracker.i\". Based on this input file, I modified the number of grains and order parameters (op_num = 180,grain_num=1000) , increasing the number of grains, but the simulation has problems, as follows\uff1a\n`Uniformly refining mesh ............                                                       [ 13.40 s]\nCaching mesh information                                                                   [  1.65 s]\nInitializing equation system .............................................................\n...........................................................................                [137.15 s]\nCaching mesh information                                                                   [  1.65 s]\nComputing max dofs per elem/node .                                                         [  2.53 s]\nFramework Information:\nMOOSE Version:           git commit ef9631d on 2020-11-30\nLibMesh Version:         0d19e76fc8e7345a0634cba450f488b3a5626eb3\nPETSc Version:           3.13.3\nSLEPc Version:           3.13.3\nCurrent Time:            Wed Dec  2 09:12:13 2020\nExecutable Timestamp:    Tue Dec  1 15:13:50 2020\nParallelism:\nNum Processors:          20\nNum Threads:             1\nMesh:\nParallel Type:           replicated\nMesh Dimension:          2\nSpatial Dimension:       2\nNodes:\nTotal:                 776161\nLocal:                 39202\nElems:\nTotal:                 774400\nLocal:                 38775\nNum Subdomains:          1\nNum Partitions:          20\nPartitioner:             metis\nNonlinear System:\nNum DOFs:                139708980\nNum Local DOFs:          7056360\nVariables:               { \"gr0\" \"gr1\" \"gr2\" \"gr3\" \"gr4\" ... \"gr175\" \"gr176\" \"gr177\" \"gr178\" \"gr179\"\n}\nFinite Element Types:    \"LAGRANGE\"\nApproximation Orders:    \"FIRST\"\nAuxiliary System:\nNum DOFs:                3873761\nNum Local DOFs:          194302\nVariables:               \"bnds\" { \"unique_grains\" \"var_indices\" \"ghost_regions\" \"halos\" }\nFinite Element Types:    \"LAGRANGE\" \"MONOMIAL\"\nApproximation Orders:    \"FIRST\" \"CONSTANT\"\nExecution Information:\nExecutioner:             Transient\nTimeStepper:             IterationAdaptiveDT\nSolver Mode:             Preconditioned JFNK\nPETSc Preconditioner:    hypre boomeramg\nLEGACY MODES ENABLED:\nThis application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material\n_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate dif\nfs due to zero values being stored, and these tests should be re-golded.\nCaching mesh information                                                                   [  1.69 s]\nComputing Polycrystal Initial Condition ...........                                        [ 12.19 s]\nProjecting initial condition .............................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................                 [2116.46 s]\nComputing initial stateful property values ..                                              [  3.86 s]\nInitial adaptivity step 1 of 2 ...........................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n....................................................\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   PID 1894809 RUNNING AT pwmoose-PowerEdge-T640\n=   EXIT CODE: 9\n=   CLEANING UP REMAINING PROCESSES\n=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Killed (signal 9)\nThis typically refers to a problem with your application.\nPlease see the FAQ page for debugging suggestions\n`\nAny idea what I am doing wrong?\nThanks in advance,\nwei peng",
          "url": "https://github.com/idaholab/moose/discussions/16370",
          "updatedAt": "2022-07-12T03:28:08Z",
          "publishedAt": "2020-12-02T09:53:29Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "PengWei97"
                  },
                  "bodyText": "And this is my input file and Display information running in simulation\npw8.txt\ngrain_growth_2D_graintracker_1000.txt",
                  "url": "https://github.com/idaholab/moose/discussions/16370#discussioncomment-144677",
                  "updatedAt": "2022-07-12T03:28:27Z",
                  "publishedAt": "2020-12-02T10:07:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "You are probably running out of memory. You don't need to increase the number of order parameters, you should be able to maintain 8 order parameters for a 2D simulation and just increase the number of grains and corresponding mesh size. The advantage of the GrainTracker system is that it will allow you to re-use order parameters. I would suggest reading up on it more here to understand how it works better:\nhttps://mooseframework.inl.gov/source/postprocessors/GrainTracker.html",
                  "url": "https://github.com/idaholab/moose/discussions/16370#discussioncomment-144923",
                  "updatedAt": "2022-07-12T03:28:26Z",
                  "publishedAt": "2020-12-02T15:07:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "You are probably running out of memory. You don't need to increase the number of order parameters, you should be able to maintain 8 order parameters for a 2D simulation and just increase the number of grains and corresponding mesh size. The advantage of the GrainTracker system is that it will allow you to re-use order parameters. I would suggest reading up on it more here to understand how it works better:\nhttps://mooseframework.inl.gov/source/postprocessors/GrainTracker.html\n\nThank you very much for your response. , I got it.\nNow I have another question, in the \"voronoi\" sub-block, what does \"rand_seed = 5\" mean? Through the study of PolycrystalVoronoi webpage, I know that it is used to generate a voronoi diagram with 5 subdomains. But if I set \"grain_num = 10\", the output cloud image is composed of 18 sub-domains and represents 10 grains.\n[UserObjects] [./voronoi] type = PolycrystalVoronoi grain_num = 100 # Number of grains rand_seed = 10 [../] []\nSo I want to ask\uff1a\n\nWhat does \"voronoi/rand_seed\" affect in the model?\nAnd for different numbers of grains, how to choose the appropriate number of \"rand_seed\"?\nThank you for your precious time. Do you have any information to understand the \"voronoi\" and \"grain_tracker\" in the UserObjects block, which is a better Moose program for beginners like me? Learning from the web, I still don't quite understand the meaning of some auxiliary variables in the input file, such as ghost_regions, halos and so on.",
                          "url": "https://github.com/idaholab/moose/discussions/16370#discussioncomment-145669",
                          "updatedAt": "2022-07-12T03:28:26Z",
                          "publishedAt": "2020-12-03T07:48:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Whenever you see rand_seed or something similar, it's a number for seeding the pseudo-random number generator(s) in MOOSE. In this case, each number will give you a different \"random\" initial condition so you can repeat your simulations as necessary. Feel free to change this number to see what happens to your IC.\nThe rand_seed number has no relation to the number of grains or order parameters. It will affect the location and sizes of all your grains however. Feel free to play around with this number. There is documentation on the Polycrystal Initial Condition system, as well as information on the GrainTracker on this page: https://mooseframework.inl.gov/modules/phase_field/index.html. Specifically you can find some guidance on good settings for grains versus order parameters here: https://mooseframework.inl.gov/source/userobjects/PolycrystalVoronoi.html. Note however, that if you start to add more and more grains, you will need more and more mesh to capture the smooth interfaces between grains.",
                          "url": "https://github.com/idaholab/moose/discussions/16370#discussioncomment-146152",
                          "updatedAt": "2022-07-12T03:28:27Z",
                          "publishedAt": "2020-12-03T15:30:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "OK\uff0cthank you for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/16370#discussioncomment-147699",
                          "updatedAt": "2022-07-12T03:28:28Z",
                          "publishedAt": "2020-12-05T03:45:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "auxvariable and non linear variable",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nI would have a simple (naive) questions: is it possible to add to a non linear variable the value computed from an aux variable? And, if yes, when and where would it be done? One thing to add is that what I would need is actually the coupleGradient of the non linear variable afterwards.\nThanks for any help,\nmauro",
          "url": "https://github.com/idaholab/moose/discussions/16368",
          "updatedAt": "2022-12-15T16:02:32Z",
          "publishedAt": "2020-12-02T09:37:54Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Yes, that is possible, but it'd be useful to know more details:\n\nare you constructing a new AuxVariable = anotherAux + u ?\nare you doing this in the input file, or in C++ code?\ninstead, are you wanting to modify u, eg, u = u + Aux?   If so, when do you want the modification done?  After every nonlinear iteration, after every timestep, ... ?   Are you doing this in C++ code, or using the input file (I believe it is impossible to do this from the input file)?",
                  "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-145378",
                  "updatedAt": "2022-12-15T16:02:32Z",
                  "publishedAt": "2020-12-02T20:50:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Dear @WilkAndy,\nThanks. Mine would exactly match your last bullet point. I compute a non linear var (u) and I have an aux kernel that provides an aux and would like to have it as a correction to u (u=u+aux) at timestep end (do not need to internally iterate). Indeed, I would only want to make use of the new value (its coupledgradient actually) in the next timestep. All would be in a c++ file on runtime, though I still did not find exactly where and how. As always, any suggestion is greatly appreciated.\nThanks again,\nMauro",
                          "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-145480",
                          "updatedAt": "2022-12-15T16:02:32Z",
                          "publishedAt": "2020-12-02T23:07:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I suggest you attempt to write your DEs so the AuxVariable is included in the DEs, and hence just becomes a coupledVariable in a Kernel.   That will fit nicely into the MOOSE paradigm, and could be more physical too.  Eg, maybe the AuxVariable is some sort of source term.\nIf that just isn't possible, then you could follow the code at\nhttps://github.com/idaholab/moose/blob/next/modules/richards/src/base/RichardsMultiphaseProblem.C\nwhich modifies a nonlinear variable in a similar way to what you'd like.",
                          "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-145528",
                          "updatedAt": "2022-12-15T16:02:32Z",
                          "publishedAt": "2020-12-03T00:36:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@WilkAndy: I had a quick look at the code (above) in the Richards' module. One question: should it only work based on two non linear variables (and not with one non linear and one aux variable)? Just wondering, sorry for posting back...",
                          "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-147161",
                          "updatedAt": "2022-12-15T16:02:32Z",
                          "publishedAt": "2020-12-04T14:23:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Yea, it'll probably work fine.",
                          "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-147642",
                          "updatedAt": "2022-12-15T16:02:46Z",
                          "publishedAt": "2020-12-05T00:40:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "CoupledForce might be what you're looking for.",
                  "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-145544",
                  "updatedAt": "2022-12-15T16:02:48Z",
                  "publishedAt": "2020-12-03T01:07:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "Thanks @WilkAndy and @WilkAndy. I ended up with something similar on CoupleForce. Will nevertheless try to have a deeper look at the original code in the framework.\nmauro",
                  "url": "https://github.com/idaholab/moose/discussions/16368#discussioncomment-145727",
                  "updatedAt": "2022-12-15T16:02:53Z",
                  "publishedAt": "2020-12-03T09:14:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "tensor rotation",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "Hi all. I wanted to talk about tensor rotations (again) as it pertains to mechanics simulations, but without a discussion on those pesky Euler angles. It seems all you need is a rotation matrix and some clever manipulation to rotate the tensor (easy in python). Now I already know the basis vectors for how my crystal phase is embedded in my matrix phase, so there are really only two rotation matrices possible - the basis vectors are either rows or columns. One takes a vector direction in the matrix (sample) phase and gives me a direction in the crystal phase, and vice versa. After some googling, which one you want depends on the application. So for the case of straining a sample and getting the proper stresses inside of the crystal phase, which way do I go?",
          "url": "https://github.com/idaholab/moose/discussions/16252",
          "updatedAt": "2023-01-13T21:57:23Z",
          "publishedAt": "2020-11-19T14:32:20Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "Where you able to find an answer to this?",
                  "url": "https://github.com/idaholab/moose/discussions/16252#discussioncomment-146872",
                  "updatedAt": "2023-01-13T21:57:27Z",
                  "publishedAt": "2020-12-04T02:16:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "I tried to figure it out myself and ended up submitting #16341. If anybody has any comments I would ask them to post there.",
                          "url": "https://github.com/idaholab/moose/discussions/16252#discussioncomment-146886",
                          "updatedAt": "2023-01-13T21:57:27Z",
                          "publishedAt": "2020-12-04T03:08:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PerfGraph",
          "author": {
            "login": "singhgp4321"
          },
          "bodyText": "I am removing this post since I found the answer.",
          "url": "https://github.com/idaholab/moose/discussions/16374",
          "updatedAt": "2023-04-09T10:23:00Z",
          "publishedAt": "2020-12-02T20:23:38Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "In the future - if you find an answer yourself, it would be beneficial to others to comment on what the solution you discovered was and leave your original question as a resource. We want this new Discussions forum to be a searchable database of user issues and support, much like the old mailing list.\nThank you for submitting a question, and I'm glad you were able to find the answer!",
                  "url": "https://github.com/idaholab/moose/discussions/16374#discussioncomment-146777",
                  "updatedAt": "2023-04-09T10:23:00Z",
                  "publishedAt": "2020-12-03T22:41:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get only the converged solution for a material property?",
          "author": {
            "login": "jaYINGLING"
          },
          "bodyText": "I am writing a material property that updates the elasticity as a function of the highest vonmises_stress in each element.\nIn the computeQpElasticityTensor() method I have the following logic:\nif (_trial_stress[_qp] > _max_trial_stress[_qp])\n     _max_trial_stress[_qp] = _trial_stress[_qp];\n\nAfter which a damage coefficient is calculated to determine the young's modulus and poisson's ratio.  _trial_stress is a coupledVar to vonmises_stress and _max_trial_stress is a declared material property.\nFor some reason using the logic above to specify _max_trial_stress results in some elements getting assigned values of vonmises_stress that were never seen in any previous timestep for a particular element. More specifically, if I use paraview to track the values of vonmises_stress in a particular element, it may never exceed 20MPa. However, the max_trial_stress for that element might be as high as 60MPa.\nI have verified that I can correctly assign  _max_trial_stress[_qp] = _trial_stress[_qp]; to each element by removing the if statement. However, this logic is essential to describing the elasticity of the material upon relaxation.\nIt seems like maybe very large values of vonmises_stress are being stored in _max_trial_stress during the iteration process before a solution for the timestep is found. I'm not sure how to get around this problem. I tried using coupledVarOld to use the previously converged solution, but the problem still occurs.\nAt what point should I assign _max_trial_stress[_qp]=_trial_stress[_qp] so that it only takes the value of the converged solution?\nPerhaps a related question is: How is _qp used to write to material properties. Does each thread iterate through a list of _qps or is the material property accessed all at once as a vector?",
          "url": "https://github.com/idaholab/moose/discussions/16172",
          "updatedAt": "2023-05-01T16:28:48Z",
          "publishedAt": "2020-11-12T23:07:37Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "Material properties are computed on the fly and don't maintain their state like you are expecting. The the _max_trial_stress references memory in the internals of MOOSE that get swapped out at each element before calling the compute methods.\nThis problem might require the use of old material properties (getMaterialPropertyOld) to use for comparison. Hopefully, someone with more experience with this type of calculation will jump in.",
                  "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-128455",
                  "updatedAt": "2023-06-09T14:07:49Z",
                  "publishedAt": "2020-11-13T04:22:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jaYINGLING"
                          },
                          "bodyText": "OK. A solution might be to get the _trial_stress and assign it to a material property _trial_stress_prop. Then use:\nif (_trial_stress_prop_old[_qp] > _max_trial_stress[_qp])\n     _max_trial_stress[_qp] = _trial_stress_prop_old[_qp];\n\nI'll give this a try. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-128926",
                          "updatedAt": "2023-06-09T14:07:49Z",
                          "publishedAt": "2020-11-13T19:40:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jaYINGLING"
                          },
                          "bodyText": "Unfortunately this does not solve the problem. Here you can see my material that gets strained from left to right. The _max_trial_stress is the same for large groups of elements with sudden transitions that I think are related to the number of threads used to do the solve. In effect, using just one thread would result in all mesh elements taking the same value of _max_trial_stress. The correct behavior would be to see a gradient of _max_trial_stress, largest to smallest, from left to right.",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-128944",
                          "updatedAt": "2023-06-09T14:07:49Z",
                          "publishedAt": "2020-11-13T20:14:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jaYINGLING"
                  },
                  "bodyText": "Perhaps I would be better off writing an AuxKernel that computes _max_trial_stress and then use that to calculate the elasticity?",
                  "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-128948",
                  "updatedAt": "2023-06-09T14:07:52Z",
                  "publishedAt": "2020-11-13T20:20:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "I wouldn't recommend this there is potential to get interpolation errors because aux variables are computed at differing locations than the material properties. Additionally, automatic differentiation is not supported.",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-132811",
                          "updatedAt": "2023-06-09T14:07:52Z",
                          "publishedAt": "2020-11-18T16:32:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@sapitts @bwspenc Do you have any ideas for solving this problem?",
                  "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-132828",
                  "updatedAt": "2023-06-09T14:07:52Z",
                  "publishedAt": "2020-11-18T16:43:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "It might be worthwhile to put the _max_trial_stress[_qp] setting/ calculation in a computeStressFinalize method; however, we only have that type of method within the radial return type methods instead of the ComputeElasticityTensor classes.\nYou might instead consider storing the maximum von mises stress value (_vonmises_stress_old) from the previous timestep in the first iteration of the current timestep. With this approach your max_trial_stress value would lag by a timestep, but you would know you were working with the converged von mises stress value from that previous timestep. @dschwen helped me put in logic for a different material calculation, which essentially had the form\nint number_nonlinear_it =\n      _fe_problem.getNonlinearSystemBase().getCurrentNonlinearIterationNumber();\n  if (number_nonlinear_it == 0)\n\nin the jacobianSetup() method of my material class. Perhaps this approach would be helpful for your problem too?",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-133034",
                          "updatedAt": "2023-06-09T14:07:52Z",
                          "publishedAt": "2020-11-18T19:53:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "Sorry, I'm super late to this conversation. It sounds like what you want is a damage model. Rather than updating the elasticity tensor, you would want to update a damage index that is computed based on the strain. We have a fully developed system for damage models in TensorMechanics. Look at ComputeDamageStress. That's used together with the actual damage model, which computes the scalar damage material property. I don't think we have a \"real\" damage model in MOOSE, but there is one in BlackBear that derives from the ScalarDamageBase class in MOOSE: https://github.com/idaholab/blackbear/blob/devel/src/materials/MazarsDamage.C",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-144405",
                          "updatedAt": "2023-06-09T14:07:53Z",
                          "publishedAt": "2020-12-02T00:51:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jaYINGLING"
                          },
                          "bodyText": "These are good leads. Thank you for your help. This is a side project for me so I apologize for the delayed responses.",
                          "url": "https://github.com/idaholab/moose/discussions/16172#discussioncomment-146596",
                          "updatedAt": "2023-06-09T14:08:03Z",
                          "publishedAt": "2020-12-03T18:30:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error for C code in Moose",
          "author": {
            "login": "caoductoan379"
          },
          "bodyText": "Dear All for help\nI modified the code as follows:\n#include \"PFFracBulkRateMaterial.h\"\n#include \"Function.h\"\nregisterMooseObject(\"PhaseFieldApp\", PFFracBulkRateMaterial);\ntemplate<>\nInputParameters validParams()\n{\nInputParameters params = validParams();\nparams.addClassDescription(\"Material properties used in phase-field fracture damage evolution kernel\");\nparams.addParam(\"function\", \"Function describing energy release rate type parameter distribution\");\nparams.addParam(\"gc\", 1.0, \"Energy release rate type parameter\");\nreturn params;\n}\nPFFracBulkRateMaterial::PFFracBulkRateMaterial(const InputParameters & parameters) :\nMaterial(parameters),\n_gc(getParam(\"gc\")),\n_gc_prop(declareProperty(\"gc_prop\")),\n_function_prop(isParamValid(\"function\") ? &getFunction(\"function\") : NULL);\n{\n}\nvoid\nPFFracBulkRateMaterial::initQpStatefulProperties()\n{\n_gc_prop[_qp] = _gc;\n}\nvoid\nPFFracBulkRateMaterial::computeQpProperties()\n{\n_gc_prop[_qp] = _gc;\n/**\n\nThis function computes heterogeneous gc\nUser should override this function if heterogenities needs consideration\n*/\ngetProp();\n}\n\nvoid\nPFFracBulkRateMaterial::getProp()\n{\nif (_function_prop != NULL)\n_gc_prop[_qp] = _function_prop->value(_t, _q_point[_qp]);\n}\n#include \"Material.h\"\n#include \"Function.h\"\n/**\n\nPhase-field fracture\nThis class obtains critical energy release rate (gc) value\nUsed by PFFRacBulkRate\n*/\n\nclass PFFracBulkRateMaterial;\ntemplate<>\nInputParameters validParams();\nclass PFFracBulkRateMaterial : public Material\n{\npublic:\nPFFracBulkRateMaterial(const InputParameters & parameters);\nprotected:\nvirtual void initQpStatefulProperties();\nvirtual void computeQpProperties();\n/**\n\nThis function obtains the value of gc\nMust be overidden by the user for heterogeneous gc\n*/\nvirtual void getProp();\n\n///Input parameter for homogeneous gc\nReal _gc;\n///Material property where the gc values are stored\nMaterialProperty &_gc_prop;\n///Function to specify varying gc\nFunction * _function_prop;\nprivate:\n};\nI compiled my code in phase field model. I received the error as follows:\n/projects/moose/modules/phase_field/src/materials/PFFracBulkRateMaterial.C: In constructor 'PFFracBulkRateMaterial::PFFracBulkRateMaterial(const InputParameters&)':\n/projects/moose/modules/phase_field/src/materials/PFFracBulkRateMaterial.C:26:45: error: invalid conversion from 'const Function*' to 'Function*' [-fpermissive]\n_function_prop(isParamValid(\"function\") ? &getFunction(\"function\") : NULL);\n^\n/projects/moose/modules/phase_field/src/materials/PFFracBulkRateMaterial.C:26:79: error: expected '{' before ';' token\n_function_prop(isParamValid(\"function\") ? &getFunction(\"function\") : NULL);\n^\n/projects/moose/modules/phase_field/src/materials/PFFracBulkRateMaterial.C: At global scope:\n/projects/moose/modules/phase_field/src/materials/PFFracBulkRateMaterial.C:27:1: error: expected unqualified-id before '{' token\n{\n^\n/projects/moose/framework/build.mk:118: recipe for target '/projects/moose/modules/phase_field/build/unity_src/materials_Unity.x86_64-pc-linux-gnu.opt.lo' failed\nmake: *** [/projects/moose/modules/phase_field/build/unity_src/materials_Unity.x86_64-pc-linux-gnu.opt.lo] Error 1\nCould everyone help to correct this error ? i really appreciate it .\nKind regards,\nToan",
          "url": "https://github.com/idaholab/moose/discussions/16357",
          "updatedAt": "2022-07-01T04:33:38Z",
          "publishedAt": "2020-12-01T19:53:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "addParam needs a type: ie.\nparams.addParam<FunctionName>(\"function\", \"Function describing energy release rate type parameter distribution\");\nAlso no semicolon is needed after the constructor\n_function_prop(isParamValid(\"function\") ? &getFunction(\"function\") : NULL)",
                  "url": "https://github.com/idaholab/moose/discussions/16357#discussioncomment-144165",
                  "updatedAt": "2022-07-12T19:50:28Z",
                  "publishedAt": "2020-12-01T20:02:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Same goes for your gc param. Perhaps params.addParam<Real>?\nAlso I think when you declare the property, that is going to need a type: declareProperty<Real>",
                          "url": "https://github.com/idaholab/moose/discussions/16357#discussioncomment-144170",
                          "updatedAt": "2022-07-12T19:50:28Z",
                          "publishedAt": "2020-12-01T20:07:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "caoductoan379"
                          },
                          "bodyText": "Thanks  Jessecarter. I will try it and i will let you know what happens.\nKind regards,\nToan",
                          "url": "https://github.com/idaholab/moose/discussions/16357#discussioncomment-144185",
                          "updatedAt": "2022-07-12T19:50:27Z",
                          "publishedAt": "2020-12-01T20:21:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "caoductoan379"
                          },
                          "bodyText": "Thanks  Jessecarter.  it is working.\nThank for your help.\nKind regards,\nToan",
                          "url": "https://github.com/idaholab/moose/discussions/16357#discussioncomment-145020",
                          "updatedAt": "2022-07-12T19:50:28Z",
                          "publishedAt": "2020-12-02T16:22:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "LineValueSampler",
          "author": {
            "login": "LiuPengPeter"
          },
          "bodyText": "Hello,\nWhen I use the LineValueSampler in the s5 from phase_field/tutorials/spinodal_decomposition.\nIt shows that:\nTask add_postprocessor is not registered to build VectorPostprocessor derived objects\nI s there any problem in my change?\n[Postprocessors]\n  [./c_end]\n    type =  LineValueSampler\n    start_point = '0 0 0'\n    end_point = '25 0 0'\n    variable = c\n    num_points = 26\n    sort_by =  id\n    execute_on = timestep_end\n  [../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/16366",
          "updatedAt": "2022-11-28T23:31:46Z",
          "publishedAt": "2020-12-02T09:01:04Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "It\u2019s a VectorPostprocessor, not a Postprocessor.\nUse a [VectorPostprocessors] block instead.",
                  "url": "https://github.com/idaholab/moose/discussions/16366#discussioncomment-144901",
                  "updatedAt": "2023-03-02T16:03:53Z",
                  "publishedAt": "2020-12-02T14:42:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "compile PETSc on cluster",
          "author": {
            "login": "wsfsz123"
          },
          "bodyText": "Hi, dear all,\nI am always stacked when compiling PETSc using the code ./scripts/update_and_rebuild_petsc.sh on cluster, as shown in the attached picture. I don't know how to fix it, I am following the steps on\nhttps://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html\nThanks,\nShizhe",
          "url": "https://github.com/idaholab/moose/discussions/16330",
          "updatedAt": "2022-07-18T18:08:49Z",
          "publishedAt": "2020-11-30T07:58:23Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "What you are seeing is what you should be seeing. There is no error here.",
                  "url": "https://github.com/idaholab/moose/discussions/16330#discussioncomment-142867",
                  "updatedAt": "2022-07-18T18:08:47Z",
                  "publishedAt": "2020-11-30T16:49:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Maybe \"stacked\" means \"stuck\" here, and the hypre download is not completing. This is odd, because the PETSc config script appears to have successfully downloaded SUPERLU from github already. Try giving it more time.",
                          "url": "https://github.com/idaholab/moose/discussions/16330#discussioncomment-143872",
                          "updatedAt": "2022-07-18T18:08:46Z",
                          "publishedAt": "2020-12-01T15:47:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "I received notification emails that you posted (twice) to this discussion, but I am not seeing those posts. From what I am reading (in my email I did receive from GitHub), it would seem PETSc may not have successfully finished building. Can you post the configure.log for PETSc as well? That should reside at:\nmoose/petsc/configure.log\n\nThanks!",
                  "url": "https://github.com/idaholab/moose/discussions/16330#discussioncomment-143857",
                  "updatedAt": "2022-07-18T18:08:43Z",
                  "publishedAt": "2020-12-01T15:23:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "wsfsz123"
                  },
                  "bodyText": "Thank you all. I have solved this problem, it seems I had trouble git hypre, I downloaded it manually and modified the configure code, it works.",
                  "url": "https://github.com/idaholab/moose/discussions/16330#discussioncomment-144648",
                  "updatedAt": "2022-07-18T18:08:43Z",
                  "publishedAt": "2020-12-02T09:28:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}