{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wMi0xMVQxMTo1MDo1OC0wNjowMM4AMN-x"
    },
    "edges": [
      {
        "node": {
          "title": "(De)Insertion of species into domain - boundary flux",
          "author": {
            "login": "souzanha"
          },
          "bodyText": "Hello Moose community,\nI have a few questions regarding boundary conditions - species flux.\nI've been looking at this paper: https://pubs.rsc.org/en/content/articlehtml/2020/ta/c9ta11697d\nwhere they define the reaction rate at one boundary using the Butler-Volmer equation (6). This flux of ions depends on the chemical potential variable which is solved from the Cahn-Hilliard equation.\nIn short, I want to define a function at a boundary using the variable values at that boundary. Any hints on how to move forward? Looking forward to some inputs! :)",
          "url": "https://github.com/idaholab/moose/discussions/16984",
          "updatedAt": "2022-06-23T14:34:14Z",
          "publishedAt": "2021-02-12T17:10:07Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf this boundary condition is not in the phase field module already, it looks like you want to be creating a new boundary condition.\nYou can look at CoupledVarNeumannBC for inspiration. Someone with more experience with the phase field module and the Butler-Volmer equation may be able to recommend a better example or a boundary condition class your new one could inherit from.\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16984#discussioncomment-366624",
                  "updatedAt": "2022-06-23T14:34:16Z",
                  "publishedAt": "2021-02-13T20:40:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "srinath-chakravarthy"
                          },
                          "bodyText": "Butler-volmer is sort of like a RobinBc .. see if this will serve as inspiration for you.\n/*\n * Copyright (C) 2020 srinath\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/* \n * File:   ADButlerVolmerBC.C\n * Author: srinath\n * \n * Created on October 20, 2020, 8:25 AM\n */\n\n#include \"ADButlerVolmerBC.h\"\n\n#include \"Function.h\"\n\n\nregisterMooseObject(\"electro_chemo_mechApp\", ADButlerVolmerBC);\n\nInputParameters\nADButlerVolmerBC::validParams()\n{\n    InputParameters params = ADIntegratedBC::validParams();\n    params.addRequiredParam<Real>(\"exchange_current_density\", \"Value of exchange\"\n            \"current density\");\n    params.addParam<Real>(\"faraday\", 96485.3329, \"Faraday's Constant\");\n    params.addParam<Real>(\"R\", 8.3145, \"Universal Gas Constant\");\n    params.addParam<Real>(\"Temperature\", 298, \"Value of temperature to use\");\n    params.addParam<Real>(\"current_density\", \"Applied Current Density\");\n    params.addParam<FunctionName>(\"current_density_function\", \"\", \"Function for current density\");\n    return params;\n}\n\nADButlerVolmerBC::ADButlerVolmerBC(const InputParameters & parameters)\n        : ADIntegratedBC(parameters),\n        _i0(getParam<Real>(\"exchange_current_density\")),\n        _faraday(getParam<Real>(\"faraday\")),\n        _gas_constant(getParam<Real>(\"R\")),\n        _temp(getParam<Real>(\"Temperature\")),\n        _current(isParamValid(\"current_density\") ? getParam<Real>(\"current_density\") : 0), \n        _equilibrium_potential(&getADMaterialProperty<Real>(\"equilibrium_potential\") ? &getADMaterialProperty<Real>(\"equilibrium_potential\") : NULL), \n        _func(getParam<FunctionName>(\"current_density_function\") != \"\" \n                            ? &getFunction(\"current_density_function\") : NULL)\n{\n    if (isParamValid(\"current_density\") && _func)\n    {\n        mooseError(\"Cannot define both current density and current density function\");\n    }\n}\n\nADReal\nADButlerVolmerBC::computeQpResidual()\n{\n    auto prefac = 0.5*_faraday/(_gas_constant * _temp);\n    auto deltaPhi = prefac * _u[_qp];\n    if (_equilibrium_potential)\n        deltaPhi -= prefac * (*_equilibrium_potential)[_qp];\n    auto fac = std::exp(deltaPhi) - std::exp(-deltaPhi);\n    ADReal i = 0;\n    if (isParamValid(\"current_density\"))\n        i = _current;\n    if (_func)\n        i = _func->value(_t, _q_point[_qp]);\n    return (i - _i0 * fac) * _test[_i][_qp];\n}",
                          "url": "https://github.com/idaholab/moose/discussions/16984#discussioncomment-366631",
                          "updatedAt": "2022-06-23T14:34:19Z",
                          "publishedAt": "2021-02-13T20:49:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Thank you! This is a great push towards the right direction.",
                          "url": "https://github.com/idaholab/moose/discussions/16984#discussioncomment-369524",
                          "updatedAt": "2022-06-23T14:34:21Z",
                          "publishedAt": "2021-02-15T07:41:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Initializing the _hist material property for the phase field fracture model from the input file",
          "author": {
            "login": "Aoiosamas"
          },
          "bodyText": "Hello all,\nI have a question regarding the history variable approach used in the phase field fracture model in MOOSE, when I have a distribution of preexisting cracks. The question is about the initialization of the _hist material property. According to this post (https://groups.google.com/g/moose-users/c/Bf_nkvs-j3k/m/yXib3yPMBwAJ), I have to hard code ComputeIsotropicLinearElasticPFFractureStress::initQpStatefulProperties() function, if I'm not interested in creating the cracks in the mesh itself (real cracks). I was wondering if it has become possible somehow to initialize this history variable in the input time, e.g., using an Auxillary variable or a material property. Any insights/suggestions are really appreciated.\nThank you,\nAhmed",
          "url": "https://github.com/idaholab/moose/discussions/16991",
          "updatedAt": "2023-02-10T17:48:43Z",
          "publishedAt": "2021-02-14T13:34:04Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Do you have to use a history field? I recommend against it. Instead, it's better to apply initial condition on c, and enforce the irreversibility using VariableOldValueBoundsAux.\nNow, if you insist on using history to initialize the crack, you can take a look at this PR: #15102 which tried to do what you are describing here. It seems to me that PR was really close to be merged, I don't know why it got closed in the end. Like I said there, I'm not a big fan of the history approach, but I also have no objection in us supporting that capability.",
                  "url": "https://github.com/idaholab/moose/discussions/16991#discussioncomment-367650",
                  "updatedAt": "2023-02-10T17:48:55Z",
                  "publishedAt": "2021-02-14T14:21:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Aoiosamas"
                          },
                          "bodyText": "This is very helpful. Thank you so much.",
                          "url": "https://github.com/idaholab/moose/discussions/16991#discussioncomment-367818",
                          "updatedAt": "2023-02-10T17:48:56Z",
                          "publishedAt": "2021-02-14T15:47:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Discrepancy in analytic solution",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi All\nGot a weird one here, sure its a simple one but I can't seem to figure it. Im trying to reproduce a validation from Code_Aster EDF's thermo-mechanical code, which can easily be viewed here - https://www.simscale.com/docs/validation-cases/hollow-sphere-convection-radiation/\nI reproduced the geometry in Trelis, applied the same boundary conditions, and setup the problem, correctly as far as I can tell.\nHowever, running the simulation with 1st and 2nd order hexes, I see a consistent difference between the analytic solution from - https://www.code-aster.org/doc/default/fr/man_v/v4/v4.43.001.pdf - of about 3 degrees on the hot surface and 2 degrees on the cooler surface. Ive done this with a tabualated and explicit function to describe the heat flux on the radiative surface but give very similar results.\nAny tips/suggestions appreciated.\nreactor.zip\nThanks\nAndy",
          "url": "https://github.com/idaholab/moose/discussions/16979",
          "updatedAt": "2022-09-06T18:28:45Z",
          "publishedAt": "2021-02-12T14:44:32Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Your radiation BC is wrong. I modified your input and it works:\n[Mesh]\n  type = FileMesh\n  file = '../mesh/reactor.e'\n[]\n\n[Variables]\n  [temp]\n  []\n[]\n\n[AuxVariables]\n  [temp_in_C]\n  []\n  [radiation_flux]\n  []\n[]\n\n[Kernels]\n  [heat]\n    type = HeatConduction\n    variable = temp\n  []\n[]\n\n[AuxKernels]\n  [K_to_C]\n    type = ParsedAux\n    variable = 'temp_in_C'\n    function = 'temp-273.15'\n    args = 'temp'\n  []\n  [radiation]\n    type = ParsedAux\n    variable = radiation_flux\n    args = 'temp'\n    function = 'sigma*epsilon*(start_t^4 - temp^4)'\n    constant_names = 'sigma epsilon start_t'\n    constant_expressions = '5.73e-8 0.6 773.15'\n  []\n[]\n\n[BCs]\n  [abcd]\n    type = CoupledConvectiveHeatFluxBC\n    boundary = 'abcd'\n    variable = temp\n    htc = '133.5'\n    T_infinity = 293.15\n  []\n  [efgh]\n    type = CoupledNeumannBC\n    variable = temp\n    boundary = 'efgh'\n    coupled_var = 'radiation_flux'\n  []\n[]\n\n[Materials]\n  [density]\n    type = GenericConstantMaterial\n    prop_names = 'density  thermal_conductivity cp'\n    prop_values = '1 40 1'\n  []\n[]\n\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  automatic_scaling = true\n  type = Steady\n  petsc_options = '-snes_converged_reason'\n  petsc_options_iname = '-pc_type -sub_pc_type -pc_asm_overlap -ksp_gmres_restart'\n  petsc_options_value = 'asm lu 1 101'\n  line_search = none\n[]\n\n[Postprocessors]\n  [external_surf_ave]\n    type = SideAverageValue\n    variable = temp_in_C\n    boundary = 'abcd'\n  []\n  [internal_surf_ave]\n    type = SideAverageValue\n    variable = temp_in_C\n    boundary = 'efgh'\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/16979#discussioncomment-363295",
                  "updatedAt": "2022-09-06T18:28:48Z",
                  "publishedAt": "2021-02-12T16:25:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Thanks @hugary1995 thats what I needed! I need to make one change to your input, for whatever reason I dont see that BC type being available, neither does the documentation. I had to use\n    type = CoupledVarNeumannBC\n    v = 'radiation_flux'\n\nBut other than that, can confirm that this gives what I was after! Superb!\nOnly one question really, what was incorrect about my original functionneumanbc, shouldn't it behave the same way? What am I missing?",
                          "url": "https://github.com/idaholab/moose/discussions/16979#discussioncomment-364180",
                          "updatedAt": "2022-09-06T18:28:57Z",
                          "publishedAt": "2021-02-12T22:22:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Oh my bad, that CoupledNeumannBC is something from my app, sorry for the confusion.\nI'm on my phone so cannot confirm this, but I remember you originally used sigma epsilon (T0^4 - x^4), but the equation should really be sigma epsilon (T0^4 - T^4). This is a robin BC strictly speaking.",
                          "url": "https://github.com/idaholab/moose/discussions/16979#discussioncomment-364248",
                          "updatedAt": "2022-09-06T18:28:58Z",
                          "publishedAt": "2021-02-12T22:47:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to change an element inside a RankTwoTensor?",
          "author": {
            "login": "pharshaad"
          },
          "bodyText": "Hi all,\nI was wondering how I can change a particular element inside a RankTwoTensor. To give a little perspective,  I have a material that computes an ADRankTwoTensor consisting of the gradient of some variable. More specifically,\nvoid\nADComputeSomeQuantity::computeQpProperties()\n{\n  ADRankTwoTensor A((*_grad_ref[0])[_qp], (*_grad_ref[1])[_qp], (*_grad_ref[2])[_qp]);\n}\n\nThe goal is to inverse this tensor to get something like _some_quantity[_qp] = A.inverse();\nSince I'm working in 2-D at the moment, the 3rd row and the 3rd column of tensor A is zero which makes it singular. I was wondering if there's a way to access a particular element to change for example A_33 to something non-zero.\nThanks,\nLeon",
          "url": "https://github.com/idaholab/moose/discussions/16981",
          "updatedAt": "2022-11-04T07:03:34Z",
          "publishedAt": "2021-02-12T16:14:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can do\nA(2, 2) = 1;\nMOOSE RankTwoTensor doxygen can be found here: https://mooseframework.inl.gov/docs/doxygen/moose/classRankTwoTensorTempl.html.\nRankTwoTensor extends libMesh's TypeTensor:\nhttps://libmesh.github.io/doxygen/classlibMesh_1_1TypeTensor.html.\nIn your case, what you are looking for is the operator() in TypeTensor.",
                  "url": "https://github.com/idaholab/moose/discussions/16981#discussioncomment-363342",
                  "updatedAt": "2022-11-04T07:03:35Z",
                  "publishedAt": "2021-02-12T16:35:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pharshaad"
                          },
                          "bodyText": "Thanks for the tip Gary! Much appreciated.",
                          "url": "https://github.com/idaholab/moose/discussions/16981#discussioncomment-363840",
                          "updatedAt": "2022-11-04T07:03:41Z",
                          "publishedAt": "2021-02-12T19:27:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Creating a circular sideset",
          "author": {
            "login": "KamalnathOSU"
          },
          "bodyText": "Dear all,\nI am trying to define to define a circular sideset called 'exterior' at the front boundary. I am using ParsedGenerateSideset to do it. But I am getting only a square sideset. I am guessing that \"ParsedGenerateSideset\" is performed before refinement.  Can we make it happen after refinement ?\nBelow is my input mesh script\nxcenter=0\nycenter=0\nradius_oxide=5\n\n[Mesh]\nuniform_refine = 3\n        [./gmg]\n  type = GeneratedMeshGenerator\n  dim = 3\n  nx = 16\n  ny = 16\n  nz = 8\n  xmin = -32\n  xmax = 32\n  ymin = -32\n  ymax = 32\n  zmin = 0\n  zmax = 32\n  elem_type = HEX8\n        [../]\n        [./sideset]\n   type = ParsedGenerateSideset\n   input = gmg\n   combinatorial_geometry = ' (x-${xcenter})^2+(y-${ycenter})^2<=${radius_oxide}*${radius_oxide} & z<1 '\n   normal = '0 0 -1'\n   new_sideset_name = exterior\n        [../]\n[]\n\n\nThis is the 'exterior' sideset I got .\n\nRegards,\nKamal",
          "url": "https://github.com/idaholab/moose/discussions/16980",
          "updatedAt": "2022-10-20T19:13:26Z",
          "publishedAt": "2021-02-12T16:03:11Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Kamal,\nNot that I know of. In the future I think the refinement may become its own mesh generator, since there is definitely a valid use case for refining in between generation steps, or refining blocks selectively (though some of that overlaps with what adaptivity can provide).\nFor your problem, I would speficy : nx, ny and nz with ${fparse int(8 * 2^factor)} and just set factor at the beginning of the input file.\nHope this helps,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16980#discussioncomment-363601",
                  "updatedAt": "2022-10-20T19:13:33Z",
                  "publishedAt": "2021-02-12T18:04:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "KamalnathOSU"
                  },
                  "bodyText": "Thank you.",
                  "url": "https://github.com/idaholab/moose/discussions/16980#discussioncomment-363675",
                  "updatedAt": "2022-10-20T19:13:35Z",
                  "publishedAt": "2021-02-12T18:34:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Output the energy contribution for different terms",
          "author": {
            "login": "emmelines"
          },
          "bodyText": "Hi,\nI set up a simulation base on the Phase-field model which combines the Cahn-Hillard and Allen-Cahn equation.\nAnd now I would like to see the free energy change for only one term(Like composition only) How should I set it up?\nThank you.\nbest,\nEmmeline",
          "url": "https://github.com/idaholab/moose/discussions/16977",
          "updatedAt": "2024-05-29T23:39:43Z",
          "publishedAt": "2021-02-12T03:15:01Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "Perhaps you could use the TotalFreeEnergy AuxKernel and just pass it your concentration variable and its gradient coefficient. Then integrate the AuxVariable with a postprocessor to see the total energy change.",
                  "url": "https://github.com/idaholab/moose/discussions/16977#discussioncomment-362997",
                  "updatedAt": "2024-05-29T23:40:44Z",
                  "publishedAt": "2021-02-12T14:54:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem on grain growth during free sintering: non-uniform domain shrinkage with periodicity",
          "author": {
            "login": "JingShuShi"
          },
          "bodyText": "Dear Moose experts,\nI want to study the sintering using phase field + tensor mechanics modules. The key outputs I am looking for are the volume shrinkage during sintering and evaluate the effective properties (e.g. elastic stress state) from the whole simulation domain.\nMy initial idea is to setup a RVE with periodic boundary conditions and randomly fill the grains to certain volume fraction (or import from existing packing file), then assign only one order parameter to solve the interface evolution. Then adding rigid body motion, and coupled to tensor mechanics to get the stress/strain fields.\nIf I now consider free sintering with gravity in y-direction, during sintering the pores are closed and grains will shrink in y-direction due to gravity, but the top boundary will still be the same as t=0, so the domain volume is constant, thus the effective volume fraction in the whole domain remains constant. Is it possible to set the domain to move and follow the shrinkage of top layer of grains?\nI also have a second question on how to apply gravity onto the material:\noption1: add it through force density in Rigid Body Motion on each grain (or maybe on elements with concentration > 0.95).\noption2: add it as body force term into tensor mechanics module, so the extra strain energy from gravity will go into total free energy.\nCould you please tell me which option would be better and why?\nThanks for the help.\nBest Regards,\nHao",
          "url": "https://github.com/idaholab/moose/discussions/16860",
          "updatedAt": "2022-07-02T23:59:33Z",
          "publishedAt": "2021-02-02T21:41:27Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "SudiptaBiswas"
                  },
                  "bodyText": "I believe we don't yet have the capability to change the domain size with the shrinking particles. You can use the RVE based analysis to apply load and capture the associated deformation behavior including volume/shape change. https://www.sciencedirect.com/science/article/pii/S0168874X20301165\nIf you want to model initial powder stacking, you can apply the gravitational force to each of the particles but you will need a way to detect contact between particles to avoid any overlap.",
                  "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-342972",
                  "updatedAt": "2022-07-03T00:13:40Z",
                  "publishedAt": "2021-02-05T20:57:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "JingShuShi"
                          },
                          "bodyText": "Thanks for the paper, I had a look at it and got the idea of the global strain periodicity.  In this method, you need to specify the reference point that has no deformation. If the reference point is set at the center of the bottom boundary, then apply load on the top boundary, this will result only in top boundary moving, the displacements on top/bottom boundaries are not periodic but all the other quantities (stress, concentration, etc.) are still kept periodic?\nFor the initial powder stacking, by avoiding overlap, do you mean avoiding this only for the initial conditions, or during the whole simulation? Will the rigid body motion already ensure the particles without overlapping with each other?",
                          "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-349202",
                          "updatedAt": "2022-07-03T00:13:40Z",
                          "publishedAt": "2021-02-08T12:10:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "For a periodic domain, I often consider the center of the domain as the reference point. With this, you would allow both the boundaries to deform and your stress-strain would be periodic.\nThe whole simulation, if you apply external forces. Rigid body motion under externally applied force will not be sufficient for this.",
                          "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-353613",
                          "updatedAt": "2022-07-03T00:13:47Z",
                          "publishedAt": "2021-02-09T16:26:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "JingShuShi"
                          },
                          "bodyText": "Thanks for the answer, I see, in order to maintain both stress and strain periodicity, the reference point has to be in the center, otherwise the final result will be asymmetric.\nAs you pointed out, if the external force is applied, the rigid body motion could not prevent the particles get into contact, then it is more like the pressurized sintering case, where the diffusion at interface will be enhanced by the interface pushed towards each other. I don't see the problem with interface getting close/overlap, will mass not be conserved in this case? What about the two centroids getting too close then? Will they merge into one centroid?",
                          "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-359254",
                          "updatedAt": "2022-07-03T00:13:47Z",
                          "publishedAt": "2021-02-11T11:25:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "It would depend on how you apply the force and how you resolve the contact between particles. You just have to make sure nothing un-physical happens.",
                          "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-360172",
                          "updatedAt": "2022-07-03T00:14:06Z",
                          "publishedAt": "2021-02-11T16:54:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "JingShuShi"
                          },
                          "bodyText": "thanks, I will try some simple test cases to see if any un-physical happens.",
                          "url": "https://github.com/idaholab/moose/discussions/16860#discussioncomment-362020",
                          "updatedAt": "2022-07-03T00:14:07Z",
                          "publishedAt": "2021-02-12T08:28:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "February 2021 News",
          "author": {
            "login": "aeslaughter"
          },
          "bodyText": "February 2021 news",
          "url": "https://github.com/idaholab/moose/discussions/16976",
          "updatedAt": "2021-02-14T21:27:05Z",
          "publishedAt": "2021-02-12T03:04:18Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "January 2021 Newsletter",
          "author": {
            "login": "aeslaughter"
          },
          "bodyText": "See the January 2021 newsletter here:\nhttps://mooseframework.inl.gov/newsletter/2021_01.html",
          "url": "https://github.com/idaholab/moose/discussions/16775",
          "updatedAt": "2021-02-13T04:05:59Z",
          "publishedAt": "2021-01-21T15:48:43Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Inheriting from INSFVMomentumAdvection",
          "author": {
            "login": "joe61vette"
          },
          "bodyText": "Hello:\nIn my application, I need to have density(P,T) in a weakly compressible formulation.  So, no worries about shock capturing etc.\nI would like to base my app on INSFV (or PINSFV).  But it seems that I have a problem with inheritance.  Namely, in INSFVMomentumAdvection (and related kernels & BCs), the density is given by:\n/// Density\nconst Real & _rho;\nand is a required parameter:\nparams.addRequiredParam(\"rho\", \"The value for the density\");\nparams.declareControllable(\"rho\");\nand initialized by:\n_rho(getParam(\"rho\")),\nI can't think of a way to inherit from this and transform _rho to an ADMaterialProperty.  Is there some way to accomplish this?\nThanks,\nJoe Kelly",
          "url": "https://github.com/idaholab/moose/discussions/16949",
          "updatedAt": "2022-10-24T21:32:28Z",
          "publishedAt": "2021-02-10T23:03:41Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Hi @joe61vette. It was after charged discussion that we made the design choice to make rho a Real as opposed to a potentially varying material property. We made this choice to actually ensure that users didn't accidentally try to model a compressible problem with incompressible equations. If you actually want to model a compressible problem, I wouldn't recommend trying to work with the INSFV implementation; I would wait instead for the coming CNSFV/PCNSFV work or work off the gitlab fork I've shared with you if you want to get started now. I'm actually quite excited for the CNSFV work where we naturally have on-diagonals in the continuity equation and consequently don't have to use a Rhie-Chow interpolation for velocity in order to avoid the saddle-point problem and the accompanying checkerboard pattern in the pressure field.",
                  "url": "https://github.com/idaholab/moose/discussions/16949#discussioncomment-358232",
                  "updatedAt": "2022-11-13T15:17:06Z",
                  "publishedAt": "2021-02-10T23:18:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Thanks Alex. I will take your advice and look at the CNSFV branch.  However, my application may fall between CNSFV and INSFV as it would need to consider subcooled liquid (Rhie-Chow needed?) to low-pressure vapor where the effect of gravity head on density is significant.\nI am impressed that FVM has been successfully implemented into the MOOSE framework and hope to take advantage of this new capability.\nJoe Kelly",
                          "url": "https://github.com/idaholab/moose/discussions/16949#discussioncomment-359576",
                          "updatedAt": "2022-11-13T15:17:06Z",
                          "publishedAt": "2021-02-11T13:47:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I would not consider myself a CFD expert, nor an expert on anything really. More a jack-of-all-trades, master-of-none kind of guy \ud83d\ude04 So I, and others, are open to additional implementations and more importantly additional knowledge! Here is my understanding: if we wanted to go with a pressure-based approach to solving (some) (weakly) compressible flows, as opposed to a density-based approach, then what we would be doing fundamentally at a MOOSE implementation level is switching from using density as the nonlinear variable to using pressure as the nonlinear variable. If we do that, then we do indeed need Rhie-Chow again to combat the saddle-point nature of this implementation choice because we no longer have on-diagonals (without Rhie-Chow) in the mass continuity equation. Perhaps naively, this seems like an odd choice, but it must not be so odd because most people do it this way for low Mach number flows. But on the other hand most people are not doing fully coupled solves...but on the gripping hand (a @roystgnr catch-phrase) perhaps the segregated vs. fully-coupled distinction does not even matter. Perhaps I'm making much ado about nothing, and the pressure-based approach for low Mach number flows is truly the best choice even for fully-coupled solves. Anyway if we did elect to support a pressure-based approach to compressible flows, then we could indeed reuse much of the INSFV code. We would have to do some modifications to how we compute the Rhie-Chow interpolated velocity, however.",
                          "url": "https://github.com/idaholab/moose/discussions/16949#discussioncomment-360244",
                          "updatedAt": "2022-11-13T15:17:56Z",
                          "publishedAt": "2021-02-11T17:13:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "I am not a CFD expert by any means (not even a knowledgeable user).  But I have worked in two-phase code development my entire career.  Of course, that was finite volume with a staggered grid.  Over time, I have developed a marked preference for using primitive variables (P, V, T) rather than conservative ones.  A lot of that is based on the phase interaction terms.\nAlso, my application is for relatively low-speed flows but with density as fn(P, T).  I refer to that as \"weakly\" compressible.  It is much simpler than fully compressible (shock capturing etc).  So, for now, I will go ahead and work off of INSFV and try to make needed changes in my app.  For Rhie-Chow, I am guessing that the necessary changes are because del-dot-V is assumed zero.  Of course, that will require me to fully understand the implementation of Rhie-Chow.  Lots to learn.\nThanks again for the help,\nJoe K",
                          "url": "https://github.com/idaholab/moose/discussions/16949#discussioncomment-360291",
                          "updatedAt": "2023-01-02T21:49:14Z",
                          "publishedAt": "2021-02-11T17:29:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "So our most used reference for creating INSFV was Moukalled, et. al, \"The Finite Volume Method in Computational Fluid Dynamics\". You know I'm looking over his compressible flow chapter right now and actually there may be no needed modifications to the way we compute the \"Rhie-Chow velocity\". Today or over the next few days, I think I should be able to drum up a comparison between a density-based approach and a pressure-based approach that leverages the existing code from INSFV with slight modification. I will try to report back to you ASAP",
                          "url": "https://github.com/idaholab/moose/discussions/16949#discussioncomment-360337",
                          "updatedAt": "2023-02-17T14:28:39Z",
                          "publishedAt": "2021-02-11T17:49:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Also @joe61vette if you ever come up with some code that you think is generally useful, we would love to have some external contributors to the module!",
                          "url": "https://github.com/idaholab/moose/discussions/16949#discussioncomment-360340",
                          "updatedAt": "2023-02-17T14:29:27Z",
                          "publishedAt": "2021-02-11T17:50:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}