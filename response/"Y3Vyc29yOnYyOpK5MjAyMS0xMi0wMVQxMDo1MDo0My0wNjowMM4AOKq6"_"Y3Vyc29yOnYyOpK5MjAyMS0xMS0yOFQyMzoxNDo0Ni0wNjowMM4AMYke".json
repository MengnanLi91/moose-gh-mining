{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0xMS0yOFQyMzoxNDo0Ni0wNjowMM4AMYke"
    },
    "edges": [
      {
        "node": {
          "title": "Caught signal 11 (Segmentation fault)",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hello Mooser,\nI come across this error, and I tried the debugging as https://mooseframework.inl.gov/application_development/debugging.html but it didn't work well. Any advice on that? Thank you.\n[mpsc0377:966319:0:966319] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x128)\n==== backtrace (tid: 966319) ====\n 0  /shared/apps/.gcc/8.3/openucx/1.11.2/lib/libucs.so.0(ucs_handle_error+0x254) [0x1463524ead34]\n 1  /shared/apps/.gcc/8.3/openucx/1.11.2/lib/libucs.so.0(+0x23ef4) [0x1463524eaef4]\n 2  /shared/apps/.gcc/8.3/openucx/1.11.2/lib/libucs.so.0(+0x240aa) [0x1463524eb0aa]\n 3  /lib64/libpthread.so.0(+0x12b20) [0x14634f4b2b20]\n 4  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libsuperlu_dist.so.6(BcTree_getDestCount+0x19) [0x1463547322f0]\n 5  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libsuperlu_dist.so.6(+0x687aa) [0x1463547817aa]\n 6  /lib64/libgomp.so.1(GOMP_parallel+0x46) [0x14634e2e2706]\n 7  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libsuperlu_dist.so.6(pdgstrs+0x138f) [0x146354784a40]\n 8  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libsuperlu_dist.so.6(pdgssvx+0x1ce6) [0x14635475b40f]\n 9  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0x4a6a08) [0x146355f3ba08]\n10  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(MatSolve+0x291) [0x1463560d7d56]\n11  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xa10a53) [0x1463564a5a53]\n12  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(PCApply+0x42d) [0x14635663083e]\n13  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(KSPUnwindPreconditioner+0xc0) [0x146356733bcf]\n14  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xbfa833) [0x14635668f833]\n15  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xbfd737) [0x146356692737]\n16  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xbfdb22) [0x146356692b22]\n17  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xc8dc6b) [0x146356722c6b]\n18  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(KSPSolve+0x13) [0x14635672543a]\n19  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(+0xcb7e97) [0x14635674ce97]\n20  /work/home/rh40rejy/MOOSE/moose/petsc/arch-moose/lib/libpetsc.so.3.15(SNESSolve+0x1330) [0x1463567b9c13]\n21  /home/rh40rejy/MOOSE/moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(_ZN7libMesh20PetscNonlinearSolverIdE5solveERNS_12SparseMatrixIdEERNS_13NumericVectorIdEES7_dj+0x37f) [0x146358c0863f]\n22  /home/rh40rejy/MOOSE/moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0(_ZN7libMesh23NonlinearImplicitSystem5solveEv+0xe5) [0x146358c734f5]\n23  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN14TimeIntegrator5solveEv+0x28) [0x14635a4865b8]\n24  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN15NonlinearSystem5solveEv+0x11f) [0x14635aa6e6cf]\n25  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN13FEProblemBase5solveEv+0xd4) [0x14635a5d2b04]\n26  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN14FEProblemSolve5solveEv+0x48) [0x14635a954808]\n27  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN15FixedPointSolve9solveStepERdS0_RKSt3setImSt4lessImESaImEE+0x24c) [0x14635a9563cc]\n28  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN15FixedPointSolve5solveEv+0x272) [0x14635a959d72]\n29  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN11TimeStepper4stepEv+0x2b) [0x14635a706ecb]\n30  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN9Transient8takeStepEd+0xac) [0x14635a95594c]\n31  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN17TransientMultiApp9solveStepEddb+0x103e) [0x14635ab67b8e]\n32  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN13FEProblemBase13execMultiAppsE13MooseEnumItemb+0x346) [0x14635a5cb376]\n33  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN15FixedPointSolve9solveStepERdS0_RKSt3setImSt4lessImESaImEE+0x42d) [0x14635a9565ad]\n34  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN15FixedPointSolve5solveEv+0x272) [0x14635a959d72]\n35  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN11TimeStepper4stepEv+0x2b) [0x14635a706ecb]\n36  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN9Transient8takeStepEd+0xac) [0x14635a95594c]\n37  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN9Transient7executeEv+0x57) [0x14635a95ab37]\n38  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN8MooseApp18executeExecutionerEv+0x243) [0x14635b178873]\n39  /home/rh40rejy/MOOSE/moose/framework/libmoose-opt.so.0(_ZN8MooseApp3runEv+0x74e) [0x14635b17b3ee]\n40  /home/rh40rejy/MOOSE/hound/hound-opt() [0x40a490]\n41  /lib64/libc.so.6(__libc_start_main+0xf3) [0x14634df2f493]\n42  /home/rh40rejy/MOOSE/hound/hound-opt() [0x40a6ce]\n=================================\nsrun: error: mpsc0377: task 32: Segmentation fault (core dumped)",
          "url": "https://github.com/idaholab/moose/discussions/19518",
          "updatedAt": "2022-07-04T08:29:20Z",
          "publishedAt": "2021-12-01T15:17:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nthis is still an opt build. You should work with a debug build to debug this. Please recompile and get a backtrace with a debug build.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19518#discussioncomment-1729272",
                  "updatedAt": "2022-07-04T08:29:18Z",
                  "publishedAt": "2021-12-01T16:13:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stresses and strain in shell elements",
          "author": {
            "login": "hrishiv"
          },
          "bodyText": "The test modules/tensor_mechanics/test/tests/shell/static/plate_bending2.i compares the displacement result of the shell element in MOOSE with ABAQUS. I created the same ABAQUS input file and also added the strains and stresses output for the shell elements in MOOSE. The displacement results of the node C that are mentioned in the MOOSE test file were similar in MOOSE (12.519)  and ABAQUS (12.54) as mentioned in the test input file.\nHowever, I can see that the results of the stress and strains are significantly different.\nMOOSE                                      ABAQUS\nStress xx -              3.4641                                              6\nStress yy -              3.4641                                              6\nStress xy-               8.15e-15 (0)                                      6\nMOOSE and ABAQUS use different formulations for Shell elements. I am unsure if that would be the only reason for the result to be halved in MOOSE than ABAQUS. So, I would be thankful if someone could explain the reason for it or have a look at it.\nI have also attached the picture of the ABAQUS result for displacement and stress xx.\n\n\n# Shell element verification test from Abaqus verification manual 1.3.13\n\n# A 40 m x 20 m x 1 m plate that has E = 1000 Pa and Poisson's ratio = 0.3\n# is subjected to the following boundary/loading conditions. A single shell\n# element is used to model the plate.\n\n# disp_z = 0 at vertices A (0, 0), B (40, 0) and D (20, 0).\n# disp_x and disp_y are zero at all four vertices.\n\n# F_z = -2.0 N at vertex C (40, 20).\n# M_x = 20.0 Nm at vertices A and B (bottom boundary)\n# M_x = -20.0 Nm at vertices C and D (top boundary)\n# M_y = 10.0 Nm at vertices B and C (right boundary)\n# M_y = -10.0 Nm at vertices A and D (left boundary)\n\n# The disp_z at vertex C is -12.54 m using S4 elements in Abaqus.\n# The solution obtained using Moose is -12.519 m with a relative error\n# of 0.16%.\n\n[Mesh]\n  [./gmg]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 1\n    ny = 1\n    xmin = 0.0\n    xmax = 40.0\n    ymin = 0.0\n    ymax = 20.0\n  [../]\n\n  [./c_node]\n    type = ExtraNodesetGenerator\n    input = gmg\n    new_boundary = 100\n    coord = '40.0 20.0'\n  [../]\n[]\n\n[Variables]\n  [./disp_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_y]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_z]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./rot_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./rot_y]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n[AuxVariables]\n  [./stress_xx0]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./strain_xx0]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./stress_yy0]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./strain_yy0]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./stress_xy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./strain_xy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./stress_zy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./strain_zy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./stress_xx0]\n    type = RankTwoAux\n    variable = stress_xx0\n    rank_two_tensor = global_stress_t_points_1\n    index_i = 0\n    index_j = 0\n  [../]\n  [./strain_xx0]\n    type = RankTwoAux\n    variable = strain_xx0\n    rank_two_tensor = total_global_strain_t_points_1\n    index_i = 0\n    index_j = 0\n  [../]\n  [./stress_yy0]\n    type = RankTwoAux\n    variable = stress_yy0\n    rank_two_tensor = global_stress_t_points_1\n    index_i = 1\n    index_j = 1\n  [../]\n  [./strain_yy0]\n    type = RankTwoAux\n    variable = strain_yy0\n    rank_two_tensor = total_global_strain_t_points_1\n    index_i = 1\n    index_j = 1\n  [../]\n  [./stress_xy]\n    type = RankTwoAux\n    variable = stress_xy\n    rank_two_tensor = global_stress_t_points_1\n    index_i = 0\n    index_j = 1\n  [../]\n  [./strain_xy]\n    type = RankTwoAux\n    variable = strain_xy\n    rank_two_tensor = total_global_strain_t_points_1\n    index_i = 0\n    index_j = 1\n  [../]\n  [./strain_zy]\n    type = RankTwoAux\n    variable = strain_xy\n    rank_two_tensor = total_global_strain_t_points_1\n    index_i = 1\n    index_j = 2\n  [../]\n  [./stress_yz]\n    type = RankTwoAux\n    variable = stress_xy\n    rank_two_tensor = global_stress_t_points_1\n    index_i = 1\n    index_j = 2\n  [../]\n  []\n\n[BCs]\n  [./simply_support_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'right top bottom left'\n    value = 0.0\n  [../]\n  [./simply_support_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'right top bottom left'\n    value = 0.0\n  [../]\n  [./simply_support_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom left'\n    value = 0.0\n  [../]\n[]\n\n[NodalKernels]\n  [./force_C]\n    type = ConstantRate\n    variable = disp_z\n    boundary = 100\n    rate = -2.0\n  [../]\n  [./Mx_AB]\n    type = ConstantRate\n    variable = rot_x\n    boundary = bottom\n    rate = 20.0\n  [../]\n  [./Mx_CD]\n    type = ConstantRate\n    variable = rot_x\n    boundary = top\n    rate = -20.0\n  [../]\n  [./My_BC]\n    type = ConstantRate\n    variable = rot_y\n    boundary = right\n    rate = 10.0\n  [../]\n  [./My_AD]\n    type = ConstantRate\n    variable = rot_y\n    boundary = left\n    rate = -10.0\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  line_search = 'none'\n  #nl_max_its = 2\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 6e-6\n\n  dt = 1.0\n  dtmin = 1.0\n  end_time = 3\n[]\n\n[Kernels]\n  [./solid_disp_x]\n    type = ADStressDivergenceShell\n    block = '0'\n    component = 0\n    variable = disp_x\n    through_thickness_order = SECOND\n  [../]\n  [./solid_disp_y]\n    type = ADStressDivergenceShell\n    block = '0'\n    component = 1\n    variable = disp_y\n    through_thickness_order = SECOND\n  [../]\n  [./solid_disp_z]\n    type = ADStressDivergenceShell\n    block = '0'\n    component = 2\n    variable = disp_z\n    through_thickness_order = SECOND\n  [../]\n  [./solid_rot_x]\n    type = ADStressDivergenceShell\n    block = '0'\n    component = 3\n    variable = rot_x\n    through_thickness_order = SECOND\n  [../]\n  [./solid_rot_y]\n    type = ADStressDivergenceShell\n    block = '0'\n    component = 4\n    variable = rot_y\n    through_thickness_order = SECOND\n  [../]\n[]\n\n[Materials]\n  [./elasticity]\n    type = ADComputeIsotropicElasticityTensorShell\n    youngs_modulus = 1e3\n    poissons_ratio = 0.3\n    block = 0\n    through_thickness_order = SECOND\n  [../]\n  [./strain]\n    type = ADComputeIncrementalShellStrain\n    block = '0'\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y'\n    thickness = 1.0\n    through_thickness_order = SECOND\n  [../]\n  [./stress]\n    type = ADComputeShellStress\n    block = 0\n    through_thickness_order = SECOND\n  [../]\n[]\n\n[Postprocessors]\n  [./disp_z2]\n    type = PointValue\n    point = '40.0 20.0 0.0'\n    variable = disp_z\n  [../]\n  [./stress_xx_el_0]\n   type = ElementalVariableValue\n   elementid = 0\n   variable = stress_xx0\n [../]\n [./strain_xx_el_0]\n  type = ElementalVariableValue\n  elementid = 0\n  variable = strain_xx0\n[../]\n[./stress_yy_el_0]\n type = ElementalVariableValue\n elementid = 0\n variable = stress_yy0\n[../]\n[./stress_xy_el_0]\n type = ElementalVariableValue\n elementid = 0\n variable = stress_xy\n[../]\n[./stress_yz_el_0]\n type = ElementalVariableValue\n elementid = 0\n variable = stress_zy\n[../]\n[./strain_xy_el_0]\n type = ElementalVariableValue\n elementid = 0\n variable = strain_xy\n[../]\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/18592",
          "updatedAt": "2022-06-18T08:03:29Z",
          "publishedAt": "2021-08-12T19:54:04Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hrishiv"
                  },
                  "bodyText": "@sveerara I am not sure if you are still working on MOOSE but thought you would be the best person to ask :)",
                  "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1165353",
                  "updatedAt": "2022-06-18T08:03:51Z",
                  "publishedAt": "2021-08-12T19:54:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hrishiv"
                  },
                  "bodyText": "I was able to match the stress in xx and yy direction to 3.464 in MOOSE and ABAQUS by using Gauss thickness integration with 2 points in ABAQUS but still, MOOSE result indicates 0 stress in XY direction whereas ABAQUS results show stress XY to be 3.464.",
                  "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1165530",
                  "updatedAt": "2022-06-18T08:03:51Z",
                  "publishedAt": "2021-08-12T20:35:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "@hrishiv This comparison is tricky without knowing where Abaqus is measuring the stresses. I am guessing Abaqus is measuring stresses at the mid-thickness point. Assume we are using N points, in moose, the through thickness integration points are indexed by 0, 1, 2, ..., N-1, and the mid-thickness point would correspond to the (N-1)/2th point.\nI slightly modified your input file to reflect that. In the input file I defined two parameters order and N. order would be the through thickness quadrature order, and I evaluate the stress at the Nth point. For example, order = THIRD corresponds to N = 1, and order = SEVENTEENTH corresponds to N = 8. I can obtain satisfactory results with these changes:\norder stress_xx stress_yy stress_xy\n3     3.464102  3.464102  3.464102\n5     4.647580  4.647580  4.647580\n9     5.437079  5.437079  5.437079\n17    5.808961  5.808961  5.808961\n33    5.943453  5.943453  5.943453\n\nI remember the implementation in moose is mostly the same as Abaqus's, but don't quote me on that.\nMy input file is attached here:\norder = THIRD\nN = 1\n\n[GlobalParams]\n  through_thickness_order = ${order}\n  large_strain = true\n[]\n\n[Mesh]\n  [gmg]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 1\n    ny = 1\n    xmin = 0.0\n    xmax = 40.0\n    ymin = 0.0\n    ymax = 20.0\n  []\n  [A]\n    type = ExtraNodesetGenerator\n    input = gmg\n    new_boundary = A\n    coord = '0 0'\n  []\n  [B]\n    type = ExtraNodesetGenerator\n    input = A\n    new_boundary = B\n    coord = '40 0'\n  []\n  [C]\n    type = ExtraNodesetGenerator\n    input = B\n    new_boundary = C\n    coord = '40 20'\n  []\n  [D]\n    type = ExtraNodesetGenerator\n    input = C\n    new_boundary = D\n    coord = '0 20'\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n  [rot_x]\n  []\n  [rot_y]\n  []\n[]\n\n[BCs]\n  [simply_support_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'A B C D'\n    value = 0\n  []\n  [simply_support_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'A B C D'\n    value = 0\n  []\n  [simply_support_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'A B D'\n    value = 0\n  []\n[]\n\n[NodalKernels]\n  [force_C]\n    type = ConstantRate\n    variable = disp_z\n    boundary = C\n    rate = -2\n  []\n  [Mx_AB]\n    type = ConstantRate\n    variable = rot_x\n    boundary = bottom\n    rate = 20\n  []\n  [Mx_CD]\n    type = ConstantRate\n    variable = rot_x\n    boundary = top\n    rate = -20\n  []\n  [My_BC]\n    type = ConstantRate\n    variable = rot_y\n    boundary = right\n    rate = 10\n  []\n  [My_AD]\n    type = ConstantRate\n    variable = rot_y\n    boundary = left\n    rate = -10\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n  nl_rel_tol = 1e-08\n  nl_abs_tol = 1e-10\n\n  num_steps = 1\n[]\n\n[Kernels]\n  [solid_disp_x]\n    type = ADStressDivergenceShell\n    component = 0\n    variable = disp_x\n  []\n  [solid_disp_y]\n    type = ADStressDivergenceShell\n    component = 1\n    variable = disp_y\n  []\n  [solid_disp_z]\n    type = ADStressDivergenceShell\n    component = 2\n    variable = disp_z\n  []\n  [solid_rot_x]\n    type = ADStressDivergenceShell\n    component = 3\n    variable = rot_x\n  []\n  [solid_rot_y]\n    type = ADStressDivergenceShell\n    component = 4\n    variable = rot_y\n  []\n[]\n\n[Materials]\n  [elasticity]\n    type = ADComputeIsotropicElasticityTensorShell\n    youngs_modulus = 1e3\n    poissons_ratio = 0.3\n  []\n  [strain]\n    type = ADComputeFiniteShellStrain\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y'\n    thickness = 1.0\n  []\n  [stress]\n    type = ADComputeShellStress\n    output_properties = 'global_stress_t_points_7'\n    outputs = exodus\n  []\n[]\n\n[Postprocessors]\n  [disp_z]\n    type = PointValue\n    point = '40.0 20.0 0.0'\n    variable = disp_z\n  []\n  [stress_xx]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 0\n    index_j = 0\n  []\n  [stress_yy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 1\n    index_j = 1\n  []\n  [stress_xy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 0\n    index_j = 1\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1166158",
                  "updatedAt": "2022-06-18T08:03:53Z",
                  "publishedAt": "2021-08-13T01:21:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "@hugary1995 Thanks for the suggestion. I can now get the same stresses in the format that you suggested with single element but is there any other postprocessor that allows me to get the stress at a particular element when I have multiple elements.\nHowever, when I try to output the strain in a similar way using small strain formulation in both ABAQUS and MOOSE I am facing some differences (I changed to small strain because when I used ADComputeFiniteShellStrain and   output_properties = 'total_global_strain_t_points_${N}' I was getting 0 for the strains).\nABAQUS - strain xx  and strainyy = 2.425e-3,    strainxy = 9.007e-3\nMOOSE - strainxx = 3.879e2     strainyy =2.424e2        strainxy=1.801e2\nI think there is an error during the transformation of the strain in lines 240-241 of ADComputeIncrementalShellStrain.\n      (*_total_global_strain[j])[i] = (*_rotation_matrix[j])[i].transpose() *\n                                      _unrotated_total_strain * (*_rotation_matrix[j])[i];\n\nI changed this line to\n        (*_total_global_strain[j])[i] =  ((*_rotation_matrix[j])[i].inverse()).transpose() *\n                                    _unrotated_total_strain * (*_rotation_matrix[j])[i].inverse();\n\nand the results for xx and yy are close and xy is half (may be abaqus is giving me 2exy not sure though)\nMOOSE after change - strain xx  and strainyy = 2.42487e-3,    strainxy = 4.503332e-3\nPlease correct me if I am wrong or have made any mistakes.\nThank you\nHere is my input file.\norder = THIRD\nN = 1\n\n[GlobalParams]\n  through_thickness_order = ${order}\n  # large_strain = true\n[]\n\n[Mesh]\n  [gmg]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 1\n    ny = 1\n    xmin = 0.0\n    xmax = 40.0\n    ymin = 0.0\n    ymax = 20.0\n  []\n  [A]\n    type = ExtraNodesetGenerator\n    input = gmg\n    new_boundary = A\n    coord = '0 0'\n  []\n  [B]\n    type = ExtraNodesetGenerator\n    input = A\n    new_boundary = B\n    coord = '40 0'\n  []\n  [C]\n    type = ExtraNodesetGenerator\n    input = B\n    new_boundary = C\n    coord = '40 20'\n  []\n  [D]\n    type = ExtraNodesetGenerator\n    input = C\n    new_boundary = D\n    coord = '0 20'\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n  [rot_x]\n  []\n  [rot_y]\n  []\n[]\n\n[BCs]\n  [simply_support_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'A B C D'\n    value = 0\n  []\n  [simply_support_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'A B C D'\n    value = 0\n  []\n  [simply_support_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'A B D'\n    value = 0\n  []\n[]\n\n[NodalKernels]\n  [force_C]\n    type = ConstantRate\n    variable = disp_z\n    boundary = C\n    rate = -2\n  []\n  [Mx_AB]\n    type = ConstantRate\n    variable = rot_x\n    boundary = bottom\n    rate = 20\n  []\n  [Mx_CD]\n    type = ConstantRate\n    variable = rot_x\n    boundary = top\n    rate = -20\n  []\n  [My_BC]\n    type = ConstantRate\n    variable = rot_y\n    boundary = right\n    rate = 10\n  []\n  [My_AD]\n    type = ConstantRate\n    variable = rot_y\n    boundary = left\n    rate = -10\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n  nl_rel_tol = 1e-08\n  nl_abs_tol = 1e-10\n\n  num_steps = 1\n[]\n\n[Kernels]\n  [solid_disp_x]\n    type = ADStressDivergenceShell\n    component = 0\n    variable = disp_x\n  []\n  [solid_disp_y]\n    type = ADStressDivergenceShell\n    component = 1\n    variable = disp_y\n  []\n  [solid_disp_z]\n    type = ADStressDivergenceShell\n    component = 2\n    variable = disp_z\n  []\n  [solid_rot_x]\n    type = ADStressDivergenceShell\n    component = 3\n    variable = rot_x\n  []\n  [solid_rot_y]\n    type = ADStressDivergenceShell\n    component = 4\n    variable = rot_y\n  []\n[]\n\n[Materials]\n  [elasticity]\n    type = ADComputeIsotropicElasticityTensorShell\n    youngs_modulus = 1e3\n    poissons_ratio = 0.3\n  []\n  [strain]\n    type = ADComputeIncrementalShellStrain\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y'\n    thickness = 1.0\n    output_properties = 'total_global_strain_t_points_${N}'\n  []\n  [stress]\n    type = ADComputeShellStress\n    output_properties = 'global_stress_t_points_${N}'\n    outputs = exodus\n  []\n[]\n\n[Postprocessors]\n  [disp_z]\n    type = PointValue\n    point = '40.0 20.0 0.0'\n    variable = disp_z\n  []\n  [stress_xx]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 0\n    index_j = 0\n  []\n  [stress_yy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 1\n    index_j = 1\n  []\n  [stress_xy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'global_stress_t_points_${N}'\n    index_i = 0\n    index_j = 1\n  []\n  [strain_xx]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'total_global_strain_t_points_${N}'\n    index_i = 0\n    index_j = 0\n  []\n  [strain_yy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'total_global_strain_t_points_${N}'\n    index_i = 1\n    index_j = 1\n  []\n  [strain_xy]\n    type = MaterialTensorAverage\n    rank_two_tensor = 'total_global_strain_t_points_${N}'\n    index_i = 0\n    index_j = 1\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1190922",
                          "updatedAt": "2022-06-23T14:42:51Z",
                          "publishedAt": "2021-08-16T16:15:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Your modification looks reasonable to me. You could simplify that using the fact that the inverse of the rotation matrix is its transpose.\nHowever, I cannot guarantee this is exactly what you need, as I have never gone through the shell formulation in moose in detail. I believe @cbolisetti has more experience about this shell formulation.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1192217",
                          "updatedAt": "2022-06-23T14:42:53Z",
                          "publishedAt": "2021-08-16T21:23:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "@hugary1995 With the postprocessor you suggested I was able to get the stress and strain when I used the single element. But, as it gives average stress or strain over the volume, I think it can't give me stress and strain of a particular element when I use 2 or more elements. Is there any other postprocessor that you would suggest to output the stress and strain of a particular element when I use multiple elements?\nAlso, is there any postprocessor to output the strain and stress at the quadrature points?",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1329828",
                          "updatedAt": "2022-06-23T14:42:52Z",
                          "publishedAt": "2021-09-14T20:33:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You can use an elemental Auxkernel to output stress/strain per element. If you use RankTwoAux, you can optionally provide a parameter selected_qp to output the quantity at a specific quadrature point.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1346145",
                          "updatedAt": "2022-06-23T14:43:06Z",
                          "publishedAt": "2021-09-17T07:38:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "@hugary1995 Thank you for the reply. It helped me in static case but now I am facing problems in dynamic simulations with shell elements and comparing with ABAQUS. So I decided to run one of the similar tests created by the MOOSE group.\nmodules/tensor_mechanics/test/tests/shell/dynamics/shell_dynamics_bending_moment.i\nIt was not running and I had to uncomment the commented section in the Executioner block and had to add petsc for convergence to\n[Executioner]\ntype = Transient\nsolve_type = PJFNK\nnl_max_its = 20\nnl_rel_tol = 1e-10\nnl_abs_tol = 5e-4\ndt = 0.0005\ndtmin = 0.0005\nend_time = 1\n[./TimeIntegrator]\ntype = NewmarkBeta\nbeta = 0.25\ngamma = 0.5\n[../]\npetsc_options = '-snes_ksp_ew'\npetsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\npetsc_options_value = '201                hypre    boomeramg      4'\n[]\nThe analytical solution for the displacement at tip has been calculated in the heading as disp_z= 1.9 m using the small deformation theory. I was able to get 1.98 m in ABAQUS, the higher value may be on accounting for the large deflection theory.\nBut when I ran the test in MOOSE I was able to get only 0.645 m.  Also, the header mentions that the displacement at the tip is 1.875 m in MOOSE. I am confused why I am not getting so much difference.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427232",
                          "updatedAt": "2022-06-23T14:43:06Z",
                          "publishedAt": "2021-10-04T22:58:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "That input file (shell_dynamics_bending_moment.i) is not being tested. I just happen to have touched it in an open PR. You cannot trust what it says in the header, sorry.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427290",
                          "updatedAt": "2022-06-23T14:43:06Z",
                          "publishedAt": "2021-10-04T23:29:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "@dschwen I checked the analytical solution and it seems correct. Also, the result in the ABAQUS is close to it. So, I would assume MOOSE to give a similar result but the results in the MOOSE for the dynamic analysis of shell elements are way off. I am more concerned with the deviation of results from the analytical and ABAQUS solution rather than the MOOSE answer mentioned in the header file.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427330",
                          "updatedAt": "2022-06-23T14:43:06Z",
                          "publishedAt": "2021-10-04T23:53:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'll take a look at this.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427632",
                          "updatedAt": "2022-06-23T14:43:06Z",
                          "publishedAt": "2021-10-05T01:49:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I modified the input file such that it matches the description in the heading:\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  rotations = 'rot_x rot_y'\n  thickness = 0.1\n  through_thickness_order = FOURTH\n[]\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 1\n  ny = 4\n  xmin = 0.0\n  xmax = 1.0\n  ymin = 0.0\n  ymax = 10.0\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n  [rot_x]\n  []\n  [rot_y]\n  []\n[]\n\n[AuxVariables]\n  [stress_yy]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [stress_yz]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  # aux variables for dynamics\n  [vel_x]\n  []\n  [vel_y]\n  []\n  [vel_z]\n  []\n  [accel_x]\n  []\n  [accel_y]\n  []\n  [accel_z]\n  []\n  [rot_vel_x]\n  []\n  [rot_vel_y]\n  []\n  [rot_accel_x]\n  []\n  [rot_accel_y]\n  []\n[]\n\n[AuxKernels]\n  [stress_yy]\n    type = RankTwoAux\n    variable = stress_yy\n    rank_two_tensor = global_stress_t_points_0\n    index_i = 1\n    index_j = 1\n  []\n  [stress_yz]\n    type = RankTwoAux\n    variable = stress_yz\n    rank_two_tensor = global_stress_t_points_0\n    index_i = 1\n    index_j = 2\n  []\n\n  # Kernels for dynamics\n  [accel_x]\n    type = NewmarkAccelAux\n    variable = accel_x\n    displacement = disp_x\n    velocity = vel_x\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_x]\n    type = NewmarkVelAux\n    variable = vel_x\n    acceleration = accel_x\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_y]\n    type = NewmarkAccelAux\n    variable = accel_y\n    displacement = disp_y\n    velocity = vel_y\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_y]\n    type = NewmarkVelAux\n    variable = vel_y\n    acceleration = accel_y\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_z]\n    type = NewmarkAccelAux\n    variable = accel_z\n    displacement = disp_z\n    velocity = vel_z\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_z]\n    type = NewmarkVelAux\n    variable = vel_z\n    acceleration = accel_z\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [rot_accel_x]\n    type = NewmarkAccelAux\n    variable = rot_accel_x\n    displacement = rot_x\n    velocity = rot_vel_x\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [rot_vel_x]\n    type = NewmarkVelAux\n    variable = rot_vel_x\n    acceleration = rot_accel_x\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [rot_accel_y]\n    type = NewmarkAccelAux\n    variable = rot_accel_y\n    displacement = rot_y\n    velocity = rot_vel_y\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [rot_vel_y]\n    type = NewmarkVelAux\n    variable = rot_vel_y\n    acceleration = rot_accel_y\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n\n[]\n\n[BCs]\n  [fixx1]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom'\n    value = 0.0\n  []\n  [fixy1]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0.0\n  []\n  [fixz1]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom'\n    value = 0.0\n  []\n  [fixr1]\n    type = DirichletBC\n    variable = rot_x\n    boundary = 'bottom'\n    value = 0.0\n  []\n  # [fixr2]\n  #   type = DirichletBC\n  #   variable = rot_y\n  #   boundary = 'bottom'\n  #   value = 0.0\n  # []\n[]\n\n[NodalKernels]\n  [force_y2]\n    type = UserForcingFunctionNodalKernel\n    variable = disp_z\n    boundary = 'top'\n    function = 0.5\n  []\n[]\n\n[Kernels]\n  [solid_disp_x]\n    type = ADStressDivergenceShell\n    component = 0\n    variable = disp_x\n    use_displaced_mesh = true\n  []\n  [solid_disp_y]\n    type = ADStressDivergenceShell\n    component = 1\n    variable = disp_y\n    use_displaced_mesh = true\n  []\n  [solid_disp_z]\n    type = ADStressDivergenceShell\n    component = 2\n    variable = disp_z\n    use_displaced_mesh = true\n  []\n  [solid_rot_x]\n    type = ADStressDivergenceShell\n    component = 3\n    variable = rot_x\n    use_displaced_mesh = true\n  []\n  [solid_rot_y]\n    type = ADStressDivergenceShell\n    component = 4\n    variable = rot_y\n    use_displaced_mesh = true\n  []\n  [inertial_force_x]\n    type = ADInertialForceShell\n    velocities = 'vel_x vel_y vel_z'\n    accelerations = 'accel_x accel_y accel_z'\n    rotational_velocities = 'rot_vel_x rot_vel_y'\n    rotational_accelerations = 'rot_accel_x rot_accel_y'\n    component = 0\n    variable = disp_x\n  []\n  [inertial_force_y]\n    type = ADInertialForceShell\n    velocities = 'vel_x vel_y vel_z'\n    accelerations = 'accel_x accel_y accel_z'\n    rotational_velocities = 'rot_vel_x rot_vel_y'\n    rotational_accelerations = 'rot_accel_x rot_accel_y'\n    component = 1\n    variable = disp_y\n  []\n  [inertial_force_z]\n    type = ADInertialForceShell\n    velocities = 'vel_x vel_y vel_z'\n    accelerations = 'accel_x accel_y accel_z'\n    rotational_velocities = 'rot_vel_x rot_vel_y'\n    rotational_accelerations = 'rot_accel_x rot_accel_y'\n    component = 2\n    variable = disp_z\n  []\n  [inertial_force_rot_x]\n    type = ADInertialForceShell\n    velocities = 'vel_x vel_y vel_z'\n    accelerations = 'accel_x accel_y accel_z'\n    rotational_velocities = 'rot_vel_x rot_vel_y'\n    rotational_accelerations = 'rot_accel_x rot_accel_y'\n    component = 3\n    variable = rot_x\n  []\n  [inertial_force_rot_y]\n    type = ADInertialForceShell\n    velocities = 'vel_x vel_y vel_z'\n    accelerations = 'accel_x accel_y accel_z'\n    rotational_velocities = 'rot_vel_x rot_vel_y'\n    rotational_accelerations = 'rot_accel_x rot_accel_y'\n    component = 4\n    variable = rot_y\n  []\n[]\n\n[Materials]\n  [elasticity]\n    type = ADComputeIsotropicElasticityTensorShell\n    youngs_modulus = 2100000\n    poissons_ratio = 0.0\n  []\n  [strain]\n    type = ADComputeFiniteShellStrain\n  []\n  [stress]\n    type = ADComputeShellStress\n  []\n  [density]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = '1.0'\n  []\n[]\n\n[Postprocessors]\n  [disp_z_tip]\n    type = PointValue\n    point = '1.0 10.0 0.0'\n    variable = disp_z\n  []\n  [rot_x_tip]\n    type = PointValue\n    point = '0.0 10.0 0.0'\n    variable = rot_x\n  []\n  [stress_yy_el_0]\n    type = ElementalVariableValue\n    elementid = 0\n    variable = stress_yy\n  []\n  [stress_yy_el_1]\n    type = ElementalVariableValue\n    elementid = 1\n    variable = stress_yy\n  []\n  [stress_yy_el_2]\n    type = ElementalVariableValue\n    elementid = 2\n    variable = stress_yy\n  []\n  [stress_yy_el_3]\n    type = ElementalVariableValue\n    elementid = 3\n    variable = stress_yy\n  []\n  [stress_yz_el_0]\n    type = ElementalVariableValue\n    elementid = 0\n    variable = stress_yz\n  []\n  [stress_yz_el_1]\n    type = ElementalVariableValue\n    elementid = 1\n    variable = stress_yz\n  []\n  [stress_yz_el_2]\n    type = ElementalVariableValue\n    elementid = 2\n    variable = stress_yz\n  []\n  [stress_yz_el_3]\n    type = ElementalVariableValue\n    elementid = 3\n    variable = stress_yz\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = PJFNK\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = '201 hypre boomeramg 4'\n\n  # solve_type = NEWTON\n  # petsc_options_iname = '-pc_type'\n  # petsc_options_value = 'lu'\n\n  automatic_scaling = true\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-8\n\n  dt = 0.0005\n  dtmin = 0.0005\n  end_time = 1\n\n  timestep_tolerance = 1e-9\n\n  [TimeIntegrator]\n    type = NewmarkBeta\n  []\n[]\n\n[Outputs]\n  print_linear_residuals = false\n  exodus = true\n[]\n\nThe most notable change is in the forcing function. Before, it was mistakenly ramped from 0 to 0.5, and I changed to constant 0.5.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427677",
                          "updatedAt": "2022-06-23T14:43:07Z",
                          "publishedAt": "2021-10-05T02:18:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "WIth these changes, the tip disp_z goes to 1.704083 and tip rot_x goes to 0.2725277. They are much closer, but still not perfect. I'd have to look at the original problem setup to figure whatelse might be wrong.",
                          "url": "https://github.com/idaholab/moose/discussions/18592#discussioncomment-1427681",
                          "updatedAt": "2022-06-23T14:43:18Z",
                          "publishedAt": "2021-10-05T02:20:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can MOOSE work with overlapping subdomains?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys, I'm having trouble uploading Abaqus mesh (with overlapping subdomain) to MOOSE\nMOOSE's meshfile and FileMeshGenerator don't seem to detect the subdomain within the larger subdomain for example the figure below (mining-related)\nthe green and the yellow are the model rock type block and the smaller blocks are the mining activity blocks,\nbut in this case, MOOSE will only see the rock type blocks and completely ignore the smaller blocks\nI need both of them for my workflow, is there a way to deal with this issue?\n\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/19501",
          "updatedAt": "2022-09-27T19:57:11Z",
          "publishedAt": "2021-11-30T00:31:19Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Every element belongs to one and only one subdomain. This has been a fundamental assumption in lots of code in libmesh. You may look into alternatives such as elemental auxvariables and extra element IDs.",
                  "url": "https://github.com/idaholab/moose/discussions/19501#discussioncomment-1728106",
                  "updatedAt": "2022-09-27T19:57:11Z",
                  "publishedAt": "2021-12-01T12:45:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "fail to import pyhit in HPC",
          "author": {
            "login": "ada-ayy"
          },
          "bodyText": "Hello, everyone!\nI have installed moose on the HPC cluster followed by https://mooseframework.inl.gov/getting_started/installation/conda.html.\nWhen I try \"run_tests\" on my login node, they all go on smoothly. But when I submit a task to compute nodes, it always fails with \"fail to import pyhit\".\n$ which python\n~/miniconda3/envs/moose/bin/python\n$ module list\nNo modules loaded\n(for the compute nodes, I sometimes module load intel, but it still fails to import pyhit)\nAnd here is my conda list and ldd result.\nconda list and ldd.txt\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/19483",
          "updatedAt": "2022-07-01T16:17:55Z",
          "publishedAt": "2021-11-25T02:33:54Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIn your submit script, do you load the environment?\neg do you have conda activate moose ?\nNote that the conda install isnt optimal for HPC clusters. You want to look at these instructions for that:\nhttps://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1697747",
                  "updatedAt": "2022-07-20T15:25:26Z",
                  "publishedAt": "2021-11-25T03:50:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "yeah, I have loaded the environment,  when I \"echo $CONDA_DEFAULT_ENV\", both of the login node and compute node return \"moose\"\nI have tried https://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html, but it fails with many problems, so I wonder whether I could use conda to install it.",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1697773",
                          "updatedAt": "2022-07-20T15:25:30Z",
                          "publishedAt": "2021-11-25T04:01:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "My experience is that you can but it wont be as fast. Not sure for the error message. @milljm will know",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1697798",
                          "updatedAt": "2022-07-20T15:25:30Z",
                          "publishedAt": "2021-11-25T04:11:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "Thanks! I will try the hpc_install guide again if the conda doesn't fit.",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1697806",
                          "updatedAt": "2022-07-20T15:25:30Z",
                          "publishedAt": "2021-11-25T04:17:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ada-ayy"
                  },
                  "bodyText": "@milljm Hello! Do you have any suggestions for me?",
                  "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1713236",
                  "updatedAt": "2022-07-20T15:25:33Z",
                  "publishedAt": "2021-11-29T01:25:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Are you using qsub to launch a job? If so, can we see the qsub script?\nHave you tried to perform the same things in this qsub script, manually, using qsub -I. -I launches an interactive session on a node, allowing you to troubleshoot things like this.\n\"fail to import pyhit\" usually means MOOSE is attempting to be run with a different environment than it was built with. So we're looking for reasons why \"conda activate moose\" may not be occurring during your job submission routine.\nINL HPC?\nWhich HPC cluster are we talking about? One of ours at INL? If so, we have modules available that are better suited to running MOOSE instead of using Conda's \"non-optimized compilers\". Concerning Falcon, Lemhi, and Sawtooth, the general instructions for obtaining these compilers is:\nmodule load use.moose PETSc",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1716617",
                          "updatedAt": "2022-07-20T15:25:32Z",
                          "publishedAt": "2021-11-29T15:22:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Also, sorry @ada-ayy. I am going through my email after a long period of inactivity (thanksgiving holiday for us), and I just made it to yours (about me asking you to create a new discussion). I was keeping my eye out for one from you, but it slipped through my attention...",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1716780",
                          "updatedAt": "2022-07-20T15:25:33Z",
                          "publishedAt": "2021-11-29T15:50:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "Never mind, I'm not in a hurry :\uff09\nI use sbatch script (slurm system)  to submit my task.\nThe HPC cluster I use is from my university, not INL. I do not use the default conda environment in my cluster, but create a new one within my home directory. Maybe this is the problem?\nThe operating system is CentOS 7.6.\nThis is my script:\n#!/bin/bash\n#SBATCH -p cpu-normal \n#SBATCH -J moosetest\n#SBATCH -N 1\n#SBATCH -n 4\n#SBATCH  -t 1:00:00\n\nsrun hostname | sort > machinefile.${SLURM_JOB_ID}\n\nNP=`cat machinefile.${SLURM_JOB_ID} | wc -l`\n\n#conda activate moose\n#module load intel/19.0.5.281\n\n#make hit\n\n#srun -n 4 ./run_tests \n./run_tests -j 4",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1719673",
                          "updatedAt": "2022-07-20T15:25:39Z",
                          "publishedAt": "2021-11-30T03:01:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I am not understanding this batch script... it looks like conda activate moose is commented out. Pretty sure you want this line to actually run. I would uncomment that as the first step.",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1722617",
                          "updatedAt": "2022-12-11T13:52:04Z",
                          "publishedAt": "2021-11-30T14:35:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "yeah, I have tried, but failed with the same problem again. Maybe it is more related to the environment of my HPC cluster. I will ask the administer for advice or try another way to install moose. Thanks again!",
                          "url": "https://github.com/idaholab/moose/discussions/19483#discussioncomment-1725818",
                          "updatedAt": "2022-12-11T13:52:04Z",
                          "publishedAt": "2021-12-01T02:23:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Use \"if-else\" in input file & set initial value for post-processor",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Because I'm working on several themes simultaneously, I made several discussion...\nI'm sorry about that.\nFirst question is\n\"How to use \"if-else\" statement in an input file?\"\n\nI tried to use \"if-else\" statement, but this failed.. I also tried to find an appropriate example for what I need. It was hard to find.\nfor example, what I want to do is\nif (time=0) {'vals = 0 1.03665 0.4'}\nelse {'vals = 0.03607 1.03665 0.4'}\nSecond question is\n\"How to assign the initial value (initialization) for post-processor?\"\nFrom the previous discussion that I made, I knew Postprocessor is not being executed at the 0th timestep.\nSo, introducing execute_on = 'initial timestep_end' in the postprocessor will work.\nHowever, what I want to do now is \"assign a specific value for postprocessor at 0th step\"\nFor my function like below,\n\nI need to assign 0 on postprocessor \"numerical_phi_YSZ\" at 0th step to make it work correctly.",
          "url": "https://github.com/idaholab/moose/discussions/18247",
          "updatedAt": "2022-07-19T18:51:24Z",
          "publishedAt": "2021-07-02T22:59:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo this is fine, a discussion for each topic is definitely the way to go.\nIn general, you can use the Controls system to enable/disable blocks, to make if-else like statements.\nBut for a parsed function, you can use this syntax:\n  [./const_ref]\n    type = ParsedFunction\n    value = '\n            ix := if(x < 0.5, 0, if(x < 1, 1, 2));\n            iy := if(y > 0, 2, if(y > -0.5, 1, 0));\n            iy * 3 + ix\n            '\n  [../]\n\nYou cant do that for postprocessors. If executing at the initial timestep does not work for you, then you need to use an if-else statement there too.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18247#discussioncomment-958781",
                  "updatedAt": "2022-07-19T18:16:19Z",
                  "publishedAt": "2021-07-02T23:09:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "First you dont need this:\nmaterial_property_names = k\nk does not come in the function expression\nthen I just tested your block with this input file below and it gave 0.024 as expected:\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 10\n  ny = 10\n[]\n\n[Variables]\n  [u]\n  []\n[]\n\n[Kernels]\n  [diff]\n    type = Diffusion\n    variable = u\n  []\n[]\n\n[BCs]\n  [left]\n    type = DirichletBC\n    variable = u\n    boundary = left\n    value = 0\n  []\n  [right]\n    type = DirichletBC\n    variable = u\n    boundary = right\n    value = 1\n  []\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\n[AuxVariables]\n  [temperature]\n    type = MooseVariableFVReal\n    initial_condition = 2000\n  []\n  [k]\n    type = MooseVariableFVReal\n  []\n[]\n\n[AuxKernels]\n  [to_k]\n    type = MaterialRealAux\n    property = k\n    variable = k\n  []\n[]\n\n[Materials]\n  [thermal_conductivity]\n    type = DerivativeParsedMaterial\n    function ='if(temperature<=1268,0.015 ,if(1268<temperature & temperature<=1923, 0.012, 0.024))'\n    args = 'temperature'\n    f_name = k\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nAlso please create your own post, dont hijack someone else's",
                          "url": "https://github.com/idaholab/moose/discussions/18247#discussioncomment-1725665",
                          "updatedAt": "2022-07-19T18:15:59Z",
                          "publishedAt": "2021-12-01T01:28:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Which kernel can model U_xy term",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi\nGiven the following differential equation, which kernel should I use to model the second and the third terms?\n\nOr, I would need to implement a custom one?",
          "url": "https://github.com/idaholab/moose/discussions/19475",
          "updatedAt": "2022-07-12T12:49:37Z",
          "publishedAt": "2021-11-24T18:40:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont know of one but libmesh can compute hessians so it should be possible. @lindsayad do we have this in MOOSE? I had no luck looking in the variable code.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1697841",
                  "updatedAt": "2022-07-12T12:49:37Z",
                  "publishedAt": "2021-11-25T04:32:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "It's possible that somewhere in the MOOSE app eco-system someone has this, but I don't believe we have this in the MOOSE repository itself. So you will likely need to implement a custom one. Is u your nonlinear variable for the equation you posted? If so you can couple in second derivatives of variables. You can look here for an example of using the coupledSecond API. The automatic differentiation (AD) version is adCoupledSecond. I believe the tensor that is returned to you will be upper triangular with the knowledge that partial derivatives commute. So you should always index u_ij with j >= i, I believe. If you don't, you'll probably always get zeroes returned. @roystgnr could potentially weigh in on this last bit",
                  "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1718383",
                  "updatedAt": "2022-07-12T12:50:19Z",
                  "publishedAt": "2021-11-29T20:47:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@jwpeterson would also know about the libMesh hessians and if my reading of the code is right and it's upper triangular, then our current SUPG stabilization for INS is not quite right, e.g. this code should not be as simple as it is now\nRealVectorValue\nINSBase::strongViscousTermTraction()\n{\n  return strongViscousTermLaplace() -\n         _mu[_qp] *\n             (_second_u_vel[_qp].row(0) + _second_v_vel[_qp].row(1) + _second_w_vel[_qp].row(2));\n}",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1718435",
                          "updatedAt": "2022-07-12T12:50:22Z",
                          "publishedAt": "2021-11-29T20:56:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "You should always see u_ij == u_ji; internally we loop over only one triangle's entries when computing basis second derivatives, but we copy the off-diagonal entries into the other triangle too.\nIn hindsight I should have created a SymmetricTensor class, though.  You can write simple kernels thanks to the full tensor being complete, but generally as soon as that's done you want to rewrite them to also only loop over one triangle's entries to again save a few flops.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1718535",
                          "updatedAt": "2022-07-12T12:50:19Z",
                          "publishedAt": "2021-11-29T21:12:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jwpeterson"
                          },
                          "bodyText": "@lindsayad The code you have above looks correct to me. In Cartesian coords and using index notation, the term in question is:\nu_i,jj + u_j,ij\n\nwith summation over the dummy index j, and where the comma represents differentiation. The strongViscousTermLaplace() call gives you the first term, and I checked that the various row calls you make give you the the second term. In cylindrical coords the second derivatives are a bit messier... not sure if we claim to support that.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1718716",
                          "updatedAt": "2022-07-12T12:50:38Z",
                          "publishedAt": "2021-11-29T21:50:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Oh what a dope. I only looking at the comment in the h1 transformation code. Right there in the equalities ... both xy and yx\n              // phi_{x y}\n              d2phi[i][p].slice(0).slice(1) = d2phi[i][p].slice(1).slice(0) = d2phidxdy[i][p] =",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1719270",
                          "updatedAt": "2022-09-15T18:21:43Z",
                          "publishedAt": "2021-11-30T00:58:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "d I checked that the various ro\n\nYesm\n\nIt's possible that somewhere in the MOOSE app eco-system someone has this, but I don't believe we have this in the MOOSE repository itself. So you will likely need to implement a custom one. Is u your nonlinear variable for the equation you posted? If so you can couple in second derivatives of variables. You can look here for an example of using the coupledSecond API. The automatic differentiation (AD) version is adCoupledSecond. I believe the tensor that is returned to you will be upper triangular with the knowledge that partial derivatives commute. So you should always index u_ij with j >= i, I believe. If you don't, you'll probably always get zeroes returned. @roystgnr could potentially weigh in on this last bit\n\nYes, U and W are my nonlinear variables that are coupled and live on the same mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1723925",
                          "updatedAt": "2022-09-15T18:21:46Z",
                          "publishedAt": "2021-11-30T18:15:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jwpeterson"
                  },
                  "bodyText": "@aaelmeli This is a strong form PDE, once you multiply by a test function and apply the divergence theorem, you won't need to use second derivatives, right? Unless I guess you are planning to do some sort of stabilization scheme that requires the strong form...",
                  "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1718753",
                  "updatedAt": "2022-07-12T12:50:51Z",
                  "publishedAt": "2021-11-29T21:58:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Yes, this is the strong form PDE. As you said, I won't need to use the second derivative after forming the weak form, however, I am not aware of a kernel in moose that can model the second term.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1723920",
                          "updatedAt": "2022-07-12T12:50:51Z",
                          "publishedAt": "2021-11-30T18:15:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "aware of a kernel in moose that can model the second term.\n\nYea I don't think we have anything for you. How does this equation generalize to 3D? I'm curious whether there is a nice way to write this with divergence and gradient operators.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1724135",
                          "updatedAt": "2022-07-12T12:50:47Z",
                          "publishedAt": "2021-11-30T18:56:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "In 3D, after some manipulation to the coefficient, this can be written as\n\nYes, that is what I am trying. I am trying to use stress divergence to model this PDE.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1724331",
                          "updatedAt": "2022-07-12T12:50:46Z",
                          "publishedAt": "2021-11-30T19:37:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jwpeterson"
                          },
                          "bodyText": "Your 3D PDE is in the usual divergence form\ndiv \\sigma(u) = b\n\nwhere \\sigma is a stress tensor, so the weak form is also standard,\n-\\int \\sigma(u) : grad test = \\int b . test + boundary terms\n\nNot sure if you need to introduce the auxiliary variables \"theta\" and \"e\", but it should be possible to do in MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/19475#discussioncomment-1724377",
                          "updatedAt": "2022-07-12T12:50:52Z",
                          "publishedAt": "2021-11-30T19:44:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Simulation of solidification structure in additive manufacturing",
          "author": {
            "login": "wowodejiajia"
          },
          "bodyText": "Dear MOOSE developers,\nCan MOOSE simulate solidification structure simulation in additive manufacturing\uff1fIf it can, please give an example.",
          "url": "https://github.com/idaholab/moose/discussions/19385",
          "updatedAt": "2022-07-12T07:15:03Z",
          "publishedAt": "2021-11-15T02:50:08Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "I guess you asked about the phase-field modeling of solidification. @SudiptaBiswas did you add any examples in MOOSE?",
                  "url": "https://github.com/idaholab/moose/discussions/19385#discussioncomment-1642274",
                  "updatedAt": "2022-07-12T07:15:03Z",
                  "publishedAt": "2021-11-15T04:13:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "We have some solidification examples here.",
                          "url": "https://github.com/idaholab/moose/discussions/19385#discussioncomment-1653153",
                          "updatedAt": "2022-07-12T07:15:03Z",
                          "publishedAt": "2021-11-16T17:46:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wowodejiajia"
                          },
                          "bodyText": "Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/19385#discussioncomment-1655650",
                          "updatedAt": "2022-07-12T07:15:03Z",
                          "publishedAt": "2021-11-17T04:08:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @wowodejiajia\nWe have done this recent work:\nhttps://arxiv.org/abs/2105.13257\nwhich is now accepted in Computational Mechanics journal.\nIt is not based on phase field, but on elements moved from active to inactive subdomain and vice versa\nto model solidification.\nThe simulation used in the paper is here:\nhttps://github.com/ngrilli/c_pfor_am/tree/main/test/tests/Paper_ElementEliminationMethod\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/19385#discussioncomment-1656952",
                  "updatedAt": "2022-07-12T07:15:06Z",
                  "publishedAt": "2021-11-17T10:06:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wowodejiajia"
                          },
                          "bodyText": "Thank you very much.",
                          "url": "https://github.com/idaholab/moose/discussions/19385#discussioncomment-1719739",
                          "updatedAt": "2022-07-12T07:15:06Z",
                          "publishedAt": "2021-11-30T03:20:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Peacock segmentation fault on MacOS",
          "author": {
            "login": "brandon-barclay"
          },
          "bodyText": "Hello,\nI have been running into a segmentation fault when trying to run peacock on mac. Have not had any issues running moose apps but I have been unable to visualize results with peacock. I did try paraview but I was also receiving an error there about the format of my output files being incorrect, which I haven't had when using peacock on ubuntu. I am currently on MacOS 12.0.1.\nThanks for your help.",
          "url": "https://github.com/idaholab/moose/discussions/19438",
          "updatedAt": "2022-07-04T08:30:08Z",
          "publishedAt": "2021-11-19T19:59:37Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhich version is your paraview?\nThe latest version complains about something we do with nodesets and sidesets (sharing the same name).\nDowngrading paraview could help. The alternative is to find the legacy exodus reader inside your new paraview. I've been told that's not easy\nOtherwise for peacock I dont know that we support Monterey yet. I ll try to find out\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19438#discussioncomment-1678907",
                  "updatedAt": "2022-07-04T08:30:11Z",
                  "publishedAt": "2021-11-22T00:58:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "It's supposed to work yes... but I can reproduce this issue. More than likely an issue with one of dependency modules for VTK. I'll see if I can isolate it to PyQt, or Qt, etc...\n\u276f uname -r\n21.1.0\n\nInvoking with -i\n\u276f cd tests/kernels/simple_diffusion\n\u276f ../../../../python/peacock/peacock -i simple_diffusion.i\nFound executable: /Users/milljm/projects/moose/test/moose_test-opt\nzsh: bus error  ../../../../python/peacock/peacock -i simple_diffusion.i\n\nJust running peacock.\n\u276f ../../../../python/peacock/peacock\nFound executable: /Users/milljm/projects/moose/test/moose_test-opt\nzsh: segmentation fault  ../../../../python/peacock/peacock",
                          "url": "https://github.com/idaholab/moose/discussions/19438#discussioncomment-1681747",
                          "updatedAt": "2022-07-04T08:30:07Z",
                          "publishedAt": "2021-11-22T14:13:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "brandon-barclay"
                          },
                          "bodyText": "The issue I was having with paraview was the duplicate naming one, so thanks for letting me know. And as well the issue with peacock was producing the same output as above. Thanks for looking into it.",
                          "url": "https://github.com/idaholab/moose/discussions/19438#discussioncomment-1702044",
                          "updatedAt": "2022-07-04T08:30:11Z",
                          "publishedAt": "2021-11-25T18:19:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I can isolate this to being a PyQt/Qt issue. Unfortunately we have a dependency issue preventing us from upgrading to a newer version. While this might not be the 100% fix, this is our dilemma:\n\u276f mamba create -n testing_environment clangxx_osx-64=12 pyqt python=3.9\n\n<trimmed>\n\nLooking for: ['clangxx_osx-64=12', 'pyqt', 'python=3.9']\n\nconda-forge/osx-64       Using cache\nconda-forge/noarch       Using cache\npublic/osx-64            [====================] (00m:00s) No change\npublic/noarch            [====================] (00m:00s) No change\nEncountered problems while solving:\n  - package clangxx_osx-64-12.0.1-h7e1b574_0 requires clang_osx-64 12.0.1 hb91bd55_0, but none of the providers can be installed\nWhile not very forthcoming with the actual dependency error; What the above is trying to tell us is that there exists no version of PyQt for any version of Python higher than 3.7 when also requiring Clang 12.\nThe gist of it is, we have moved on to Clang 12.x compilers, while PyQt has only been built with Clang 12.x for Python 3.7. I think the fix exists in later versions of Python/PyQt/Qt. I will attempt to see if that is the case. Will take some doing (use older version of MOOSE, since Peacock requires pyhit, which is a moose contrib).\nIndeed, throughout this whole process, I've managed to get Peacock to launch correctly 4 times (out of many attempts while using pdb), with no changes to any code (thread buggy?). Seems to be something with:\ndiff --git a/python/peacock/Execute/ExecuteOptionsPlugin.py b/python/peacock/Execute/ExecuteOptionsPlugin.py\nindex 480793cfca..6df59acf86 100755\n--- a/python/peacock/Execute/ExecuteOptionsPlugin.py\n+++ b/python/peacock/Execute/ExecuteOptionsPlugin.py\n@@ -168,12 +168,12 @@ class ExecuteOptionsPlugin(QWidget, Plugin):\n         self._loading_dialog.setInformativeText(app_path)\n         self._loading_dialog.show()\n         self._loading_dialog.raise_()\n-        QApplication.processEvents()\n+        QApplication.sendPostedEvents()\n\n         app_info = ExecutableInfo()\nThat is, something is dying in a PyQt thread process when asking it to perform background tasks (ref: https://doc.qt.io/qt-5/qcoreapplication.html#processEvents).",
                          "url": "https://github.com/idaholab/moose/discussions/19438#discussioncomment-1716902",
                          "updatedAt": "2022-07-04T08:30:11Z",
                          "publishedAt": "2021-11-29T16:10:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Confirmed... while pinning a later Python (3.9), Peacock seems to launch. So far, this is what I am having to do:\n\u276f mamba init             # I am using Mambaforge, replace your commands with `conda` where applicable\n< restart terminal >\n\u276f mamba create -n peacock python=3.9 clangxx_osx-64 clang_osx-64 \\\n  gfortran_osx-64 mpich boa conda-build pyqt pandas matplotlib vtk\n\u276f mamba activate peacock\n< make changes to moose/conda/pyhit, see below diff >\n\u276f cd moose/conda/pyhit\n\u276f mamba mambabuild .     # or `conda build .`\n\u276f mamba install --use-local moose-pyhit\n\u276f mamba deactivate\n\u276f mamba activate peacock # reload environment\n\u276f cd moose/python\n\u276f mv pyhit not_pyhit     # Looks like Peacock prepends this path to syspath, making it impossible\n                         # to load our custom moose-pyhit package instead\n\u276f cd peacock\n\u276f ./peacock              # profit. So far so good. Peacock loads at least.\npyhit package diff (force build pyhit with Clang 11.x and Python 3.9):\ndiff --git a/conda/pyhit/meta.yaml b/conda/pyhit/meta.yaml\nindex 854b57f881..6f252f7792 100644\n--- a/conda/pyhit/meta.yaml\n+++ b/conda/pyhit/meta.yaml\n@@ -1,5 +1,5 @@\n {% set build = 0 %}\n-{% set version = \"2021.10.27\" %}\n+{% set version = \"2021.11.29\" %}\n \n package:\n   name: moose-pyhit\n@@ -14,18 +14,18 @@ build:\n \n requirements:\n   build:\n-    - {{ moose_cxx }}\n-    - {{ moose_python }}\n+    - clangxx_osx-64 11.1.0\n+    - python 3.9\n     - cython\n \n   host:\n-    - {{ moose_cxx }}\n-    - {{ moose_python }}\n+    - clangxx_osx-64 11.1.0\n+    - python 3.9\n     - cython\n \n   run:\n-    - {{ moose_cxx }}\n-    - python\n+    - clangxx_osx-64 11.1.0\n+    - python 3.9\n \n test:\n   imports:\nWith the above partially working, I think it might be possible to use a different environment solely for the purpose of launching Peacock. I'll continue to investigate. You may be thinking; Why not just use Clang 11? Well, Monterey's XCode version(s) do not gibe well with Clang-11. It forced us to move to Clang 12... MOOSE simply doesn't compile correctly under Monterey with Clang-11. @cticenhour is that correct?\n@brandon-barclay I am not exactly asking you to perform the above as a fix. I am just documenting my findings, as I find them. Although if you do wish to build the above, you will need to obtain the 10.9 MacSDK and install it to /opt. I use the conveniently available SDKs from here: https://github.com/phracker/MacOSX-SDKs/releases",
                          "url": "https://github.com/idaholab/moose/discussions/19438#discussioncomment-1717233",
                          "updatedAt": "2022-07-04T08:30:43Z",
                          "publishedAt": "2021-11-29T17:11:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "Monterey (or Big Sur with the most up-to-date Xcode version) just did not work with Clang 11, presumably due to the changes needed in order for Apple to have compatibility with their newer Apple Silicon platforms. The end result was that much of the MOOSE dependencies could be built successfully, but the final build of MOOSE would be riddled with library and linking errors resulting in a broken build. It's very possible Clang-11 could have worked with some heavy effort on Mac Intel systems, but our push for Apple Silicon support preempted any more work on it. Clang 12.0.0 or later holds partially optimized support for that architecture, with more full-featured support coming in Clang-13.",
                          "url": "https://github.com/idaholab/moose/discussions/19438#discussioncomment-1717422",
                          "updatedAt": "2022-07-04T08:30:49Z",
                          "publishedAt": "2021-11-29T17:38:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Looks like using two environments may be the only path forward for now. Also, renaming that \"moose/python/pyhit\" directory is necessary. I'll have to bring all this up with my group, on how to proceed. I like the idea of no longer tying Peacock to moose/python/pyhit. As it seems to work just fine on my end:",
                          "url": "https://github.com/idaholab/moose/discussions/19438#discussioncomment-1717565",
                          "updatedAt": "2022-07-04T08:30:49Z",
                          "publishedAt": "2021-11-29T18:05:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to take grain size into consideration in uniaxial tension",
          "author": {
            "login": "xchengood"
          },
          "bodyText": "Dear Moose expert or users,\nCould anyone share your ideas or thoughts about how to take grain/particle size into consideration in power-law model (https://mooseframework.inl.gov/source/materials/crystal_plasticity/CrystalPlasticityKalidindiUpdate.html) for uniaxial tension simulation and look at how the effect of grain/particle size on the stress-strain curve? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/19199",
          "updatedAt": "2022-06-29T07:39:50Z",
          "publishedAt": "2021-10-25T19:29:57Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "Hi @xchengood,\nYou may like to consider a Hall-Petch type term (for grain size influence) or an impenetrable barrier type model (for embedded particles) as additional hardening terms.\nIn a class that inherits from CrystalPlasticityKalidindiUpdate, I'd recommend either overwriting the method calculateStateVariableEvolutionRateComponent or adding a new constant hardening contribution term that is called in the stateful property initialization method. An example of this second approach is used in the initQpStatefulProperties method of CrystalPlasticityHCPDislocationSlipBeyerleinUpdate.\nHope this helps,\nStephanie",
                  "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1534645",
                  "updatedAt": "2022-06-29T07:39:50Z",
                  "publishedAt": "2021-10-25T19:48:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @xchengood, You may like to consider a Hall-Petch type term (for grain size influence) or an impenetrable barrier type model (for embedded particles) as additional hardening terms.\nIn a class that inherits from CrystalPlasticityKalidindiUpdate, I'd recommend either overwriting the method calculateStateVariableEvolutionRateComponent or adding a new constant hardening contribution term that is called in the stateful property initialization method. An example of this second approach is used in the initQpStatefulProperties method of CrystalPlasticityHCPDislocationSlipBeyerleinUpdate.\nHope this helps, Stephanie\n\nHi @sapitts. Thank you for your information. It is helpful. I am wondering if the example model for HCP you mentioned can be used for FCC or BCC structure. If so, what can I make some modifications to this model (https://github.com/idaholab/moose/blob/next/modules/tensor_mechanics/test/tests/crystal_plasticity/hcp_single_crystal/update_method_hcp_aprismatic_capyramidal.i). Appreciate your help.",
                          "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1540612",
                          "updatedAt": "2022-06-29T07:39:50Z",
                          "publishedAt": "2021-10-26T18:45:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "I'd strongly recommend against using the HCP class for a cubic crystal. As the name suggests, the class I linked to as an example applies assumptions unique to HCP crystal structures. The Kalidindi class that you linked to, source code here, is intended for FCC materials.\nYou will need to write some code to achieve your objective here. I'd advise creating a new class that inherits from CrystalPlasticityKalidindiUpdate and overwrite the initQpStatefulProperties method to add the new slip resistance contributions",
                          "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1541687",
                          "updatedAt": "2022-06-29T07:40:06Z",
                          "publishedAt": "2021-10-26T22:30:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "I'd strongly recommend against using the HCP class for a cubic crystal. As the name suggests, the class I linked to as an example applies assumptions unique to HCP crystal structures. The Kalidindi class that you linked to, source code here, is intended for FCC materials.\nYou will need to write some code to achieve your objective here. I'd advise creating a new class that inherits from CrystalPlasticityKalidindiUpdate and overwrite the initQpStatefulProperties method to add the new slip resistance contributions\n\nHi @sapitts. Very appreciate your information.  The method of CrystalPlasticityHCPDislocationSlipBeyerleinUpdate you mentioned is developed based on the paper (https://www.sciencedirect.com/science/article/pii/S074964190700109X). My questions are below.\n\n\nDoes that method for HCP take the the VPSC model menthoned in the paper into consideration? If not, could you share any ideas about how to combine VPSC model to that method with me? So that I can apply the model to polycrystal.\n\n\nHow can I get and output pole figures presented in the paper in Moose?\n\n\nI see there are many variables referring to slip resistance and forest dislocation and substructure dislocation in the program (https://github.com/idaholab/moose/blob/next/modules/tensor_mechanics/test/tests/crystal_plasticity/hcp_single_crystal/update_method_hcp_aprismatic_active.i). Could you explain more about those variables in Postprocessors module? I also want to study the slip resistance, forest and substructure dislolcation change with time or temperature. But I am confused about the specific meaning of each variable.\n\n\nThanks a lot.",
                          "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1622909",
                          "updatedAt": "2022-06-29T07:40:07Z",
                          "publishedAt": "2021-11-10T23:36:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @xchengood\nI have implemented some time ago the Beyerlein, Tome model in MOOSE:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainCrystalPlasticityUranium.C\nThis is based on forest and substructure dislocation densities as state variables.\nVPSC is not really a constitutive model but it is a type of solver, different from the finite element method in MOOSE.\nVPSC means that each grain is considered immersed into a uniform medium and treated as Eshelby inclusion to calculate the plastic deformation. It's different from CPFEM.\nConverting a pole figure from a paper into grain orientations is generally complicated,\nyou could parse the colours in the figure, convert into a distribution function, then use monte carlo methods\nto pick grain orientations.\nIt's better if you ask to the corresponding author if they can provide the original Euler angles data.\nBest Regards,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1623062",
                          "updatedAt": "2022-06-29T07:40:58Z",
                          "publishedAt": "2021-11-11T00:32:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Hi @xchengood,\n\nAs @ngrilli describe, the crystal plasticity FEM implementation in MOOSE is different from the VPSC implementation described in Beyerlein and Tome, although both can use the same constitutive models. An overview of the crystal plasticity algorithm is given on the documentation page for ComputeMultipleCrystalPlasticityStress. There are many papers by Tome and collaborators to describe VPSC.\nWe do not currently have the capability to generate pole figures in MOOSE. We certainly do accept pull requests though!\nThe slip resistance, forest dislocations, and substructure density are explained in the documentation page for CrystalPlasticityHCPDislocationSlipBeyerleinUpdate as well as the papers cited on that documentation page. The numbers appended to the slip resistance and forest dislocations in the input file correspond to specific slip systems, in the order given in the text file hcp_aprismatic_capyramidal_slip_sys.txt.\n\nIf you'd like to discuss this HCP class and/or the forest dislocations and slip resistances further, please open a new discussion post specific to this new topic. In that way we will be best following the discussion board guidelines.  Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1626509",
                          "updatedAt": "2022-06-29T07:41:01Z",
                          "publishedAt": "2021-11-11T15:20:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Hi @ngrilli,\nIt'd be great if you would be open to making a pull request to MOOSE for your crystal plasticity code, after generalizing the material and switching to the latest base class version. @dewenyushu has performed some bench-marking which shows that the ComputeMultipleCrystalPlasticityStress and CrystalPlasticityStressUpdateBase version is faster. We've also fixed some bugs from the older FiniteStrainCrystalPlasticity and UserObject versions. We'd be glad to assist you in navigating the documentation and testing requirements for a MOOSE pull request.\nIt would be nice to have contributed code from our community of crystal plasticity users in the MOOSE repository!\nBest Regards,\nStephanie",
                          "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1626558",
                          "updatedAt": "2022-06-29T07:41:01Z",
                          "publishedAt": "2021-11-11T15:31:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Hi @sapitts\nI have only recently learned the User Object Crystal Plasticity code,\ntherefore my previous code is mainly done using the monolithic version.\nI think my code for the Beyerlein, Tom\u00e9 model is very similar to CrystalPlasticityHCPDislocationSlipBeyerleinUpdate\nI have other classes that may be interesting to the MOOSE CP community,\nI have recently coupled CP and phase field fracture:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainUObasedCPDamageVol.C\nmy understanding is that there is no way to do that with existing classes.\nAnother interesting development is the implementation of continuum dislocation dynamics with transport equations,\nthe model by Thomas Hochrainer, Stefan Sandfeld, Michael Zaiser, Peter Gumbsch:\nhttps://www.sciencedirect.com/science/article/pii/S0022509613001877\ncoupled with the CP model using Orowan's law, but it's still using the monolithic code:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainCrystalPlasticityDislo.C\nIt works but the code is poorly written and need to be improved.\nI did the pull request procedure once about 5 years ago and I may still remember how to do.\n@DaijunHU is working with me on this\nand we will be happy to contribute in the future.\nWe will let you know once we are ready.\nBest Regards,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1640903",
                          "updatedAt": "2022-06-29T07:41:40Z",
                          "publishedAt": "2021-11-14T18:35:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @sapitts @ngrilli . Thank you very much for your information. I really learned a lot. But I still have some confusion.\n\n\nAs you mentioned 'the VPSC is a kind of solver and it is a constitutive model', is there VPSC solver in Moose? If so, how to use it and are there any examples? If not, How can I apply the HCP model to polycrystal, not only for single crystal?\n\n\nI also want to study how the stress-strain curve change with temperature. I add the the following block to the [AuxKernels]\n[temperature]\ntype = FunctionAux\nvariable = temperature\nfunction = '300+400*t' # temperature increases at a constant rate\nexecute_on = timestep_begin\n[]\nIs my method correct? Basically, I got stress-strain curve at 300K and 1600K. The yield strength shows significant decrease, but the Young's modulus does not show any change. Two curves have the same slope. This does not make sense. If my method is not correct, could you share any ideas with me? Basically, the Young's modulus should decrease with the increase of temperature.\n\n\nThank you. Best wishes!",
                          "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1652754",
                          "updatedAt": "2022-06-29T07:42:02Z",
                          "publishedAt": "2021-11-16T16:39:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Hi @xchengood,\nPlease make a new discussion post to discuss these new issues. A new discussion post, with a title to capture these questions about including temperature effects and multiple crystals , will help other users find our discussion in the future.\nThanks,\nStephanie",
                          "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1652843",
                          "updatedAt": "2022-06-29T07:42:24Z",
                          "publishedAt": "2021-11-16T16:53:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @xchengood, Please make a new discussion post to discuss these new issues. A new discussion post, with a title to capture these questions about including temperature effects and multiple crystals , will help other users find our discussion in the future.\nThanks, Stephanie\n\nHi @sapitts Thank you. I will make a new discussion post.",
                          "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1653695",
                          "updatedAt": "2022-06-29T07:42:25Z",
                          "publishedAt": "2021-11-16T19:32:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dewenyushu"
                  },
                  "bodyText": "How can I get and output pole figures presented in the paper in Moose?\n\nWe had some issues calculating the updated Euler angles. I am working on a PR (#19494) to fix this issue and enable the capability to output updated Euler angles.\nTo visualize the texture, you will need to output the updated Euler angles in .csv files via appropriate postprocessors, and then use additional tools, e.g., MTEX, to plot the pole figures.",
                  "url": "https://github.com/idaholab/moose/discussions/19199#discussioncomment-1717192",
                  "updatedAt": "2022-06-29T07:40:10Z",
                  "publishedAt": "2021-11-29T17:04:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "SUPG tau stabilization parameter for temperature",
          "author": {
            "login": "smpark7"
          },
          "bodyText": "I've been using the INSAD kernels with SUPG and PSPG to model molten salt flow and temperature advection-diffusion in a lid-driven cavity with a volumetric heat source (fission) and sink. The tau parameter for temperature advection-diffusion in INSADStabilized3Eqn.C has an additional term in transient simulations that depends on the timestep size (4/dt**2).\nFor non-large timesteps in advection-dominated flow, this timestep term effectively eliminates the artificial diffusion from SUPG on \"non-physical\" boundary points like the top left corner of the lid-driven cavity where the velocity value is zero. This causes the temperature value on the corner to plunge and creates spurious oscillations in the temperature along the boundary when using natural BCs.\nI looked through the MOOSE INS Overview paper and tried looking at other resources but I couldn't find any references for the derivation of this term. Is this term in tau necessary for transient simulations?",
          "url": "https://github.com/idaholab/moose/discussions/17185",
          "updatedAt": "2022-06-05T03:56:33Z",
          "publishedAt": "2021-03-02T19:09:47Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Tagging @pbalest and @snschune  as they will know more on what reference was followed for this implementation.\nIs stabilization required for your use case?",
                  "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-491173",
                  "updatedAt": "2022-06-05T03:56:35Z",
                  "publishedAt": "2021-03-16T22:20:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "Yes the prandtl number of the lid-driven cavity with molten salt is ~300k so it produces worse numerical oscillations in the temperature without stabilization.\nI also tried removing the timestep-dependent term in the tau parameter before running with SUPG stabilization. At steady state, the temperature values along the vertical and horizontal lines passing through the middle of the cavity are close to literature-reported values. The \"non-physical\" temperature value observed on the top-left corner is steady and does not induce oscillations in other parts of the domain like what I described in my initial post above.",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-493280",
                          "updatedAt": "2022-06-05T03:56:35Z",
                          "publishedAt": "2021-03-17T11:51:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Thanks for the additional information.\nWould you consider using our new finite volume capabilities? It should be able to remove unphysical corner values which can be simply caused by difficulties in applying boundary conditions there.\nThere are examples of lid-driven cavities in modules/navier_stokes/test/tests/finite_volume/ins/lid-driven",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-494087",
                          "updatedAt": "2022-06-05T03:56:35Z",
                          "publishedAt": "2021-03-17T14:42:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "Yes I'll definitely look into INSFV for future work!",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-512610",
                          "updatedAt": "2022-06-05T03:56:37Z",
                          "publishedAt": "2021-03-22T11:15:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@jwpeterson I believe I added that transient contribution to the tau parameter based off information in one of your fluids textbooks which I liked to steal and unfortunately can no longer steal \ud83d\ude06 I don't suppose you know the reference?",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-1689654",
                          "updatedAt": "2022-08-26T19:40:59Z",
                          "publishedAt": "2021-11-23T19:09:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We want to emphasize our FV capability but I still want to ensure that our FE capabilities are as good as they can be",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-1689656",
                          "updatedAt": "2022-08-26T19:40:59Z",
                          "publishedAt": "2021-11-23T19:10:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "Thanks for checking in on this thread. May I ask what's the current status on coupling and other supporting features in the NS FV system? I've seen the conference papers on Griffin & Pronghorn which showcased tight coupling through the multiapp system (please correct me if I'm wrong). Is direct coupling to FE variables a work-in-progress?",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-1689918",
                          "updatedAt": "2022-08-26T19:40:59Z",
                          "publishedAt": "2021-11-23T19:55:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We have coupled FV variables to FE physics, but not the other way around yet. @csdechant was working on FE variables to FV physics in #18394 but we seem to have stalled a little.\nI have been focused on the fluid flow physics development for FV, but others like @GiudGiud have applied it in more multiphysics contexts, with neutronics for instance. For neutronics coupling I believe that has been done with multiapps. But energy transport and passive scalar transport can certainly be solved in a single monolithic system (using FV variables for all)",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-1690292",
                          "updatedAt": "2022-08-26T19:40:59Z",
                          "publishedAt": "2021-11-23T21:15:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jwpeterson"
                  },
                  "bodyText": "I don't suppose you know the reference?\n\nI'm not sure what the original reference is, but my understanding is that this \"sum of reciprocals\" formula became a pseudo-standard approach in the early literature. See for example Eq. (18) and the discussion leading up to it in Tezduyar & Osawa, CMAME 190 (2000), p. 411-430 (attached).\nThe main idea is that in the limit as dt -> 0, tau -> dt/2, which I think relates back to the (even older) Taylor-Galerkin  stabilization method. On the other hand if dt is not small and |u|~0, then tau -> C * h^2 / nu, i.e. the classical diffusive limit for SUPG.\n\nYes the prandtl number of the lid-driven cavity with molten salt is ~300k\n\nThe Prandtl number for molten salt is .003 according to Wikipedia?\nTezduyar_CMAME_2000.pdf",
                  "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-1689889",
                  "updatedAt": "2022-06-05T03:56:37Z",
                  "publishedAt": "2021-11-23T19:50:35Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "Thank you for the references. I've also since found one other publication by the same author providing that tau formulation (link), but without as much derivation.\n\nThe Prandtl number for molten salt is .003 according to Wikipedia?\n\nThat appears to be the Prandtl number for molten potassium metal, rather than molten salt.",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-1690014",
                          "updatedAt": "2022-06-06T08:48:59Z",
                          "publishedAt": "2021-11-23T20:18:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jwpeterson"
                          },
                          "bodyText": "OK, well, a Prandtl number that large would mean that the thermal boundary layer is much, much, much thinner than the momentum boundary layer, so the mesh that you would need to capture the thermal boundary layer accurately would be much finer than that needed for capturing the velocity boundary layer. You might have better luck with a decoupled approach, as I would also expect thermal changes and momentum changes to happen on very different time scales, i.e. the two things would be almost decoupled from one another physically.",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-1690028",
                          "updatedAt": "2022-06-06T08:48:59Z",
                          "publishedAt": "2021-11-23T20:20:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpark7"
                          },
                          "bodyText": "I see. Thank you for the insights!",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-1690621",
                          "updatedAt": "2022-06-06T08:48:59Z",
                          "publishedAt": "2021-11-23T22:41:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "doquang"
                          },
                          "bodyText": "@jwpeterson - Do you mean the decoupled approach is the MultiApp in Moose?",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-1708642",
                          "updatedAt": "2022-08-26T19:40:59Z",
                          "publishedAt": "2021-11-27T08:55:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jwpeterson"
                          },
                          "bodyText": "@doquang Yes, MultiApps would be one way to implement a decoupled approach in MOOSE. This would allow you to e.g. use different time steps and different meshes for the momentum and thermal equations. I don't know much about the details of what you are doing, though, so decoupling the equations is just my initial instinct upon hearing about the high Prandtl number. Keeping the equations coupled would make sense if the Pr was up to O(10) or so.",
                          "url": "https://github.com/idaholab/moose/discussions/17185#discussioncomment-1713719",
                          "updatedAt": "2022-08-30T19:15:55Z",
                          "publishedAt": "2021-11-29T05:14:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}