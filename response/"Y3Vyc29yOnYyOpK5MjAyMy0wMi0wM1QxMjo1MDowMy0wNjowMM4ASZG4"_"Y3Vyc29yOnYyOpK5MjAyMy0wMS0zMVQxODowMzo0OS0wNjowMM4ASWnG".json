{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wMS0zMVQxODowMzo0OS0wNjowMM4ASWnG"
    },
    "edges": [
      {
        "node": {
          "title": "Spherical particles within a medium: modelling heat flows",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Hi everyone,\nA collaborator of mine is considering the problem in which a hot fluid flows through a medium that contains a number of cool, solid spheres.  Let's call the space in which the fluid flows the \"interstellar space\" and the spheres \"planets\".  The fluid slowly heats the planets, via heat transfer and heat conduction through the spherical body, which cools the fluid via heat transfer.   Let's think of ways this could be modelled.\nHere's one way: create a conforming mesh (so the mesh contains the interstellar space (eg block=1) and the planets (eg block=2)).  Use NavierStokes or PorousFlow to flow through the interstellar space, use heat conduction to solve heat conduction in the planets, and a heat-transfer coefficient between them both.\nBut my collaborator is wondering: what if the planets are spherical and small, so that perhaps their temperature distribution can be considered a function of radius alone?  (If they were big then the parts facing the fluid source would heat first, but in this Discussion, let's assume this is unimportant.)  Then perhaps we could treat them in a separate MultiApp, with a spherically-symmetric type of Problem?   Ideas?",
          "url": "https://github.com/idaholab/moose/discussions/23262",
          "updatedAt": "2023-02-03T18:48:49Z",
          "publishedAt": "2023-01-26T22:32:46Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Andy\nBoth these approaches are feasible.\nIn fact something similar is performed using the NEAMS tools for pebble bed reactors.\nThe first idea seems feasible though maybe a tad computationally expensive, depending on the fluid flow regime and the size of the meshes for heat conduction and for fluid flow.\nThe second idea is performed in this example on the Virtual Test Bed for pebble bed reactor simulations\nYou need Pronghorn to run these inputs, but taking a look it's fairly obvious what is being done\nhttps://github.com/idaholab/virtual_test_bed/blob/devel/pbfhr/steady/ss1_combined.i\nThe fluid flow is the ss1 input, then the ss3 input is a coarse mesh representing the pebble locations, and ss4 inputs are pebbles (planets here) that exchange surface boundary conditions.\nThe MultiApp are 1D spherical calculations. They receive the surface fluid temperature for the heat conduction problem.\nThey do not send back any info to the fluid solve. They would be sending a heat flux, but we do that separately here.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23262#discussioncomment-4800084",
                  "updatedAt": "2023-01-27T19:23:29Z",
                  "publishedAt": "2023-01-27T19:23:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Wow, this is great, thank you @GiudGiud .  My collaborator (Julia) will be studying that input file in lots of detail!",
                          "url": "https://github.com/idaholab/moose/discussions/23262#discussioncomment-4801042",
                          "updatedAt": "2023-01-27T21:54:04Z",
                          "publishedAt": "2023-01-27T21:54:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "JuliaHLee"
                          },
                          "bodyText": "Thanks a lot, @WilkAndy  and @GiudGiud!\nI am the collaborator who asked for help. It is great to know that there is an example for this kind of problem. I would like to try to run this input files using MultiApp. But when I tried to get information about Pronghorn on the MOOSE website, I found that the access seems to be protected. I assume that I will need to install Pronghorn first to run these input files, right? Could you let me know if I can get access to the information about Pronghorn and installation of the app?\nI hope the discussion is still opened to ask further on this issue. It would be great if I get a clue about using the app.\nBest regards,\nJulia",
                          "url": "https://github.com/idaholab/moose/discussions/23262#discussioncomment-4860107",
                          "updatedAt": "2023-02-03T09:19:59Z",
                          "publishedAt": "2023-02-03T09:19:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nPronghorn is export controlled. You ll have to ask for access here and let us know\nIt can take a couple weeks depending on when you apply and when they meet to consider your application\nhttps://ncrcaims.inl.gov/Identity/Account/Login\n@aprilnovak 's thesis has all the equations that are implemented in Pronghorn wrt to porous media with \"pebbles\", including the distributed spherical simulations\nPronghorn manual can help too\nhttps://inldigitallibrary.inl.gov/sites/sti/sti/Sort_24425.pdf\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/23262#discussioncomment-4864121",
                          "updatedAt": "2023-02-03T16:55:59Z",
                          "publishedAt": "2023-02-03T16:55:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "Hi all, thanks for the interest in this! I want to note that the heterogeneous heat conduction method in Pronghorn (i.e. the multiscale method used to approximate particle temperatures distributed through a medium) is almost entirely accessible through open-source parts of MOOSE. I believe there is just one object in Pronghorn (a LinearCombinationMatchedValueBC that sets a dirichlet value as coupled Variable + Postprocessor) that you'd need to do this open-source.\nAs part of other work at ANL, I was planning in the next few months to move that one object into the open-source part of MOOSE (because it's so generic it has nothing to do with nuclear physics), effectively making the heterogeneous heat conduction approach open-source.",
                          "url": "https://github.com/idaholab/moose/discussions/23262#discussioncomment-4865058",
                          "updatedAt": "2023-02-03T18:48:50Z",
                          "publishedAt": "2023-02-03T18:48:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Auxvariable as a function of position along a specified distance/length in the model",
          "author": {
            "login": "batodon"
          },
          "bodyText": "Hello, I\u2019m using the ParsedFunction to implement an Auxvariable that depends on a specific execution time (e.g., timestep_end) and position along a distance (e.g., along the x-axis) in the model. My function should look like this:\nZ= R/sqrt(t), where R is the position along the specified length and t is the execution time. Could anyone please help with possible leads? Here is a snippet of my code. Thank you.\n[Functions]\n  [sol_variable]\n   type = ParsedFunction \n   value = ??\n  []\n[] \n\n[AuxKernels]\n [Z]\n    type = FunctionAux\n    variable = Z\n    function = sol_variable\n []\n[]\n\n[AuxVariables]\n [Z]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23333",
          "updatedAt": "2023-02-03T18:41:39Z",
          "publishedAt": "2023-02-02T23:30:36Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "timestep_end is not a variable\nIt should be t for time",
                  "url": "https://github.com/idaholab/moose/discussions/23333#discussioncomment-4856749",
                  "updatedAt": "2023-02-02T23:41:11Z",
                  "publishedAt": "2023-02-02T23:41:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Sure @GiudGiud. Sorry, that value in the ParsedFunction is not correct. It is just an 'example' to show what I really want to implement \ud83d\ude0a.",
                          "url": "https://github.com/idaholab/moose/discussions/23333#discussioncomment-4856817",
                          "updatedAt": "2023-02-02T23:56:22Z",
                          "publishedAt": "2023-02-02T23:54:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "do this then (with a new version of MOOSE, we changed the parameters)\n[Functions]\n  [sol_variable]\n   type = ParsedFunction \n   expression = R/sqrt(t)\n   symbol_names = R\n   symbol_values = \"${R}\"\n  []\n[] \n\nR being defined somewhere else in the input file as\nR = some_value\n\nif R is not a constant. you ll need to adapt this",
                          "url": "https://github.com/idaholab/moose/discussions/23333#discussioncomment-4856839",
                          "updatedAt": "2023-02-02T23:58:51Z",
                          "publishedAt": "2023-02-02T23:58:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Ok. I got you. How will I define R, though? R is the position along the entire length of my domain (for example, the x-axis). I want to output my final result at (let's say) 10 positions/points along the x-axis.",
                          "url": "https://github.com/idaholab/moose/discussions/23333#discussioncomment-4856935",
                          "updatedAt": "2023-02-03T00:09:15Z",
                          "publishedAt": "2023-02-03T00:08:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh then use x instead of R\nyou can then get rid of these two lines\nsymbol_names = R\nsymbol_values = \"${R}\"\nfor output, use a vectorpostprocessor\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/LineFunctionSampler.html",
                          "url": "https://github.com/idaholab/moose/discussions/23333#discussioncomment-4856950",
                          "updatedAt": "2023-02-03T00:11:45Z",
                          "publishedAt": "2023-02-03T00:11:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Great, this is exactly what I want (the vectorpostprocessor). Thanks, Guillaume.  \ud83d\udc4d",
                          "url": "https://github.com/idaholab/moose/discussions/23333#discussioncomment-4856977",
                          "updatedAt": "2023-02-03T00:15:09Z",
                          "publishedAt": "2023-02-03T00:15:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Hello @GiudGiud, probably trivial, but I tried using the log function in my ParsedFunction, but the input file did not accept it. How could I do this, please? I want a function like Z= log(x/sqrt(t)). Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/23333#discussioncomment-4864668",
                          "updatedAt": "2023-02-03T17:59:03Z",
                          "publishedAt": "2023-02-03T17:59:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It should\nsee this manual for what is supported\nhttp://warp.povusers.org/FunctionParser/fparser.html",
                          "url": "https://github.com/idaholab/moose/discussions/23333#discussioncomment-4864826",
                          "updatedAt": "2023-02-03T18:20:33Z",
                          "publishedAt": "2023-02-03T18:20:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stitch Mesh",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello MOOSE experts,\nI am trying to stitch three meshes and getting the following error:\nErrors:\nIn UnstructuredMesh::stitch_meshes:\nThis mesh has 7 nodes on boundary 2.\nOther mesh has 7 nodes on boundary 0.\nMinimum edge length on both surfaces is 1.66667e-06.\nIn UnstructuredMesh::stitch_meshes:\nFound 7 matching nodes.\n\n*** ERROR ***\nstd::bad_alloc\n\n*** ERROR ***\nstd::bad_alloc\n\n*** ERROR ***\nstd::bad_alloc\n\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 2\n\n*** ERROR ***\nstd::bad_alloc\n\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 3\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 1\n\nMesh Generators:\nd = 10e-6\ny_copper = 10e-6\ny_buffer = 11e-6\ny_silicon = 25e-6\n\nNodes_x = 6  # 6 nodes for 10e-6 length\n\n\n[Mesh]\n\ncoord_type = RZ\n\n [./gen1]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = ${Nodes_x}\n    ny = 5\n    xmin = 0\n    xmax = ${d}\n    ymin = 0\n    ymax = ${y_copper}\n  [../]\n  [bottom_block]\n    type = SubdomainIDGenerator\n    input = gen1\n    subdomain_id = 0\n  []\n\n  [./gen2]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = ${Nodes_x}\n    ny = 7\n    xmin = 0\n    xmax = ${d}\n    ymin = ${y_copper}\n    ymax = ${y_buffer}\n  [../]\n  [middle_block]\n    type = SubdomainIDGenerator\n    input = gen2\n    subdomain_id = 1\n  []\n\n  [./gen3]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = ${Nodes_x}\n    ny = 7\n    xmin = 0\n    xmax = ${d}\n    ymin = ${y_buffer}\n    ymax = ${y_silicon}\n  [../]\n  [top_block]\n    type = SubdomainIDGenerator\n    input = gen3\n    subdomain_id = 2\n  []\n\n  [two_blocks]\n    type = StitchedMeshGenerator\n    inputs = 'bottom_block middle_block top_block'\n    clear_stitched_boundary_ids = true\n    stitch_boundaries_pairs = 'top bottom top bottom'\n    parallel_type = 'replicated' \n  []\n[]\n\nCan you please help me to figure out the solution? Thank you.\nBest,\nAvtar",
          "url": "https://github.com/idaholab/moose/discussions/23332",
          "updatedAt": "2023-02-03T16:37:19Z",
          "publishedAt": "2023-02-02T23:21:56Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe error message is not great but basically the stitiching failed.\nThe meshes are overlapping. Is this desired?\nI think you actually want to adjust xmin and xmax in every generator to make them stack?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23332#discussioncomment-4856665",
                  "updatedAt": "2023-02-02T23:24:46Z",
                  "publishedAt": "2023-02-02T23:24:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Hello Guillaume,\nYes, I want them to be of same radius. I am stacking them in y-direction keeping length in r-direction same.\nIf I do only two blocks its working. As soon as I add third, the error pops up.\nBest,\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/23332#discussioncomment-4856677",
                          "updatedAt": "2023-02-02T23:34:47Z",
                          "publishedAt": "2023-02-02T23:27:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok just use two stitcher blocks then and we ll look at it",
                          "url": "https://github.com/idaholab/moose/discussions/23332#discussioncomment-4856736",
                          "updatedAt": "2023-02-02T23:38:54Z",
                          "publishedAt": "2023-02-02T23:38:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Sorry for misunderstanding.\nBy two blocks, I mean if I stitched two meshes its working. As soon as I added third mesh, I am getting the above error.\nI tried to add two stitched blocks, its not working as well and getting the following error:\nYour MeshGenerator tree contains multiple possible generator outputs :\n\"two_blocks_2 and one or more of the following from an independent set: \"bottom_block, gen1, two_blocks_1\"\n\nThis may be due to a missing dependency or may be intentional. Please select the final MeshGenerator in\nthe [Mesh] block with the \"final_generator\" parameter or add additional dependencies to remove the ambiguity.\n\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/23332#discussioncomment-4856758",
                          "updatedAt": "2023-02-02T23:44:51Z",
                          "publishedAt": "2023-02-02T23:43:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You need to make sure there is one generator at the end of the tree of generators.\nRight now it s not clear what the last one is, you need to make sure all the meshes end up in the same mesh.\nMaybe you need to stitch the intermediate stitched mesh and the 3rd mesh together?",
                          "url": "https://github.com/idaholab/moose/discussions/23332#discussioncomment-4856913",
                          "updatedAt": "2023-02-03T00:03:48Z",
                          "publishedAt": "2023-02-03T00:03:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Resolved.\nThanks,\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/23332#discussioncomment-4863950",
                          "updatedAt": "2023-02-03T16:37:16Z",
                          "publishedAt": "2023-02-03T16:37:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Keep mesh centered without pinning nodes?",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "I'm trying to recreate some Abaqus results in MOOSE. To more easily measure model distortions, the mesh is kept centered by applying constraints that force the displacements of certain nodes (corner nodes for example) to sum to zero. In Abaqus you can also explicitly set the rotational degrees of freedom to zero so there is no rigid body motion.\nI have written a NodalKernel for MOOSE that does the mesh centering, but some rotation can still occur. Is there a way I can prevent rotations without pinning nodes?",
          "url": "https://github.com/idaholab/moose/discussions/23063",
          "updatedAt": "2023-02-03T16:00:42Z",
          "publishedAt": "2023-01-04T14:01:30Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCould you follow the same approach and force some measure of the displacement from a rotation (maybe |disp| to avoid compensation between opposite nodes) to sum to zero?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4592082",
                  "updatedAt": "2023-01-04T14:11:45Z",
                  "publishedAt": "2023-01-04T14:11:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Sounds reasonable but how do you measure the rotation?",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4593403",
                          "updatedAt": "2023-01-04T16:21:22Z",
                          "publishedAt": "2023-01-04T16:21:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Oh it s not always around the origin that you forced?",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4593635",
                          "updatedAt": "2023-01-04T16:41:54Z",
                          "publishedAt": "2023-01-04T16:41:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "no, the meshes I'm working with are all over the place.",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4593722",
                          "updatedAt": "2023-01-04T16:52:43Z",
                          "publishedAt": "2023-01-04T16:52:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is the rotation always around the center of mass though?\nis the axis always the same too?\nDoes this all depend on which nodes you chose to pin by forcing the displacement sum to 0?",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4593781",
                          "updatedAt": "2023-01-04T16:59:00Z",
                          "publishedAt": "2023-01-04T16:59:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "I've only inspected it visually, but it does seem the rotation is about the center. Just looking at 2D models for now. Haven't played around with the constraint nodes since those are already built in to the Abaqus models I'm working with.",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4594258",
                          "updatedAt": "2023-01-04T17:49:55Z",
                          "publishedAt": "2023-01-04T17:49:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you know that center you could compute a moment with the displacement for the constraint node and try to constain that.",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4596880",
                          "updatedAt": "2023-01-05T01:10:15Z",
                          "publishedAt": "2023-01-05T01:10:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "I do know the point coordinates (which are also a nodeset), so computing the centroid is no problem.\nGuess I would need to find the component of the displacement that is perpendicular to the radial vector (center to point), sum those for each point, and constrain that value?",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4597796",
                          "updatedAt": "2023-01-05T04:17:32Z",
                          "publishedAt": "2023-01-05T04:17:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think to compute the moment you would also need to multiply by the radial vector length.\nBut both of these are heuristics so either could work?",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4611379",
                          "updatedAt": "2023-01-06T11:57:40Z",
                          "publishedAt": "2023-01-06T11:57:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any luck with this heuristic or the petsc nullspace removal?",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4858451",
                          "updatedAt": "2023-02-03T05:22:45Z",
                          "publishedAt": "2023-02-03T05:22:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "I ended up implementing the ad-hoc sum-to-zero constraints I mentioned using NodalKernels for applying forces and ScalarKernels for computing Lagrange multipliers. Multiple constraints were needed to prevent both rotation and translation. Unfortunately my abilities with petsc don't go beyond passing petsc options in the MOOSE input file, so I never tried to tackle the null space removal.",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4862179",
                          "updatedAt": "2023-02-03T13:26:02Z",
                          "publishedAt": "2023-02-03T13:26:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "There's a capability in petsc which automatically computes and removes (near) null spaces in the context of solid mechanics. @reverendbedford recently tried that IIRC.",
                  "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4596799",
                  "updatedAt": "2023-01-05T00:53:36Z",
                  "publishedAt": "2023-01-05T00:53:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "reverendbedford"
                          },
                          "bodyText": "I suppose I should finish that PR...",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4597209",
                          "updatedAt": "2023-01-05T02:16:13Z",
                          "publishedAt": "2023-01-05T02:16:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "There's a capability in petsc which automatically computes and removes (near) null spaces in the context of solid mechanics. @reverendbedford recently tried that IIRC.\n\n@hugary1995 does this capability currently exist in MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4597705",
                          "updatedAt": "2023-01-05T03:49:51Z",
                          "publishedAt": "2023-01-05T03:49:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "Let me back up and make sure I'm doing things right. What I'm after is for all $i$ nodes in my nodeset: $\\sum_{i} disp_{x,i}=0$, $\\sum_{i} disp_{y,i}=0$ and not $disp_{x,i}=0$, $disp_{y,i}=0$.\nI'm using PenaltyDirichletNodalKernel with value=0.0. Is that what I want or do I need to do something different?",
                  "url": "https://github.com/idaholab/moose/discussions/23063#discussioncomment-4613328",
                  "updatedAt": "2023-01-06T15:17:24Z",
                  "publishedAt": "2023-01-06T15:17:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Negative mass/concentration problem",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear all,\nI am stuck with a numerical problem with our application. Here I want to show one simple model to ask a question.\nI have a 1D model and let water flow through the 1D system by setting a constant water flow rate at one boundary. In addition, I want to have a chemical component following the water to flow through the 1D system by giving a constant concentration at the boundary with water injection. Initially, there is only water in the system.\nNow the question is after computation, there is always a negative value for chemical component concentration (please see figure below), even at the first time step.\nI tried to check my code and solver conditions but nothing helps me with the negative value. Could you help to give some comments regarding that? Thanks in advance. Attached are my input file and results.",
          "url": "https://github.com/idaholab/moose/discussions/23099",
          "updatedAt": "2023-03-09T22:24:32Z",
          "publishedAt": "2023-01-07T00:43:35Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou have boundary conditions on both ends for this solute right?\nIt doesnt seem physically to have an inlet at a concentration and an outlet at 0.\nIs the solute supposed to have entirely reacted or something? I dont see a loss/reaction kernel\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23099#discussioncomment-4618458",
                  "updatedAt": "2023-01-07T10:02:31Z",
                  "publishedAt": "2023-01-07T10:02:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "Hello\nYou have boundary conditions on both ends for this solute right? It doesnt seem physically to have an inlet at a concentration and an outlet at 0. Is the solute supposed to have entirely reacted or something? I dont see a loss/reaction kernel\nGuillaume\n\nYes. I have boundary conditions on both ends for this solute.\nIf I only set the inlet at a concentration and do not set an outlet, I still got similar results with some negative concentrations (shown in the attached picture).\nOnly the advection of concentration is considered in this process. There are no loss/reaction kernels.",
                          "url": "https://github.com/idaholab/moose/discussions/23099#discussioncomment-4619148",
                          "updatedAt": "2023-01-07T12:58:26Z",
                          "publishedAt": "2023-01-07T12:58:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What is the advection velocity here?\nThe solute concentration is essentially 0 here. So the advection and the diffusion are not propagating the solute",
                          "url": "https://github.com/idaholab/moose/discussions/23099#discussioncomment-4619648",
                          "updatedAt": "2023-01-07T14:04:24Z",
                          "publishedAt": "2023-01-07T14:04:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "while some numbers are negative, they are mostly 0",
                          "url": "https://github.com/idaholab/moose/discussions/23099#discussioncomment-4619651",
                          "updatedAt": "2023-01-07T14:04:40Z",
                          "publishedAt": "2023-01-07T14:04:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "What is the advection velocity here? The solute concentration is essentially 0 here. So the advection and the diffusion are not propagating the solute\n\nThe advection velocity value is 3.5e-6 m/s, which is the artificial darcy velocity. In the first time step (t= 0.1 s), some solute values are negative and close to 0 but the minimum value is -0.15. Also, as time goes on \uff08i.e., 363.4s\uff09, the minimum solute concentration can be minus several hundred (-545. 818, shown in the attached pictures).",
                          "url": "https://github.com/idaholab/moose/discussions/23099#discussioncomment-4619729",
                          "updatedAt": "2023-01-07T14:23:12Z",
                          "publishedAt": "2023-01-07T14:23:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok this latest screenshot does show this more clearly.\nIs this with the two boundary conditions on both ends? As I was mentioning earlier, this seems unphysical.\nOr with the single boundary condition on one end?",
                          "url": "https://github.com/idaholab/moose/discussions/23099#discussioncomment-4858446",
                          "updatedAt": "2023-02-03T05:21:29Z",
                          "publishedAt": "2023-02-03T05:21:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Solution not converging by number of iteration as expected",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hello,\nI am trying two solve a simple poison equation with two subdomains using MultiApp. The idea is to use RobinBC at the interface. Now, the solution is expected to have a different convergence rate as the scalar value (alpha) changes. It should converge to the same solution though with a different number of iterations. I am getting that my solution converges in two iterations for all values of alpha. This is weird. Please what could I do to achieve a different convergence rate as the alpha changes, and for it to converge to the same true solution at every single time?\nMore specifically, the idea is to have the solutions transferred to and from each subdomain at every step of the iteration until convergence. Currently, I think the right subdomain solves and send the result to the left. Then the left sub uses those values in its calculation and output the result. That's the two iterations. How can I make the results to be sent back and forth until convergence?\nThank you!\n-----------------------------\nRight Subdomain\n-------------------------------\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  nx = 1\n  xmin = 1\n  xmax = 2\n\n[]\n\n[Variables]\n  [v]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [flux_v]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[Kernels]\n  [diffusion]\n    type = MatDiffusion\n    variable = v\n    diffusivity = 1\n  []\n[]\n\n[AuxKernels]\n  [fluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = 1\n    variable = flux_v\n    diffusion_variable = v\n    component = x\n  []\n[]\n\n[BCs]\n  [interface_leftBC] \n    type = VacuumBC\n    variable = v\n    boundary = 'left'\n    alpha = 2\n  []\n  \n  [rightBC] \n    type = NeumannBC\n    variable = v\n    boundary = 'right'\n    value = 3\n  []\n[]\n\n[Functions]\n  [BC_vleft_Neumann]\n    type = ParsedFunction\n    value = '-a'\n    vars = 'a'\n    vals = 'u_flux_right'\n  []\n[]\n\n[Postprocessors]\n  [left_vflux]\n    type = PointValue\n    variable = 'flux_v'\n    point = '1 0 0'\n   []\n  [left_vval]\n    type = PointValue\n    variable = 'v'\n    point = '1 0 0'\n   []\n  [uval_right]\n    type = Receiver\n  []\n  [u_flux_right]\n    type = Receiver\n  []\n  \n  [no_picard_its]\n    type = NumFixedPointIterations\n    execute_on = 'initial timestep_end'\n  []\n\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = 'PJFNK'\n  \n  #type = Transient\n  #num_steps = 10\n  #dt = 1\n\n  fixed_point_max_its = 50\n  nl_abs_tol = 1e-10\n  fixed_point_rel_tol = 1e-16\n  fixed_point_abs_tol = 1e-10\n\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  console = true\n[]\n\n[VectorPostprocessors]\n  [point_sample]\n    type = PointValueSampler\n    variable = 'v flux_v'\n    points = '1 0 0'\n    sort_by = x\n  []\n[]\n\n-----------------------------\nLeft Subdomain\n---------------------------\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  nx = 1\n  xmin = 0\n  xmax = 1\n\n[]\n\n[Variables]\n  [u]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [flux_u]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[Kernels]\n  [diffusion]\n    type = MatDiffusion\n    variable = u\n    diffusivity = 1\n  []\n[]\n\n[AuxKernels]\n  [fluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = 1\n    variable = flux_u\n    diffusion_variable = u\n    component = x\n  []\n[]\n\n[BCs]\n  [leftBC] \n    type = DirichletBC\n    variable = u\n    boundary = 'left'\n    value = 0\n  []\n\n  [interfaceBC_right] \n    type = FunctionNeumannBC\n    variable = u\n    boundary = 'right'\n    function = interface_flux_right\n  []\n\n \n[]\n\n[Functions]\n [interface_flux_right]\n   type = ParsedFunction\n   value = '-a'\n   vars = 'a'\n   vals = 'v_flux_left'\n  []\n\n  [interface_right]\n   type = ParsedFunction\n   value = 'b'\n   vars = 'b'\n   vals = 'vval_left'\n  []\n  \n[]\n\n[Postprocessors]\n  [right_uflux]\n    type = PointValue\n    variable = 'flux_u'\n    point = '1 0 0'\n   []\n  [right_uval]\n    type = PointValue\n    variable = 'u'\n    point = '1 0 0'\n   []\n  [vval_left]\n    type = Receiver\n  []\n  [v_flux_left]\n    type = Receiver\n  []\n  \n  [picard_its]\n    type = NumFixedPointIterations\n    execute_on = 'initial timestep_end'\n  []\n[]\n\n\n[Executioner]\n\n  type = Steady\n  solve_type = 'PJFNK'\n\n  #type = Transient\n  #num_steps = 10\n  #dt = 1\n\n  fixed_point_max_its = 50\n  nl_abs_tol = 1e-10\n  fixed_point_rel_tol = 1e-16\n  fixed_point_abs_tol = 1e-10\n\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  console = true\n[]\n\n\n[MultiApps]\n  [sub]\n    type = FullSolveMultiApp\n    #type = TransientMultiApp\n    positions = '1 0 0'\n    input_files = 'right_subdomain_01.i'\n    execute_on = 'timestep_begin'\n  []\n[]\n\n[Transfers]\n  [flux_ut]\n    type = MultiAppPostprocessorTransfer\n    to_multi_app = sub\n    from_postprocessor = right_uflux\n    to_postprocessor = u_flux_right\n  []\n  [uval_t]\n    type = MultiAppPostprocessorTransfer\n    to_multi_app = sub\n    from_postprocessor = right_uval\n    to_postprocessor = uval_right\n  []\n  [flux_vt]\n    type = MultiAppPostprocessorTransfer\n    from_multi_app = sub\n    reduction_type = average\n    from_postprocessor = left_vflux\n    to_postprocessor = v_flux_left\n  []\n  [vval_t]\n    type = MultiAppPostprocessorTransfer\n    from_multi_app = sub\n    reduction_type = average\n    from_postprocessor = left_vval\n    to_postprocessor = vval_left\n  [] \n[]\n\n---------------------------------\nWhen solved without subdomain\n------------------------------------\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  nx = 1\n  xmin = 0\n  xmax = 2\n\n[]\n\n[Variables]\n  [v]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [flux_v]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[Kernels]\n  [diffusion]\n    type = MatDiffusion\n    variable = v\n    diffusivity = 1\n  []\n[]\n\n[AuxKernels]\n  [fluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = 1\n    variable = flux_v\n    diffusion_variable = v\n    component = x\n  []\n[]\n\n[BCs]\n   [leftBC] \n    type = DirichletBC\n    variable = v\n    boundary = 'left'\n    value = 0\n  []\n\n  [rightBC] \n    type = NeumannBC\n    variable = v\n    boundary = 'right'\n    value = 3\n  []\n[]\n\n\n[Executioner]\n  type = Steady\n  solve_type = 'PJFNK'\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  console = true\n[]\n\n[Postprocessors]\n  [picard_its]\n    type = NumFixedPointIterations\n    execute_on = 'initial timestep_end'\n  [../]\n[]\n\n\n[VectorPostprocessors]\n  [point_sample]\n    type = PointValueSampler\n    variable = 'v flux_v'\n    points = '1 0 0'\n    sort_by = x\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23223",
          "updatedAt": "2023-02-02T17:32:16Z",
          "publishedAt": "2023-01-23T05:22:38Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe numerical scheme is not exactly the same between those two cases.\nIn the fully coupled, single input case, you are using PJFNK to solve the entire problem.\nIn the tightly coupled, two inputs case, you are using PJFNK to solve each problem, but you are using a simple fixed point iteration scheme for the coupled problem.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23223#discussioncomment-4760627",
                  "updatedAt": "2023-01-23T20:43:52Z",
                  "publishedAt": "2023-01-23T20:43:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "salaudeen-ya"
                  },
                  "bodyText": "Thanks for your reply.\n\nSo, could you suggest a better option than the Numerical scheme I chose?\n\n\nThanks!\n\u2026\nOn Mon, Jan 23, 2023, 3:44 PM Guillaume Giudicelli ***@***.***> wrote:\n Hello\n\n The numerical scheme is not exactly the same between those two cases.\n\n In the fully coupled, single input case, you are using PJFNK to solve the\n entire problem.\n In the tightly coupled, two inputs case, you are using PJFNK to solve each\n problem, but you are using a simple fixed point iteration scheme for the\n coupled problem.\n\n Guillaume\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#23223 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AJCC7Q5SAO5DK2AA25AK72LWT3URFANCNFSM6AAAAAAUDNZJEA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/23223#discussioncomment-4760890",
                  "updatedAt": "2023-01-23T21:28:05Z",
                  "publishedAt": "2023-01-23T21:28:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is there a reason you do not want to solve both problems at the same time in the same input?\nHave you tried relaxation of the picard iteration? (setting a fixed point relaxation factor and the variable to relax)",
                          "url": "https://github.com/idaholab/moose/discussions/23223#discussioncomment-4760936",
                          "updatedAt": "2023-01-23T21:34:37Z",
                          "publishedAt": "2023-01-23T21:34:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "salaudeen-ya"
                  },
                  "bodyText": "The idea is to use MultiApp, using different input.\n\nI haven't tried the relaxation yet. I'll try that.\n\u2026\nOn Mon, Jan 23, 2023, 4:34 PM Guillaume Giudicelli ***@***.***> wrote:\n Is there a reason you do not want to solve both problems at the same time\n in the same input?\n\n Have you tried relaxation of the picard iteration? (setting a fixed point\n relaxation factor and the variable to relax)\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#23223 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AJCC7Q4UWPHPA5D2SIXUIWTWT32O5ANCNFSM6AAAAAAUDNZJEA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/23223#discussioncomment-4760942",
                  "updatedAt": "2023-01-23T21:36:01Z",
                  "publishedAt": "2023-01-23T21:36:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Another option is to use different fixed point iteration algorithms (Secant and Steffensen method)\nThis is unlikely to converge if Picard fixed point iterations dont converge",
                          "url": "https://github.com/idaholab/moose/discussions/23223#discussioncomment-4761044",
                          "updatedAt": "2023-01-23T21:51:53Z",
                          "publishedAt": "2023-01-23T21:51:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "salaudeen-ya"
                  },
                  "bodyText": "Thanks, I'll check it out.\n\u2026\nOn Mon, Jan 23, 2023 at 4:51 PM Guillaume Giudicelli < ***@***.***> wrote:\n Another option is to use different fixed point iteration algorithms\n (Secant and Steffensen method)\n This is unlikely to converge if Picard fixed point iterations dont converge\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#23223 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AJCC7Q6EMCQHPPKTU2GAO5TWT34PVANCNFSM6AAAAAAUDNZJEA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/23223#discussioncomment-4761156",
                  "updatedAt": "2023-01-23T22:12:29Z",
                  "publishedAt": "2023-01-23T22:12:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "salaudeen-ya"
                  },
                  "bodyText": "I got it working.\nI conceptualized the boundary conditions better and reformulated it.",
                  "url": "https://github.com/idaholab/moose/discussions/23223#discussioncomment-4854068",
                  "updatedAt": "2023-02-02T17:19:30Z",
                  "publishedAt": "2023-02-02T17:19:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Awesome. Please feel free to explain more so others can learn from your experiences.",
                          "url": "https://github.com/idaholab/moose/discussions/23223#discussioncomment-4854135",
                          "updatedAt": "2023-02-02T17:25:37Z",
                          "publishedAt": "2023-02-02T17:25:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "Okay. I think it is problem specific\nBy reformulating the BC, this is what I did:\n\nSo, I implemented the first equation in my left subdomain and the second in the right subdomain, paying attention to the signs coming from the fluxes from the two subdomains. The left side of the equations is implemented as the robin/vacuum BC, while the right sides are from the transferred values. The idea is that as the lambda and the alpha change, the solution should converge at different rates to achieve the same result. Note that the lambda and the alpha are the iteration parameters.",
                          "url": "https://github.com/idaholab/moose/discussions/23223#discussioncomment-4854199",
                          "updatedAt": "2023-02-02T17:32:17Z",
                          "publishedAt": "2023-02-02T17:32:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Understanding which factors influence memory usage?",
          "author": {
            "login": "Eilloo"
          },
          "bodyText": "Hi all,\nI have recently been encountering the following error when trying to run an fsi simulation:\nLinear solve did not converge due to DIVERGED_PC_FAILED iterations 0\nPC failed due to FACTOR_OUTMEMORY\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH\nGenerally speaking, I am aware that this is probably caused by using an lu preconditioner, which is very memory intensive.\nHowever, so far, no alternatives which converge have been found (I am planning on making another post about this soon, but am happy to discuss here if relevant).\nThrough observation of when this error appears, it is clear that a number of other parameters have a significant effect on the memory usage.\nSome of these are perfectly intuitive such as mesh size and number of variables. However, others, such as time step size, and number of cores used are less obvious.\nI would like to understand how the above factors affect memory usage, as well as any others which may be significant (For instance, I am guessing number of kernels has an effect?).\nHopefully this will help improve things whilst the search for a more appropriate preconditioner continues!\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/23274",
          "updatedAt": "2023-02-04T06:52:43Z",
          "publishedAt": "2023-01-30T12:09:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nLU tends to report out of memory simply when it fails, not only when it s truly out of memory.\nYou should try to investigate whether the system is well conditioned, see this comment\n#22425 (reply in thread)\nIf all is well, to improve conditioning the next step is likely to try a field split\nhttps://mooseframework.inl.gov/source/preconditioners/FieldSplitPreconditioner.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23274#discussioncomment-4820843",
                  "updatedAt": "2023-01-30T16:33:20Z",
                  "publishedAt": "2023-01-30T16:33:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Eilloo"
                          },
                          "bodyText": "Thanks for the suggestions - I have a couple of questions about each of these:\nTo see the singular value composition as per your comment in the linked thread, am I right in thinking I should replace my current petsc options with the following in the executioner block:\npetsc_options = '-pc_svd_monitor'\npetsc_options_iname = '-pc_type'\npetsc_options_value = 'svd'\nWith these options alone, the simulation just seems to sit there not attempting the first timestep, so I wonder if I need to add some other options?\nEDIT: I have realised that svd is only useful for small problems - I will try to create a version with fewer dofs to investigate this.\nWhen using field split, would you typically use the same preconditioner (in this case for instance, lu), or is the idea that splitting the variables could allow less 'strong' pc's such as ilu to work for each subsolver?",
                          "url": "https://github.com/idaholab/moose/discussions/23274#discussioncomment-4850864",
                          "updatedAt": "2023-02-02T15:23:52Z",
                          "publishedAt": "2023-02-02T11:35:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No I would not use LU everywhere, some physics are likely to be easy enough to solve that you dont need a direct solver",
                          "url": "https://github.com/idaholab/moose/discussions/23274#discussioncomment-4853894",
                          "updatedAt": "2023-02-02T17:03:42Z",
                          "publishedAt": "2023-02-02T17:03:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Should we remove local, nonsparse AD indexing?",
          "author": {
            "login": "lindsayad"
          },
          "bodyText": "There are documented cases where the local indexing, nonsparse container is faster than our default global indexing, sparse container (see #17674). However, the local indexing container is essentially unusable for MOOSE FV (at least as it is currently implemented) and generally is untenable as the element coupling stencil increases; for standard DG it is fine, but for any more element neighbor layers than 1, things are tough. Additionally the global indexing container is much easier to use as a developer.",
          "url": "https://github.com/idaholab/moose/discussions/23308",
          "updatedAt": "2023-02-02T01:38:09Z",
          "publishedAt": "2023-02-01T21:02:39Z",
          "category": {
            "name": "Polls"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "Will removing this capability prevent us from using AD for other purposes? For instance, our optimization work is looking into using AD to compute residual derivatives w.r.t. parameter values.",
                  "url": "https://github.com/idaholab/moose/discussions/23308#discussioncomment-4845072",
                  "updatedAt": "2023-02-01T21:14:12Z",
                  "publishedAt": "2023-02-01T21:14:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "No. You would likely want to use the sparse (default) container for that",
                          "url": "https://github.com/idaholab/moose/discussions/23308#discussioncomment-4845144",
                          "updatedAt": "2023-02-01T21:23:10Z",
                          "publishedAt": "2023-02-01T21:23:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I would be very surprised if forward AD (regardless of container type) works well for parameter partials... say you have one objective function and millions of quadrature points each having a parameter.",
                          "url": "https://github.com/idaholab/moose/discussions/23308#discussioncomment-4845561",
                          "updatedAt": "2023-02-01T22:21:00Z",
                          "publishedAt": "2023-02-01T22:20:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Yeah, the application is not that. It would be a few model parameters or a reduced resolution parameter mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/23308#discussioncomment-4845709",
                          "updatedAt": "2023-02-01T22:48:52Z",
                          "publishedAt": "2023-02-01T22:48:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We're getting off-topic but in the conversations I've heard about this, you want to get an idea about how a parameter may effect something like a postprocessor value. Forward AD could pretty easily calculate the explicit dependence of the postprocessor on a parameter, but if the postprocessor is a function of the nonlinear degrees of freedom (or even the aux system dofs) and the parameter influences the nonlinear solution (say its viscosity in a navier-stokes simulation), how do you capture the implicit dependence of the postprocessor on the parameter through the system dofs? @grmnptr I know we've touched on this stuff briefly",
                          "url": "https://github.com/idaholab/moose/discussions/23308#discussioncomment-4845897",
                          "updatedAt": "2023-02-01T23:25:51Z",
                          "publishedAt": "2023-02-01T23:25:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zachmprince"
                          },
                          "bodyText": "I think it's a little simpler than what you are describing @lindsayad . I just need the derivative of the residual w.r.t. to a parameter. So if you had N dofs and P parameters, the derivative would be a matrix N-by-P.",
                          "url": "https://github.com/idaholab/moose/discussions/23308#discussioncomment-4846573",
                          "updatedAt": "2023-02-02T01:38:09Z",
                          "publishedAt": "2023-02-02T01:38:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Picard iteration divergence problem during MultiApps coupling",
          "author": {
            "login": "WayneX-Wong"
          },
          "bodyText": "Hi all,\nI was running a MultiApps problem,  main app is a heat conduction problem, and sub app is a simple lumped parameter problem. The calculation process is that main app uses the initial temperature boundary conditions to calculate steady-state heat conduction, after that, the integrate heat flux is postprocessed at the boundary and then transfer to the sub app to calculate and update the boundary temperature and continue the iteration.\nI set Picard iteration in the [Executioner] block, use the default fixed_point_rel_tol, and set fixed_point_min_its to 2. The calculation converge in the second picard iteration, and the results look reasonable; However, when I set fixed_point_min_its to larger (10), it still converges after the tenth picard iteration, but the result is different and extremely unreasonable.\nSo I have two questions:\n\nSeems Picard iteration is not converged from the calculation results, then why it showed solve converged?\nWhat parameters can be adjusted to improve the convergence of iteration? I've tried to set relaxation_factor to <1, and also refine the mesh or reduce the tolerance to enhanced convergence, but still no improvement.\n\nAny guidance is greatly appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/23102",
          "updatedAt": "2023-02-02T07:05:21Z",
          "publishedAt": "2023-01-07T14:29:33Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you please attach the logs for these two runs?\nOne thing to note is that the criterion for convergence of these multiapps coupling is the residual in the main app. So if the subapp does not influence the main app much (can happen also if you are missing a transfer from the subapp to the main app), you can have a converged fixed point iteration between the apps, yet the subapp result is not converged.\nRelaxation factor is the only lever pretty much here. Everything else only deals with how converged the result should be.\nOther fixed point iteration algorithms are more brittle than Picard as well\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23102#discussioncomment-4624626",
                  "updatedAt": "2023-01-08T10:55:29Z",
                  "publishedAt": "2023-01-08T10:55:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WayneX-Wong"
                          },
                          "bodyText": "Thanks for your reply Guillaume.\nI attached the log files and main app input here.\nlog_2_iterations.txt\nlog_10_iterations.txt\ninput.txt\nI originally thought fixed point iteration is that the two fields exchange data in one Picard iteration step and converge relative to the previous step, so I thought that the convergence criterion of fixed point iteration was the field value difference between two iteration steps. Did I misunderstand?",
                          "url": "https://github.com/idaholab/moose/discussions/23102#discussioncomment-4625132",
                          "updatedAt": "2023-01-08T13:29:35Z",
                          "publishedAt": "2023-01-08T12:49:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I should double check, but it should not be that.\nWe have a very valid way of checking if something is converged, by computing the residual. We dont need to rely on the difference between two iterations.\nTwo things:\n 0 Picard |R| = 5.290898e+04\n 1 Picard |R| = 2.343748e-07\n 2 Picard |R| = 5.052297e-12\n 3 Picard |R| = 4.752913e-04\n 4 Picard |R| = 2.395892e-11\n 5 Picard |R| = 3.797361e-07\n 6 Picard |R| = 2.392503e-11\n 7 Picard |R| = 2.137410e-09\n 8 Picard |R| = 2.585106e-11\n 9 Picard |R| = 4.846381e-09\n10 Picard |R| = 3.554305e-11\n\nthe main app residual is jumping around between odd and even fixed point iterations/.\nSimilarly:\nfixed point 5\nHP80: Time Step 1, time = 1, dt = 1\nHP80:  0 Nonlinear |R| = 1.128290e-06\nHP80:  1 Nonlinear |R| = 2.371580e-10\nHP80:  Solve Converged!\n\nfixed point 6\nHP80: Time Step 1, time = 1, dt = 1\nHP80:  0 Nonlinear |R| = 1.832242e-01\nHP80:  1 Nonlinear |R| = 4.521310e-05\nHP80:  2 Nonlinear |R| = 1.649082e-08\nHP80:  3 Nonlinear |R| = 3.225161e-12\nHP80:  Solve Converged!\n\nthe residual of the subapps are also jumping around between fixed point iterations. in fact it seems to grow every other iteration.\nThis is symptomatic of either instability or a problem with the timing of execution of the transfers pipeline.\nRight now I see this:\n  [boundary_temp_post2]\n    type = ScalarVariable\n    variable = boundary_temp2\n    execute_on = TIMESTEP_BEGIN\n  []\n\nthis will lag the postprocessor by one iteration. It might be the issue. Execute this more often by using the default or adding more execute_on",
                          "url": "https://github.com/idaholab/moose/discussions/23102#discussioncomment-4633258",
                          "updatedAt": "2023-01-09T12:57:43Z",
                          "publishedAt": "2023-01-09T12:57:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "As you are probably already aware of, Picard isn't necessarily convergent: https://arxiv.org/pdf/1410.1390.pdf\nThe simplest way to tell if Picard is convergent is by looking at each sub-problem and check\n\nif the sequence of Picard iterates are bounded\nif the sub-problem is convex\n\nIf both are true, then Picard should converge, though the convergence interval may vary.",
                          "url": "https://github.com/idaholab/moose/discussions/23102#discussioncomment-4633737",
                          "updatedAt": "2023-01-09T13:55:22Z",
                          "publishedAt": "2023-01-09T13:55:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WayneX-Wong"
                          },
                          "bodyText": "@GiudGiud I Change execute_on as default, some changes occurred, but Picard still didn't converge, and eventually main app didn't converge in a non-linear iteration step, and I break the running, as shown in the run log:\nlog_default_trans_post.txt\nI tried adding more execute_on also, still not convergent.",
                          "url": "https://github.com/idaholab/moose/discussions/23102#discussioncomment-4634359",
                          "updatedAt": "2023-01-09T14:56:12Z",
                          "publishedAt": "2023-01-09T14:56:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WayneX-Wong"
                          },
                          "bodyText": "Thanks for your guidance @hugary1995 , I actually suspect that my coupling problem itself is divergent... I will read the paper of this link and try to find more clues.",
                          "url": "https://github.com/idaholab/moose/discussions/23102#discussioncomment-4634383",
                          "updatedAt": "2023-01-09T14:58:24Z",
                          "publishedAt": "2023-01-09T14:58:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@WayneX-Wong one thing to try is to run a relaxation transient, with 'fake' time steps where only 1 fixed point iteration is taken on every time step.\nAnother thing is underrelaxation.\nI think you may need to specify which variables to relax (with relaxed_variables or transformed_variables parameters), it wont do all by default",
                          "url": "https://github.com/idaholab/moose/discussions/23102#discussioncomment-4649618",
                          "updatedAt": "2023-01-10T20:35:12Z",
                          "publishedAt": "2023-01-10T20:35:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WayneX-Wong"
                          },
                          "bodyText": "@GiudGiud I tried these things, and I've set a very small relaxation factor, but still no improvement.\nI don't know yet how to mathematically analyze the convergence of this coupling problem, while I briefly analyzed from the physical aspect.\nThe coupling parameters are the heat flux and boundary temperature, because the thermal conductivity of the problem is large and the geometry is small, small temperature differences can lead to large heat flux differences, which in turn make larger temperature differences, results to divergence.\nSo I changed the thermal conductivity directly to 1% of what it was before, and picard converge well without underrelaxation.\nSo I can probably infer that the problem itself doesn't converge. Do you have any suggestions?",
                          "url": "https://github.com/idaholab/moose/discussions/23102#discussioncomment-4652516",
                          "updatedAt": "2023-01-11T04:59:56Z",
                          "publishedAt": "2023-01-11T04:59:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "But did you specify which variables to relax?\nIs the system itself physically unstable?",
                          "url": "https://github.com/idaholab/moose/discussions/23102#discussioncomment-4655660",
                          "updatedAt": "2023-01-11T12:01:28Z",
                          "publishedAt": "2023-01-11T12:01:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WayneX-Wong"
                          },
                          "bodyText": "Yes by declaring the transformed_variables parameter = temp. Can be seen that setting a smaller relaxation factor will cause the picard to have a tendency of convergence at the first few iterations, but still will diverge at specific iteration step, like\n 0 Picard |R| = 1.234543e+05\n 1 Picard |R| = 1.641611e-09\n 2 Picard |R| = 1.539429e+04\n 3 Picard |R| = 1.154572e+04\n 4 Picard |R| = 8.735435e+03\n 5 Picard |R| = 6.575765e+03\n 6 Picard |R| = 4.931576e+03\n 7 Picard |R| = 3.692373e+03\n 8 Picard |R| = 2.752174e+03\n 9 Picard |R| = 2.109329e+03\n10 Picard |R| = 1.582342e+03\n11 Picard |R| = 1.610063e+03\n12 Picard |R| = 2.204031e+03\n13 Picard |R| = 2.017019e+03\n14 Picard |R| = 7.424021e+03\n15 Picard |R| = 1.106489e+03\n16 Picard |R| = 2.244228e+04\n17 Picard |R| = 1.633168e+04\n18 Picard |R| = 5.725446e+04\n19 Picard |R| = 9.156200e+04\n20 Picard |R| = 1.372499e+05\n21 Picard |R| = 6.423847e+05\n\nA larger relaxation factor leads to faster divergence, which implies to some extent, the relaxation factor is effective. But I guess this problem is physically unstable actually.",
                          "url": "https://github.com/idaholab/moose/discussions/23102#discussioncomment-4655855",
                          "updatedAt": "2023-01-11T12:26:35Z",
                          "publishedAt": "2023-01-11T12:26:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You should try to use the conservative transfer parameters. This will reduce the impact of numerical errors during transfers\nif the problem is physically unstable, you should try to add a constraint when solving it. Maybe force the integral of a quantity to be constant between each solve",
                          "url": "https://github.com/idaholab/moose/discussions/23102#discussioncomment-4660883",
                          "updatedAt": "2023-01-11T21:10:48Z",
                          "publishedAt": "2023-01-11T21:10:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to output '_flow_direction' in the file 'CrystalPlasticityStressUpdateBase.C' to exodus file",
          "author": {
            "login": "pshen20127"
          },
          "bodyText": "Hello All\nI want to output '_flow_direction' in the file 'CrystalPlasticityStressUpdateBase.C' to exodus file. Since it has been defined in the file 'CrystalPlasticityStressUpdateBase.C' like:\n_flow_direction(declareProperty<std::vector<RankTwoTensor>>(_base_name + \"flow_direction\")),\nSo I directly add a new variable in .inp file trying to output it.\n\n[SchmidTensor_xx]\ntype = RankTwoAux\nvariable = SchmidTensor_xx\nrank_two_tensor = flow_direction\nindex_j = 0\nindex_i = 0\nexecute_on = timestep_end\n[../]\n\nBut when I run codes, it displays an error 'Material has no property named: flow_direction'. How do I output '_flow_direction'\nHere is my inp file:https://github.com/pshen20127/IN625.git\nThanks\nPengfei",
          "url": "https://github.com/idaholab/moose/discussions/23300",
          "updatedAt": "2023-02-02T21:07:16Z",
          "publishedAt": "2023-01-31T22:51:16Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe name of this property is not just flow_direction.\nIt's _base_name + \"flow_direction\"\nso you need to add this base name.\nIf you dont know it you can use the [Debug] option to show all material properties created\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23300#discussioncomment-4834921",
                  "updatedAt": "2023-01-31T23:00:08Z",
                  "publishedAt": "2023-01-31T23:00:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "There's not a base_name specified in the input file, so using rank_two_tensor = flow_direction ought to work\n@pshen20127 I see you are using your own class in the input file. I'll see if I can replicate this error with the original CrystalPlasticityKalidindiUpdate class. If not, we'll probably need to see your crystal plasticity class in order to help further",
                          "url": "https://github.com/idaholab/moose/discussions/23300#discussioncomment-4834952",
                          "updatedAt": "2023-01-31T23:05:08Z",
                          "publishedAt": "2023-01-31T23:05:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "The issue here is that each slip system (in your case there are 12) has it's own Schmid tensor, so the material property flow_direction is a vector of Rank-2 tensors:\n_flow_direction(declareProperty<std::vector<RankTwoTensor>>(_base_name + \"flow_direction\")),\n\nAs such, the usual RankTwoAux that we use for outputting tensors like the plastic deformation gradient won't work here. Same thing for the MaterialStdVectorAux that we use to output the slip system resistance and slip increments.\n@GiudGiud do we have an auxkernel that can output a specific tensor component from a tensor within a vector of tensors?",
                  "url": "https://github.com/idaholab/moose/discussions/23300#discussioncomment-4835013",
                  "updatedAt": "2023-01-31T23:14:57Z",
                  "publishedAt": "2023-01-31T23:14:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no I dont think we have that one",
                          "url": "https://github.com/idaholab/moose/discussions/23300#discussioncomment-4835069",
                          "updatedAt": "2023-01-31T23:25:20Z",
                          "publishedAt": "2023-01-31T23:25:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It would not be hard to make at all",
                          "url": "https://github.com/idaholab/moose/discussions/23300#discussioncomment-4835070",
                          "updatedAt": "2023-01-31T23:25:44Z",
                          "publishedAt": "2023-01-31T23:25:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "@sapitts @GiudGiud Thanks for your reply. Are all auxkernels stored in the directorties '/moose/modules/tensor_mechanics/src/auxkernels' and '/moose/framework/src/auxkernels' ? I have checked these 2 folders and don't find any works. Will you write an auxkernel that can output this type of variables? Or could you suggest other ways that can output this variable?",
                          "url": "https://github.com/idaholab/moose/discussions/23300#discussioncomment-4835251",
                          "updatedAt": "2023-02-01T00:03:50Z",
                          "publishedAt": "2023-02-01T00:03:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}