{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wOS0yMVQxMDo0NTo0OS0wNTowMM4AVdHl"
    },
    "edges": [
      {
        "node": {
          "title": "Matematical Functions",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "Are Bessel functions and other special mathematical functions included for use in MOOSE?",
          "url": "https://github.com/idaholab/moose/discussions/25560",
          "updatedAt": "2023-09-23T06:53:01Z",
          "publishedAt": "2023-09-23T04:41:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can use boost for those functions.",
                  "url": "https://github.com/idaholab/moose/discussions/25560#discussioncomment-7087591",
                  "updatedAt": "2023-09-23T06:53:02Z",
                  "publishedAt": "2023-09-23T06:53:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "error: cannot convert 'std::vector<double>' to 'std::vector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>, std::allocator<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> > >&'",
          "author": {
            "login": "navier-rgb"
          },
          "bodyText": "Hello,\nI\u2019m trying to obtain the eigenvectors from the Creep stain in the PowerLawCreepStressUpdate.C, but I\u2019m getting the above data type conversion error. Any suggestions why this error?  Here is my implementation:\n    RankTwoTensor eigvec;\n    std::vector<Real> eigvals;\n    _creep_strain[_qp].symmetricEigenvaluesEigenvectors(eigvals, eigvec);\n    RealVectorValue ortho_eps1 = eigvec.column(1); \n    RealVectorValue ortho_eps2 = eigvec.column(2);",
          "url": "https://github.com/idaholab/moose/discussions/25559",
          "updatedAt": "2024-05-01T06:04:19Z",
          "publishedAt": "2023-09-22T22:39:30Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou're trying to store a vector of AD number in a vector of reals.\nWe've disallowed this implicit conversion, you ll need to store in an ADRealvectorvalue\nanother way is to use the MetaPhysicL::raw_value(ADReal a) routine to convert each component of the vector\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25559#discussioncomment-7086203",
                  "updatedAt": "2023-09-22T22:51:06Z",
                  "publishedAt": "2023-09-22T22:51:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "navier-rgb"
                          },
                          "bodyText": "The problem seems to stem from this line:\n_creep_strain[_qp].symmetricEigenvaluesEigenvectors(eigvals, eigvec);\n      |                                                         ^~~~~~~\n      |                                                         |\n      |                                                         std::vector<MetaPhysicL::DualNumber<double, double>, std::allocator<MetaPhysicL::DualNumber<double, double> > >\n\nI tried the following three options but didn't succeed:\n    ADRealVectorValue ortho_eps1 = eigvec.column(1); \n    ADRealVectorValue ortho_eps2 = eigvec.column(2);\n\n    auto ortho_eps1 = eigvec.column(1); \n    auto ortho_eps2 = eigvec.column(2);\n\n    RealVectorValue ortho_eps1 = MetaPhysicL::raw_value(eigvec.column(1)); \n    RealVectorValue ortho_eps2 = MetaPhysicL::raw_value(eigvec.column(2));",
                          "url": "https://github.com/idaholab/moose/discussions/25559#discussioncomment-7086236",
                          "updatedAt": "2023-09-22T23:06:35Z",
                          "publishedAt": "2023-09-22T23:06:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "does the last one work?\nif not you can try to do a loop, something like (you ll probably need to fix that code) :\nRealVectorValue ortho_eps1;\nfor (const auto i : make_range(LIBMESH_DIM))\n  ortho_eps1(i) = MetaPhysicL::raw_value(eigvec.column(1)(i));",
                          "url": "https://github.com/idaholab/moose/discussions/25559#discussioncomment-7086523",
                          "updatedAt": "2023-09-22T23:38:47Z",
                          "publishedAt": "2023-09-22T23:38:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "navier-rgb"
                          },
                          "bodyText": "Nope. none of them works. error:\n    _creep_strain[_qp].symmetricEigenvaluesEigenvectors(eigvals, eigvec);\n      |                                                         ^~~~~~~\n      |                                                         |\n      |                                                         std::vector<double>\n\nMakes me wonder if it is possible to obtain the eigenvector from that creep strain.",
                          "url": "https://github.com/idaholab/moose/discussions/25559#discussioncomment-7086629",
                          "updatedAt": "2023-09-23T00:06:06Z",
                          "publishedAt": "2023-09-23T00:06:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So eigvec is of the wrong type right?\nWhat is the compiler saying for the type that it should be?",
                          "url": "https://github.com/idaholab/moose/discussions/25559#discussioncomment-7086969",
                          "updatedAt": "2023-09-23T02:48:16Z",
                          "publishedAt": "2023-09-23T02:48:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "navier-rgb"
                          },
                          "bodyText": "yeah this works. thanks @iyevugah @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/25559#discussioncomment-7087010",
                          "updatedAt": "2023-09-23T03:08:50Z",
                          "publishedAt": "2023-09-23T03:08:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Component thermal_expansion_coeff implementation",
          "author": {
            "login": "chakra34"
          },
          "bodyText": "Hi,\nI am trying to add a code similar to \"ComputeThermalExpansionEigenstrain\" with something like \"ComputeThermalExpansionEigenstrainOrthotropic\" where I want to provide 3 values of thermal expansion coefficient. To do that I did the following:\nAdded a method in RankTwoTensorImplementation.h similar to addIa(a) :\nvoid\nRankTwoTensorTempl<T>::addDiag(const T & a)\n{\n  for (auto i : make_range(N))\n    (*this)(i, i) += a(i);\n}\nThe objective is to have the diagonal components added to the vector (which would be a non-isotropic eigenstrain)\nSubsequently, I followed \"ComputeThermalExpansionEigenstrain\" to write a new code \"ComputeThermalExpansionEigenstrainOrthotropic\" where I am taking 3 thermal expansion coefficients and the new \"computeThermalStrain()\" looks something like:\ntemplate <bool is_ad>\nValueAndDerivative<is_ad>\nComputeThermalExpansionEigenstrainOrthotropicTempl<is_ad>::computeThermalStrain()\n{\n  _diagonal_strain_components(1) = _thermal_expansion_coeff_11 * (_temperature[_qp] - _stress_free_temperature[_qp]);\n  _diagonal_strain_components(2) = _thermal_expansion_coeff_22 * (_temperature[_qp] - _stress_free_temperature[_qp]);\n  _diagonal_strain_components(3) = _thermal_expansion_coeff_33 * (_temperature[_qp] - _stress_free_temperature[_qp]);\n  return _diagonal_strain_components ;\n}\nwith the _diagonal_strain_components being a std of size 3 that has the eigenstrain components.\nNow my question is-- to add this to the _eigenstrain[_qp] in the computeQpEigenstrain in \"ComputeThermalExpansionEigenstrainBase\", how do I modify such that when the thermal_strain is a vector it uses the aforementioned .addDiag(thermal_strain.value()) instead of .addIa(thermal_strain.value()) :\ntemplate <bool is_ad>\nvoid\nComputeThermalExpansionEigenstrainBaseTempl<is_ad>::computeQpEigenstrain()\n{\n  _eigenstrain[_qp].zero();\n  const auto thermal_strain = computeThermalStrain();\n\n  if constexpr (is_ad)\n    _eigenstrain[_qp].addIa(thermal_strain);\n  else\n  {\n    _eigenstrain[_qp].addIa(thermal_strain.value());\n    (*_deigenstrain_dT)[_qp].zero();\n    if (!_use_old_temperature)\n      (*_deigenstrain_dT)[_qp].addIa(thermal_strain.derivatives());\n  }\n}\nOne thing I was thinking was to put a flag to check whether the thermal_strain is a scalar or a vector and use accordingly, but I am not sure if that makes sense...\nAlso, for my case where thermal_strain is a vector can I still use thermal_strain.derivatives() and thermal_strain.values() ?\n(P.S. New Moose user and trying my hand at small modifications :( )\nAny suggestions/comments would be extremely helpful.\nThanks,\nAritra",
          "url": "https://github.com/idaholab/moose/discussions/25548",
          "updatedAt": "2023-10-17T14:45:40Z",
          "publishedAt": "2023-09-21T21:53:31Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Can't you follow ComputeCrystalPlasticityThermalEigenstrain if it doesn't already handle your use case?",
                  "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7075255",
                  "updatedAt": "2023-09-21T22:30:03Z",
                  "publishedAt": "2023-09-21T22:30:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Currently, we are going to use it for thermo-elastic problems in small strain, so not crystal plasticity and large strain mechanics. Also with this I want to get me feet wet in coding/understanding MOOSE for some of the future developments we have planned (temperature dependent orthotropic thermal_expansion and elasticity).. so I wanted to implement a relatively simple code.",
                          "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7082391",
                          "updatedAt": "2023-09-22T14:32:23Z",
                          "publishedAt": "2023-09-22T14:32:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I understand what you are trying to do. What I was suggesting is that you can write your code following the ComputeCrystalPlasticityThermalEigenstrain. All the operations you need are already done in the source code of that object.",
                          "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7083918",
                          "updatedAt": "2023-09-22T16:48:52Z",
                          "publishedAt": "2023-09-22T16:48:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Thanks a lot @hugary1995 for the suggestion, really appreciate it, and I looked at the code and as you mention it has all the requisite operations in the crystal plasticity large strain formulation.\nI did manage to write a code that does for simple cubic systems, that seem to work. However, I inherited from ComputeThermalExpansionEigenstrain class. If you get a chance please let me know your thoughts about the approach.\nThanks again,\n-Aritra",
                          "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7084964",
                          "updatedAt": "2023-09-22T19:09:10Z",
                          "publishedAt": "2023-09-22T19:09:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "wangzhaohao"
                  },
                  "bodyText": "I think i meet the same problem, my method is use the fillFromInputVector",
                  "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7076568",
                  "updatedAt": "2023-09-22T01:47:13Z",
                  "publishedAt": "2023-09-22T01:47:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "chakra34"
                  },
                  "bodyText": "@hugary1995 @wangzhaohao  I liked the fillFromInputVector and have used this to accept a vector value for the thermal expansion coeff and then using that to get the eigenstrain. But I think the operator '*' does not work for the following (last function):\n#include \"ComputeThermalExpansionEigenstrainOrthotropic.h\"\n\nregisterMooseObject(\"TensorMechanicsApp\", ComputeThermalExpansionEigenstrainOrthotropic);\nregisterMooseObject(\"TensorMechanicsApp\", ADComputeThermalExpansionEigenstrainOrthotropic);\n\ntemplate <bool is_ad>\nInputParameters\nComputeThermalExpansionEigenstrainOrthotropicTempl<is_ad>::validParams()\n{\n  InputParameters params = ComputeThermalExpansionEigenstrainTempl<is_ad>::validParams();\n  params.addClassDescription(\"Computes eigenstrain due to thermal expansion \"\n                             \"with a 3 coefficients coefficient\");\n  params.addRequiredParam<std::vector<Real>>(\n      \"thermal_expansion_coeff_comp\", \"Thermal expansion coefficient components x y z directions\");\n\n  return params;\n}\n\ntemplate <bool is_ad>\nComputeThermalExpansionEigenstrainOrthotropicTempl<is_ad>::ComputeThermalExpansionEigenstrainOrthotropicTempl(\n    const InputParameters & parameters)\n  : ComputeThermalExpansionEigenstrainTempl<is_ad>(parameters)\n{\n  _eigen_ortho_tensor.fillFromInputVector(this->template getParam<std::vector<Real>>(\"thermal_expansion_coeff_comp\"));\n}\n\ntemplate <bool is_ad>\nValueAndDerivative<is_ad>\nComputeThermalExpansionEigenstrainOrthotropicTempl<is_ad>::computeThermalStrain()\n{\n  return _eigen_ortho_tensor * (_temperature[_qp] - _stress_free_temperature[_qp]);\n}\n\ntemplate class ComputeThermalExpansionEigenstrainOrthotropicTempl<false>;\ntemplate class ComputeThermalExpansionEigenstrainOrthotropicTempl<true>;\nwhere I want to multiply the _eigen_ortho_tensor (defined as RankTwoTensor in the header) with a scalar which is the difference between the temperatures.\nAlso, the ComputeThermalStrain() is used in the ComputeThermalExpansionEigenstrainBase class as\ntemplate <bool is_ad>\nvoid\nComputeThermalExpansionEigenstrainBaseTempl<is_ad>::computeQpEigenstrain()\n{\n  _eigenstrain[_qp].zero();\n  const auto thermal_strain = computeThermalStrain();\n\n  if constexpr (is_ad)\n    _eigenstrain[_qp].addIa(thermal_strain);\n  else\n  {\n    _eigenstrain[_qp].addIa(thermal_strain.value());\n    (*_deigenstrain_dT)[_qp].zero();\n    if (!_use_old_temperature)\n      (*_deigenstrain_dT)[_qp].addIa(thermal_strain.derivatives());\n  }\n}\nThis complains when computeThermalStrain is a RankTwoTensor since it wants a ValueAndDerivative. So what would be the correct datatype to pass through computeThermalStrain() for my case where I am computing the tensor instead of a scalar value?\nThanks again for the help.\n-Aritra",
                  "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7082478",
                  "updatedAt": "2023-09-22T15:33:02Z",
                  "publishedAt": "2023-09-22T14:41:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "i directly pubilc computeEigenstrainBase, i think there should have more simple method.",
                          "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7082819",
                          "updatedAt": "2023-09-22T15:07:52Z",
                          "publishedAt": "2023-09-22T15:07:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "And then modify computeQPEigenstrain (), yeah..that's an approach. I was thinking along those lines too, but then you would have to get temperature (material property) as well as the stress free temperature at each _qp.\nThat's why I wanted to inherit from ThermalExpansion class",
                          "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7083028",
                          "updatedAt": "2023-09-22T15:25:19Z",
                          "publishedAt": "2023-09-22T15:25:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "chakra34"
                  },
                  "bodyText": "Following the discussion, I tried modifying computeQPEigenstrain() function inheriting from computeThermalExpansion.C. So I returned 0.0 for the computeThermalStrain () and directly modified the eigenstrain at the [_qp] in my orthotropic class. The code compiles and here's the following source code:\ntemplate <bool is_ad>\nInputParameters\nComputeThermalExpansionEigenstrainOrthotropicTempl<is_ad>::validParams()\n{\n  InputParameters params = ComputeThermalExpansionEigenstrainTempl<is_ad>::validParams();\n  params.addClassDescription(\"Computes eigenstrain due to thermal expansion \"\n                             \"with a 3 coefficients coefficient\");\n  params.addRequiredParam<std::vector<Real>>(\n      \"thermal_expansion_coeff_comp\", \"Thermal expansion coefficient components x y z directions\");\n\n  return params;\n}\n\ntemplate <bool is_ad>\nComputeThermalExpansionEigenstrainOrthotropicTempl<is_ad>::ComputeThermalExpansionEigenstrainOrthotropicTempl(\n    const InputParameters & parameters)\n  : ComputeThermalExpansionEigenstrainTempl<is_ad>(parameters)\n{\n  _eigen_ortho_tensor.fillFromInputVector(this->template getParam<std::vector<Real>>(\"thermal_expansion_coeff_comp\"));\n}\n\ntemplate <bool is_ad>\nValueAndDerivative<is_ad>\nComputeThermalExpansionEigenstrainOrthotropicTempl<is_ad>::computeThermalStrain()\n{\n  return 0.0 ; \n}\n\ntemplate <bool is_ad>\nvoid\nComputeThermalExpansionEigenstrainOrthotropicTempl<is_ad>::computeQpEigenstrain()\n{\n  // Define Eigenstrain\n  _eigenstrain[_qp].zero();\n  if constexpr (is_ad)\n  {\n    _eigenstrain[_qp] = _eigen_ortho_tensor * (_temperature[_qp].value() - _stress_free_temperature[_qp]);\n  }\n  else\n  {\n    _eigenstrain[_qp] = _eigen_ortho_tensor * (_temperature[_qp].value() - _stress_free_temperature[_qp]);\n    \n    (*_deigenstrain_dT)[_qp].zero();\n    if (!_use_old_temperature)\n      (*_deigenstrain_dT)[_qp] = _eigen_ortho_tensor;\n  }\n\n}\n\n\ntemplate class ComputeThermalExpansionEigenstrainOrthotropicTempl<false>;\ntemplate class ComputeThermalExpansionEigenstrainOrthotropicTempl<true>;\n\nDoes this make sense ? Or is it a convoluted way of doing such ? Would be great to have some feedback\nThanks,\n-Aritra",
                  "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7084226",
                  "updatedAt": "2023-09-22T18:35:20Z",
                  "publishedAt": "2023-09-22T17:32:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "I tested the above code and it seems to work for a preliminary case, where I have CTE_11 != CTE_22 != CTE_33 for a cubic geometry with linearly varying temperature field:",
                          "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7084807",
                          "updatedAt": "2023-09-22T18:44:40Z",
                          "publishedAt": "2023-09-22T18:44:40Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "However, since I inherited from ComputeThermalExpansionEigenstrain which needs the required parameter thermal_expansion_coeff I had to provide that in the input file (i gave it 0).",
                          "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7084875",
                          "updatedAt": "2023-09-22T18:54:26Z",
                          "publishedAt": "2023-09-22T18:54:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "I guess define the same name\n'thermal_expansion_coeff' will slove this problem\uff1fLater i will try.",
                          "url": "https://github.com/idaholab/moose/discussions/25548#discussioncomment-7086686",
                          "updatedAt": "2023-09-23T00:41:48Z",
                          "publishedAt": "2023-09-23T00:41:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question on [ComputeLagrangianStrain]",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Dear MOOSEers,\nin the page of ComputeLagrangianStrain https://mooseframework.inl.gov/moose/source/materials/lagrangian/ComputeLagrangianStrain.html, there is the note reading\"The strain calculator does not apply the eigenstrains to the deformation gradient, only the incremental and integrated strain measures.\"\nSo dose it mean for small strain, it's used to calculate eigenstrain from total strain as \\epsilon = \\epsilon_mech + \\epsilon_eigen?\nand for large kinematics, the eigen part like the thermal deformation gradient is not excluded from the total deformation gradient, as decomposed F=F^\\theta F^mech? and what if the thermal part should be excluded?",
          "url": "https://github.com/idaholab/moose/discussions/25553",
          "updatedAt": "2023-09-23T06:57:40Z",
          "publishedAt": "2023-09-22T14:30:14Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "So dose it mean for small strain, it's used to calculate eigenstrain from total strain as \\epsilon = \\epsilon_mech + \\epsilon_eigen?\n\nThis is correct. The stress calculator computes stress as function of mechanical strain.\n\nand for large kinematics, the eigen part like the thermal deformation gradient is not excluded from the total deformation gradient, as decomposed F=F^\\theta F^mech? and what if the thermal part should be excluded?\n\nNo, for large kinematics the eigenstrains are also accounted for if you use one of the objectively integrated stress calculator, i.e. we advect a small stress-strain model to render it as a large deformation model.\nHowever, if you use some hyperelastic material model and directly compute stress as a function of the deformation gradient, then indeed the eigenstrains are not being excluded. That is a missing capability in the new system.",
                  "url": "https://github.com/idaholab/moose/discussions/25553#discussioncomment-7084008",
                  "updatedAt": "2023-09-22T17:01:58Z",
                  "publishedAt": "2023-09-22T17:01:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thanks @hugary1995",
                          "url": "https://github.com/idaholab/moose/discussions/25553#discussioncomment-7084521",
                          "updatedAt": "2023-09-22T18:06:32Z",
                          "publishedAt": "2023-09-22T18:06:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "undefined reference to `MooseApp::restore(std::shared_ptr<Backup>, bool)`",
          "author": {
            "login": "Thomas-Ulrich"
          },
          "bodyText": "Hi,\nI've updated the conda moose environment and moose (git pull on branch next), but I'm now unable to install my application, because of the following error:\nLinking Executable /import/heisenbug-dump/ulrich/myLibs/Tiger/tiger-opt...\n/import/tegern-data/ulrich/MyLibs/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.4.0/../../../../x86_64-conda-linux-gnu/bin/ld: /import/heisenbug-dump/ulrich/myLibs/moose/modules/module_loader/lib/libmodule_loader_with_fp_tm_pf-opt.so: undefined reference to `MooseApp::restore(std::shared_ptr<Backup>, bool)'\ncollect2: error: ld returned 1 exit status\n\nAny idea?\nThanks in advance,\nThomas Ulrich",
          "url": "https://github.com/idaholab/moose/discussions/25552",
          "updatedAt": "2023-09-22T15:25:09Z",
          "publishedAt": "2023-09-22T13:30:39Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou ll need to:\n\nsave all your work (git commit -am if you're not sure)\ngo in the tiger/ folder\ngit clean -xfd\ngit submodule foreach git clean -xfd\nthen rebuild\n\nthere are some old compiled objects in the folders and they're messing with the linking\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25552#discussioncomment-7081709",
                  "updatedAt": "2023-09-22T13:32:38Z",
                  "publishedAt": "2023-09-22T13:32:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Thomas-Ulrich"
                          },
                          "bodyText": "I did that, but I get the same result.\n(on moose I m at 81a54cc)\n(moose) ulrich@kernelpanic:/import/heisenbug-dump/ulrich/myLibs/Tiger$ git clean -xfd\nRemoving .libs/\nRemoving build/\nRemoving lib/\nRemoving src/.libs/\nRemoving src/base/.libs/\nRemoving src/base/TigerApp.x86_64-conda-linux-gnu.opt.lo\nRemoving src/base/TigerApp.x86_64-conda-linux-gnu.opt.lo.d\nRemoving src/main.x86_64-conda-linux-gnu.opt.lo\nRemoving src/main.x86_64-conda-linux-gnu.opt.lo.d\nRemoving test/lib/\nRemoving tiger.yaml\n(moose) ulrich@kernelpanic:/import/heisenbug-dump/ulrich/myLibs/Tiger$ git submodule foreach git clean -xfd\n(moose) ulrich@kernelpanic:/import/heisenbug-dump/ulrich/myLibs/Tiger$ make -j 40\nCreating Unity Directory /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src\nRebuilding symlinks in /import/heisenbug-dump/ulrich/myLibs/Tiger/build/header_symlinks\nCreating Unity /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/dirackernels_Unity.C\nCreating Unity /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/auxkernels_Unity.C\nCreating Unity /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/bcs_Unity.C\nCreating Unity /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/kernels_Unity.C\nCreating Unity /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/materials_Unity.C\nLinking Library /import/heisenbug-dump/ulrich/myLibs/Tiger/test/lib/libtiger_test-opt.la...\nCreating Resource file /import/heisenbug-dump/ulrich/myLibs/Tiger/tiger.yaml\nCreating Unity /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/userobjects_Unity.C\nCompiling C++ (in opt mode) /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/dirackernels_Unity.C...\nCompiling C++ (in opt mode) /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/auxkernels_Unity.C...\nCompiling C++ (in opt mode) /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/bcs_Unity.C...\nCompiling C++ (in opt mode) /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/kernels_Unity.C...\nCompiling C++ (in opt mode) /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/materials_Unity.C...\nCompiling C++ (in opt mode) /import/heisenbug-dump/ulrich/myLibs/Tiger/src/base/TigerApp.C...\nCompiling C++ (in opt mode) /import/heisenbug-dump/ulrich/myLibs/Tiger/src/main.C...\nCompiling C++ (in opt mode) /import/heisenbug-dump/ulrich/myLibs/Tiger/build/unity_src/userobjects_Unity.C...\nLinking Library /import/heisenbug-dump/ulrich/myLibs/Tiger/lib/libtiger-opt.la...\nLinking Executable /import/heisenbug-dump/ulrich/myLibs/Tiger/tiger-opt...\n/import/tegern-data/ulrich/MyLibs/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.4.0/../../../../x86_64-conda-linux-gnu/bin/ld: /import/heisenbug-dump/ulrich/myLibs/moose/modules/module_loader/lib/libmodule_loader_with_fp_tm_pf-opt.so: undefined reference to `MooseApp::restore(std::shared_ptr<Backup>, bool)'\ncollect2: error: ld returned 1 exit status\nmake: *** [/import/heisenbug-dump/ulrich/myLibs/moose/framework/app.mk:445: /import/heisenbug-dump/ulrich/myLibs/Tiger/tiger-opt] Error 1",
                          "url": "https://github.com/idaholab/moose/discussions/25552#discussioncomment-7081749",
                          "updatedAt": "2023-09-22T13:37:09Z",
                          "publishedAt": "2023-09-22T13:37:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so moose is not a submodule of Tiger?\nwhere is moose?\nyou can navigate to the moose folder and git clean -xfd it",
                          "url": "https://github.com/idaholab/moose/discussions/25552#discussioncomment-7081807",
                          "updatedAt": "2023-09-22T13:42:39Z",
                          "publishedAt": "2023-09-22T13:42:38Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Thomas-Ulrich"
                          },
                          "bodyText": "I've started from a fresh moose and it worked.",
                          "url": "https://github.com/idaholab/moose/discussions/25552#discussioncomment-7083025",
                          "updatedAt": "2023-09-22T15:25:09Z",
                          "publishedAt": "2023-09-22T15:25:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "doubled AreaPostprocessor results",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear all,\nI use AreaPostprocessor to set the proper 'flux_function' for PorousFlowSink BC.\nThe model contains a 50m(X)5m (Y)50m (Z) reservoir within the 100m100m100m cubic.\nI set the PorousFlowSink BCs on both the inj_well (in green, 5m50m=250 m2) and pro_well (in blue, 5m50m=250 m2).\nBut the output of AreaPostprocessor is 500 m2, two times of actual area. But the volume of the reservoir is 125000 m3, and the area results of top and bottom boundaries are 1000 m2. These are correct.\nCould you please help me with this?",
          "url": "https://github.com/idaholab/moose/discussions/25544",
          "updatedAt": "2023-09-22T13:03:23Z",
          "publishedAt": "2023-09-21T18:14:01Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthis is a meshing issue most likely\nEither:\n\ntwo layers of sides are included in the sideset you re measuring the area of\nsides in both directions (normal pointing both ways) are included in the sideset\n\nboth are problematic, and will force you to redo your mesh generation\nYou can also work with a ParsedGenerateSideset to restrict the sideset to what you want. Maybe indicating the included_sideset and included subdomains will be enough to restrict the sideset\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25544#discussioncomment-7073507",
                  "updatedAt": "2023-09-21T18:20:10Z",
                  "publishedAt": "2023-09-21T18:20:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "Hi Guillaume,\nthanks a lot! I use ParsedGenerateSideset and get the correct area of 250 m2.\nBest regards,\nJ",
                          "url": "https://github.com/idaholab/moose/discussions/25544#discussioncomment-7073641",
                          "updatedAt": "2023-09-21T18:40:18Z",
                          "publishedAt": "2023-09-21T18:40:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Deformation issue",
          "author": {
            "login": "jin0123456"
          },
          "bodyText": "Hello,\nI want to know in MOOSE how to output the deformation displacement caused by a single strain model like creep? I hope someone can answer my question. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/25538",
          "updatedAt": "2023-09-22T17:02:48Z",
          "publishedAt": "2023-09-21T07:41:21Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nlook for the variable disp_x in your output.\nAre you wanting to see the field or sample some values?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25538#discussioncomment-7069472",
                  "updatedAt": "2023-09-21T11:40:53Z",
                  "publishedAt": "2023-09-21T11:40:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "Like if there is a deformation caused by thermal expansion and creep, How do I know how much deformation is caused by thermal expansion or creep alone?",
                          "url": "https://github.com/idaholab/moose/discussions/25538#discussioncomment-7069996",
                          "updatedAt": "2023-09-21T12:31:28Z",
                          "publishedAt": "2023-09-21T12:31:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Those are probably stored as strains.\nUse show_material_properties in the Debug block to see if they are. And if so you can output material properties with an option in the Outputs block",
                          "url": "https://github.com/idaholab/moose/discussions/25538#discussioncomment-7070038",
                          "updatedAt": "2023-09-21T12:36:08Z",
                          "publishedAt": "2023-09-21T12:35:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "You can only output strains separately. If you want, maybe you can find a way to integrate the strain and get the displacements from the strain. I do not believe we have that capability yet.",
                          "url": "https://github.com/idaholab/moose/discussions/25538#discussioncomment-7070046",
                          "updatedAt": "2023-09-21T12:36:13Z",
                          "publishedAt": "2023-09-21T12:36:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "That's what I was thinking\uff0cthanks.",
                          "url": "https://github.com/idaholab/moose/discussions/25538#discussioncomment-7070125",
                          "updatedAt": "2023-09-21T12:44:23Z",
                          "publishedAt": "2023-09-21T12:44:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Maybe we should back up a little bit first: Do you want some measure of deformation that corresponds to the entire body, or at every point in the domain? In other words, do you need a single number or some field outputs?",
                          "url": "https://github.com/idaholab/moose/discussions/25538#discussioncomment-7070265",
                          "updatedAt": "2023-09-21T12:57:36Z",
                          "publishedAt": "2023-09-21T12:57:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "At every point in the domain I suppose.",
                          "url": "https://github.com/idaholab/moose/discussions/25538#discussioncomment-7070368",
                          "updatedAt": "2023-09-21T13:07:41Z",
                          "publishedAt": "2023-09-21T13:07:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "Or a specific point on the boundary.",
                          "url": "https://github.com/idaholab/moose/discussions/25538#discussioncomment-7070526",
                          "updatedAt": "2023-09-21T13:23:20Z",
                          "publishedAt": "2023-09-21T13:23:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "That you won't be able to tell directly, and reason is simple: displacements are macroscopic observables and you can't decompose them according to constitutive relations.\nI second @jiangwen84 's suggestion. If you really want to decompose some global measure you'll have to get the global measure by homogenizing your quantities of interest in the first place. For example, integrate strain_xx to get total displacement in the x direction, and since strain = elastic strain + creep strain + thermal strain, you can then integrate each of them to get their respective contributions.",
                          "url": "https://github.com/idaholab/moose/discussions/25538#discussioncomment-7071037",
                          "updatedAt": "2023-09-21T14:10:14Z",
                          "publishedAt": "2023-09-21T14:10:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "I see\uff0cthanks.",
                          "url": "https://github.com/idaholab/moose/discussions/25538#discussioncomment-7079409",
                          "updatedAt": "2023-09-22T09:01:35Z",
                          "publishedAt": "2023-09-22T09:01:34Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "self-creep does not effecate",
          "author": {
            "login": "wangzhaohao"
          },
          "bodyText": "Hello, I have coded a creep type. After make -j4. but the creep type does not work\uff0cand there is no warning.\n$\\dot\\varepsilon_{ir} = C_0\\Phi^{C_1}\\sigma_m^{C_2}$\n\n\n\n\u6750\u6599\u7c7b\u578b\n$C_0$\n$C_1$\n$C_2$\n\n\n\n\nSRA\n$3.577\\times10^{-24}$\n0.85\n1.0\n\n\nRXA\n$1.654\\times10^{-24}$\n0.85\n1.0\n\n\nPRXA\n$2.714\\times10^{-24}$\n0.85\n1.0\n\n\nZIRLO\n$2.846\\times10^{-24}$\n0.85\n1.0\n\n\n\nThere is my code\n#pragma once\n#include \"RadialReturnCreepStressUpdateBase.h\"\n\n /**\n  * $\\dot\\varepsilon_{ir} = C_0\\Phi^{C_1}\\sigma_m^{C_2}$\n  * and there are different type zircaloy with different $ C_0 C_1 C_2$\n  */\ntemplate <bool is_ad>\nclass ZrIrradiationCreepTempl : public RadialReturnCreepStressUpdateBaseTempl<is_ad>\n{\npublic:\n  static InputParameters validParams();\n  ZrIrradiationCreepTempl(const InputParameters & parameters);\n\n  virtual Real computeStrainEnergyRateDensity(const GenericMaterialProperty<RankTwoTensor, is_ad> & stress, const GenericMaterialProperty<RankTwoTensor, is_ad> & strain_rate) override;\n\n  virtual bool substeppingCapabilityEnabled() override;\n\n  virtual void resetIncrementalMaterialProperties() override;\n\nprotected:\n  virtual void computeStressInitialize(const GenericReal<is_ad> & effective_trial_stress,\n                                       const GenericRankFourTensor<is_ad> & elasticity_tensor) override;\n\n  virtual void computeStressFinalize(const GenericRankTwoTensor<is_ad> & plastic_strain_increment) override;\n\n  virtual GenericReal<is_ad> computeResidual(const GenericReal<is_ad> & effective_trial_stress,\n                                             const GenericReal<is_ad> & scalar) override\n  {\n    return computeResidualInternal<GenericReal<is_ad>>(effective_trial_stress, scalar);\n  }\n  virtual GenericReal<is_ad> computeDerivative(const GenericReal<is_ad> & effective_trial_stress,\n                                               const GenericReal<is_ad> & scalar) override;\n  virtual GenericChainedReal<is_ad> computeResidualAndDerivative(const GenericReal<is_ad> & effective_trial_stress,\n                                                                 const GenericChainedReal<is_ad> & scalar) override\n  {\n    return computeResidualInternal<GenericChainedReal<is_ad>>(effective_trial_stress, scalar);\n  }\n\n  const GenericVariableValue<is_ad> * const _fast_neutron_flux;\n  MooseEnum _zircaloy_type;\n  GenericReal<is_ad> _power;\n\n  using RadialReturnCreepStressUpdateBaseTempl<is_ad>::_qp;\n  using RadialReturnCreepStressUpdateBaseTempl<is_ad>::_dt;\n  using RadialReturnCreepStressUpdateBaseTempl<is_ad>::_t;\n  using RadialReturnCreepStressUpdateBaseTempl<is_ad>::_three_shear_modulus;\n  using RadialReturnCreepStressUpdateBaseTempl<is_ad>::_creep_strain;\n  using RadialReturnCreepStressUpdateBaseTempl<is_ad>::_creep_strain_old;\n\nprivate:\n  template <typename ScalarType>\n    ScalarType computeResidualInternal(const GenericReal<is_ad> & effective_trial_stress,\n                                       const ScalarType & scalar);\n};\n\ntypedef ZrIrradiationCreepTempl<false> ZrIrradiationCreep;\ntypedef ZrIrradiationCreepTempl<true> ADZrIrradiationCreep;\n#include \"ZrIrradiationCreep.h\"\n\nregisterMooseObject(\"PulseApp\", ZrIrradiationCreep);\nregisterMooseObject(\"PulseApp\", ADZrIrradiationCreep);\n\ntemplate <bool is_ad>\nInputParameters\nZrIrradiationCreepTempl<is_ad>::validParams()\n{\n  InputParameters params = RadialReturnCreepStressUpdateBaseTempl<is_ad>::validParams();\n  params.addCoupledVar(\"fast_neutron_flux\", \"Coupled fast neutron flux\");\n  MooseEnum zircaloy_types(\"SRA RXA PRXA ZIRLO\");\n  params.addParam<MooseEnum>(\"zircaloy_type\", zircaloy_types, \"the different zircaloy materials SRA: stress relief annealed; RXA: recrystallization annealed; PRXA: partially recrystallization annealed; ZIRLO: SRA ZIRLO\");\n\n  return params;\n}\n\ntemplate <bool is_ad>\nZrIrradiationCreepTempl<is_ad>::ZrIrradiationCreepTempl(const InputParameters & parameters) : RadialReturnCreepStressUpdateBaseTempl<is_ad>(parameters),\n  _fast_neutron_flux(&this->template coupledGenericValue<is_ad>(\"fast_neutron_flux\")),\n  _zircaloy_type(this->template getParam<MooseEnum>(\"zircaloy_type\"))\n{\n}\n\ntemplate <bool is_ad>\nvoid\nZrIrradiationCreepTempl<is_ad>::computeStressInitialize(const GenericReal<is_ad> & /*effective_trial_stress*/, const GenericRankFourTensor<is_ad> & /*elasticity_tensor*/)\n{\n    if (_zircaloy_type == \"SRA\")\n    _power = 3.577e-24 * std::pow((*_fast_neutron_flux)[_qp], 0.85);\n  else if (_zircaloy_type == \"RXA\")\n    _power = 1.654e-24 * std::pow((*_fast_neutron_flux)[_qp], 0.85);\n  else if (_zircaloy_type == \"PRXA\")\n    _power = 2.714e-24 * std::pow((*_fast_neutron_flux)[_qp], 0.85);\n  else if (_zircaloy_type == \"ZIRLO\")\n    _power = 2.846e-24 * std::pow((*_fast_neutron_flux)[_qp], 0.85);\n\n}\n\ntemplate <bool is_ad>\ntemplate <typename ScalarType>\nScalarType\nZrIrradiationCreepTempl<is_ad>::computeResidualInternal(const GenericReal<is_ad> & effective_trial_stress, const ScalarType & scalar)\n{\n  const ScalarType stress_delta = effective_trial_stress - _three_shear_modulus * scalar;\n  const ScalarType creep_rate = stress_delta / 1e6 * _power;\n  return creep_rate * _dt - scalar;\n  std::cout<<\"wang\"<<std::endl;\n}\n\ntemplate <bool is_ad>\nGenericReal<is_ad>\nZrIrradiationCreepTempl<is_ad>::computeDerivative(const GenericReal<is_ad> & effective_trial_stress, const GenericReal<is_ad> & scalar)\n{\n  const GenericReal<is_ad> & stress_delta = effective_trial_stress - _three_shear_modulus * scalar;\n  const GenericReal<is_ad> creep_rate_derivate = -_three_shear_modulus / 1e6 * _power;\n  return creep_rate_derivate * _dt - 1.0;\n  std::cout<<\"zhao\"<<std::endl;\n}\n\ntemplate <bool is_ad>\nReal\nZrIrradiationCreepTempl<is_ad>::computeStrainEnergyRateDensity(const GenericMaterialProperty<RankTwoTensor, is_ad> & stress, const GenericMaterialProperty<RankTwoTensor, is_ad> & strain_rate)\n{\n  return 0;\n}\n\ntemplate <bool is_ad>\nvoid\nZrIrradiationCreepTempl<is_ad>::computeStressFinalize(const GenericRankTwoTensor<is_ad> & plastic_strain_increment)\n{\n  _creep_strain[_qp] += plastic_strain_increment;\n}\n\ntemplate <bool is_ad>\nvoid\nZrIrradiationCreepTempl<is_ad>::resetIncrementalMaterialProperties()\n{\n  _creep_strain[_qp] = _creep_strain_old[_qp];\n}\n\ntemplate <bool is_ad>\nbool\nZrIrradiationCreepTempl<is_ad>::substeppingCapabilityEnabled()\n{\n  return this->_use_substepping != RadialReturnStressUpdateTempl<is_ad>::SubsteppingType::NONE;\n}\n\ntemplate class ZrIrradiationCreepTempl<false>;\ntemplate class ZrIrradiationCreepTempl<true>;\ntemplate Real ZrIrradiationCreepTempl<false>::computeResidualInternal<Real>(const Real &, const Real &);\ntemplate ADReal ZrIrradiationCreepTempl<true>::computeResidualInternal<ADReal>(const ADReal &, const ADReal &);\ntemplate ChainedReal ZrIrradiationCreepTempl<false>::computeResidualInternal<ChainedReal>(const Real &, const ChainedReal &);\ntemplate ChainedADReal\nZrIrradiationCreepTempl<true>::computeResidualInternal<ChainedADReal>(const ADReal &, const ChainedADReal &);\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 1\n  ny = 1\n  nz = 1\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[AuxVariables]\n  [flux]\n  []\n[]\n\n[AuxKernels]\n  [flux_aux]\n    type = ConstantAux\n    variable = flux\n    value = 12.5e17\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    strain = FINITE\n    add_variables = true\n    incremental = true\n    automatic_eigenstrain_names = true\n    generate_output = 'hydrostatic_stress strain_xx'\n  []\n[]\n\n[BCs]\n  [x_bot]\n    type = DirichletBC\n    variable = disp_x\n    boundary = left\n    value = 0.0\n  []\n  [y_bot]\n    type = DirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0.0\n  []\n  [pull_disp_y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = top\n    function = pull\n  []\n[]\n\n[Functions]\n  [pull]\n    type = PiecewiseLinear\n    x = '0 10'\n    y = '0 1e-3'\n  []\n[]\n\n[Materials]\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 1e10\n    poissons_ratio = 0.3\n  []\n\n  [elastic_strain]\n    type = ComputeMultipleInelasticStress\n    inelastic_models = \"power_law_creep\"\n #   tangent_operator = nonlinear\n  []\n\ninactive = 'irradiation_creep'\n  [irradiation_creep]\n    type = ZrIrradiationCreep\n    fast_neutron_flux = flux\n    zircaloy_type = PRXA\n  []\n  [power_law_creep]\n    type = PowerLawCreepStressUpdate\n    coefficient = 6.546110837e-15 # 2.714e-24 * 12.5e17^0.85\n    n_exponent = 1\n    activation_energy = 0\n  []\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n  []\n\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n\n  l_max_its = 50\n  nl_max_its = 50\n  nl_rel_tol = 1e-5\n  nl_abs_tol = 1e-5\n  l_tol = 1e-9\n\n  start_time = 0.0\n  end_time = 8640000\n  dt = 86400\n  dtmin = 0.001\n\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n[]\n\n[Outputs]\n  csv = true\n[]\n\n[Postprocessors]\n  [strain]\n    type = ElementAverageValue\n    variable = strain_xx\n  []\n  [hydro]\n    type = ElementAverageValue\n    variable = hydrostatic_stress\n  []\n  [flux]\n    type = AverageNodalVariableValue\n    variable = flux\n  []\n  [dt]\n    type = TimestepSize\n  []\n[]\nthanks for you advice.",
          "url": "https://github.com/idaholab/moose/discussions/25537",
          "updatedAt": "2023-09-22T01:40:00Z",
          "publishedAt": "2023-09-21T02:58:12Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "what do you mean by \"NOT WORKING\"? does not converge? or you can not see only creep deformation?\nYou can output the strain either add a print statement in the computeStressFinalize function or output them in Paraview or PostProcessor.",
                  "url": "https://github.com/idaholab/moose/discussions/25537#discussioncomment-7070169",
                  "updatedAt": "2023-09-21T12:49:56Z",
                  "publishedAt": "2023-09-21T12:49:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "the not working is when i close the ZrIrradiationCreep, the strain_xx is same to the condition that i use the ZrIrradiationCreep, but different with the condition that i use the PowerLawCreep.\nthe creep rate is same, for the model is unit Mpa",
                          "url": "https://github.com/idaholab/moose/discussions/25537#discussioncomment-7070309",
                          "updatedAt": "2023-09-21T13:04:41Z",
                          "publishedAt": "2023-09-21T13:01:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Put a print statement here\ntemplate <bool is_ad>\nvoid\nZrIrradiationCreepTempl<is_ad>::computeStressFinalize(const GenericRankTwoTensor<is_ad> & plastic_strain_increment)\n{\n  _creep_strain[_qp] += plastic_strain_increment;\n  std::cout << \"_creep_strain_xx = \" << _creep_strain[_qp](0,0) << std::endl;\n}\n\nSee if you actually calculate any creep strain. If not, check your calculation. If yes, check the magnitude. It can be too small to be noticed. Then it means either your unit is wrong or the creep is not activated at its condition.",
                          "url": "https://github.com/idaholab/moose/discussions/25537#discussioncomment-7070469",
                          "updatedAt": "2023-09-21T13:17:53Z",
                          "publishedAt": "2023-09-21T13:17:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "i output the _creep_strain_xx, but it zero. so it mean that the code is wrong?",
                          "url": "https://github.com/idaholab/moose/discussions/25537#discussioncomment-7070669",
                          "updatedAt": "2023-09-21T13:35:34Z",
                          "publishedAt": "2023-09-21T13:35:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "adding more print statements to figure out which step is wrong.",
                          "url": "https://github.com/idaholab/moose/discussions/25537#discussioncomment-7070839",
                          "updatedAt": "2023-09-21T13:51:46Z",
                          "publishedAt": "2023-09-21T13:51:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "i have solved! thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/25537#discussioncomment-7070878",
                          "updatedAt": "2023-09-21T13:54:13Z",
                          "publishedAt": "2023-09-21T13:54:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "there is some new in powerLawCreepUpdate.\ntemplate <bool is_ad>\nvoid\nPowerLawCreepStressUpdateTempl<is_ad>::computeStressInitialize(\n    const GenericReal<is_ad> & effective_trial_stress,\n    const GenericRankFourTensor<is_ad> & elasticity_tensor)\n{\n  RadialReturnStressUpdateTempl<is_ad>::computeStressInitialize(effective_trial_stress,\n                                                                elasticity_tensor);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/25537#discussioncomment-7076526",
                          "updatedAt": "2023-09-22T01:39:57Z",
                          "publishedAt": "2023-09-22T01:39:57Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Is it possible to overlap control drum mesh with reactor core lattice?",
          "author": {
            "login": "robertjdemuth"
          },
          "bodyText": "I am new to MOOSE and using the reactor module to mesh a control drum and hexagonal lattice reactor core. The reactor I am trying to model has already been developed and optimized by a previous student in SCALE. However, I am running into an issue creating the mesh with the reactor module because in the SCALE model, the control drum and hexagonal lattice overlap as seen below:\n\nI can't find anything in the docs where you can delete sections of the hexagonal lattice and replace it with another mesh. I have created the model using the PatternedHexMeshGenerator to create the lattice and PeripheralRingMeshGenerator to create the control drum and combined them using XYDelaunayGenerator.\n\nIs this even possible using the reactor module, or would I need to import a geometry meshed using a different software?",
          "url": "https://github.com/idaholab/moose/discussions/25539",
          "updatedAt": "2023-09-21T17:09:21Z",
          "publishedAt": "2023-09-21T14:20:50Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@miaoyinb",
                  "url": "https://github.com/idaholab/moose/discussions/25539#discussioncomment-7071251",
                  "updatedAt": "2023-09-21T14:27:36Z",
                  "publishedAt": "2023-09-21T14:27:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "miaoyinb"
                  },
                  "bodyText": "If the background region (the region outside the central circles) of the partial assembly meshes are the same material (block) as the peripheral region. You can use FlexiblePatternGenerator to do it.\nIf not, meshing it might still be possible but the process would be complex/non-trivial. We can discuss if needed.",
                  "url": "https://github.com/idaholab/moose/discussions/25539#discussioncomment-7071488",
                  "updatedAt": "2023-09-21T14:50:21Z",
                  "publishedAt": "2023-09-21T14:50:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "robertjdemuth"
                          },
                          "bodyText": "The background region of the partial assembly meshes is the same block as the peripheral region, however, there is a duct on the hexagonal lattice with a different block. Would this be an issue?",
                          "url": "https://github.com/idaholab/moose/discussions/25539#discussioncomment-7071633",
                          "updatedAt": "2023-09-21T15:04:03Z",
                          "publishedAt": "2023-09-21T15:04:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "miaoyinb"
                          },
                          "bodyText": "Is the duct connected to the control drum?",
                          "url": "https://github.com/idaholab/moose/discussions/25539#discussioncomment-7072148",
                          "updatedAt": "2023-09-21T15:46:53Z",
                          "publishedAt": "2023-09-21T15:46:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "robertjdemuth"
                          },
                          "bodyText": "The duct is around the hexagonal lattice structure for the fuel pin. The control drum does not have a duct.",
                          "url": "https://github.com/idaholab/moose/discussions/25539#discussioncomment-7072317",
                          "updatedAt": "2023-09-21T16:02:35Z",
                          "publishedAt": "2023-09-21T16:02:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "miaoyinb"
                          },
                          "bodyText": "As your control drum is overlapped with the hexagon structure. At the position of the overlapping, is the duct of the hexagon structure connected to the external surface of the control drum?",
                          "url": "https://github.com/idaholab/moose/discussions/25539#discussioncomment-7072350",
                          "updatedAt": "2023-09-21T16:05:06Z",
                          "publishedAt": "2023-09-21T16:05:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "robertjdemuth"
                          },
                          "bodyText": "The current model in scale just has the duct disappear at the location of intersection, but it could be added or removed. Our design is not at that level of detail yet.",
                          "url": "https://github.com/idaholab/moose/discussions/25539#discussioncomment-7072501",
                          "updatedAt": "2023-09-21T16:22:05Z",
                          "publishedAt": "2023-09-21T16:22:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "miaoyinb"
                          },
                          "bodyText": "Whether the duct needs to be connected to the control drum or not would actually affect the complexity in meshing.\nIf they are not connected, you may use XYMeshLineCutter to cut a fraction of the hexagon structure and then use FlexiblePatternGenerator to fill the gap. Otherwise, I think a non-trivial use of ParsedCurveGenerator + XYDelaunayGenerator may be needed to take care of things.",
                          "url": "https://github.com/idaholab/moose/discussions/25539#discussioncomment-7072937",
                          "updatedAt": "2023-09-21T17:09:22Z",
                          "publishedAt": "2023-09-21T17:09:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multicomponent phase-field simulations",
          "author": {
            "login": "jerewang20"
          },
          "bodyText": "I am fairly new to phase-field simulations, but I wanted to try using them to explore liquid-liquid phase separations.  I did see some examples for multiphase models, but I am struggling a bit to implement a multi-component model.  I would like to simulate a system with 4 charged species (two positive and two negative) and solvent, and I was wondering what is the best way to ensure the concentrations of all species sum to 1, and ensure that charge neutrality is maintained.",
          "url": "https://github.com/idaholab/moose/discussions/25451",
          "updatedAt": "2023-09-21T15:45:49Z",
          "publishedAt": "2023-09-13T16:42:56Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "@vprithiv just worked on this! Not with charged liquids though.",
                  "url": "https://github.com/idaholab/moose/discussions/25451#discussioncomment-6993155",
                  "updatedAt": "2023-09-13T17:25:17Z",
                  "publishedAt": "2023-09-13T17:24:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "One way to ensure the concentrations of all species sum to 1 is to remove one concentration and substitute it by 1-sum(c_i). Another way would be to use the Lagrange Multiplier approach we have implemented.",
                          "url": "https://github.com/idaholab/moose/discussions/25451#discussioncomment-6993169",
                          "updatedAt": "2023-09-13T17:26:18Z",
                          "publishedAt": "2023-09-13T17:26:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "I'd go farther and just have two variables: p and n, for the concentrations of one of the positive and one of the negative species.  Then the second positive species has concentration 0.5-p, the second negative 0.5-n.  (Assuming all charged species are singly-charged; the same trick works if some are doubly- or whatever but the numbers differ)",
                          "url": "https://github.com/idaholab/moose/discussions/25451#discussioncomment-6993481",
                          "updatedAt": "2023-09-13T18:01:58Z",
                          "publishedAt": "2023-09-13T18:01:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vprithiv"
                          },
                          "bodyText": "This is what I have been recently working on: simulating a two-phase flow using a combined Navier-Stokes and Cahn-Hilliard equations. I employed a single order parameter, which can take values of -1 or 1. The phase field was primarily used to track the interface between the two fluids. Material properties in the Navier-Stokes equations, namely density and viscosity, were defined as functions of the order parameter. If you are working on anything similar or find this information helpful, I can provide you with the relevant references.",
                          "url": "https://github.com/idaholab/moose/discussions/25451#discussioncomment-6993771",
                          "updatedAt": "2023-09-13T18:36:27Z",
                          "publishedAt": "2023-09-13T18:36:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jerewang20"
                          },
                          "bodyText": "@dschwen I did see the Lagrange Multiplier kernel, and I'll look into it more!  It might also help with the charge neutrality.  I was able to directly add the electrostatic penalty to the mixing energy for enforce charge neutrality in my simulations, but it does seem to be computationally costly, and so I was wondering if there was a more efficient way to impose constraints on the component concentrations.\nIf you have a good example of the lagrange multiplier being implemented somewhere I think that would help me a lot!",
                          "url": "https://github.com/idaholab/moose/discussions/25451#discussioncomment-6994494",
                          "updatedAt": "2023-09-13T20:05:26Z",
                          "publishedAt": "2023-09-13T20:03:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jerewang20"
                          },
                          "bodyText": "@vprithiv I am interested in implementing hydrodynamics into my phase field simulations, although currently I am more focused on the spinodal decomposition aspect of polyelectrolyte coacervates systems.  Still, I would love to read up more on coupling Navier-Stokes with Cahn-Hilliard!",
                          "url": "https://github.com/idaholab/moose/discussions/25451#discussioncomment-6994530",
                          "updatedAt": "2023-09-13T20:08:36Z",
                          "publishedAt": "2023-09-13T20:08:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jerewang20"
                  },
                  "bodyText": "I'd go farther and just have two variables: p and n, for the concentrations of one of the positive and one of the negative species. Then the second positive species has concentration 0.5-p, the second negative 0.5-n. (Assuming all charged species are singly-charged; the same trick works if some are doubly- or whatever but the numbers differ)\n\nI will give it a shot!  I do have a significant amount of solvent in both phases, but perhaps I just need to rewrite the free energies of mixing.",
                  "url": "https://github.com/idaholab/moose/discussions/25451#discussioncomment-6995284",
                  "updatedAt": "2023-09-13T21:54:26Z",
                  "publishedAt": "2023-09-13T21:54:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "vprithiv"
                          },
                          "bodyText": "These may help:\nP Yue et al., Phase-field simulations of interfacial dynamics in viscoelastic fluids using finite elements with adaptive meshing\nC Zhou et al., 3D phase-field simulations of interfacial dynamics in Newtonian and viscoelastic fluids",
                          "url": "https://github.com/idaholab/moose/discussions/25451#discussioncomment-7072123",
                          "updatedAt": "2023-09-21T15:45:50Z",
                          "publishedAt": "2023-09-21T15:45:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}