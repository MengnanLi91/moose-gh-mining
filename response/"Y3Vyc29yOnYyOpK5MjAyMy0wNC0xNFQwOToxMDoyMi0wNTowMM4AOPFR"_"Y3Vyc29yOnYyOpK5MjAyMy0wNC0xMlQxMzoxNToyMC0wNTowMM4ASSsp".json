{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNC0xMlQxMzoxNToyMC0wNTowMM4ASSsp"
    },
    "edges": [
      {
        "node": {
          "title": "Different results between New Lagrangian Kernels and old system",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hello MOOSEer,\nI'm trying to compare the New Lagrangian Kernels with the old ones. I found that for small strain (or large_kinematics = false), the results of uniaxial tension are the same, but for finite strain (or large_kinematics = true), the results are different, as shown in the figure below. Are the results reasonable or do I misunderstand somewhere? Here are the input files I used. Thanks. https://github.com/rh201/New-Lagrangian-Kernels.git",
          "url": "https://github.com/idaholab/moose/discussions/24067",
          "updatedAt": "2023-04-14T13:18:08Z",
          "publishedAt": "2023-04-14T09:54:17Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "There are three objective rates that come with the new system. The default is Truesdell IIRC. Can you also compare Jaumann and Green-Naghdi rates on the same plot?\nShort answer is all models are wrong, some are useful. Pick the one most suitable for your problem. Otherwise, pick your favorite.",
                  "url": "https://github.com/idaholab/moose/discussions/24067#discussioncomment-5615473",
                  "updatedAt": "2023-04-14T12:20:19Z",
                  "publishedAt": "2023-04-14T12:20:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thanks @hugary1995 for the advice. Here I plot the results with three different objective_rate, and the other two ways works perfect.",
                          "url": "https://github.com/idaholab/moose/discussions/24067#discussioncomment-5616017",
                          "updatedAt": "2023-04-14T13:15:43Z",
                          "publishedAt": "2023-04-14T13:15:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to specify different quadrature in different direction",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hi\nI have a sample 2D domain below\n\nI want to use different quadrature rules in both x and y-directions. Specifically, I want to use full integration in the y-axis with fine discretization, and mid-point rule in the x-direction. How do I specify these directions?\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/23915",
          "updatedAt": "2023-04-29T02:48:48Z",
          "publishedAt": "2023-03-30T21:46:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "You ll want to build your own quadrature rule to do this, we dont have that one",
                  "url": "https://github.com/idaholab/moose/discussions/23915#discussioncomment-5482536",
                  "updatedAt": "2023-03-30T21:49:15Z",
                  "publishedAt": "2023-03-30T21:49:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "This has to be in the libmesh, right?",
                          "url": "https://github.com/idaholab/moose/discussions/23915#discussioncomment-5555556",
                          "updatedAt": "2023-04-07T17:50:27Z",
                          "publishedAt": "2023-04-07T17:50:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes",
                          "url": "https://github.com/idaholab/moose/discussions/23915#discussioncomment-5556221",
                          "updatedAt": "2023-04-07T19:48:02Z",
                          "publishedAt": "2023-04-07T19:48:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "I want to modify the way the tensor_product_quad function works in the quadrature.C below\nhttps://github.com/libMesh/libmesh/blob/14633497ea867c56053d1ea7a1fbe0442727eb24/src/quadrature/quadrature.C\nThe idea is to have parameters npx and npy in the quadrature block. This npx and npy variables would help in determining if the quadrature tensor product is to be done only in one direction (for a 2D case), or for corners. The npx and npy variables would be integers.\nI know I would have to populate the tensor_product_quad function in the quadrature.C file based on the values I inputed as npx and npy in the input file by including the variables in the header file:\nhttps://github.com/libMesh/libmesh/blob/14633497ea867c56053d1ea7a1fbe0442727eb24/include/quadrature/quadrature.h\nHow best can I achieve this?",
                          "url": "https://github.com/idaholab/moose/discussions/23915#discussioncomment-5607732",
                          "updatedAt": "2023-04-13T18:17:47Z",
                          "publishedAt": "2023-04-13T18:16:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Start by making a new quadrature class in libmesh.\nYou can define new weights. & q points but you can also override all these routines, including tensor_product_quad to make them behave differently for your quadrature\nOnce it s accepted, we can add it to the list in MOOSE",
                          "url": "https://github.com/idaholab/moose/discussions/23915#discussioncomment-5610510",
                          "updatedAt": "2023-04-14T00:47:18Z",
                          "publishedAt": "2023-04-14T00:47:17Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "question about variable value transfer UO in THM",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "@joshuahansel Hi josh, I wrote a hexagonal assembly which has 18 channels. And I met some new problems:\nI made some changes to the ElementalVariableTransferUO:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"FLARE_ElementalVariableTransferUO.h\"\n#include \"MooseMesh.h\"\n#include \"KDTree.h\"\n#include \"Assembly.h\"\n\nregisterMooseObject(\"ThermalHydraulicsApp\", FLARE_ElementalVariableTransferUO);\n\nInputParameters\nFLARE_ElementalVariableTransferUO::validParams()\n{\n  InputParameters params = ElementUserObject::validParams();\n  params.addRequiredParam<ChannelMapping *>(\"_channel_mapping\",\n                                                  \"Flow channel alignement object\");\n  params.addCoupledVar(\"w\", \"Lateral velocity between flow channels\");\n  params.addCoupledVar(\"H\", \"Specific total enthalpy in current flow channel\");\n  params.addCoupledVar(\"rho\", \"Density in current flow channel\");\n  params.addCoupledVar(\"vel\", \"Velocity in current flow channel\");\n  params.addCoupledVar(\"T\", \"Temperature in current flow channel\");\n  params.addCoupledVar(\"A\", \"Area of current flow channel\");\n  params.addCoupledVar(\"p\", \"Pressure in current flow channel\");\n  params.addClassDescription(\n      \"Base class for caching variables between 2 flow channels.\");\n  return params;\n}\n\nFLARE_ElementalVariableTransferUO::FLARE_ElementalVariableTransferUO(\n    const InputParameters & parameters)\n  : ElementUserObject(parameters),\n    _channel_mapping(*getParam<ChannelMapping *>(\"_channel_mapping\")),\n    _w_var(getVar(\"w\", 0)),\n    _H_var(getVar(\"H\", 0)),\n    _rho_var(getVar(\"rho\", 0)),\n    _vel_var(getVar(\"vel\", 0)),\n    _T_var(getVar(\"T\", 0)),\n    _A_var(getVar(\"A\", 0)),\n    _p_var(getVar(\"p\", 0))\n\n{\n}\n\nvoid\nFLARE_ElementalVariableTransferUO::initialize()\n{\n}\n\nvoid\nFLARE_ElementalVariableTransferUO::execute()\n{\n    dof_id_type nearest_elem_id = _channel_mapping.getNearestElemID(_current_elem->id());\n    // get elemental variable value in current element\n    ADReal _w,_H,_rho,_vel,_T,_A,_p;\n    _w = _w_var->getElementalValue(_current_elem);\n    _H = _H_var->getElementalValue(_current_elem);\n    _rho = _rho_var->getElementalValue(_current_elem);\n    _vel = _vel_var->getElementalValue(_current_elem);\n    _T = _T_var->getElementalValue(_current_elem);\n    _A = _A_var->getElementalValue(_current_elem);\n    _p = _p_var->getElementalValue(_current_elem);\n\n    // get the local DoF indices corresponding to the variable on the element\n//    std::vector<dof_id_type> dof_indices;\n//    _w_var->dofMap().dof_indices(_current_elem, dof_indices, _w_var->number());\n//    _H_var->dofMap().dof_indices(_current_elem, dof_indices, _H_var->number());\n//    _rho_var->dofMap().dof_indices(_current_elem, dof_indices, _rho_var->number());\n//    _vel_var->dofMap().dof_indices(_current_elem, dof_indices, _vel_var->number());\n//    _T_var->dofMap().dof_indices(_current_elem, dof_indices, _T_var->number());\n//    _A_var->dofMap().dof_indices(_current_elem, dof_indices, _A_var->number());\n//    _p_var->dofMap().dof_indices(_current_elem, dof_indices, _p_var->number());\n\n    // \"seed\" the derivative\n//    Moose::derivInsert(_vel.derivatives(), dof_indices[0], 1.0);\n//    Moose::derivInsert(_rho.derivatives(), dof_indices[0], 1.0);\n//    Moose::derivInsert(_p.derivatives(), dof_indices[0], 1.0);\n\n    _adj_w[nearest_elem_id] = _w;\n    _adj_H[nearest_elem_id] = _H;\n    _adj_rho[nearest_elem_id] = _rho;\n    _adj_vel[nearest_elem_id] = _vel;\n    _adj_T[nearest_elem_id] = _T;\n    _adj_A[nearest_elem_id] = _A;\n    _adj_p[nearest_elem_id] = _p;\n\n}\n\nvoid\nFLARE_ElementalVariableTransferUO::finalize()\n{\n}\n\nvoid\nFLARE_ElementalVariableTransferUO::threadJoin(const UserObject & y)\n{\n  const FLARE_ElementalVariableTransferUO & uo =\n      static_cast<const FLARE_ElementalVariableTransferUO &>(y);\n    for (auto & it : uo._adj_w)\n      _adj_w[it.first] = it.second;\n    for (auto & it : uo._adj_H)\n      _adj_H[it.first] = it.second;\n    for (auto & it : uo._adj_rho)\n      _adj_rho[it.first] = it.second;\n    for (auto & it : uo._adj_vel)\n      _adj_vel[it.first] = it.second;\n    for (auto & it : uo._adj_T)\n      _adj_T[it.first] = it.second;\n    for (auto & it : uo._adj_A)\n        _adj_A[it.first] = it.second;\n    for (auto & it : uo._adj_p)\n      _adj_p[it.first] = it.second;\n}\n\nconst ADReal &\nFLARE_ElementalVariableTransferUO::getAdjacentW(dof_id_type element_id) const\n{\n  Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n  auto it = _adj_w.find(element_id);\n  if (it != _adj_w.end())\n    return it->second;\n  else\n    mooseError(name(), \": Requested Lateral Velocity for element \", element_id, \" was not computed.\");\n}\n\nconst ADReal &\nFLARE_ElementalVariableTransferUO::getAdjacentH(dof_id_type element_id) const\n{\n  Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n  auto it = _adj_H.find(element_id);\n  if (it != _adj_H.end())\n    return it->second;\n  else\n    mooseError(name(), \": Requested Specific Total Enthalpy for element \", element_id, \" was not computed.\");\n}\n\nconst ADReal &\nFLARE_ElementalVariableTransferUO::getAdjacentRHO(dof_id_type element_id) const\n{\n  Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n  auto it = _adj_rho.find(element_id);\n  if (it != _adj_rho.end())\n    return it->second;\n  else\n    mooseError(name(), \": Requested Density for element \", element_id, \" was not computed.\");\n}\n\nconst ADReal &\nFLARE_ElementalVariableTransferUO::getAdjacentVEL(dof_id_type element_id) const\n{\n  Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n  auto it = _adj_vel.find(element_id);\n  if (it != _adj_vel.end())\n    return it->second;\n  else\n    mooseError(name(), \": Requested Velocity for element \", element_id, \" was not computed.\");\n}\n\nconst ADReal &\nFLARE_ElementalVariableTransferUO::getAdjacentT(dof_id_type element_id) const\n{\n  Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n  auto it = _adj_T.find(element_id);\n  if (it != _adj_T.end())\n    return it->second;\n  else\n    mooseError(name(), \": Requested Temperature for element \", element_id, \" was not computed.\");\n}\n\nconst ADReal &\nFLARE_ElementalVariableTransferUO::getAdjacentA(dof_id_type element_id) const\n{\n  Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n  auto it = _adj_A.find(element_id);\n  if (it != _adj_A.end())\n    return it->second;\n  else\n    mooseError(name(), \": Requested Area for element \", element_id, \" was not computed.\");\n}\n\nconst ADReal &\nFLARE_ElementalVariableTransferUO::getAdjacentP(dof_id_type element_id) const\n{\n  Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n  auto it = _adj_p.find(element_id);\n  if (it != _adj_p.end())\n    return it->second;\n  else\n    mooseError(name(), \": Requested Pressure for element \", element_id, \" was not computed.\");\n}\n\n\nI use the addCoupledVar interface because I want to add some flexibility. But there is some error info when I run the input file.\nThe info using debugger is :\nProcess 383340 launched: '/home/linux/projects/moose/modules/thermal_hydraulics/thermal_hydraulics-dbg' (x86_64)\nwarning: (x86_64) /home/linux/mambaforge3/envs/moose/lib/libstdc++.so.6 unsupported DW_FORM value: 0x1e\n\nFramework Information:\nMOOSE Version:           git commit 5d2aa15248 on 2022-04-01\nLibMesh Version:         \nPETSc Version:           3.16.5\nSLEPc Version:           3.16.2\nCurrent Time:            Tue Mar 28 09:29:56 2023\nExecutable Timestamp:    Tue Mar 28 09:28:53 2023\n\nParallelism:\n  Num Processors:          1\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          1\n  Spatial Dimension:       3\n  Nodes:                   558\n  Elems:                   540\n  Num Subdomains:          18\n\nNonlinear System:\n  Num DOFs:                2340\n  Num Local DOFs:          2340\n  Variables:               { \"rhoA\" \"rhoEA\" \"rhouA\" } \"w1\" \"w2\" \n  Finite Element Types:    \"MONOMIAL\" \"MONOMIAL\" \"MONOMIAL\" \n  Approximation Orders:    \"CONSTANT\" \"CONSTANT\" \"CONSTANT\" \n\nAuxiliary System:\n  Num DOFs:                6498\n  Num Local DOFs:          6498\n  Variables:               \"A\" \"A_linear\" { \"H\" \"P_hf\" \"T\" \"e\" \"p\" \"rho\" \"v\" \"vel_x\" \"vel_y\" \"vel_z\" \n                             } \n  Finite Element Types:    \"MONOMIAL\" \"LAGRANGE\" \"MONOMIAL\" \n  Approximation Orders:    \"CONSTANT\" \"FIRST\" \"CONSTANT\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  Solver Mode:             Preconditioned JFNK\n  MOOSE Preconditioner:    SMP\n\n\n    Setting Up Initial Conditions......                                                  [ 43.38 s] [    8 MB]\n    Finished Initializing Auxiliary System                                               [  5.53 s] [    0 MB]\nProcess 383340 stopped\n* thread #1, name = 'thermal_hydraul', stop reason = signal SIGSEGV: invalid address (fault address: 0x878)\n    frame #0: 0x00007ffff3cf052c libmoose-dbg.so.0`std::__uniq_ptr_impl<MooseVariableData<double>, std::default_delete<MooseVariableData<double> > >::_M_ptr(this=0x0000000000000878) const at unique_ptr.h:173:58\n   170 \t      }\n   171 \t\n   172 \t      pointer&   _M_ptr() { return std::get<0>(_M_t); }\n-> 173 \t      pointer    _M_ptr() const { return std::get<0>(_M_t); }\n   174 \t      _Dp&       _M_deleter() { return std::get<1>(_M_t); }\n   175 \t      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }\n   176 \t\n(lldb) bt\n* thread #1, name = 'thermal_hydraul', stop reason = signal SIGSEGV: invalid address (fault address: 0x878)\n  * frame #0: 0x00007ffff3cf052c libmoose-dbg.so.0`std::__uniq_ptr_impl<MooseVariableData<double>, std::default_delete<MooseVariableData<double> > >::_M_ptr(this=0x0000000000000878) const at unique_ptr.h:173:58\n    frame #1: 0x00007ffff3ce9440 libmoose-dbg.so.0`std::unique_ptr<MooseVariableData<double>, std::default_delete<MooseVariableData<double> > >::get(this=0x0000000000000878) const at unique_ptr.h:422:27\n    frame #2: 0x00007ffff3cdf92c libmoose-dbg.so.0`std::unique_ptr<MooseVariableData<double>, std::default_delete<MooseVariableData<double> > >::operator->(this=0x0000000000000878) const at unique_ptr.h:416:12\n    frame #3: 0x00007ffff4dd8ca3 libmoose-dbg.so.0`MooseVariableFE<double>::getElementalValue(this=0x0000000000000000, elem=0x0000555555bdffa0, idx=0) const at MooseVariableFE.C:225:42\n    frame #4: 0x00007ffff7a4195a libthermal_hydraulics-dbg.so.0`FLARE_ElementalVariableTransferUO::execute(this=0x0000555558ea7630) at FLARE_ElementalVariableTransferUO.C:63:39\n    frame #5: 0x00007ffff4131b5a libmoose-dbg.so.0`ComputeUserObjectsThread::onElement(this=0x00007fffffffaf80, elem=0x0000555555bdffa0) at ComputeUserObjectsThread.C:123:16\n    frame #6: 0x00007ffff6e3cc3f libnavier_stokes-dbg.so.0`ThreadedElementLoopBase<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> >::operator(this=0x00007fffffffaf80, range=0x0000555555e3b0c0, bypass_threading=false)(libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> const&, bool) at ThreadedElementLoopBase.h:226:18\n    frame #7: 0x00007ffff4885625 libmoose-dbg.so.0`void libMesh::Threads::parallel_reduce<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*>, ComputeUserObjectsThread>(range=0x0000555555e3b0c0, body=0x00007fffffffaf80) at threads_pthread.h:380:9\n    frame #8: 0x00007ffff48440b2 libmoose-dbg.so.0`FEProblemBase::computeUserObjectsInternal(this=0x0000555555be9a00, type=0x00007ffff5dcd380, group=0x00007fffffffb364, query=0x00007fffffffb220) at FEProblemBase.C:3886:29\n    frame #9: 0x00007ffff48432a2 libmoose-dbg.so.0`FEProblemBase::computeUserObjects(this=0x0000555555be9a00, type=0x00007ffff5dcd380, group=0x00007fffffffb364) at FEProblemBase.C:3812:29\n    frame #10: 0x00007ffff4842ae6 libmoose-dbg.so.0`FEProblemBase::execute(this=0x0000555555be9a00, exec_type=0x00007ffff5dcd380) at FEProblemBase.C:3725:21\n    frame #11: 0x00007ffff4828dbc libmoose-dbg.so.0`FEProblemBase::initialSetup(this=0x0000555555be9a00) at FEProblemBase.C:987:12\n    frame #12: 0x00007ffff3e81bb5 libmoose-dbg.so.0`Transient::init(this=0x0000555555e98ac0) at Transient.C:249:24\n    frame #13: 0x00007ffff4f2c91a libmoose-dbg.so.0`MooseApp::executeExecutioner(this=0x00005555556f6650) at MooseApp.C:1085:23\n    frame #14: 0x00007ffff4f2f4fa libmoose-dbg.so.0`MooseApp::run(this=0x00005555556f6650) at MooseApp.C:1400:23\n    frame #15: 0x00005555555577d3 thermal_hydraulics-dbg`main(argc=3, argv=0x00007fffffffc0c8) at main.C:34:11\n    frame #16: 0x00007fffea0f7493 libc.so.6`__libc_start_main + 243\n    frame #17: 0x0000555555557079 thermal_hydraulics-dbg`_start + 41\n\nIt seems there is something wrong with the FLARE_ElementalVariableTransferUO in line 63:\n_rho = _rho_var->getElementalValue(_current_elem);\nBut I don't see what the problem is. Do you have any ideas?\nEthan",
          "url": "https://github.com/idaholab/moose/discussions/23872",
          "updatedAt": "2023-04-29T02:50:58Z",
          "publishedAt": "2023-03-28T13:42:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "It's not obvious. Is there something different about rho than H? Can you comment out the rho line and see if it occurs with other variables?",
                  "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5454975",
                  "updatedAt": "2023-03-28T14:34:14Z",
                  "publishedAt": "2023-03-28T14:34:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "You inspire me. I replace the UO in TwoChannelsModel with the new UO. And it can calculate successfully. I think I should check the new component first.",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5460295",
                          "updatedAt": "2023-03-29T01:48:30Z",
                          "publishedAt": "2023-03-29T01:48:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Ethan-xj"
                  },
                  "bodyText": "@joshuahansel Hello josh, do you know how to increase the --param max-gcse-memory in MOOSE? It probably is a parameter in gcc.\nWhen I compile in the terminal, it says:\n/home/linux/projects/moose/modules/thermal_hydraulics/src/components/FLARE_HEX_7RODS.C:5967:1: warning: const/copy propagation disabled: 25859 basic blocks and 62092 registers; increase '--param max-gcse-memory' above 200872712 [-Wdisabled-optimization]\nI try some instruction codes but failed.\nEthan",
                  "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5485756",
                  "updatedAt": "2023-03-31T07:17:08Z",
                  "publishedAt": "2023-03-31T07:17:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Sorry, I have no idea what this is even talking about!",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5488491",
                          "updatedAt": "2023-03-31T12:03:56Z",
                          "publishedAt": "2023-03-31T12:03:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "@GiudGiud Hello Giud, do you have any ideas about the --param max-gcse-memory ?",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5504746",
                          "updatedAt": "2023-04-03T01:19:42Z",
                          "publishedAt": "2023-04-03T01:19:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "never dealt with that.\nI wouldnt worry about it though. Just keep it in the back of your mind, and if you profile the code and notice a large slowdown in that area of the code, then it could be that and you'd want to address it",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5504792",
                          "updatedAt": "2023-04-03T01:30:10Z",
                          "publishedAt": "2023-04-03T01:30:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "OK, thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5509212",
                          "updatedAt": "2023-04-03T12:05:49Z",
                          "publishedAt": "2023-04-03T12:05:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Ethan-xj"
                  },
                  "bodyText": "@joshuahansel Hi josh, I'm working on a larger case these days since I calculated a two-channels case not long ago. The convergence of the two-channels case is not so good, but the case can be converged. But the larger case(18-channels case) is not converged at all, the residual of linear iterations are not dropping for a specific time step. And I add these options in the Executioner block:\n  automatic_scaling = true\n  off_diagonals_in_auto_scaling = true\n  line_search = 'none'\n\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -pc_svd_monitor'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu superlu_dist'\n\n\nThe residual start to drop, but not enough to converge.\nSo I start to think about the correctness of this method. Maybe there's some mistakes in this method and with the increase of the case's scale, the mistake became apparent.\nI want to ask: When I add the density and pressure of channel2 into channel1's kernel. What does the Jacobian look like? Will them be counted as variables? Or just a number?\nNow the situation is: I can calculate the lateral momentum equation in 18-channels case. But once I couple w(actually w1 and w2, because there are multiple channels adjacent to each other) into the other equations, the case start to become non-converged. I have no idea about how to make the case converged.\nEthan",
                  "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5509613",
                  "updatedAt": "2023-04-03T12:45:58Z",
                  "publishedAt": "2023-04-03T12:45:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Hi Ethan,\nI don't know how well certain solve options work, like auto-scaling, since I don't try it very often. Definitely experiment with different combinations of options. For my applications (which are probably a bit smaller than yours), I typically just use -pc_type lu. It's surprising that your linear residuals are not dropping with LU preconditioner. Just to experiment, do -pc_type lu -ksp_type preonly, which does a true direct linear solve - that should converge in a single linear iteration (I'm not suggesting this as a solution, just troubleshooting at least).\n\nWhat does the Jacobian look like? Will them be counted as variables? Or just a number?\n\nNot sure what you mean. For the AD strategy we discussed, the Jacobians with respect to these DoFs should be handled correctly, without any approximation.\n\nI can calculate the lateral momentum equation in 18-channels case. But once I couple w(actually w1 and w2, because there are multiple channels adjacent to each other) into the other equations, the case start to become non-converged. I have no idea about how to make the case converged.\n\nI don't understand. So first you try solving the lateral momentum equations independently of the others, which works? But then you add terms to your other equations involving w, and you have trouble converging? If that's the case, I'm not sure. Are these terms correct? Do you have their Jacobians accounted for? Maybe you could try using PC type of FDP rather than SMP (if your problem isn't too large) to see if the nonlinear solve is better in that case, which would imply that you need to fix some Jacobians. However, I've found that sometimes FDP doesn't do well anyway, despite being approximately correct.",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5510038",
                          "updatedAt": "2023-04-03T13:22:40Z",
                          "publishedAt": "2023-04-03T13:22:39Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "@joshuahansel\n\nI don't know how well certain solve options work, like auto-scaling, since I don't try it very often. Definitely experiment with different combinations of options. For my applications (which are probably a bit smaller than yours), I typically just use -pc_type lu. It's surprising that your linear residuals are not dropping with LU preconditioner. Just to experiment, do -pc_type lu -ksp_type preonly, which does a true direct linear solve - that should converge in a single linear iteration (I'm not suggesting this as a solution, just troubleshooting at least).\n\nThis is my [Executioner]:\n[Executioner]\n  type = Transient\n  start_time = 0\n  end_time = 3\n  dt = 0.1\n\n#  line_search = basic\n  solve_type = 'PJFNK'\n  l_max_its = 100\n\n  nl_rel_tol = 1e-5\n  nl_abs_tol = 1e-5\n  nl_max_its = 100\n\n  automatic_scaling = true\n  off_diagonals_in_auto_scaling = true\n  line_search = 'none'\n\n  petsc_options = '-ksp_type<preonly>'\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n  \n[]\n\nAnd the residual is like:\nTime Step 0, time = 0\n\nTime Step 1, time = 0.1, dt = 0.1\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 2.455059e+02\n      0 Linear |R| = 2.455059e+02\n      1 Linear |R| = 1.924805e+01\n      2 Linear |R| = 1.587375e+01\n      3 Linear |R| = 1.413960e+01\n      4 Linear |R| = 1.356323e+01\n      5 Linear |R| = 1.285219e+01\n      6 Linear |R| = 1.282729e+01\n      7 Linear |R| = 1.279495e+01\n      8 Linear |R| = 1.273282e+01\n      9 Linear |R| = 1.273265e+01\n     10 Linear |R| = 1.253161e+01\n     11 Linear |R| = 1.253013e+01\n     12 Linear |R| = 1.251579e+01\n     13 Linear |R| = 1.229304e+01\n     14 Linear |R| = 1.228967e+01\n     15 Linear |R| = 1.221899e+01\n     16 Linear |R| = 1.220805e+01\n     17 Linear |R| = 1.219621e+01\n     18 Linear |R| = 1.216995e+01\n     19 Linear |R| = 1.216977e+01\n     20 Linear |R| = 1.216974e+01\n  Linear solve did not converge due to DIVERGED_ITS iterations 20\n 1 Nonlinear |R| = 1.943354e+01\n      0 Linear |R| = 1.943354e+01\n      1 Linear |R| = 1.943290e+01\n      2 Linear |R| = 1.943276e+01\n      3 Linear |R| = 1.943271e+01\n      4 Linear |R| = 1.942160e+01\n      5 Linear |R| = 1.933211e+01\n      6 Linear |R| = 1.933120e+01\n      7 Linear |R| = 1.931915e+01\n      8 Linear |R| = 1.931915e+01\n      9 Linear |R| = 1.910380e+01\n     10 Linear |R| = 1.908773e+01\n     11 Linear |R| = 1.908750e+01\n     12 Linear |R| = 1.906571e+01\n     13 Linear |R| = 1.895970e+01\n     14 Linear |R| = 1.893580e+01\n     15 Linear |R| = 1.893309e+01\n     16 Linear |R| = 1.890683e+01\n     17 Linear |R| = 1.853304e+01\n     18 Linear |R| = 1.851893e+01\n     19 Linear |R| = 1.851336e+01\n     20 Linear |R| = 1.847420e+01\n  Linear solve did not converge due to DIVERGED_ITS iterations 20\n 2 Nonlinear |R| = 1.858191e+01\n      0 Linear |R| = 1.858191e+01\n      1 Linear |R| = 1.858113e+01\n      2 Linear |R| = 1.857834e+01\n      3 Linear |R| = 1.856644e+01\n      4 Linear |R| = 1.854676e+01\n      5 Linear |R| = 1.854324e+01\n      6 Linear |R| = 1.854309e+01\n      7 Linear |R| = 1.852844e+01\n      8 Linear |R| = 1.852452e+01\n      9 Linear |R| = 1.852201e+01\n     10 Linear |R| = 1.850517e+01\n     11 Linear |R| = 1.846804e+01\n     12 Linear |R| = 1.845457e+01\n     13 Linear |R| = 1.840026e+01\n     14 Linear |R| = 1.838043e+01\n     15 Linear |R| = 1.836730e+01\n     16 Linear |R| = 1.831367e+01\n     17 Linear |R| = 1.806890e+01\n     18 Linear |R| = 1.803449e+01\n     19 Linear |R| = 1.799668e+01\n     20 Linear |R| = 1.799663e+01\n  Linear solve did not converge due to DIVERGED_ITS iterations 20\n 3 Nonlinear |R| = 1.812376e+01\n      0 Linear |R| = 1.812376e+01\n      1 Linear |R| = 1.812342e+01\n      2 Linear |R| = 1.811398e+01\n      3 Linear |R| = 1.811271e+01\n      4 Linear |R| = 1.810790e+01\n      5 Linear |R| = 1.810379e+01\n      6 Linear |R| = 1.810295e+01\n      7 Linear |R| = 1.809153e+01\n      8 Linear |R| = 1.808781e+01\n      9 Linear |R| = 1.805791e+01\n     10 Linear |R| = 1.804930e+01\n     11 Linear |R| = 1.804921e+01\n     12 Linear |R| = 1.803793e+01\n     13 Linear |R| = 1.802701e+01\n     14 Linear |R| = 1.802388e+01\n     15 Linear |R| = 1.801677e+01\n     16 Linear |R| = 1.801424e+01\n     17 Linear |R| = 1.770647e+01\n     18 Linear |R| = 1.770312e+01\n     19 Linear |R| = 1.769540e+01\n     20 Linear |R| = 1.768225e+01\n  Linear solve did not converge due to DIVERGED_ITS iterations 20\n 4 Nonlinear |R| = 1.775048e+01\n      0 Linear |R| = 1.775048e+01\n      1 Linear |R| = 1.775048e+01\n      2 Linear |R| = 1.774899e+01\n      3 Linear |R| = 1.774626e+01\n      4 Linear |R| = 1.774492e+01\n      5 Linear |R| = 1.774491e+01\n      6 Linear |R| = 1.774088e+01\n      7 Linear |R| = 1.773989e+01\n      8 Linear |R| = 1.773176e+01\n      9 Linear |R| = 1.773024e+01\n     10 Linear |R| = 1.772377e+01\n     11 Linear |R| = 1.772212e+01\n     12 Linear |R| = 1.767269e+01\n     13 Linear |R| = 1.765532e+01\n     14 Linear |R| = 1.765440e+01\n     15 Linear |R| = 1.758903e+01\n     16 Linear |R| = 1.753487e+01\n     17 Linear |R| = 1.750003e+01\n     18 Linear |R| = 1.749350e+01\n     19 Linear |R| = 1.749314e+01\n     20 Linear |R| = 1.749309e+01\n  Linear solve did not converge due to DIVERGED_ITS iterations 20\n 5 Nonlinear |R| = 1.754063e+01\n      0 Linear |R| = 1.754063e+01\n      1 Linear |R| = 1.754062e+01\n      2 Linear |R| = 1.753922e+01\n      3 Linear |R| = 1.753839e+01\n      4 Linear |R| = 1.750152e+01\n      5 Linear |R| = 1.748760e+01\n      6 Linear |R| = 1.748131e+01\n      7 Linear |R| = 1.746809e+01\n      8 Linear |R| = 1.744389e+01\n      9 Linear |R| = 1.742203e+01\n     10 Linear |R| = 1.740935e+01\n     11 Linear |R| = 1.740613e+01\n     12 Linear |R| = 1.739940e+01\n     13 Linear |R| = 1.737862e+01\n     14 Linear |R| = 1.737736e+01\n     15 Linear |R| = 1.737491e+01\n     16 Linear |R| = 1.737372e+01\n     17 Linear |R| = 1.710702e+01\n     18 Linear |R| = 1.707838e+01\n     19 Linear |R| = 1.705797e+01\n     20 Linear |R| = 1.703600e+01\n  Linear solve did not converge due to DIVERGED_ITS iterations 20\n 6 Nonlinear |R| = 1.712855e+01\n      0 Linear |R| = 1.712855e+01\n      1 Linear |R| = 1.712854e+01\n      2 Linear |R| = 1.711985e+01\n      3 Linear |R| = 1.711689e+01\n      4 Linear |R| = 1.710944e+01\n      5 Linear |R| = 1.710769e+01\n      6 Linear |R| = 1.710147e+01\n      7 Linear |R| = 1.708301e+01\n      8 Linear |R| = 1.706861e+01\n      9 Linear |R| = 1.702431e+01\n     10 Linear |R| = 1.702281e+01\n     11 Linear |R| = 1.700613e+01\n     12 Linear |R| = 1.700593e+01\n     13 Linear |R| = 1.699160e+01\n     14 Linear |R| = 1.698790e+01\n     15 Linear |R| = 1.698787e+01\n     16 Linear |R| = 1.690293e+01\n     17 Linear |R| = 1.682969e+01\n     18 Linear |R| = 1.682179e+01\n     19 Linear |R| = 1.673479e+01\n     20 Linear |R| = 1.673478e+01\n\n\nI don't understand. So first you try solving the lateral momentum equations independently of the others, which works? But then you add terms to your other equations involving w, and you have trouble converging? If that's the case, I'm not sure. Are these terms correct? Do you have their Jacobians accounted for? Maybe you could try using PC type of FDP rather than SMP (if your problem isn't too large) to see if the nonlinear solve is better in that case, which would imply that you need to fix some Jacobians. However, I've found that sometimes FDP doesn't do well anyway, despite being approximately correct.\n\nI'm worrying about the Jacobian. We use AD in all the kernels, so we don't need to write the Jacobian ourselves right? But I use analyzejacobian on my two-channels model and I find out that:\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' is wrong (off by 29.3 %)\n\nKernel for variable 'w':\n  (3,0) Off-diagonal Jacobian for variable 'rhoA' is questionable (off by 10.56 %)\n  (3,1) Off-diagonal Jacobian for variable 'rhoEA' is questionable (off by 10.56 %)\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' is wrong (off by 123.6 %)\n\nKernel for variable 'rhouA':\n  (2,3) Off-diagonal Jacobian for variable 'w' is wrong (off by 29179.4 %)\n\nKernel for variable 'w':\n  (3,0) Off-diagonal Jacobian for variable 'rhoA' is questionable (off by 10.56 %)\n  (3,1) Off-diagonal Jacobian for variable 'rhoEA' is questionable (off by 10.56 %)\n  (3,2) Off-diagonal Jacobian for variable 'rhouA' is questionable (off by 10.56 %)\n\nKernel for variable 'rhoA':\n  (0,0) On-diagonal Jacobian is wrong (off by 37.6 %)\n  (0,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (0,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoEA':\n  (1,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (1,1) On-diagonal Jacobian is wrong (off by 28.8 %)\n  (1,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n\nKernel for variable 'rhouA':\n  (2,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (2,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (2,2) On-diagonal Jacobian is wrong (off by 23.5 %)\n  (2,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'w':\n  (3,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (3,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (3,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n  (3,3) On-diagonal Jacobian is wrong (off by 27.4 %)\n\nKernel for variable 'rhoA':\n  (0,0) On-diagonal Jacobian is wrong (off by 463.7 %)\n  (0,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (0,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoEA':\n  (1,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (1,1) On-diagonal Jacobian is wrong (off by 481.9 %)\n  (1,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n\nKernel for variable 'rhouA':\n  (2,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (2,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (2,2) On-diagonal Jacobian is wrong (off by 484.3 %)\n  (2,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'w':\n  (3,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (3,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (3,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n  (3,3) On-diagonal Jacobian is slightly off (by 0.084206 %)\n\nKernel for variable 'rhoA':\n  (0,0) On-diagonal Jacobian is wrong (off by 80.0 %)\n  (0,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (0,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoEA':\n  (1,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (1,1) On-diagonal Jacobian is wrong (off by 99.7 %)\n  (1,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n\nKernel for variable 'rhouA':\n  (2,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (2,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (2,2) On-diagonal Jacobian is wrong (off by 99.0 %)\n  (2,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'w':\n  (3,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (3,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (3,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n  (3,3) On-diagonal Jacobian is inexact (off by 1.183 %)\n\nKernel for variable 'rhoA':\n  (0,0) On-diagonal Jacobian is wrong (off by 5056.2 %)\n  (0,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (0,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoEA':\n  (1,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (1,1) On-diagonal Jacobian is wrong (off by 414.8 %)\n  (1,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n\nKernel for variable 'rhouA':\n  (2,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (2,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (2,2) On-diagonal Jacobian is wrong (off by 804.4 %)\n  (2,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'w':\n  (3,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (3,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (3,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,0) On-diagonal Jacobian is wrong (off by 1512.5 %)\n  (0,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (0,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoEA':\n  (1,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (1,1) On-diagonal Jacobian is wrong (off by 1197.2 %)\n  (1,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n\nKernel for variable 'rhouA':\n  (2,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (2,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (2,2) On-diagonal Jacobian is wrong (off by 1184.5 %)\n  (2,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'w':\n  (3,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (3,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (3,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n  (3,3) On-diagonal Jacobian is slightly off (by 0.000016 %)\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoEA':\n  (1,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n\nKernel for variable 'rhouA':\n  (2,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (2,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'w':\n  (3,0) Off-diagonal Jacobian for variable 'rhoA' should just return  zero\n  (3,1) Off-diagonal Jacobian for variable 'rhoEA' should just return  zero\n  (3,2) Off-diagonal Jacobian for variable 'rhouA' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nKernel for variable 'rhoA':\n  (0,3) Off-diagonal Jacobian for variable 'w' should just return  zero\n\nIt seems that the Jacobian has big problem.\nI've tried FDP and it doesn't make a difference.\nI can't make sure if my kernel which couple w is wrong Orz.",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5511201",
                          "updatedAt": "2023-04-03T15:03:53Z",
                          "publishedAt": "2023-04-03T15:03:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "A lot to unpack here:\n\nusing AD only means the Jacobian will be correct if sufficient care is taken to not loose the derivatives through implicit conversion etc\n\nSo we should review that code to make sure that does not happen\n\nif it does not converge with FDP then I would begin to suspect that the problem is not well posed. You can use svd for the preconditioner as well as passing pc_svd_monitor to the petsc options to see about that.\nThis will only work on small problems (10k dofs MAX)\n\nthis will be very slow, keep the number of dofs below 10k.\nSo yeah two things potentially to fix.",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5511478",
                          "updatedAt": "2023-04-03T16:05:17Z",
                          "publishedAt": "2023-04-03T15:30:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "@GiudGiud @joshuahansel Thank you Giud.\nI create a UO which can transfer the elemental variable's value of a block to another block.\nFor a specific example(lateral pressure gradient term), A/l*(Pi - Pj) , Pi is the pressure of current block and Pj is the pressure of adjacent block. There should be dPi/drhoA - dPj/drhoA (as well as rhouA and rhoEA) in the Jacobian. I think AD can help me to calculate the dPi/drhoA, and I want to know if AD can help me to calculate the dPj/drhoA?\nIf can't, I think maybe I need to write the Jacobian myself.\nEthan",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5520586",
                          "updatedAt": "2023-04-04T12:34:48Z",
                          "publishedAt": "2023-04-04T12:34:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Yes, AD should be able to give you all of the Jacobians. As @GiudGiud pointed out, you just need to make sure you didn't accidentally drop the AD stuff - can you share your kernel?",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5533401",
                          "updatedAt": "2023-04-05T14:48:11Z",
                          "publishedAt": "2023-04-05T14:48:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "@joshuahansel Oh, even if I only use the method like _rho = _rho_var->getElementalValue(_current_elem) to transfer the variable value, just like in the ADRDG3EqnMaterial.C, the variable value will be treated as a AD variable when being called(I didn't use Moose::derivInsert to any aux variable like rho p T etc, but I use Moose::derivInsert to w, solution variable to the lateral momentum equation)?\nI was going to change the way I transfer the aux variable value into transferring the solution variable and recompute the aux variable in my kernel. So I don't have to do any of this?\nHere is some kernels in my component:\nLateral momentum kernel:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"FLARE_LateralMomentum.h\"\n#include \"FLARE_LateralKernelUO.h\"\n\nregisterMooseObject(\"ThermalHydraulicsApp\", FLARE_LateralMomentum);\n\nInputParameters\nFLARE_LateralMomentum::validParams()\n{\n  InputParameters params = ADKernel::validParams();\n  params.addParam<Real>(\"lk\", 0.023 ,\"Length of the turbulence\");\n  params.addParam<Real>(\"sk\", 0.011 ,\"Width of the gap\");\n  params.addParam<Real>(\"kg\", 0.5 ,\"Drag coefficient of the cross flow\");\n  params.addRequiredParam<MaterialPropertyName>(\"rho\", \"Density property\");\n  params.addRequiredParam<MaterialPropertyName>(\"p\", \"Pressure property\");\n  params.addRequiredParam<UserObjectName>(\n      \"q_uo\", \"The name of the user object that transfers the variables\");\n//  params.addRequiredParam<UserObjectName>(\"fp\", \"The name of the user object for fluid properties\");\n  params.addClassDescription(\"Computes the lateral velocity between 2 channels.\");\n  return params;\n}\n\nFLARE_LateralMomentum::FLARE_LateralMomentum(const InputParameters & parameters)\n  : ADKernel(parameters),\n    _rho(getADMaterialProperty<Real>(\"rho\")),\n    _p(getADMaterialProperty<Real>(\"p\")),\n    _lk(getParam<Real>(\"lk\")),\n    _sk(getParam<Real>(\"sk\")),\n    _kg(getParam<Real>(\"kg\")),\n    _q_uo(getUserObject<FLARE_LateralKernelUO>(\"q_uo\"))\n\n{\n}\n\nADReal\nFLARE_LateralMomentum::computeQpResidual()\n{\n  ADReal adj_rho = _q_uo.getAdjacentRHO(_current_elem->id());\n  ADReal adj_p = _q_uo.getAdjacentP(_current_elem->id());\n  return  -_test[_i][_qp]*_sk/_lk*(_p[_qp]-adj_p)+\n          _test[_i][_qp]*_kg*std::abs(_u[_qp])*_u[_qp]/(_sk*_lk*(_rho[_qp]+adj_rho));\n}\n\nLateral term in mass equation(include 2 kernels, because between 2 channels, only one lateral mass flux is calculated):\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"FLARE_MassLateralTerm_S.h\"\n\nregisterMooseObject(\"ThermalHydraulicsApp\", FLARE_MassLateralTerm_S);\n\nInputParameters\nFLARE_MassLateralTerm_S::validParams()\n{\n  InputParameters params = ADKernel::validParams();\n  params.addRequiredCoupledVar(\"w\", \"lateral velocity\");\n  params.addClassDescription(\"Computes lateral term of the mass equation.\");\n  return params;\n}\n\nFLARE_MassLateralTerm_S::FLARE_MassLateralTerm_S(const InputParameters & parameters)\n  : ADKernel(parameters),\n    _w(adCoupledValue(\"w\"))\n{\n}\n\nADReal\nFLARE_MassLateralTerm_S::computeQpResidual()\n{\n    return  _test[_i][_qp]*_w[_qp];\n}\n\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"FLARE_MassLateralTerm_L.h\"\n#include \"FLARE_LateralTermUO.h\"\n\nregisterMooseObject(\"ThermalHydraulicsApp\", FLARE_MassLateralTerm_L);\n\nInputParameters\nFLARE_MassLateralTerm_L::validParams()\n{\n  InputParameters params = ADKernel::validParams();\n  params.addRequiredParam<UserObjectName>(\n      \"q_uo\", \"The name of the user object that transfers the variables\");\n  params.addClassDescription(\"Computes lateral term of the mass equation.\");\n  return params;\n}\n\nFLARE_MassLateralTerm_L::FLARE_MassLateralTerm_L(const InputParameters & parameters)\n  : ADKernel(parameters),\n    _q_uo(getUserObject<FLARE_LateralTermUO>(\"q_uo\"))\n{\n}\n\nADReal\nFLARE_MassLateralTerm_L::computeQpResidual()\n{\n  ADReal adj_w = _q_uo.getAdjacentW(_current_elem->id());\n  return  -_test[_i][_qp]*adj_w;\n}\n\nLateral term in axial momentum equation:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"FLARE_MomentumLateralTerm_S.h\"\n#include \"FLARE_LateralTermUO_L2S.h\"\n\nregisterMooseObject(\"ThermalHydraulicsApp\", FLARE_MomentumLateralTerm_S);\n\nInputParameters\nFLARE_MomentumLateralTerm_S::validParams()\n{\n  InputParameters params = ADKernel::validParams();\n  params.addRequiredCoupledVar(\"w\", \"lateral velocity\");\n  params.addRequiredParam<MaterialPropertyName>(\"vel\", \"Velocity property\");\n  params.addRequiredParam<UserObjectName>(\n      \"q_uo\", \"The name of the user object that transfers the variables\");\n  params.addClassDescription(\"Computes lateral term of the momentum equation.\");\n  return params;\n}\n\nFLARE_MomentumLateralTerm_S::FLARE_MomentumLateralTerm_S(const InputParameters & parameters)\n  : ADKernel(parameters),\n    _w(adCoupledValue(\"w\")),\n    _vel(getADMaterialProperty<Real>(\"vel\")),\n    _q_uo(getUserObject<FLARE_LateralTermUO_L2S>(\"q_uo\"))\n{\n}\n\nADReal\nFLARE_MomentumLateralTerm_S::computeQpResidual()\n{\n  ADReal adj_vel = _q_uo.getAdjacentVEL(_current_elem->id());\n  if(_w[_qp] > 0)\n  {\n    return  _test[_i][_qp]*_w[_qp]*_vel[_qp];\n  }\n  else\n  {\n    return  _test[_i][_qp]*_w[_qp]*adj_vel;\n  }\n}\n\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"FLARE_MomentumLateralTerm_L.h\"\n#include \"FLARE_LateralTermUO.h\"\n\nregisterMooseObject(\"ThermalHydraulicsApp\", FLARE_MomentumLateralTerm_L);\n\nInputParameters\nFLARE_MomentumLateralTerm_L::validParams()\n{\n  InputParameters params = ADKernel::validParams();\n  params.addRequiredParam<MaterialPropertyName>(\"vel\", \"Velocity property\");\n  params.addRequiredParam<UserObjectName>(\n      \"q_uo\", \"The name of the user object that transfers the variables\");\n  params.addClassDescription(\"Computes lateral term of the momentum equation.\");\n  return params;\n}\n\nFLARE_MomentumLateralTerm_L::FLARE_MomentumLateralTerm_L(const InputParameters & parameters)\n  : ADKernel(parameters),\n    _vel(getADMaterialProperty<Real>(\"vel\")),\n    _q_uo(getUserObject<FLARE_LateralTermUO>(\"q_uo\"))\n{\n}\n\nADReal\nFLARE_MomentumLateralTerm_L::computeQpResidual()\n{\n  ADReal adj_vel = _q_uo.getAdjacentVEL(_current_elem->id());\n  ADReal adj_w = _q_uo.getAdjacentW(_current_elem->id());\n  //  if(_p[_qp] > adj_p)\n    if(adj_w > 0)\n  {\n    return  -_test[_i][_qp]*adj_w*adj_vel;\n  }\n  else\n  {\n    return  -_test[_i][_qp]*adj_w*_vel[_qp];\n  }\n}\n\nSome other kernels is in the same form, so I'm not going to list them here. In my component I define the mapping of every 2 channels and add these kernels to every channel.\nEthan",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5538615",
                          "updatedAt": "2023-04-06T01:56:37Z",
                          "publishedAt": "2023-04-06T01:56:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Can you show FLARE_LateralKernelUO?",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5543254",
                          "updatedAt": "2023-04-06T12:34:21Z",
                          "publishedAt": "2023-04-06T12:34:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "@joshuahansel Here it is\uff1a\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"FLARE_LateralKernelUO.h\"\n#include \"MooseMesh.h\"\n#include \"KDTree.h\"\n#include \"Assembly.h\"\n\nregisterMooseObject(\"ThermalHydraulicsApp\", FLARE_LateralKernelUO);\n\nInputParameters\nFLARE_LateralKernelUO::validParams()\n{\n  InputParameters params = ElementUserObject::validParams();\n  params.addRequiredParam<ChannelMapping *>(\"_channel_mapping\",\n                                                  \"Flow channel alignement object\");\n  params.addRequiredCoupledVar(\"rho\", \"Density in current flow channel\");\n  params.addRequiredCoupledVar(\"p\", \"Pressure in current flow channel\");\n  params.addClassDescription(\n      \"Base class for caching variables between 2 flow channels.\");\n  return params;\n}\n\nFLARE_LateralKernelUO::FLARE_LateralKernelUO(\n    const InputParameters & parameters)\n  : ElementUserObject(parameters),\n    _channel_mapping(*getParam<ChannelMapping *>(\"_channel_mapping\")),\n    _rho_var(getVar(\"rho\", 0)),\n    _p_var(getVar(\"p\", 0))\n\n{\n}\n\nvoid\nFLARE_LateralKernelUO::initialize()\n{\n}\n\nvoid\nFLARE_LateralKernelUO::execute()\n{\n    dof_id_type nearest_elem_id = _channel_mapping.getNearestElemID(_current_elem->id());\n    // get elemental variable value in current element\n    ADReal _rho,_p;\n    _rho = _rho_var->getElementalValue(_current_elem);\n    _p = _p_var->getElementalValue(_current_elem);\n\n    // \"seed\" the derivative\n//    Moose::derivInsert(_vel.derivatives(), dof_indices[0], 1.0);\n//    Moose::derivInsert(_rho.derivatives(), dof_indices[0], 1.0);\n//    Moose::derivInsert(_p.derivatives(), dof_indices[0], 1.0);\n    _adj_rho[nearest_elem_id] = _rho;\n    _adj_p[nearest_elem_id] = _p;\n}\n\nvoid\nFLARE_LateralKernelUO::finalize()\n{\n}\n\nvoid\nFLARE_LateralKernelUO::threadJoin(const UserObject & y)\n{\n  const FLARE_LateralKernelUO & uo =\n      static_cast<const FLARE_LateralKernelUO &>(y);\n    for (auto & it : uo._adj_rho)\n      _adj_rho[it.first] = it.second;\n    for (auto & it : uo._adj_p)\n      _adj_p[it.first] = it.second;\n}\n\nconst ADReal &\nFLARE_LateralKernelUO::getAdjacentRHO(dof_id_type element_id) const\n{\n  Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n  auto it = _adj_rho.find(element_id);\n  if (it != _adj_rho.end())\n    return it->second;\n  else\n    mooseError(name(), \": Requested Density for element \", element_id, \" was not computed.\");\n}\n\nconst ADReal &\nFLARE_LateralKernelUO::getAdjacentP(dof_id_type element_id) const\n{\n  Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n  auto it = _adj_p.find(element_id);\n  if (it != _adj_p.end())\n    return it->second;\n  else\n    mooseError(name(), \": Requested Pressure for element \", element_id, \" was not computed.\");\n}",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5543286",
                          "updatedAt": "2023-04-06T12:39:40Z",
                          "publishedAt": "2023-04-06T12:39:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "@joshuahansel Hi josh, I still haven't solved why the calculations don't converge. Is there anywhere wrong in the UO?",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5570657",
                          "updatedAt": "2023-04-10T13:19:40Z",
                          "publishedAt": "2023-04-10T13:19:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Sorry, I didn't see that you responded.\nIt's clear from this UO that you don't have the derivatives. What happened to the plan we discussed? We need to get the solution variables from the adjacent channels, \"seed\" the derivatives, and then locally compute the aux quantities rho and p. Try that, and show the UO, and I can tell you if it looks right.",
                          "url": "https://github.com/idaholab/moose/discussions/23872#discussioncomment-5571494",
                          "updatedAt": "2023-04-10T15:10:17Z",
                          "publishedAt": "2023-04-10T15:10:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "DG and cohesive zone modelling",
          "author": {
            "login": "AbbBallout"
          },
          "bodyText": "I am looking for a FEM library that allows me to do cohesive zone modelling.\nI found the paper \"An IIPG-Based Finite Element Framework in MOOSE for Modeling Fiber Reinforced Composite Failure Governed by Extrinsic Cohesive Laws\" which makes MOOSE look promising.\nI can't find tutorials in MOOSE for CZM. Are there any examples somewhere else",
          "url": "https://github.com/idaholab/moose/discussions/24047",
          "updatedAt": "2023-04-13T14:47:17Z",
          "publishedAt": "2023-04-12T19:01:49Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "There are CZM tests in the tensor_mechanics module, see for example\nlindad@pop-os:~/projects/moose/modules/tensor_mechanics/test/tests(nodal-bc-flex-23940)$ git grep -I --name-only Cohesive\ncohesive_zone_model/bilinear_mixed.i\ncohesive_zone_model/bilinear_mixed_scale_strength.i\ncohesive_zone_model/czm_multiple_action_and_materials.i\ncohesive_zone_model/czm_multiple_dimension_base.i\ncohesive_zone_model/czm_patch_test_base.i\ncohesive_zone_model/czm_traction_separation_base.i\ncohesive_zone_model/stretch_rotate_large_deformation.i",
                  "url": "https://github.com/idaholab/moose/discussions/24047#discussioncomment-5596548",
                  "updatedAt": "2023-04-12T19:23:37Z",
                  "publishedAt": "2023-04-12T19:23:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "AbbBallout"
                  },
                  "bodyText": "One more thing.\nAre cohesive elements created automatically or should I include those by myself?",
                  "url": "https://github.com/idaholab/moose/discussions/24047#discussioncomment-5602480",
                  "updatedAt": "2023-04-13T10:03:38Z",
                  "publishedAt": "2023-04-13T10:03:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "They are created by one of the mesh generator. Please follow the examples @lindsayad provided above.",
                          "url": "https://github.com/idaholab/moose/discussions/24047#discussioncomment-5604303",
                          "updatedAt": "2023-04-13T13:09:11Z",
                          "publishedAt": "2023-04-13T13:09:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Why can't some modules change the time discrete parameters\uff1f",
          "author": {
            "login": "Moyiqi"
          },
          "bodyText": "Hello everyone. May I ask a question?\nWhat is the default time discretization in Modules/TensorMechanics/Master\uff0cis Newmark or not?\nIf so, where could I change the parameter \u03b1\uff1f\nLily",
          "url": "https://github.com/idaholab/moose/discussions/24058",
          "updatedAt": "2023-04-14T07:37:42Z",
          "publishedAt": "2023-04-13T01:25:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nit should show at the beginning of the log, under the mesh information\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24058#discussioncomment-5599265",
                  "updatedAt": "2023-04-13T02:51:41Z",
                  "publishedAt": "2023-04-13T02:51:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Moyiqi"
                          },
                          "bodyText": "[Modules/TensorMechanics/Master]\n\u00a0 \u00a0 [all]\n\u00a0 \u00a0 \u00a0 # strain = FINITE\n\u00a0 \u00a0 \u00a0 add_variables = true\n\u00a0 \u00a0 \u00a0 generate_output = 'stress_zz strain_zz'\n\u00a0 \u00a0 \u00a0 block = '1 2'\n\u00a0 \u00a0 \u00a0 use_automatic_differentiation = true\n\u00a0 \u00a0 []\n\u00a0 []\n\u00a0 \n\u00a0 [Materials]\n\u00a0 \u00a0 [elasticity]\n\u00a0 \u00a0 \u00a0 type = ADComputeVariableIsotropicElasticityTensor\n\u00a0 \u00a0 \u00a0 poissons_ratio = 0.3\n\u00a0 \u00a0 \u00a0 youngs_modulus = 1e3\n\u00a0 \u00a0 \u00a0 block = '1 2'\n\u00a0 \u00a0 []\n\u00a0 \u00a0 [stress]\n\u00a0 \u00a0 \u00a0 type = ADComputeLinearElasticStress\n\u00a0 \u00a0 \u00a0 block = '1 2'\n\u00a0 \u00a0 []\n\u00a0 []\n\u00a0 \n\u00a0\n\u00a0 [UserObjects]\n\u00a0 \u00a0 [activated_elem_uo]\n\u00a0 \u00a0 \u00a0 type = ActivateElementsCoupled\n\u00a0 \u00a0 \u00a0 execute_on = timestep_begin\n\u00a0 \u00a0 \u00a0 coupled_var = strain_zz\n\u00a0 \u00a0 \u00a0 activate_value = 0.05\n\u00a0 \u00a0 \u00a0 active_subdomain_id = 1\n\u00a0 \u00a0 \u00a0 expand_boundary_name = 'moving_interface'\n\u00a0 \u00a0 []\n\u00a0 []\n\u00a0 \n\u00a0 [Outputs]\n\u00a0 \u00a0 exodus = true\n\u00a0 []\n\u00a0 [Postprocessors]\n\u00a0 \u00a0 [single_nodal_x]\n\u00a0 \u00a0 \u00a0 type = PointValue\n\u00a0 \u00a0 \u00a0 point = ' 1 1 1'\n\u00a0 \u00a0 \u00a0 variable = \"disp_x\"\n\u00a0 \u00a0 []\n\u00a0 []\n\nWhen I run this model, which only involves tensor mechanics, modifying scheme parameters has no effect on the results. Whether the equations of tensor mechanics have a default time-discretization scheme, such as using HHT.\nLily",
                          "url": "https://github.com/idaholab/moose/discussions/24058#discussioncomment-5599297",
                          "updatedAt": "2023-04-13T03:38:43Z",
                          "publishedAt": "2023-04-13T03:00:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "How are you changing the time scheme? Could you please paste your executioner block",
                          "url": "https://github.com/idaholab/moose/discussions/24058#discussioncomment-5603616",
                          "updatedAt": "2023-04-13T12:07:23Z",
                          "publishedAt": "2023-04-13T12:07:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Moyiqi"
                          },
                          "bodyText": "[Executioner]\ntype = Transient\nautomatic_scaling = true\n\nsolve_type = 'PJFNK'\n\nline_search = 'none'\nscheme=bdf2\n\nl_max_its = 100\nnl_max_its = 20\nnl_rel_tol = 1e-4\n\nstart_time = 0.0\nend_time = 1.0\ndt = 1e-1\ndtmin = 1e-4\n\n[]\nLily",
                          "url": "https://github.com/idaholab/moose/discussions/24058#discussioncomment-5603969",
                          "updatedAt": "2023-04-13T12:39:30Z",
                          "publishedAt": "2023-04-13T12:39:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "https://mooseframework.inl.gov/source/timeintegrators/NewmarkBeta.html",
                          "url": "https://github.com/idaholab/moose/discussions/24058#discussioncomment-5604290",
                          "updatedAt": "2023-04-13T13:07:46Z",
                          "publishedAt": "2023-04-13T13:07:45Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Parameter study]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Hi,\nI would like to know if there is any function for parameter study.\nFor example, in the same input file, I only want to adjust a single parameter value and get the calculation results.\ninput.i -> parameter = 1 => results_out_1.out\n-> parameter = 2 => results_out_2.out\n-> parameter = 3 => results_out_3.out\n...\n-> parameter = 100 => results_out_100.out\nIs there any function like this?",
          "url": "https://github.com/idaholab/moose/discussions/24037",
          "updatedAt": "2023-04-13T00:06:52Z",
          "publishedAt": "2023-04-12T11:21:03Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere is, it s part of the Stochastic Tools module\nhttps://mooseframework.inl.gov/docs/site/syntax/ParameterStudy/index.html\nhttps://mooseframework.inl.gov/docs/site/source/actions/ParameterStudyAction.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24037#discussioncomment-5592643",
                  "updatedAt": "2023-04-12T13:20:53Z",
                  "publishedAt": "2023-04-12T13:20:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "coskrrb2002"
                          },
                          "bodyText": "Oh, thanks for helping.\nI will take a look!",
                          "url": "https://github.com/idaholab/moose/discussions/24037#discussioncomment-5598345",
                          "updatedAt": "2023-04-13T00:06:52Z",
                          "publishedAt": "2023-04-13T00:06:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "OptimizationReporter",
          "author": {
            "login": "am-tc01"
          },
          "bodyText": "In one of the optimization tests, why is there one value in lower_bounds and upper_bounds, while num_values = 2. What if I want different lower and upper bounds for each value in diffusivty_values?\n[OptimizationReporter]\n  type = OptimizationReporter\n  parameter_names = diffusivity_values\n  num_values = 2 # diffusivity in the bottom material and in the top material of model.i\n  initial_condition = '3 4' # the expected result is about '1 10' so this initial condition is not too bad\n  lower_bounds = '1'\n  upper_bounds = '20'\n  measurement_file = 'synthetic_data.csv'\n  file_value = 'temperature'\n[]\n\nRegards.",
          "url": "https://github.com/idaholab/moose/discussions/23772",
          "updatedAt": "2023-04-12T21:17:48Z",
          "publishedAt": "2023-03-17T12:58:26Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis would be an optimization that has not been added to the code.\nFeel free to add it, we would just need to have a \"vector of vector\" syntax for the parameter, then get the indexing right\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23772#discussioncomment-5347671",
                  "updatedAt": "2023-03-17T16:19:32Z",
                  "publishedAt": "2023-03-17T16:19:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@zachmprince for awareness",
                          "url": "https://github.com/idaholab/moose/discussions/23772#discussioncomment-5347673",
                          "updatedAt": "2023-03-17T16:19:43Z",
                          "publishedAt": "2023-03-17T16:19:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "am-tc01"
                          },
                          "bodyText": "Thank you for your answer.\nIn an earlier version, one could just specify the name of the vector in parameter_names and the size of the vector in num_values, and then specify lower_bounds and upper_bounds for the same vector length as num_values. But now, I think, this is changed, and it gets somehow a little confusing. The following worked in an earlier version, but now it gives an error: There must be a lower bound associated with each parameter.\n[OptimizationReporter]\n  type = OptimizationReporter\n  parameter_names = diffusivity_values\n  num_values = 2 # diffusivity in the bottom material and in the top material of model.i\n  initial_condition = '3 4' # the expected result is about '1 10' so this initial condition is not too bad\n  lower_bounds = '1 2'\n  upper_bounds = '10 20'\n  measurement_file = 'synthetic_data.csv'\n  file_value = 'temperature'\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/23772#discussioncomment-5353388",
                          "updatedAt": "2023-03-18T13:33:31Z",
                          "publishedAt": "2023-03-18T13:33:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "@am-tc01   I removed the ability to have different lower and upper bounds for each parameter.  I wanted to make the optimizationReporter consistent with the mesh based method for defining parameters, ParameterMeshOptimization.  Do you have a good reason for needing different lower and upper bounds for the same material property?  Maybe it is something I can try to add back in.",
                          "url": "https://github.com/idaholab/moose/discussions/23772#discussioncomment-5398483",
                          "updatedAt": "2023-03-22T21:48:07Z",
                          "publishedAt": "2023-03-22T21:48:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "am-tc01"
                          },
                          "bodyText": "@lynnmunday thanks for your answer.\nOne could have different properties or different parameters to optimize for. For instance, in my case I have 5 different parameters to optimize for and then I need to have them in the same OptimizationReporter. It's not logical to have same upper and lower bounds on all those. Not sure how one can have a vector of vectors, have different upper and lower bounds on each and then transfer them to a sub-app?",
                          "url": "https://github.com/idaholab/moose/discussions/23772#discussioncomment-5406304",
                          "updatedAt": "2023-03-23T13:42:02Z",
                          "publishedAt": "2023-03-23T13:42:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zachmprince"
                          },
                          "bodyText": "@am-tc01 Just so you know, you can have multiple parameter groups. So you can change your input to have:\n[OptimizationReporter]\n  type = OptimizationReporter\n  parameter_names = 'diffusivity_bottom diffusivity_top'\n  num_values = '1 1' # diffusivity in the bottom material and in the top material of model.i\n  initial_condition = '3 4' # the expected result is about '1 10' so this initial condition is not too bad\n  lower_bounds = '1 2'\n  upper_bounds = '10 20'\n  measurement_file = 'synthetic_data.csv'\n  file_value = 'temperature'\n[]\n\nThere is an example of doing this here.\nIt seems like this might be cumbersome for your problem though. We can consider adding the capability to have both options: one for single bound for all values, and one for a bound for each value.",
                          "url": "https://github.com/idaholab/moose/discussions/23772#discussioncomment-5411256",
                          "updatedAt": "2023-03-23T20:56:45Z",
                          "publishedAt": "2023-03-23T20:56:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "am-tc01"
                          },
                          "bodyText": "@zachmprince Yes that is correct. In principle this can be done but then if one has many parameters, it could get very cumbersome to deal with all the parameters separately in the sub-app. I would really appreciate if you could add this capability again, to have a bound for each value.\nRegards.",
                          "url": "https://github.com/idaholab/moose/discussions/23772#discussioncomment-5426926",
                          "updatedAt": "2023-03-25T14:20:04Z",
                          "publishedAt": "2023-03-25T14:20:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "@am-tc01 I added this pull request #23868 to change this and make all of these parameters a vector of vectors.  The input syntax changed a bit to do this, you now need to use a \";\"  to separate each vector of parameters.  You can see this in some changes to input files in that pr.",
                          "url": "https://github.com/idaholab/moose/discussions/23772#discussioncomment-5446709",
                          "updatedAt": "2023-03-28T00:05:39Z",
                          "publishedAt": "2023-03-28T00:05:39Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "am-tc01"
                          },
                          "bodyText": "@lynnmunday Super! many thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/23772#discussioncomment-5455727",
                          "updatedAt": "2023-03-28T15:31:48Z",
                          "publishedAt": "2023-03-28T15:31:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "@am-tc01 could you tell me anything about the problems your are trying to solve with the optimization module?  I'm just curious how its being used.",
                          "url": "https://github.com/idaholab/moose/discussions/23772#discussioncomment-5456296",
                          "updatedAt": "2023-03-28T16:19:30Z",
                          "publishedAt": "2023-03-28T16:19:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "am-tc01"
                          },
                          "bodyText": "@lynnmunday I am trying to optimize processing parameters for certain manufacturing processes.\nI wonder if you or others, if you know, have used optimization module for some rigorous optimization problems? If yes, then how, in general is your experience with Petsc TAO solvers?",
                          "url": "https://github.com/idaholab/moose/discussions/23772#discussioncomment-5514388",
                          "updatedAt": "2023-04-03T20:50:30Z",
                          "publishedAt": "2023-04-03T20:50:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "TestHarness does not require python3",
          "author": {
            "login": "hzclarksm"
          },
          "bodyText": "PythonUnitTest.getCommand() does explicitly use python3.  In my environment \"python\" is by default python2.   This cases several tests to fail which missing libraries and and/or syntax errors.  Here is a simple fix.\ndiff --git a/python/TestHarness/testers/PythonUnitTest.py b/python/TestHarness/testers/PythonUnitTest.py\nindex 1afb363c31..1a77cd6e92 100644\n--- a/python/TestHarness/testers/PythonUnitTest.py\n+++ b/python/TestHarness/testers/PythonUnitTest.py\n@@ -44,6 +44,6 @@ class PythonUnitTest(RunApp):\n         if self.specs[\"separate\"]:\n             cmd = os.path.join(self.specs['moose_dir'], 'scripts', 'separate_unittests.py') + ' -f ' + test_case + use_buffer\n         else:\n-            cmd = \"python -m unittest\" + use_buffer + \"-v \" + test_case\n+            cmd = \"python3 -m unittest\" + use_buffer + \"-v \" + test_case\n \n         return cmd  + ' '.join(self.specs['cli_args'])",
          "url": "https://github.com/idaholab/moose/discussions/24048",
          "updatedAt": "2023-04-29T02:51:05Z",
          "publishedAt": "2023-04-12T19:30:42Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@milljm can we do that?\nIs python3 (in addition to python) provided on every platform we care about?",
                  "url": "https://github.com/idaholab/moose/discussions/24048#discussioncomment-5596647",
                  "updatedAt": "2023-04-12T19:34:04Z",
                  "publishedAt": "2023-04-12T19:34:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Bringing in @dschwen, because his voice on this is like mine :)\nI say we change all our Python shebangs to #!/usr/bin/env python3 If not already. I thought I had sneaked this in already at some point.",
                          "url": "https://github.com/idaholab/moose/discussions/24048#discussioncomment-5596698",
                          "updatedAt": "2023-04-12T19:41:50Z",
                          "publishedAt": "2023-04-12T19:41:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "but yes, I agree with the change. When calling python we should call python3",
                          "url": "https://github.com/idaholab/moose/discussions/24048#discussioncomment-5596701",
                          "updatedAt": "2023-04-12T19:42:20Z",
                          "publishedAt": "2023-04-12T19:42:18Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hzclarksm"
                          },
                          "bodyText": "The change to Python shebangs does seem to already be in place.  That of course has no effect when running python commands as built in PythonUnitTest.py.",
                          "url": "https://github.com/idaholab/moose/discussions/24048#discussioncomment-5596762",
                          "updatedAt": "2023-04-12T19:52:02Z",
                          "publishedAt": "2023-04-12T19:52:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "libmesh build fails - PETSc with Hypre was not found",
          "author": {
            "login": "heinono1"
          },
          "bodyText": "I just pulled a new Moose distribution, build PETSc (using the update_and_rebuild_petsc.sh script) ad checked that the build did download Hypre and built it. But when I try to build libmesh (using the update_and_rebuild_libmesh.sh script) I get an errer: \"PETSc with Hypre was not found, but --enable-petsc-hypre-required was specified\". I had updated the conda environment before starting to build. I am a bit mystified by this as I checked that Hypre was indeed built. What is more perplexing is that I pulled Moose yesterday (on another machine) and did exactly the same thing (build PETSc, libmesh, and Moose) without any errors.",
          "url": "https://github.com/idaholab/moose/discussions/24045",
          "updatedAt": "2023-04-12T18:18:34Z",
          "publishedAt": "2023-04-12T17:22:49Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Looks like the problem was trivial - I just had to unset environment variables (MOOSE_DIR, PETSC_DIR, LIBMESH_DIR) that I had set earlier to something else.",
                  "url": "https://github.com/idaholab/moose/discussions/24045#discussioncomment-5596012",
                  "updatedAt": "2023-04-12T18:18:28Z",
                  "publishedAt": "2023-04-12T18:18:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "NodalStickConstraint with Shell Elements",
          "author": {
            "login": "Zoophish"
          },
          "bodyText": "Hello,\nI was trying to experiment and see if I could 'glue' two shell element surfaces together using the NodalStickConstraint. I'm getting some bizarre results when running a shell element scenario with the constraints. I noticed there are only example for beam elements, so I was hoping someone could tell me if it's possible to use NodalStickConstraint with shell elements.\n\n  Input File\nep = 1e-4\nspacing = 0.001\n\n[Mesh]\n  [Beams]\n    type = FileMeshGenerator\n    file = 'L_beams.msh'\n  []\n  [Contact1]\n    type = BoundingBoxNodeSetGenerator\n    input = Beams\n    bottom_left = '${fparse 1.0-ep} ${fparse -0.2-ep} ${fparse 0.0-ep}'\n    top_right = '${fparse 1+ep} ${fparse 0+ep} ${fparse 0.4+ep}'\n    new_boundary = contact1\n  []\n  [Contact2]\n    type = BoundingBoxNodeSetGenerator\n    input = Contact1\n    bottom_left = '${fparse 1+spacing-ep} ${fparse -.2-ep} ${fparse 0-ep}'\n    top_right = '${fparse 1+spacing+ep}  ${fparse 0+ep} ${fparse 0.4+ep}'\n    new_boundary = contact2\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n  [rot_x]\n  []\n  [rot_y]\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  rotations = 'rot_x rot_y'\n[]\n\n[Kernels]\n  [solid_disp_x]\n    type = ADStressDivergenceShell\n    component = 0\n    variable = disp_x\n    through_thickness_order = SECOND\n  []\n  [solid_disp_y]\n    type = ADStressDivergenceShell\n    component = 1\n    variable = disp_y\n    through_thickness_order = SECOND\n  []\n  [solid_disp_z]\n    type = ADStressDivergenceShell\n    component = 2\n    variable = disp_z\n    through_thickness_order = SECOND\n  []\n  [solid_rot_x]\n    type = ADStressDivergenceShell\n    component = 3\n    variable = rot_x\n    through_thickness_order = SECOND\n  []\n  [solid_rot_y]\n    type = ADStressDivergenceShell\n    component = 4\n    variable = rot_y\n    through_thickness_order = SECOND\n  []\n[]\n\n[Materials]\n  # Materials are computed using the shell functions, see the moose docs on Shells.\n  [stress]\n    type = ADComputeShellStress\n    through_thickness_order = SECOND\n  []\n  [elasticity]\n    type = ADComputeIsotropicElasticityTensorShell\n    youngs_modulus = 500e9\n    poissons_ratio = 0.25\n    through_thickness_order = SECOND\n  []\n  [strain]\n    type = ADComputeFiniteShellStrain\n    thickness = 0.0001\n    through_thickness_order = SECOND\n  []\n[]\n\n[Constraints]\n  [GlueX]\n    type = NodalStickConstraint\n    boundary = 'contact2'\n    secondary = 'contact1'\n    penalty = 10e9\n    variable = disp_x\n  []\n  [GlueY]\n    type = NodalStickConstraint\n    boundary = 'contact2'\n    secondary = 'contact1'\n    penalty = 10e9\n    variable = disp_y\n  []\n  [GlueZ]\n    type = NodalStickConstraint\n    boundary = 'contact2'\n    secondary = 'contact1'\n    penalty = 10e9\n    variable = disp_z\n  []\n  [GlueRY]\n    type = NodalStickConstraint\n    boundary = 'contact2'\n    secondary = 'contact1'\n    penalty = 10e9\n    variable = rot_x\n  []\n  [GlueRZ]\n    type = NodalStickConstraint\n    boundary = 'contact2'\n    secondary = 'contact1'\n    penalty = 10e9\n    variable = rot_y\n  []\n[]\n\n[BCs]\n  [Fixed_X]\n    type = ADDirichletBC\n    boundary = 'left'\n    value = 0\n    variable = disp_x\n  []\n  [Fixed_Y]\n    type = ADDirichletBC\n    boundary = 'left'\n    value = 0\n    variable = disp_y\n  []\n  [Fixed_Z]\n    type = ADDirichletBC\n    boundary = 'left'\n    value = 0\n    variable = disp_z\n  []\n  [Fixed_Rot_X]\n    type = ADDirichletBC\n    boundary = 'left'\n    value = 0\n    variable = rot_x\n  []\n  [Fixed_Rot_Y]\n    type = ADDirichletBC\n    boundary = 'left'\n    value = 0\n    variable = rot_y\n  []\n  [Load]\n    type = ADDirichletBC\n    boundary = right\n    value = -.01\n    variable = disp_z\n    preset = false\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = false\n  []\n[]\n\n[Executioner]\n  type = Steady\n  automatic_scaling = TRUE\n  solve_type = 'NEWTON'\n  #   line_search = 'default'\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\n[Outputs]\n  [output_file]\n    type = Exodus\n    file_base = l_beams_glue\n  []\n[]\n\n\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/23256",
          "updatedAt": "2023-04-29T02:51:29Z",
          "publishedAt": "2023-01-26T16:17:31Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@neuphris @recuero on shell elements",
                  "url": "https://github.com/idaholab/moose/discussions/23256#discussioncomment-4800092",
                  "updatedAt": "2023-01-27T19:24:23Z",
                  "publishedAt": "2023-01-27T19:24:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "It appears that NodalStickConstraint has never been used with shells. What kind of bizarre results do you get? Is the penalty factor you selected sufficiently high?",
                  "url": "https://github.com/idaholab/moose/discussions/23256#discussioncomment-4821648",
                  "updatedAt": "2023-01-30T18:00:31Z",
                  "publishedAt": "2023-01-30T18:00:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Zoophish"
                          },
                          "bodyText": "The two parts that are supposed to be stuck together move apart by a very large distance on the first time step. The penalty factors in my example input file above are all 1e+10, but I tried with a variety of magnitudes and still got the same result.\nOne thing I was wondering was if the constrained nodes have to be overlapping in their initial state, or if they can have a small amount of spacing between them?\nThanks",
                          "url": "https://github.com/idaholab/moose/discussions/23256#discussioncomment-4832141",
                          "updatedAt": "2023-01-31T16:58:05Z",
                          "publishedAt": "2023-01-31T16:58:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I'd start with coincident nodes or extremely small gap. I'd also try enforcing the constraint only on displacements degrees of freedom, since that's the most trivial set.",
                          "url": "https://github.com/idaholab/moose/discussions/23256#discussioncomment-4835176",
                          "updatedAt": "2023-01-31T23:52:10Z",
                          "publishedAt": "2023-01-31T23:52:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Zoophish"
                          },
                          "bodyText": "So I removed the rotational constraints and reduced that spacing between the glued regions by two orders of magnitude; unfortunately I still get the same result.\nTimestep 0s\n\nTimestep 0.25s\n\nWould you expect this to work with shell elements?",
                          "url": "https://github.com/idaholab/moose/discussions/23256#discussioncomment-4849598",
                          "updatedAt": "2023-02-02T09:32:15Z",
                          "publishedAt": "2023-02-02T09:32:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I can try running it myself: Can you attach the mesh file?",
                          "url": "https://github.com/idaholab/moose/discussions/23256#discussioncomment-4856689",
                          "updatedAt": "2023-02-02T23:28:59Z",
                          "publishedAt": "2023-02-02T23:28:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Zoophish"
                          },
                          "bodyText": "Sure, here's the mesh.\nL_beams.msh.zip",
                          "url": "https://github.com/idaholab/moose/discussions/23256#discussioncomment-4860874",
                          "updatedAt": "2023-02-03T10:43:08Z",
                          "publishedAt": "2023-02-03T10:43:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Zoophish"
                          },
                          "bodyText": "I can try running it myself: Can you attach the mesh file?\n\nI don't suppose you've had a chance to do this yet?\nThanks",
                          "url": "https://github.com/idaholab/moose/discussions/23256#discussioncomment-5591463",
                          "updatedAt": "2023-04-12T11:27:10Z",
                          "publishedAt": "2023-04-12T11:27:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I didn't, but I am getting an issue with the mesh generator now:\n*** ERROR ***\nThe following error occurred in the object \"Contact1\", of type \"BoundingBoxNodeSetGenerator\".\n\nNo nodes found within the bounding box",
                          "url": "https://github.com/idaholab/moose/discussions/23256#discussioncomment-5595983",
                          "updatedAt": "2023-04-12T18:15:21Z",
                          "publishedAt": "2023-04-12T18:15:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}