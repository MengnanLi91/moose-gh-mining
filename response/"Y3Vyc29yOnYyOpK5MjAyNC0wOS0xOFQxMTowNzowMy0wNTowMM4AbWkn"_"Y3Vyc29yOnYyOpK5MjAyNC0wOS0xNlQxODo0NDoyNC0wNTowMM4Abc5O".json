{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wOS0xNlQxODo0NDoyNC0wNTowMM4Abc5O"
    },
    "edges": [
      {
        "node": {
          "title": "Hydrogen Transportation",
          "author": {
            "login": "AlejandroRiano2023"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello everyone, I hope you are doing great.\nI am working in Hydrogen Embrittlement. I am aiming to include hydrogen transportation into the phase field model. I was thinking about creating a variable for hydrogen concentration (c) that depends as follows c = c0 + \u03b1d, with (c0 is the initial Hydrogen Concentration, \u03b1 is a parameter and d is the phase field value parameter).\nThe problem is that I have only found equations in the form that you can see in the image. (Huang et all 2020)\n\nDo you happen to know which approach will be easier to adopt?  Should I include a new kernel with the Hydrogen Transportation and recompile my application?",
          "url": "https://github.com/idaholab/moose/discussions/28655",
          "updatedAt": "2024-09-18T15:49:44Z",
          "publishedAt": "2024-09-18T15:48:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Cyclic loading",
          "author": {
            "login": "engrmessi"
          },
          "bodyText": "Good afternoon\nI successfully simulated phase field model of diffusion controlled stress corrosion cracking SCC. In this model, my loading conditions was in form of strain rate, i.e. I applied strain rate (time displacement) at the right boundary as shown in the section of my code share here. Now my Advisor wants me to change the loading condition with cyclic loading to simulate fatigue cracking. Could anyone help me with how to implement cyclic load on BC block. Thank you",
          "url": "https://github.com/idaholab/moose/discussions/28312",
          "updatedAt": "2024-09-18T14:24:10Z",
          "publishedAt": "2024-08-05T18:35:05Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can write down a cyclic load with for example a cosine function?\nexpression = 2.94e-7 * cos(2*pi * t / period)\nsymbol_names = 'period'\nsymbol_values = ...",
                  "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10248972",
                  "updatedAt": "2024-08-06T03:08:34Z",
                  "publishedAt": "2024-08-06T03:08:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "engrmessi"
                  },
                  "bodyText": "Thank you for your response.\nI particularly want to know the type of function to use. Is it still 'ParsedFunction'? or Wound \"FunctionExpression\" be a better option?\nIs there any MOOSE documentation for cyclic loading, if yes, please share the link with me. I already searched, but I could not find any\nBest regards",
                  "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10255084",
                  "updatedAt": "2024-08-06T15:09:45Z",
                  "publishedAt": "2024-08-06T15:09:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "parsedfunction can be great to create the period loading.\nyou can also chain functions if you want a complex profile in one and the periodicity in the other",
                          "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10255181",
                          "updatedAt": "2024-08-06T15:18:43Z",
                          "publishedAt": "2024-08-06T15:18:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "engrmessi"
                          },
                          "bodyText": "Thank you for your feedback. I am still not successful\n[Functions]\n[tdisp]\ntype = ParsedFunction\nexpression = 2.94e-7 * cos(2pit/period)\nsymbol_names = 'period'\nsymbol_values = '16'\n[]\n[]\nAbove is what I incorporated in my script, but my simulation is failing. the error says \"syntax error, unexpected invalid token, expecting = or :=\"\nI also used the below function and the error persists\n[Functions]\n[tdisp]\ntype = ParsedFunction\nexpression = 2.94e-7 * cos(2pit/16)\n[]\n[]\nPlease how do I fix this syntax error. This error occurs in the line containing   expression = 2.94e-7 * cos(2pit/period)  and expression = 2.94e-7 * cos(2pit/16)",
                          "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10278561",
                          "updatedAt": "2024-08-08T17:52:30Z",
                          "publishedAt": "2024-08-08T17:52:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "engrmessi"
                          },
                          "bodyText": "Sorry, I fixed the syntax problem.\nBest regards",
                          "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10279526",
                          "updatedAt": "2024-08-08T20:17:32Z",
                          "publishedAt": "2024-08-08T20:17:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Awesome. Yes you were simply missing multiply symbols",
                          "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10280182",
                          "updatedAt": "2024-08-08T21:52:23Z",
                          "publishedAt": "2024-08-08T21:52:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "engrmessi"
                  },
                  "bodyText": "Good morning GiudGiud,\nStill on modeling stress cracking fatigue under cyclic load. My PI asked that I model two cases (1) strain controlled cyclic load and (2) stress controlled cyclic load.\nThe figures (a) and (b) are the input file and result (plot of stress vs time) obtain from strain controlled load which looks nice as the the peak stress is uniform.\nThe figure (c) and (d) are for the stress controlled input file and plot of stress vs time. Here the pick stress is not uniform. My question is if this plot is ok. Must the peak stress be uniform as in the case (1). If this is not ok, what can I do to achieve the even stress pick?\nPlease also note that the amplitude of the functions used differs for both cases. case (1), requires 0.05 amplitude for the material to degrade while case (2) needs 50 amplitude, please see the input files used\nCase (1): Strain controlled cyclic load\n\n\nCase (2): Stress controlled cyclic load",
                  "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10682290",
                  "updatedAt": "2024-09-18T14:34:07Z",
                  "publishedAt": "2024-09-18T14:07:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are these results converged in the time grid?\n@bwspenc who would be a good person to comment on this?",
                          "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10682435",
                          "updatedAt": "2024-09-18T14:13:29Z",
                          "publishedAt": "2024-09-18T14:13:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "engrmessi"
                  },
                  "bodyText": "Yes the results converged, however because there are a lot oscillations (cycle time) ....... up to 200000s, I only plot up to just 1200s and 2000s respectively.",
                  "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10682509",
                  "updatedAt": "2024-09-18T14:19:16Z",
                  "publishedAt": "2024-09-18T14:19:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "engrmessi"
                  },
                  "bodyText": "These are the fatigue cracking for the cases respectively",
                  "url": "https://github.com/idaholab/moose/discussions/28312#discussioncomment-10682563",
                  "updatedAt": "2024-09-18T14:24:11Z",
                  "publishedAt": "2024-09-18T14:24:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "error when use CoupledVarThresholdElementSubdomainModifier and mesh adaptivity at the same time",
          "author": {
            "login": "PEI0214"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello\nWhen I used CoupledVarThresholdElementSubdomainModifier and mesh adaptivity at the same time , appeared the following error:\nlibMesh terminating:\nExodusII_IO_Helper: block id 2 not found in block_ids.\n[0] ../src/mesh/exodusII_io_helper.C, line 3266, compiled Aug 20 2024 at 14:09:52\n\nAbort(1) on node 0 (rank 0 in comm 0): application called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n\nThe input file is as follows:\n\ntest.i\n# primary model units (m | s | Pa | kg --> N/m\u00b2)\n[Problem]\n  kernel_coverage_check = false\n  material_coverage_check = false\n  boundary_restricted_node_integrity_check = false\n[]\n\nnew_domain_blocks = '1001\t1002'\n\n[Mesh]\n  [BaseMesh]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 20\n    ny = 20\n    nz = 2\n    xmin = -5\n    xmax = +5\n    ymin = -5\n    ymax = +5\n    zmin = -2\n    zmax = +2\n  []\n  [Box1]\n    type = SubdomainBoundingBoxGenerator\n    input = \"BaseMesh\"\n    block_id = 1\n    location = \"INSIDE\"\n    bottom_left = \"-10 -10 -2\"\n    top_right   = \"+10 +10 +2\"\n  []\n  [Box2]\n    type = SubdomainBoundingBoxGenerator\n    input = \"Box1\"\n    block_id = 2\n    location = \"INSIDE\"\n    bottom_left = \"-10 -10 0\"\n    top_right   = \"+10 +10 +2\"\n  []\n\n  add_subdomain_ids = ${new_domain_blocks}\n\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  use_displaced_mesh = false\n[]\n\n[Variables]\n  [disp_x]\n    block = '${new_domain_blocks}'\n  []\n  [disp_y]\n    block = '${new_domain_blocks}'\n  []\n  [disp_z]\n    block = '${new_domain_blocks}'\n  []\n[]\n\n[Physics/SolidMechanics/QuasiStatic]\n  [./all]\n    strain = finite\n    add_variables = true\n    block = '${new_domain_blocks}'\n    generate_output = 'stress_xx stress_zz strain_xx strain_zz'\n  [../]\n[]\n\n# ===== Gravity =====\n[Kernels]\n  [Gravity]\n    type = Gravity\n    block = '${new_domain_blocks}'\n    use_displaced_mesh = false\n    variable = disp_z\n    value = -10\n  []\n[]\n\n# ===== Boundary Conditions =====\n[BCs]\n  [archor_x]\n    type = DirichletBC\n    boundary = 'back'\n    variable = disp_x\n    value = 0\n  []\n\n  [archor_y]\n    type = DirichletBC\n    boundary = 'back'\n    variable = disp_y\n    value = 0\n  []\n\n  [archor_z]\n    type = DirichletBC\n    boundary = 'back'\n    variable = disp_z\n    value = 0\n  []\n[]\n\n# ===== Materials (linear-elastic to keep it simple) =====\n[Materials]\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    block = '${new_domain_blocks}'\n    youngs_modulus = 50E6 # 50 MPa\n    poissons_ratio = 0.3\n  []\n\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n    block = '${new_domain_blocks}'\n  []\n\n  [density]\n    type = GenericConstantMaterial\n    block = '${new_domain_blocks}'\n    prop_names = density\n    prop_values = 2000\n  []\n[]\n\n# ===== Block Activation/Deactivation =====\n[Functions]\n  [Box_ActivationStateFunction]\n    type = PiecewiseConstant\n    direction = left\n    xy_data = '0   2\n               100 2\n               200 1\n               300 1\n               400 0\n               800 0'\n  []\n[]\n\n[AuxVariables]\n  [Box_Activation_AuxVariable]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n[]\n# link Box2_ActivationStateFunction and Box2_Activation_AuxVariable\n[AuxKernels]\n  [Box_Activation_FunctionAux]\n    type = FunctionAux\n    variable = 'Box_Activation_AuxVariable'\n    function = 'Box_ActivationStateFunction'\n    execute_on = 'INITIAL TIMESTEP_BEGIN'\n  []\n[]\n# move Box2 between subdomains\n[MeshModifiers]\n  [Box1_SubdomainModifier]\n    type = CoupledVarThresholdElementSubdomainModifier\n    coupled_var = 'Box_Activation_AuxVariable'\n    criterion_type = ABOVE\n    threshold = 1.5\n    block = 1\n    subdomain_id = 1\n    complement_subdomain_id = 1001\n    execute_on = 'INITIAL TIMESTEP_BEGIN'\n  []\n  [Box2_SubdomainModifier]\n    type = CoupledVarThresholdElementSubdomainModifier\n    coupled_var = 'Box_Activation_AuxVariable'\n    criterion_type = ABOVE\n    threshold = 0.5\n    block = 2\n    subdomain_id = 2\n    complement_subdomain_id = 1002\n    execute_on = 'INITIAL TIMESTEP_BEGIN'\n  []\n[]\n\n[Adaptivity]\n  marker = marker\n  max_h_level = 2\n  initial_steps = 1\n  stop_time = 200\n  [Markers]\n    [marker]\n      type = UniformMarker\n      mark = REFINE\n      block = '2'\n    []\n  []\n[]\n\n# ===== Executioner =====\n[Executioner]\n  type = Transient\n  automatic_scaling = true\n\n  end_time = 800\n  dt = 100\n\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = ' lu       mumps'\n\n  nl_abs_tol = 1E-2\n  nl_max_its = 400\n\n  l_tol = 1E-8\n  l_max_its = 200\n[]\n\n[Outputs]\n  [out]\n    type = Exodus\n  []\n  perf_graph = true\n[]\n\n[Debug]\n  show_var_residual_norms = true\n  # show_material_props = true\n[]\n\n\n\nWhen mesh adaptivity is not used, the simulation runs normally. CoupledVarThresholdElementSubdomainModifier and mesh adaptivity seems to conflicts. Is there a way to solve this problem?",
          "url": "https://github.com/idaholab/moose/discussions/28598",
          "updatedAt": "2024-09-18T08:17:54Z",
          "publishedAt": "2024-09-11T09:10:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis seems to come from the exodus output. It's a known issue\n#28005",
                  "url": "https://github.com/idaholab/moose/discussions/28598#discussioncomment-10618943",
                  "updatedAt": "2024-09-11T20:39:48Z",
                  "publishedAt": "2024-09-11T20:39:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "Hello, is there a solution to this problem now?",
                          "url": "https://github.com/idaholab/moose/discussions/28598#discussioncomment-10678601",
                          "updatedAt": "2024-09-18T07:47:50Z",
                          "publishedAt": "2024-09-18T07:47:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear @PEI0214, I dont know of any solution but there is an corresponding issue over there with libmesh: libMesh/libmesh#3949",
                          "url": "https://github.com/idaholab/moose/discussions/28598#discussioncomment-10678926",
                          "updatedAt": "2024-09-18T08:17:55Z",
                          "publishedAt": "2024-09-18T08:17:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Tools to split one boundary into two",
          "author": {
            "login": "pj131611"
          },
          "bodyText": "Hi there,\nWhile using \"Thermal Contact\" for mutually contacting geometry, we need to find a way to turn the interface or intersection between two geometry into two different boundaries. But I'm stuck on how to do so while the two contacting objects are in different size, let's say, a cube with length of 1 and a cube with length 2. Do I have to cut the larger cube in this case?\nAny help will be much appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/28642",
          "updatedAt": "2024-09-18T03:16:18Z",
          "publishedAt": "2024-09-17T11:16:44Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe contact interfaces do not have to match.\nIf your geometries are cubes, the sidesets-generators in moose (under MeshGenerator) should easily add the new sidesets\n(bottom of https://mooseframework.inl.gov/syntax/Mesh/index.html)\nIf your mesh started out with the two cubes merged together, you can use the BreakMeshByBlockGenerator to split them\nhttps://mooseframework.inl.gov/source/meshgenerators/BreakMeshByBlockGenerator.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10669548",
                  "updatedAt": "2024-09-17T11:28:56Z",
                  "publishedAt": "2024-09-17T11:28:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pj131611"
                          },
                          "bodyText": "Thanks for the quick response! That's exactly what I need!\nOn top of that, some of the interface are connected while I would like to take care of them one by one. So is there a function that breaks orthogonal connected interface into single pieces?",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676268",
                          "updatedAt": "2024-09-18T01:36:00Z",
                          "publishedAt": "2024-09-18T01:35:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "do you mean cutting subdomains apart? or do you mean cutting a large boundary in multiple parts?",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676284",
                          "updatedAt": "2024-09-18T01:39:00Z",
                          "publishedAt": "2024-09-18T01:39:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pj131611"
                          },
                          "bodyText": "Cutting a large boundary into multiple parts.",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676288",
                          "updatedAt": "2024-09-18T01:39:34Z",
                          "publishedAt": "2024-09-18T01:39:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you use the ParsedGenerateSideset with include_boundaries to do that?",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676401",
                          "updatedAt": "2024-09-18T02:00:37Z",
                          "publishedAt": "2024-09-18T02:00:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pj131611"
                          },
                          "bodyText": "I always run into error while using Parsed related functions, but I manage to split the interface with SideSetsAroundSubdomainGenerator by setting different normal vectors (benefit of cubes :D), but I noticed that some of the side side doesn't have a corresponding node set and the name of side set and node set doesn't agree either, did I missed anything?",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676656",
                          "updatedAt": "2024-09-18T02:51:22Z",
                          "publishedAt": "2024-09-18T02:51:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If there is a missing nodeset you can use an option in the Mesh block to convert the sidesets to nodeset s\nThere is also a generator for this conversion\nSidesetsToNodesetsGenerator iirc",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676769",
                          "updatedAt": "2024-09-18T03:14:54Z",
                          "publishedAt": "2024-09-18T03:14:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pj131611"
                          },
                          "bodyText": "That's Wonderful. Thanks again for all your help!",
                          "url": "https://github.com/idaholab/moose/discussions/28642#discussioncomment-10676777",
                          "updatedAt": "2024-09-18T03:16:14Z",
                          "publishedAt": "2024-09-18T03:16:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Inconsistent precipitates",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "The precipitates in my simulation look very weird and I cannot figure out why. Below is a picture. Most of them are too long than usual.\n\nI had a multiphase script(two-precipitate) as seen below. That is the shapes I want. I changes it to only one precipitate and they grow too long.\n\nBelow are snippets of the code\n\n[Bounds]\n  [./eta_upper_bound]\n    type = ConstantBounds\n    variable = bounds_dummy\n    bounded_variable = eta0\n    bound_type = upper\n    bound_value = 1\n  [../]\n  [./eta_lower_bound]\n    type = ConstantBounds\n    variable = bounds_dummy\n    bounded_variable = eta0\n    bound_type = lower\n    bound_value = -1\n  [../]\n  \n[]\n[Functions]\n  [./ic_func_c]\n    type = ParsedFunction\n    expression = 0.5+0.01*(cos(1.05*x)*cos(1.1*y)+(cos(1.3*x)*cos(0.87*y))^2+cos(0.25*x-1.5*y)*cos(0.7*x-0.2*y))\n  [../]\n  [./bc_func]\n    type = ParsedFunction\n    expression = sin(alpha*pi*x)\n    symbol_names = alpha\n    symbol_values = 16\n  [../]\n  [./disp_func]\n    type = ParsedFunction\n    expression = 'if(t<50,6e-3*t,0.3)'\n  [../]\n  [./press_func]\n    type = ParsedFunction\n    expression = '1'\n  [../]\n[]\n\n[ICs]\n  [./eta0]\n    variable = eta0\n    type = RandomIC\n    min = -0.1625\n    max = 0.1625\n    seed = 192\n  [../]\n  \n  [./c]\n    variable = c\n    type = RandomIC\n    min = 0.24375\t\n    max = 0.25625\n    seed = 89\t\n  [../]\n[Materials]\n  # simple toy free energies\n  [./f0]\n    type = DerivativeParsedMaterial\n    property_name = fc_0\n    coupled_variables = 'c0'\n    expression = '100.0*(c0-0.3333)^2'\n  [../]\n  # Elastic energy of the phase 0\n  [./elastic_free_energy_0]\n    type = ElasticEnergyMaterial\n    base_name = phase0\n    property_name = fe_0\n    coupled_variables = ' '\n  [../]\n  # Total free energy of the phase 0\n  [./Total_energy_0]\n    type = DerivativeSumMaterial\n    property_name = F0\n    sum_materials = 'fc_0 fe_0'\n    coupled_variables = 'c0'\n  [../]\n\n \n\n  [./f1]\n    type = DerivativeParsedMaterial\n    property_name = fc_1\n    coupled_variables  = 'c1'\n    expression = '5.0*(c1-0.20)^2'\n  [../]\n  # Elastic energy of the phase 1\n  [./elastic_free_energy_1]\n    type = ElasticEnergyMaterial\n    base_name = phase1\n    property_name = fe_1\n    coupled_variables = ' '\n  [../]\n  # Total free energy of the phase 1\n  [./Total_energy_1]\n    type = DerivativeSumMaterial\n    property_name = F1\n    sum_materials = 'fc_1 fe_1'\n    coupled_variables = 'c1'\n  [../]\n\n  # Switching functions for each phase\n  # h0(eta0, eta1)\n  [./h0]\n    type = SwitchingFunctionMultiPhaseMaterial\n    phase_etas = eta0\n    all_etas = 'eta0  eta1'\n    h_name = h0\n  [../]\n  \n  # h1(eta0,  eta1)\n  [./h1]\n    type = SwitchingFunctionMultiPhaseMaterial\n    phase_etas = eta1\n    all_etas = 'eta0  eta1'\n    h_name = h1\n  [../]\n\n  # Coefficients for diffusion equation\n  [./Dh0]\n    type = DerivativeParsedMaterial\n    material_property_names = 'D h0'\n    function = D*h0\n    f_name = Dh0\n  [../]\n  \n  [./Dh1]\n    type = DerivativeParsedMaterial\n    material_property_names = 'D h1'\n    function = D*h1\n    f_name = Dh1\n  [../]\n\n  # Barrier functions for each phase\n  [./g0]\n    type = BarrierFunctionMaterial\n    g_order = SIMPLE\n    eta = eta0\n    function_name = g0\n  [../]\n\n  [./g1]\n    type = BarrierFunctionMaterial\n    g_order = SIMPLE\n    eta = eta1\n    function_name = g1\n  [../]\n\n  # constant properties\n  [./constants]\n    type = GenericConstantMaterial\n    prop_names  = 'L    kappa  D    W'\n    prop_values = '0.3  0.01   1    0.01'\n  [../]\n\n  #Mechanical properties\n  [./Stiffness_phase0]\n    type = ComputeElasticityTensor\n    C_ijkl = '1982 534 496 1606 605 1788 985 1056 388'    \n    base_name = phase0\n    fill_method = symmetric9\n  [../]\n  \n  [./Stiffness_phase1]\n    type = ComputeElasticityTensor\n    C_ijkl = '2008.5 448.9 918.5 2008.5 918.5 1538.7 779.8 779.8 309.9'    \n    base_name = phase1\n    fill_method = symmetric9\n  [../]\n\n  [./stress_phase0]\n    type = ComputeLinearElasticStress\n    base_name = phase0\n  [../]\n  \n  [./stress_phase1]\n    type = ComputeLinearElasticStress\n    base_name = phase1\n  [../]\n\n  [./strain_phase0]\n    type = ComputeSmallStrain\n    displacements = 'disp_x disp_y'\n    base_name = phase0\n    eigenstrain_names = eigenstrain0\n  [../]\n \n  [./strain_phase1]\n    type = ComputeSmallStrain\n    displacements = 'disp_x disp_y'\n    base_name = phase1\n  [../]\n\n  [./eigen_strain0]\n   type = ComputeEigenstrain\n   base_name = phase0\n   eigen_base = '1 0 0 0 0 0'\n   prefactor = '0.005 0.005 0.005'\n   eigenstrain_name = eigenstrain0\n  [../]\n\n\n\n  # Generate the global stress from the phase stresses\n  [./global_stress]\n    type = MultiPhaseStressMaterial\n    phase_base = 'phase0  phase1'\n    h          = 'h0        h1'\n  [../]\n\n  [./global_strain]\n    type = ComputeSmallStrain\n    displacements = 'disp_x disp_y'\n  [../]\n[]\n\n[Kernels]\n  \n\n  #Kernels for diffusion equation\n  [./diff_time]\n    type = TimeDerivative\n    variable = c\n  [../]\n  [./diff_c0]\n    type = MatDiffusion\n    variable = c\n    diffusivity = Dh0\n    v = c1\n  [../]\n\n  [./diff_c1]\n    type = MatDiffusion\n    variable = c\n    diffusivity = Dh1\n    v = c1\n  [../]\n\n  # Kernels for Allen-Cahn equation for eta0\n  [./deta0dt]\n    type = TimeDerivative\n    variable = eta0\n  [../]\n  [./ACBulkF0]\n    type = KKSMultiACBulkF\n    variable  = eta0\n    Fj_names  = 'F0  F1'\n    hj_names  = 'h0  h1'\n    gi_name   = g0\n    eta_i     = eta0\n    wi        = 0.01\n    args      = 'c0  c1  eta1'\n  [../]\n  [./ACBulkC0]\n    type = KKSMultiACBulkC\n    variable  = eta0\n    Fj_names  = 'F0  F1'\n    hj_names  = 'h0  h1'\n    cj_names  = 'c0  c1'\n    eta_i     = eta0\n    args      = 'eta1'\n  [../]\n  [./ACInterface0]\n    type = ACInterface\n    variable = eta0\n    kappa_name = kappa\n  [../]\n\n \n\n  # Kernels for constraint equation eta0 + eta1 = 1\n  # eta1 is the nonlinear variable for the constraint equation\n  [./eta1reaction]\n    type = MatReaction\n    variable = eta1\n    mob_name = 1\n  [../]\n  [./eta0reaction]\n    type = MatReaction\n    variable = eta1\n    v = eta0\n    mob_name = 1\n  [../]\n  \n  [./one]\n    type = BodyForce\n    variable = eta1\n    value = -1.0\n  [../]\n\n\n  # Phase concentration constraints\n  [./chempot13]\n    type = KKSPhaseChemicalPotential\n    variable = c0\n    cb       = c1\n    fa_name  = F0\n    fb_name  = F1\n  [../]\n  \n  [./phaseconcentration]\n    type = KKSMultiPhaseConcentration\n    variable = c1\n    cj = 'c0  c1'\n    hj_names = 'h0 h1'\n    etas = 'eta0  eta1'\n    c = c\n  [../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/28649",
          "updatedAt": "2024-09-18T00:16:59Z",
          "publishedAt": "2024-09-17T20:13:19Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou left out the executonier block. We should check your solver parameters to be sure this is converged.",
                  "url": "https://github.com/idaholab/moose/discussions/28649#discussioncomment-10675653",
                  "updatedAt": "2024-09-17T23:06:20Z",
                  "publishedAt": "2024-09-17T23:06:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "Below is the executioner block.\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu            mumps            vinewtonrsls'\n\n  l_max_its = 50\n  nl_max_its = 25\n  l_tol = 1.0e-3\n  nl_rel_tol = 1.0e-6\n  nl_abs_tol = 1.0e-8\n\n  end_time = 10000\n\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 5e-4\n    cutback_factor = 0.75\n    growth_factor = 1.2\n    optimal_iterations = 20\n  [../]\n\n  [./Adaptivity]\n    initial_adaptivity = 0\n    refine_fraction = 0.7\n    coarsen_fraction = 0.1\n    max_h_level = 1\n  [../]\n\n[]\n\nI have attached a snippet of the .out file\nResetting modules to system default. Reseting $MODULEPATH back to system default. All extra directories will be removed from $MODULEPATH.\nRun 'mamba init' to be able to run mamba activate/deactivate\nand start a new shell session. Or use conda to activate/deactivate.\n\n\n\ufffd[36m\n*** Info ***\nSolidMechanics Action: selecting 'incremental finite strain' formulation.\ufffd[39m\n\n\ufffd[33m\n*** Warning, This code is deprecated and will be removed in future versions:\n/home/emmanuel324/projects/belson/My_Project/My_two_phase/Test_5_two_phase_test_trial_5/Test_5_two_phase_test_trial_5.i:257: (Materials/Dh0/f_name):\nThe parameter 'f_name' is deprecated.\nf_name is deprecated, use property_name\n\ufffd[39m\n\n\ufffd[33m\n*** Warning, This code is deprecated and will be removed in future versions:\n/home/emmanuel324/projects/belson/My_Project/My_two_phase/Test_5_two_phase_test_trial_5/Test_5_two_phase_test_trial_5.i:256: (Materials/Dh0/function):\nThe parameter 'function' is deprecated.\n'function' is deprecated, use 'expression' instead\n\ufffd[39m\n\n\ufffd[33m\n*** Warning, This code is deprecated and will be removed in future versions:\n/home/emmanuel324/projects/belson/My_Project/My_two_phase/Test_5_two_phase_test_trial_5/Test_5_two_phase_test_trial_5.i:385: (Kernels/ACBulkF0/args):\n'args' has been deprecated and will be removed on 02/07/2024. Please use 'coupled_variables' instead.\n\ufffd[39m\nCurrently Setting Up\n  Initializing\n    Finished Initializing Equation Systems                                               [\ufffd[33m  0.69 s\ufffd[39m] [\ufffd[33m  427 MB\ufffd[39m]\n  Finished Initializing                                                                  [\ufffd[33m  0.92 s\ufffd[39m] [\ufffd[33m  427 MB\ufffd[39m]\nUsing EXPERIMENTAL Stateful Material Property projection with Adaptivity!\nFinished Setting Up                                                                      [\ufffd[33m  3.77 s\ufffd[39m] [\ufffd[33m  427 MB\ufffd[39m]\nFramework Information:\nMOOSE Version:           git commit 4505a3e on 2024-06-10\nLibMesh Version:         1c5369aa05eaae8ebeb7930845fce3b1d59cbb37\nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1\nCurrent Time:            Mon Sep 16 14:55:44 2024\nExecutable Timestamp:    Wed Sep 11 14:18:50 2024\n\nParallelism:\n  Num Processors:          2\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   \n    Total:                 22801\n    Local:                 11492\n    Min/Max/Avg:           11309/11492/11400\n  Elems:                   \n    Total:                 22500\n    Local:                 11250\n    Min/Max/Avg:           11250/11250/11250\n  Num Subdomains:          1\n  Num Partitions:          2\n  Partitioner:             metis\n\nNonlinear System:\n  Num DOFs:                159607\n  Num Local DOFs:          80444\n  Variables:               { \"c\" \"eta0\" \"eta1\" \"c0\" \"c1\" } { \"disp_x\" \"disp_y\" } \n  Finite Element Types:    \"LAGRANGE\" \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                90301\n  Num Local DOFs:          45242\n  Variables:               \"Energy\" \"stress_xx\" \"e_xx\" \"bounds_dummy\" \n  Finite Element Types:    \"MONOMIAL\" \"MONOMIAL\" \"MONOMIAL\" \"LAGRANGE\" \n  Approximation Orders:    \"CONSTANT\" \"CONSTANT\" \"CONSTANT\" \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             IterationAdaptiveDT\n  TimeIntegrator:          ImplicitEuler\n  Solver Mode:             Preconditioned JFNK\n  PETSc Preconditioner:    lu \n  MOOSE Preconditioner:    SMP\n\nCurrently Executing\n  Performing Initial Setup\n    Finished Setting Up Initial Conditions                                               [\ufffd[33m  0.24 s\ufffd[39m] [\ufffd[33m  643 MB\ufffd[39m]\n  Finished Performing Initial Setup                                                      [\ufffd[33m  1.38 s\ufffd[39m] [\ufffd[33m  675 MB\ufffd[39m]\n\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\n\nTime Step 1, time = 0.0005, dt = 0.0005\n 0 Nonlinear |R| = \ufffd[32m3.867241e+04\ufffd[39m\n      0 Linear |R| = \ufffd[32m3.867241e+04\ufffd[39m\n      1 Linear |R| = \ufffd[33m3.867241e+04\ufffd[39m\n      2 Linear |R| = \ufffd[33m3.867241e+04\ufffd[39m\n      3 Linear |R| = \ufffd[33m3.867240e+04\ufffd[39m\n      4 Linear |R| = \ufffd[33m3.867235e+04\ufffd[39m\n      5 Linear |R| = \ufffd[33m3.867210e+04\ufffd[39m\n      6 Linear |R| = \ufffd[33m3.867025e+04\ufffd[39m\n      7 Linear |R| = \ufffd[33m3.867025e+04\ufffd[39m\n      8 Linear |R| = \ufffd[33m3.867011e+04\ufffd[39m\n      9 Linear |R| = \ufffd[33m3.867011e+04\ufffd[39m\n     10 Linear |R| = \ufffd[33m3.866875e+04\ufffd[39m\n     11 Linear |R| = \ufffd[33m3.866621e+04\ufffd[39m\n     12 Linear |R| = \ufffd[33m3.866498e+04\ufffd[39m\n     13 Linear |R| = \ufffd[33m3.865598e+04\ufffd[39m\n     14 Linear |R| = \ufffd[33m3.861835e+04\ufffd[39m\n     15 Linear |R| = \ufffd[33m3.861363e+04\ufffd[39m\n     16 Linear |R| = \ufffd[33m3.861319e+04\ufffd[39m\n     17 Linear |R| = \ufffd[33m3.861305e+04\ufffd[39m\n     18 Linear |R| = \ufffd[33m3.847891e+04\ufffd[39m\n     19 Linear |R| = \ufffd[33m3.841992e+04\ufffd[39m\n     20 Linear |R| = \ufffd[33m3.841864e+04\ufffd[39m\n     21 Linear |R| = \ufffd[33m3.838637e+04\ufffd[39m\n     22 Linear |R| = \ufffd[33m3.829653e+04\ufffd[39m\n     23 Linear |R| = \ufffd[33m3.828652e+04\ufffd[39m\n     24 Linear |R| = \ufffd[33m3.821860e+04\ufffd[39m\n     25 Linear |R| = \ufffd[33m3.821019e+04\ufffd[39m\n     26 Linear |R| = \ufffd[33m3.813820e+04\ufffd[39m\n     27 Linear |R| = \ufffd[33m3.803107e+04\ufffd[39m\n     28 Linear |R| = \ufffd[33m3.801110e+04\ufffd[39m\n     29 Linear |R| = \ufffd[33m3.799088e+04\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 1 Nonlinear |R| = \ufffd[33m3.867241e+04\ufffd[39m\n      0 Linear |R| = \ufffd[32m3.867241e+04\ufffd[39m\n      1 Linear |R| = \ufffd[33m3.867239e+04\ufffd[39m\n      2 Linear |R| = \ufffd[33m3.867224e+04\ufffd[39m\n      3 Linear |R| = \ufffd[33m3.866658e+04\ufffd[39m\n      4 Linear |R| = \ufffd[33m3.863841e+04\ufffd[39m\n      5 Linear |R| = \ufffd[33m3.856503e+04\ufffd[39m\n      6 Linear |R| = \ufffd[33m3.780299e+04\ufffd[39m\n      7 Linear |R| = \ufffd[33m3.761568e+04\ufffd[39m\n      8 Linear |R| = \ufffd[33m3.760762e+04\ufffd[39m\n      9 Linear |R| = \ufffd[33m3.745536e+04\ufffd[39m\n     10 Linear |R| = \ufffd[33m3.727775e+04\ufffd[39m\n     11 Linear |R| = \ufffd[33m3.715244e+04\ufffd[39m\n     12 Linear |R| = \ufffd[33m3.560428e+04\ufffd[39m\n     13 Linear |R| = \ufffd[33m3.421370e+04\ufffd[39m\n     14 Linear |R| = \ufffd[33m3.418394e+04\ufffd[39m\n     15 Linear |R| = \ufffd[33m3.371675e+04\ufffd[39m\n     16 Linear |R| = \ufffd[33m3.354023e+04\ufffd[39m\n     17 Linear |R| = \ufffd[33m3.336458e+04\ufffd[39m\n     18 Linear |R| = \ufffd[33m3.252735e+04\ufffd[39m\n     19 Linear |R| = \ufffd[32m2.777352e+04\ufffd[39m\n     20 Linear |R| = \ufffd[33m2.659539e+04\ufffd[39m\n     21 Linear |R| = \ufffd[33m2.608524e+04\ufffd[39m\n     22 Linear |R| = \ufffd[33m2.491752e+04\ufffd[39m\n     23 Linear |R| = \ufffd[33m2.491735e+04\ufffd[39m\n     24 Linear |R| = \ufffd[33m2.476447e+04\ufffd[39m\n     25 Linear |R| = \ufffd[33m2.361111e+04\ufffd[39m\n     26 Linear |R| = \ufffd[33m2.286284e+04\ufffd[39m\n     27 Linear |R| = \ufffd[33m2.269276e+04\ufffd[39m\n     28 Linear |R| = \ufffd[33m2.268898e+04\ufffd[39m\n     29 Linear |R| = \ufffd[33m2.162033e+04\ufffd[39m\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n 2 Nonlinear |R| = \ufffd[32m2.589565e+04\ufffd[39m\n      0 Linear |R| = \ufffd[32m2.589565e+04\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.144917e+02\ufffd[39m\n      2 Linear |R| = \ufffd[32m1.939679e-01\ufffd[39m\n 3 Nonlinear |R| = \ufffd[32m1.718004e+03\ufffd[39m\n      0 Linear |R| = \ufffd[32m1.718004e+03\ufffd[39m\n      1 Linear |R| = \ufffd[32m6.564048e-01\ufffd[39m\n 4 Nonlinear |R| = \ufffd[32m1.054581e+01\ufffd[39m\n      0 Linear |R| = \ufffd[32m1.054581e+01\ufffd[39m\n      1 Linear |R| = \ufffd[32m2.552648e-03\ufffd[39m\n 5 Nonlinear |R| = \ufffd[32m2.544406e-03\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m 96.31 s\ufffd[39m] [\ufffd[33m  808 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m7.603077e-12\ufffd[39m\n  eta0: \ufffd[31m2.561580e-04\ufffd[39m\n  eta1: \ufffd[31m4.820619e-14\ufffd[39m\n  c0: \ufffd[31m2.340218e-12\ufffd[39m\n  c1: \ufffd[31m2.140194e-06\ufffd[39m\n  disp_x: \ufffd[31m2.451197e-03\ufffd[39m\n  disp_y: \ufffd[31m6.324660e-04\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\n  Adapting Mesh\n  Finished Adapting Mesh                                                                 [\ufffd[33m 14.45 s\ufffd[39m] [\ufffd[33m 1252 MB\ufffd[39m]\n\nTime Step 2, time = 0.0011, dt = 0.0006\n 0 Nonlinear |R| = \ufffd[32m6.006612e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.86 s\ufffd[39m] [\ufffd[33m 1407 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m6.006612e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m5.328848e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m5.316300e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.75 s\ufffd[39m] [\ufffd[33m 3488 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m5.316300e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m7.714357e-07\ufffd[39m\n      2 Linear |R| = \ufffd[32m7.090030e-11\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m1.255470e-10\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m110.95 s\ufffd[39m] [\ufffd[33m 1544 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m9.528201e-11\ufffd[39m\n  eta0: \ufffd[31m7.168654e-11\ufffd[39m\n  eta1: \ufffd[31m7.472552e-13\ufffd[39m\n  c0: \ufffd[31m3.539682e-11\ufffd[39m\n  c1: \ufffd[31m1.974631e-13\ufffd[39m\n  disp_x: \ufffd[31m1.640355e-11\ufffd[39m\n  disp_y: \ufffd[31m4.671379e-12\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\n  Adapting Mesh\n  Finished Adapting Mesh                                                                 [\ufffd[33m 17.39 s\ufffd[39m] [\ufffd[33m 1393 MB\ufffd[39m]\n\nTime Step 3, time = 0.00182, dt = 0.00072\n 0 Nonlinear |R| = \ufffd[32m1.786843e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  8.21 s\ufffd[39m] [\ufffd[33m 1551 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.786843e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.523108e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m1.522840e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.79 s\ufffd[39m] [\ufffd[33m 3785 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.522840e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.674963e-07\ufffd[39m\n      2 Linear |R| = \ufffd[32m3.133248e-11\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m9.677091e-11\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m128.34 s\ufffd[39m] [\ufffd[33m 1482 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m8.186533e-11\ufffd[39m\n  eta0: \ufffd[31m2.438065e-11\ufffd[39m\n  eta1: \ufffd[31m7.638718e-13\ufffd[39m\n  c0: \ufffd[31m3.699846e-11\ufffd[39m\n  c1: \ufffd[31m1.932151e-13\ufffd[39m\n  disp_x: \ufffd[31m2.568946e-11\ufffd[39m\n  disp_y: \ufffd[31m6.229445e-12\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n|   1.820000e-03 |   4.500000e+04 |   9.945580e+05 |   6.519926e+01 |   8.993480e+04 |   5.509244e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\nMesh unchanged, skipping remaining steps...\n\nTime Step 4, time = 0.002684, dt = 0.000864\n 0 Nonlinear |R| = \ufffd[32m1.217144e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.55 s\ufffd[39m] [\ufffd[33m 1501 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.217144e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.515804e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m1.515815e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.57 s\ufffd[39m] [\ufffd[33m 3779 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.515815e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m5.053920e-08\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m5.053913e-08\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m123.99 s\ufffd[39m] [\ufffd[33m 1492 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m2.321059e-12\ufffd[39m\n  eta0: \ufffd[31m5.042481e-08\ufffd[39m\n  eta1: \ufffd[31m2.414986e-14\ufffd[39m\n  c0: \ufffd[31m1.172858e-12\ufffd[39m\n  c1: \ufffd[31m6.881574e-15\ufffd[39m\n  disp_x: \ufffd[31m3.226314e-09\ufffd[39m\n  disp_y: \ufffd[31m1.064560e-09\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n|   1.820000e-03 |   4.500000e+04 |   9.945580e+05 |   6.519926e+01 |   8.993480e+04 |   5.509244e+03 |\n|   2.684000e-03 |   4.500000e+04 |   9.945580e+05 |   6.521072e+01 |   8.993479e+04 |   5.509244e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\nMesh unchanged, skipping remaining steps...\n\nTime Step 5, time = 0.0037208, dt = 0.0010368\n 0 Nonlinear |R| = \ufffd[32m1.212686e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.61 s\ufffd[39m] [\ufffd[33m 1511 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.212686e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.819112e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m1.819128e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.47 s\ufffd[39m] [\ufffd[33m 3788 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.819128e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m6.065502e-08\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m6.065484e-08\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m121.59 s\ufffd[39m] [\ufffd[33m 1568 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m2.120318e-12\ufffd[39m\n  eta0: \ufffd[31m6.051764e-08\ufffd[39m\n  eta1: \ufffd[31m2.414130e-14\ufffd[39m\n  c0: \ufffd[31m1.178198e-12\ufffd[39m\n  c1: \ufffd[31m7.662110e-15\ufffd[39m\n  disp_x: \ufffd[31m3.871935e-09\ufffd[39m\n  disp_y: \ufffd[31m1.277637e-09\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n|   1.820000e-03 |   4.500000e+04 |   9.945580e+05 |   6.519926e+01 |   8.993480e+04 |   5.509244e+03 |\n|   2.684000e-03 |   4.500000e+04 |   9.945580e+05 |   6.521072e+01 |   8.993479e+04 |   5.509244e+03 |\n|   3.720800e-03 |   4.500000e+04 |   9.945580e+05 |   6.522447e+01 |   8.993478e+04 |   5.509244e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\nMesh unchanged, skipping remaining steps...\n\nTime Step 6, time = 0.00496496, dt = 0.00124416\n 0 Nonlinear |R| = \ufffd[32m1.207379e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.36 s\ufffd[39m] [\ufffd[33m 1568 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.207379e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m2.183145e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m2.183168e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.34 s\ufffd[39m] [\ufffd[33m 3818 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m2.183168e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m7.279718e-08\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m7.279711e-08\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m121.23 s\ufffd[39m] [\ufffd[33m 1591 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m2.161549e-12\ufffd[39m\n  eta0: \ufffd[31m7.263246e-08\ufffd[39m\n  eta1: \ufffd[31m2.419832e-14\ufffd[39m\n  c0: \ufffd[31m1.186779e-12\ufffd[39m\n  c1: \ufffd[31m9.005750e-15\ufffd[39m\n  disp_x: \ufffd[31m4.646854e-09\ufffd[39m\n  disp_y: \ufffd[31m1.533397e-09\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n|   1.820000e-03 |   4.500000e+04 |   9.945580e+05 |   6.519926e+01 |   8.993480e+04 |   5.509244e+03 |\n|   2.684000e-03 |   4.500000e+04 |   9.945580e+05 |   6.521072e+01 |   8.993479e+04 |   5.509244e+03 |\n|   3.720800e-03 |   4.500000e+04 |   9.945580e+05 |   6.522447e+01 |   8.993478e+04 |   5.509244e+03 |\n|   4.964960e-03 |   4.500000e+04 |   9.945580e+05 |   6.524097e+01 |   8.993476e+04 |   5.509244e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n\nMesh unchanged, skipping remaining steps...\n\nTime Step 7, time = 0.00645795, dt = 0.00149299\n 0 Nonlinear |R| = \ufffd[32m1.201069e+00\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.79 s\ufffd[39m] [\ufffd[33m 1591 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.201069e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m2.620077e-04\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m2.620109e-04\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  7.73 s\ufffd[39m] [\ufffd[33m 3818 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m2.620109e-04\ufffd[39m\n      1 Linear |R| = \ufffd[32m8.737295e-08\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m8.737272e-08\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m123.53 s\ufffd[39m] [\ufffd[33m 1576 MB\ufffd[39m]\n\ufffd[32m Solve Converged!\ufffd[39m\n\nOutlier Variable Residual Norms:\n  c: \ufffd[31m2.549443e-12\ufffd[39m\n  eta0: \ufffd[31m8.717512e-08\ufffd[39m\n  eta1: \ufffd[31m2.412127e-14\ufffd[39m\n  c0: \ufffd[31m1.178910e-12\ufffd[39m\n  c1: \ufffd[31m1.119583e-14\ufffd[39m\n  disp_x: \ufffd[31m5.576988e-09\ufffd[39m\n  disp_y: \ufffd[31m1.840444e-09\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | dofs           | gr0area        | gr1area        | h1_error       |\n+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   3.258755e+01 |   0.000000e+00 |   6.517510e+01 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-04 |   4.500000e+04 |   2.499080e+05 |   6.518175e+01 |   8.993482e+04 |   1.107186e+04 |\n|   1.100000e-03 |   4.500000e+04 |   9.526030e+05 |   6.518971e+01 |   8.993481e+04 |   6.119708e+03 |\n|   1.820000e-03 |   4.500000e+04 |   9.945580e+05 |   6.519926e+01 |   8.993480e+04 |   5.509244e+03 |\n|   2.684000e-03 |   4.500000e+04 |   9.945580e+05 |   6.521072e+01 |   8.993479e+04 |   5.509244e+03 |\n|   3.720800e-03 |   4.500000e+04 |   9.945580e+05 |   6.522447e+01 |   8.993478e+04 |   5.509244e+03 |\n|   4.964960e-03 |   4.500000e+04 |   9.945580e+05 |   6.524097e+01 |   8.993476e+04 |   5.509244e+03 |\n|   6.457952e-03 |   4.500000e+04 |   9.945580e+05 |   6.526078e+01 |   8.993474e+04 |   5.509244e+03 |\n+----------------+----------------+----------------+----------------+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/28649#discussioncomment-10675758",
                          "updatedAt": "2024-09-17T23:32:46Z",
                          "publishedAt": "2024-09-17T23:32:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "nl_rel_tol could be tighter but I think the convergence looks good enough.\nYou might want to confer with phase field experts",
                          "url": "https://github.com/idaholab/moose/discussions/28649#discussioncomment-10675786",
                          "updatedAt": "2024-09-17T23:40:40Z",
                          "publishedAt": "2024-09-17T23:40:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "Yeah. When I had two precipitates, they evolved into reasonable sizes but after I modified to one and started tracking the average area they grew uncontrollably. Can you tag someone on my behalf?",
                          "url": "https://github.com/idaholab/moose/discussions/28649#discussioncomment-10675825",
                          "updatedAt": "2024-09-17T23:52:32Z",
                          "publishedAt": "2024-09-17T23:52:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@amjokisaari @dschwen",
                          "url": "https://github.com/idaholab/moose/discussions/28649#discussioncomment-10675897",
                          "updatedAt": "2024-09-18T00:17:00Z",
                          "publishedAt": "2024-09-18T00:16:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Failed to open output file",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI am running an input script and it failed due to this error\n*** ERROR ***\nFailed to open fileTest_5_two_phase_test_trial_5_new_out.e-s008\ufffd[39m",
          "url": "https://github.com/idaholab/moose/discussions/28650",
          "updatedAt": "2024-09-17T23:41:11Z",
          "publishedAt": "2024-09-17T22:30:40Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nwe need more information here. What were you running, what systems were in use? etc",
                  "url": "https://github.com/idaholab/moose/discussions/28650#discussioncomment-10675650",
                  "updatedAt": "2024-09-17T23:05:37Z",
                  "publishedAt": "2024-09-17T23:05:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "I am running a phase field model using kks. Everything was working fine until all my current running jobs failed due to similar error messages. I am using an HPC cluster",
                          "url": "https://github.com/idaholab/moose/discussions/28650#discussioncomment-10675742",
                          "updatedAt": "2024-09-17T23:27:00Z",
                          "publishedAt": "2024-09-17T23:27:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "did you meet the storage limit on the HPC cluster? This would explain why the file cant be created/read",
                          "url": "https://github.com/idaholab/moose/discussions/28650#discussioncomment-10675790",
                          "updatedAt": "2024-09-17T23:41:11Z",
                          "publishedAt": "2024-09-17T23:41:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Is there a BC object to specify a BC that depends on the time derivative of a variable?",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nIs there an existing implementation that can apply the neumann BC:\nstress . normal = -d * du/dt?\nWhere d is a constant and du/dt is the time derivative of a variable (displacement)? I am trying to use this in conjunction with DynamicStressDivergenceTensors. I checked the existing ones and couldn't find one, wanted to know if there's an alternative way before I attempt implementing it myself.",
          "url": "https://github.com/idaholab/moose/discussions/28646",
          "updatedAt": "2024-09-17T23:22:07Z",
          "publishedAt": "2024-09-17T17:05:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI went through the list and did not see one. You could search more in the dynamics examples\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28646#discussioncomment-10675707",
                  "updatedAt": "2024-09-17T23:19:01Z",
                  "publishedAt": "2024-09-17T23:19:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "okay thank you",
                          "url": "https://github.com/idaholab/moose/discussions/28646#discussioncomment-10675721",
                          "updatedAt": "2024-09-17T23:22:07Z",
                          "publishedAt": "2024-09-17T23:22:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Converge issue",
          "author": {
            "login": "Yulongggggg"
          },
          "bodyText": "https://github.com/Yulongggggg/2D_groundstress This is my code link, I am trying to model the situation of biaxial loading of soil. But the code seems unable to converge, could you please tell me my mistakes. Thank you so much!",
          "url": "https://github.com/idaholab/moose/discussions/28641",
          "updatedAt": "2024-11-20T19:18:24Z",
          "publishedAt": "2024-09-17T03:43:07Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthere are some troubleshooting instructions here\nhttps://mooseframework.inl.gov/moose/application_usage/failed_solves.html\nand some advice on preconditioning for porous media / geomecha here\nhttps://mooseframework.inl.gov/modules/porous_flow/solvers.html",
                  "url": "https://github.com/idaholab/moose/discussions/28641#discussioncomment-10669576",
                  "updatedAt": "2024-09-17T11:32:32Z",
                  "publishedAt": "2024-09-17T11:32:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "issues in executing code for Dynamic Phase Field Fracture using Explicit Time Integration Scheme.",
          "author": {
            "login": "zuckarm"
          },
          "bodyText": "hi all,\ni am working on a dynamic fracture problem: a 2d notched plate is subjected to traction on its top and bottom edges. i am using the MultiApps system to separate the solid mechanics problem in the main app, and phase field problem in the sub app. i want to solve the problem using explicit time integration scheme.\ni am facing the following errors when i run the code:\nTime Step 0, time = 0\nCurrently Executing\n  Finished Performing Initial Setup                                                      [  7.32 s] [  460 MB]\n\nTime Step 0, time = 0\n\nTime Step 1, time = 5e-09, dt = 5e-09\nInitial fixed point residual norm: 0.000000e+00\n\nBeginning fixed point iteration 0\n\n\nMain app solve:\n\nPerforming automatic scaling calculation\n\nThe 1-th row of A is exactly zero\nThe 1-th row of A is exactly zero\nThe 1-th row of A is exactly zero\nThe 1-th row of A is exactly zero\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n Solve Did NOT Converge!\n  Finished Solving                                                                       [  9.26 s] [  813 MB]\nFixed point convergence reason: DIVERGED_NONLINEAR\nAborting as solve did not converge\n\n\ni have tried a number of edits to the code, but the initial fixed point residual norm is always reported as zero, whether i use an explicit or implicit scheme.\nwhile using an implicit scheme, the nonlinear residuals are zero at all timesteps, due to which the code progresses but it reports values of all variables: displacement, phase field as zero for all timesteps.\ncan anyone help me in resolving this issue?\nproblem data:\nupload.zip",
          "url": "https://github.com/idaholab/moose/discussions/28623",
          "updatedAt": "2024-09-17T11:30:46Z",
          "publishedAt": "2024-09-15T15:20:50Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nis this transfer in the right direction?\n\t\n\t[./to_psie_active]\n\t\ttype\t\t\t= MultiAppCopyTransfer\n\t\tfrom_multi_app \t= 'fracture'\n\t\tvariable\t\t= psie_active\n\t\tsource_variable = psie_active\n\t[../]\n\nshouldnt it be to_multi_app?\nYou should make sure both inputs are valid with aritifical data from the other input (setting the transferred auxiliary variables using initial conditions for example)",
                  "url": "https://github.com/idaholab/moose/discussions/28623#discussioncomment-10653154",
                  "updatedAt": "2024-09-15T17:20:56Z",
                  "publishedAt": "2024-09-15T17:20:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zuckarm"
                          },
                          "bodyText": "yes, it must be \"to_multi_app\". i made the changes, but i am still facing same error as before.\ni have changed preconditioning too, but i am still getting initial residual as zero.\nwhat could be the reason for initial residual to be zero?",
                          "url": "https://github.com/idaholab/moose/discussions/28623#discussioncomment-10660297",
                          "updatedAt": "2024-09-16T15:47:56Z",
                          "publishedAt": "2024-09-16T14:09:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zuckarm"
                          },
                          "bodyText": "i have made a few more changes, and now the code seems to work fine for implicit scheme. however, when i go for explicit scheme, i get the following error:\nInitial fixed point residual norm: inf\ni have tried reducing the timestep, but to no avail. can anyone please suggest any alternatives?",
                          "url": "https://github.com/idaholab/moose/discussions/28623#discussioncomment-10666301",
                          "updatedAt": "2024-09-17T05:05:03Z",
                          "publishedAt": "2024-09-17T05:05:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you have to go kernel by kernel (and BCs too) and check which one is returning the inf number\nThis interface, which kernels use, will let you save their contribution to the residual in an auxiliary variable\nhttps://mooseframework.inl.gov/source/interfaces/TaggingInterface.html",
                          "url": "https://github.com/idaholab/moose/discussions/28623#discussioncomment-10669565",
                          "updatedAt": "2024-09-17T11:30:46Z",
                          "publishedAt": "2024-09-17T11:30:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A question about the load balance in MOOSE",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nDear MOOSE Experts,\nI have a question regarding dynamic load balancing between processors, particularly when using Adaptive Mesh Refinement (AMR). From my understanding, the code tries to partition the domain to equally distribute finite element degrees of freedom across processors. Could someone elaborate on how this load balancing is achieved, and possibly provide references or documentation that further describe the process? I am interested to know the algorithm behind this.\nI\u2019ve attached an example from my simulation illustrating the load balancing behavior.\nThank you in advance for your help!\nBest regards,",
          "url": "https://github.com/idaholab/moose/discussions/28638",
          "updatedAt": "2024-09-16T23:44:24Z",
          "publishedAt": "2024-09-16T22:37:44Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe process first depends on your partitioner. Which one are you using?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28638#discussioncomment-10664664",
                  "updatedAt": "2024-09-16T22:45:44Z",
                  "publishedAt": "2024-09-16T22:45:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "I use the default partitioner which should be METIS.",
                          "url": "https://github.com/idaholab/moose/discussions/28638#discussioncomment-10664670",
                          "updatedAt": "2024-09-16T22:46:55Z",
                          "publishedAt": "2024-09-16T22:46:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "depends on whether you use distributed mesh\n      if (use_distributed_mesh)\n        partitioner = \"parmetis\";\n      else\n        partitioner = \"metis\";\n\nanyway once you have a partitioner, this partitions using a heuristic and more or less of an internal solve to get an optimal partition.\nThis is repeated on every re-partition. There is communication performed by libmesh (for the mesh), petsc (for the solution vectors) and moose (for stateful material properties)",
                          "url": "https://github.com/idaholab/moose/discussions/28638#discussioncomment-10664691",
                          "updatedAt": "2024-09-16T22:53:19Z",
                          "publishedAt": "2024-09-16T22:53:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "depends on whether you use distributed mesh\n      if (use_distributed_mesh)\n        partitioner = \"parmetis\";\n      else\n        partitioner = \"metis\";\n\nanyway once you have a partitioner, this partitions using a heuristic and more or less of an internal solve to get an optimal partition.\nThis is repeated on every re-partition. There is communication performed by libmesh (for the mesh), petsc (for the solution vectors) and moose (for stateful material properties)",
                          "url": "https://github.com/idaholab/moose/discussions/28638#discussioncomment-10664692",
                          "updatedAt": "2024-09-16T22:53:20Z",
                          "publishedAt": "2024-09-16T22:53:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Thanks. It seems like a complicated process that involve MOOSE, libmesh and petsc. I need to cite a paper for dynamic load balancing.  Can you think of any reference from MOOSE, libmesh or petsc that go through the details of the load balance?",
                          "url": "https://github.com/idaholab/moose/discussions/28638#discussioncomment-10664711",
                          "updatedAt": "2024-09-16T22:57:40Z",
                          "publishedAt": "2024-09-16T22:57:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you are focused on the load balance part, then it s the partitioners you want to cite. MOOSE/libmesh/petsc re-partition, but the \"balance\" is provided by the partitioner",
                          "url": "https://github.com/idaholab/moose/discussions/28638#discussioncomment-10664727",
                          "updatedAt": "2024-09-16T23:00:15Z",
                          "publishedAt": "2024-09-16T23:00:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Is there any part of the code I can look into to learn about this? \"this partitions using a heuristic and more or less of an internal solve to get an optimal partition.\"",
                          "url": "https://github.com/idaholab/moose/discussions/28638#discussioncomment-10664882",
                          "updatedAt": "2024-09-16T23:39:39Z",
                          "publishedAt": "2024-09-16T23:39:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you can open one of the partitioner source files, then use vscode \"go to reference\" to see how its routines are called",
                          "url": "https://github.com/idaholab/moose/discussions/28638#discussioncomment-10664907",
                          "updatedAt": "2024-09-16T23:44:24Z",
                          "publishedAt": "2024-09-16T23:44:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}