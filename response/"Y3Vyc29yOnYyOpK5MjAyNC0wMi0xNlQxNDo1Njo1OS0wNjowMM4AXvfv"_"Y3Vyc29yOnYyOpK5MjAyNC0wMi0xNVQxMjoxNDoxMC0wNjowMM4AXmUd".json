{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wMi0xNVQxMjoxNDoxMC0wNjowMM4AXmUd"
    },
    "edges": [
      {
        "node": {
          "title": "Model slanted grain growth with GBAnisotropy using an inclination angle",
          "author": {
            "login": "Hejie-Guo"
          },
          "bodyText": "Hello, moose community, i am a freshman in grain growth and moose modeling.\nI am trying to model slanted temperature-dependent grain growth behavior from experimental obervations and first following grain growth model in the work of \"Phase-field modeling of grain evolutions in additive manufacturing from nucleation, growth, to coarsening\" , the anisotropic grain growth behavior is similar as the following figures in the article:\n\nI simply modify some moose examples and modeling the temperature-dependent behavior, but did not quite understand how to model the anisotropic grain growth. Though i have test the examples in the dir ../GBAnisotropy/, I am still confused that how to model the slanted shape. Here is the result i can get using moose,  i just want to anisotropic modeling the shape as the black line.\n\nThe grain growth model in the article may be explicitly modeled by moose and do not need additional coding work.  It is saied that the anisotropic grain growth behavior by incorporating the anisotropic grain boundary energy:\n\nHowever, I did not find way to define the inclination angle in GBAnisotropy. Could anybody give some suggestions?",
          "url": "https://github.com/idaholab/moose/discussions/26500",
          "updatedAt": "2024-02-16T19:00:17Z",
          "publishedAt": "2024-01-08T03:50:02Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Hejie-Guo"
                  },
                  "bodyText": "could anybody help? can moose simulate the elongate grain growth or it did need some external coding work?",
                  "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8058594",
                  "updatedAt": "2024-01-09T00:56:45Z",
                  "publishedAt": "2024-01-09T00:56:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@laagesen",
                          "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8060605",
                          "updatedAt": "2024-01-09T05:04:31Z",
                          "publishedAt": "2024-01-09T05:04:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Hi there,\nHave a look at this example, as it shows how to include inclination dependence in a grain growth model:\nmoose/modules/phase_field/test/tests/GBAnisotropy/test3.i\nYou will probably also need to look at the paper which this model is based on, Phys. Rev. B, 78(2), 024113, 2008, by N. Moelans, as well as the source code for GBAnisotropy and GBAnisotropyBase.",
                  "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8067389",
                  "updatedAt": "2024-01-09T14:33:29Z",
                  "publishedAt": "2024-01-09T14:33:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Hejie-Guo"
                          },
                          "bodyText": "Hello, I have made some attempts, but i still need some help indeed.\n1\u3001I have tried to read the article and the source code GBAnisotropy and GBAnisotropyBase, but it is a bit difficult for me. Some equations in GBAnisotropyBase can not be found in the article and i am confused what it means.  For example, i did not find the definition in the following source code if the inclination is used and i am confused what phi_ave means and why it is equal to \"pi * n / (2.0 * _op_num)\".\n\n2\u3001I only found the following figure in the article can be related with the equation f_sigma=1+deltacos(4phi). It seems that the source code GBAnisotropy only define the weak inclination situation. If i want to simulate the elongate grain shape, I should change the equation f_sigma=(1+delta)^(-1)(1+delta*abs(cos(phi))) and let the delta to be 2?\n\n3\u3001I also tryied to simulate the test case \"moose/modules/phase_field/test/tests/GBAnisotropy/test3.i\". The grain shape is consistent with the figure in the article for delta_sigma=0.5 as following figure. But the simulation did not converge when delta_sigma is bigger e.g. delta_sigma=2.\n\n#Could anybody tell me more specific details and what should i do if i want simulate the elongate grain growth behaviour?",
                          "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8091233",
                          "updatedAt": "2024-01-11T08:01:50Z",
                          "publishedAt": "2024-01-11T07:52:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "You would want to use the value of epsilon prime that the authors of the paper used in Eq. (12) from the image you pasted.",
                          "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8101103",
                          "updatedAt": "2024-01-11T21:42:12Z",
                          "publishedAt": "2024-01-11T21:42:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Hejie-Guo"
                          },
                          "bodyText": "Sorry, the Eq.(12) is shown as following figure. I did not find the relationship between the source code and this Eq.(12). Could you please give some more details.",
                          "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8102636",
                          "updatedAt": "2024-01-12T00:39:36Z",
                          "publishedAt": "2024-01-12T00:39:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "I meant the Equation (12) from this image you posted",
                          "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8135742",
                          "updatedAt": "2024-01-15T17:42:00Z",
                          "publishedAt": "2024-01-15T17:41:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Hejie-Guo"
                          },
                          "bodyText": "Sorry, did you mean i should set the value of delta_sigma equal to epsilon prime ? but the equation seems to be different\uff0c one use the equation f_sigma=1+deltacons(4phi), another use the equation sigma=sigma0(1+epsilon_prime*(cos(phi)^4+sin(phi)^4))",
                          "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8138676",
                          "updatedAt": "2024-01-16T01:09:43Z",
                          "publishedAt": "2024-01-16T01:09:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "I think you can show analytically using trigonometric relations that these two angle-dependent forms are equal to each other. Or you can just plot the functions using a polar plot to see that they are the same.",
                          "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8150176",
                          "updatedAt": "2024-01-16T23:09:56Z",
                          "publishedAt": "2024-01-16T23:09:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Hejie-Guo"
                          },
                          "bodyText": "Did you mean cos(4phi) equal to (cos(phi))^4+(sin(phi))^4?\nThe cos(4phi) can be splitted into 2(cos(phi))^4+2(sin(phi))^4-4(cos(phi))^2*(sin(phi))^2-1\uff0c but it is not equal to  (cos(phi))^4+(sin(phi))^4.",
                          "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8151005",
                          "updatedAt": "2024-01-17T01:39:52Z",
                          "publishedAt": "2024-01-17T01:39:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Hejie-Guo"
                          },
                          "bodyText": "Another question is that  does this angle GBAnisotropyBase is the same with that angle in the reference? I did not understand the definition angle in GBAnisotropyBase that \"phi_ave=pin/(2_op_num)\" and then use some other equations. could the explantation of these equations  be found in any reference?",
                          "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8151161",
                          "updatedAt": "2024-01-17T02:04:58Z",
                          "publishedAt": "2024-01-17T02:04:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Hejie-Guo"
                          },
                          "bodyText": "I try to use the GBanisotropiy and change the f_delta\uff0cbut it seems that this parameter did not affect the results. Andthe result for the vorononi structure seem to be a homogenious state. Could anybody tell me how to model the elongate grain growth phenomenon..\nhere is my input file and result:\n[Mesh]\ntype = GeneratedMesh\ndim = 2 # Problem dimension\nnx = 12 # Number of elements in the x-direction\nny = 12 # Number of elements in the y-direction\nnz = 0 # Number of elements in the z-direction\nxmin = 0    # minimum x-coordinate of the mesh\nxmax = 1000 # maximum x-coordinate of the mesh\nymin = 0    # minimum y-coordinate of the mesh\nymax = 1000 # maximum y-coordinate of the mesh\nzmin = 0\nzmax = 0\nelem_type = QUAD4 # Type of elements used in the mesh\nuniform_refine = 3 # Initial uniform refinement of the mesh\nparallel_type = replicated # Periodic BCs\n[]\n[GlobalParams]\nop_num = 8 # Number of grains\nvar_name_base = gr # Base name of grains\n[]\n[UserObjects]\n[./voronoi]\ntype = PolycrystalVoronoi\ngrain_num = 50\nrand_seed = 100\ncoloring_algorithm = bt # We must use bt to force the UserObject to assign one grain to each op\n[../]\n[]\n[ICs]\n[./PolycrystalICs]\n[./PolycrystalColoringIC]\npolycrystal_ic_uo = voronoi\n[../]\n[../]\n[]\n[Variables]\n[./PolycrystalVariables]\n# Custom action that created all of the grain variables\norder = FIRST # element type used by each grain variable\nfamily = LAGRANGE\n[../]\n[]\n[AuxVariables]\n[./bnds]\norder = FIRST\nfamily = LAGRANGE\n[../]\n[unique_grains]\norder = CONSTANT\nfamily = MONOMIAL\n[]\n[var_indices]\norder = CONSTANT\nfamily = MONOMIAL\n[]\n[]\n[AuxKernels]\n[unique_grains]\ntype = FeatureFloodCountAux\nvariable = unique_grains\nflood_counter = grain_tracker\nfield_display = UNIQUE_REGION\nexecute_on = 'initial timestep_end'\n[]\n[var_indices]\ntype = FeatureFloodCountAux\nvariable = var_indices\nflood_counter = grain_tracker\nfield_display = VARIABLE_COLORING\nexecute_on = 'initial timestep_end'\n[]\n[]\n[Kernels]\n[./PolycrystalKernel]\n[../]\n[]\n[AuxKernels]\n[./bnds_aux]\ntype = BndsCalcAux\nvariable = bnds\nexecute_on = timestep_end\n[../]\n[]\n[BCs]\n[./Periodic]\n[./top_bottom]\nauto_direction = 'x y' # Makes problem periodic in the x and y directions\n[../]\n[../]\n[]\n[Materials]\n[CuGrGr]\ntype = GBAnisotropy\nAnisotropic_GB_file_name = anisotropy.txt\ninclination_anisotropy = true\ndelta_sigma = 0.05\ndelta_mob = 0.0\n# Quantitative material properties for copper grain growth.  Dimensions are nm and ns\n#GBmob0 = 8.5e-6 # Mobility prefactor for Cu from Schonfelder1997\n#GBenergy = 0.708 # GB energy for Cu from Schonfelder1997\n#Q = 0.53 # Activation energy for grain growth from Schonfelder 1997\nT = 1500 # Constant temperature of the simulation (for mobility calculation)\nwGB = 24 # Width of the diffuse GB\n[]\n[]\n[UserObjects]\n[grain_tracker]\ntype = GrainTracker\ntracking_step = 20 #Tracking is delayed until the polycrystalline structure is established\n[]\n[]\n[Postprocessors]\nactive = 'dt '\n[./dt]\n# Outputs the current time step\ntype = TimestepSize\n[../]\n[]\n[Executioner]\ntype = Transient # Type of executioner, here it is transient with an adaptive time step\nscheme = bdf2 # Type of time integration (2nd order backward euler), defaults to 1st order backward euler\n#Preconditioned JFNK (default)\nsolve_type = 'PJFNK'\npetsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart -mat_mffd_type'\npetsc_options_value = 'hypre    boomeramg      101                ds'\nl_max_its = 30 # Max number of linear iterations\nl_tol = 1e-4 # Relative tolerance for linear solves\nnl_max_its = 40 # Max number of nonlinear iterations\nnl_abs_tol = 1e-11 # Relative tolerance for nonlienar solves\nnl_rel_tol = 1e-8 # Absolute tolerance for nonlienar solves\nstart_time = 0.0\nend_time = 4000\n[./TimeStepper]\ntype = IterationAdaptiveDT\ndt = 10 # Initial time step.  In this simulation it changes.\noptimal_iterations = 6 #Time step will adapt to maintain this number of nonlinear iterations\n[../]\n[./Adaptivity]\ninitial_adaptivity = 2 # Number of times mesh is adapted to initial condition\nrefine_fraction = 0.7 # Fraction of high error that will be refined\ncoarsen_fraction = 0.1 # Fraction of low error that will coarsened\nmax_h_level = 4 # Max number of refinements used, starting from initial mesh (before uniform refinement)\n[../]\n[]\n[Outputs]\nexodus = true\ncsv = true\n[./console]\ntype = Console\nmax_rows = 20\n[../]\n[]\nthe anisotropic file:\n\">>>>>>>>> GB properties <<<<<<<<<\n---GB energy, mobility prefactor, activation energy---\n6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01\n6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01\n6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01\n6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01\n6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01\n6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01\n6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01\n6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01 6.000000e-01\n2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06\n2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06\n2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06\n2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06\n2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06\n2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06\n2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06\n2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06 2.500000e-06\n5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01\n5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01\n5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01\n5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01\n5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01\n5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01\n5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01\n5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01 5.300000e-01\n\"\n\nThe initial vorononi grain state:\n\nthe grain growth final state:",
                          "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8155861",
                          "updatedAt": "2024-01-17T11:58:47Z",
                          "publishedAt": "2024-01-17T11:58:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "yixishen"
                          },
                          "bodyText": "I believe can use GBAnisotropy function in MOOSE.  In the reference paper, inclination is coupled through grain boundary energy term, which is same as Moelans(2008). And I believe the GB orientation need to be calculated via the gradient of phase field variable. GBAnisotropy in MOOSE is based on Phys. Rev. B, 78(2), 024113, 2008, by N. Moelans, which is ref 33 in the reference paper you mentioned. The methods to calculate PF parameter from GB energy is same between your reference and Moelans work.",
                          "url": "https://github.com/idaholab/moose/discussions/26500#discussioncomment-8496161",
                          "updatedAt": "2024-02-16T19:47:27Z",
                          "publishedAt": "2024-02-16T19:00:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Production well in geothermal doublet",
          "author": {
            "login": "JustinPogacnik"
          },
          "bodyText": "Hi Team,\nI'm trying to create a geothermal doublet simulation. I'd like to control both the injection and production well by mass flow rate. The injection well seems to be going fine, but I'm having problems with the production well temperature increasing over time. I've seen some similar discussion and the solution was to use a Peaceman borehole description. I'm not sure how to do that and control the mass flow rate of the production well. It's quite easy to control that flowrate with a pointsource/sink term. But the problem is the temperature at the outflow node. I've tried a few different approaches using either polylinesink or pointsource in both falcon PTGeothermal and PorousFlow physics and seeing the same issue. So I'm pretty well convinced that I'm the problem. Can someone help me out here?\nPRODUCTION_VPO.txt",
          "url": "https://github.com/idaholab/moose/discussions/26802",
          "updatedAt": "2024-02-16T16:17:51Z",
          "publishedAt": "2024-02-13T15:56:56Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cpgr",
                  "url": "https://github.com/idaholab/moose/discussions/26802#discussioncomment-8494612",
                  "updatedAt": "2024-02-16T16:17:52Z",
                  "publishedAt": "2024-02-16T16:17:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Calculating flow through a boundary",
          "author": {
            "login": "nlosacco"
          },
          "bodyText": "For my problem I have to impose a time-varying porepressure at a boundary through a DirichletBC. This seems to be the best option for my case, compared to Neumann bc's like e.g. PorousFlowSink. Now I need the total flow through the boundary but I could not find a straightforward way to obtain it. When working with the simple Diffusion Kernel I could use a SideDiffusiveFluxIntegral but I have no idea if I can employ it with PorousFlow (e.g. how do I define the correct diffusivity given that the permeability might be anisotropic and changing with time?).\nMaybe I can calculate the flow by first using PorousFlowDarcyVelocityComponent, but again I have no clue on how to do that.",
          "url": "https://github.com/idaholab/moose/discussions/26745",
          "updatedAt": "2024-02-16T16:17:06Z",
          "publishedAt": "2024-02-05T19:49:53Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "how do I define the correct diffusivity given that the permeability might be anisotropic and changing with time?\n\nIn that kind of situation, I think the answer is to write your own version of SideDiffusiveFluxIntegral that has the right diffusivity\nThere is an advective flux postprocessor as well, but I am not sure it applies to porous flow.",
                  "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8376010",
                  "updatedAt": "2024-02-05T22:35:10Z",
                  "publishedAt": "2024-02-05T22:35:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "nlosacco"
                          },
                          "bodyText": "Wow, that's gonna be hard... I can hardly read the C++ code. I've even found an issue raised by @WilkAndy in 2018 and apparently not solved yet: #11376\nI do not think I am able to play with the code, maybe I can find some AuxKernels, Postprocessors, etc. that can come to aid",
                          "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8376340",
                          "updatedAt": "2024-02-05T23:31:08Z",
                          "publishedAt": "2024-02-05T23:31:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@cpgr any recommendation?\nmodifying the C++ is kind of expected when no one has done what you want before",
                          "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8376367",
                          "updatedAt": "2024-02-05T23:34:45Z",
                          "publishedAt": "2024-02-05T23:34:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "The correct thing to do is probably to make a post processor that does this, but in the mean time, you might be able to approximate it using a combination of SideIntegralVariablePostprocessor and a product of PorousFlowDarcyVelocityComponent AuxVariable and an AuxVariable for density (using PorousFlowPropertyAux)? Or maybe a SideAdvectiveFluxIntegral using a density AuxVariable and the velocity from PorousFlowDarcyVelocityComponent?",
                          "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8376722",
                          "updatedAt": "2024-02-06T00:37:21Z",
                          "publishedAt": "2024-02-06T00:36:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nlosacco"
                          },
                          "bodyText": "I've found this: https://mooseframework.inl.gov/source/postprocessors/BoundaryFluxPostprocessor.html\nthat seems to be helpful\nbut it seems not to work (the corresponding TestBoundaryFlux UserObject is not defined)",
                          "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8383775",
                          "updatedAt": "2024-02-06T14:57:18Z",
                          "publishedAt": "2024-02-06T14:57:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nNo that one is not helpful, it s an object for the RDG module that is coded very differently from porousFlow",
                          "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8385109",
                          "updatedAt": "2024-02-06T16:50:32Z",
                          "publishedAt": "2024-02-06T16:50:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nlosacco"
                          },
                          "bodyText": "I'm having a headache after spending one day trying to build my own postprocessor.\nI know it is cumbersome but I've done:\nget velocity components with PorousFlowDarcyVelocityComponent stored in AuxVariables with type = MONOMIAL\nget an elemental vector variable with a ParsedVectorAux stored as MONOMIAL_VEC\nuse the latter in my own implementation of SideDiffusiveFluxIntegral:\ntemplate <bool is_ad>\nReal\nSideDiffusiveFluxIntegralNTempl<is_ad>::computeQpIntegral()\n{\n  return _v * _normals[_qp];\n}\n\n_v is the elemental vector variable (type const VectorVariableValue) and _normals[_qp] is of type const libMesh::Point\nNow when building the application I get:\nerror: no match for 'operator*' (operand types are 'const VectorVariableValue' {aka 'const MooseArray<libMesh::VectorValue<double> >'} and 'const libMesh::Point')\n\nI understand the * operator is overloaded somewhere for types VariableGradient and Point, but I do not know where to look at due to my ignorance of C++. Can you give me a hint, please?",
                          "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8396849",
                          "updatedAt": "2024-02-07T15:54:40Z",
                          "publishedAt": "2024-02-07T15:54:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yeah i dont know why.\nJust do it manually for now\nreturn _v(0) * _normals[_qp](0) + _v(1) * _normals[_qp](1) + _v(2) * _normals[_qp](2);",
                          "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8397623",
                          "updatedAt": "2024-02-07T17:00:39Z",
                          "publishedAt": "2024-02-07T17:00:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nlosacco"
                          },
                          "bodyText": "ok, I found out by looking at libMesh documentation that I have to swap the operands:\nreturn _normals[_qp] * _v[_qp] compiles.\nBy the way, is it _v or _v[_qp] ?\nNow build fails with\nmain.x86_64-conda-linux-gnu.opt.lo' is not a valid libtool object\nyour suggestion yields:\nerror: no match for call to '(const VectorVariableValue {aka const MooseArray<libMesh::VectorValue<double> >}) (int)'\n   38 | return _v(0) * _normals[_qp](0) + _v(1) * _normals[_qp](1) + _v(2) * _normals[_qp](2);",
                          "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8397765",
                          "updatedAt": "2024-02-07T17:14:41Z",
                          "publishedAt": "2024-02-07T17:11:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "must be _v[0] then\nthat is unrelated I think you need to clean up your repo, make sure the right compilers are in use",
                          "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8397842",
                          "updatedAt": "2024-02-07T17:17:20Z",
                          "publishedAt": "2024-02-07T17:17:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "#include \"AdvectiveFluxAuxBE.h\"\n#include \"Assembly.h\"\n\nregisterMooseObject(\"moose_behApp\", AdvectiveFluxAuxBE);\n\nInputParameters\nAdvectiveFluxAuxBE::validParams()\n{\n  InputParameters params = AuxKernel::validParams();\n  MooseEnum component(\"x y z normal\");\n  params.addClassDescription(\"Compute components of flux vector for advection problems \"\n                             \"$(\\\\vec{J} = \\\\vec{v} \\\\cdot \\\\vec{n})$.\");\n  params.addCoupledVar(\"vx\", \"The x component of velocity\");\n  params.addCoupledVar(\"vy\", \"The y component of velocity\");\n  params.addCoupledVar(\"vz\", \"The z component of velocity\");\n  params.addParam<MooseEnum>(\"component\", component, \"The desired component of flux.\"); // Added this line\n  return params;\n}\n\nAdvectiveFluxAuxBE::AdvectiveFluxAuxBE(const InputParameters & parameters)\n  : AuxKernel(parameters),\n    _component(getParam<MooseEnum>(\"component\")),\n    _vx(coupledValue(\"vx\")),\n    _vy(coupledValue(\"vy\")),\n    _vz(coupledValue(\"vz\")),\n    _normals(_assembly.normals()),\n    _use_normal(getParam<MooseEnum>(\"component\") == \"normal\")\n{\n  if (_use_normal && !isParamValid(\"boundary\"))\n    paramError(\"boundary\", \"A boundary must be provided if using the normal component!\");\n}\n\nReal\nAdvectiveFluxAuxBE::computeValue()\n{\n  // RealVectorValue velocity(_v[_qp]);\n  return (_vx[_qp] * _normals[_qp](0)) + (_vy[_qp] * _normals[_qp](1)) + ((_vz[_qp]) * _normals[_qp](2)) ;\n}\n\nI've made this a while back, not sure if it's what you want, the vx vy vz are from PorousFlowDarcyVelocityComponent",
                  "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8437170",
                  "updatedAt": "2024-02-12T03:54:41Z",
                  "publishedAt": "2024-02-12T03:54:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "nlosacco"
                          },
                          "bodyText": "Hi @Traiwit , tanks so much for your reply.\nI deemed it somewhat more logical to use directly the Darcy velocity vector in the calculations\n\nget velocity components with PorousFlowDarcyVelocityComponent stored in AuxVariables with type = MONOMIAL\nget an elemental vector variable with a ParsedVectorAux stored as MONOMIAL_VEC\n\nplease find attached the files I used for my postprocessor (called SideDiffusiveFluxIntegralN which I should obviously change) I copied the SideDiffusiveFluxIntegral.C and base class files and got ride of the Finite Volume bit. Please find them attached.\nI've noted that a PorousFlowDarcyVelocityMaterial exists that computes said velocity vectors. Why is it only implemented at quadrature points at_nodes = false)? Is it possible to calculate the velocity at the nodes as for other PorousFlow materials?\nSideDiffusiveFluxIntegralN.C.txt\nSideDiffusiveFluxIntegralN.h.txt\nSideIntegralVariablePostprocessorN.C.txt\nSideIntegralVariablePostprocessorN.h.txt",
                          "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8456633",
                          "updatedAt": "2024-02-13T17:15:42Z",
                          "publishedAt": "2024-02-13T17:15:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Velocity is computed with\n    _darcy_velocity[_qp][ph] =\n        -(_permeability[_qp] * (_grad_p[_qp][ph] - _fluid_density[_qp][ph] * _gravity) *\n          _relative_permeability[_qp][ph] / _fluid_viscosity[_qp][ph]);\n\nthe problem is the gradient of pressure here. If pressure is a lagrange variable, its gradient is not continuous on nodes. You can do some type of gradient averaging / reconstruction but it might not help for getting conservation",
                          "url": "https://github.com/idaholab/moose/discussions/26745#discussioncomment-8494602",
                          "updatedAt": "2024-02-16T16:17:07Z",
                          "publishedAt": "2024-02-16T16:17:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Want to run the code in debuging mode by puting breakpoints",
          "author": {
            "login": "abdullah2146"
          },
          "bodyText": "Hi,\nI want to know is there any way that I can put a breakpoint at any code line and it will stop at that point to see the values.\nI'm also trying to use another way of std::cout<<var_name<<std::endl; , but the problem is I need to compile the code again and it takes time. So is there any other way to skip that time?",
          "url": "https://github.com/idaholab/moose/discussions/21337",
          "updatedAt": "2024-02-16T15:25:14Z",
          "publishedAt": "2022-06-17T16:00:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes you definitely can do.\nSee the manual for gdb\nhttps://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_27.html\nWe are also building up documentation for working with visual studio and use the connection to the debugger there. It's not ready yet\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21337#discussioncomment-2972898",
                  "updatedAt": "2022-06-17T16:05:31Z",
                  "publishedAt": "2022-06-17T16:05:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Hello\nYes you definitely can do. See the manual for gdb https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_27.html\nWe are also building up documentation for working with visual studio and use the connection to the debugger there. It's not ready yet\nGuillaume\n\nHi @GiudGiud\nHave you had any documentation for the vs code?",
                          "url": "https://github.com/idaholab/moose/discussions/21337#discussioncomment-5819424",
                          "updatedAt": "2023-05-05T19:42:38Z",
                          "publishedAt": "2023-05-05T19:42:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Best documentation is there\nhttps://mooseframework.inl.gov/help/development/VSCode.html\nStill nothing on debugging within VScode though.",
                          "url": "https://github.com/idaholab/moose/discussions/21337#discussioncomment-5820904",
                          "updatedAt": "2023-05-05T21:16:26Z",
                          "publishedAt": "2023-05-05T21:16:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adhithya96"
                          },
                          "bodyText": "Any updates on this ? It's hard to navigate through the moose code to understand the workflow. Setting some breakpoints in an IDE will be a lifesaver.",
                          "url": "https://github.com/idaholab/moose/discussions/21337#discussioncomment-8488497",
                          "updatedAt": "2024-02-16T05:43:44Z",
                          "publishedAt": "2024-02-16T05:43:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@dschwen do you know anyone who could write this down",
                          "url": "https://github.com/idaholab/moose/discussions/21337#discussioncomment-8494010",
                          "updatedAt": "2024-02-16T15:25:15Z",
                          "publishedAt": "2024-02-16T15:25:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "What is the principle of Quadrature sampler for Polynomial Chaos",
          "author": {
            "login": "Ating24"
          },
          "bodyText": "Are there any papers or literature that provide a detailed introduction to this method\uff1f",
          "url": "https://github.com/idaholab/moose/discussions/26825",
          "updatedAt": "2024-03-01T14:51:39Z",
          "publishedAt": "2024-02-16T07:56:15Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@somu15",
                  "url": "https://github.com/idaholab/moose/discussions/26825#discussioncomment-8492355",
                  "updatedAt": "2024-02-16T13:11:09Z",
                  "publishedAt": "2024-02-16T13:11:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "somu15"
                  },
                  "bodyText": "Polynomial chaos requires evaluating integral numerically which can become very expensive when the number of input parameters increases. So, quadrature sampler in STM enables both regular and sparse grid approaches to perform this integration, more efficiently using sparse grids. See this Sandia presentation which looked informative to me: https://www.osti.gov/servlets/purl/1237887. Also, here is our quadrature sampler documentation: https://mooseframework.inl.gov/source/samplers/QuadratureSampler.html.",
                  "url": "https://github.com/idaholab/moose/discussions/26825#discussioncomment-8493881",
                  "updatedAt": "2024-02-16T15:12:29Z",
                  "publishedAt": "2024-02-16T15:12:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Writing to and reading from scalar aux variable",
          "author": {
            "login": "Flolaffel"
          },
          "bodyText": "Hello,\nI'm calculating a scalar value that is constant over my whole domain that I'd like to store in an scalar aux variable\n[scalar]\n  family = SCALAR\n  order = FIRST\n[]\n\nWrite\nHeader-File\nMooseVariableScalar * _scalar_var;\nConstructor\n_scalar_var(&_subproblem.getScalarVariable(_tid, \"var_name\")\nMethod\n_scalar_var->setValues(value);\nRead\nHeader-File\nMooseVariableScalar * _scalar_var;\nConstructor\n_scalar_var(&_subproblem.getScalarVariable(_tid, \"var_name\")\nMethod\nReal value = _scalar_var->sln()[0]\nThis code is working fine. My problem lies in the MOOSE Output which isn't updated throughout the simulation and stays 0, even though I can pass my scalar value using the scalar aux variable between classes. So my question is: How can I write the value from my solution vector to wherever MOOSE reads the output values from?",
          "url": "https://github.com/idaholab/moose/discussions/26806",
          "updatedAt": "2024-02-16T13:05:11Z",
          "publishedAt": "2024-02-14T09:41:27Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you using a Scalar Auxkernel to set this variable? This would be the cannon way instead of setting it directly.\nThis would also let you look at the timing of execution between output and ths scalar auxkernel\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26806#discussioncomment-8467320",
                  "updatedAt": "2024-02-14T15:24:01Z",
                  "publishedAt": "2024-02-14T15:24:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "I'm using a UserObject to set the variable. And for clarity reasons, I'd like to keep it in a UserObject, if that's possible.",
                          "url": "https://github.com/idaholab/moose/discussions/26806#discussioncomment-8476272",
                          "updatedAt": "2024-02-15T08:05:16Z",
                          "publishedAt": "2024-02-15T08:05:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Which output is giving you the wrong value? The console output?\nWhen are you executing these operations? What execute_on flag is passed to the user object?",
                          "url": "https://github.com/idaholab/moose/discussions/26806#discussioncomment-8478579",
                          "updatedAt": "2024-02-15T11:34:31Z",
                          "publishedAt": "2024-02-15T11:34:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Also is a first order scalar variable one or two DoFs? I don't recall\nAnd how many do you need?",
                          "url": "https://github.com/idaholab/moose/discussions/26806#discussioncomment-8478598",
                          "updatedAt": "2024-02-15T11:36:34Z",
                          "publishedAt": "2024-02-15T11:36:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "The console output?\n\nYes, the console output doesn't match the values the objects are passing to each other.\n\nWhat execute_on flag is passed to the user object?\n\nThe UserObjects are executed at TIMESTEP_END and post_aux.\n\nAlso is a first order scalar variable one or two DoFs?\n\nFirst order\n\nAnd how many do you need?\n\nHow many scalar aux variables? Number varies based on simulation but will (for now) be 2 max.",
                          "url": "https://github.com/idaholab/moose/discussions/26806#discussioncomment-8478680",
                          "updatedAt": "2024-02-15T11:46:25Z",
                          "publishedAt": "2024-02-15T11:46:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you use Debug/show_execution_order=ALWAYS to make sure the UOs are executed before the console prints?\nIf it s not an ordering issue, then the 'problem' happens in TableOutput::outputScalarVariable\nwhere the scalar variable is reinited to be obtained  well-updated from the solution vector\nI think what you are missing is a call to insert the value in the solution vector after setting the value.\nMooseVariableScalar::insert(NumericVector<Number> & soln)\n\niirc you can get the solution vector from the nonlinear system which you can get from the problem",
                          "url": "https://github.com/idaholab/moose/discussions/26806#discussioncomment-8487548",
                          "updatedAt": "2024-02-16T02:42:51Z",
                          "publishedAt": "2024-02-16T02:42:50Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "That was it, thanks! I added the following lines to insert the value into the solution vector:\n_scalar_var->insert(_scalar_var->sys().solution());\n_scalar_var->sys().solution().close();\n\nHowever I don't quite understand what exactly is happening here yet. Could please reiterate what is the difference between setValues() and insert()? I thought setValues() already sets the values of the solution vector?",
                          "url": "https://github.com/idaholab/moose/discussions/26806#discussioncomment-8489650",
                          "updatedAt": "2024-02-16T08:41:28Z",
                          "publishedAt": "2024-02-16T08:41:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think the call to close here at least is important to synchronize the solution vector.\nThe explanation for both routines should be in the doxygen for moose",
                          "url": "https://github.com/idaholab/moose/discussions/26806#discussioncomment-8492296",
                          "updatedAt": "2024-02-16T13:05:12Z",
                          "publishedAt": "2024-02-16T13:05:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to Initialize an Empty Subdomain Block",
          "author": {
            "login": "czadeh"
          },
          "bodyText": "Hi,\nI just posted the other day but I have a different question.\nIn a heat conduction app I am developing, I am trying to track the interface of a melt pool.\nTo achieve this I tried to divide the domain into solid and liquid domains.\nI used SubdomainBoundingBoxGenerator to bound the entire domain and set it to block 1 to represent the solid phase.\nI plan to use block 2 to represent the liquid domain, but I do not initialize it in the [Mesh] section of the input file because there is no liquid domain initially.\nI set up a system with CoupledVarThresholdElementSubdomainModifier to set the subdomain to block 2 if conditions are met to make it liquid.\nBut I run into the error\n\nthe following blocks (ids) do not exist on the mesh: 2\n\nor\n\nRequested subdomain 2 does not exist\n\nMy input file only works if subdomain 2 has been declared already, however in my problem liquid does not exist initially.\nHow do I initialize subdomain 2 as an empty set and then add to it later?\nAlternatively, is this the right way to approach this problem with a moving interface or do you recommend another method?\nThanks,\nCameron",
          "url": "https://github.com/idaholab/moose/discussions/19084",
          "updatedAt": "2024-02-16T03:09:51Z",
          "publishedAt": "2021-10-13T00:51:52Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dewenyushu @hugary1995 @ngrilli @jiangwen84 @dschwen\ndid you come across this / think about this when working on element deletion? I know it s sort of the opposite problem",
                  "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-1478209",
                  "updatedAt": "2022-07-18T19:50:13Z",
                  "publishedAt": "2021-10-14T16:33:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Yes I had similar issues before. I tried to have empty subdomain work but did not end up getting it work well. My work around was to create a small enough subdomain 2 initially (containing only a few elements) instead of leaving it totally empty.\nI remember @hugary1995 also met the similar issue and he might have a better solution.",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-1478307",
                          "updatedAt": "2022-07-18T19:50:13Z",
                          "publishedAt": "2021-10-14T16:52:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "My work around was to create a small enough subdomain 2 initially (containing only a few elements) instead of leaving it totally empty.\n\n@dewenyushu How did you create that small subdomain? Did you use SubdomainBoundingBoxGenerator to place a smaller box within the bigger box? Or do you somehow have to \"cut out\" that smaller box from the bigger box?",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-1478419",
                          "updatedAt": "2022-07-18T19:50:13Z",
                          "publishedAt": "2021-10-14T17:18:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Could you just place this box completely outside of the mesh you care about, then delete it in the first timestep with adaptivity?",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-1478454",
                          "updatedAt": "2022-07-18T19:50:18Z",
                          "publishedAt": "2021-10-14T17:25:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "I can try that, but what do you mean by delete with adaptivity?",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-1478501",
                          "updatedAt": "2022-10-27T21:09:39Z",
                          "publishedAt": "2021-10-14T17:34:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "See adaptivity\nhttps://mooseframework.inl.gov/syntax/Adaptivity/index.html\ndeleting elements is done in some mesh generators. Should be fairly easy to add it to adaptivity if it s not already there",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-1478583",
                          "updatedAt": "2022-10-27T21:09:39Z",
                          "publishedAt": "2021-10-14T17:53:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "My work around was to create a small enough subdomain 2 initially (containing only a few elements) instead of leaving it totally empty.\n\n@dewenyushu How did you create that small subdomain? Did you use SubdomainBoundingBoxGenerator to place a smaller box within the bigger box? Or do you somehow have to \"cut out\" that smaller box from the bigger box?\n\nYes, I used the SubdomainBoundingBoxGenerator to create a smaller box. I did not cut it out from the bigger box.",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-1478609",
                          "updatedAt": "2022-10-27T21:09:39Z",
                          "publishedAt": "2021-10-14T17:58:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I asked about it but @loganharbour shut me down. Logan, do you think supporting dummy subdomain names that initially contain zero elements in the map is possible in MOOSE? This is also helpful for #19074 .\nOn the other side, I believe exodus already supports empty blocks. So I think we can get it to work as long as MOOSE can support it. For example, we can provide a mesh generator that creates empty subdomains.",
                  "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-1480672",
                  "updatedAt": "2022-07-18T19:50:17Z",
                  "publishedAt": "2021-10-15T04:20:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "I don't think this is an awful idea - but we will have to ping @roystgnr.\nThe issue is that the concept of available subdomains comes from looping through elements and collecting the set of the subdomains set on elements. There are quite a few ways go to about this... but it will require changing things at a very fundamental level in libmesh.",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-1480705",
                          "updatedAt": "2022-07-18T19:50:24Z",
                          "publishedAt": "2021-10-15T04:32:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Well, in libMesh we already do have two distinct concepts here: MeshBase::get_mesh_subdomains() tries to return the set of subdomain ids that currently exist in the mesh, and there's no way to change that without breaking the API for people, but MeshBase::get_subdomain_name_map() returns all subdomain ids that have been given names, and there's no requirement for any correspondence between the two; you can add an additional id->name entry whether that id yet exists in the mesh or not.\nI'm totally unsure about whether we correctly read or write empty blocks to Exodus, though.  We certainly don't have any unit tests checking it though, and it's not the sort of thing we'd have been likely to get right on accident.",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-1484806",
                          "updatedAt": "2022-07-18T19:50:24Z",
                          "publishedAt": "2021-10-15T20:15:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear @hugary1995, @loganharbour and @roystgnr,\nPlease excuse me for resurrecting this old (resolved) discussion. In the meantime, is there a way to allow empty subdomains?\nI'm trying to build a model that consists of a number of blocks that should be switched off and on individually. The CoupledVarThresholdElementSubdomainModifier is to be used for this. Without \"empty blocks\" I have several problems:\n\nThe (initially empty) block for the inactive domain must have a few dummy elements as described above.\nIf I use CoupledVarThresholdElementSubdomainModifier to make a whole block inactive, it is currently deleted by Moose (and Moose complains that the blocks are no longer numbered consecutively).\n\nThe availability of \"empty blocks\" would be a great help.\nKind regards,\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-8462743",
                          "updatedAt": "2024-02-14T08:29:40Z",
                          "publishedAt": "2024-02-14T08:29:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nyes there is. It s in the Mesh block, you can declare future subdomains that are not in use yet\nThe add_subdomain_ids parameter\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-8467625",
                          "updatedAt": "2024-02-14T15:48:14Z",
                          "publishedAt": "2024-02-14T15:48:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear @GiudGiud,\nThank you very much for your answer. This option looks great. Is there an similar option to prevent Moose to delete subdomains after becomming empty (e.g. after moving all elements to another block via CoupledVarThresholdElementSubdomainModifier)?\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-8468914",
                          "updatedAt": "2024-02-14T17:04:37Z",
                          "publishedAt": "2024-02-14T17:04:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It s a good question. Did you try using this same Boolean for that purpose?",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-8474783",
                          "updatedAt": "2024-02-15T04:08:00Z",
                          "publishedAt": "2024-02-15T04:07:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "That doesn't seem to work. Please see below.\nIn the code below I load the subdomains 1 to 7 from a MSH file. Furthermore, I ask Moose for a subdomain 8 - and I have also added the subdomains 1 to 7 again in add_subdomain_ids, because I do not want Moose to delete them after I have moved all elements with CoupledVarThresholdElementSubdomainModifier to subdomain 8. Moose accepts this code, creates subdomain 8, but deletes subdomains 1 to 7 later anyway.\n[Mesh]\n\n  [File]\n    type = FileMeshGenerator\n    file = \"stages.msh\"   # This gives subdomains 1 to 7\n    show_info = true\n  []\n\n  add_subdomain_ids = '1 2 3 4 5 6 7 8'   # I dont want 1 to 7 getting deleted later on - and I need subdomain 8\n\n[]\n\nThe specific error message I get is:\nTime Step 0, time = 0\n\nTime Step 1, time = 0.2, dt = 0.2\n\n*** ERROR ***\n/home/user/projects/moose_bare_tmech/models/stages.i:95: (UserObjects/BlockActivation_StatesCSV/nblock):\n    Element block id 8 greater than than total number of blocks in mesh: 7. Blocks should be numbered consecutively.",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-8475222",
                          "updatedAt": "2024-02-15T06:58:23Z",
                          "publishedAt": "2024-02-15T05:39:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is not from the mesh losing a subdomain.\nThis is from the PropertyReadFIle user object which does not update the number of subdomains in the mesh.\nThe solution here is to implement a meshChanged() routine to this UO and make it update the number of subdomains.\nOR\nquery the number of subdomains dynamically instead of setting it at the construction of the UO",
                          "url": "https://github.com/idaholab/moose/discussions/19084#discussioncomment-8487672",
                          "updatedAt": "2024-02-16T03:09:52Z",
                          "publishedAt": "2024-02-16T03:09:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "An inquiry about generate a quasi-3D bicrystal RVE in MOOSSE",
          "author": {
            "login": "NINGYURICHARD"
          },
          "bodyText": "Hi,\nI am trying to generate a quasi-3D bicrystal RVE (i.e. one element in the transverse direction) in MOOSE. The attached figure\n\nis the example I want to generate for compression or tension simulation. I am a beginner of MOOSE, could you please tell me whether MOOSE can generate such bicrystal RVE? Thank you very much!\nBest Regards,\nRichard",
          "url": "https://github.com/idaholab/moose/discussions/26821",
          "updatedAt": "2024-02-16T03:03:34Z",
          "publishedAt": "2024-02-16T02:36:12Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can make the 2D system in moose either with a fitted circular mesh or from a cartesian regular mesh and a bicrystal initial condition.\nThere should be a tutorial in the phase field module to do this\nhttps://mooseframework.inl.gov/modules/phase_field/index.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26821#discussioncomment-8487632",
                  "updatedAt": "2024-02-16T03:03:34Z",
                  "publishedAt": "2024-02-16T03:03:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Boundary Condition not being obeyed",
          "author": {
            "login": "gj19866"
          },
          "bodyText": "Hi there,\nI have 2 variables, and I want to apply Neumann BCs to them.\nI want that $\\nabla \\varphi \\cdot \\hat{n} = 0$, and that $\\nabla \\psi \\cdot \\hat{n} = j$, where j is a constant.\nWhen I try to implement this I get that $\\nabla \\psi \\cdot \\hat{n} = j$ is obeyed, however $\\nabla \\varphi \\cdot \\hat{n} = 0$ is not obeyed.\nWhen I use a DirichletBC $\\varphi = 0$ the solution looks how I expect it to (0 everywhere). This also then has $\\nabla \\varphi \\cdot \\hat{n} = 0$.\nIs there a reason you can think of why my $\\nabla \\varphi \\cdot \\hat{n} = 0$  boundary is not being obeyed properly? Below is an image of what I'm seeing.\n\nAll the best,\nGillian",
          "url": "https://github.com/idaholab/moose/discussions/26812",
          "updatedAt": "2024-02-16T01:57:41Z",
          "publishedAt": "2024-02-14T17:07:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "schakrabortygithub"
                  },
                  "bodyText": "If it is a transient problem, you might be missing initial condition. Can you try by specifying non-zero initial_condition e.g. 'Constant_IC', and zero or finite_value Neumann BC.\n`",
                  "url": "https://github.com/idaholab/moose/discussions/26812#discussioncomment-8482044",
                  "updatedAt": "2024-02-15T16:05:32Z",
                  "publishedAt": "2024-02-15T16:05:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Which boundary did you apply a zero current boundary condition? both?\nDid you specify a Neumann BC or did you just specify no boundary conditions on that boundary?",
                  "url": "https://github.com/idaholab/moose/discussions/26812#discussioncomment-8487336",
                  "updatedAt": "2024-02-16T01:57:41Z",
                  "publishedAt": "2024-02-16T01:57:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Adding a field in the MOOSE output exodus file using Python",
          "author": {
            "login": "chakra34"
          },
          "bodyText": "Hi,\nI was wondering if anyone have some suggestion in using Python to read the exodus output of MOOSE and then add extra fields for visualization in ParaView. For example I have stress values that are output for each grid point in ParaView and I want to scale them with different values based on some temperature dependent function.\nSo my objective is to\nread the moouse_out.exo\nget stress components\nget temperature\nadd field = sigma_xx/(A*temperature +B)\nwrite into exodus output\nAny help would be great!!\nthanks,\nAritra",
          "url": "https://github.com/idaholab/moose/discussions/26752",
          "updatedAt": "2024-02-15T18:14:12Z",
          "publishedAt": "2024-02-06T12:32:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can work in Python with the VTK libraries to do all this. MOOSE can output to vtk\nBut it would be much easier to do this in a small input in MOOSE that just does not solve. Add this line to avoid solving\n[Problem]\n  solve = false\n[]\n\nand add an auxkernel (maybe a ParsedAux?) to compute the new field. You may need an auxkernel to get sigma_xx into an auxiliary variable first\n\nget stress components\n\nthat can come from auxkernels or from automated material property output (using the Material or the TensorMechanics Master parameters) in your simulation\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26752#discussioncomment-8385182",
                  "updatedAt": "2024-02-06T16:55:14Z",
                  "publishedAt": "2024-02-06T16:55:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Thanks a lot :)",
                          "url": "https://github.com/idaholab/moose/discussions/26752#discussioncomment-8386116",
                          "updatedAt": "2024-02-06T18:07:52Z",
                          "publishedAt": "2024-02-06T18:07:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "@GiudGiud a quick follow up\nSo in my case, I simulate a linear elastic problem under a temperature field. I have the stresses in aux variable, and I supply the scaling function too (as xy-data; x-being temperature; y-being scaling factor)\nNow, I want to add an auxvariable that would do the following: stress_xx/stress_scaling_func(temp) (essentially scaling the stress at the location with the scale factor that is a function of the temperature at that location.\nIs the above possible via auxkernels and auxvariables?\nI am attaching a simple moose_input file where I have put the \"stress_scaling_func\"\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 20\n  ny = 20\n  nz = 20\n  xmin = 0.0\n  xmax = 1.0\n  ymin = 0.0\n  ymax = 1.0\n  zmin = 0.0\n  zmax = 1.0\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n\n[Functions]\n  [./topfunc]\n    type = ParsedFunction\n    value = '1e-4*t' # ramped displacement BC\n  [../]\n\n  [./temp_function]\n    type  = ParsedFunction\n    value = '200.0*(z+0)'\n  [../]\n\n  **'comment:  x data is temperature ; y data is scaling_factor'**\n\n  [./stress_scaling_func]\n    type = PiecewiseLinear\n    xy_data = '25\t130.70\n               500 1000.0'\n    scale_factor = 1.0\n  [../]\n     \n[]\n\n[BCs]\n\n  [./bot_fix_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0\n  [../]\n\n  [./top_disp_y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = 'top'\n    function = topfunc\n  [../]\n\n  [./left_fix_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left'\n    value = 0\n  [../]\n\n  [./front_fix_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'front'\n    value = 0\n  [../]\n\n[]\n\n[Modules/TensorMechanics/Master/All]\n  strain = FINITE\n  incremental = true\n  add_variables = true\n  temperature = temp\n  eigenstrain_names = eigenstrain  \n  generate_output = 'stress_xy stress_yz stress_zx'\n  use_automatic_differentiation = false\n[]\n[Materials]\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 150e9\n    poissons_ratio = 0.3\n  []\n\n  [./stress]\n    type = ComputeFiniteStrainElasticStress\n  [../]\n\n  [./thermal_expansion_strain]\n    type = ComputeThermalExpansionEigenstrain\n    thermal_expansion_coeff = 1.0e-4\n    stress_free_temperature = 100.0\n    temperature = temp\n    eigenstrain_name = eigenstrain\n  [../]\n\n[]\n\n\n[AuxVariables]\n  [temp]\n    order  = FIRST\n    family = LAGRANGE\n  []\n  [./von_mises_stress]\n\t#Dependent variable used to visualize the Von Mises stress\n    order = SECOND\n    family = MONOMIAL\n  [../]\n\n  [./stress_yy]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n  [./stress_xx]\n    order = SECOND\n    family = MONOMIAL\n  [../]\n\n[]\n\n[AuxKernels]\n  [set_temp]\n     variable = temp\n     type = FunctionAux\n     function = temp_function\n  []\n\n  [./stress_yy]\n    type = RankTwoAux\n    rank_two_tensor = stress\n    variable = stress_yy\n    index_i = 1\n    index_j = 1\n    execute_on = 'initial timestep_end'\n  [../]\n  [./stress_xx]\n    type = RankTwoAux\n    rank_two_tensor = stress\n    variable = stress_xx\n    index_i = 0\n    index_j = 0\n    execute_on = 'initial timestep_end'\n  [../]\n  \n[]\n\n\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = 'Newton'\n\n  start_time = 0.0\n  dt    = 0.1\n  dtmax = 1.0\n  dtmin = 1e-31\n  nl_abs_tol = 1e-6\n  end_time = 1\n []\n\n[Outputs]\n  print_linear_residuals = true\n  perf_graph = true\n  csv = true\n  [./out]\n    type = Exodus\n    elemental_as_nodal = true\n  [../]\n  [./console]\n    type = Console\n    max_rows = 100\n  [../]\n[]\n\n\nThanks,\nAritra",
                          "url": "https://github.com/idaholab/moose/discussions/26752#discussioncomment-8408505",
                          "updatedAt": "2024-02-08T16:32:19Z",
                          "publishedAt": "2024-02-08T14:48:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nyou mention an auxiliary variable for this. Is this for output? Or will it be used in the simulation?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/26752#discussioncomment-8409680",
                          "updatedAt": "2024-02-08T16:32:42Z",
                          "publishedAt": "2024-02-08T16:32:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "this is only output [ basically an extra output field of scaled value of stress_xx by the function which is a function of temperature at the element.]\nThanks again,\nAritra",
                          "url": "https://github.com/idaholab/moose/discussions/26752#discussioncomment-8410241",
                          "updatedAt": "2024-02-08T17:19:48Z",
                          "publishedAt": "2024-02-08T17:19:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So yes an auxvariable would do great.\nYou already have stress_xx in an auxvariable\nand stress_scaling_func in a function\nso now use a ParsedAux to do the division of one by the other",
                          "url": "https://github.com/idaholab/moose/discussions/26752#discussioncomment-8410312",
                          "updatedAt": "2024-02-08T17:25:32Z",
                          "publishedAt": "2024-02-08T17:25:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "this is giving error\n\"\"\"\n[scaling_stress]\ntype = ParsedAux\nvariable = scaled_stress_xx\ncoupled_variables = 'stress_xx stress_scaling_func '\nfunction = 'stress_xx/stress_scaling_func'\n[]\n\"\"\"\n*** ERROR ***\nThe following error occurred in the object \"scaling_stress\", of type \"ParsedAux\".\nInvalid function\nstress_xx\nin ParsedAux scaling_stress.\nSyntax error: Unknown identifier\n\"\"\"\nI tried the following and it still gave me Unknown identifier error:\n\"\"\"\n[shear_stress_var]\norder = CONSTANT\nfamily = MONOMIAL\n[]\n\"\"\"\n\"\"\"\n[shear_stress]\ntype = ParsedAux\nvariable = shear_stress_var\ncoupled_variables = 'stress_yz stress_xz'\nfunction = 'sqrt(stress_yz^2 + stress_zx^2)'\n[]\n\"\"\"\nthe example in ParsedAux documentation.\nIs there I am missing ?\nAritra",
                          "url": "https://github.com/idaholab/moose/discussions/26752#discussioncomment-8412131",
                          "updatedAt": "2024-02-08T20:37:57Z",
                          "publishedAt": "2024-02-08T20:37:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is stress_xx in the input file still as an auxiliary variable?",
                          "url": "https://github.com/idaholab/moose/discussions/26752#discussioncomment-8412180",
                          "updatedAt": "2024-02-08T20:42:46Z",
                          "publishedAt": "2024-02-08T20:42:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "@GiudGiud I figured out the error, I am using an older version where instead of \"coupled_variables\" the tag is \"args\". Apologies for that.\nBut I have the following question-- so I have the scaling function:\n  [./stress_scaling_func]\n    type = PiecewiseLinear\n    xy_data = '25\t130.70\n               500 1000.0'\n    scale_factor = 1.0\n  [../]\n\nwhere the x is temperature and y is data. I made an auxvariable out of it by:\n  [set_mor_a]\n    variable = temp_mor_a\n    type = FunctionAux\n    function = stress_scaling_func\n []\n\nAnd then I do the following parsedAux\n  [shear_stress]\n      type = ParsedAux\n      variable = shear_stress_var\n      args = 'stress_xx temp_mor_a'\n      function = 'stress_xx/temp_mor_a'\n    []\n\nThe code runs, but my question is how/where does the code know to use the temperature to get the temp_mor_a value which corresponds to the element location where the stress_xx is also evaluated ?\n[As in in the above function the temp_mor_a would be stress_xx(x,y,z)/temp_mor_a(temperature(x,y,z)) where (x,y,z) are the local coordinates/location.]\nBest,\nAritra",
                          "url": "https://github.com/idaholab/moose/discussions/26752#discussioncomment-8412997",
                          "updatedAt": "2024-02-08T22:21:38Z",
                          "publishedAt": "2024-02-08T22:21:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the temperature to get the temp_mor_a value which corresponds to the element location where the stress_xx is also evaluated ?\n\nSo the expression will be evaluated on quadrature points for. both the variable and the function, then using this a projection is made onto the target auxiliary variable.",
                          "url": "https://github.com/idaholab/moose/discussions/26752#discussioncomment-8413436",
                          "updatedAt": "2024-02-08T23:34:28Z",
                          "publishedAt": "2024-02-08T23:34:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "okay, thanks, sorry a quick follow up:  so while evaluating temp_mor_a on quadrature point how will it decide what to use as the input for the function.\nSo let's say at the quadrature point my temperature is 500 C and displacement is 0.5, so how do we make sure when we evaluate the temp_mor_a which is a function using the temperature it uses the temperature values (500 C) and not other variables (e.g. displacement and 0.5) ?\nIn my case temperature is also an AuxVariable coming from the function:\n  [./temp_function]\n    type  = ParsedFunction\n    value = '200.0*(z+0)'\n  [../]\n\n\nand the AuxVariable and AuxKernel being:\n  [temp]\n    order  = FIRST\n    family = LAGRANGE\n  []\n\n  [set_temp]\n     variable = temp\n     type = FunctionAux\n     function = temp_function\n  []\n\nI am really sorry if these questions are too trivial :( , the reason I am wondering is because in no place for the stress_scaling_func or the ParsedAux did we input the information of the temperature (AuxVariable) temp.\nAgain, really appreciate the help @GiudGiud\nAritra",
                          "url": "https://github.com/idaholab/moose/discussions/26752#discussioncomment-8413610",
                          "updatedAt": "2024-02-09T00:14:56Z",
                          "publishedAt": "2024-02-09T00:13:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}