{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wOC0wOFQyMzo1NTozNy0wNTowMM4ANXwW"
    },
    "edges": [
      {
        "node": {
          "title": "StochasticTools: Trainers/skip_unconverged_samples Issue",
          "author": {
            "login": "higgnm"
          },
          "bodyText": "Hello,\nI'm having trouble using skip_unconverged_samples. I finally got past \"must use / delimiter\" and \"reporter not declared\" errors with converged_reporter, but I am now getting an error:\n\nReporter with the name \"stoch_tools_converged/bool\" within app \"pr_sub093\" was not found.\n\nWhich seems to stem from my chosen reporter. I'm using a PostProcessor that simply checks if the transient has run for 60+ seconds to determine that it has \"converged\":\n[stoch_tools_converged]\n    type = PostprocessorComparison\n    comparison_type = greater_than_equals\n    value_a = time\n    value_b = 60\n[]\n\nIf I change bool to value, I correctly get an error stating that the reporter has been requested of type std::vector<bool> but declared of type std::vector<double>. This indicates to me that my usage is fundamentally wrong. Based off the wording, I would think converged_reporter requires a bool, but I can't find any tests demonstrating usage of these keywords to guide me. Any help would be appreciated.\nAlso, as a side note, if  StochasticTools can print multiapp_converged in output .csv files, why can't skip_unconverged_samples simply be set to true without need for additional manipulation?",
          "url": "https://github.com/idaholab/moose/discussions/18559",
          "updatedAt": "2022-07-05T19:01:25Z",
          "publishedAt": "2021-08-09T15:02:01Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@zachmprince",
                  "url": "https://github.com/idaholab/moose/discussions/18559#discussioncomment-1155425",
                  "updatedAt": "2022-07-05T19:01:18Z",
                  "publishedAt": "2021-08-10T18:31:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "Hi @higgnm, you seem to have found a very new capability in stochastic tools! Could you post your inputs to see exactly what you are trying to do?\nTo summarize how skip_unconverged_samples works. First, SamplerReporterTransfer automatically creates a reporter value of type std::vector<bool> which contains a value for each sample, true if the solve was able to converge and false if it doesn't. Whether the solve converged or not directly determined from the sub-app's nonlinear system, there is no need for a separate postprocessor or reporter to determine this. Second, these values are transferred to a StochasticReporter so the resulting name is <stochastic_reporter_name>/<transfer_name>:converged. Finally, the trainer has the option to skip samples where the solve did not converge by setting skip_unconverged_samples = true and converged_reporter = <stochastic_reporter_name>/<transfer_name>:converged.",
                  "url": "https://github.com/idaholab/moose/discussions/18559#discussioncomment-1156195",
                  "updatedAt": "2022-07-05T19:01:18Z",
                  "publishedAt": "2021-08-10T22:15:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "higgnm"
                          },
                          "bodyText": "That worked to get my cases running. Unfortunately I'm now getting a \"Task add_vector_postprocessor is not registered to build Reporter derived objects\" error which I believe relates to a new version of my program and is a separate issue. Your explanation of the reporter usage makes sense; I was mistaken on how to access the :converged value.",
                          "url": "https://github.com/idaholab/moose/discussions/18559#discussioncomment-1159691",
                          "updatedAt": "2022-07-05T19:01:20Z",
                          "publishedAt": "2021-08-11T16:31:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For which object are you getting this?\nYou need to move this object from the [VectorPostprocessor] block to the [Postprocessor] block I think",
                          "url": "https://github.com/idaholab/moose/discussions/18559#discussioncomment-1159817",
                          "updatedAt": "2022-07-05T19:01:46Z",
                          "publishedAt": "2021-08-11T17:02:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "higgnm"
                          },
                          "bodyText": "This error was arising from using a newer version (with the skip_unconverged_samples) without updating the surrogate evaluation syntax to the newer Reporter syntax.",
                          "url": "https://github.com/idaholab/moose/discussions/18559#discussioncomment-1160076",
                          "updatedAt": "2022-07-05T19:01:46Z",
                          "publishedAt": "2021-08-11T18:13:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Axissymmetric Problem with Peridynamics Module",
          "author": {
            "login": "ppandit95"
          },
          "bodyText": "Dear MOOSE Community\nI wish to work with peridynamics module in order to simulate thermo-mechanical model for an axissymmetric problem regarding which I wish to know whether \"FEProblem\" declaration in Problems block will still work .....\nHoping to get headers in this direction.\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/18566",
          "updatedAt": "2022-07-14T21:07:30Z",
          "publishedAt": "2021-08-10T04:37:35Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "@hchen139",
                  "url": "https://github.com/idaholab/moose/discussions/18566#discussioncomment-1153915",
                  "updatedAt": "2022-07-14T21:07:43Z",
                  "publishedAt": "2021-08-10T11:55:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hchen139"
                  },
                  "bodyText": "The MOOSE peridynamics module currently does not have axisymmetric models. Please refer to the test problems of the peridynamics module on how to write an input file to use available peridynamics capabilities in MOOSE.",
                  "url": "https://github.com/idaholab/moose/discussions/18566#discussioncomment-1155981",
                  "updatedAt": "2022-07-14T21:07:58Z",
                  "publishedAt": "2021-08-10T20:57:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ppandit95"
                  },
                  "bodyText": "Ohh, Thanks for clarifying this issue.....\n\u2026\nOn Wed, Aug 11, 2021 at 2:27 AM Hailong Chen ***@***.***> wrote:\n The MOOSE peridynamics module currently does not have axisymmetric models.\n Please refer to the test problems of the peridynamics module on how to\n write an input file to use available peridynamics capabilities in MOOSE.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#18566 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ALP7KHSWEJK7EZ6Y3VIVIB3T4GHD5ANCNFSM5B3KXXHA>\n .\n Triage notifications on the go with GitHub Mobile for iOS\n <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n or Android\n <https://play.google.com/store/apps/details?id=com.github.android&utm_campaign=notification-email>\n .",
                  "url": "https://github.com/idaholab/moose/discussions/18566#discussioncomment-1157049",
                  "updatedAt": "2022-07-14T21:07:54Z",
                  "publishedAt": "2021-08-11T06:05:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Enforcing Jump Constraint in XFEM Module",
          "author": {
            "login": "pratyushpotu"
          },
          "bodyText": "Hi,\nI am trying to create a model for the evaporation of liquid into vapor, and am trying to use the XFEM and Level Set modules with the LevelSetCutUserObject for the interface. I am having difficulty directly enforcing the jump in heat across the moving boundary. In particular, I am trying to use the XFEMSingleVariableConstraint to enforce this jump condition but I'm not sure if this is the best way to go. Explicitly, the condition I am trying to implement is below:\nWe have simulated the following equations: Let $\\phi$ be the signed distance function where for each time, $t$, the zero level set is the interface between liquid and vapor phases. Explicitly, the interface between the liquid and vapor phases is given by\n\nLet the region with $\\phi(x) &gt; 0$ be the vapor phase and let the negative distances from the interface being identified with the liquid phase. Now, with this, we simulate the below two equations and reinforces energy jump condition across the interface:\n\nAny ideas/help with how to would be greatly appreciated.\nThanks,\nPratyush",
          "url": "https://github.com/idaholab/moose/discussions/18572",
          "updatedAt": "2022-07-25T16:45:35Z",
          "publishedAt": "2021-08-10T17:45:17Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "First, we have not really tried to combine XFEM and Level Set modules together yet. Issues there are: 1. what is the solution scheme to compute level set and physics model? Concurrently coupling or staggered coupling? 2. XFEM will cut the mesh, and you need some constraints to heal the mesh to run level set evolution equation.\nSecond, the set of equations does not seem to be complete. I think we still need a Dirichlet like BC to enforce the temperature jump. So far, you only have the flux BCs on the interface. For both interfacial conditions, you can use ElemElemConstraint to implement your weak forms.\nLastly, we have been developing a mesh-based moving interface capability. We use a mesh to represent the interface and we calculate the interface velocity on the cutting mesh to move the mesh. With that, you do not need to couple level set module. See #17813",
                  "url": "https://github.com/idaholab/moose/discussions/18572#discussioncomment-1155984",
                  "updatedAt": "2022-07-25T16:45:35Z",
                  "publishedAt": "2021-08-10T20:57:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "L2 error for a transient simulation",
          "author": {
            "login": "pharshaad"
          },
          "bodyText": "Hi all,\nI'm following example 14 for calculating the L2 norm of the error for a transient wave propagation simulation. I'm using a fine mesh solution as my exact solution, however, I'm a bit confused with the multiple .xda and _mesh.xda files that are being generated for the fine mesh solution. I'm not sure which one to feed into the SolutionUserObject of the coarse mesh simulation. Is it going to be the last file (0200.xda and 0200_mesh.xda for a 200 timestep run)?\nThanks,\nLeon",
          "url": "https://github.com/idaholab/moose/discussions/18568",
          "updatedAt": "2022-06-16T21:44:19Z",
          "publishedAt": "2021-08-10T14:02:21Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "You can specify the highest number (so the latest timestep) or you can replace the number with .LATEST in your input file and it ll pick the latest.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18568#discussioncomment-1154842",
                  "updatedAt": "2022-06-16T21:44:19Z",
                  "publishedAt": "2021-08-10T15:13:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Resolving Transient runtime Error: auto_advance=false",
          "author": {
            "login": "japresa"
          },
          "bodyText": "Hello,\nIn my SAM-MOOSE simulation, I'm getting this runtime error and don't know how to fix it.\nFullSolveMultiApp is not compatible with auto_advance=false\nI've tried making a SolveStep object and set auto_advance=true but it isn't recognized. I've also tried to manually change the bool value in other blocks but am still getting the error. Any advice on how to get rid of this error would help :)",
          "url": "https://github.com/idaholab/moose/discussions/18556",
          "updatedAt": "2022-07-08T08:46:00Z",
          "publishedAt": "2021-08-09T04:04:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHave you tried setting that parameter to false to the MultiApps block?\nIs another moose app the subapp?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18556#discussioncomment-1147274",
                  "updatedAt": "2022-07-08T08:45:59Z",
                  "publishedAt": "2021-08-09T04:42:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "japresa"
                  },
                  "bodyText": "Hello\nI've tried to manually change the parameter's bool value in the MultiApp block.\nWhat do you mean by \"another moose app being the subapp\"? I know this subapp, (FullSolveMultiApp), runs a complete simulation every execution? That's the only app I define in the MultiApp block.",
                  "url": "https://github.com/idaholab/moose/discussions/18556#discussioncomment-1150760",
                  "updatedAt": "2022-07-08T08:46:12Z",
                  "publishedAt": "2021-08-09T18:13:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is the sub app SAM or is it a different app",
                          "url": "https://github.com/idaholab/moose/discussions/18556#discussioncomment-1150921",
                          "updatedAt": "2022-07-08T08:46:17Z",
                          "publishedAt": "2021-08-09T19:02:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "japresa"
                          },
                          "bodyText": "Yes, I\u2019m using SAM",
                          "url": "https://github.com/idaholab/moose/discussions/18556#discussioncomment-1151198",
                          "updatedAt": "2022-07-08T08:46:17Z",
                          "publishedAt": "2021-08-09T20:33:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think something in SAM is preventing you from running FullSolveMultiApp, by hard setting auto_advance=false. I just tried on some SAM inputs of mine and got the same error.\n@andrsd any thoughts on this?\nDo you have the github handles of SAM developers we could tag here?",
                  "url": "https://github.com/idaholab/moose/discussions/18556#discussioncomment-1151455",
                  "updatedAt": "2022-07-08T08:46:20Z",
                  "publishedAt": "2021-08-09T22:04:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "travismui"
                          },
                          "bodyText": "Hi @GiudGiud, I'm part of the SAM developer team. Just wanted to check\u2013 the auto_advance = true parameter is set in the Executioner block, correct? This should be allowed, I don't believe SAM enforces any Executioner parameters. I'm not sure if anyone has previously worked with SAM on a FullSolveMultiApp problem, but it should be possible.\nI just checked with one of our regression test TransientMultiApp problems and was able to run it as a FullSolveMultiApp by setting auto_advance = true in the Transient executioner block of the main app. It seems like it yielded the expected behavior, namely the sub app executing a full simulation for each tilmestep of the main app.",
                          "url": "https://github.com/idaholab/moose/discussions/18556#discussioncomment-1154401",
                          "updatedAt": "2022-07-08T08:46:32Z",
                          "publishedAt": "2021-08-10T13:43:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hi Travis\nThanks for pitching in!\nGood catch, it's an executioner parameter not a MultiApp parameter.\nI was able to run a FullSolveMultiApp in my SAM inputs as well by setting this option.\nSAM (or something) must be enforcing this parameter in some fashion. Other MOOSE apps do not require setting this parameter before using a FullSolveMultiApp.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/18556#discussioncomment-1154750",
                          "updatedAt": "2022-07-08T08:46:38Z",
                          "publishedAt": "2021-08-10T15:01:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Boundary conditions ignored by MOOSE",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "I created a simple mesh with gmsh for a simple flow under a dam. This is the content of the input file:\nhttps://pastebin.com/tGFruT1s\nYet, when I run the simulation, the output seems to completely ignore the BCs, and I have flow_pot = 0 everywhere including at the boundaries I specified. I made my own custom kernels for this to try to learn how MOOSE works, by the way. And they compile fine:\nMaterial Class: https://pastebin.com/pnUfeM3B\nKernel: https://pastebin.com/HBcT2KBq\n.inp mesh file created:\nhttps://pastebin.com/QrY55VzP",
          "url": "https://github.com/idaholab/moose/discussions/18149",
          "updatedAt": "2022-07-29T02:10:45Z",
          "publishedAt": "2021-06-23T08:14:09Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nGave a quick look and:\n\nyou dont need to specify zero Neumann BCs on the wall, that is a default\nIs this just a diffusion problem? There are pre-built kernels for this btw\nYou dont seem to be initializing permeability in that source file. You only declare it. If it's a constant, you could use a GenericConstantMaterial. You could also have a look at that file to see how the prop_values are retrieved from the input file and placed in the properties at the quadrature points\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-910937",
                  "updatedAt": "2022-07-29T02:11:03Z",
                  "publishedAt": "2021-06-23T15:51:35Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Hi,\nYes it is, but I was trying to learn how to create the kernel using the material interface so I can apply it to a more complex problem.\nI believe I fixed that now, and the simulation does seem to be calculating residuals now unlike before (where it would converge with one iteration and |r|=0). However, when I view the output with paraview, it's still giving me a value of flow_pot = 0 everywhere. I still used the 'ADMaterialProperty' btw, because the problem I eventually want to do isn't just a generic constant.\nHere's the updated Material source file:\nhttps://pastebin.com/stmsL7fK\nSo I set the _permeability at the quadrature points to always equal the constant value retrieved from the user (with _the_permeability).  The input file and kernel remain unchanged.",
                          "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-912543",
                          "updatedAt": "2022-07-29T02:11:13Z",
                          "publishedAt": "2021-06-23T23:25:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "That's weird. Is paraview showing the initial condition by chance?\nIf there s a non zero residual, chances are the variable is not identically 0.",
                          "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-912920",
                          "updatedAt": "2022-07-29T02:11:14Z",
                          "publishedAt": "2021-06-24T03:00:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "No, not even showing the boundary condition. The value of flow_pot ranges from 0 to 1e-38 (which I assume is computer precision for 0)\nhttps://ibb.co/ZJDhQYW\nHowever the residual calculation starts off large so its clearly calculating something:\n0 Nonlinear |R| = 1.300704e+02\n0 Linear |R| = 1.300704e+02\n1 Linear |R| = 1.451357e-05\n1 Nonlinear |R| = 1.031623e-05\n0 Linear |R| = 1.031623e-05\n1 Linear |R| = 1.702694e-12\n2 Nonlinear |R| = 8.267341e-14\nSolve Converged!",
                          "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-913021",
                          "updatedAt": "2022-07-29T02:11:20Z",
                          "publishedAt": "2021-06-24T03:34:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok I cant access the page, my chrome wont let me. Can you please post a paraview screenshot?\nAlternatively, could you add postprocessors to characterize your solution? So like ElementAverageValue and SideAverageValue on the boundaries.\nI would try to isolate the problem by replacing each part of your custom simulation with generic moose objects and see what improves it.",
                          "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-913035",
                          "updatedAt": "2021-06-24T03:36:59Z",
                          "publishedAt": "2021-06-24T03:36:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "This is the paraview screenshot.\nI added the postprocessors and its clearly calculating something, the SideAverageValue on each boundary returned the value of the boundary conditions. I also tried \"SideAverageValue\" for the walls, and that gave me a number in between both boundaries. So it means something is wrong with the .e output file.",
                          "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-913046",
                          "updatedAt": "2021-06-24T03:47:18Z",
                          "publishedAt": "2021-06-24T03:43:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Did you change anything about the output block?\nIn paraview, did you make sure to select the last timestep?",
                          "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-913090",
                          "updatedAt": "2022-09-08T02:03:12Z",
                          "publishedAt": "2021-06-24T04:09:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "This is the output block:\n[Outputs]\nexodus = true\nperf_graph = true\n[]\nAnd in paraview, for the last timestep (only two timesteps as expected for a Steady State calculation) the whole mesh = 1.2e-38\nEdit: I've also been trying PointValue for random points within the mesh and they all return values between the BCs",
                          "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-913093",
                          "updatedAt": "2022-09-08T02:03:12Z",
                          "publishedAt": "2021-06-24T04:12:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "",
                          "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-913113",
                          "updatedAt": "2022-09-21T22:01:48Z",
                          "publishedAt": "2021-06-24T04:23:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Edit: I installed the latest version of paraview and finally got the solution displayed. A little bizarre imo but at least its working now. Thank you for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-913148",
                          "updatedAt": "2022-09-21T22:01:52Z",
                          "publishedAt": "2021-06-24T04:50:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah great I was getting super confused. Thanks for letting us know. Good luck for the rest of the model!",
                          "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-913220",
                          "updatedAt": "2022-09-21T22:01:52Z",
                          "publishedAt": "2021-06-24T05:26:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Hi @GiudGiud\nI see you mentioned\n\n'You dont seem to be initializing permeability in that source file. You only declare it. If it's a constant, you could use a GenericConstantMaterial. You could also have a look at that file to see how the prop_values are retrieved from the input file and placed in the properties at the quadrature points'\n\nI wonder if we can pre-define material properties such as permeability/porosity in the mesh file (.inp) and MOOSE will recognise it?\nI want to specify a different value of the property at each element (base on element number/ID), is this possible with MOOSE?\nThank you.\nKind regards,\nTraiwit",
                  "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-1152204",
                  "updatedAt": "2022-07-29T02:11:20Z",
                  "publishedAt": "2021-08-10T03:56:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm not aware of this capability for .inp files.\nInput of material properties is usually done per block.\nYou should post in another discussions thread to find out if there's a per-element option. I dont think there is, but maybe someone has done something similar before.",
                          "url": "https://github.com/idaholab/moose/discussions/18149#discussioncomment-1152248",
                          "updatedAt": "2022-09-21T22:01:52Z",
                          "publishedAt": "2021-08-10T04:13:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issue with Neumann boundary conditions on .inp mesh created with gmsh",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "Hi, I have a mesh created with gmsh with a pretty simple geometry, but I'm having trouble using it with Neumann BCs.\nhttps://easyupload.io/6p4kka\nThe above is the raw/unedited .inp export from gmsh- when I used this I got the error:\n\"Expected boundary element of dimension 2 but got 1\"\nSo I manually deleted all the line and surface elements, and left only the volume element. I applied Dirichlet conditions on one of the \"physical groups\" I created, which is a surface of one side, and it ran fine.\nThe problem I'm facing now is applying Neumann condition to the same surface- I get:\n*** ERROR ***\n    the following side set ids do not exist on the mesh: 3\n\n    MOOSE distinguishes between \"node sets\" and \"side sets\" depending on whether\n    you are using \"Nodal\" or \"Integrated\" BCs respectively. Node sets corresponding\n    to your side sets are constructed for you by default.\n\n    Try setting \"Mesh/construct_side_list_from_node_list=true\" if you see this error.\n    Note: If you are running with adaptivity you should prefer using side sets.\n\nSo I added that argument to the Mesh block, and nothing changed. I also thought it could be the element sets created by gmsh, and since I deleted all the surface elements, I should delete the surface elsets too (and leave only the nodesets). Doing that gave me the error:\n*** ERROR ***\nInvalid dimension dim = 4\n\nI also tried remaking the mesh and instead of defining the surface as the boundary, I'd define the lines that make up the surface as the boundary (in the attached file, these are named \"left_tract\" and \"right_tract\"). I did that and tried in MOOSE but just got a segmentation fault with no backtrace.",
          "url": "https://github.com/idaholab/moose/discussions/18499",
          "updatedAt": "2022-06-18T18:47:30Z",
          "publishedAt": "2021-08-02T22:58:59Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "@richmondodufisan you can attach files here directly without resorting to sketchy looking download sites...\nSee here: dike_mesh.inp.gz\nIt would be more useful to see you gmsh script that generated that file.",
                  "url": "https://github.com/idaholab/moose/discussions/18499#discussioncomment-1130832",
                  "updatedAt": "2022-06-18T18:47:35Z",
                  "publishedAt": "2021-08-04T15:31:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Meaning the .geo file!\nYou can create sidesets with the SideSetsFromBoundingBoxGenerator, SideSetsAroundSubdomainGenerator, SideSetsFromNormalsGenerator, ParsedGenerateSideset etc. All those are MeshGenerators that would be chained after your FileMeshGenerator.",
                          "url": "https://github.com/idaholab/moose/discussions/18499#discussioncomment-1130903",
                          "updatedAt": "2022-06-18T18:47:35Z",
                          "publishedAt": "2021-08-04T15:50:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Hi Daniel, thanks for the tip! Also, I used the GUI to create the mesh, I guess I'll need to learn how to generate a mesh from a script so I can share that",
                          "url": "https://github.com/idaholab/moose/discussions/18499#discussioncomment-1150887",
                          "updatedAt": "2022-06-18T18:47:36Z",
                          "publishedAt": "2021-08-09T18:51:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @richmondodufisan\nI paste below a simple 3D .geo file with definitions of physical surface.\nThis was working for me some time ago and I could define the boundary conditions in the moose input file\nby referring to the names of the physical surfaces, such as \"bottom\", \"top\", et cetera.\nYou can compare with your .geo file and see if there are differences.\nOr maybe the problem is your gmsh version, not all of versions generate the same .msh files.\nHope this helps.\nBest Regards,\nNicol\u00f2\ncl__1 = 0.1;\nPoint(1) = {0, 0, 0, 0.1};\nPoint(2) = {3, 0, 0, 0.1};\nPoint(3) = {3, 3, 0, 0.1};\nPoint(4) = {0, 3, 0, 0.1};\nPoint(5) = {1.5, 1.5, 0, 0.1};\nPoint(6) = {2, 1.5, 0, 0.1};\nPoint(7) = {1.5, 2, 0, 0.1};\nPoint(8) = {1, 1.5, 0, 0.1};\nPoint(9) = {1.5, 1, 0, 0.1};\nPoint(10) = {1.5, 0, 0, 0.1};\nPoint(11) = {3, 1.5, 0, 0.1};\nPoint(12) = {1.5, 3, 0, 0.1};\nPoint(13) = {0, 1.5, 0, 0.1};\nLine(1) = {1, 10};\nTransfinite Line {1} = 16Using Progression 1;\nLine(2) = {10, 2};\nTransfinite Line {2} = 16Using Progression 1;\nLine(3) = {2, 11};\nTransfinite Line {3} = 16Using Progression 1;\nLine(4) = {11, 3};\nTransfinite Line {4} = 16Using Progression 1;\nLine(5) = {3, 12};\nTransfinite Line {5} = 16Using Progression 1;\nLine(6) = {12, 4};\nTransfinite Line {6} = 16Using Progression 1;\nLine(7) = {4, 13};\nTransfinite Line {7} = 16Using Progression 1;\nLine(8) = {13, 1};\nTransfinite Line {8} = 16Using Progression 1;\nLine(9) = {10, 9};\nTransfinite Line {9} = 11Using Progression 1;\nLine(10) = {11, 6};\nTransfinite Line {10} = 11Using Progression 1;\nLine(11) = {12, 7};\nTransfinite Line {11} = 11Using Progression 1;\nLine(12) = {13, 8};\nTransfinite Line {12} = 11Using Progression 1;\nCircle(13) = {8, 5, 9};\nTransfinite Line {13} = 11Using Progression 1;\nCircle(14) = {9, 5, 6};\nTransfinite Line {14} = 11Using Progression 1;\nCircle(15) = {6, 5, 7};\nTransfinite Line {15} = 11Using Progression 1;\nCircle(16) = {7, 5, 8};\nTransfinite Line {16} = 11Using Progression 1;\nLine Loop(18) = {8, 1, 9, -13, -12};\nPlane Surface(18) = {18};\nRecombine Surface {18};\nLine Loop(19) = {13, 14, 15, 16};\nPlane Surface(19) = {19};\nRecombine Surface {19};\nLine Loop(20) = {9, 14, -10, -3, -2};\nPlane Surface(20) = {20};\nRecombine Surface {20};\nLine Loop(22) = {10, 15, -11, -5, -4};\nPlane Surface(22) = {22};\nRecombine Surface {22};\nLine Loop(24) = {11, 16, -12, -7, -6};\nPlane Surface(24) = {24};\nRecombine Surface {24};\nExtrude {0, 0, 0.1} {\n  Surface{18, 19, 20, 22, 24};\n  Layers{1};\n  Recombine;\n}\nPhysical Surface(\"bottom\") = {38, 99};\nPhysical Surface(\"top\") = {122, 153};\nPhysical Surface(\"right\") = {95, 126};\nPhysical Surface(\"left\") = {149, 34};\nPhysical Surface(\"front\") = {154, 127, 100, 51};\nPhysical Surface(\"back\") = {18, 20, 22, 24};\nPhysical Volume(\"all\") = {1, 2, 3, 4, 5};\nPhysical Volume(\"pore\") = {2};\nPhysical Volume(\"allminuspore\") = {1, 3, 4, 5};",
                  "url": "https://github.com/idaholab/moose/discussions/18499#discussioncomment-1131180",
                  "updatedAt": "2022-06-18T18:47:38Z",
                  "publishedAt": "2021-08-04T16:55:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "So I have this:\ncl__1 = 1;\nPoint(1) = {0, 0, 0, cl__1};\nPoint(2) = {300, 0, 0, cl__1};\nPoint(3) = {136, 80, 0, cl__1};\nPoint(4) = {164, 80, 0, cl__1};\nPoint(5) = {164, 80, 25, cl__1};\nPoint(6) = {136, 80, 25, cl__1};\nPoint(7) = {0, 0, 25, cl__1};\nPoint(8) = {300, 0, 25, cl__1};\nLine(1) = {7, 6};\nLine(2) = {6, 5};\nLine(3) = {5, 8};\nLine(4) = {8, 2};\nLine(5) = {2, 1};\nLine(6) = {1, 7};\nLine(7) = {1, 3};\nLine(8) = {3, 6};\nLine(9) = {3, 4};\nLine(10) = {4, 5};\nLine(11) = {4, 2};\nLine(12) = {8, 7};\nCurve Loop(1) = {1, 2, 3, 12};\nPlane Surface(1) = {1};\nCurve Loop(2) = {7, 8, -1, -6};\nPlane Surface(2) = {2};\nCurve Loop(3) = {2, -10, -9, 8};\nPlane Surface(3) = {3};\nCurve Loop(4) = {3, 4, -11, 10};\nPlane Surface(4) = {4};\nCurve Loop(5) = {12, -6, -5, -4};\nPlane Surface(5) = {5};\nCurve Loop(6) = {11, 5, 7, 9};\nPlane Surface(6) = {6};\nSurface Loop(1) = {1, 2, 6, 4, 5, 3};\nVolume(1) = {1};\nPhysical Surface(\"front\") = {1};\nPhysical Surface(\"back\") = {6};\nPhysical Surface(\"left\") = {2};\nPhysical Surface(\"right\") = {4};\nPhysical Surface(\"top\") = {3};\nPhysical Surface(\"bottom\") = {5};\nwhich seems slightly different from yours. In my version lines are referred to as curves. There's also a \"recombine surface\" in yours that I can't find- what version of gmsh are you using? Mine is 4.8.4.",
                          "url": "https://github.com/idaholab/moose/discussions/18499#discussioncomment-1151063",
                          "updatedAt": "2022-06-18T18:48:10Z",
                          "publishedAt": "2021-08-09T19:47:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "I also tried giving MOOSE .msh files instead of .inp files, and I got this error:\nError: Exodus requires all elements with a given subdomain ID to be the same type.\nCan't write both PYRAMID5 and TET4 in the same block!Error: Exodus requires all elements with a given subdomain ID to be the same type.\nCan't write both PYRAMID5 and TET4 in the same block!\n\nBut in my mesh preferences, I selected:\n2D Algorithm: MeshAdapt (I also tried \"Automatic\" and \"Frontal Delaunay for Quads\")\n3D Algorithm: Delaunay (I tried all non \"experimental\" algorithms available).\n2D Recombination Algorithm: Simple Full Quad\nSubdivision Algorithm: All Quads",
                          "url": "https://github.com/idaholab/moose/discussions/18499#discussioncomment-1151091",
                          "updatedAt": "2022-06-18T18:48:15Z",
                          "publishedAt": "2021-08-09T19:56:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Coefficient field (material properties) reconstruction through MOOSE - Wave Equation",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi\nI am working on two types of the inverse problem (reconstruction of the material properties) that involves solving the wave equation in the frequency domain for multiple right-hand sides. This problem is well known in geophysics (seismic inversion) and in biomedical imaging (Ultrasound imaging). Typically, this problem involve thousands of forward solves (FE simulation) as a results of sweeping over all frequency content and all sources (right hand sides) at each iteration to the optimization (reconstruction).\nAlthough I am just starting learning MOOSE and trying to switch to this new mindset, I can imagine how powerful MOOSE is especially for multiphysics simulation. However, I am still have some issues in deciding whether MOOSE is a suitable choice for my problems.\nTo be specific, the optimum framework that I am looking for is preferably have the following:\n1- Can handle complex arithmetics (needed for solving the wave equation in the frequency domain)\n2- Ability to modify the integration rule for specific region/regions of the domain (e.g. mid point integration), this is needed to model a variant of the perfectly matched layer (PMDL) that acts as wave absorber.\n3- Abitility to update material properties after each optimization iteration in runtime without the need for updating the input.i file after each iteration.\nSo, if you could please give some pointers on the previous 3 points and some pointer on how to model an arbitrary, completely heterogenous 3D domain (i.e each finite element in the mesh has different material property).\nI really appreciate your response.",
          "url": "https://github.com/idaholab/moose/discussions/18547",
          "updatedAt": "2022-08-08T18:21:48Z",
          "publishedAt": "2021-08-06T11:18:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe can definitely do 3. this is very routine. People can define material properties that are function of time, space, temperature, you name it. Their values can be different in every element, and can be recomputed as often as you want.\nSo you would want to use a different element type or quadrature rule in parts of the domain for 2? This is also possible, though more involved if this is not part of the ones we have already implemented in the framework. If you have an equation for that we may be able to give more details.\nI ll let people more expert about the wave equation reply about 1.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1140966",
                  "updatedAt": "2022-08-08T18:22:33Z",
                  "publishedAt": "2021-08-06T20:49:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think op wants different time integrators for different subdomains, which is currently not supported.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141052",
                          "updatedAt": "2022-08-08T18:22:53Z",
                          "publishedAt": "2021-08-06T21:35:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ah ok\nYou could do a multiapp approach for this. It would be like a separate calculation that you iterate to convergence.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141087",
                          "updatedAt": "2022-08-08T18:22:53Z",
                          "publishedAt": "2021-08-06T21:50:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Thank you, Guillaume and Gary, for the response.\nWith respect to the integration part (point 2), let's, for example, consider an elasticity problem in 2D, and consider the bilinear Q4 finite element, the full integration requires 4 Gauss Points, this is already there and I have no problem with it.\nNow, for some cases, for instance, when the problem suffers from volumetric locking, we need to do \"selective reduced integration\" where the volumetric strain is evaluated by only integrating at  one Gauss Point in the middle of the Q4 element, whereas the shear strain is evaluated by full integration.\nThis is a very helpful technique when modeling elastic half-spaces and wave absorbers. In addition, it can be used for modeling soft tissues where soft tissues are known to be incompressible.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141217",
                          "updatedAt": "2022-08-08T18:22:53Z",
                          "publishedAt": "2021-08-06T23:12:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "I think op wants different time integrators for different subdomains, which is currently not supported.\n\nI do not think I would need different time integrators. The problem that I solve is in the frequency domain. So, we would have many steady-state problems (corresponds to each frequency in the spectrum) as opposed to marching in time.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141226",
                          "updatedAt": "2022-09-28T23:06:41Z",
                          "publishedAt": "2021-08-06T23:19:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Ah sorry I misunderstood. Yeah, we do volumetric locking correction routinely. Mostly B-bar and F-bar.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141232",
                          "updatedAt": "2022-09-28T23:06:41Z",
                          "publishedAt": "2021-08-06T23:26:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Regarding your point one, I know libMesh definitely is able to solve complex eigenvalue problems, so there's no reason moose can't do that. I haven't done that myself, I think @fdkong or maybe @roystgnr know more about that.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1141241",
                          "updatedAt": "2022-09-28T23:06:41Z",
                          "publishedAt": "2021-08-06T23:28:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "The trouble on the libMesh side is that, because PETSc (and thereby SLEPc) always forced users to choose between real and complex PetscScalar at configure time, libMesh never bothered to add runtime-selectable support for real and complex either.  For users who were writing individual complex eigenproblem solver applications this wasn't a hassle, but for frameworks like Moose?  Building a whole copy of Moose against an --enable-complex libMesh is what you'd have to do, and I'm not sure whether people actually can do that or not.",
                          "url": "https://github.com/idaholab/moose/discussions/18547#discussioncomment-1149714",
                          "updatedAt": "2022-09-28T23:06:41Z",
                          "publishedAt": "2021-08-09T14:28:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Working with ADMaterial",
          "author": {
            "login": "rksin8"
          },
          "bodyText": "Is there any equivalent AD function to the coupledValueOld() and getMaterialPropertyOld<T>()?\nThanks,\nRanjeet",
          "url": "https://github.com/idaholab/moose/discussions/18482",
          "updatedAt": "2022-11-16T23:49:40Z",
          "publishedAt": "2021-07-30T09:47:47Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "rksin8"
                  },
                  "bodyText": "Solved this issue with help of tensor module material.",
                  "url": "https://github.com/idaholab/moose/discussions/18482#discussioncomment-1090974",
                  "updatedAt": "2022-11-16T23:49:41Z",
                  "publishedAt": "2021-07-30T11:01:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Old state properties are always non-dual numbers. The old state of an ADReal property is simply of type Real. That is because the old state does not depend on the current solution state! So the solution is to simply use coupledValueOld() and getMaterialPropertyOld<T>().",
                  "url": "https://github.com/idaholab/moose/discussions/18482#discussioncomment-1091849",
                  "updatedAt": "2022-11-16T23:49:42Z",
                  "publishedAt": "2021-07-30T15:26:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rksin8"
                          },
                          "bodyText": "Thank you for explaining this.\nWould you please explain when to use precomputeQpResidual() instead of computeQpResidual()?\nThank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18482#discussioncomment-1118519",
                          "updatedAt": "2022-11-16T23:49:42Z",
                          "publishedAt": "2021-08-02T05:44:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "You should start a new thread for this question. I assume you are asking something like precalculateQpResidual in IntegratedBC vs computeQpResidual. precalculateQpResidual provides derived objects a function to override where they can put local evaluations independent on shape functions (_i) to avoid repeated operations. You can see this by checking the code in IntegratedBC.C.",
                          "url": "https://github.com/idaholab/moose/discussions/18482#discussioncomment-1119056",
                          "updatedAt": "2022-11-16T23:49:43Z",
                          "publishedAt": "2021-08-02T08:12:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rksin8"
                          },
                          "bodyText": "@YaqiWang Thank you for pointing out some reference codes. I will ask a new question if need further help.",
                          "url": "https://github.com/idaholab/moose/discussions/18482#discussioncomment-1147667",
                          "updatedAt": "2022-11-16T23:49:43Z",
                          "publishedAt": "2021-08-09T07:02:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Postprocessor][Material property][getMaterialProperty]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Dear moose users,\nHow can I load material property in postprocessors?\nTypically, I want to use NodalVariablePostprocessor to calculate some values by nodal variable and material property.\nBut, when I use getMaterialProperty, it doesn't work and it shows the following error:\n'getMaterialProperty' was not declared in this scope; did you mean 'ADMaterialProperty'?\nI guess I have to add some header file that includes the definition of getMaterialProperty.\nBut I am not sure.\nKind regards",
          "url": "https://github.com/idaholab/moose/discussions/18545",
          "updatedAt": "2022-07-13T19:27:57Z",
          "publishedAt": "2021-08-06T06:17:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes, in general, you have to add the MaterialPropertyInterface to the classes that the postprocessor inherits from in order to use the getMaterialProperty routine. This is done for the user object classes that a lot of postprocessors inherit from.\nHowever, you are using a Nodal postprocessor, and currently NodalUserObject does not inherit from that class. The reason is that this interface is not able to compute nodal values, as material properties are tied to subdomains, so it would not know why one to pick at an interface between two subdomains.\nSo the solution here is to wait for us to implement functor material properties, which is underway in #18395, and will do nodal values of material properties\nOR\nconvert from nodal to elemental variables and use the Elemental postprocessors.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18545#discussioncomment-1141018",
                  "updatedAt": "2022-07-13T19:28:00Z",
                  "publishedAt": "2021-08-06T21:13:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "coskrrb2002"
                          },
                          "bodyText": "Dear @GiudGiud,\nThank you for your comment!\nIt helps me a lot.\nI will look and follow up #18395 post.\nCheers,\nNakkyu",
                          "url": "https://github.com/idaholab/moose/discussions/18545#discussioncomment-1147298",
                          "updatedAt": "2022-07-13T19:28:05Z",
                          "publishedAt": "2021-08-09T04:55:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}