{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNi0wOVQwNjo1NzoxNi0wNTowMM4APcSQ"
    },
    "edges": [
      {
        "node": {
          "title": "The coupling of phase field and mechanical stress",
          "author": {
            "login": "biaogxb"
          },
          "bodyText": "I just came into contact with moose. I want to use the phase field method to simulate the growth of dendrites and couple the mechanical stress by adding  elastic strain energy . I encountered difficulties in coupling the mechanical stress. Is there a similar example?\nAnd I want to customize kappa as kappa=k0 (1+w*cos\uff08 \u03b8\uff09\uff09\uff0c among \u03b8 is the changing angle between the normal vector of interface and the reference axis, I don't know how to express this \u03b8\uff0c Do you have any suggestions?\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/21246",
          "updatedAt": "2022-06-11T08:35:23Z",
          "publishedAt": "2022-06-09T09:13:15Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere are examples in the combined module.\nhttps://github.com/idaholab/moose/tree/next/modules/combined/examples/phase_field-mechanics\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21246#discussioncomment-2915347",
                  "updatedAt": "2022-06-09T16:45:44Z",
                  "publishedAt": "2022-06-09T16:45:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Thank you!!! I want to customize kappa as kappa=k0 (1+w*cos\uff08 \u03b8\uff09\uff09\uff0c among \u03b8 is the changing angle between the normal vector of interface and the reference axis, I don't know how to express this \u03b8\uff0c Do you have any suggestions?",
                          "url": "https://github.com/idaholab/moose/discussions/21246#discussioncomment-2918727",
                          "updatedAt": "2022-06-10T02:20:22Z",
                          "publishedAt": "2022-06-10T02:20:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so this theta, is it a property of the dendrites or is it local to the mesh?\nYou should search in moose for models for kappa.",
                          "url": "https://github.com/idaholab/moose/discussions/21246#discussioncomment-2925496",
                          "updatedAt": "2022-06-10T19:14:32Z",
                          "publishedAt": "2022-06-10T19:14:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Okay thank you very much",
                          "url": "https://github.com/idaholab/moose/discussions/21246#discussioncomment-2927835",
                          "updatedAt": "2022-06-11T08:35:19Z",
                          "publishedAt": "2022-06-11T08:35:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "the problem of combustion",
          "author": {
            "login": "xiaojbing"
          },
          "bodyText": "Does MOOSE support to compute the problem of combustion\uff1fWhether to support  files of CHEMKIN\uff1f",
          "url": "https://github.com/idaholab/moose/discussions/21219",
          "updatedAt": "2022-06-13T08:10:19Z",
          "publishedAt": "2022-06-07T01:16:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@permcody do you know?",
                  "url": "https://github.com/idaholab/moose/discussions/21219#discussioncomment-2909860",
                  "updatedAt": "2022-06-09T01:49:14Z",
                  "publishedAt": "2022-06-09T01:49:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "No, we don\u2019t have any support for that.",
                          "url": "https://github.com/idaholab/moose/discussions/21219#discussioncomment-2926779",
                          "updatedAt": "2022-06-11T01:29:55Z",
                          "publishedAt": "2022-06-11T01:29:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Help needed on PowerLawCreepStressUpdate class",
          "author": null,
          "bodyText": "Dear MOOSE experts,\nI\u2019m a newbie to MOOSE, and I\u2019m leveraging the capabilities of the PowerLawCreepStressUpdate class in FALCON (MOOSE application). I have a few questions about the parent classes of the PowerLawCreepStressUpdate.\nLine 170 in the SingleVariableReturnMappingSolution.C class reads: scalar = initialGuess (effective_trial_stress).\nI think that scalar is being initialized here, but does this mean that scalar is initialized with the \u201ceffective_trial_stress \u201d value? If this is true, does it mean I can define my own parameter that I can use to initialize the scalar parameter?\nAlso, Line 211 in the RadialReturnStressUpdate.C file reads: _scalar_effective_inelastic_strain = 0.0. Is _scalar_effective_inelastic_strain being initialized here too? If yes, can I define my own value and use it to initialize _scalar_effective_inelastic_strain?\nThanks in advance for your help!",
          "url": "https://github.com/idaholab/moose/discussions/21267",
          "updatedAt": "2022-06-25T05:50:33Z",
          "publishedAt": "2022-06-10T16:39:08Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "No. The initialGuess is a a virtual function. By default, it is zero. As I mentioned before in our emails, we use a Newton method to solve scalar. A good initial guess will help convergence. If you do not know, zero would be a nice guess.",
                  "url": "https://github.com/idaholab/moose/discussions/21267#discussioncomment-2924740",
                  "updatedAt": "2022-06-10T16:52:30Z",
                  "publishedAt": "2022-06-10T16:52:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Thanks, @jiangwen84. So what is the role of the effective_trial_stress in the brackets after the initialGuess on line 170 in the SingleVariableReturnMappingSolution.C class?",
                          "url": "https://github.com/idaholab/moose/discussions/21267#discussioncomment-2924828",
                          "updatedAt": "2022-06-10T17:03:37Z",
                          "publishedAt": "2022-06-10T17:03:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "It provides a way to formulate the initial guess as a function of effective_trial_stress. In this case, effective_trial_stress is not used.",
                          "url": "https://github.com/idaholab/moose/discussions/21267#discussioncomment-2924869",
                          "updatedAt": "2022-06-10T17:09:45Z",
                          "publishedAt": "2022-06-10T17:09:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "3D mortar contact: why is contact stiffness matrix implemented by automatic differentiation?",
          "author": {
            "login": "ch950423"
          },
          "bodyText": "Hi MOOSE experts.\nI am trying to implement the 3D mortar contact using dual Lagrange multipliers following the thesis of Alexander Popp. But the contact stiffness matrix is so complicated that it is even not fully written in the thesis. The thesis just told me every term of the contact stiffness matrix, i.e. the directional derivatives of the mortar matrix \u0394D and \u0394M.\nI debugged the following example:\nmoose/modules/contact/test/tests/3d-mortar-contact/frictionless-mortar-3d-test-derivative-trimming.i\nI found the contact stiffness matrix is computed as follows:\nmoose/modules/contact/src/constraints/ADMortarLagrangeConstraint.C\n90 void\n91 ADMortarLagrangeConstraint::computeJacobian(Moose::MortarType mortar_type)\n...\n146  std::vector< DualReal > residuals_lower;\n147  residuals_lower.resize(number_indices_on_lowerd, 0);\n148\n149  // Only populate nodal residuals on the primary/secondary surfaces\n150  // We do this regardless of whether we are interpolating normals. Use of this class\n151  // implies we have Lagrange elements, so internal (high-dimensional) normals have no meaning\n152  // and should be zero. As such, we decide to omit them and avoid possible spurious population of\n153  // automatic differentiation-generated derivatives.\n154  for (_qp = 0; _qp < _qrule_msm->n_points(); _qp++)\n155  {\n156    unsigned int index_lower = 0;\n157    for (const auto index : is_index_on_lower_dimension)\n158    {\n159      _i = index;\n160      residuals_lower[index_lower] += _JxW_msm[_qp] * _coord[_qp] * computeQpResidual(mortar_type);\n161\n162      // Get rid of derivatives that we assume won't count (tolerance prescribed by user)\n163      // residuals_lower[index_lower].derivatives().sparsity_trim(_ad_derivative_threshold);\n164      index_lower++;\n165    }\n166  }\n\nThe line 160 is computing the residuals and its derivatives, i.e. the contact forces and the contact stiffness. Then the residuals_lower[i].derivatives() are used for assembly of the contact stiffness matrix.\nI found the computeQpResidual(mortar_type) is a ADReal and the automatic differentiation technique is used here.\nWhy is the contact stiffness matrix implemented by the automatic differentiation rather than implemented directly according to the formula? Is it because the formula is too complicated? What is the difference between the two ways?\nWhat is your advise if I want to compute the contact stiffness matrix?\nThanks in advance.",
          "url": "https://github.com/idaholab/moose/discussions/21220",
          "updatedAt": "2022-06-10T01:16:58Z",
          "publishedAt": "2022-06-07T02:40:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "The complexity of computing contact stiffness matrices is avoided by usage of automatic differentiation (AD) in MOOSE. AD also allows to change the way one defines contact forces without much development (e.g. one may want to introduce additional dependencies in the constraint equations). AD may generate additional computations to compute the system Jacobian, but, in the case of contact, since it acts on lower-dimensional domain, I have not found it to be limiting in any relevant way. I don't think there is a significant difference between the manual and the AD approach in the intended final result. Terms can be neglected both using AD or computing the Jacobian manually.\nNot sure if you want to compute the contact stiffness matrix in your own code or get the result from MOOSE. In the former case, I'd suggest dig into the literature. In the latter, I'd output the Jacobian in MOOSE for simpler problems.",
                  "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2899071",
                  "updatedAt": "2022-06-07T15:39:47Z",
                  "publishedAt": "2022-06-07T15:39:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ch950423"
                          },
                          "bodyText": "I have read relevant literature Automatic Differentiation in MetaPhysicL and Its Applications in MOOSE and A mortar thermomechanical contact computational framework for nuclear fuel performance simulation.\nIt seems the main feature of AD is the simplification of the computation of the derivative, at the cost of memory and computing efficiency, but without lose of accuracy.\nI still have some questions:\nThe relevant literature aforementioned focus on AD application in mortar contact in 2D.\nWhat the effect of applying AD to 3D mortar frictional contact? How about the convergence?\nWhen simulating a large model (i.e. too many DOFs and multiple contact zones existing), will the main disadvantages of AD show up? (will memory usage and computing efficiency become unacceptable?)\nThanks a lot.",
                          "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2911994",
                          "updatedAt": "2022-06-09T09:11:23Z",
                          "publishedAt": "2022-06-09T09:11:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ch950423"
                          },
                          "bodyText": "By the way, because the main complexity relies on computing the contact stiffness, is it feasible that I use AD to compute the contact stiffness matrix only, while computing other part of the system Jacobian manually (i.e. implementing other part of the system Jacobian directly according to the formula)?",
                          "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2912153",
                          "updatedAt": "2022-06-09T09:35:50Z",
                          "publishedAt": "2022-06-09T09:35:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "What the effect of applying AD to 3D mortar frictional contact? How about the convergence?\n\nI don't think there is any fundamental difference between 2D and 3D, other than dimensionality, which would increase the number of AD dependencies by some factor.\n\nwill the main disadvantages of AD show up? (will memory usage and computing efficiency become unacceptable?)\n\nWhen the AD container size is required to be too large, some memory limitations could potentially come into play. Say, if you have many variables per element, 3D problem, high-order elements, and a fine (finely meshed relative to the secondary side) primary side which increases the number of dependencies via projections. Typical simulations do not reach this kind of problems.\n\nBy the way, because the main complexity relies on computing the contact stiffness, is it feasible that I use AD to compute the contact stiffness matrix only, while computing other part of the system Jacobian manually (i.e. implementing other part of the system Jacobian directly according to the formula)?\n\nYes, that's what I meant by \"AD may generate additional computations to compute the system Jacobian, but, in the case of contact, since it acts on lower-dimensional domain, I have not found it to be limiting in any relevant way\".",
                          "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2913250",
                          "updatedAt": "2022-06-09T12:34:26Z",
                          "publishedAt": "2022-06-09T12:31:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "btw dont forget to reconfigure then recompile MOOSE with a larger ad-derivative-container size (see ./configure --help) to work on mortar contact with AD.\nStart with 200 maybe and let us know if you run into any issue",
                          "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2915357",
                          "updatedAt": "2022-06-09T16:47:29Z",
                          "publishedAt": "2022-06-09T16:47:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ch950423"
                          },
                          "bodyText": "OK",
                          "url": "https://github.com/idaholab/moose/discussions/21220#discussioncomment-2918392",
                          "updatedAt": "2022-06-10T01:16:58Z",
                          "publishedAt": "2022-06-10T01:16:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fluid-solid conjugate heat transfer problem",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, everyone, I recently ran into a fluid-solid conjugate heat transfer problem.\nThis is a relatively simple question, with only one variable called temp. This is the radial mesh:\n\nIn Kernels I have a volume heat source term in the fuel section and a convection term in the coolant section. Fuel, cladding, and coolant all have time and heat conduction terms. In BCs, I set the coolant inlet temperature(593K) and outlet velocity. And I set the initial value of temp is 593K.The entire input file is as follows:\nflow_velocity = 151.5 # cm/s\nini_temp = 593 # K\ncoolant_inlet_temp = 593 # K\n\n[Variables]\n  [./temp]\n    initial_condition = ${ini_temp}\n  [../]\n[]\n\n[Mesh]\n  file = 'model_finer.msh'\n[]\n\n[Kernels]\n  [./temp_time_derivative]\n    type = INSTemperatureTimeDerivative\n    variable = temp\n  [../]\n  [./temp_diffusion]\n    type = MatDiffusion\n    diffusivity = 'k'\n    variable = temp\n  [../]\n  [./temp_heat_source]\n    type = HeatSource\n    variable = temp\n    block = 'fuel'\n    value = 1e8\n  [../]\n  [./temp_advection_fuel]\n    type = ConservativeTemperatureAdvection\n    velocity = '0 0 ${flow_velocity}'\n    variable = temp\n    block = 'cool'\n  [../]\n[]\n\n[BCs]\n  [./temp_inlet_coolant]\n    type = DirichletBC\n    boundary = 'cool_inlet'\n    variable = temp\n    value = '${coolant_inlet_temp}'\n  [../]\n  [./temp_advection_coolant]\n    type = TemperatureOutflowBC\n    boundary = 'cool_outlet'\n    variable = temp\n    velocity = '0 0 ${flow_velocity}'\n  [../]\n[]\n\n[Materials]\n  [./rho_fuel]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.010982399418993717'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n  [./cp_fuel]\n    type = ParsedMaterial\n    f_name = cp\n    function = '297.81083870424914'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n  [./k_fuel]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.059515513277033714'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n\n  [./rho_clad]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.007667215971999999'\n    args = 'temp'\n    block = 'clad'\n  [../]\n  [./cp_clad]\n    type = ParsedMaterial\n    f_name = cp\n    function = '581.7254559999992'\n    args = 'temp'\n    block = 'clad'\n  [../]\n  [./k_clad]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.3'\n    args = 'temp'\n    block = 'clad'\n  [../]\n\n  [./rho_cool]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.0103111'\n    args = 'temp'\n    block = 'cool'\n  [../]\n  [./cp_cool]\n    type = ParsedMaterial\n    f_name = cp\n    function = '145.2432'\n    args = 'temp'\n    block = 'cool'\n  [../]\n  [./k_cool]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.12085239999999998'\n    args = 'temp'\n    block = 'cool'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 100\n  dt = 2e-7\n  #end_time = 100\n\n  nl_rel_tol = 1e-6\n  nl_abs_tol = 1e-6\n\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n  line_search = 'none'\n   # petsc_options_iname = '-snes_type'\n  # petsc_options_value = 'test'\n\n  nl_max_its = 30\n  l_max_its = 100\n  steady_state_detection = true\n  steady_state_tolerance = 1e-10\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Postprocessors]\n  [./max_temp_fuel]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'fuel'\n  [../]\n  [./max_temp_clad]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'clad'\n  [../]\n  [./max_temp_cool]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'cool'\n  [../]\n  [./min_temp_fuel]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'fuel'\n  [../]\n  [./min_temp_clad]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'clad'\n  [../]\n  [./min_temp_cool]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'cool'\n  [../]\n  [./average_temp_fuel]\n    type = ElementAverageValue\n    variable = temp\n    block = 'fuel'\n  [../]\n  [./average_temp_clad]\n    type = ElementAverageValue\n    variable = temp\n    block = 'clad'\n  [../]\n  [./average_temp_cool]\n    type = ElementAverageValue\n    variable = temp\n    block = 'cool'\n  [../]\n[]\n\n[VectorPostprocessors]\n  [./aa]\n    type = LineValueSampler\n    variable = 'temp'\n    start_point = '0.57 0 45'\n    end_point = '0.57 1.14 45'\n    num_points = 115\n    sort_by = y\n    execute_on = TIMESTEP_END\n  [../]\n[]\n\n[Outputs]\n  perf_graph = true\n  print_linear_residuals = true\n  [./exodus]\n    type = Exodus\n    file_base = 'thermal_time_diff_adv_heatsource'\n  [../]\n  [./csv]\n    type = CSV\n    file_base = 'thermal_time_diff_adv_heatsource'\n  [../]\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\nSince I use a software called Moltres, the ConservativeTemperatureAdvvection and TemperatureOutflowBC in the input file are in Moltres, so you may not be able to run this input file. But I posted the result of running it. Below are the average, maximum, and minimum temperatures of the fuel, cladding, and coolant sections, and plots of temperature versus y at x=0.57cm, z=45cm at 1e-5 seconds.\n\n\n\n\nIt stands to reason that, given the initial and boundary conditions, the fuel is always exothermic, and there should be no temperature drop in the entire system. But there is an unusual temperature drop in the picture. I would like to know why this is the case, is it necessary to set some conditions at the interface of fluid and solid in fluid-solid conjugate heat transfer ? Do I also need to set conditions for solid-to-solid heat transfer ?\nI also tried to calculate an extreme case where in addition to the time term, only the volume heat source term for the fuel part of the entire system. The input file is as follows (this one can be run by anyone who has installed MOOSE):\nini_temp = 593 # K\ncoolant_inlet_temp = 593 # K\n\n\n[Variables]\n  [./temp]\n    initial_condition = ${ini_temp}\n  [../]\n[]\n\n[Mesh]\n  file = 'model_finer.msh'\n[]\n\n[Kernels]\n  [./temp_time_derivative]\n    type = INSTemperatureTimeDerivative\n    variable = temp\n  [../]\n  [./temp_heat_source]\n    type = HeatSource\n    variable = temp\n    block = 'fuel'\n    value = 1e8\n  [../]\n[]\n\n[BCs]\n  [./temp_inlet_coolant]\n    type = DirichletBC\n    boundary = 'cool_inlet'\n    variable = temp\n    value = '${coolant_inlet_temp}'\n  [../]\n[]\n\n[Materials]\n  [./rho_fuel]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.010982399418993717'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n  [./cp_fuel]\n    type = ParsedMaterial\n    f_name = cp\n    function = '297.81083870424914'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n  [./k_fuel]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.059515513277033714'\n    args = 'temp'\n    block = 'fuel'\n  [../]\n\n  [./rho_clad]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.007667215971999999'\n    args = 'temp'\n    block = 'clad'\n  [../]\n  [./cp_clad]\n    type = ParsedMaterial\n    f_name = cp\n    function = '581.7254559999992'\n    args = 'temp'\n    block = 'clad'\n  [../]\n  [./k_clad]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.3'\n    args = 'temp'\n    block = 'clad'\n  [../]\n\n  [./rho_cool]\n    type = ParsedMaterial\n    f_name = rho\n    function = '0.0103111'\n    args = 'temp'\n    block = 'cool'\n  [../]\n  [./cp_cool]\n    type = ParsedMaterial\n    f_name = cp\n    function = '145.2432'\n    args = 'temp'\n    block = 'cool'\n  [../]\n  [./k_cool]\n    type = ParsedMaterial\n    f_name = k\n    function = '0.12085239999999998'\n    args = 'temp'\n    block = 'cool'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 100\n  dt = 2e-7\n  #end_time = 100\n\n  nl_rel_tol = 1e-6\n  nl_abs_tol = 1e-6\n\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n  line_search = 'none'\n   # petsc_options_iname = '-snes_type'\n  # petsc_options_value = 'test'\n\n  nl_max_its = 30\n  l_max_its = 100\n  steady_state_detection = true\n  steady_state_tolerance = 1e-10\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Postprocessors]\n  [./max_temp_fuel]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'fuel'\n  [../]\n  [./max_temp_clad]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'clad'\n  [../]\n  [./max_temp_cool]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = max\n    block = 'cool'\n  [../]\n  [./min_temp_fuel]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'fuel'\n  [../]\n  [./min_temp_clad]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'clad'\n  [../]\n  [./min_temp_cool]\n    type = ElementExtremeValue\n    variable = temp\n    value_type = min\n    block = 'cool'\n  [../]\n  [./average_temp_fuel]\n    type = ElementAverageValue\n    variable = temp\n    block = 'fuel'\n  [../]\n  [./average_temp_clad]\n    type = ElementAverageValue\n    variable = temp\n    block = 'clad'\n  [../]\n  [./average_temp_cool]\n    type = ElementAverageValue\n    variable = temp\n    block = 'cool'\n  [../]\n[]\n\n[VectorPostprocessors]\n  [./aa]\n    type = LineValueSampler\n    variable = 'temp'\n    start_point = '0.57 0 45'\n    end_point = '0.57 1.14 45'\n    num_points = 115\n    sort_by = y\n    execute_on = TIMESTEP_END\n  [../]\n[]\n\n[Outputs]\n  perf_graph = true\n  print_linear_residuals = true\n  [./exodus]\n    type = Exodus\n    file_base = 'thermal_time_heatsource'\n  [../]\n  [./csv]\n    type = CSV\n    file_base = 'thermal_time_heatsource'\n  [../]\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\nIt stands to reason that only the temperature of the fuel will rise in this case, and the temperature of the cladding and coolant will not change (because there is no heat conduction and advection heat transfer). But its calculation result is very, very similar to the previous one, I only post the result for the minimum temperature:\n\nI would like to know why this happens. The .msh file needed for the calculation and the .geo file to generate the meshes have been attached.\nThanks for any advice!\nmesh.zip",
          "url": "https://github.com/idaholab/moose/discussions/21251",
          "updatedAt": "2022-06-25T05:42:50Z",
          "publishedAt": "2022-06-09T15:35:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is pretty obviously a nuclear system and we cant really legally help you with modeling this kind of system.\nI'd encourage you to reach out to the moltres community for assistance.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21251#discussioncomment-2915493",
                  "updatedAt": "2022-06-09T17:04:12Z",
                  "publishedAt": "2022-06-09T17:04:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Can you give me some suggestions for fluid-structure coupling heat transfer calculations using MOOSE? This kind of calculation is actually very, very common, it happens in all fields. For example, water flows and transfers heat through pipes.",
                          "url": "https://github.com/idaholab/moose/discussions/21251#discussioncomment-2915540",
                          "updatedAt": "2022-06-09T17:10:32Z",
                          "publishedAt": "2022-06-09T17:10:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Given @GiudGiud 's answer, i don't think you're going to get any help here.  I have no experience in your type of model, but would something like this help?  https://mooseframework.inl.gov/source/kernels/PorousFlowHeatMassTransfer.html",
                          "url": "https://github.com/idaholab/moose/discussions/21251#discussioncomment-2917266",
                          "updatedAt": "2022-06-09T21:03:28Z",
                          "publishedAt": "2022-06-09T21:03:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thanks a lot, Andy. I'll read it carefully.",
                          "url": "https://github.com/idaholab/moose/discussions/21251#discussioncomment-2918208",
                          "updatedAt": "2022-06-10T00:31:41Z",
                          "publishedAt": "2022-06-10T00:31:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Accessing quadrature points of a feature to modify material properties",
          "author": {
            "login": "rayaprolu143"
          },
          "bodyText": "Hello,\nTo modify the material properties within a feature, I want to access the quadrature points of elements that are part of a feature (e.g., precipitate, bubble). I did try the method getVarToFeatureVector(_current_elem->id()) of the FeatureFloodCount to know if an element has any features, but I only ended up getting invalid id for every element. Could anyone provide me guidance to achieve the latter?\nThanks,\nSreekar",
          "url": "https://github.com/idaholab/moose/discussions/21066",
          "updatedAt": "2022-06-25T05:39:05Z",
          "publishedAt": "2022-05-22T12:53:32Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen @SudiptaBiswas",
                  "url": "https://github.com/idaholab/moose/discussions/21066#discussioncomment-2909810",
                  "updatedAt": "2022-06-09T01:38:44Z",
                  "publishedAt": "2022-06-09T01:38:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "getVarToFeatureVector gives you the grain_id to order parameter map for the element. If the element is within a bubble, you would get invalid_id.  Can you not identify the features by the active order parameter (or variable) values? We would need more information about what you are trying to implement to guide you toward the right approach.",
                          "url": "https://github.com/idaholab/moose/discussions/21066#discussioncomment-2917669",
                          "updatedAt": "2022-06-09T22:19:19Z",
                          "publishedAt": "2022-06-09T22:19:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mesh setting up message at the beginning of output",
          "author": {
            "login": "xueyang94"
          },
          "bodyText": "I sometimes randomly (but rarely) receive this message at the beginning of the output when running a moose input file. With this message, the simulation takes a long time to run. But when I ran the same input file for a second time, I don't receive the mesh setting message and everything is normal. Where does this message comes from and how to make sure the future run does not have this message? Thanks. -Xueyang",
          "url": "https://github.com/idaholab/moose/discussions/20940",
          "updatedAt": "2022-06-10T20:02:07Z",
          "publishedAt": "2022-05-03T15:17:43Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThese are messages from the live perf graph. It's outputting to let you know it's not stuck.\nhttps://mooseframework.inl.gov/source/utils/PerfGraph.html\nI imagine the Reading mesh ... is always there and the Updating mesh ... message is only sometimes there?\nAre you running with a distributed mesh?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2681229",
                  "updatedAt": "2022-06-10T20:02:07Z",
                  "publishedAt": "2022-05-03T15:39:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "The Reading mesh and Updating mesh either appear together or don't appear at all. In the latter case the output just starts with Framework Information. I am not using distributed mesh. The mesh is read from an exodus file and the variables are imported. This is strange because I am running a bunch of input files with everything else exactly the same except for one diffusion material property parameter. Within those input files, only one gave me the Setting Mesh info I showed above, and that one took much longer wall time. But I ran that one input again, it didn't show the mesh setting message and finished normally just like other files.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2681357",
                          "updatedAt": "2022-06-10T20:02:12Z",
                          "publishedAt": "2022-05-03T15:59:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is this on an HPC platform? Or a work computer?\nThese logs appearing/disappearing is tied to how fast you are loading the mesh basically. So if something is slowing down file IO outside of MOOSE that can trigger that.\nReading mesh in MOOSE is deterministic otherwise.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2681809",
                          "updatedAt": "2022-06-10T20:02:13Z",
                          "publishedAt": "2022-05-03T17:23:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "This particular batch of files was on HPC, but I have seen the same thing happened before on local machine. I don't think these logs appearing is an issue, the issue is that in all of the following iterations, each step takes far more wall time somehow. If something was slowing down the IO when I started the simulation, I would expect the simulation speed to catch up after a while. By ending the simulation and restarting immediately, the normal speed was recovered.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2682061",
                          "updatedAt": "2022-06-10T20:02:13Z",
                          "publishedAt": "2022-05-03T17:54:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so the whole simulation is slower when they appear?",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2682648",
                          "updatedAt": "2022-06-10T20:02:17Z",
                          "publishedAt": "2022-05-03T19:42:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "Correct.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2683769",
                          "updatedAt": "2022-06-10T20:02:18Z",
                          "publishedAt": "2022-05-04T00:22:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you can share your inputs I can see if I can reproduce this. But the fact that this affects the whole simulation and not parts of it points to an issue with either your machine or how moose is being ran rather than a buggy feature which would only be present in parts of the simulation.\nAre you running threads or MPI?",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2684321",
                          "updatedAt": "2022-06-10T20:02:17Z",
                          "publishedAt": "2022-05-04T04:24:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "I'm running MPI. On both cluster and my local machine, with that message, the simulation is slowed down. My input file imports mesh from an exodus file which is 25GB. How would you prefer me to share both the exodus and input file? Thanks for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2694874",
                          "updatedAt": "2022-06-10T20:02:17Z",
                          "publishedAt": "2022-05-05T15:43:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "That message appears because the simulation is slow I think, not the other way around.\nWith MPI a classic 2x slowdown is if two processes get bound to the same core. Or if you are using all the cores but one of the cores is busy doing something else for the system (often an issue on HPC).\nHow many processes are you using and how many cores are there on the machines?\nIf you can share those I can see if it's reproducible on INL HPC.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2694941",
                          "updatedAt": "2022-06-10T20:02:22Z",
                          "publishedAt": "2022-05-05T15:53:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "On my university HPC, for one simulation I request 8 nodes and 32 MPI processes. Each node has 2 CPU and 32 cores. So I use 16 CPU and 256 cores in total.\nMy local machine has 1 CPU and 8 cores in total. I use all cores to execute a simulation: mpirun -np 8 -opt -i.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2722953",
                          "updatedAt": "2022-06-10T20:02:22Z",
                          "publishedAt": "2022-05-10T14:13:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So you could send me the inputs by email. My email is on my github profile.\nWhat application do I need to run it? just moose?\nI ll see if I can reproduce the slowdown.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2755461",
                          "updatedAt": "2022-06-10T20:02:27Z",
                          "publishedAt": "2022-05-15T21:24:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@xueyang94 any luck finding the culprit?",
                  "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2909765",
                  "updatedAt": "2022-06-09T01:27:22Z",
                  "publishedAt": "2022-06-09T01:27:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "@GiudGiud I have emailed you back days ago. The printing of mesh setting messages and the subsequent slow down is most likely due to the machine being busy. Thanks for the help.",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2917177",
                          "updatedAt": "2022-06-09T20:46:06Z",
                          "publishedAt": "2022-06-09T20:46:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh sorry. Glad this is settled and thanks for letting me know",
                          "url": "https://github.com/idaholab/moose/discussions/20940#discussioncomment-2917235",
                          "updatedAt": "2022-06-09T20:59:33Z",
                          "publishedAt": "2022-06-09T20:59:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Thermal contact problems",
          "author": {
            "login": "Edward-Eth"
          },
          "bodyText": "Hi, I am wondering what the best approach to model conduction between two meshes that are in direct contact but are not meshed together is? I have tried using the thermal contact action, but setting the gap conductivity to the material conductivity (which seems like the correct thing to do in my case) results in a model that never converges/has to use incredibly small time steps. Am I using the wrong method? In the below input file gap_conductivity values greater than about 10e-6 will not converge, which is odd when my material conductivity is 8e-3.\n[Mesh]\n    [Top_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 2\n        ymax = 2\n        zmax = 2\n        xmin = 0\n        ymin = 0\n        zmin = 1\n        boundary_name_prefix = 'Upper'\n        boundary_id_offset = 10\n    []\n    [Bottom_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 2\n        ymax = 2\n        zmax = 1\n        boundary_name_prefix = 'Lower'\n    []\n    [Combine]\n        type = CombinerGenerator\n        inputs = 'Bottom_Block Top_Block'\n        positions = '0 0 0 0.12 0.12 0'\n    []\n    [Rename]\n        type = RenameBoundaryGenerator\n        input = Combine\n        old_boundary = '10 11 12 13 14 15'\n        new_boundary = 'Upper_back Upper_bottom Upper_right Upper_top Upper_left Upper_front'\n    []\n    [LowerSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = Rename\n        combinatorial_geometry = 'z<1'\n        block_id = 1\n        block_name = 'Lower_Block'\n    []\n    [UpperSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = LowerSubDomain\n        combinatorial_geometry = 'z>1'\n        block_id = 2\n        block_name = 'Upper_Block'\n    []\n[]\n\n[Variables]\n    [T]\n        block = '1 2'\n    []\n[]\n\n[ICs]\n    [T_Lower]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 1\n    []\n\n    [T_Upper]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 2\n    []\n[]\n\n[Kernels]\n    [HeatConduction]\n        type = HeatConduction\n        variable = T\n    []\n    [HeatConductionTimeDerivative]\n        type = HeatConductionTimeDerivative\n        variable = T\n    []\n[]\n\n[BCs]\n    [Heat_Out_Base]\n        type = ADDirichletBC\n        value = 293.0\n        variable = T\n        boundary = 'Lower_back'\n    []\n    [Heat_In_Top]\n        type = ADDirichletBC\n        value = 350.0\n        variable = T\n        boundary = 'Upper_front'\n    []\n[]\n\n[ThermalContact]\n  [thermal_contact]\n    type = GapHeatTransfer\n    variable = T\n    primary = 'Upper_back'\n    secondary = 'Lower_front'\n    emissivity_primary = 0\n    emissivity_secondary = 0\n    gap_conductivity = 1e-6\n    #quadrature = True\n    #gap_geometry_type = PLATE\n  []\n[]\n\n[Materials]\n    [./ti_material]\n        type = GenericConstantMaterial\n        prop_names = 'density thermal_conductivity poissons_ratio specific_heat'\n        prop_values = '4e-6 8e-3 0.3 560'\n        block = '1 2'\n    [../]\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    automatic_scaling = True\n    nl_abs_tol = 1e-3\n    nl_max_its = 50\n    l_max_its = 50\n    num_steps = 20\n    dt = 0.05\n[]\n\n[Outputs]\n    [outfile]\n        type = Exodus\n        file_base = \"ThermalGlueTest\"\n    []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/20830",
          "updatedAt": "2022-06-25T05:39:24Z",
          "publishedAt": "2022-04-21T10:35:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\ngap_geometry_type = PLATE should be correct in this case right? Does it help?\nWhat does the solution look like for the first few steps it converged? Is it going towards the right temperature gradient?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2610250",
                  "updatedAt": "2022-06-05T05:25:55Z",
                  "publishedAt": "2022-04-21T16:45:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Edward-Eth"
                  },
                  "bodyText": "Sorry for the very delayed response, I moved onto a different problem but have now come back to this issue. It seems that gap heat transfer, when used to conduct between contacting but not merged meshes, conducts a lot faster than it ought too. For example, in input file 1, the material has a conductivity of 0.0057, and the \"gap\" has a conductivity of 0.0000000057, which is 10^6 times smaller than than the material. Despite this, viewing the exodus file shows that the conductivity across the \"gap\" occurs barely slower than conduction through the material, so despite what should be a very insulating layer between the two blocks of mesh, conductivity between them is almost as quick as conduction within. This explains why using the same value for conductivity for the gap and the part causes issues, as this would result in extremely quick conduction making the sim unstable and stop it from converging.\nThis seems to be specifically an issue with gaps that are zero seperation, ie in contact, as when I increase the gap to equivalent to the element size in the mesh, using the same conductance in the gap as in the material works correctly, as seen in this image:\n\nThis model was stable with gap conductivity = material conductivity, however this doesn't resolve the problem of what conductivity value to use to conduct between disjoint meshes that are in perfect contact. This model is Input File 2.\nOne thought therefore would be to artificially add a small gap into the model between the two blocks of mesh, this was attempted in Input File 3. I found that at a gap of 1/10 mesh size the simulation was again unstable.\nBasically, it seems that the issue is the tool is designed for a gap heat transfer, so as the gap diminishes to zero the rate of heat transfer grows and in the contact case diverges to an unsolvable fast transfer. This makes sense for a gap, the smaller the gap the faster the transfer, but then means that zero gap is unsolvable. Am I just using the wrong tool for this?\n\n  Input File 1\n\n[Mesh]\n    [Top_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 20\n        xmin = 0\n        ymin = 0\n        zmin = 10\n        boundary_name_prefix = 'Upper'\n        boundary_id_offset = 10\n    []\n    [Bottom_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 10\n        boundary_name_prefix = 'Lower'\n    []\n    [Combine]\n        type = CombinerGenerator\n        inputs = 'Bottom_Block Top_Block'\n        positions = '0 0 0 0 0 0'\n    []\n    [LowerSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = Combine\n        combinatorial_geometry = 'z<=10'\n        block_id = 1\n        block_name = 'Lower_Block'\n    []\n    [UpperSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = LowerSubDomain\n        combinatorial_geometry = 'z>10'\n        block_id = 2\n        block_name = 'Upper_Block'\n    []\n[]\n\n[Variables]\n    [T]\n        block = '1 2'\n    []\n[]\n\n[ICs]\n    [T_Lower]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 1\n    []\n    [T_Upper]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 2\n    []\n[]\n\n[Kernels]\n    [HeatConduction]\n        type = HeatConduction\n        variable = T\n    []\n    [HeatConductionTimeDerivative]\n        type = HeatConductionTimeDerivative\n        variable = T\n    []\n[]\n\n[BCs]\n    [Heat_Out_Base]\n        type = ADDirichletBC\n        value = 293.0\n        variable = T\n        boundary = 'Lower_back'\n    []\n    [Heat_In_Top]\n        type = ADDirichletBC\n        value = 350.0\n        variable = T\n        boundary = 'Upper_front'\n    []\n[]\n\n[ThermalContact]\n  [thermal_contact]\n    type = GapHeatTransfer\n    variable = T\n    primary = 'Upper_back'\n    secondary = 'Lower_front'\n    emissivity_primary = 0\n    emissivity_secondary = 0\n    gap_conductivity = 0.0000000057\n    gap_geometry_type = PLATE\n  []\n[]\n\n[Materials]\n    [./ti_material]\n        type = GenericConstantMaterial\n        prop_names = 'density thermal_conductivity specific_heat'\n        prop_values = '0.0000045 0.0057 544'\n        block = '1 2'\n    [../]\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    automatic_scaling = True\n    nl_max_its = 50\n    l_max_its = 50\n    num_steps = 40\n    dt = 0.1\n[]\n\n[Outputs]\n    [outfile]\n        type = Exodus\n        file_base = \"SimpleThermalGlueTest\"\n        append_date = true\n    []\n[]\n\n\n\n  Input File 2\n# Thermal contact between two blocks, has issues with conductivity values anywhere near the conductivity of the material itself so not sure what's going on here.\n\n[Mesh]\n    [Top_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 9\n        xmax = 20\n        ymax = 20\n        zmax = 20\n        xmin = 0\n        ymin = 0\n        zmin = 11\n        boundary_name_prefix = 'Upper'\n        boundary_id_offset = 10\n    []\n    [Bottom_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 10\n        boundary_name_prefix = 'Lower'\n    []\n    [Combine]\n        type = CombinerGenerator\n        inputs = 'Bottom_Block Top_Block'\n        positions = '0 0 0 0 0 0'\n    []\n    [LowerSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = Combine\n        combinatorial_geometry = 'z<=10'\n        block_id = 1\n        block_name = 'Lower_Block'\n    []\n    [UpperSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = LowerSubDomain\n        combinatorial_geometry = 'z>10'\n        block_id = 2\n        block_name = 'Upper_Block'\n    []\n[]\n\n[Variables]\n    [T]\n        block = '1 2'\n    []\n[]\n\n[ICs]\n    [T_Lower]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 1\n    []\n\n    [T_Upper]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 2\n    []\n[]\n\n[Kernels]\n    [HeatConduction]\n        type = HeatConduction\n        variable = T\n    []\n    [HeatConductionTimeDerivative]\n        type = HeatConductionTimeDerivative\n        variable = T\n    []\n[]\n\n[BCs]\n    [Heat_Out_Base]\n        type = ADDirichletBC\n        value = 293.0\n        variable = T\n        boundary = 'Lower_back'\n    []\n    [Heat_In_Top]\n        type = ADDirichletBC\n        value = 350.0\n        variable = T\n        boundary = 'Upper_front'\n    []\n[]\n\n[ThermalContact]\n  [thermal_contact]\n    type = GapHeatTransfer\n    variable = T\n    primary = 'Upper_back'\n    secondary = 'Lower_front'\n    emissivity_primary = 0\n    emissivity_secondary = 0\n    gap_conductivity = 0.0057\n    gap_geometry_type = PLATE\n  []\n[]\n\n[Materials]\n    [./ti_material]\n        type = GenericConstantMaterial\n        prop_names = 'density thermal_conductivity specific_heat'\n        prop_values = '0.0000045 0.0057 544'\n        block = '1 2'\n    [../]\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    automatic_scaling = True\n    nl_max_its = 50\n    l_max_its = 50\n    num_steps = 40\n    dt = 0.1\n[]\n\n[Outputs]\n    [outfile]\n        type = Exodus\n        file_base = \"SimpleThermalGlueTest\"\n        append_date = true\n    []\n[]\n\n\n\n  Input File 3\n# Thermal contact between two blocks, has issues with conductivity values anywhere near the conductivity of the material itself so not sure what's going on here.\n\n[Mesh]\n    [Top_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 20\n        xmin = 0\n        ymin = 0\n        zmin = 10\n        boundary_name_prefix = 'Upper'\n        boundary_id_offset = 10\n    []\n    [Bottom_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 10\n        boundary_name_prefix = 'Lower'\n    []\n    [Combine]\n        type = CombinerGenerator\n        inputs = 'Bottom_Block Top_Block'\n        positions = '0 0 0 0 0 0.1'\n    []\n    [LowerSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = Combine\n        combinatorial_geometry = 'z<=10'\n        block_id = 1\n        block_name = 'Lower_Block'\n    []\n    [UpperSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = LowerSubDomain\n        combinatorial_geometry = 'z>10'\n        block_id = 2\n        block_name = 'Upper_Block'\n    []\n[]\n\n[Variables]\n    [T]\n        block = '1 2'\n    []\n[]\n\n[ICs]\n    [T_Lower]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 1\n    []\n\n    [T_Upper]\n        type = ConstantIC\n        value = 293.0\n        variable = T\n        block = 2\n    []\n[]\n\n[Kernels]\n    [HeatConduction]\n        type = HeatConduction\n        variable = T\n    []\n    [HeatConductionTimeDerivative]\n        type = HeatConductionTimeDerivative\n        variable = T\n    []\n[]\n\n[BCs]\n    [Heat_Out_Base]\n        type = ADDirichletBC\n        value = 293.0\n        variable = T\n        boundary = 'Lower_back'\n    []\n    [Heat_In_Top]\n        type = ADDirichletBC\n        value = 350.0\n        variable = T\n        boundary = 'Upper_front'\n    []\n[]\n\n[ThermalContact]\n  [thermal_contact]\n    type = GapHeatTransfer\n    variable = T\n    primary = 'Upper_back'\n    secondary = 'Lower_front'\n    emissivity_primary = 0\n    emissivity_secondary = 0\n    gap_conductivity = 0.0057\n    gap_geometry_type = PLATE\n  []\n[]\n\n[Materials]\n    [./ti_material]\n        type = GenericConstantMaterial\n        prop_names = 'density thermal_conductivity specific_heat'\n        prop_values = '0.0000045 0.0057 544'\n        block = '1 2'\n    [../]\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    automatic_scaling = True\n    nl_max_its = 50\n    l_max_its = 50\n    num_steps = 40\n    dt = 0.1\n[]\n\n[Outputs]\n    [outfile]\n        type = Exodus\n        file_base = \"SimpleThermalGlueTest\"\n        append_date = true\n    []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2768819",
                  "updatedAt": "2022-06-05T05:26:01Z",
                  "publishedAt": "2022-05-17T15:46:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@Edward-Eth can you specify the gap_distance parameter manually?\nthe behavior you are describing is consistent with determining the gap distance automatically. If the gap is pretty much closed, then it's not really slowing down heat transfer",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2770785",
                          "updatedAt": "2022-06-05T05:26:06Z",
                          "publishedAt": "2022-05-17T20:42:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Edward-Eth"
                          },
                          "bodyText": "If I specify zero I'm guessing it will still break though?",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2773824",
                          "updatedAt": "2022-06-05T05:26:06Z",
                          "publishedAt": "2022-05-18T08:09:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Edward-Eth"
                          },
                          "bodyText": "I'm looking for something like the mesh to mesh hard contact feature in nastran:(https://help.mscsoftware.com/bundle/MSC_Nastran_2020/page/Nastran_Combined_Book/non_linear/ch09/TOC.Thermal.Contact1.xhtml)\nThe temperature at each node on one surface is a combination of weighted temperatures from nodes on the opposite surface. Would this be more easily achieved with a matched value boundary condition or interface diffusion?",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2773892",
                          "updatedAt": "2022-06-05T05:26:06Z",
                          "publishedAt": "2022-05-18T08:19:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Edward-Eth"
                          },
                          "bodyText": "Not sure if this is relevant but what I'm modelling is actually one solid object, it's just that the mesh for two parts of it are disjoint, but what I'm trying to achieve is conduction as though they were one solid continuously meshed object. I've tried equal value boundary constraint but that seems to end up enforcing that the bottom of the top block should be the same temperature as the top of the bottom one, but never heats up the bottom one, so it effectively sets a dirichlet of the lower block's temperature on the underside of the top block.",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2775873",
                          "updatedAt": "2022-06-11T10:28:22Z",
                          "publishedAt": "2022-05-18T13:15:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "have you looked at the thermal contact action ?\nhttps://mooseframework.inl.gov/source/actions/ThermalContactAction.html",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2777181",
                          "updatedAt": "2022-05-18T15:58:08Z",
                          "publishedAt": "2022-05-18T15:58:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "interfaces are usually for internal sidesets so I m not sure interface diffusion is the right object. Which one are you think of?",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2777195",
                          "updatedAt": "2022-05-18T16:00:13Z",
                          "publishedAt": "2022-05-18T16:00:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Edward-Eth"
                          },
                          "bodyText": "have you looked at the thermal contact action ? https://mooseframework.inl.gov/source/actions/ThermalContactAction.html\n\nI used that for setting up the gap heat transfer in the first instance. Is there some other type within thermal contact action that would be more suitable? The ThermalContactSystem page (which thermal contact action recommends you look at for examples and parameters) is empty so there's not much to go on there...",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2781823",
                          "updatedAt": "2022-05-19T08:21:55Z",
                          "publishedAt": "2022-05-19T08:21:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "If you look at the parameters of this material: https://mooseframework.inl.gov/source/materials/GapConductance.html, you'll see options to define radiation and conductivity.\nInformation for similar radiation formulation: https://mooseframework.inl.gov/source/userobjects/GapFluxModelRadiation.html.\nFor conduction, you can provide a constant gap conductivity or a function. There are some additional factors that appear in the parameter section.",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2784244",
                          "updatedAt": "2022-05-19T14:48:05Z",
                          "publishedAt": "2022-05-19T14:48:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Edward-Eth"
                          },
                          "bodyText": "If you look at the parameters of this material: https://mooseframework.inl.gov/source/materials/GapConductance.html, you'll see options to define radiation and conductivity.\nInformation for similar radiation formulation: https://mooseframework.inl.gov/source/userobjects/GapFluxModelRadiation.html. For conduction, you can provide a constant gap conductivity or a function. There are some additional factors that appear in the parameter section.\n\nCircling back onto this issues and still not understanding how to get this to work. Here's my input file for trying to use the GapConductance material, but nothing happens that indicates there's any heat transfer from one mesh to the other. Not sure how I'm supposed to implement the GapConductance as there's no example input file. It's labelled as a material so I've put it in the materials block, but that seems odd to me.\nInput file:\n\n  Input File 1\n[Mesh]\n    [Top_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 20\n        xmin = 0\n        ymin = 0\n        zmin = 10\n        boundary_name_prefix = 'Upper'\n        boundary_id_offset = 10\n    []\n    [Bottom_Block]\n        type = GeneratedMeshGenerator\n        dim = 3\n        nx = 10\n        ny = 10\n        nz = 10\n        xmax = 20\n        ymax = 20\n        zmax = 10\n        boundary_name_prefix = 'Lower'\n    []\n    [Combine]\n        type = CombinerGenerator\n        inputs = 'Bottom_Block Top_Block'\n        positions = '0 0 0 0 0 0'\n    []\n    [LowerSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = Combine\n        combinatorial_geometry = 'z<=10'\n        block_id = 1\n        block_name = 'Lower_Block'\n    []\n    [UpperSubDomain]\n        type = ParsedSubdomainMeshGenerator\n        input = LowerSubDomain\n        combinatorial_geometry = 'z>10'\n        block_id = 2\n        block_name = 'Upper_Block'\n    []\n[]\n\n[Variables]\n    [T_Upper]\n        block = 2\n    []\n    [T_Lower]\n        block = 1\n    []\n[]\n\n[ICs]\n    [T_Upper_Initial]\n        type = ConstantIC\n        value = 293.0\n        variable = T_Upper\n        block = 2\n    []\n    [T_Lower_Initial]\n        type = ConstantIC\n        value = 293.0\n        variable = T_Lower\n        block = 1\n    []\n[]\n\n[Kernels]\n    [HeatConduction_Upper]\n        type = ADHeatConduction\n        variable = T_Upper\n        block = 2\n    []\n    [HeatConductionTimeDerivative_Upper]\n        type = ADHeatConductionTimeDerivative\n        variable = T_Upper\n        block = 2\n    []\n    [HeatConduction_Lower]\n        type = ADHeatConduction\n        variable = T_Lower\n        block = 1\n    []\n    [HeatConductionTimeDerivative_Lower]\n        type = ADHeatConductionTimeDerivative\n        variable = T_Lower\n        block = 1\n    []\n[]\n\n[BCs]\n    [Heat_Out_Base]\n        type = ADDirichletBC\n        value = 293.0\n        variable = T_Lower\n        boundary = 'Lower_back'\n    []\n    [Heat_In_Top]\n        type = ADDirichletBC\n        value = 350.0\n        variable = T_Upper\n        boundary = 'Upper_front'\n    []\n[]\n\n[Materials]\n    [./ti_material]\n        type = ADGenericConstantMaterial\n        prop_names = 'density thermal_conductivity specific_heat youngs_modulus poissons_ratio'\n        prop_values = '0.0000045 0.0057 544 1.16E+05 0.3'\n        block = '1 2'\n    [../]\n    [GapTransferMaybe]\n        type = GapConductance\n        variable = T_Upper\n        boundary = 'Upper_back'\n        paired_boundary = 'Lower_front'\n        gap_conductivity = 0.0057\n        emissivity_primary = 0.0\n        emissivity_secondary = 0.0\n        gap_geometry_type = PLATE\n        gap_temp = T_Lower\n        quadrature = True\n        warnings = True\n    []\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    automatic_scaling = True\n    nl_max_its = 50\n    l_max_its = 200\n    num_steps = 40\n    dt = 0.5\n[]\n\n[Outputs]\n    [outfile]\n        type = Exodus\n        file_base = \"ThermalContactTesting/SimpleThermalGlueTest\"\n        append_date = true\n    []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2906386",
                          "updatedAt": "2022-06-08T14:22:34Z",
                          "publishedAt": "2022-06-08T14:22:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I am not sure if you want to use or to implement a gap conductance model. If you want to use it, I'd just look into the tests in the MOOSE repository. For example, large_gap_heat_transfer_test_cylinder.i in the heat conduction module uses the thermal action to establish gap heat transfer physics in a problem:\n  [RPV_gap]\n    type = GapHeatTransfer\n    gap_geometry_type = 'CYLINDER'\n    emissivity_primary = 0.8\n    emissivity_secondary = 0.8\n    variable = Tsolid\n    primary = 'core_outer'\n    secondary = 'rpv_inner'\n    gap_conductivity = 0.1\n    quadrature = true\n    cylinder_axis_point_1 = '0 0 0'\n    cylinder_axis_point_2 = '0 0 5'\n  []\n[]\n\nThe action creates the gap conductance material, or a constant gap conductance, if a constant value is provided through the action -- this is typically done for many MOOSE physics.",
                          "url": "https://github.com/idaholab/moose/discussions/20830#discussioncomment-2907093",
                          "updatedAt": "2022-06-08T15:49:19Z",
                          "publishedAt": "2022-06-08T15:49:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cylindrical shell example",
          "author": {
            "login": "hrishiv"
          },
          "bodyText": "I was performing a simulation with a cylindrical shell model and got some errors so I decided to look into one of the test examples https://github.com/idaholab/moose/blob/next/modules/tensor_mechanics/test/tests/shell/static/pinched_cylinder_symm.i\nPinching of the cylinder is modeled by applying load at the side (1,0,1) in the X direction and the result is correct. Instead, I tried to simulate the same pinching in the Y direction by applying a load at the top (0,1,1) in the Y direction. I expected the displacement at the point of application of the load (0,1,1) in the Y direction in my simulation to be equal to the displacement in the X direction at the point of application of a load (1,0,1) of the example as I just changed the application of pinching force from the side to the top. However, I saw different results. Can someone please help me with this? Thank you in advance.",
          "url": "https://github.com/idaholab/moose/discussions/19580",
          "updatedAt": "2022-06-25T05:39:56Z",
          "publishedAt": "2021-12-08T15:21:41Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you please paste your updated DiracKernel for the source?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-1777046",
                  "updatedAt": "2022-06-09T12:57:51Z",
                  "publishedAt": "2021-12-09T06:42:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "or the whole input file if you have changed anything else",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-1777166",
                          "updatedAt": "2022-06-09T12:58:00Z",
                          "publishedAt": "2021-12-09T07:20:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "Hi, I just changed DiracKernel and the postprocessor.\n[DiracKernels]\n[./top]\ntype = ConstantPointSource\nvariable = disp_y\npoint = '0 1 1'\nvalue = -2.5 # P = 10\n[../]\n[]\n[Postprocessors]\n[./disp_y]\ntype = PointValue\npoint = '0 1 1'\nvariable = disp_y\n[../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-1780709",
                          "updatedAt": "2022-06-09T12:57:57Z",
                          "publishedAt": "2021-12-09T17:17:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This seems right. Not sure why the solution is not symmetric.\nGit blame says @sveerara and @bwspenc should know",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-1782722",
                          "updatedAt": "2022-06-09T12:58:03Z",
                          "publishedAt": "2021-12-10T00:00:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hrishiv"
                          },
                          "bodyText": "Also from what have I observed using shell elements in MOOSE in different orientations has been causing some issues. When I have a model like a box that would have shell elements in two perpendicular planes YZ and XZ, the solution is wrong (compared to ABAQUS) when I specify the same two rotation variables 'rotx' and 'roty' for both the planes. When I divided the model into two blocks and used 'rotz and roty' as the variables for a block in plane YZ and 'rotx and rotz' variables for the block in XZ plane I got displacements similar to ABAQUS for static case (I still have not got similar result for dynamic case using different block too).",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-1782793",
                          "updatedAt": "2022-06-09T12:58:13Z",
                          "publishedAt": "2021-12-10T00:33:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@jain651 any thoughts on this?",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-2909857",
                          "updatedAt": "2022-06-09T01:48:51Z",
                          "publishedAt": "2022-06-09T01:48:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jain651"
                          },
                          "bodyText": "Hrishiv is here at INL as an intern with us. We, including Ben, are looking at this problem together. We will post our findings with this problem as soon as possible.",
                          "url": "https://github.com/idaholab/moose/discussions/19580#discussioncomment-2914240",
                          "updatedAt": "2022-06-09T14:39:26Z",
                          "publishedAt": "2022-06-09T14:39:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "mooseInfo question",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "Is there a way for a message sent to mooseInfo() to output each time it's called? Looks like it's wrapped in a \"mooseDoOnce\" call which I assume does what it says?\nFor instance, I'm using a Terminator to cut the time step when a material model needs it (using MaterialTimeStepPostprocessor) and I'd like it to print the Terminator message each time rather than just the first time.",
          "url": "https://github.com/idaholab/moose/discussions/20932",
          "updatedAt": "2022-06-11T01:27:57Z",
          "publishedAt": "2022-05-02T18:02:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNot currently. We have a PR up to improve that system and be able to output things on a customizable schedule.\n#17897\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2675757",
                  "updatedAt": "2022-06-11T01:27:57Z",
                  "publishedAt": "2022-05-02T18:42:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Thanks. Looks like that PR is a bit old but I hope it gets through because the functionality would be useful.",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2676269",
                          "updatedAt": "2022-06-11T18:24:49Z",
                          "publishedAt": "2022-05-02T20:12:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If this PR doesnt make it in I ll make another one next week. We have a few users for this functionality at this point.",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2676352",
                          "updatedAt": "2022-07-10T05:24:34Z",
                          "publishedAt": "2022-05-02T20:30:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We're still working on it. I ll try to get you an update on this next week",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2755401",
                          "updatedAt": "2022-07-10T05:24:35Z",
                          "publishedAt": "2022-05-15T21:01:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this PR is stalled as its makers arent happy with it. I have another idea for this but will take some free time.",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2909753",
                          "updatedAt": "2022-06-09T01:23:41Z",
                          "publishedAt": "2022-06-09T01:23:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "btw we're not going to change mooseInfo's behavior. Use a _console output for your needs",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2909759",
                          "updatedAt": "2022-06-09T01:24:36Z",
                          "publishedAt": "2022-06-09T01:24:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Got it, thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/20932#discussioncomment-2913041",
                          "updatedAt": "2022-06-09T11:57:18Z",
                          "publishedAt": "2022-06-09T11:57:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}