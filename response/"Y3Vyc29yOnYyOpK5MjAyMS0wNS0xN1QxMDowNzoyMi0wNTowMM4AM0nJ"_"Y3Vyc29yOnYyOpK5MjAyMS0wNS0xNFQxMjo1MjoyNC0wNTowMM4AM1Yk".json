{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNS0xNFQxMjo1MjoyNC0wNTowMM4AM1Yk"
    },
    "edges": [
      {
        "node": {
          "title": "Help with contact",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "I've been playing unsuccessfully with contact for a few days now, its seems that for a given contact problem if I'm using displacement based input, i.e. I drive the bodies into contact by enforcing a time based displacment things generally work fine. When I come to do this with a force instead, I have immediate convergence failures. Could someone confirm the steps I should go through to turn a displacement based problem, into a force based problem?\nTake the example in modules/contact/test/tests/ring_contact, i turned this into a force based example and I have immediate convergence fails and -ve jacobians, usually the elements become hugely deformed (presumably) since they have a very large -ve y coordinate, e.g.\n  Elem Information\n   id()=0, unique_id()=322, processor_id()=0\n   type()=HEX20\n   dim()=3\n   n_nodes()=20\n    0  Node id()=0, processor_id()=0, Point=(x,y,z)=(       2, -3.78525e+15,      0.5)\n    DoFs=(0/0/0) (0/1/1) (0/2/2) (1/0/0) (1/1/1) (1/2/2) \n    1  Node id()=1, processor_id()=0, Point=(x,y,z)=(       2, -3.78525e+15,     -0.5)\n    DoFs=(0/0/3) (0/1/4) (0/2/5) (1/0/3) (1/1/4) (1/2/5) \n    2  Node id()=2, processor_id()=0, Point=(x,y,z)=(-211.815, -3.78525e+15,     -0.5)\n    DoFs=(0/0/6) (0/1/7) (0/2/8) (1/0/6) (1/1/7) (1/2/8) \n    3  Node id()=3, processor_id()=0, Point=(x,y,z)=(-216.919, -3.78525e+15,      0.5)\n    DoFs=(0/0/9) (0/1/10) (0/2/11) (1/0/9) (1/1/10) (1/2/11) \n    4  Node id()=4, processor_id()=0, Point=(x,y,z)=(0.694593, -3.78525e+15,      0.5)\n    DoFs=(0/0/12) (0/1/13) (0/2/14) (1/0/12) (1/1/13) (1/2/14) \n    5  Node id()=5, processor_id()=0, Point=(x,y,z)=(0.694593, -3.78525e+15,     -0.5)\n    DoFs=(0/0/15) (0/1/16) (0/2/17) (1/0/15) (1/1/16) (1/2/17) \n    6  Node id()=6, processor_id()=0, Point=(x,y,z)=(  -497.9, -3.78525e+15,     -0.5)\n    DoFs=(0/0/18) (0/1/19) (0/2/20) (1/0/18) (1/1/19) (1/2/20) \n    7  Node id()=7, processor_id()=0, Point=(x,y,z)=(-494.795, -3.78525e+15,      0.5)\n    DoFs=(0/0/21) (0/1/22) (0/2/23) (1/0/21) (1/1/22) (1/2/23) \n    8  Node id()=8, processor_id()=0, Point=(x,y,z)=(       2, -3.78525e+15, -1.71438)\n    DoFs=(0/0/24) (0/1/25) (0/2/26) (1/0/24) (1/1/25) (1/2/26) \n    9  Node id()=9, processor_id()=0, Point=(x,y,z)=(-84.9996, -3.78525e+15,     -0.5)\n    DoFs=(0/0/27) (0/1/28) (0/2/29) (1/0/27) (1/1/28) (1/2/29) \n    10  Node id()=10, processor_id()=0, Point=(x,y,z)=(-214.509, -3.78525e+15,  1.47086)\n    DoFs=(0/0/30) (0/1/31) (0/2/32) (1/0/30) (1/1/31) (1/2/32) \n    11  Node id()=11, processor_id()=0, Point=(x,y,z)=(-86.2479, -3.78525e+15,      0.5)\n    DoFs=(0/0/33) (0/1/34) (0/2/35) (1/0/33) (1/1/34) (1/2/35) \n    12  Node id()=12, processor_id()=0, Point=(x,y,z)=( 1.36808, -3.78525e+15,      0.5)\n    DoFs=(0/0/36) (0/1/37) (0/2/38) (1/0/36) (1/1/37) (1/2/38) \n    13  Node id()=13, processor_id()=0, Point=(x,y,z)=( 1.36808, -3.78525e+15,     -0.5)\n    DoFs=(0/0/39) (0/1/40) (0/2/41) (1/0/39) (1/1/40) (1/2/41) \n    14  Node id()=14, processor_id()=0, Point=(x,y,z)=(-369.114, -3.78525e+15,     -0.5)\n    DoFs=(0/0/42) (0/1/43) (0/2/44) (1/0/42) (1/1/43) (1/2/44) \n    15  Node id()=15, processor_id()=0, Point=(x,y,z)=(-367.026, -3.78525e+15,      0.5)\n    DoFs=(0/0/45) (0/1/46) (0/2/47) (1/0/45) (1/1/46) (1/2/47) \n    16  Node id()=16, processor_id()=0, Point=(x,y,z)=(0.694593, -3.78525e+15,  1.09482)\n    DoFs=(0/0/48) (0/1/49) (0/2/50) (1/0/48) (1/1/49) (1/2/50) \n    17  Node id()=17, processor_id()=0, Point=(x,y,z)=(-256.926, -3.78525e+15,     -0.5)\n    DoFs=(0/0/51) (0/1/52) (0/2/53) (1/0/51) (1/1/52) (1/2/53) \n    18  Node id()=18, processor_id()=0, Point=(x,y,z)=(-496.338, -3.78525e+15, -1.46908)\n    DoFs=(0/0/54) (0/1/55) (0/2/56) (1/0/54) (1/1/55) (1/2/56) \n    19  Node id()=19, processor_id()=0, Point=(x,y,z)=(-258.382, -3.78525e+15,      0.5)\n    DoFs=(0/0/57) (0/1/58) (0/2/59) (1/0/57) (1/1/58) (1/2/59) \n\nI did this using a nodal kernel on my real problem, and a body force on this one. Maybe I'm missing something fundamental?",
          "url": "https://github.com/idaholab/moose/discussions/17780",
          "updatedAt": "2022-07-12T14:04:47Z",
          "publishedAt": "2021-05-09T14:53:02Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad Can you help out please?",
                  "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-729551",
                  "updatedAt": "2022-07-12T14:04:56Z",
                  "publishedAt": "2021-05-12T14:40:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Looks like this is kinematic node-face contact. I think @bwspenc or maybe @recuero are better resources for this",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-729897",
                          "updatedAt": "2022-07-12T14:04:54Z",
                          "publishedAt": "2021-05-12T15:39:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "First thing I'd check is if you have rigid body modes in your problem. That can potentially happen when you go from controlling a body's displacement to just applying a force.",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-730035",
                          "updatedAt": "2022-07-12T14:04:56Z",
                          "publishedAt": "2021-05-12T16:04:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Not for the ring contact problem, but my 'real' problem I did fix the displacement of the moving body in the y direction to make sure it would move only down and out and nothing perpendicular, you would recommend a further constraint?",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-730057",
                          "updatedAt": "2022-07-12T14:04:56Z",
                          "publishedAt": "2021-05-12T16:07:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "If I understand well, you are fixing the directions perpendicular to the motion, so that makes sense to me. I'd also check that you are not getting rigid body rotations. Finally, when you apply the force, I'd make sure the surfaces are into contact. You can make this happen by using MOOSE's controls. You use displacement control until the bodies come (slightly) into contact, then, switch to force control.",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-730401",
                          "updatedAt": "2022-07-12T14:06:00Z",
                          "publishedAt": "2021-05-12T17:29:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Ah \"I'd make sure the surfaces are into contact. You can make this happen by using MOOSE's controls. You use displacement control until the bodies come (slightly) into contact, then, switch to force control.\" this could well be it, I have a large (by contact standards - 10 cm or so) between my components, which are fine when displaced. Its not clear how I would switch between displacement control and force control?",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-731014",
                          "updatedAt": "2022-07-12T14:06:04Z",
                          "publishedAt": "2021-05-12T20:44:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "You can define both the displacement BC and an external force. Then, when in contact, disable the displacement BC, and the body will be driven solely by the external force. A partial example below, documentation on MOOSE controls system here.\n  [period0]\n    type = TimePeriod\n    disable_objects = 'BCs::top_disp_z'\n    start_time = '1.0' \n    end_time = '70.0'\n    execute_on = 'initial timestep_begin linear nonlinear timestep_end'\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-731092",
                          "updatedAt": "2022-07-12T14:06:00Z",
                          "publishedAt": "2021-05-12T21:10:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Ah ok, thats helpful. A little painful though if there are lots of contacts, if we have a complex system, we often only have force based constraints, conceptually, driven displacements as a function of time are equivalent to the accelerations right? Shouldn't it be possible to determine the displacement given a force (acceleration)?",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-737894",
                          "updatedAt": "2022-07-12T14:06:02Z",
                          "publishedAt": "2021-05-14T10:41:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "driven displacements as a function of time are equivalent to the accelerations right?\n\nAre you referring to dynamics? In dynamics, if you apply a force, you'll get corresponding nodal accelerations and, given enough proximity between the bodies in contact, everything would work out. If you apply a force in quasi-static simulations, and there are rigid bodies in the system, results aren't usually good.\n\nShouldn't it be possible to determine the displacement given a force (acceleration)?\n\nIf you have contact, then you'll need to use contact formulations to determine the states and displacements of the nodes in contact.",
                          "url": "https://github.com/idaholab/moose/discussions/17780#discussioncomment-748396",
                          "updatedAt": "2022-07-12T14:06:39Z",
                          "publishedAt": "2021-05-17T14:34:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to install MOOSE on ARM64 HPC with Fujitsu A64FX cpu?",
          "author": {
            "login": "zhang-rite"
          },
          "bodyText": "Hi MOOSE developer,\nIs there a method for installing MOOSE on ARM64 HPC with Fujitsu A64FX CPU?\nFor the ARM64 architecture, the options for compiling may need to change but I don't know how to do it. I have tried following the installation guide hpc_install_moose but not successful.\nThe HPC has a Fujitsu compiler \"Fujitsu Development Studio\".\nGCC 11 may also work but I haven't tested it yet.\nDoes anyone have the experience? or give any suggestion? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/17855",
          "updatedAt": "2022-11-07T16:53:10Z",
          "publishedAt": "2021-05-17T08:50:08Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "We have no instructions for supporting ARM, but several folks over the years have successfully built MOOSE on such an architecture (Raspberry Pi, Beaglebone, etc). Almost always it will be about building everything from scratch (GCC, MPICH, their dependencies, etc). And when you do hit a failure along the way, you take those errors and look them up on the internet for a possible solution. Your google-fu will be tested!\nIt will certainly be an adventure, with no quick path forward...",
                  "url": "https://github.com/idaholab/moose/discussions/17855#discussioncomment-747970",
                  "updatedAt": "2022-11-07T16:53:10Z",
                  "publishedAt": "2021-05-17T12:58:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "I've built it on the cavium thunder x2, and it was fine, just stick to the gcc toolchain and I think you'll be fine.",
                          "url": "https://github.com/idaholab/moose/discussions/17855#discussioncomment-747999",
                          "updatedAt": "2022-11-07T16:53:10Z",
                          "publishedAt": "2021-05-17T13:04:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Shikhar installed MOOSE on an ARM 64 architecture and explained the steps in this thread\n#17416",
                  "url": "https://github.com/idaholab/moose/discussions/17855#discussioncomment-748307",
                  "updatedAt": "2022-11-07T16:53:44Z",
                  "publishedAt": "2021-05-17T14:15:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Simple subdomain remeshing",
          "author": {
            "login": "dealmeidavf"
          },
          "bodyText": "Hello,\nThis x-direction subdomain partition of the mesh\n[Mesh]\n  [generated_mesh]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 4\n    ny = 4\n  []\n  [block1]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 1\n    bottom_left = '0 0 0'\n    top_right = '0.5 1 0'\n    input = generated_mesh\n  []\n  [block2]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 2\n    bottom_left = '0.5 0 0'\n    top_right = '1 1 0'\n    input = block1\n  []\n[]\n\nleaves the blocks with equal number of elements (2x4). How do I change the number of elements in the x direction for each block?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/17853",
          "updatedAt": "2022-07-19T19:27:30Z",
          "publishedAt": "2021-05-16T19:25:49Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "The Cartesian mesh generator will do both block assignment and specifying the number of elements for each block.\nhttps://mooseframework.inl.gov/source/meshgenerators/CartesianMeshGenerator.html\nOr are you asking for the general mesh case?",
                  "url": "https://github.com/idaholab/moose/discussions/17853#discussioncomment-745471",
                  "updatedAt": "2022-07-19T19:27:31Z",
                  "publishedAt": "2021-05-16T19:39:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dealmeidavf"
                          },
                          "bodyText": "Thanks. I will check this option. I have been using SubdomainBoundingBoxGenerator for problems with interfaces as this is used in the examples. I suppose the CartesianMeshGenerator can also be used but I have not seen an example of interface problems using it.\nYes the question was for Cartesian meshes as generated by GeneratedMeshGenerator.",
                          "url": "https://github.com/idaholab/moose/discussions/17853#discussioncomment-745623",
                          "updatedAt": "2022-07-19T19:27:31Z",
                          "publishedAt": "2021-05-16T20:55:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dealmeidavf"
                          },
                          "bodyText": "It seems that CartesianMeshGenerator does not accept an elem_type parameter as GeneratedMeshGenerator does, therefore I can't use it with second order finite elements. I guess the way to do this is to create two meshes using GeneratedMeshGenerator and stitch them together?",
                          "url": "https://github.com/idaholab/moose/discussions/17853#discussioncomment-745777",
                          "updatedAt": "2022-07-19T19:27:38Z",
                          "publishedAt": "2021-05-16T22:29:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you can make it second order by specifying second_order = true under Mesh, so\n[Mesh]\n  second_order = true\n  [cmg]\n    type = CartesianMeshGenerator\n ...\n\ncould you please try that?\nStitching two meshes can also work",
                          "url": "https://github.com/idaholab/moose/discussions/17853#discussioncomment-746294",
                          "updatedAt": "2022-07-19T19:27:32Z",
                          "publishedAt": "2021-05-17T04:19:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dealmeidavf"
                          },
                          "bodyText": "I created two meshes with GeneratedMeshGenerator and stitched them with StitchedMeshGenerator.\nThanks for the help.",
                          "url": "https://github.com/idaholab/moose/discussions/17853#discussioncomment-748198",
                          "updatedAt": "2022-10-10T17:01:35Z",
                          "publishedAt": "2021-05-17T13:49:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "XCode 12.4 resulting in \"Clang frontend command failed due to signal compilation error\"",
          "author": {
            "login": "JoshuaHalsted"
          },
          "bodyText": "Hello,\nI am also having the same issues. However, when I uninstalled XCode 12.5 and installed XCode 12.4, I get essentially the same problem. I made sure that XCode was installed properly and was able to open the application.\nI've attached the complete output message when I try to run the \"make -j 4\" command as specified in the tutorial.\nThanks,\nJosh\nUsing HIT from /Users/joshhalsted/projects/moose/framework/contrib/hit\nCompiling C++ (in opt mode) /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.C...\nIn file included from /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.C:2:\nIn file included from /Users/joshhalsted/projects/moose/framework/src/linesearches/LineSearch.C:10:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/LineSearch.h:12:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/MooseObject.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/InputParameters.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/MooseUtils.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/HashMap.h:13:\nIn file included from /Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include/libmesh/threads.h:24:\nIn file included from /Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include/libmesh/libmesh_common.h:36:\nIn file included from /Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:85:\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/stdlib.h:142:34: error: unknown type name 'ldiv_t'\ninline _LIBCPP_INLINE_VISIBILITY ldiv_t div(long __x, long __y) _NOEXCEPT {\n^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/stdlib.h:143:12: error: no member named 'ldiv' in the global namespace\nreturn ::ldiv(__x, __y);\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/stdlib.h:146:34: error: unknown type name 'lldiv_t'\ninline _LIBCPP_INLINE_VISIBILITY lldiv_t div(long long __x,\n^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/stdlib.h:148:12: error: no member named 'lldiv' in the global namespace\nreturn ::lldiv(__x, __y);\n~~^\nIn file included from /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.C:2:\nIn file included from /Users/joshhalsted/projects/moose/framework/src/linesearches/LineSearch.C:10:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/LineSearch.h:12:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/MooseObject.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/InputParameters.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/MooseUtils.h:13:\nIn file included from /Users/joshhalsted/projects/moose/framework/build/header_symlinks/HashMap.h:13:\nIn file included from /Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include/libmesh/threads.h:24:\nIn file included from /Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include/libmesh/libmesh_common.h:36:\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:99:9: error: no member named 'size_t' in the global namespace\nusing ::size_t;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib\ud83d\udcaf9: error: no member named 'div_t' in the global namespace\nusing ::div_t;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:101:9: error: no member named 'ldiv_t' in the global namespace\nusing ::ldiv_t;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:103:9: error: no member named 'lldiv_t' in the global namespace\nusing ::lldiv_t;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:105:9: error: no member named 'atof' in the global namespace\nusing ::atof;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:106:9: error: no member named 'atoi' in the global namespace\nusing ::atoi;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:107:9: error: no member named 'atol' in the global namespace\nusing ::atol;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:109:9: error: no member named 'atoll' in the global namespace\nusing ::atoll;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:111:9: error: no member named 'strtod' in the global namespace\nusing ::strtod;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:112:9: error: no member named 'strtof' in the global namespace\nusing ::strtof;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:113:9: error: no member named 'strtold' in the global namespace\nusing ::strtold;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:114:9: error: no member named 'strtol' in the global namespace\nusing ::strtol;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:116:9: error: no member named 'strtoll' in the global namespace\nusing ::strtoll;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:118:9: error: no member named 'strtoul' in the global namespace\nusing ::strtoul;\n~~^\n/Users/joshhalsted/opt/anaconda3/envs/moose/bin/../include/c++/v1/cstdlib:120:9: error: no member named 'strtoull' in the global namespace\nusing ::strtoull;\n~~^\nfatal error: too many errors emitted, stopping now [-ferror-limit=]\nPLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace, preprocessed source, and associated run script.\nStack dump:\n0. Program arguments: x86_64-apple-darwin13.4.0-clang++ -march=core2 -mtune=haswell -std=gnu++17 -DNDEBUG -Wall -Wextra -DADFPARSER_INCLUDES=\"-I/Users/joshhalsted/projects/moose/framework/include/utils -I/Users/joshhalsted/projects/moose/framework/include/base -I/Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include\" -DMOOSE_TEST_ENABLED -march=core2 -mtune=haswell -mssse3 -ftree-vectorize -fPIC -fstack-protector-strong -O2 -pipe -stdlib=libc++ -fvisibility-inlines-hidden -std=c++14 -fmessage-length=0 -isystem /Users/joshhalsted/opt/anaconda3/envs/moose/include -O2 -felide-constructors -Qunused-arguments -Wunused-parameter -Wunused -fopenmp -DMETHOD=opt -Werror=return-type -Werror=reorder -Woverlength-strings -I/Users/joshhalsted/projects/moose/framework/build/header_symlinks -I/Users/joshhalsted/projects/moose/framework/contrib/boost/include -I/Users/joshhalsted/projects/moose/framework/contrib/json/include -I/Users/joshhalsted/projects/moose/framework/contrib/json/include/nlohmann -I/Users/joshhalsted/projects/moose/framework/contrib/mtwist/include -I/Users/joshhalsted/projects/moose/framework/contrib/pcre/include -I/Users/joshhalsted/projects/moose/framework/contrib/pugixml/include -I/Users/joshhalsted/projects/moose/framework/contrib/tinydir/include -I/Users/joshhalsted/projects/moose/framework/contrib/gtest -I/Users/joshhalsted/projects/moose/framework/contrib/hit -I/Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include -I/Users/joshhalsted/opt/anaconda3/envs/moose/libmesh-vtk/include/vtk-6.3 -D_THREAD_SAFE -pthread -I/Users/joshhalsted/opt/anaconda3/envs/moose/include -I/Users/joshhalsted/opt/anaconda3/envs/moose//include -I/Users/joshhalsted/projects/moose/test/build/header_symlinks -I/Users/joshhalsted/opt/anaconda3/envs/moose/libmesh/include -I/Users/joshhalsted/opt/anaconda3/envs/moose/libmesh-vtk/include/vtk-6.3 -D_THREAD_SAFE -pthread -I/Users/joshhalsted/opt/anaconda3/envs/moose/include -I/Users/joshhalsted/opt/anaconda3/envs/moose//include -MMD -MP -MF /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.x86_64-apple-darwin13.4.0.opt.lo.d -MT /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.x86_64-apple-darwin13.4.0.opt.lo -c /Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.C -fno-common -DPIC -o /Users/joshhalsted/projects/moose/framework/build/unity_src/.libs/linesearches_Unity.x86_64-apple-darwin13.4.0.opt.o -I/Users/joshhalsted/opt/anaconda3/envs/moose/include\nparser at end of file\n0 libLLVM-11.dylib 0x000000010d212c16 llvm::sys::PrintStackTrace(llvm::raw_ostream&) + 54\n1 libLLVM-11.dylib 0x000000010d211a08 llvm::sys::RunSignalHandlers() + 248\n2 libLLVM-11.dylib 0x000000010d212142 llvm::sys::CleanupOnSignal(unsigned long) + 258\n3 libLLVM-11.dylib 0x000000010d13a24e CrashRecoverySignalHandler(int) + 206\n4 libsystem_platform.dylib 0x00007fff2053dd7d _sigtramp + 29\n5 libclang-cpp.11.dylib 0x0000000109cde075 clang::EvaluatedExprVisitorBase<std::__1::add_pointer, (anonymous namespace)::DeferredDiagnosticsEmitter>::VisitStmt(clang::Stmt*) + 133\n6 libclang-cpp.11.dylib 0x0000000109703c5f clang::ASTContext::getBaseElementType(clang::QualType) const + 47\n7 libclang-cpp.11.dylib 0x0000000109cdd56a clang::StmtVisitorBase<std::__1::add_pointer, (anonymous namespace)::DeferredDiagnosticsEmitter, void>::Visit(clang::Stmt*) + 1418\n8 libclang-cpp.11.dylib 0x0000000109cde075 clang::EvaluatedExprVisitorBase<std::__1::add_pointer, (anonymous namespace)::DeferredDiagnosticsEmitter>::VisitStmt(clang::Stmt*) + 133\n9 libclang-cpp.11.dylib 0x0000000109cde075 clang::EvaluatedExprVisitorBase<std::__1::add_pointer, (anonymous namespace)::DeferredDiagnosticsEmitter>::VisitStmt(clang::Stmt*) + 133\n10 libclang-cpp.11.dylib 0x0000000109cde075 clang::EvaluatedExprVisitorBase<std::__1::add_pointer, (anonymous namespace)::DeferredDiagnosticsEmitter>::VisitStmt(clang::Stmt*) + 133\n11 libclang-cpp.11.dylib 0x0000000109cdcaef (anonymous namespace)::DeferredDiagnosticsEmitter::checkFunc(clang::SourceLocation, clang::FunctionDecl*) + 1695\n12 libclang-cpp.11.dylib 0x0000000109cd2bbb clang::Sema::emitDeferredDiags() + 379\n13 libclang-cpp.11.dylib 0x0000000109cd1e40 clang::Sema::ActOnEndOfTranslationUnitFragment(clang::Sema::TUFragmentKind) + 576\n14 libclang-cpp.11.dylib 0x0000000109cd2e59 clang::Sema::ActOnEndOfTranslationUnit() + 345\n15 libclang-cpp.11.dylib 0x00000001096e5de3 clang::Parser::ParseTopLevelDecl(clang::OpaquePtrclang::DeclGroupRef&, bool) + 1267\n16 libclang-cpp.11.dylib 0x000000010962970d clang::ParseAST(clang::Sema&, bool, bool) + 525\n17 libclang-cpp.11.dylib 0x000000010af0b5b8 clang::FrontendAction::Execute() + 104\n18 libclang-cpp.11.dylib 0x000000010ae9c721 clang::CompilerInstance::ExecuteAction(clang::FrontendAction&) + 2145\n19 libclang-cpp.11.dylib 0x000000010af7d06e clang::ExecuteCompilerInvocation(clang::CompilerInstance*) + 1998\n20 x86_64-apple-darwin13.4.0-clang++ 0x00000001094d8d53 cc1_main(llvm::ArrayRef<char const*>, char const*, void*) + 2131\n21 x86_64-apple-darwin13.4.0-clang++ 0x00000001094d6e35 ExecuteCC1Tool(llvm::SmallVectorImpl<char const*>&) + 357\n22 libclang-cpp.11.dylib 0x000000010ab376c7 void llvm::function_ref<void ()>::callback_fn<clang::driver::CC1Command::Execute(llvm::ArrayRef<llvm::Optionalllvm::StringRef >, std::__1::basic_string<char, std::__1::char_traits, std::__1::allocator >, bool) const::$_1>(long) + 23\n23 libLLVM-11.dylib 0x000000010d139fda llvm::CrashRecoveryContext::RunSafely(llvm::function_ref<void ()>) + 218\n24 libclang-cpp.11.dylib 0x000000010ab36a65 clang::driver::CC1Command::Execute(llvm::ArrayRef<llvm::Optionalllvm::StringRef >, std::__1::basic_string<char, std::__1::char_traits, std::__1::allocator >, bool) const + 405\n25 libclang-cpp.11.dylib 0x000000010ab03cf1 clang::driver::Compilation::ExecuteCommand(clang::driver::Command const&, clang::driver::Command const*&) const + 433\n26 libclang-cpp.11.dylib 0x000000010ab0426c clang::driver::Compilation::ExecuteJobs(clang::driver::JobList const&, llvm::SmallVectorImpl<std::__1::pair<int, clang::driver::Command const*> >&) const + 140\n27 libclang-cpp.11.dylib 0x000000010ab1ddec clang::driver::Driver::ExecuteCompilation(clang::driver::Compilation&, llvm::SmallVectorImpl<std::1::pair<int, clang::driver::Command const*> >&) + 428\n28 x86_64-apple-darwin13.4.0-clang++ 0x00000001094d67c8 main + 10264\n29 libdyld.dylib 0x00007fff20513f3d start + 1\nclang-11: error: clang frontend command failed due to signal (use -v to see invocation)\nclang version 11.0.0\nTarget: x86_64-apple-darwin13.4.0\nThread model: posix\nInstalledDir: /Users/joshhalsted/opt/anaconda3/envs/moose/bin\nclang-11: note: diagnostic msg:\nPLEASE ATTACH THE FOLLOWING FILES TO THE BUG REPORT:\nPreprocessed source(s) and associated run script(s) are located at:\nclang-11: note: diagnostic msg: /var/folders/qr/b09rm3rs6hz9c18pp3_301jm0000gn/T/linesearches_Unity-9916ec.cpp\nclang-11: note: diagnostic msg: /var/folders/qr/b09rm3rs6hz9c18pp3_301jm0000gn/T/linesearches_Unity-9916ec.sh\nclang-11: note: diagnostic msg: Crash backtrace is located in\nclang-11: note: diagnostic msg: /Users/joshhalsted/Library/Logs/DiagnosticReports/clang-11.crash\nclang-11: note: diagnostic msg: (choose the .crash file that corresponds to your crash)\nclang-11: note: diagnostic msg:\nmake: *** [/Users/joshhalsted/projects/moose/framework/build/unity_src/linesearches_Unity.x86_64-apple-darwin13.4.0.opt.lo] Error 1\n(moose) Joshs-MacBook-Air:test joshhalsted$",
          "url": "https://github.com/idaholab/moose/discussions/17850",
          "updatedAt": "2022-06-23T21:58:17Z",
          "publishedAt": "2021-05-15T23:23:54Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "JoshuaHalsted"
                  },
                  "bodyText": "I was able to resolve the problem. I had to dig around my drive using OmniDiskSweeper to find any evidence that a previous version of XCode was being used (even though I had uninstalled it and the CommandLineTools prior). There was a folder called \"Xcode\" in the /Library/Developer/CommandLineTools path, which I deleted (I didn't previously) and, upon full installation of 12.4, was able to successfully run the tests.",
                  "url": "https://github.com/idaholab/moose/discussions/17850#discussioncomment-743533",
                  "updatedAt": "2022-10-04T04:45:42Z",
                  "publishedAt": "2021-05-16T05:01:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "This is good to know! Thank you for posting!",
                          "url": "https://github.com/idaholab/moose/discussions/17850#discussioncomment-747979",
                          "updatedAt": "2022-10-04T04:45:45Z",
                          "publishedAt": "2021-05-17T13:00:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Adding a kernel with two or more variables",
          "author": {
            "login": "iampham"
          },
          "bodyText": "Hello,\nI've been trying to implement the following expression into my residual:\n\nwhere phi_i is the main \"variable\" in the sense of what you'd put in a default MOOSE kernel. However, I want to find the variational derivative of a function with respect to another variable phi_j, and add the term into the same residual that acts on the variable phi_i. These parameters are individually defined in the Variables system.\nAdding the variational derivative of F with respect to phi_i is already implemented in MOOSE's PhaseField module (AllenCahn.c). However, I believe I need to create my own file to add the variational derivative of F with respect to phi_j into the residual. This process doesn't seem trivial to me because I'm not familiar with what the constructors for a kernel do when they take variables as input.\nI have two questions regarding this process.\n\nDoes MOOSE create a unique residual for each variable defined in the variables system? Or do they get added into some global residual?\nHow can I add an additional variable as input into the kernel? If I do this, how can I refer to it in the .C file? For instance, a variable in a kernel usually gets referred to as _var.name(). If I add a second variable variable2, is there a get function that I can easily use?\n\nI've been poring through the documentation for an answer, but this seems like enough of an edge case to make it difficult to find. If you have a link to the relevant documentation, please let me know it!\nThank you for your help!\nEDIT: Just in case anybody stumbles across this problem, I found an additional useful page that describes how MOOSE variables work: https://mooseframework.inl.gov/source/variables/MooseVariableBase.html",
          "url": "https://github.com/idaholab/moose/discussions/17524",
          "updatedAt": "2022-06-15T14:05:10Z",
          "publishedAt": "2021-04-07T02:09:58Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "I will try answering your questions:\n\nresidual vector is composed of parts of number of variables, each for a primal (with respect to auxiliary) variable.\nnormal kernel can only evaluate residual contributions on local elements for one variable, specified by variable parameter. If you want a kernel to operate on multiple variables, you can consider array variable/kernel (documented here: https://mooseframework.inl.gov/source/variables/ArrayMooseVariable.html).\n\nHope these help.",
                  "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-582339",
                  "updatedAt": "2022-06-17T14:01:51Z",
                  "publishedAt": "2021-04-08T00:06:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "iampham"
                          },
                          "bodyText": "Thank you for the answer! I took a look at the documentation and I think this is what I had in mind.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-585040",
                          "updatedAt": "2022-06-17T14:01:53Z",
                          "publishedAt": "2021-04-08T13:53:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dzheng26"
                          },
                          "bodyText": "It is good that I find this discussion. I'm thinking about implemeningt a tensor mechanics kernel. In my case, I need disp_x, disp_y and disp_z as a vector together. I had a look of the current tensor mechanics kernel StressDivergenceTensors.C. It basically handles disp_x, disp_y and disp_z separately. The function computeOffDiagJacobian is used 9 times for each element for the combination of 3 variables disp_x, disp_y, and disp_z. It seems to be not the optimal way to do it and it also does not fit my need.\nWith the new Arraykernel, it seems to be a better kernel type for tensor mechanics. I should be able to implement my case. Is this the intension of this type of kernel? @YaqiWang",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-693960",
                          "updatedAt": "2022-06-17T14:02:17Z",
                          "publishedAt": "2021-05-04T15:37:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "We developed ArrayKernel for operating array variables that can potentially have hundreds of components. But I think it can find usages for with a few or several components. It can make relevant codes organized together thus easier to maintain. Even with a small number of components, we do not see performance degradation. So I think you can go ahead.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-694126",
                          "updatedAt": "2022-06-17T14:02:24Z",
                          "publishedAt": "2021-05-04T16:01:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dzheng26"
                          },
                          "bodyText": "Another questions: What is the difference between ArrayKernel and VectorKernel?  Is the variable used by them be used by things like BCs, Pressure, etc.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-694129",
                          "updatedAt": "2023-02-08T13:08:17Z",
                          "publishedAt": "2021-05-04T16:02:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Array kernels require array variables whose components must be in the same family and order. Vector kernels require a vector variable in a specific type with number of components being space dimension. I think vector kernels are designed for some specific problems, @lindsayad can possibly answer this better. We have BCs, kernels, etc. for both array and vector variables.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-694160",
                          "updatedAt": "2023-02-08T13:08:28Z",
                          "publishedAt": "2021-05-04T16:10:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@dzheng-conti I think you should use VectorKernel for vector version ofStressDivergenceTensors  because that is supposed to work with VectorVariable.  You can take a look at INSADMomentumViscous on how VectorKernel can be used.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-694162",
                          "updatedAt": "2023-02-08T13:08:28Z",
                          "publishedAt": "2021-05-04T16:11:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dzheng26"
                          },
                          "bodyText": "Thanks a lot! @YaqiWang  @jiangwen84",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-694178",
                          "updatedAt": "2023-02-08T13:08:29Z",
                          "publishedAt": "2021-05-04T16:13:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dzheng26"
                          },
                          "bodyText": "I had a look of the VectorKernal and ArrayKernal examples and I had another questions need your help.\nMy question is that can I use one component of a Vector or Array variable for the scalerKernel (scalerClass).\nIn tensormechanics module, there are many Classes defined for things like material models, pressure loads, contact etc. They all expect scaler (LAGRANGE) variables, say disp_x, disp_y, and disp_z. If I write a VectorKernel for  StressVivergenceTensors, it expects a vector (LAGRANGE_VEC) variable, say disp. If I want to use the already defined Classes in combination of my new VectorKernel, how can I let Moose know that disp_x, disp_y, and disp_z are the three components of disp?",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-719468",
                          "updatedAt": "2023-02-08T13:08:31Z",
                          "publishedAt": "2021-05-10T16:38:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I'd have to see your weak form to really understand what you want to do. But you can always create a vector in your computeQpResidual statement from scalar components like so:\nRealVectorValue disp_vec(_disp_x[_qp], _disp_y[_qp], _disp_z[_qp]);",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-725383",
                          "updatedAt": "2023-02-08T13:08:38Z",
                          "publishedAt": "2021-05-11T18:34:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dzheng26"
                          },
                          "bodyText": "@lindsayad. Thanks for the reply. I will try to explain what I mean with an example.\nCurrently in TensorMechanics module, all the classes are using standard variables. To do a simulation with gravity load for example, the input file is something like (I show the input file without using action)\n[Variables]\n  [./disp_x]\n    family = LAGRANGE\n  [../]\n  [./disp_y]\n    family = LAGRANGE\n  [../]\n  [./disp_z]\n    family = LAGRANGE\n  [../]\n[]\n[Kernels]\n  [elements_x]\n    type = StressDivergenceTensors\n    component = 0\n    variable = disp_x\n  []\n  [elements_y]\n    type = StressDivergenceTensors\n    component = 1\n    variable = disp_y\n  []\n  [elements_z]\n    type = StressDivergenceTensors\n    component = 2\n    variable = disp_z\n  []\n  [gravity_z]\n    type = Gravity\n    variable = disp_z\n    value = -1.0e-3\n    function = load\n  []\n[]\n\nThree standard variables are defined to representing the displacement vector. The variables are then used for StressDivergenceTensor and for Gravity. For one element, the computerOffDiagJacobian of StressDivergenceTensor is used 9 times (loops i_var=disp_x, disp_y, disp_z and j_var=disp_x, disp_y, disp_z) to compute the full jacobian. In other words, for Hex8 element, the full jacobian is a 24x24 matrix. Each call of  computerOffDiagJacobian  generates only an 8x8 submatrix of the full jacobian.\nFor my case,  I cannot compute the 8x8 submatrix for disp_x if disp_y and disp_z is not available. I need disp_x, disp_y and disp_z together so that I can calculate the 24x24 full jacobian in one call of computeJacobian.  I thought that I can write a VectorStressDivergenceTensor.  Then the input file can become something like\n[Variables]\n  [./dispvec]\n    family = LAGRANGE_VEC\n  [../]\n[]\n\n[Kernels]\n  [elements]\n    type = VectorStressDivergenceTensors\n    variable = dispvec\n  []\n[]\n\nThe full jacobian can be calculated with one call of computeJacobian since all three components are represented by dispvec\nMy problem come from the things like the Gravity kernel. There, variable= expects a standard variable representing displacement in one (say z) direction. With vector kernel, my displacement is defined as vector variable. Is there a way to pass one component of the vector variable dispvec to the Gravity kernel which needs a standard variable?\n[Variables]\n  [./dispvec]\n    family = LAGRANGE_VEC\n  [../]\n[]\n[Kernels] \n  ...\n  [gravity_z]\n    type = Gravity\n    variable = ? ## what should be here?\n    value = -1.0e-3\n    function = load\n  []\n[]\n\nWithout this function, it seems to me that I cannot use a vector kernel in combination of other classes in the TensorMechanics module which use standard variable. There are many of them (Gravity, Pressure, Contact, etc.) already defined. It is a lot of work if we have to rewrite them to use vector variable.\nIn fact, it should be also fine if we can use 3 standard variables instead of a vector variable for VectorKernel. Libmesh example \"examples/systems_of_equations/systems_of_equations_ex7\" seems did it this way.\nThanks for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/17524#discussioncomment-729213",
                          "updatedAt": "2023-02-08T13:08:39Z",
                          "publishedAt": "2021-05-12T13:36:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MultiApp Transfer to nearest node only",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Hi everyone,\n@lynnmunday , @cbolisetti , @rpodgorney , KT and I are working on simulating flow through fractured porous media using a MultiApp approach.  In this work, the \"fracture\" is a 2D mesh living within the \"matrix\", which is a 3D mesh.  The fracture nodes/elements don't usually conform with the matrix nodes/elements.\nI can pass information from the matrix to the fracture using, eg, MultiAppNearestNodeTransfer or MultiAppInterpolationTransfer.  These Transfers put a value at each node of the fracture mesh from the nearest node of the matrix mesh (or interpolate a few matrix values in the case of InterpolationTransfer).\nI need to pass information from the fracture to the matrix.  Physically, heat is flowing from the fracture to the matrix.  Each node of the fracture should pass information (heat) to one node of the matrix only : the matrix node nearest to the fracture node.  Using a MultiAppNearestNodeTransfer does not achieve this, for all nodes of the matrix get a value (heat) from their nearest fracture node.  There are other possibilities that would also work, for instance, passing information from each of the fracture nodes to nodes of the matrix element that contains the fracture node.  I also have to be careful that many fracture nodes may be close to a single matrix node (in which case the transferred thing - heat energy - would have to be summed, just like putting lots of DiracKernels inside a single element).  But before considering these subtleties, i wanted to ask:\nDoes MOOSE or one of its Apps have anything like this, or can you see another approach that would work ?\na",
          "url": "https://github.com/idaholab/moose/discussions/17806",
          "updatedAt": "2022-06-13T23:58:08Z",
          "publishedAt": "2021-05-12T00:45:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "vincentlaboure"
                  },
                  "bodyText": "Would MultiApps/*/bounding_box_padding help with your need?",
                  "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-729297",
                  "updatedAt": "2022-06-13T23:58:14Z",
                  "publishedAt": "2021-05-12T13:57:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Thanks @vincentlaboure - this might be the kind of thing i'm looking for.  I couldn't get it to work as desired in simple cases, but, regardless, in complicated-mesh cases, i suspected the \"padding\" and \"inflation\" would have to be dependent on the matrix mesh.  Eg, some of the fracture nodes might be very close to a matrix node, meaning the padding&inflation needs to be small for them, while other fracture nodes would need more padding&inflation because they're a long distance from any matrix node",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-731128",
                          "updatedAt": "2022-06-13T23:58:15Z",
                          "publishedAt": "2021-05-12T21:20:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@WilkAndy I had a similar (though different in a way) problem, need to compute and pass back and forth traction stresses from matrix elements to frac elements and the other way around (slip modelling). What I did was to compute (via an UO, but can be done in a Multiapp as well) a map among those and use that for passing the information.  In my case all is comforming, that is there are max 2 3D elements per each 2D elements, and the geometry does not change, but the map could be extended to more complicated cases (I fill in vectors of ids) and for evolving geometries (by running the map during run time and not on initialization as I am doing). The only caveat here is that my mapping is not 100% thread safe and so far works only on serial meshes (did not have enough time/man power to generalize it). In case I could share my piece of code (would be lovely to have it smarten). Hope this helps, mauro",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-732909",
                          "updatedAt": "2022-06-13T23:58:15Z",
                          "publishedAt": "2021-05-13T09:29:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Thank @mcacace , that could be good.  The team is meeting in about 12 hours and we'll discuss this in detail - i'll get back to you if we end up needing this feature.",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-732940",
                          "updatedAt": "2022-06-13T23:58:16Z",
                          "publishedAt": "2021-05-13T09:38:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Does DiracKernel work? It seems you have considered it but I am curious why it doesn't satisfy your needs.",
                  "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-733694",
                  "updatedAt": "2022-06-13T23:58:15Z",
                  "publishedAt": "2021-05-13T12:59:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "We are using the porousFlowHeatMassTransfer kernel where we apply the temperature difference between the fracture and matrix times a heat transfer coefficient.  It is easy to pass the temperature back and forth between the apps but if we use the diracKernel, we would need to compute a heat flux and pass that.  Maybe we could compute that from the temperature difference in the same way. Would you suggest making a diracKernel for each node on the subapp and passing that point along with a flux to the main app using a reporter?",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-735922",
                          "updatedAt": "2022-06-13T23:58:16Z",
                          "publishedAt": "2021-05-13T21:54:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Lynn, it doesn't have to be all that complicated. I took a look at PorousFlowHeatMassTransfer, basically all you want is a coupled variable v which is temperature or whatever information from the lower dimensional domain, right? There is a very simple trick to do that. It is very similar to an L2-projection, but you replace the source term with discrete approximations using DiracKernel.\nI quickly put together a test in moose, and it is performing well. I first manufacture a field (suppose that is the information from the lower dimensional domain), then I sample the field value at N points and reconstruct the field onto the matrix mesh using this trick. Some results are here:\n\nI am only using 20 elements in the matrix mesh, and with 64 sampling points from the lower dimensional domain, the error is already negligible. That corresponds to 2~3 points per element, which is pretty cheap. If you think this could work, we can discuss offline.",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736167",
                          "updatedAt": "2022-06-13T23:58:16Z",
                          "publishedAt": "2021-05-13T23:37:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Per our discussion, this is input file I used:\n[Mesh]\n  [gmg]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmax = 20\n    ymax = 1\n    nx = 20\n    ny = 1\n  []\n[]\n[Variables]\n  [T]\n  []\n[]\n[Kernels]\n  [react]\n    type = Reaction\n    variable = T\n  []\n[]\n[DiracKernels]\n  [projection]\n    type = VectorPostprocessorPointSource\n    variable = T\n    vector_postprocessor = data\n  []\n[]\n[VectorPostprocessors]\n  [data]\n    type = CSVReader\n    csv_file = data_${N}.csv\n    outputs = none\n  []\n  [T]\n    type = LineValueSampler\n    variable = T\n    start_point = '0 0.5 0'\n    end_point = '20 0.5 0'\n    num_points = 200\n    sort_by = x\n  []\n[]\n[Executioner]\n  type = Steady\n[]\n[Outputs]\n  file_base = T_${N}\n  [csv]\n    type = CSV\n    execute_vector_postprocessors_on = FINAL\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736210",
                          "updatedAt": "2022-06-13T23:58:17Z",
                          "publishedAt": "2021-05-14T00:02:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "@WilkAndy I think @hugary1995 method will be really easy to try out and I think its probably going to work better than a nodal transfer",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736244",
                          "updatedAt": "2022-10-18T18:24:20Z",
                          "publishedAt": "2021-05-14T00:15:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "How is this going to work for complicated fractures?  As i understand it, each fracture node becomes a DiracKernel in the matrix.  So it looks like you have to pre-define the position of each fracture (or fracture node), which will be difficult and annoying for users.  Also difficult when mesh adaptivity is used?",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736284",
                          "updatedAt": "2022-10-18T18:24:20Z",
                          "publishedAt": "2021-05-14T00:31:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "No, you only need to sample temperature at each quadrature points in the fracture mesh, then transfer the VPP to the main app. In main app, you only need ONE DiracKernel.",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736364",
                          "updatedAt": "2022-10-18T18:24:20Z",
                          "publishedAt": "2021-05-14T01:19:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "How do you sample the temperature at each qp of the fracture?  I'm thinking of a fracture with crazy geometry that can't be written as a simple function, so the qps will be thousands/millions of \"random\" points in space.  I think something is missing from my understanding - perhaps i don't understand how the matrix app knows where those points qps are.",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736383",
                          "updatedAt": "2022-10-18T18:24:20Z",
                          "publishedAt": "2021-05-14T01:31:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yeah we should back off a little bit...\nIn your original post, you were mentioning a 2D mesh representing \"fracture\". I was assuming there is a temperature field on your fracture mesh, and you are using the difference between the temperature on the fracture and the temperature on the matrix mesh to drive some transfer (which happens in your main app, i.e. on the matrix mesh).\nDid I understand something wrong?",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736422",
                          "updatedAt": "2022-10-18T18:24:20Z",
                          "publishedAt": "2021-05-14T01:55:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "This is correct.  The difficulty we're struggling with is that the 2D fracture physically transfers heat energy only to the 3D matrix elements that contain the 2D fracture nodes.  We can do that in two ways\n\nTransfer heat energy from the 2D fracture to the appropriate 3D matrix elements\nTransfer temperature information from the 2D fracture to the appropriate 3D matrix elements, and (this is the easy bit) let the matrix app figure out how much heat-energy that corresponds to.\n\nI believe your approach would Transfer the information to an appropriate DiracKernel in the matrix app.  But i don't know how this DiracKernel or VectorPostprocessor knows the positions of the fracture nodes or quadpoints.  What am I missing?",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736443",
                          "updatedAt": "2022-10-18T18:24:30Z",
                          "publishedAt": "2021-05-14T02:06:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay we are close. In the subapp (fracture mesh), you need to have a VPP or reporter that loop over all elements, sample the field (be it temperature or heat energy, or whatever) at each quadrature point (scaled appropriately with element volume), and store the location of the qp together with the sampled value in the VPP with the structure like:\nx,      y,       z,      value\n2.85,   0.52,    0.02,   0.826\n2.11,   3.13,    9.72,   11.96\n......\n\nThen you can use MultiAppVectorPostprocessorTransfer to transfer the data of the VPP from the subapp to the main app.\nIn the main app, you will use a structure similar to the input file I pasted above to reconstruct the sampled field from the subapp.\nIn the main app, you always only need one VectorPostprocessorPointSource DiracKernel. This DiracKernel will read information from the VPP, apply point sources at all points that you provided.\nI think it'll actually be easier to just sample and transfer the heat energy. Because, if you were to transfer temperature from fracture mesh to matrix mesh, you will end up with mostly zero temperature in the elements that do not intersect with the fracture mesh. You can probably do some smart things about that though, like only evaluating your PorousFlowHeatMassTransfer kernel on elements that intersect with the fracture mesh? But anyways, choosing what to transfer from subapp to main app is up to you, what I am describing is a general way of transferring information.",
                          "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-736480",
                          "updatedAt": "2022-10-18T18:24:42Z",
                          "publishedAt": "2021-05-14T02:26:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Let's take further discussion to issues #17854 or #17835, whichever is appropriate",
                  "url": "https://github.com/idaholab/moose/discussions/17806#discussioncomment-745928",
                  "updatedAt": "2022-06-13T23:58:22Z",
                  "publishedAt": "2021-05-17T00:17:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Not converged][Print Variable]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Dear moose users,\nI would like to know if there is any way to print variables that did not converge during the calculation?\nI want to analyze which variable causes the problem of convergence in my numerical model.\nBest regrads,\nQ",
          "url": "https://github.com/idaholab/moose/discussions/17837",
          "updatedAt": "2021-05-31T05:26:36Z",
          "publishedAt": "2021-05-14T04:56:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "simopier"
                  },
                  "bodyText": "Hi,\nYou can add the following block to your input file to see the residual for each variable of your model.\n[Debug]\n  show_var_residual_norms = true\n[../]\n\nIf the residuals are very different from each other, you might consider using scaling factors for your variables to help the convergence. It would look something like this:\n[Variables]\n  [./variable_1]\n    scaling = 1e3\n  [../]\n  [./variable_2]\n     scaling = 1\n  [../]\n[]\n\nYou might also benefit from automatic scaling. You can find information here. It consists of adding these lines in your executioner block:\nautomatic_scaling = true\ncompute_scaling_once = false\nverbose = true\n\nI hope that helps!",
                  "url": "https://github.com/idaholab/moose/discussions/17837#discussioncomment-738783",
                  "updatedAt": "2021-05-14T14:41:26Z",
                  "publishedAt": "2021-05-14T14:41:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "coskrrb2002"
                          },
                          "bodyText": "Dear simopier,\nIt helps me a lot!\nThank you for your advice!\nBest regards,\nQ",
                          "url": "https://github.com/idaholab/moose/discussions/17837#discussioncomment-743428",
                          "updatedAt": "2021-05-16T03:45:51Z",
                          "publishedAt": "2021-05-16T03:45:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "how to printout node number with std::cout",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "Dear MOOSE Team,\nI am working on debugging by printing variable \"flux_value\" using std::cout as:\nstd::cout << \" \" << _q_point[_qp]\n<< \" flux = \" << _flux_value[_qp]\n<< \" dt =\" << _dt << \" t =\" << _t\n<< std::endl;\nI am also trying to print the node number using \"_current_node\" but it is not working.\nPlease help.\nThomas",
          "url": "https://github.com/idaholab/moose/discussions/17803",
          "updatedAt": "2022-06-02T14:35:24Z",
          "publishedAt": "2021-05-11T19:47:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "The '<<' operator probably has not been defined for the type of _current_node (libmesh Node). You can print its attributes or you can use the already defined routines.\nSee libmesh Node\nNote that if you used a debugger instead I think you could just do p _current_node and get everything about it.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-725743",
                  "updatedAt": "2022-06-02T14:35:48Z",
                  "publishedAt": "2021-05-11T20:04:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you GiudGiud.\nNo. I am not using a debugger.\nI am still new to MOOSE.\nCould you please explain more about \"You can print its attributes or you can use the already defined routines?\"\nIt would be appreciated if you could give me an example(s).\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-725833",
                          "updatedAt": "2022-06-02T14:35:50Z",
                          "publishedAt": "2021-05-11T20:33:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "like you can do std::cout << _current_node.get_info() or .get_id()",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-725963",
                          "updatedAt": "2022-06-02T14:36:17Z",
                          "publishedAt": "2021-05-11T21:09:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "I am sorry Guillaume but\nstd::cout << _current_node.get_info()\nor\nstd::cout << _current_node.get_id()\nare not working for me. :(\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-726226",
                          "updatedAt": "2022-06-02T14:36:17Z",
                          "publishedAt": "2021-05-11T22:13:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "Why are you trying to get the node ID?\nAlso, it's a pointer:\nstd::cout << _current_node->id() << std::endl;",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-726229",
                          "updatedAt": "2024-10-26T20:55:50Z",
                          "publishedAt": "2021-05-11T22:15:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "styyokuda"
                  },
                  "bodyText": "Thank you Logan,\nBy some reason, \"std::cout << _current_node->id() << std::endl;\" is not\nworking for me. :(\nIn my program, coefficients are calculated and I am trying to make sure the\ncoefficients values are correct by printing them with the node number. If I\ndon't use \"std::cout,\" what do you recommend?\nPlease let me know.\nThomas\n\u2026\nOn Tue, May 11, 2021 at 3:15 PM Logan Harbour ***@***.***> wrote:\n Why are you trying to get the node ID?\n\n Also, it's a pointer:\n\n std::cout << _current_node->id() << std::endl;\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#17803 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ASQAPL7LMCOVJO3D234MOFTTNGUABANCNFSM44WWSS2Q>\n .",
                  "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-731230",
                  "updatedAt": "2022-06-02T14:36:41Z",
                  "publishedAt": "2021-05-12T21:53:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I believe it's get_id() you should be using. <- not true, see below\nI recommend you use a debugger. They are incredibly powerful and can be used with any software. You will find tutorials online, and there is more information for using them in MOOSE there",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-731457",
                          "updatedAt": "2022-06-02T14:36:50Z",
                          "publishedAt": "2021-05-12T23:03:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "No, std::cout << _current_node->id() << std::endl; should work. Please let us know what do you mean by \"is not working for me\", then we can help.",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-733713",
                          "updatedAt": "2022-06-02T14:36:48Z",
                          "publishedAt": "2021-05-13T13:04:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "styyokuda"
                  },
                  "bodyText": "Thank you very much, Gary.\nThe compiler error is: *use of undeclared identifier '_current_node';**did\nyou mean '_current_elem'?*\nstd::cout << _current_elem->id() << std::endl; is working but this printout\nis for element number, isn't it?\nMy MacBOOK Pro is still running on macOS Mojave and I have not updated\nMOOSE for more than a year\nbecause I believe a higher macOS operating system is required for the\nupdate.\nDo you think this is the reason?\n\nIt is not exactly debugging. Because I wrote C++ objects to calculate a\nnumber of coefficients and boundary fluxes (for BC settings)\nfor a heat transfer and concentration diffusion model.\nI thought I could print coefficients and fluxes along with temperatures and\nconcentrations on nodes on the screen with std::cout.\nPlease let me know if any other way is possible.\nI would like to thank you for your time and help.\nThomas\n\u2026\nOn Thu, May 13, 2021 at 6:04 AM Gary (Tianchen) Hu ***@***.***> wrote:\n No, std::cout << _current_node->id() << std::endl; should work. Please\n let us know what do you mean by \"is not working for me\", then we can help.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#17803 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ASQAPL2ZJ6IQCR6ITAMN7TTTNPE6VANCNFSM44WWSS2Q>\n .",
                  "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-736088",
                  "updatedAt": "2022-06-02T14:37:03Z",
                  "publishedAt": "2021-05-13T22:59:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok _current_node is not set for the class of kernel that you are using. You should work off the _current_elem and _qp index to retrieve the node if you need it.\nSee libmesh Elem doxygen for all the routines you can use.\nYou dont need to update your macOS to update moose.",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-736110",
                          "updatedAt": "2022-06-02T14:38:16Z",
                          "publishedAt": "2021-05-13T23:07:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you GiudGiud for your time and effort.\nBecause your suggestion seems to be too much work for me, I will look for other way to do that.\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17803#discussioncomment-740310",
                          "updatedAt": "2022-06-02T14:38:24Z",
                          "publishedAt": "2021-05-14T21:20:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Segment Fault for CNS Advection",
          "author": {
            "login": "ChrocheMisawa"
          },
          "bodyText": "Hello,\n  I'm current using the latest branch from @lindsayad , I was trying to produce some similar results for the model that I shown in #17760 . However, the code gives Segmentation fault error whenever I ran it with multiple cores, both for my input and the test input file at \"modules/navier_stokes/test/tests/finite_volume/cns/scalar_advection/mass-frac-advection.i\"\n\n  Both input file can run under single thread mode. (Although mine does not converge)\n\n  I wonder if the MPI feature is fully supported at this stage.\n\nFlow_Past_a_Cylinder_cns.zip\nThank you,\nZeyu Chen",
          "url": "https://github.com/idaholab/moose/discussions/17815",
          "updatedAt": "2022-06-21T01:11:15Z",
          "publishedAt": "2021-05-13T02:31:00Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad",
                  "url": "https://github.com/idaholab/moose/discussions/17815#discussioncomment-734542",
                  "updatedAt": "2022-06-21T01:11:15Z",
                  "publishedAt": "2021-05-13T16:09:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "I will try to take a look at this soon",
                  "url": "https://github.com/idaholab/moose/discussions/17815#discussioncomment-735254",
                  "updatedAt": "2022-06-21T01:11:15Z",
                  "publishedAt": "2021-05-13T18:48:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@ChrocheMisawa if you pull my most recent branch updates these should run now. There was an error in the number of ghost layers being used. Previously that input was generating one ghost layer when it needed two.",
                          "url": "https://github.com/idaholab/moose/discussions/17815#discussioncomment-739778",
                          "updatedAt": "2022-06-21T01:11:48Z",
                          "publishedAt": "2021-05-14T18:32:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "interface conditions",
          "author": {
            "login": "dealmeidavf"
          },
          "bodyText": "Hello,\nIs there a MOOSE documentation of a weak formulation involving interfaces that I can read about? I am interested in understanding, at the mathematical level, what MOOSE does when we code a class derived from InterfaceKernel. I believe MOOSE considers unknown variables in different subdomains as discontinuous across the interface. If the interface condition calls for continuity, this needs to be imposed weakly using an InterfaceKernel class. Is there another way to impose continuity at an interface?\nA related issue is the code:\n\n  \n    \n      moose/modules/heat_conduction/src/interfacekernels/ConjugateHeatTransfer.C\n    \n    \n        Lines 42 to 56\n      in\n      1585ebf\n    \n  \n  \n    \n\n        \n          \n           Real \n        \n\n        \n          \n           ConjugateHeatTransfer::computeQpResidual(Moose::DGResidualType type) \n        \n\n        \n          \n           { \n        \n\n        \n          \n             switch (type) \n        \n\n        \n          \n             { \n        \n\n        \n          \n               case Moose::Element: \n        \n\n        \n          \n                 return raw_value(_h[_qp]) * (_T_fluid[_qp] - _neighbor_value[_qp]) * _test[_i][_qp]; \n        \n\n        \n          \n            \n        \n\n        \n          \n               case Moose::Neighbor: \n        \n\n        \n          \n                 return raw_value(_h[_qp]) * (_neighbor_value[_qp] - _T_fluid[_qp]) * _test_neighbor[_i][_qp]; \n        \n\n        \n          \n            \n        \n\n        \n          \n               default: \n        \n\n        \n          \n                 return 0.0; \n        \n\n        \n          \n             } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nIf the temperature is continuous at the interface, this would make the return value of the residual equal to zero correct?\nThanks.\n--\nValmor",
          "url": "https://github.com/idaholab/moose/discussions/17828",
          "updatedAt": "2022-06-11T02:18:08Z",
          "publishedAt": "2021-05-13T16:26:49Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "InterfaceKernel allows you to implement a weak form at the interface by providing you the shape/test functions, variable values, etc at both sides of the interface. At the mathematical level, you need to derive your weak form baed on your interfacial condition. It can be used to enforce continuity condition, like PenaltyInterfaceDiffusion.C, or transfer heat from one domain to another, like ConjugateHeatTransfer.C.\nFor your second question, if the temperature is continuous, the residual will be zero. Physically, it means there is no heat transfer if two domains have the same temperature across the interface.",
                  "url": "https://github.com/idaholab/moose/discussions/17828#discussioncomment-736637",
                  "updatedAt": "2022-06-11T02:18:35Z",
                  "publishedAt": "2021-05-14T03:17:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dealmeidavf"
                          },
                          "bodyText": "From this signature:\n\nReal\nConjugateHeatTransfer::computeQpResidual(Moose::DGResidualType type)\n{\n\nI take it the test function of the interface condition is discontinuous on finite elements. Correct?\nAlso on your last comment, even with continuous temperature there may still exist a non-zero heat flux; hence heat transfer can occur. The gradient of temperature at the interface is the deciding factor.\nI don't seem to be able to find a Galerkin weak formulation for interfacial problems in the MOOSE site/distribution. It would be instructive to have one or be directed to one.\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/17828#discussioncomment-739430",
                          "updatedAt": "2022-06-11T02:18:36Z",
                          "publishedAt": "2021-05-14T16:50:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "ConjugateHeatTransfer is not used to enforce temperature continuity across the interface unless the heat transfer coefficient is large enough (then it becomes the penalty parameter). It actually applies a Neumann boundary condition to both sides of the interface where the flux is defined as _h[_qp]) * (_T_fluid[_qp] - _neighbor_value[_qp]). The flux is always the same but opposite at two sides of the interface, so the flux is continuous. When there is no temperature jump, the flux becomes zero and it would apply a zero flux BC.\nSounds like this might not be what you would like to use for your application. If you could let us know what interfacial conditions you would like to apply, we can help on the weak form derivation and implementation.\nFor your first question, I believe interfaceKernel can be used on both continuous or discontinuous interface. It depends on whether your mesh is continuous or not across the interface.",
                          "url": "https://github.com/idaholab/moose/discussions/17828#discussioncomment-739631",
                          "updatedAt": "2022-06-11T02:19:31Z",
                          "publishedAt": "2021-05-14T17:52:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}