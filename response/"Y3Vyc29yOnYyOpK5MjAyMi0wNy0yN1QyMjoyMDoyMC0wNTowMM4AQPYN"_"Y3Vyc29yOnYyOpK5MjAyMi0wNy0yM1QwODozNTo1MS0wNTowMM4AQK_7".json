{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNy0yM1QwODozNTo1MS0wNTowMM4AQK_7"
    },
    "edges": [
      {
        "node": {
          "title": "The pattern for face numbers for element and neighbor",
          "author": {
            "login": "ambehnam"
          },
          "bodyText": "Hello there. I have a question regarding the face numbers for element and neighbor. What pattern MOOSE/Libmesh uses to define _neighbor_side and _current_side?\nFrom the HEX8 element, the local node numbers are defined in the documentation. However, I couldn't find how the faces are numbered and set for _neighbor_side and _current_side.\nI have a 2 element model with an interface between them. The _current_side value is 2, and I expected the _neighbor_side to be 1, so  the two will be back to back and have opposite faces. But the _neighbor_side value is 4. What is the reason for this?\nThanks a lot,\nAmir",
          "url": "https://github.com/idaholab/moose/discussions/21697",
          "updatedAt": "2022-07-27T13:53:59Z",
          "publishedAt": "2022-07-26T18:59:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI looked at the doxygen and the answer is here:\nhttps://libmesh.github.io/doxygen/classlibMesh_1_1Hex8.html#ae6fd20a71114610dac6b527498248007\nside 1 is made of nodes {0, 3, 2, 1},\nside 2 of nodes  {0, 1, 5, 4},\netc\nThis is HEX8, it ll be different for each element type\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21697#discussioncomment-3257324",
                  "updatedAt": "2022-07-27T04:46:53Z",
                  "publishedAt": "2022-07-27T04:46:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Generator that combines node/element sets?",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "Hi all -\nIs there a MeshGenerator that takes multiple node sets or element sets as input and combines them into a single, new set?",
          "url": "https://github.com/idaholab/moose/discussions/21682",
          "updatedAt": "2022-08-13T16:12:31Z",
          "publishedAt": "2022-07-25T19:21:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can use the RenameBoundary and RenameBlock Generator to combine node / respectively element sets\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21682#discussioncomment-3225960",
                  "updatedAt": "2022-07-25T20:51:22Z",
                  "publishedAt": "2022-07-25T20:51:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Does that keep the old sets intact?",
                          "url": "https://github.com/idaholab/moose/discussions/21682#discussioncomment-3240555",
                          "updatedAt": "2022-07-26T17:55:01Z",
                          "publishedAt": "2022-07-26T17:55:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no.\nwhy do you need to combine them?\nwe write most objects such that one can pass inputs like 'sideset1 sideset2' and it ll still work",
                          "url": "https://github.com/idaholab/moose/discussions/21682#discussioncomment-3241363",
                          "updatedAt": "2022-07-26T18:01:36Z",
                          "publishedAt": "2022-07-26T18:01:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "I'm trying to read in Abaqus mesh files, which have this combining feature built-in, so I'm looking for an equivalent in MOOSE. I may be able to use your solution as long as individual node/element sets are not referred to.",
                          "url": "https://github.com/idaholab/moose/discussions/21682#discussioncomment-3242230",
                          "updatedAt": "2022-07-26T18:09:14Z",
                          "publishedAt": "2022-07-26T18:09:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MOOSE Framework Website Down",
          "author": {
            "login": "BenjaminWillisINL"
          },
          "bodyText": "Hello, I went to look at some syntax on the MOOSE Framework website and noticed that the entire website is down. Is there anyway to remedy this? Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/21692",
          "updatedAt": "2022-07-26T15:06:34Z",
          "publishedAt": "2022-07-26T14:25:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "mooseframework.inl.gov is available again.",
                  "url": "https://github.com/idaholab/moose/discussions/21692#discussioncomment-3232128",
                  "updatedAt": "2022-07-26T15:07:36Z",
                  "publishedAt": "2022-07-26T15:06:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A question about simulating a contracting ring",
          "author": {
            "login": "xuxiaobei1995"
          },
          "bodyText": "Hi all,\nI want to simulate a contracting ring by increasing its inner radius but not changing its outer radius, just like what the figure below shows. Directly setting the displacement BC at the inner bound is not OK because I don't want this contract to cause extra stress respond. Does any one know how to realize this? One of my thoughts is to derive the after-contract position (xe, ye) of any point (x, y) to get the displacement field u(x, y) = (xe, ye) - (x, y). Then we can get the strain tensor \u03b5ij = 0.5 * (\u2202ui/\u2202xj + \u2202uj/\u2202xi) to construct an eigen strain material to realize the contract. Is this approach correct?",
          "url": "https://github.com/idaholab/moose/discussions/21672",
          "updatedAt": "2022-07-26T00:34:40Z",
          "publishedAt": "2022-07-24T07:48:45Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Firstly, whatever you do, make sure you solve this using RZ coordinates in MOOSE.\nSecondly, i don't understand how you can deform the annulus and maintain stress=0.  The only stress=0 solution is when the displacement is zero (except for rigid-body movement).  Generally, when displacement!=0 then stress!=0.  i think i'm fundamentally misunderstanding something here.  Can you explain further?  Eg, do you also have temperature?",
                  "url": "https://github.com/idaholab/moose/discussions/21672#discussioncomment-3215605",
                  "updatedAt": "2022-07-24T10:20:02Z",
                  "publishedAt": "2022-07-24T10:20:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "My understanding is that if we can give the ring an eigen strain that make it contract \"uniformly\", it may maintain stress = 0, just like a uniform thermal expansion process.  More specifically, if we can guarantee that the relative position of each point in the ring is not changed during the contract process (r1/r2 = r3/r4 in the figure), the stress may not be generated. Is this a wrong idea?",
                          "url": "https://github.com/idaholab/moose/discussions/21672#discussioncomment-3215889",
                          "updatedAt": "2022-07-24T11:58:31Z",
                          "publishedAt": "2022-07-24T11:58:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I think i don't have enough imagination to understand at the moment.  Where does this eigenstrain come from?  In your thermal expansion example, the eigenstrain comes from a temperature change, so while the stress=0, some other property (the temperature) has changed, which causes the displacement.  So, in your example, what's the other property that's going to change and cause displacement != 0.  Clearly, the displacement will depend on that property.  (For instance, if it were temperature and your annulus had anisotropic or heterogeneous thermal-expansion properties, then the displacement could be quite complicated compared with the isotropic, homogeneous case.)",
                          "url": "https://github.com/idaholab/moose/discussions/21672#discussioncomment-3217340",
                          "updatedAt": "2022-07-24T20:28:26Z",
                          "publishedAt": "2022-07-24T20:28:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "Maybe what I said before is ambiguous ... In fact, my aim is just to find a way to change the geometry condition of the domain with time. More specifically, the user can specify the inner radius varying with time Rin(t) and the geometry will be changed with time in the simulation depending on Rin(t) while the outer radius is not changed. Since it is a pure geometry effect, I don't want this change to generate stress respond.\nI think a possible way to realize this function is to create a NEW eigen strain for the material so that the annulus will deform as what Rin(t) describes with no stress respond. But how the annulus deforms with no stress respond?  my thought is that if the deformation is \"uniform\", the extra stress may not be generated, just like the uniform thermal expansion process. the \"uniform\" here means the relative position of each point in the ring is not changed during the contract process (r1/r2 = r3/r4 in the figure). So based on this geometry relation, we can get the displacement field u(x,y,Rin(t)), then we can get the eigen strain tensor \u03b5ij = 0.5 * (\u2202ui/\u2202xj + \u2202uj/\u2202xi), based on which the new eigen strain object (e.g., ComputeContractEigenStrain) will be developed. The inputs of the eigen strain object are Rin(t) and Rout. Do you think this approach is reasonable?",
                          "url": "https://github.com/idaholab/moose/discussions/21672#discussioncomment-3220481",
                          "updatedAt": "2022-07-25T09:33:56Z",
                          "publishedAt": "2022-07-25T09:33:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I might be understanding your question.  Is this true: you know that in real life, the deformation you describe will result in stress!=0, but you want to trick MOOSE so that it thinks stress=0 ?   If so, then i think just create your EigenStrain as you describe above.",
                          "url": "https://github.com/idaholab/moose/discussions/21672#discussioncomment-3225913",
                          "updatedAt": "2022-07-25T20:42:28Z",
                          "publishedAt": "2022-07-25T20:42:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "That is exactly what I meant. Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/21672#discussioncomment-3226825",
                          "updatedAt": "2022-07-26T00:34:05Z",
                          "publishedAt": "2022-07-26T00:34:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "the weak form in kobayashi module",
          "author": {
            "login": "CGH20171006"
          },
          "bodyText": "I can not correctly derive the weak form in the kobayshi model.The process is as follows:\n\nThe weak form in the READEME as follows:",
          "url": "https://github.com/idaholab/moose/discussions/21676",
          "updatedAt": "2022-08-13T16:13:26Z",
          "publishedAt": "2022-07-25T11:09:23Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "CGH20171006"
                  },
                  "bodyText": "and could you tell me why it is not necessary to define eps and deps in the \\projects\\moose\\modules\\phase_field\\examples\\anisotropic_interfaces\\ad_snow.i \uff1f",
                  "url": "https://github.com/idaholab/moose/discussions/21676#discussioncomment-3221465",
                  "updatedAt": "2022-07-25T11:51:10Z",
                  "publishedAt": "2022-07-25T11:51:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "CGH20171006"
                          },
                          "bodyText": "Let me rephrase the question, how do I modify the formulas for eps and deps in that example (e.g. change the isotropic factor from 4 to 2)",
                          "url": "https://github.com/idaholab/moose/discussions/21676#discussioncomment-3224177",
                          "updatedAt": "2022-07-25T16:26:20Z",
                          "publishedAt": "2022-07-25T16:26:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "eps and deps are material properties, so you may modify them there.\nhttps://mooseframework.inl.gov/syntax/Materials/\nIf you just want to add a factor you could just use an ADParsedMaterial for that\nhttps://mooseframework.inl.gov/source/materials/ParsedMaterial.html",
                          "url": "https://github.com/idaholab/moose/discussions/21676#discussioncomment-3224209",
                          "updatedAt": "2022-07-25T16:29:10Z",
                          "publishedAt": "2022-07-25T16:29:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "CGH20171006"
                          },
                          "bodyText": "eps and deps are material properties, so you may modify them there. https://mooseframework.inl.gov/syntax/Materials/ If you just want to add a factor you could just use an ADParsedMaterial for that https://mooseframework.inl.gov/source/materials/ParsedMaterial.html OK,I got you,I find that in materials/ADInterfaceOrientationMaterial.C,thank you so much!",
                          "url": "https://github.com/idaholab/moose/discussions/21676#discussioncomment-3224303",
                          "updatedAt": "2022-07-25T16:39:12Z",
                          "publishedAt": "2022-07-25T16:39:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "CGH20171006"
                  },
                  "bodyText": "I can not correctly derive the weak form in the kobayshi model.The process is as follows: \nThe weak form in the READEME as follows: \n\nI still do not know how to derive this weak form : (",
                  "url": "https://github.com/idaholab/moose/discussions/21676#discussioncomment-3224522",
                  "updatedAt": "2022-07-25T17:01:55Z",
                  "publishedAt": "2022-07-25T17:01:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to output variables in source codes to exodus file",
          "author": {
            "login": "pshen20127"
          },
          "bodyText": "Hello all\nI hope to output a variable 'equivalent_slip_increment' in the file 'ComputeMultipleCrystalPlasticityStress.C' when running the simulation. I directly add a AuxVariable in input file as below. But the output value is zero. What should I do to fix it? Thanks. (Input file 'polycrystal.txt' is attached)\n\n\n\n\npolycrystal.txt",
          "url": "https://github.com/idaholab/moose/discussions/21585",
          "updatedAt": "2022-07-25T16:13:54Z",
          "publishedAt": "2022-07-14T04:07:26Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "Hi @pshen20127,\nThe Rank-2 tensor equivalent_slip_increment is a local variable and the RankTwoAux auxvariable works with those Rank-2 tensors that are declared as material properties. See the declaration of the plastic_deformation_gradient in ComputeMultiCrystalPlasticityStress here: \n  \n    \n      moose/modules/tensor_mechanics/src/materials/crystal_plasticity/ComputeMultipleCrystalPlasticityStress.C\n    \n    \n         Line 82\n      in\n      3bb5876\n    \n  \n  \n    \n\n        \n          \n           _plastic_deformation_gradient(declareProperty<RankTwoTensor>(\"plastic_deformation_gradient\")), \n        \n    \n  \n\n\nIf you would like to monitor the change in plastic strain, the plastic_deformation_gradient may be a good option. If you would like to monitor the slip increment on individual slip systems, the vector slip_incrementwould be a good option. Use the AuxKernel MaterialStdVectorAux as shown in this regression test input file: https://github.com/idaholab/moose/blob/next/modules/tensor_mechanics/test/tests/crystal_plasticity/stress_update_material_based/update_method_test.i\nFinally, please post input file snippets as quoted text, not as screenshots, as outlined in the posting guidelines here: #18270\nHope this helps!",
                  "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3147723",
                  "updatedAt": "2022-07-14T14:35:11Z",
                  "publishedAt": "2022-07-14T14:35:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "Hi Thank you for reply. Very useful. Is there a way to output plastic strain instead of plastic deformation gradient?",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3148264",
                          "updatedAt": "2022-07-14T15:40:55Z",
                          "publishedAt": "2022-07-14T15:40:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "There is not a direct way to output the plastic strain. When I have wanted to determine the plastic strain, I output the total strain (e.g. total_lagrangian_strain), monitor the plastic deformation gradient diagonal terms for when the value changes from 1.0 (larger or smaller depends on the loading conditions and the location in the diagonal). I take the value of the total strain, at the timestep before the plastic deformation gradient changes from 1.0, as the elastic strain. Finally, I subtract that value of elastic strain from the total strain, at timesteps after the plastic deformation changes from 1.0, to determine the plastic strain.\nNote that this method assumes no eigenstrain in the simulation.",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3148505",
                          "updatedAt": "2022-07-14T16:06:02Z",
                          "publishedAt": "2022-07-14T16:06:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "Nice. My output elastic strain is always zero. Do you know what's wrong with my setting(please see attached input file)? And is there a way to output true stress and strain?\npolycrystal.txt",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3149084",
                          "updatedAt": "2022-07-14T17:26:56Z",
                          "publishedAt": "2022-07-14T17:26:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "part a) I can take a look at your input file next week but I won't have time until then\npart b) Yes, use the material properties stress (the Cauchy stress) and total_strain",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3149252",
                          "updatedAt": "2022-07-14T17:48:50Z",
                          "publishedAt": "2022-07-14T17:48:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "No problem. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3150394",
                          "updatedAt": "2022-07-14T21:19:28Z",
                          "publishedAt": "2022-07-14T21:19:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Hi @pshen20127,\nThe elastic strain in your simulation is reported as zero because we do not save the calculated Green-Lagrange strain tensor  (defined with respect to the reference configuration) as a material property--turns out this is the same issue as with the equivalent_slip_increment tensor. In the crystal plasticity classes we have made the choice to not save this value to the elastic_strain variable because that strain measure is the Almansi strain tensor (defined with respect to the current configuration and the work conjugate of the Cauchy stress).\nThe elastic Green-Lagrange strain is defined locally in the ComputeMultipleCrystalPlasticityStress class here and the line 523 below: \n  \n    \n      moose/modules/tensor_mechanics/src/materials/crystal_plasticity/ComputeMultipleCrystalPlasticityStress.C\n    \n    \n         Line 522\n      in\n      4cb06f1\n    \n  \n  \n    \n\n        \n          \n           elastic_strain = ce - RankTwoTensor::Identity(); \n        \n    \n  \n\n\nIf you wanted to output that variable, you could define a new material property for that Green-Lagrange elastic strain within the ComputeMultipleCrystalPlasticityStress, and, if you wanted, contribute that change back to the MOOSE repository. As many members of the MOOSE team say, we accept merge requests :-)\nA final note: I saw in your input file that you are using only two displacement variables, disp_x and disp_y, and thus are essentially running a 2D simulation. Are you intended to use a crystal plasticity model in a 2D simulation?",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3193334",
                          "updatedAt": "2022-07-20T23:28:31Z",
                          "publishedAt": "2022-07-20T23:28:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pshen20127"
                          },
                          "bodyText": "Hi sapitts, yes, it's a 2D simulation. And thanks for your deteailed and very useful explanation.",
                          "url": "https://github.com/idaholab/moose/discussions/21585#discussioncomment-3224038",
                          "updatedAt": "2022-07-25T16:13:54Z",
                          "publishedAt": "2022-07-25T16:13:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Electromagnetics Module Based on edge element or node element\uff1f",
          "author": {
            "login": "AdelineHunter"
          },
          "bodyText": "Hi,\nIs the Electromagnetics Module developed based on the edge element method? Or based on the node element method\uff1f\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/21673",
          "updatedAt": "2022-08-13T16:13:37Z",
          "publishedAt": "2022-07-24T12:25:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "If you choose to solve the vector fields component-wise, you can use node elements. If you solve them directly as vectors, you use edge elements (specifically, Nedelec first order). See the benchmark examples for general module usage, and most of those use the edge element.",
                  "url": "https://github.com/idaholab/moose/discussions/21673#discussioncomment-3218508",
                  "updatedAt": "2022-07-25T03:13:59Z",
                  "publishedAt": "2022-07-25T03:09:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "One more note - you could use LAGRANGE_VEC type elements. That's just a vector of Lagrange node elements. Can be useful for transitioning an input file from component-wise to full vector.",
                          "url": "https://github.com/idaholab/moose/discussions/21673#discussioncomment-3218517",
                          "updatedAt": "2022-07-25T03:15:48Z",
                          "publishedAt": "2022-07-25T03:15:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Convergence Criterion",
          "author": {
            "login": "Krystalfang"
          },
          "bodyText": "Dear Expert,\nI recently tried to use MOOSE to simulate the conjugate heat transfer, but encountered the problem of non-convergence, so I want to ask what is the convergence criterion of MOOSE,  I set nl_rel_tol = 1e-6.\n\nBut it has been calculated until 10^-7, and the residuals of each variable are also less than 10^-6. The result is still not convergent, why is this?",
          "url": "https://github.com/idaholab/moose/discussions/21653",
          "updatedAt": "2022-08-13T16:14:08Z",
          "publishedAt": "2022-07-21T01:57:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "You are mixing absolute and relative tolerance up. Try setting nl_abs_tol = 1e-6. Your setting requires the initial residual to drop by 6 orders of magnitude, which is not always possible, if you start out with an initial guess that is very close to the solution.",
                  "url": "https://github.com/idaholab/moose/discussions/21653#discussioncomment-3193897",
                  "updatedAt": "2022-07-21T02:00:58Z",
                  "publishedAt": "2022-07-21T02:00:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "The default convergence criteria are listed as the default parameters to the Executioner here:\nhttps://mooseframework.inl.gov/source/executioners/Steady.html\nPlease post a full log rather than these screenshots so we can see what is going on with the convergence history",
                  "url": "https://github.com/idaholab/moose/discussions/21653#discussioncomment-3218499",
                  "updatedAt": "2022-07-25T03:08:27Z",
                  "publishedAt": "2022-07-25T03:08:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MOOSE IGA",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "I've been doing some 'playing' with the recently merged IGA capabilities, which is great, I've been leveraging Coreform Cubit to generate the IGA relevant exodus files. One of the problems I've been playing with is a cylinder problem, one of the things I've noticed is that it I'm not getting the resolution I would expect from the output data, like its correct, but the output resolution seems to be tied to the underlying hex elements, rather than the highly curved elements originating from the IGA. I guess this is because its not clear how VTK should handle it, or is there a remap stage I should go through to get a better representation in plotting the data?\nAre other things supported as in 'regular' mesh, such as contact, I guess ray tracing doesn't work? I've not tried, but I'm sure someone is in the know.",
          "url": "https://github.com/idaholab/moose/discussions/21642",
          "updatedAt": "2022-08-13T16:14:32Z",
          "publishedAt": "2022-07-20T10:14:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@roystgnr",
                  "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3188990",
                  "updatedAt": "2022-07-20T13:08:59Z",
                  "publishedAt": "2022-07-20T13:08:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "I'm afraid right now there's two alternatives for IGA output: \"VTK 9\", or \"absolutely anything else\".  With the \"absolutely anything else\" option, we output Rational-Bernstein-Bezier control points as if they were Lagrange nodes, and yet no, no they aren't.  It's still useful for debugging a solution or visualizing the coarse features of a solution but not for any kind of post-processing.\nWith VTK 9 (or possibly 9.1?  see #21449), the Coreform folks added code for us to output rational elements natively in VTK (their own work on that end too! - https://www.kitware.com/implementation-of-rational-bezier-cells-into-vtk/ ).  I'm not sure how robust this is (I was getting failures from it locally, and we don't have the tests running in our regular CI...) however, and on top of that there's the problem that you need your viz program to also support rational elements.  IIRC Paraview is the only visualizer that supports rational curves so far, and you might need still need to put in some work on that side for proper support: https://discourse.paraview.org/t/nonlinear-subdivision-for-rational-bezier-curves-not-working/6522",
                  "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3190492",
                  "updatedAt": "2022-07-20T15:41:36Z",
                  "publishedAt": "2022-07-20T15:41:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Thanks for the reply, so I would compile libmesh with vtk 9.0, then that should be enough to get an appropriate vtk file out - possibly? Then build my own Paraview with vtk 9.0? Looking at one of the linked issues, I guess that would also allow MOOSE to export to VTK using the lagrangian FE elements for better represenation of 2nd order elements and results?",
                          "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3193095",
                          "updatedAt": "2022-07-20T22:16:04Z",
                          "publishedAt": "2022-07-20T22:16:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "msederberg"
                          },
                          "bodyText": "Do these details help? https://mooseframework.inl.gov/modules/tensor_mechanics/examples/cframe_iga.html",
                          "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3207154",
                          "updatedAt": "2022-07-22T15:13:30Z",
                          "publishedAt": "2022-07-22T15:13:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GregVernon"
                  },
                  "bodyText": "@makeclean - Do you have a screenshot that shows what you're seeing?  I believe it's a known issue atm that the Exodus export from MOOSE isn't supported for these IGA analyses.  Using the VTK output should allow you to specify the nonlinear subdivision level (see below).\nTo set the nonlinear subdivision level on a ParaView pipeline object:\n\nIn the Properties browser make sure the Advanced Properties are active\n\nScroll down to the Miscellaneous section where you'll see Nonlinear Subdivision Level\n\nI often find 4 to be sufficient and a good compromise with performance\n\nExample\nNonlinear subdivision level = 1 (default)\n\nNonlinear subdivision level = 4 (my recommendation)\n\nRendering higher-order elements with edges\nThere is an outstanding bug regarding rendering higher-order elements as Surface with Edges (see discussion here and here).  The workaround is to essentially create a duplicate of your data and render one as a Surface and the other as a Wireframe.  Creating the duplicate can either be done with some \"zero-op\" filters or by loading your data twice.\n\n\nSurface with Edges bug\n\n\n\nSurface with Edges workaround",
                  "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3207216",
                  "updatedAt": "2022-07-22T15:21:33Z",
                  "publishedAt": "2022-07-22T15:21:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "That's massively helpful thanks @GregVernon the only thing I would add to that documentation @msederberg is regarding the configuration of libmesh needing the vtk part, so making sure to build VTK with MPI support and the MPI group support being TRUE, then building libmesh using those libraries, otherwise - very smooth :)",
                          "url": "https://github.com/idaholab/moose/discussions/21642#discussioncomment-3214108",
                          "updatedAt": "2022-07-23T23:04:10Z",
                          "publishedAt": "2022-07-23T23:04:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unable to run split preconditioning",
          "author": {
            "login": "amosaha"
          },
          "bodyText": "When using the example provided by the official website of the split module, the problem in the figure appears. How should I solve it?",
          "url": "https://github.com/idaholab/moose/discussions/21670",
          "updatedAt": "2022-08-13T16:14:56Z",
          "publishedAt": "2022-07-23T00:30:21Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe [Splits] syntax isnt supported syntax outside of phase_field I think, but field splits are still definitely possible.\nRename this block as Preconditioning.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21670#discussioncomment-3212452",
                  "updatedAt": "2022-07-23T13:47:12Z",
                  "publishedAt": "2022-07-23T13:35:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}