{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wOS0yOFQxMDoyOToyOC0wNTowMM4ANuKQ"
    },
    "edges": [
      {
        "node": {
          "title": "p-refinement",
          "author": {
            "login": "whiffee"
          },
          "bodyText": "Hi All,\nI see in Moose example ex05 mesh adaptivity is demonstrated, but I can't tell whether it is h- or p-refinement.\nI notice that in the examples in the libMesh repository the distinction is clearly stated. Does/can Moose take\nadvantage of this choice? How would that change the input file?",
          "url": "https://github.com/idaholab/moose/discussions/18984",
          "updatedAt": "2022-06-06T14:18:04Z",
          "publishedAt": "2021-10-02T21:48:53Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nMoose does h-refinement with the unifom_refine options (or with adaptivity). Uniform refinement can be used by specifying -r xx on the command line or by adding uniform_refine = xx to the [Mesh] block.\nAdaptivity and mesh generators allow you to tune the mesh refinement more than just a uniform refinement.\nYou can do p-refinement manually by changing the FE family order in the [Variables] block.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1419851",
                  "updatedAt": "2022-06-06T14:18:09Z",
                  "publishedAt": "2021-10-03T02:27:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "whiffee"
                  },
                  "bodyText": "I'm sort of stuck with the mesh I have, a hex mesh. I've tried .inp import and it seems to work.\nI realize I probably wasn't ready to ask a question about this. However, since I already have,\nI'm supposing a variables block like\n[Variables]\n  order = FOURTH\n  family = LAGRANGE\n\n[]\nwould turn on p-refinement, with a maximum basis order of 4. But how would the decision be made\nas to which element quality would be assigned which order?\nthanks for your patience\nGary",
                  "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1421335",
                  "updatedAt": "2022-06-06T14:18:11Z",
                  "publishedAt": "2021-10-03T15:43:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "moose can refine that mesh (h-refinement) for you, with the options I listed. It doesnt matter that it's imported from a .inp file for refinement.\nThis p-refinement would only work if the mesh can accomodate such a high order variable, eg if it has all the extra points in each element.\n@roystgnr will know more than me here",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1421499",
                          "updatedAt": "2022-06-06T14:18:13Z",
                          "publishedAt": "2021-10-03T16:51:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "whiffee"
                          },
                          "bodyText": "Please don't think I'm knocking h-refinement. It's great if the local mesh quality can support it. I'm just fishing for information on p-refinement because Wikipedia said Moose could do it.",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1424897",
                          "updatedAt": "2022-06-06T14:18:13Z",
                          "publishedAt": "2021-10-04T14:01:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "I know about the libMesh side of things, so we can start off there, at least:\nTo do adaptive p-refinement, you want your \"base\" variable type to be the lowest order you ever want to see.  If you ask for FOURTH order, that means that p=4 will be the minimum in your subsequent simulation, not the maximum.\nWe don't currently support p>2 with LAGRANGE (or L2_LAGRANGE, or RATIONAL_BERNSTEIN) elements, simply because we don't have any geometric Elem types with enough nodes to get cubics with an FE type that sort of inherently associates each Degree of Freedom with a specific node.  Adding higher order geometric elements (at least for the edge/quad/hex Elem types) is on my to-do list now but I'm not sure if I'll get to it by the end of the calendar year.\nTo get adaptive p refinement (not just uniform), you also currently need an FE type that's \"hierarchic\" in the way it assigns degrees of freedom.  Right now that limits you to HERMITE, HIERARCHIC, L2_HIERARCHIC, MONOMIAL, MONOMIAL_VEC, SIDE_HIERARCHIC, SZABAB, and/or XYZ elements.  Some of those elements have other quirks or limitations too - L2_HIERARCHIC, MONOMIALs and XYZ are discontinuous, SIDE_HIERARCHIC is just defined on inter-element boundaries, etc.\nSo the variables block you'd want to start with would be something like\norder = FIRST\nfamily = HIERARCHIC\n\nAnd then you'd do p adaptivity from there ... and I'm not actually sure how to do that in Moose.  In libMesh, after you've run an error estimator and used it to flag elements (for h refinement by default), you just run MeshRefinement::switch_h_to_p_refinement() to switch those \"h refine me\" flags to be \"p refine me\" flags before calling refine_and_coarsen_elements.  A git grep isn't showing me any calls to that switch from within Moose, though.  I'm not seeing anything obvious in Adaptivity.C either.  Do we not have any way to do this from a Moose input file, without making users write custom C++ modules?  If not then that ought to go on my to-do list ASAP; it'd be pretty easy to add a new Adaptivity option that would at least cover most use cases (probably anything without mesh displacement).",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1425007",
                          "updatedAt": "2022-06-06T14:18:33Z",
                          "publishedAt": "2021-10-04T14:21:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Unrelated, about L2_LAGRANGE, was that improved to support p>2 without the geometric constraint?",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1425738",
                          "updatedAt": "2022-06-21T21:35:59Z",
                          "publishedAt": "2021-10-04T16:29:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "No; I'm going to wait until I've got higher-order LAGRANGE.  I assume everyone is going to expect/insist on local DoF ordering matching between the two, and I'd hate to run into some catch with LAGRANGE and the higher-order node ordering and discover that I had to make a backwards-incompatible change to L2_LAGRANGE to match.\nAlso ... until we have higher-order geometric elements (at which point I'll be adding the higher-order LAGRANGE immediately; we need that for just default master->physical mappings), It's hard to see the point of higher-order L2_LAGRANGE.  I guess we'd effectively have \"virtual nodes\" that don't exist, to e.g. define 16-\"node\" L2_LAGRANGE shapes on a Quad9?  That's doable, but what would the benefit even be, over L2_HIERARCHIC?  Lagrange shape functions don't work great in the mixed-order setting - you can put a first-order FE on a second-order Elem easily enough since the nodes are subsets, but you can't do that in general, only in the p1 == 2^n p2 case.  We may never support LAGRANGE on log2(elem_p/p) \\notin W cases, because there's no Lagrange node on which to \"put\" some of the DoFs there.  Supporting L2_LAGRANGE for those cases would be easier, but it'd be hard to convince me it was worth the trouble.",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1426022",
                          "updatedAt": "2022-06-21T21:35:59Z",
                          "publishedAt": "2021-10-04T17:28:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "I think I used high order L2_LAGRANGE without changing the mesh (first order) with DFEM. Now I am not sure if things were working ok.",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1426441",
                          "updatedAt": "2022-06-21T21:36:14Z",
                          "publishedAt": "2021-10-04T19:05:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "If you didn't use the Lagrange property in your code (i.e. if you could have just run with L2_HIERARCHIC instead), then that actually should have worked okay!  The trouble with high order L2_LAGRANGE is that one tends to naturally assume that L2_LAGRANGE elements are Lagrange elements, i.e. that phi_i(node_j) is 1 if i==j and 0 if i!=j.  With second-order L2_LAGRANGE on a first-order Elem, node_j doesn't even exist for high j.  But where it starts getting even worse is for third-order L2_LAGRANGE on a second-order Elem: there the first several non-vertex nodes do exist, but they're not at the 1/3 and 2/3 intervals where you'd expect them for a cubic, they're at the mid points suitable for a quadratic, and trying to evaluate phi_i(node_j) can actually give you wrong results for a cubic phi_i on a quadratic node_j, not just undefined-behavior-but-probably-a-nice-clean-segfault.\nAnyway, if you want to chat more about this, let's open a new discussion entry, not clutter up comments on the p-refinement question.",
                          "url": "https://github.com/idaholab/moose/discussions/18984#discussioncomment-1426737",
                          "updatedAt": "2022-06-21T21:36:14Z",
                          "publishedAt": "2021-10-04T20:17:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Benchmarking: Overestimated surface displacement?",
          "author": {
            "login": "tshreve"
          },
          "bodyText": "I am attempting to benchmark Moose's Tensor Mechanics module for a spheroidal pressurized cavity against an analytical solution developed for volcanic source modelling (https://pubs.usgs.gov/tm/13/b1/pdf/tm13-b1.pdf). Assuming linear elasticity, I would expect surface displacements to scale linearly with pressure change, however I found the surface displacements are overestimated when imposing a high pressure change (~1 GPa) on the cavity boundary. Figure 1 shows surface displacements when the boundary pressure change is ~1 GPa, and Figure 2 shows surface displacements when it is ~10 MPa (surface displacements are then scaled by 100). I was wondering if you have any insights as to where this discrepancy comes from.\nThanks in advance for your help!\nFigure 1:\n\nFigure 2:",
          "url": "https://github.com/idaholab/moose/discussions/18898",
          "updatedAt": "2022-06-30T13:39:53Z",
          "publishedAt": "2021-09-22T18:18:16Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nJust a small question and I ll tag the experts after, how refined is your mesh? Did you try using the uniform_refine parameter in [Mesh]?",
                  "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371107",
                  "updatedAt": "2022-06-30T13:39:59Z",
                  "publishedAt": "2021-09-22T18:25:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tshreve"
                          },
                          "bodyText": "The mesh is refined to ~80 m at the surface in a 2 km radius around the cavity, then gradually reduces to ~6 km at a distance of 30 km away from the source. The same mesh is used for both calculations and was created using gmsh. I have not tried using uniform_refine since I am already reaching a high number of DOFs (Num DOFs:                274857, Num Local DOFs: 37722 if running on 8 cores).",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371186",
                          "updatedAt": "2022-06-30T13:40:01Z",
                          "publishedAt": "2021-09-22T18:38:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it would be great to check that a single level of refinement does not change the answer much",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371212",
                          "updatedAt": "2022-06-30T13:40:02Z",
                          "publishedAt": "2021-09-22T18:41:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc @dschwen @jiangwen84",
                  "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371208",
                  "updatedAt": "2022-06-30T13:40:02Z",
                  "publishedAt": "2021-09-22T18:40:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Couple of things:\n\nplease share your input file.\nis the analytical solution derived based on small strain or finite strain assumption? I expect the the deformation will be larger for higher pressure and it might change the assumption.  Could you provide the analytical solution here?\nIs the domain large enough to eliminate the BC effect? I guess the analytical solution assumes infinite domain.",
                  "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371233",
                  "updatedAt": "2022-06-30T13:40:02Z",
                  "publishedAt": "2021-09-22T18:47:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tshreve"
                          },
                          "bodyText": "Input file for high pressure example is attached.\nIt is based on small strain assumption and is described on page 20 (Prolate Spheroid Source) of this document (https://pubs.usgs.gov/tm/13/b1/pdf/tm13-b1.pdf). Let me know if you need more info.\nThe domain is 100 km while the wavelength of the signal is <15 km, so we expect the BC effect to be mitigated.\n\nYang_ElastA3d_nograv_a1000_b500_t90_p0_vertical_highP.txt",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371281",
                          "updatedAt": "2022-06-30T13:40:02Z",
                          "publishedAt": "2021-09-22T19:01:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @tshreve\nAs others say, try a bigger domain, especially in depth along z,\nfor bigger pressures the effect of your \"signal wavelength\" may be larger and you may need a larger domain.\nAlso, try hexahedral elements, tetrahedra elements are usually not very accurate for problems involving bending.\nAlso, check the boundary conditions assumption in the analytical model,\nI think the pressure BC in MOOSE takes into account of the deformed surface,\nmeaning the total force on the surface of one boundary element is pressure * deformed area\nwhile in the analytical model the boundary condition may not consider the deformation,\nit may be applied on the undeformed domain,\notherwise, I am not sure if an analytical solution would be possible.\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371901",
                          "updatedAt": "2022-06-30T13:40:02Z",
                          "publishedAt": "2021-09-22T21:30:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "I agree with @ngrilli .\n\nAdd use_displaced_mesh = false in the Pressure block.\ndo you have other 2D example? Maybe you can use them to see the boundary effect. Currently you use symmetric BC, maybe try use a minimum BC that just restricts the rigid body motion.\nWhat did you plot in those figures? displacement along the center line? I suggest you use LineValueSampler to get them directly from MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1371944",
                          "updatedAt": "2022-06-30T13:40:14Z",
                          "publishedAt": "2021-09-22T21:42:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tshreve"
                          },
                          "bodyText": "Thanks for your quick responses!\n\nAfter running with use_displaced_mesh = false in the Pressure block, I obtain the following: Warning: unused parameter 'BCs/Pressure/use_displaced_mesh'. Do you know why this parameter is not be taken into consideration? We also noticed that in the Pressure BC documentation the pressure is always applied to the displaced mesh, which we suspect would explain the discrepancy in the displacements.\n\nTo answer your other questions:\n\nI tried with a 2D example and with a large enough domain (100 km) did not see any BC effects.\nI plot the surface displacements with python after testing various interpolation schemes. I will try LineValueSampler for comparison.",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1404355",
                          "updatedAt": "2022-06-30T13:40:27Z",
                          "publishedAt": "2021-09-29T17:34:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@tshreve The use_displaced_mesh option is not implemented in Pressure Action. You can use\n  [pressure_x]\n    type = Pressure\n    boundary = chamber\n    variable = disp_x\n    component = 0\n    factor = 0.96e9\n    use_displaced_mesh = false\n  []\n\n  [pressure_y]\n    type = Pressure\n    boundary = chamber\n    variable = disp_y\n    component = 1\n    factor = 0.96e9\n    use_displaced_mesh = false\n  []\n\n  [pressure_z]\n    type = Pressure\n    boundary = chamber\n    variable = disp_z\n    component = 2\n    factor = 0.96e9\n    use_displaced_mesh = false\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1405052",
                          "updatedAt": "2022-06-30T13:40:32Z",
                          "publishedAt": "2021-09-29T19:11:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tshreve"
                          },
                          "bodyText": "Thanks, I'll give that a try!",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1405431",
                          "updatedAt": "2022-06-30T13:40:43Z",
                          "publishedAt": "2021-09-29T20:43:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tshreve"
                          },
                          "bodyText": "use_displaced_mesh = false resolved the discrepancy. Thanks, we appreciate your help!",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1410645",
                          "updatedAt": "2022-06-30T13:40:43Z",
                          "publishedAt": "2021-09-30T18:31:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "use_displaced_mesh probably shouldn't be suppressed in the Pressure action.",
                  "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1414173",
                  "updatedAt": "2022-06-30T13:40:23Z",
                  "publishedAt": "2021-10-01T12:11:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "It is not suppressed, just not implemented as an option in Pressure action. I agree we should add it, see #18979",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1414807",
                          "updatedAt": "2022-06-30T13:40:50Z",
                          "publishedAt": "2021-10-01T14:20:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Exposing it would just be another chance for users to shoot themselves in the foot, wouldn't it? Physically it makes no sense IMO to apply the forces computed on the undisplaced mesh to the displaced mesh for a pressure BC.",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1414842",
                          "updatedAt": "2022-06-30T13:40:50Z",
                          "publishedAt": "2021-10-01T14:26:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "If we set 'use_displaced_mesh = false`, we will calculate the forces on the undisplayed mesh and apply it on the undisplayed mesh too. Isn't it?\nI guess another way to resolve @tshreve 's issue is NOT to use displaced mesh by setting 'use_displaced_mesh = false` in the Mesh block.",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1414897",
                          "updatedAt": "2022-06-30T13:40:55Z",
                          "publishedAt": "2021-10-01T14:40:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Exposing it would just be another chance for users to shoot themselves in the foot, wouldn't it? Physically it makes no sense IMO to apply the forces computed on the undisplaced mesh to the displaced mesh for a pressure BC.\n\nI think that depends. The root cause of the issue that @tshreve 's seeing is that she is assuming small deformation, while although the deformation is in some sense small, it is large enough to make a non-negligible mismatch with the analytical solution. Ideally, if the deformation was small enough, use_displaced_mesh should make negligible difference.\nNow, there are several ways to solve this issue, as @jiangwen84 suggested:\n\nDo not use the Pressure action, but setup pressure BCs manually with use_displaced_mesh = false,\nLet the displaced mesh fall back to the undisplaced mesh, by setting use_displaced_mesh = false in the Mesh block,\nReduce the magnitude of the pressure until the mismatch between the numerical solution and the analytical solution is negligible.\n\nThen, as a physics module, we need to make a choice:\na. If we want to support methods 1 and 2, then we better allow actions to set those parameters;\nb. If we suggest method 3, we are basically saying this is user error -- the user is using linear elasticity but the problem is violating the small strain assumptions.\nI see arguments for both choices. I guess if we make choice b, it would be better to issue runtime warnings like \"You are using a small strain formulation,but the deformation in your problem is outside the small strain regime, be aware of numerical errors...\".",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1417149",
                          "updatedAt": "2022-06-30T13:41:08Z",
                          "publishedAt": "2021-10-02T01:59:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Ok, makes sense. Wen, I think you're right. The force should be applies to the undisplaced mesh. I guess that means the force is still applied normal to the surface, but the local magnitude of the force is not quite correct because the undeformed  element area rather than the deformed element are is used, right?",
                          "url": "https://github.com/idaholab/moose/discussions/18898#discussioncomment-1419008",
                          "updatedAt": "2022-06-30T13:41:22Z",
                          "publishedAt": "2021-10-02T17:12:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Transferring std::vector between apps",
          "author": {
            "login": "sblondel"
          },
          "bodyText": "Hi,\nI want to take advantage of the transfer system for an external app. I know how to transfer a scalar between apps but now I am interested in transferring a std::vector which size would be defined at run time. I looked into the MultiAppReporterTransfer but I am still not sure if it is the best approach. What would you recommend using?",
          "url": "https://github.com/idaholab/moose/discussions/18894",
          "updatedAt": "2022-06-20T14:26:03Z",
          "publishedAt": "2021-09-22T12:36:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIs it sized based on the number of elements?\nIn what format do you want this to be available on the MOOSE side? Variable? Vectorpostprocessor?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1369847",
                  "updatedAt": "2022-06-20T14:26:03Z",
                  "publishedAt": "2021-09-22T14:48:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "@GiudGiud The size will be independent of the number of elements, but each mesh/grid point will be passing the same vector size. I think I would prefer to have it as a variable but as long as the externalApp can use it it doesn't matter to me.\nSophie",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1369880",
                          "updatedAt": "2022-06-20T14:26:04Z",
                          "publishedAt": "2021-09-22T14:53:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So it's a vector for every element in the mesh? Like an array variable?",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1369902",
                          "updatedAt": "2022-06-20T14:26:04Z",
                          "publishedAt": "2021-09-22T14:56:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "I believe so.",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1369943",
                          "updatedAt": "2022-06-20T14:26:07Z",
                          "publishedAt": "2021-09-22T15:06:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Great thanks! I dont think anyone has done that in particular. @aprilnovak has made regular variable transfers in Cardinal I believe. Could you please help out here? @sblondel you are at ORNL right? This will help with sharing that project.\n@fdkong @permcody  do you know of any other external apps who worked with transfers in that direction before?",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1369965",
                          "updatedAt": "2022-10-18T18:34:34Z",
                          "publishedAt": "2021-09-22T15:10:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "I am official at University of Tennessee but have an collaborator account at ORNL. For transfers I am familiar with @fdkong work in the external_petsc_solver module.",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370006",
                          "updatedAt": "2022-10-18T18:34:34Z",
                          "publishedAt": "2021-09-22T15:17:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "Hi @sblondel - we have a wrapping of the Nek CFD code in MOOSE that has transfer similar to this - but we don't use the Transfer system directly. Our general approach is to:\n\nCreate a mirror of the external App's mesh (on which the std::vector entries correspond to data on quadrature points, for instance) as a MooseMesh.\nWithin an ExternalProblem class, directly write from the std::vector into a MooseVariable on the mesh created in step (1).\nUse MOOSE's usual transfer system to then get that variable to another application.\n\nSo in essence, we don't write any custom Transfers - instead, we copy the external application's data onto a mesh that MOOSE understands, and then use any existing transfer to get data to another application. We chose not to go with the custom Transfer route because we would have had to implement all the logistics and parallelism of the transfers - like, finding the nearest node on a MooseMesh to a quadrature point in Nek, or doing a mesh interpolation/projection between a MOOSE mesh and a Nek mesh, etc. It was much simpler to just do a mesh + data copy and use MOOSE's transfers \"out-of-the-box.\"\nWhat does your application look like?",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370052",
                          "updatedAt": "2022-10-18T18:34:34Z",
                          "publishedAt": "2021-09-22T15:24:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "Hi @aprilnovak , your approach sounds good. To make sure I understand it: do you have multiple meshes for one app in this case (one for the physical domain and one for the std::vector entries)?\nI'm trying to extend this application: https://github.com/SciDAC-MOOSE-Xolotl-coupling-group/coupling_xolotl/blob/master/src/problem/XolotlProblem.C .",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370181",
                          "updatedAt": "2022-10-18T18:34:54Z",
                          "publishedAt": "2021-09-22T15:33:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "At all times, we have two meshes for Nek - one is the actual mesh that Nek uses for its CFD solve and on which the std::vector exists. The other is a \"mirror\" of that mesh in a MooseMesh format - no solves happen on this mesh - it only exists to receive the std::vector from Nek and put it into a MooseVariable.\nI'm not familiar with your application, but it looks like you have a mesh that replicates the Xolotl domain, in XolotlReflectedMesh? I think our analogue is a NekRSMesh: https://cardinal.cels.anl.gov/source/mesh/NekRSMesh.html\nTo get the std::vector onto the mesh mirror, we have a NekRSProblem where we do this in syncSolutions. In syncSolutions, we call a function like this - _nek_mesh is a pointer to the mesh mirror, and the value we pass in is essentially the std::vector we extracted from Nek.\nvoid\nNekRSProblemBase::fillAuxVariable(const unsigned int var_number, const double * value)\n{\n  auto & solution = _aux->solution();\n  auto sys_number = _aux->number();\n  auto pid = _communicator.rank();\n\n  for (unsigned int e = 0; e < _n_elems; e++)\n  {\n    auto elem_ptr = _nek_mesh->queryElemPtr(e);\n\n    for (unsigned int n = 0; n < _n_vertices_per_elem; n++)\n    {\n      auto node_ptr = elem_ptr->node_ptr(n);\n\n      // For each face vertex, we can only write into the MOOSE auxiliary fields if that\n      // vertex is \"owned\" by the present MOOSE process.\n      if (node_ptr->processor_id() == pid)\n      {\n        // Nek uses different node ordering than linMesh\n        int node_index = _nek_mesh->nodeIndex(n);\n        auto node_offset = e * _n_vertices_per_elem + node_index;\n\n        // get the DOF for the auxiliary variable, then use it to set the value in the auxiliary system\n        auto dof_idx = node_ptr->dof_number(sys_number, var_number, 0);\n        solution.set(dof_idx, value[node_offset]);\n      }\n    }\n  }\n\n  solution.close();\n}\n\nMost importantly, in the NekRSProblem::addExternalVariables function, we add MOOSE variables to represent Nek's internal solution. It looks like your XolotlProblem doesn't have any MOOSE variables added like this. If you wanted to use this approach, you'd add an external variable to represent whatever Xolotl solves for (say, flux?). Then in syncSolutions, write into that flux variable. Then you should be able to apply any MOOSE transfer to that MOOSE-variable-representation-of-flux to get it somewhere else.",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370377",
                          "updatedAt": "2022-10-18T18:34:59Z",
                          "publishedAt": "2021-09-22T15:46:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "Thank you so much for sharing this! Yes, XolotlReflectedMesh replicates the Xolotl domain. I'll try something similar to what you have and let you know how it went (it will probably take me a few days...).",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370469",
                          "updatedAt": "2022-10-18T18:36:01Z",
                          "publishedAt": "2021-09-22T16:03:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "Are you on the MOOSE slack? Feel free to reach out if you have any questions, there's not a ton of examples of the external problem approach in the framework itself",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370732",
                          "updatedAt": "2022-10-18T18:36:01Z",
                          "publishedAt": "2021-09-22T16:56:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "The Reporter system should be able to handle this, perhaps @zachmprince can provide some additional insight into this problem.",
                  "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1370470",
                  "updatedAt": "2022-06-20T14:26:08Z",
                  "publishedAt": "2021-09-22T16:03:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "Hi @sblondel. Just give an overview of the reporter system. It has the same high-level functionality as Postprocessors and VectorPostprocessors, except the data can be of arbitrary type. The data created with reporters is available throughout the entire application and can be referenced by other objects. Or it can be transferred between sub-applications using MultiAppReporterTransfer, as long as the type is copy-assignable.\nSo from my possibly flawed understanding of what you need. You could maybe create a Reporter object that converts the data from the Xototl run into an std::vector. You can then create empty std::vector reporter values in the main and other sub-apps using ConstantReporter which MultiAppReporterTransfer can transfer the data into. The objects in the sub-app running the other Xototl instances can then reference this transferred data for their execution.\nI hope this makes sense \ud83d\ude2c",
                  "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1405769",
                  "updatedAt": "2022-06-20T14:26:09Z",
                  "publishedAt": "2021-09-29T22:24:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sblondel"
                          },
                          "bodyText": "Thank you very much for the overview. I'm still trying to decide what is the best approach for my case, I'll let you know if I run into issues with the Reporter and MultiAppReporterTransfer.",
                          "url": "https://github.com/idaholab/moose/discussions/18894#discussioncomment-1414214",
                          "updatedAt": "2022-06-20T14:26:13Z",
                          "publishedAt": "2021-10-01T12:21:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Compressible Finite Volume HLLC Boundary Conditions",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "Does the CNSFVHLLC class have a no-slip boundary condition? In the Incompressible finite volume, I see there is a no-slip wall BC, but I am not sure which of the CNSFVHLLC boundary conditions would mimic that.",
          "url": "https://github.com/idaholab/moose/discussions/18963",
          "updatedAt": "2022-09-01T14:07:46Z",
          "publishedAt": "2021-09-29T12:05:29Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont think so. @lindsayad\nNo slip boundary conditions are more of a viscous flow concept, and the HLLC solver is for Eulerian flows with 0 viscosity.\nIf you have a reference for their formulation for HLLC we could have a look\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18963#discussioncomment-1403512",
                  "updatedAt": "2022-09-01T14:07:51Z",
                  "publishedAt": "2021-09-29T15:08:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We have this example here of using our fully compressible Kurganov-Tadmor implementation in a cavity with viscous drag from the walls. Use of the FVOrthogonalBoundaryDiffusion objects ensures that the only momentum flux at the walls is due to viscous forces (no advective outflow of momentum).",
                          "url": "https://github.com/idaholab/moose/discussions/18963#discussioncomment-1404520",
                          "updatedAt": "2022-09-01T14:07:51Z",
                          "publishedAt": "2021-09-29T18:00:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Thank you. I will look at this right away.",
                          "url": "https://github.com/idaholab/moose/discussions/18963#discussioncomment-1408793",
                          "updatedAt": "2022-09-01T14:07:51Z",
                          "publishedAt": "2021-09-30T12:32:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Note that a KT boundary condition may not mix well with HLLC kernels. I'd recommend switching over completely from HLLC to KT for this application.",
                          "url": "https://github.com/idaholab/moose/discussions/18963#discussioncomment-1409536",
                          "updatedAt": "2022-09-01T14:07:52Z",
                          "publishedAt": "2021-09-30T14:50:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "That example does not use any boundary conditions unique to KT",
                          "url": "https://github.com/idaholab/moose/discussions/18963#discussioncomment-1410690",
                          "updatedAt": "2022-09-01T14:07:52Z",
                          "publishedAt": "2021-09-30T18:39:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to implement the term (stress multiply strain rate) in MOOSE?",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hi MOOSEer,\nI want to ask how to calculate the term below in MOOSE? Are there any similar examples on this? Thanks.\n\nwhere \\sigma is stress and \\epsilon is strain.",
          "url": "https://github.com/idaholab/moose/discussions/18822",
          "updatedAt": "2022-06-01T08:43:56Z",
          "publishedAt": "2021-09-14T15:22:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "They are both tensors right?\nThis documentation can help you here https://mooseframework.inl.gov/docs/doxygen/moose/classRankTwoTensorTempl.html",
                  "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1325027",
                  "updatedAt": "2022-06-01T08:43:57Z",
                  "publishedAt": "2021-09-14T15:31:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@GiudGiud Thanks! Yes, they are both ranktwo tensor, I'll have look into this page. Are there any examples of it?",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1329834",
                          "updatedAt": "2022-06-01T08:43:57Z",
                          "publishedAt": "2021-09-14T20:35:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For sure. Once you find the operation you should be using (outer_product I think?) then you can grep the repo for it. I dont think there are examples in the tutorials.",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1329841",
                          "updatedAt": "2022-06-01T08:43:59Z",
                          "publishedAt": "2021-09-14T20:37:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "OK, thank you:) I'll have a try and see what happens.",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1329866",
                          "updatedAt": "2022-06-01T08:43:57Z",
                          "publishedAt": "2021-09-14T20:42:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ajacquey"
                  },
                  "bodyText": "I think you are looking for the double_contraction() function.\nIt looks like you wants the Plastic Heat Energy kernel and associated ComputePlasticHeatEnergy material from the tensor mechanics module.\nIf you'd prefer to implement your own, have a look at lines 42-43 from ComputePlasticHeatEnergy.",
                  "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1332852",
                  "updatedAt": "2022-06-01T08:43:57Z",
                  "publishedAt": "2021-09-15T11:42:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@ajacquey That's very similar to what I want, I'll definitely learn the pages. Thank you !",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1332963",
                          "updatedAt": "2022-06-01T08:44:08Z",
                          "publishedAt": "2021-09-15T12:06:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@ajacquey Hi! When I try to modify the material module above (ComputePlasticHeatEnergy), a variable _d_stress_dT (the derivative of stress w.r.t temperature) was defined, and the rest is mostly the same. But it has the error message as:\n\nerror: 'const class MaterialProperty<RankTwoTensorTempl >' has no member named 'doubleContraction'\n57 |       _d_stress_dT[_qp].doubleContraction(_elastic_strain[_qp] - _elastic_strain_old[_qp]) / _dt;\n\nDo you have any idea of what's going on with the error? Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1397809",
                          "updatedAt": "2022-06-01T08:44:08Z",
                          "publishedAt": "2021-09-28T17:58:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ajacquey"
                          },
                          "bodyText": "Hi @rh201,\nNot sure what causes this error.\nCould you share your files?",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1402301",
                          "updatedAt": "2022-06-01T08:44:07Z",
                          "publishedAt": "2021-09-29T12:44:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "This is the .C file modified form ComputePlasticHeatEnergy, in which I want to consider _d_stress_dT and AD version.\nInputParameters\nComputeElasticHeatEnergy::validParams()\n{\n  InputParameters params = ADMaterial::validParams();\n  params.addParam<std::string>(\"base_name\",\n                               \"Optional parameter that allows the user to define \"\n                               \"multiple mechanics material systems on the same \"\n                               \"block, i.e. for multiple phases\");\n  params.addRequiredCoupledVar(\"temperature\",\"Coupled temperature variable\");\n  params.addClassDescription(\"elastic heat energy density = stress * elastic_strain_rate\");\n  return params;\n}\n\nComputeElasticHeatEnergy::ComputeElasticHeatEnergy(const InputParameters & parameters)\n  : DerivativeMaterialInterface<ADMaterial>(parameters),\n    // _base_name(isParamValid(\"base_name\") ? getParam<std::string>(\"base_name\") + \"_\" : \"\"),\n    // _plastic_strain(getMaterialProperty<RankTwoTensor>(\"plastic_strain\")),\n    // _plastic_strain_old(getMaterialPropertyOld<RankTwoTensor>(\"plastic_strain\")),\n    // _stress(getMaterialProperty<RankTwoTensor>(_base_name + \"stress\")),\n    // _Jacobian_mult(getMaterialProperty<RankFourTensor>(_base_name + \"Jacobian_mult\")),\n    // _elasticity_tensor(getMaterialProperty<RankFourTensor>(_base_name + \"elasticity_tensor\")),\n    // _plastic_heat(declareProperty<Real>(_base_name + \"plastic_heat\")),\n    // _dplastic_heat_dstrain(declareProperty<RankTwoTensor>(_base_name + \"dplastic_heat_dstrain\"))\n    _base_name(isParamValid(\"base_name\") ? getParam<std::string>(\"base_name\") + \"_\" : \"\"),\n    _elastic_strain(getADMaterialProperty<RankTwoTensor>(\"elastic_strain\")),\n    _elastic_strain_old(getMaterialPropertyOld<RankTwoTensor>(\"elastic_strain\")),\n    _stress(getADMaterialProperty<RankTwoTensor>(_base_name + \"stress\")),\n    _d_stress_dT(parameters.hasDefaultCoupledValue(\"temperature\")\n          ? nullptr\n          : &getADMaterialProperty<RankTwoTensor>(derivativePropertyNameFirst(_base_name + \"stress\",\n             getVar(\"temperature\", 0)->name()))),\n    _T_dot(adCoupledDot(\"temperature\")),\n    // _Jacobian_mult(getADMaterialProperty<RankFourTensor>(_base_name + \"Jacobian_mult\")),\n    // _elasticity_tensor(getADMaterialProperty<RankFourTensor>(_base_name + \"elasticity_tensor\")),\n    _elastic_heat(declareADProperty<Real>(_base_name + \"elastic_heat\"))\n    // _delastic_heat_dstrain(declareADProperty<RankTwoTensor>(_base_name + \"delastic_heat_dstrain\"))\n{\n}\n\nvoid\nComputeElasticHeatEnergy::computeQpProperties()\n{\n  _elastic_heat[_qp] =\n      _d_stress_dT[_qp].doubleContraction(_elastic_strain[_qp] - _elastic_strain_old[_qp]) / _dt;\n\n  // if (_fe_problem.currentlyComputingJacobian())\n  // {\n  //   if (_elastic_strain[_qp] == _elastic_strain_old[_qp])\n  //     // no plastic deformation, so _elasticity_tensor = _Jacobian_mult\n  //     _delastic_heat_dstrain[_qp] = RankTwoTensor();\n  //   else\n  //   {\n  //     _delastic_heat_dstrain[_qp] =\n  //         (_elastic_strain[_qp] - _elastic_strain_old[_qp]).initialContraction(_Jacobian_mult[_qp]);\n  //     _delastic_heat_dstrain[_qp] += _stress[_qp];\n  //     _delastic_heat_dstrain[_qp] -=\n  //         _stress[_qp].initialContraction(_elasticity_tensor[_qp].invSymm() * _Jacobian_mult[_qp]);\n  //     _delastic_heat_dstrain[_qp] /= _dt;\n  //   }\n  // }\n}\n\nThe error I mentioned above will show when compiling.\nAnd when I call elastic_strain_old with getADMaterialPropertyOld as below,\n    _elastic_strain_old(getADMaterialPropertyOld<RankTwoTensor>(\"elastic_strain\")),\nanother error will occur\n\nerror: 'getADMaterialPropertyOld' was not declared in this scope; did you mean 'getMaterialPropertyOld'?\n39 |     _elastic_strain_old(getADMaterialPropertyOld(\"elastic_strain\")),\n|                         ^~~~~~~~~~~~~~~~~~~~~~~~\n|                         getMaterialPropertyOld\n\nIt seems there are no getADMaterialPropertyOld function.\nHope it's clear :)",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1403647",
                          "updatedAt": "2022-07-09T21:43:09Z",
                          "publishedAt": "2021-09-29T15:25:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There is no getADMaterialPropertyOld, AD terms are not kept for the old time step. You need to retrieve this as a regular material property\nSee this #18482",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1403664",
                          "updatedAt": "2022-07-09T21:43:11Z",
                          "publishedAt": "2021-09-29T15:28:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@rh201 , what @GiudGiud said is correct.\nYour code doesn't compile because your _d_stress_dT is a pointer. You should instead use\n(*_d_stress_dT)[_qp].doubleContraction(_elastic_strain[_qp] - _elastic_strain_old[_qp]) / _dt;",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1404239",
                          "updatedAt": "2022-07-09T21:43:12Z",
                          "publishedAt": "2021-09-29T17:12:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@GiudGiud @hugary1995 Thank you for pointing this out. It helps.\nBTW, how should I define and calculate _d_stress_dT inside the .C file instead of in input file? since I think it's not convenient to directly retrieve stress when using DerivativeParsedMaterial in input file.",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1407577",
                          "updatedAt": "2022-07-09T21:43:12Z",
                          "publishedAt": "2021-09-30T08:36:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Suppose your stress is a MaterialProperty<RankTwoTensor>, and your temperature is a VariableValue, you can declare the derivative of stress w.r.t. temperature (in the initialization list) using\n_dstress_dT(declareProperty<RankTwoTensor>(derivativePropertyName(\"stress\", {getVar(\"temperature\", 0)->name()})))\nwhere the method derivativePropertyName is defined in DerivativeMaterialPropertyNameInterface.\nSimilarly, if you want to use AD, you can use\n_dstress_dT(declareADProperty<RankTwoTensor>(derivativePropertyName(\"stress\", {getVar(\"temperature\", 0)->name()})))",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1408488",
                          "updatedAt": "2022-07-09T21:43:12Z",
                          "publishedAt": "2021-09-30T11:45:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@hugary1995  Thanks for your help, it compiles successfully now :)",
                          "url": "https://github.com/idaholab/moose/discussions/18822#discussioncomment-1408774",
                          "updatedAt": "2022-08-11T14:45:16Z",
                          "publishedAt": "2021-09-30T12:31:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem building libmesh",
          "author": {
            "login": "hsheldon"
          },
          "bodyText": "I'm having trouble building libmesh. Here's what I'm getting:\nlibtool: warning: '/apps/gcc/9.2.0/lib/gcc/x86_64-pc-linux-gnu/9.2.0/../../../../lib64/libstdc++.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libgfortran.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libgfortran.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libgfortran.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nlibtool: warning: '/apps/gcc/4.9.3/lib/../lib64/libquadmath.la' seems to be moved\nCXXLD    fparser_parse-opt\n./.libs/libmesh_opt.so: error: undefined reference to 'GOMP_loop_nonmonotonic_dynamic_start'\n./.libs/libmesh_opt.so: error: undefined reference to 'GOMP_loop_nonmonotonic_dynamic_next'\ncollect2: error: ld returned 1 exit status\nMakefile:13596: recipe for target 'fparser_parse-opt' failed\nmake[1]: *** [fparser_parse-opt] Error 1\nmake[1]: Leaving directory '/scratch1/projects/moose/moose/libmesh/build'\nMakefile:32290: recipe for target 'all-recursive' failed\nmake: *** [all-recursive] Error 1\nIn those warnings it seems to be looking for gcc/4.9.3 but I have gcc/9.2.0 loaded. Does that have something to do with it? Or is the error completely unrelated to the warnings?\nCheers,\nHeather",
          "url": "https://github.com/idaholab/moose/discussions/18929",
          "updatedAt": "2022-06-14T22:19:54Z",
          "publishedAt": "2021-09-27T01:38:50Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSeems like remnants of a previous compilation are being used. Could you please clean the repo (save your work then git clean -xfd) then try again.\nHow are you building libmesh? With scripts/update_and_rebuild_libmesh?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1393327",
                  "updatedAt": "2022-06-14T22:19:55Z",
                  "publishedAt": "2021-09-28T00:51:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "I've started over with a completely clean installation - just using plain vanilla MOOSE, not my own MOOSE app - still the same problem. I'm using scripts/update_and_rebuild_libmesh. Presumably I need to figure out why it's looking for gcc/4.9.3?\nThanks,\nHeather",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1393744",
                          "updatedAt": "2022-06-14T22:20:01Z",
                          "publishedAt": "2021-09-28T03:37:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "Heather - I suspect gcc/4.9.3 is not an issue here. Compilers are needed to compile... compilers. In this case, I suspect your server admins use gcc 4.9.3 to compile gcc 9.2.0.",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1393781",
                          "updatedAt": "2022-06-14T22:20:01Z",
                          "publishedAt": "2021-09-28T03:48:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "Ok, I'll stop going down the 4.9.3 rabbit hole! Any other suggestions?",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1393791",
                          "updatedAt": "2022-06-14T22:20:01Z",
                          "publishedAt": "2021-09-28T03:51:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what does which mpicxx return though?",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1394079",
                          "updatedAt": "2022-06-14T22:20:20Z",
                          "publishedAt": "2021-09-28T05:58:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "/apps/openmpi/3.1.4-ofed45-gcc/bin/mpicxx",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1394543",
                          "updatedAt": "2022-06-14T22:20:21Z",
                          "publishedAt": "2021-09-28T07:55:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Can you list all your loaded modules? And a printout of an env would also be helpful:\nmodule purge\nmodule load <the modules you are attempting to use>\nmodule list\nenv\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1396191",
                          "updatedAt": "2022-06-14T22:20:24Z",
                          "publishedAt": "2021-09-28T13:31:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "I seem to have fixed the problem by switching from gcc/9.2.0 to gcc/6.1.0. I have the following modules loaded:\nCurrently Loaded Modulefiles:\n\nSC                              4) openmpi/3.1.4-ofed45-gcc        7) netcdf/4.3.3.1                 10) hdf5/1.8.16-gcc                13) git/2.30.0                     16) paraview/5.5.0\nslurm/current                   5) petsc/3.10.5-gcc-mpi314-moose   8) glpk/4.60                      11) eigen/3.3.7                    14) python/2.7.13\nhpc-x/2.4.0                     6) intel-mkl/11.3.2                9) gcc/6.1.0                      12) moose/master                   15) mesa/17.2.4_gallium\n\nMaybe there's something in there that explains why gcc/6.1.0 works?",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1405873",
                          "updatedAt": "2022-06-14T22:20:21Z",
                          "publishedAt": "2021-09-29T23:09:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "As long as all of these were compiled with gcc 6.1.0 (or 9.2 previously)\nWhy are you loading moose/master though? You are compiling your own libmesh, you should compile your own moose too",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1405882",
                          "updatedAt": "2022-06-14T22:20:22Z",
                          "publishedAt": "2021-09-29T23:15:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hsheldon"
                          },
                          "bodyText": "I am compiling moose as well - which works now that I've managed to build libmesh. I have module load moose in my .profile.\nThanks for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/18929#discussioncomment-1405897",
                          "updatedAt": "2022-06-14T22:20:22Z",
                          "publishedAt": "2021-09-29T23:23:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "getting stress_old in ComputeLinearElasticPFFractureStress",
          "author": {
            "login": "selarem"
          },
          "bodyText": "Hi all,\nI am trying to get _stress_old in ComputeLinearElasticPFFractureStress by writting at the constructor:\n_stress_old(getMaterialPropertyOld(_base_name + \"stress\"))\nbut when compiling I obtain:\nprojects/moose/modules/tensor_mechanics/src/materials/ComputeLinearElasticPFFractureStress.C:34:5: error: class 'ComputeLinearElasticPFFractureStress' does not have any field named '_stress_old'\n_stress_old(getMaterialPropertyOld(_base_name + \"stress\"))\nThanks for any suggestion.\nRegards",
          "url": "https://github.com/idaholab/moose/discussions/16552",
          "updatedAt": "2022-06-09T08:18:55Z",
          "publishedAt": "2020-12-21T10:43:12Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "_stress_old needs to be defined in the header file with the correct type. The call to getMaterialPropertyOld should also contain a template argument: getMaterialPropertyStressOld<TheTypeHere>(...).\nFinally, are you modifying this class and plan to push the changes to MOOSE? Otherwise, you should create your own Material object that inherits from this within you application or a separate Material object that uses the properties from this Material.",
                  "url": "https://github.com/idaholab/moose/discussions/16552#discussioncomment-230134",
                  "updatedAt": "2022-06-09T08:19:20Z",
                  "publishedAt": "2020-12-21T16:16:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "@aeslaughter Hi! What's the correct type do you refer to? I searched getMaterialPropertyStressOld  but found no results. Are there any examples of that?\nAlso, when I modify getMaterialPropertyOld to getADMaterialPropertyOld, it seems not work, so does AD contain the function of getADMaterialPropertyOld ? Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/16552#discussioncomment-1400790",
                          "updatedAt": "2022-06-09T08:19:20Z",
                          "publishedAt": "2021-09-29T07:45:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Can you tell us why you want to get stress_old? This seems to be an unusual request, But if you describe what you want to achieve here, we might be able to suggest you the right thing to do here.",
                          "url": "https://github.com/idaholab/moose/discussions/16552#discussioncomment-1402073",
                          "updatedAt": "2022-09-09T13:19:02Z",
                          "publishedAt": "2021-09-29T11:59:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Hi Gary, what I want is strain_old to calculate the strain rate. Maybe the question #18822 is much clear.",
                          "url": "https://github.com/idaholab/moose/discussions/16552#discussioncomment-1402250",
                          "updatedAt": "2022-09-09T13:19:02Z",
                          "publishedAt": "2021-09-29T12:35:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Set of Element IDs of new elements in a refined mesh",
          "author": {
            "login": "ritamcj"
          },
          "bodyText": "Hi everyone,\nI am trying to access the set of new element IDs in a refined mesh at each time step. Are there any existing functions in Moose that can help with this? I looked into the doxygen files such as Marker.h, ValueThresholdMarker, QuadraturePointMarker and ElementIDInterface but could not find a suitable option. Additionally, I am unable to understand the boolean variable \"refine_set\" in ValueThresholdMarker. I would appreciate any leads.\nWarm regards,\nRitam",
          "url": "https://github.com/idaholab/moose/discussions/18944",
          "updatedAt": "2022-10-17T10:24:37Z",
          "publishedAt": "2021-09-28T07:37:10Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Ritam\nWhere do you want this value stores? A vectorposprocessor? An AuxVariable? Would not be too hard to write an auxkernel to place that in an auxvariable.\nrefine_set is simply a boolean to check if the user asked for a refine. It's to avoid doing that check at every quadrature point, and doing it only once in the constructor\nOne thing to know is that elements can be renumbered. You may want to disable that in the Mesh block if you want the ids pre- and post- refinement of some elements to remain the same.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18944#discussioncomment-1397374",
                  "updatedAt": "2022-10-17T10:24:39Z",
                  "publishedAt": "2021-09-28T16:28:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Guillaume,\nThank you for your suggestions and explanation of \"refine_set\". I want to read the number of new elements inside FiniteStrainUObasedCP in tensor mechanics as I want to assign properties (Fp etc.) to the quadrature points on those elements. So, the number would be an integer that would be used to locate the correct quadrature points.\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/18944#discussioncomment-1397661",
                          "updatedAt": "2022-10-17T10:24:40Z",
                          "publishedAt": "2021-09-28T17:25:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok so you need this inside the code.\nTo only loop on the newly refined elements, you could loop over all elements and examine their refinement level. If the parent is not active, then the children element are new. Maybe the JUST_REFINED refinement state will help, I'm not sure.\nSee https://libmesh.github.io/doxygen/classlibMesh_1_1Elem.html for documentation on the element",
                          "url": "https://github.com/idaholab/moose/discussions/18944#discussioncomment-1397745",
                          "updatedAt": "2022-10-17T10:24:40Z",
                          "publishedAt": "2021-09-28T17:41:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Howto retrieve the dof_id of a node for a vector field?",
          "author": {
            "login": "QuangDom"
          },
          "bodyText": "Hi, I am learning Moose and I would like to know how can I get the dof_id(s) of a node for a vector field.\nWhy VectorMooseVariable.nodalDofIndex() returns a single value?\nThanks in advance,\n/ Q.",
          "url": "https://github.com/idaholab/moose/discussions/18946",
          "updatedAt": "2024-07-29T10:48:58Z",
          "publishedAt": "2021-09-28T08:59:39Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nnodalDofIndex will return the index for the first component.\nYou can then use componentDofIndices, defined in MooseVariableBase, to get the values for the other components.\nI think the reason why is because the definition of vector variables is done through templating and that routine was never added for the vector instantiation as it doesnt make sense for the single valued instantiation.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18946#discussioncomment-1397243",
                  "updatedAt": "2024-07-29T10:48:59Z",
                  "publishedAt": "2021-09-28T16:06:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Write a test",
          "author": {
            "login": "QuangDom"
          },
          "bodyText": "Could someone point me to an example or documentation that I can learn about writing a test.\nI would like to test the results by doing an integration over the whole simulation domain (a 2D surface); Or do doing a line integration over the outlet boundary and compare the integration results with a 'gold' values.",
          "url": "https://github.com/idaholab/moose/discussions/18952",
          "updatedAt": "2023-11-13T04:58:11Z",
          "publishedAt": "2021-09-28T15:24:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe test system documentation is here https://mooseframework.inl.gov/python/TestHarness.html#!\nYou can have a look at moose/test/tests/kernels/simple_diffusion/ for an example of a test.\nThis test is an exodiff, so it compares the values of the variables everywhere.\nFor a line integration, you may want to look at a CSVDiff test, as the postrprocessors are easily output to csv files.\nAn example of that is in moose/test/tests/postprocessors/num_elems/\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18952#discussioncomment-1396976",
                  "updatedAt": "2023-11-13T04:58:11Z",
                  "publishedAt": "2021-09-28T15:29:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}