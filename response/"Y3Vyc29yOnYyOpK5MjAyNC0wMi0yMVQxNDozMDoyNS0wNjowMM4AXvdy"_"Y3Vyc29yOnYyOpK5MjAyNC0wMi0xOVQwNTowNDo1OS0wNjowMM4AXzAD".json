{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wMi0xOVQwNTowNDo1OS0wNjowMM4AXzAD"
    },
    "edges": [
      {
        "node": {
          "title": "CUDA-aware support",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nquick question: I recently installed MOOSE (+ our applications) on the leonardo booster module at CINECA in Italy. All went fine and smooth, but when trying to run the tests  (failing) -  errors are related to having disabled the CUDA-aware support (this is by deqfault required from the openMPI module installed locally). This said, I was wondering if there is a simple way to disable the CUDA-aware support at the TestHarness script level, or in other words, where I can integrate the --mca  opal_warn_on_missing_libcuda 0 option. If not, I might go all the way to install locally openmpi. Please, keep in mind that this is not a top priority discussion, since production runs are fine (at least as long as I have tested), and it is only because I found it annoying not to be able to run the tests upon a new installation (users keep on asking me why tests are failing...).\nThanks for any advise,\nmauro",
          "url": "https://github.com/idaholab/moose/discussions/26798",
          "updatedAt": "2024-02-21T09:09:59Z",
          "publishedAt": "2024-02-13T09:22:11Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "If I am reading you correctly, you may want to use:\nexport MOOSE_MPI_COMMAND='mpiexec --opal_warn_on_missing_libcuda 0'\nThis might work, if all you need is a way to add some arguments to mpiexec.\nIf instead you need to pass arguments to your MOOSE based application I believe you're after the --cli-args TestHarness option:\n./run_tests --help\n\n<trimmed>\n  --cli-args [CLI_ARGS] Append the following list of arguments to the \n                        command line (Encapsulate the command in quotes)\n\nI was looking for a decent doco page on our TestHarness, but this was all I could find: https://mooseframework.inl.gov/python/TestHarness.html\nTestHarness options/influential-environment-variables documentation could really use some TLC... #26799",
                  "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8453750",
                  "updatedAt": "2024-02-13T13:40:41Z",
                  "publishedAt": "2024-02-13T13:31:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "dear @milljm thanks a lot for your answer! It seems that adding the flag to the mpiexec works, at least against the CUDA aware support. However, all tests are crashing (signal 11 segmentation fault on one PID). Not sure whether this has to do with the cluster or not, but as said, production runs are fine.",
                          "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8479390",
                          "updatedAt": "2024-02-15T13:02:54Z",
                          "publishedAt": "2024-02-15T13:02:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I am not sure if @grmnptr can help, but, well 'CUDA'. Any ideas?\nIt sounds like the TestHarness is botching things up somehow, if we're able to manually run the application against the same test(s) without issue.",
                          "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8480650",
                          "updatedAt": "2024-02-15T14:21:20Z",
                          "publishedAt": "2024-02-15T14:21:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "I come back to this issue, though the problem slightly changed (I can open a new issue in case). However, about the test failing if based on the run_test script.... I noticed that upon a rebase of the conda environment, I keep receiving some warnings about VTKMPIController being already initialized at the beginning of each runs as well as some other related to SlepcInitialize() being called after SlepcFinalize() at the end of each runs. Could those be the reasons why the run_test script is crashing?",
                          "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8529143",
                          "updatedAt": "2024-02-20T12:12:33Z",
                          "publishedAt": "2024-02-20T12:12:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "I mean at least for conda based installation. The issue with the HPC, still remains, but there I am still without a clue.\nThanks for any feedback\nmauro",
                          "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8529256",
                          "updatedAt": "2024-02-20T12:24:38Z",
                          "publishedAt": "2024-02-20T12:24:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you please paste the entire error you see?\nAs well as:\n\nthe output of ldd on the executable\nthe output of the diagnostics script in moose/scripts",
                          "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8531722",
                          "updatedAt": "2024-02-20T15:38:38Z",
                          "publishedAt": "2024-02-20T15:38:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "dear @GiudGiud here are the required files.\ndiagnostic_moose.log\nlist_moose.log\nerror.log\nAbout the errors, the one on set up of a run is as follows (it repeats per the number of processors on the screen only, not sure why, but could not dump in a log file)\n2024-02-20 16:48:15.488 (   0.833s) [        6DD9CC80]   vtkMPIController.cxx:136   WARN| vtkMPIController (0x55e368e8f0f0): Already initialized.\nThe error at the end of a run, you can find in the log file (attached)\nThanks a lot for helping,\nmauro",
                          "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8531881",
                          "updatedAt": "2024-02-20T15:50:24Z",
                          "publishedAt": "2024-02-20T15:50:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\ninstead of the conda package list I would like the output of ldd <name of your executable-opt>",
                          "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8532028",
                          "updatedAt": "2024-02-20T16:02:15Z",
                          "publishedAt": "2024-02-20T16:02:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is this the simulation you care about btw? Because it s very small for using GPUs or even multiple CPUs",
                          "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8532157",
                          "updatedAt": "2024-02-20T16:10:55Z",
                          "publishedAt": "2024-02-20T16:10:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "It was a ldd on my executable (golem-opt), but was missing to activate the moose environment (sorry about that).  Here the update file:\ngolem.log\nAbout the test run, it is a very small example (just single timestep) only to showcase the warnings I am getting. So, no real production runs, though the relevant warnings are the same.\nThanks,\nMauro",
                          "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8532495",
                          "updatedAt": "2024-02-20T16:37:34Z",
                          "publishedAt": "2024-02-20T16:37:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "If I might add something, I had to reinstall all from scratch on another cluster, because of an upgrade of the system. All went smooth, all moose tests are passing but those from my app are still crashing (cannot have any informative hint, apart reason crash though). I also noticed that while compiling the system complains on NEML and libtorch missing, but I think this is just a warning. And again, all simulations do run fine if launched with proper slurm commands.",
                          "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8532755",
                          "updatedAt": "2024-02-20T16:56:22Z",
                          "publishedAt": "2024-02-20T16:56:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "So I think I managed to solve the issue. It all started with me trying to get rid of this warning (after updating the framework)\n\"*** Warning, This code is deprecated and will be removed in future versions:\nPlease update your main.C to adapt new main function in MOOSE framework, see 'test/src/main.C in MOOSE as an example of moose::main()'.\"\nFor which I thought it smart to update my main.C as follows:\nFrom the old version:\n// Create an instance of the application and store it in a smart pointer for easy cleanup\nstd::shared_ptr<MooseApp> app = AppFactory::createAppShared(\"GolemApp\", argc, argv);\n// Execute the application\napp->run();\nto the new version:\nMoose::main<GolemApp>(argc, argv);\nThat creates the error=crashed for all the tests. In addition, my fault, I never had a look at the log file from my students runs on the cluster, which, I realized this morning, did run till the end, but throwing an segfault message before finalizing.\nSo the question that remains, is what's the right way to update the pointer to the app. Would something like the following work fine with the new syntax?\nMooseApp * app = AppFactory::createApp(\"GolemApp\", argc, argv);\napp->run();\ndelete app;\n\nApart from that I think we can close the issue, again, sorry for bothering you all that much and thanks for the support.\nMauro",
                  "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8540724",
                  "updatedAt": "2024-02-21T09:05:12Z",
                  "publishedAt": "2024-02-21T09:05:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "On a side note, the CUDA-aware support issue has been solved by:\nexport MOOSE_MPI_COMMAND='mpiexec --opal_warn_on_missing_libcuda 0'",
                          "url": "https://github.com/idaholab/moose/discussions/26798#discussioncomment-8540795",
                          "updatedAt": "2024-02-21T09:10:00Z",
                          "publishedAt": "2024-02-21T09:09:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to solve a one dimensional diffusion problem in each node?",
          "author": {
            "login": "pengfejeac"
          },
          "bodyText": "Hi there!\nI'm working on a three dimensional problem, where it requires solving a one dimensional diffusion problem in each node. I checked some of the previous discussion about nodal kernel and ODE kernel, but none of those seems to be applicable to my case. On the other hand, I tried to customize a nodal kernel for my case, but nodal kernel doesn't have \"_grad_phi\" and \"_phi\", I have no idea on how to construct a diffusion problem without \"_phi\", so I'm stuck.\nAny help will be much appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/26532",
          "updatedAt": "2024-02-21T06:19:19Z",
          "publishedAt": "2024-01-11T02:00:20Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhich finite element family are you planning to use for the main variable? And is there only one variable?\nNodal kernels being at nodes, a lot of the families don't have a continuous gradients there and would not work for that purpose.\nDo you have to solve at nodes? Or could you solve three 1D diffusion problem volumetrically instead?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26532#discussioncomment-8089366",
                  "updatedAt": "2024-01-11T02:46:29Z",
                  "publishedAt": "2024-01-11T02:46:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pengfejeac"
                          },
                          "bodyText": "Thanks for the reply.\nAny finite element would work. The three dimensional problem has one variable, let's say u, and nodal problem has another variable, let's say v. You can think of u and v as coupled.\nI believe I have to solve at each node, but I'll re-think about this if it's not possible to implement. For one dimensional problem and one dimensional diffusion, I can draw the mesh as one straight line for one problem and a lot of orthogonal line at each node for diffusion problem. But in three dimensional case, I have no idea.\n\nOr could you solve three 1D diffusion problem volumetrically instead?\n\nI never thought about this, are there any examples that I can refer to?",
                          "url": "https://github.com/idaholab/moose/discussions/26532#discussioncomment-8089703",
                          "updatedAt": "2024-01-11T03:40:15Z",
                          "publishedAt": "2024-01-11T03:40:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Actually I have realized it would be easiest to use a multiapp approach here.\nYou can define a 1D solve in a separate input file, then distribute a bunch of sub apps, at nodes/quadrature points/element centroids, as you want, and solve them in a distrivuted manner.\nThen after that you can transfer the results of v from the distrivuted 1D solves to the 3D mesh.\nBefore the 1D solves you can also transfer the local values of u at every node to the 1D solves",
                          "url": "https://github.com/idaholab/moose/discussions/26532#discussioncomment-8093406",
                          "updatedAt": "2024-01-11T11:08:16Z",
                          "publishedAt": "2024-01-11T11:08:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Actually we do not have a NodalMultiApp or a NodalPositions (we can create multiapps on positions: https://mooseframework.inl.gov/docs/PRs/26528/site/syntax/Positions/index.html).\nI would be interested to see the latter contributed to MOOSE if you want to code it.\ncan you start with solvingthe 1D problems at element centroids otherwise?",
                          "url": "https://github.com/idaholab/moose/discussions/26532#discussioncomment-8093677",
                          "updatedAt": "2024-01-11T11:24:46Z",
                          "publishedAt": "2024-01-11T11:24:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pengfejeac"
                          },
                          "bodyText": "Sounds good to me. I will start with creating a small three dimensional mesh with a few node and try this distribution of multiapp, which I have never used before. Thanks again for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/26532#discussioncomment-8102926",
                          "updatedAt": "2024-01-12T01:03:16Z",
                          "publishedAt": "2024-01-12T01:03:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pengfejeac"
                          },
                          "bodyText": "@GiudGiud After some attempt, it seems like distributive 1D subapps is not very ideal. I need not only interactions between each subapps but also taking care of tons of subapp at the same time, which doesn't seems to be a great idea. So I'm thinking about hand-coded residual and Jacobian matrix, diagonal and off diagonal. If I fix the amount of elements in 1D diffusion, then I can obtain and calculate shape functions as well as the gradient.",
                          "url": "https://github.com/idaholab/moose/discussions/26532#discussioncomment-8164965",
                          "updatedAt": "2024-01-18T05:28:34Z",
                          "publishedAt": "2024-01-18T05:28:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Sub apps are created and run in a distributed manner so having a large number of them should be manageable.\nHowever you are right that if you need these 1D solves to be communicating in a certain way, this might not work.\nWhat we can do in terms of communication is create a field in the main app from the 1D solve then send back that field to the 1D apps.\nWe can also have transfers between multiapps. This would however mean you need to create multiple multiapps and not just one multiapp with many child app.\nMaybe you could group the 1D solves in multiple multiapps? For example in a grid as I imagine each 1D app only communicates with its neighbors?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/26532#discussioncomment-8169389",
                          "updatedAt": "2024-01-19T13:27:49Z",
                          "publishedAt": "2024-01-18T13:35:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pengfejeac"
                          },
                          "bodyText": "Wow, that sounds really advanced. Let me clear things up a little bit.\n\nWe can also have transfers between multiapps. This would however mean you need to create multiple multiapps and not just one multiapp with many child app.\n\nSo what you are suggesting is create a \"branch\" like structure with one Main app, a couple of intermediate app and a ton of sub app, is that correct? And that could be done by grouping?\nCommunicate with neighbors sounds like finite difference, but that should work if I can implement this branch.",
                          "url": "https://github.com/idaholab/moose/discussions/26532#discussioncomment-8176638",
                          "updatedAt": "2024-01-19T03:18:59Z",
                          "publishedAt": "2024-01-19T03:18:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You're right it might be too complicated. I dont think anyone has done this before.\nWhen you do these 1D solves, are you able to code up the entire solve in an object? If so you can use NodalKernels to perform the 1D solves on every node.\nNodalKernels can even contribute to the residual and Jacobian of the main solve.",
                          "url": "https://github.com/idaholab/moose/discussions/26532#discussioncomment-8181531",
                          "updatedAt": "2024-01-19T13:32:33Z",
                          "publishedAt": "2024-01-19T13:32:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pengfejeac"
                          },
                          "bodyText": "Sorry about the late reply.\nI'm capable of coding diffusion with certain boundary conditions and calculate entries in Jacobian matrix explicitly. But I'm having trouble understanding the difference between Nodal Kernel, Kernel and Array Kernels in terms of \"JxW\" term. Will that value be different if I apply Nodal kernel instead of Array kernel? Is there a way that I can avoid that?\nAs far as I understand, JxW means Jacobian times weight of Gauss quadrature rules, but I can't see the meaning of it if we are interpreting a node.",
                          "url": "https://github.com/idaholab/moose/discussions/26532#discussioncomment-8218724",
                          "updatedAt": "2024-01-23T10:08:55Z",
                          "publishedAt": "2024-01-23T10:08:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "A nodal kernel is supposed to be a local equation only active on that node. The variable is often very local, with completely independent solves on each node (but you can still pull in information from other nodes if you want)\nAn array kernel is for a field variable that extends over the entire mesh (or a few subdomains) but also has multiple components. For exmaple, the neutron flux with several energy groups is often an array variable. Or an array of multiple species being advected in a fluid.",
                          "url": "https://github.com/idaholab/moose/discussions/26532#discussioncomment-8224232",
                          "updatedAt": "2024-01-23T18:23:54Z",
                          "publishedAt": "2024-01-23T18:23:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MOOSE version",
          "author": {
            "login": "Ating24"
          },
          "bodyText": "How to view version numbers for MOOSE",
          "url": "https://github.com/idaholab/moose/discussions/26853",
          "updatedAt": "2024-02-21T02:41:46Z",
          "publishedAt": "2024-02-21T02:17:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nEither run a simulation and look at the log\nor use the executable with --version on the command line\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26853#discussioncomment-8537461",
                  "updatedAt": "2024-02-21T02:32:13Z",
                  "publishedAt": "2024-02-21T02:32:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Combining an intergrated BC",
          "author": {
            "login": "gj19866"
          },
          "bodyText": "Hi there,\nI want to create a boundary condition such that $\\hat{n} \\cdot (\\nabla \\chi - \\boldsymbol{A} )= 0$.\nIs this possible within the integrated BC method?\nI have read the docs but I am slightly confused about it.\nAll the best,\nGillian",
          "url": "https://github.com/idaholab/moose/discussions/26847",
          "updatedAt": "2024-02-20T19:12:17Z",
          "publishedAt": "2024-02-20T14:22:04Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIs chi the variable?\nAnd depending on the weak form of your equation on the volume, this looks a lot like a NeumannBC for the diffusion equation.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26847#discussioncomment-8531744",
                  "updatedAt": "2024-02-20T15:40:04Z",
                  "publishedAt": "2024-02-20T15:40:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "Hello Guillaume,\nChi is a variable (and is the variable I want the BC to act on). $\\boldsymbol{A}$ is a Vector variable however, and hence I thought that I couldn't use the standard NeumannBC for this case?\nThank you,\nGillian",
                          "url": "https://github.com/idaholab/moose/discussions/26847#discussioncomment-8531785",
                          "updatedAt": "2024-02-20T15:42:44Z",
                          "publishedAt": "2024-02-20T15:42:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is A a nonlinear variable? Or something that is fixed or known on every time step?",
                          "url": "https://github.com/idaholab/moose/discussions/26847#discussioncomment-8531810",
                          "updatedAt": "2024-02-20T15:45:12Z",
                          "publishedAt": "2024-02-20T15:45:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "A is defined by a Parsed function, and is known at very time step, and varys only in space and not time",
                          "url": "https://github.com/idaholab/moose/discussions/26847#discussioncomment-8531825",
                          "updatedAt": "2024-02-20T15:46:20Z",
                          "publishedAt": "2024-02-20T15:46:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you defined A * n as a function, then you could use a FunctionNeumannBC",
                          "url": "https://github.com/idaholab/moose/discussions/26847#discussioncomment-8531844",
                          "updatedAt": "2024-02-20T15:47:46Z",
                          "publishedAt": "2024-02-20T15:47:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "Amazing thank you. How could I go about defining that?",
                          "url": "https://github.com/idaholab/moose/discussions/26847#discussioncomment-8531860",
                          "updatedAt": "2024-02-20T15:48:55Z",
                          "publishedAt": "2024-02-20T15:48:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "The reason being, I want to apply this to non-trivial geometries.",
                          "url": "https://github.com/idaholab/moose/discussions/26847#discussioncomment-8531878",
                          "updatedAt": "2024-02-20T15:50:00Z",
                          "publishedAt": "2024-02-20T15:49:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Do you plan to use a fixed component for the normal?\nOr the actual norm to the surface?\nThe latter cannot be done in a function. We d have to use an auxKernel to do this",
                          "url": "https://github.com/idaholab/moose/discussions/26847#discussioncomment-8531998",
                          "updatedAt": "2024-02-20T15:59:17Z",
                          "publishedAt": "2024-02-20T15:59:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "I think I would need the actual norm to the surface.\nCreating an auxVar seems like a reasonable solution, I just don't know what functionality to use to create an auxvariable with value $\\hat{n} \\cdot A$.",
                          "url": "https://github.com/idaholab/moose/discussions/26847#discussioncomment-8532045",
                          "updatedAt": "2024-02-20T16:03:10Z",
                          "publishedAt": "2024-02-20T16:03:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gj19866"
                          },
                          "bodyText": "And can that be parsed into the NeumannBC the same as you would a value?",
                          "url": "https://github.com/idaholab/moose/discussions/26847#discussioncomment-8532061",
                          "updatedAt": "2024-02-20T16:04:07Z",
                          "publishedAt": "2024-02-20T16:04:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so if we use a auxiliary variable, you ll want to use:\nhttps://mooseframework.inl.gov/moose/source/bcs/CoupledVarNeumannBC.html\ninstead of a FunctionNeumannBC\nto create n*A in an auxiliary variable, you can use a CONSTANT MONOMIAL (let's start with that) auxiliary variable then a simple auxkernel that is boundary-restricted.\nThe n * A operation is somewhat close to the AdvectiveFluxAux operation? You might be able to make a new one?\nhttps://mooseframework.inl.gov/moose/source/auxkernels/AdvectiveFluxAux.html",
                          "url": "https://github.com/idaholab/moose/discussions/26847#discussioncomment-8532117",
                          "updatedAt": "2024-02-20T16:07:35Z",
                          "publishedAt": "2024-02-20T16:07:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Partial of vector V with respect the normal vector",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "Is there an example code that implements the partial derivative of vector V with respect the partial derivative of the normal vector, with that operation then multiplied by the normal direction, example n_y?",
          "url": "https://github.com/idaholab/moose/discussions/26844",
          "updatedAt": "2024-02-21T01:35:53Z",
          "publishedAt": "2024-02-20T04:11:28Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "This is different than the projection of the gradient onto the normal, e.g. $(\\nabla \\vec{u} \\cdot \\vec{n})\\vec{n}$ ?",
                  "url": "https://github.com/idaholab/moose/discussions/26844#discussioncomment-8524828",
                  "updatedAt": "2024-02-20T04:35:08Z",
                  "publishedAt": "2024-02-20T04:35:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Is there an example post processor that incorporates this?",
                          "url": "https://github.com/idaholab/moose/discussions/26844#discussioncomment-8529842",
                          "updatedAt": "2024-02-20T13:17:50Z",
                          "publishedAt": "2024-02-20T13:17:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont think so. We have (grad_u * n) in SideDiffusiveFluxIntegral but no multipliciation by the normal after.\nIt still shows how to get the gradient and what the normal vector is in the code\nIt should be pretty easy to make a new postprocessor though.\nOnce you know grad_V, computing dV/dn is simple math, and then multiplying by n_y is trivial too",
                          "url": "https://github.com/idaholab/moose/discussions/26844#discussioncomment-8531705",
                          "updatedAt": "2024-02-20T15:37:01Z",
                          "publishedAt": "2024-02-20T15:36:59Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thanks for reassuring me that there is a means to solve the formulation of this type of problem in the software. I have some more homework to do on the subject.",
                          "url": "https://github.com/idaholab/moose/discussions/26844#discussioncomment-8531863",
                          "updatedAt": "2024-02-20T15:49:08Z",
                          "publishedAt": "2024-02-20T15:49:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "IntegralDirectedSurfaceForce is exactly what I'm attempting to accomplish, but there is no finite element implementation of it.",
                          "url": "https://github.com/idaholab/moose/discussions/26844#discussioncomment-8531908",
                          "updatedAt": "2024-02-20T15:52:17Z",
                          "publishedAt": "2024-02-20T15:52:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "When the number of processors exceeds the number of examples, the initializing equation system is always displayed",
          "author": {
            "login": "Ating24"
          },
          "bodyText": "When I use sensitivity analysis\uff0cWhen the number of processors exceeds the number of examples, the initializing equation system is always displayed",
          "url": "https://github.com/idaholab/moose/discussions/26845",
          "updatedAt": "2024-02-20T06:49:11Z",
          "publishedAt": "2024-02-20T06:49:10Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Batch reset/recovery options for older versions",
          "author": {
            "login": "Ating24"
          },
          "bodyText": "the batch-reset/restore options used one process per app.Can we modify the old version of the batch reset/restore options to enable it to use multiple processes per app?",
          "url": "https://github.com/idaholab/moose/discussions/26835",
          "updatedAt": "2024-02-20T06:44:25Z",
          "publishedAt": "2024-02-19T01:18:00Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "This will not be possible. MOOSE has already created this feature in later versions of MOOSE.\nWe cannot alter git-history to add an existing feature without a massive negative impact to others.",
                  "url": "https://github.com/idaholab/moose/discussions/26835#discussioncomment-8518306",
                  "updatedAt": "2024-02-19T14:29:28Z",
                  "publishedAt": "2024-02-19T14:29:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ating24"
                          },
                          "bodyText": "Can I make modifications on my MOOSE to modify the batch reset/restore options",
                          "url": "https://github.com/idaholab/moose/discussions/26835#discussioncomment-8518351",
                          "updatedAt": "2024-02-19T14:33:08Z",
                          "publishedAt": "2024-02-19T14:33:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Oh yes, you are welcome to make any change you wish to your clone of the MOOSE repository. If you do decide to go that route, you may be hard pressed finding developers to assist you in doing so however.\nI think all developers will answer like minded; to update to the version of MOOSE which adds support for that feature request.",
                          "url": "https://github.com/idaholab/moose/discussions/26835#discussioncomment-8518498",
                          "updatedAt": "2024-02-19T14:43:39Z",
                          "publishedAt": "2024-02-19T14:43:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grmnptr"
                          },
                          "bodyText": "Here is the pull request that enabled this functionality, you can follow the changes here if you were close enough with your old version.\n#17643",
                          "url": "https://github.com/idaholab/moose/discussions/26835#discussioncomment-8518573",
                          "updatedAt": "2024-02-19T14:49:23Z",
                          "publishedAt": "2024-02-19T14:49:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ating24"
                          },
                          "bodyText": "When the number of processors exceeds the number of examples, the initializing equation system is always displayed",
                          "url": "https://github.com/idaholab/moose/discussions/26835#discussioncomment-8525699",
                          "updatedAt": "2024-02-20T06:44:26Z",
                          "publishedAt": "2024-02-20T06:44:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Seeking clarification on the distinction between Points, Nodes, Vertices, and Quadrature Points in libmesh",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "I am working on calculating the center point of an element's side by averaging the coordinates of each vertex. I have been exploring the information available regarding libmesh::Elem for this purpose. However, I am currently confused about the differences among Point, Node, Vertex, and Quadrature Point.\nMy current understanding is as follows:\nA Point solely contains coordinate information.\nA Node builds upon a Point and is associated with degrees of freedom; every Node contains a Point.\nIn MOOSE, each Quadrature Point corresponds to unknown variables (i.e. degrees of freedom), suggesting it should be linked to a Node.\nThe number of Vertices is determined by the type of the element, representing physically existing points.\nThe confusion arises from the fact that both Nodes and Vertices seem to use the same indexing scheme when accessing their positions via the elem->point(n) function.\n Point Elem::vertex_average() const\n {\n   Point cp;\n \n   const auto n_vertices = this->n_vertices();\n \n   for (unsigned int n=0; n<n_vertices; n++)\n     cp.add (this->point(n));\n \n   return (cp /= static_cast<Real>(n_vertices));\n }\n\n\nstd::unique_ptr<MeshBase>\nCoarseMeshExtraElementIDGenerator::generate()\n{\n    ......\n\n    // Check if the fine elem is nested in the coarse element\n    for (unsigned int n = 0; n < elem->n_nodes(); n++)\n    {\n      // Get the node: we need to manually move it towards the centroid to\n      // ensure that nothing weird happes due to round-off\n      Point current_node = elem->point(n);\n\n      ......\n}\n\nThis gives me the impression that Vertices and Nodes share the same index set, which seems contradictory given that their counts are different.\nFurthermore, my understanding suggests that each element has its unique set of Quadrature Points while Nodes can be shared across elements. This seemingly contradicts my earlier notion that each Quadrature Point corresponds to a single Node.\nI would greatly appreciate your help in clarifying these concepts and how they relate to finding the center point of an element's side. Thank you in advance for your attention and assistance.",
          "url": "https://github.com/idaholab/moose/discussions/26838",
          "updatedAt": "2024-02-20T04:36:22Z",
          "publishedAt": "2024-02-19T15:42:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "My advice would be to use Elem::build_side_ptr and then just call vertex_average or true_centroid with the resulting element",
                  "url": "https://github.com/idaholab/moose/discussions/26838#discussioncomment-8521357",
                  "updatedAt": "2024-02-19T19:19:57Z",
                  "publishedAt": "2024-02-19T19:19:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you for your advice. I had not come across this function before, and it appears to be exactly what I am looking for.",
                          "url": "https://github.com/idaholab/moose/discussions/26838#discussioncomment-8524547",
                          "updatedAt": "2024-02-20T03:38:15Z",
                          "publishedAt": "2024-02-20T03:38:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "But returning to your question:\n\nA Point solely contains coordinate information.\n\nYes\n\nA Node builds upon a Point and is associated with degrees of freedom; every Node contains a Point.\n\nYes, although I think it would be slightly more accurate to say a Node is a Point\n\nIn MOOSE, each Quadrature Point corresponds to unknown variables (i.e. degrees of freedom), suggesting it should be linked to a Node.\n\nQuadrature points generally have no link to nodes. They are associated with elements. This Wikipedia article describes our most commonly used quadrature rule. Quadrature points are used for numerical integration. They don't have any link to variable's degrees of freedom\n\nThe number of Vertices is determined by the type of the element, representing physically existing points.\n\nThis is true. I would probably not capitalize vertices because there is no vertex class type in libMesh/MOOSE whereas Point and Node are class types. Vertices are a subset of an element's Nodes. In the case of a Quad4 element, all the Nodes are vertices. However, with a Quad9 element there are also Nodes at the mid-points of element edges and also a Node at the center of the element. 4 vertex nodes + 4 mid-edge nodes + center node = 9 nodes in total.",
                  "url": "https://github.com/idaholab/moose/discussions/26838#discussioncomment-8521430",
                  "updatedAt": "2024-02-19T19:30:04Z",
                  "publishedAt": "2024-02-19T19:30:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you for your detailed response.\n\nVertices are a subset of an element's Nodes. In the case of a Quad4 element, all the Nodes are vertices. However, with a Quad9 element there are also Nodes at the mid-points of element edges and also a Node at the center of the element. 4 vertex nodes + 4 mid-edge nodes + center node = 9 nodes in total.\n\nI understand that vertices is part of nodes, but what intrigues me is why the vertex_average() function uses this->point(n) to access vertex data, which gives the impression that points and vertices are either entirely synonymous or, at least, the first n_vertices points correspond directly to vertices.\n Point Elem::vertex_average() const\n {\n   Point cp;\n \n   const auto n_vertices = this->n_vertices();\n \n   for (unsigned int n=0; n<n_vertices; n++)\n     cp.add (this->point(n));\n \n   return (cp /= static_cast<Real>(n_vertices));\n }",
                          "url": "https://github.com/idaholab/moose/discussions/26838#discussioncomment-8524515",
                          "updatedAt": "2024-02-20T03:31:22Z",
                          "publishedAt": "2024-02-20T03:31:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "at least, the first n_vertices points correspond directly to vertices.\n\nthis is exactly correct. libMesh stores an element's nodes such that the first n_vertices() of nodes are indeed the vertices, with mid-edge nodes, etc. following the vertices",
                          "url": "https://github.com/idaholab/moose/discussions/26838#discussioncomment-8524801",
                          "updatedAt": "2024-02-20T04:28:53Z",
                          "publishedAt": "2024-02-20T04:28:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "I get it, thank you again for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/26838#discussioncomment-8524821",
                          "updatedAt": "2024-02-20T04:34:14Z",
                          "publishedAt": "2024-02-20T04:34:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "thanks for always having such good questions!",
                          "url": "https://github.com/idaholab/moose/discussions/26838#discussioncomment-8524840",
                          "updatedAt": "2024-02-20T04:36:22Z",
                          "publishedAt": "2024-02-20T04:36:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Wrong form of CrystalPlasticityTwinningKalidindiUpdate Model realized in MOOSE?",
          "author": {
            "login": "SuperkakaSCU"
          },
          "bodyText": "Hello MOOSE experts,\nFor the \"CrystalPlasticityTwinningKalidindiUpdate.C\" Module, I compared the constitutive equations shown on the MOOSE website and the program. I thought there might be some mismatches, and ask for help:\nQuestion1: The rate of twin volume fraction on each twin system\nQuestion:\nFor \"_slip_increment\" in \"calculateConstitutiveSlipDerivative\", it has already considered time step. So, do we still need to contain \"_substep_dt\" in the rate of twin volume fraction again?\nCode:\nvoid CrystalPlasticityTwinningKalidindiUpdate::calculateStateVariableEvolutionRateComponent()\n{\nfor (const auto i : make_range(_number_slip_systems))\n_twin_volume_fraction_increment[_qp][i] =\n_slip_increment[_qp][i] / _characteristic_twin_shear * _substep_dt;\n}\nQuestion2: Twin Resistance\nQuestion:\nThe constitutive equation shown on the website uses the twin fraction increment to calculate the increment of twin propagation. However, in the code, it seems like it uses twin fraction (_twin_volume_fraction[_qp][j]) rather than twin fraction increment.\nCode:\nvoid CrystalPlasticityTwinningKalidindiUpdate::calculateTwinResistance()\n{\nDenseVector twin_hardening_increment(_number_slip_systems);\nfor (const auto i : make_range(_number_slip_systems))\n{\ntwin_hardening_increment(i) = 0.0;\nfor (const auto j : make_range(_number_slip_systems))\n{\nif (MooseUtils::relativeFuzzyEqual(_slip_plane_normalj, _slip_plane_normali) &&\nMooseUtils::relativeFuzzyEqual(_slip_plane_normalj, _slip_plane_normali))\n// If the first two are the same, the third index will have to be as well\n{\nif (_slip_increment[_qp][j] > 0.0)\ntwin_hardening_increment(i) += _coplanar_coefficient_twin_hardening *\n_total_twin_volume_fraction[_qp] *\n_twin_volume_fraction[_qp][j];\n}\nelse // assume non-coplanar\n{\nif (_slip_increment[_qp][j] > 0.0)\ntwin_hardening_increment(i) +=\n_non_coplanar_coefficient_twin_hardening *\nstd::pow(_total_twin_volume_fraction[_qp], _noncoplanar_exponent) *\n_twin_volume_fraction[_qp][j];\n}\n}\n.....\n}\nThanks for your time!",
          "url": "https://github.com/idaholab/moose/discussions/26831",
          "updatedAt": "2024-02-19T19:13:14Z",
          "publishedAt": "2024-02-17T20:21:01Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@sapitts",
                  "url": "https://github.com/idaholab/moose/discussions/26831#discussioncomment-8503926",
                  "updatedAt": "2024-02-17T23:34:21Z",
                  "publishedAt": "2024-02-17T23:34:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "I took a quick look at both codes and paper. I felt @SuperkakaSCU is probably correct on those two issues. However, I would like to hear @sapitts 's suggestions before making any code fix.",
                          "url": "https://github.com/idaholab/moose/discussions/26831#discussioncomment-8521281",
                          "updatedAt": "2024-02-19T19:13:16Z",
                          "publishedAt": "2024-02-19T19:13:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A 'Uniform' is not a registered object.",
          "author": {
            "login": "Ating24"
          },
          "bodyText": "reported the following error when using sensitivity analysis\n*** ERROR ***\nThe following Reporter(s) were not declared:\n\nReporter \"results/date:T1:value\":\n  Type:\n    std::vector<double>\n  Producer:\n    None\n  Consumer(s):\n    PolynomialChaosTrainer \"poly_chaos_temperature1\" (mode: UNSET)\n\nReporter \"results/date:T2:value\":\n  Type:\n    std::vector<double>\n  Producer:\n    None\n  Consumer(s):\n    PolynomialChaosTrainer \"poly_chaos_temperature2\" (mode: UNSET)\n....................................",
          "url": "https://github.com/idaholab/moose/discussions/26836",
          "updatedAt": "2024-02-19T11:04:59Z",
          "publishedAt": "2024-02-19T07:45:29Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Ating24"
                  },
                  "bodyText": "It has been resolved",
                  "url": "https://github.com/idaholab/moose/discussions/26836#discussioncomment-8515946",
                  "updatedAt": "2024-02-19T11:05:00Z",
                  "publishedAt": "2024-02-19T11:04:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}