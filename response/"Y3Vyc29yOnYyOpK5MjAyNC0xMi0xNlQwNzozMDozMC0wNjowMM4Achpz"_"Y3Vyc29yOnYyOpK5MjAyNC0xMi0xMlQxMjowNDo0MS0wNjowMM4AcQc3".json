{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMi0xMlQxMjowNDo0MS0wNjowMM4AcQc3"
    },
    "edges": [
      {
        "node": {
          "title": "how to translate FV var to FE var?",
          "author": {
            "login": "wangzhaohao"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello, There is a error about Material, when I try to compute a material which form is $k=P*T$, where k is material property, P is compute form FVM, T is compute form FEM.\nYour material mamox couples in both FE and FV vars. To support ghost calculations which some FV consumers may need, multiphysics simulations should define separate materials for coupling in finite element and finite volume variables because we do not have a user friendly way of running DerivedMaterial::computeQpProperties and saying 'compute this property because it doesn't depend on finite element variables' or 'don't compute this property because it *does* depend on finite element variables'\nAre there auxiliary variables AuxVariable that convert FV variables into FE variables? I can't find it from the name.\nThanks for you help in advance.\nZhaohao Wang",
          "url": "https://github.com/idaholab/moose/discussions/29525",
          "updatedAt": "2024-12-16T08:48:18Z",
          "publishedAt": "2024-12-12T08:17:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou can use a ProjectionAux to convert kne to the other.\nAlternatively you can use the functor APIs to couple FE or FV variables in any object. See the Functor documentation",
                  "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11543618",
                  "updatedAt": "2024-12-12T12:01:59Z",
                  "publishedAt": "2024-12-12T12:01:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "Thanks, this is pretty effective. Just as you say, I use ProjectionAux to convert both.\n  [porosity_back]\n  []\n  [temp_fv]\n    type = MooseVariableFVReal\n  []\n [porosity_back]\n    type = ProjectionAux\n    v = porosity\n    variable = porosity_back\n  []\n  [temp_back]\n    type = ProjectionAux\n    v = temp\n    variable = temp_fv\n  []\n   [porosityadvection]\n    type = FVPoreAdvection\n    variable = porosity\n    temperature = temp_fv\n    plutonium_concentration = 0\n  []\n  [mamox]\n    type = MAMOXThermal\n    temperature = temp\n    porosity = porosity_back\n  []\nBut there is new error. and I have used gdb to find error place.\nAssertion `!face_mat->hasStatefulProperties()' failed\nFinite volume materials do not currently support stateful properties.\nat /home/wang/projects/moose/framework/src/problems/FEProblemBase.C, line 8774\n#0  0x00007fffe134a4f0 in PMPI_Abort () from /home/wang/miniforge/envs/moose/lib/libmpi.so.12\n#1  0x00007ffff4b49b12 in moose::internal::mooseErrorRaw (msg=..., prefix=...)\n    at /home/wang/projects/moose/framework/src/base/MooseError.C:88\n#2  0x00007ffff4ca958b in mooseError<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&> () at /home/wang/projects/moose/framework/build/header_symlinks/MooseError.h:303\n#3  0x00007ffff537e4e6 in ThreadedFaceLoop<libMesh::StoredRange<MooseMesh::const_face_info_iterator, FaceInfo const*> >::~ThreadedFaceLoop (this=0x7fffffff7e60, __in_chrg=<optimized out>)\n    at /home/wang/projects/moose/framework/build/header_symlinks/ComputeFVFluxThread.h:219\n#4  0x00007ffff5349d61 in ComputeFVFluxThread<libMesh::StoredRange<MooseMesh::const_face_info_iterator, FaceInfo const*>, AttribVectorTags>::~ComputeFVFluxThread (this=0x7fffffff7e60, __in_chrg=<optimized out>)\n    at /home/wang/projects/moose/framework/build/header_symlinks/ComputeFVFluxThread.h:465\n#5  0x00007ffff537f441 in ComputeFVFluxResidualThread<libMesh::StoredRange<MooseMesh::const_face_info_iterator, FaceInfo const*> >::~ComputeFVFluxResidualThread (this=0x7fffffff7e60, __in_chrg=<optimized out>)\n    at /home/wang/projects/moose/framework/build/header_symlinks/ComputeFVFluxThread.h:890\n#6  0x00007ffff52cdc9a in NonlinearSystemBase::computeResidualInternal (this=0x555555cf7bd0, tags=...)\n    at /home/wang/projects/moose/framework/src/systems/NonlinearSystemBase.C:1748\n#7  0x00007ffff52c4eb0 in NonlinearSystemBase::computeResidualTags (this=0x555555cf7bd0, tags=...)\n    at /home/wang/projects/moose/framework/src/systems/NonlinearSystemBase.C:826\n#8  0x00007ffff682bd1a in FEProblemBase::computeResidualTags (this=0x555555cd4bc0, tags=...)\n    at /home/wang/projects/moose/framework/src/problems/FEProblemBase.C:7058\n#9  0x00007ffff6828f8f in FEProblemBase::computeResidualInternal (this=0x555555cd4bc0, soln=..., residual=..., \n    tags=...) at /home/wang/projects/moose/framework/src/problems/FEProblemBase.C:6898\n#10 0x00007ffff6827102 in FEProblemBase::computeResidual (this=0x555555cd4bc0, soln=..., residual=..., \n    nl_sys_num=0) at /home/wang/projects/moose/framework/src/problems/FEProblemBase.C:6720\n#11 0x00007ffff6826983 in FEProblemBase::computeResidualSys (this=0x555555cd4bc0, sys=..., soln=..., residual=...)\n    at /home/wang/projects/moose/framework/src/problems/FEProblemBase.C:6690\n#12 0x00007ffff52ae3f5 in ComputeResidualFunctor::residual (this=0x555555cf94c8, soln=..., residual=..., sys=...)\n    at /home/wang/projects/moose/framework/src/systems/ComputeResidualFunctor.C:27\n#13 0x00007fffef89d35d in libmesh_petsc_snes_residual ()\n   from /home/wang/miniforge/envs/moose/libmesh/lib/libmesh_dbg.so.0\n#14 0x00007fffe8094668 in SNESComputeFunction () from /home/wang/miniforge/envs/moose/petsc/lib/libpetsc.so.3.022\n#15 0x00007fffe806e931 in SNESSolve_NEWTONLS () from /home/wang/miniforge/envs/moose/petsc/lib/libpetsc.so.3.022\n#16 0x00007fffe809c505 in SNESSolve () from /home/wang/miniforge/envs/moose/petsc/lib/libpetsc.so.3.022\n#17 0x00007fffef8a4dc4 in libMesh::PetscNonlinearSolver<double>::solve(libMesh::SparseMatrix<double>&, libMesh::NumericVector<double>&, libMesh::NumericVector<double>&, double, unsigned int) ()\n   from /home/wang/miniforge/envs/moose/libmesh/lib/libmesh_dbg.so.0\n#18 0x00007fffef9426ce in libMesh::NonlinearImplicitSystem::solve() ()\n   from /home/wang/miniforge/envs/moose/libmesh/lib/libmesh_dbg.so.0\n#19 0x00007ffff52bacce in NonlinearSystem::solve (this=0x555555cf7bd0)\n    at /home/wang/projects/moose/framework/src/systems/NonlinearSystem.C:197\n#20 0x00007ffff681c85d in FEProblemBase::solve (this=0x555555cd4bc0, nl_sys_num=0)\n    at /home/wang/projects/moose/framework/src/problems/FEProblemBase.C:6247\n#21 0x00007ffff44fe0eb in FEProblemSolve::solve (this=0x555555d596f8)\n    at /home/wang/projects/moose/framework/src/executioners/FEProblemSolve.C:406\n#22 0x00007ffff4503a44 in FixedPointSolve::solveStep (this=0x555555d59d00, begin_norm=@0x555556398150: 0, \n    end_norm=@0x5555563c7630: 0, transformed_dofs=...)\n    at /home/wang/projects/moose/framework/src/executioners/FixedPointSolve.C:439\n#23 0x00007ffff45028d0 in FixedPointSolve::solve (this=0x555555d59d00)\n    at /home/wang/projects/moose/framework/src/executioners/FixedPointSolve.C:291\n#24 0x00007ffff6587b12 in TimeStepper::step (this=0x555555789dd0)\n    at /home/wang/projects/moose/framework/src/timesteppers/TimeStepper.C:168\n#25 0x00007ffff4513d62 in Transient::takeStep (this=0x555555d59340, input_dt=-1)\n    at /home/wang/projects/moose/framework/src/executioners/Transient.C:418\n#26 0x00007ffff45127e2 in Transient::execute (this=0x555555d59340)\n    at /home/wang/projects/moose/framework/src/executioners/Transient.C:293\n#27 0x00007ffff4b3406a in MooseApp::executeExecutioner (this=0x55555582d540)\n    at /home/wang/projects/moose/framework/src/base/MooseApp.C:1180\n#28 0x00007ffff4b3b552 in MooseApp::run (this=0x55555582d540)\n    at /home/wang/projects/moose/framework/src/base/MooseApp.C:1562\n#29 0x0000555555557e94 in Moose::main<MiracleTestApp> (argc=3, argv=0x7fffffffb5f8)\n    at /home/wang/projects/moose/framework/build/header_symlinks/MooseMain.h:47\n#30 0x00005555555576fd in main (argc=3, argv=0x7fffffffb5f8) at /home/wang/projects/miracle/src/main.C:17\nLooks like in \\moose\\framework? please give me some advices, thanks!\nZhaohao Wang",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11551053",
                          "updatedAt": "2024-12-13T01:27:21Z",
                          "publishedAt": "2024-12-13T01:27:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Stateful material properties are properties which depend on their value in a previous time step.\nUnfortunately this is not supported in finite volume right now, as the error message is telling you.\nI don't think it's even on the roadmap at this point. With finite volume we have fully transitioned to using functor material properties. These can handle statefulness. You would need to develop the materials again as functor materials to use this",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11551145",
                          "updatedAt": "2024-12-13T01:46:06Z",
                          "publishedAt": "2024-12-13T01:46:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "Ok, thanks. I will try to use functor, Thanks again for your quick response.",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11551201",
                          "updatedAt": "2024-12-13T01:57:02Z",
                          "publishedAt": "2024-12-13T01:57:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "emm, I can't find which material. I have change the FV variable porosity into FE variable. and in the FVKernels only has one variable - porosity.\n[FVKernels]\n  [porositydiffusion]\n    type = FVPoreDiffusion\n    variable = porosity\n    diffusivity = 1e-12\n  []\n  [porosityadvection]\n    type = FVPoreAdvection\n    variable = porosity\n    temperature = temp_fv\n    plutonium_concentration = 0\n  []\n  [porositytimederivative]\n    type = FVTimeKernel\n    variable = porosity\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11553836",
                          "updatedAt": "2024-12-13T08:34:55Z",
                          "publishedAt": "2024-12-13T08:34:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "More information I have find which FVkernel. Mainly copied FVAdvection, and add a RealVectorValue FVPoreAdvection::velocity() const. may be the VariableValue add in wrong way.\nregisterMooseObject(\"MiracleApp\", FVPoreAdvection);\n\nInputParameters\nFVPoreAdvection::validParams()\n{\n  InputParameters params = FVFluxKernel::validParams();\n  params.addRequiredCoupledVar(\"temperature\", \"the MOX temperature in K\");\n  params.addCoupledVar(\"plutonium_concentration\", \"the plutonium concentration in range 0 - 1\");\n  params += Moose::FV::advectedInterpolationParameter();\n  return params;\n}\n\nFVPoreAdvection::FVPoreAdvection(const InputParameters & params)\n  : FVFluxKernel(params),\n    _temperature(coupledValue(\"temperature\")),\n    _temperature_grad(coupledGradient(\"temperature\")),\n    _plutonium_concentration(coupledValue(\"plutonium_concentration\"))\n{\n  const bool need_more_ghosting =\n      Moose::FV::setInterpolationMethod(*this, _advected_interp_method, \"advected_interp_method\");\n  if (need_more_ghosting && _tid == 0)\n  {\n    adjustRMGhostLayers(std::max((unsigned short)(2), _pars.get<unsigned short>(\"ghost_layers\")));\n\n    // If we need more ghosting, then we are a second-order nonlinear limiting scheme whose stencil\n    // is liable to change upon wind-direction change. Consequently we need to tell our problem that\n    // it's ok to have new nonzeros which may crop-up after PETSc has shrunk the matrix memory\n    getCheckedPointerParam<FEProblemBase *>(\"_fe_problem_base\")\n        ->setErrorOnJacobianNonzeroReallocation(false);\n  }\n}\nRealVectorValue\nFVPoreAdvection::velocity() const\n{\nRealVectorValue velocity_sens =\n      5.006e-12 *\n      (0.988 + 6.395e-6 * _temperature[_qp] + 3.543e-9 * std::pow(_temperature[_qp], 2) +\n       3e-12 * std::pow(_temperature[_qp], 3)) *\n      std::pow(_temperature[_qp], -2.5) * vaporization * vapour_pressure * _temperature_grad[_qp];\n  return velocity_sens;\n}\n\nADReal\nFVPoreAdvection::computeQpResidual()\n{\n  const bool elem_is_upwind = velocity() * _normal >= 0;\n  const auto face =\n      makeFace(*_face_info, Moose::FV::limiterType(_advected_interp_method), elem_is_upwind);\n  ADReal u_interface = _var(face, determineState());\n\n  return _normal * velocity() * u_interface * (1 - u_interface);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11554571",
                          "updatedAt": "2024-12-13T09:44:35Z",
                          "publishedAt": "2024-12-13T09:44:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is your porosity actually changing in time? And at a rythm high enough that it matters for time integration purposes?\nIf porosity is the material that is requested at an older state, and porosity does not change, then you can delete that code that requires the old state and simply always use the current porosity",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11558905",
                          "updatedAt": "2024-12-13T15:59:45Z",
                          "publishedAt": "2024-12-13T15:59:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "I think the gdb pointing us in the wrong direction.\n\nIf porosity is the material that is requested at an older state, and porosity does not change, then you can delete that code that requires the old state and simply always use the current porosityz\nI don't use old value of porosity variable. In the material only\n\n  _porosity(coupledValue(\"porosity\")),\nif not use gdb the output is\n1068089 segmentation fault (core dumped)\nWhen I turn off FVPoreAdvection, the error disappears. This leads me to believe that there might be an issue with the coupled variable temperature. I am using ProjectionAux to transfer the FE-based temperature to an FV-based temperature. I have also included the code above for reference. Could you please take a look and provide some advice?\"",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11570131",
                          "updatedAt": "2024-12-15T06:10:35Z",
                          "publishedAt": "2024-12-15T06:10:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Taking another look at your code this is not going to work:\n    _temperature(coupledValue(\"temperature\")),\n    _temperature_grad(coupledGradient(\"temperature\")),\n\nthe graident of an FV variable through the coupleable interface is always 0 (const monomial shape function).\nCan you paste the header? I think you might have forgotten to store _temperature as a reference",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11572460",
                          "updatedAt": "2024-12-15T15:01:33Z",
                          "publishedAt": "2024-12-15T15:01:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "I realized that the _temperature_grad is 0 when the shape function is const. If I need the gradient, at least the shape function order is first. Badly, in MooseVariableFVReal only support MONOMIAL and CONSTANT.\nthere is a header part\nprotected:\n  virtual ADReal computeQpResidual() override;\n  const VariableValue & _temperature;\n  const VariableGradient & _temperature_grad;\n  const VariableValue & _plutonium_concentration;\n\n  RealVectorValue velocity();\n  Moose::FV::InterpMethod _advected_interp_method;\nI don't forget to use a reference.",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11575615",
                          "updatedAt": "2024-12-16T01:54:56Z",
                          "publishedAt": "2024-12-16T01:19:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "Oh, thank you. The error is caused by the temperature grad. when I use a simple RealVectorValue(1, 0, 0) replace it, the error disappear. Now the problem is how to get the gradient. Maybe I need to sort as the AuxVariable, I am trying.",
                          "url": "https://github.com/idaholab/moose/discussions/29525#discussioncomment-11575916",
                          "updatedAt": "2024-12-16T02:10:30Z",
                          "publishedAt": "2024-12-16T02:10:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "\"No Functor ever provided with name 'dh_dt' under 'T_time' FVKernel\" even though I listed the parameter",
          "author": {
            "login": "waaizhaq"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A Navier Stokes is the most appropriate category for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (avoid screenshots if possible, triple back quotes before/after pasted text, etc)\n\nQuestion\nHello,\nI am trying to conduct a simple natural convection problem in MOOSE, as shown below.\n\nMy mesh only consists of the natural circulation flow, so the width of the wall is neglected. I just set a left boundary condition of Ts, and made my mesh thickness 1 meter.\nI am very new to MOOSE so I am still learning how to use it. I've been following a lot of examples posted online in the framework to create my input file, so do let me know if something seems out of place.\nBut an error I've been running into is the 'dh_dt' not being provided even though I listed it under the INSFVEnergyTImeDerivative kernel. Is there something else that I'm missing?\nI also tried running this problem as a steady state by commenting out the time-dependent kernels and changing the executioner type to steady, but then I got an error about the solve not converging.\nBy the way, to run this input I copied the navier stokes module into my own separate directory and compiled it, following the instructions that were in the framework under 'Pre-Built MOOSE.'\nAdditional information\nMesh size and type: rectangular mesh, 5 by 5\nDiscretization (finite element CG/DG, finite volume, etc): finite volume\nModels (turbulence, porous media, etc): natural convection\nBase input you started from: nat_conv_wall.txt",
          "url": "https://github.com/idaholab/moose/discussions/29550",
          "updatedAt": "2024-12-16T03:07:01Z",
          "publishedAt": "2024-12-15T22:30:57Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis functor has to be defined by a FunctorMaterial. Here it should be this one:\nhttps://mooseframework.inl.gov/source/functormaterials/INSFVEnthalpyFunctorMaterial.html",
                  "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11574990",
                  "updatedAt": "2024-12-15T22:42:11Z",
                  "publishedAt": "2024-12-15T22:42:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "Thank you! I'll add this to my input and see if I run into any other issues.",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575013",
                          "updatedAt": "2024-12-15T22:48:28Z",
                          "publishedAt": "2024-12-15T22:48:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "So I've gotten past the FunctorMaterial issue, but I'm still running into convergence issues. I'm getting:\nLinear solve did not converge due to DIVERGED_PC_FAILED iterations 0\nPC failed due to FACTOR_NUMERIC_ZEROPIVOT\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0\nAnd I was looking at a similar discussion post that you answered a while back, mentioning to get around the FACTOR_NUMERIC_ZEROPIVOT, we can add a nonzero quantity to the diagonal, using the -pc_factor_shift NONZERO petsc options/values. I have that in my input but I'm still getting the same issue.",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575260",
                          "updatedAt": "2024-12-16T00:08:51Z",
                          "publishedAt": "2024-12-16T00:08:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "should be -pc_factor_shift_type iirc",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575287",
                          "updatedAt": "2024-12-16T00:15:43Z",
                          "publishedAt": "2024-12-16T00:15:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "That fixed it, thank you! I'm unfamiliar with the way MOOSE solves its simulations. Do you have any resources I can read into to understand the numerical methods of the different solvers?",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575360",
                          "updatedAt": "2024-12-16T00:29:31Z",
                          "publishedAt": "2024-12-16T00:29:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You ll have to look to the PETSc documentation for how the nonlinear system is solved. MOOSE does the assembly then calls petsc",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575469",
                          "updatedAt": "2024-12-16T00:46:52Z",
                          "publishedAt": "2024-12-16T00:46:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "If I wanted to run the simulation as steady-state, which parameters would I change? I've commented out the time-dependent kernels and also the TimeStepper block under the Executioner block, then changed Transient to Steady, but then I run into another DIVERGED_DTOL convergence issue, I also added automatic_scaling in my executioner block.\nFramework Information:\nMOOSE Version:           git commit 2bd11a0 on 2024-10-06\nLibMesh Version:\nPETSc Version:           3.21.5\nSLEPc Version:           3.21.1\nCurrent Time:            Sun Dec 15 19:53:48 2024\nExecutable Timestamp:    Sun Oct  6 04:10:42 2024\nCheckpoint:\nWall Time Interval:      Every 3600 s\nUser Checkpoint:         Disabled\nCheckpoints Kept:      2\nExecute On:              TIMESTEP_END\nParallelism:\nNum Processors:          1\nNum Threads:             1\nMesh:\nParallel Type:           replicated\nMesh Dimension:          2\nSpatial Dimension:       2\nNodes:                   36\nElems:                   25\nNum Subdomains:          1\nNonlinear System:\nNum DOFs:                100\nNum Local DOFs:          100\nVariables:               { \"vel_x\" \"vel_y\" \"pressure\" \"T\" }\nFinite Element Types:    \"MONOMIAL\"\nApproximation Orders:    \"CONSTANT\"\nExecution Information:\nExecutioner:             Steady\nSolver Mode:             NEWTON\nPETSc Preconditioner:    lu\nMOOSE Preconditioner:    SMP (auto)\nPostprocessor Values:\n+----------------+----------------+\n| time           | ave_T          |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+\nPerforming automatic scaling calculation\n0 Nonlinear |R| = 8.303678e+03\n0 Linear |R| = 8.303678e+03\n1 Linear |R| = 1.000718e-10\n1 Nonlinear |R| = 3.338182e+08\n0 Linear |R| = 3.338182e+08\n1 Linear |R| = 8.988101e-04\n2 Nonlinear |R| = 9.164821e+07\n0 Linear |R| = 9.164821e+07\n1 Linear |R| = 6.644202e-08\n3 Nonlinear |R| = 2.058075e+07\n0 Linear |R| = 2.058075e+07\n1 Linear |R| = 1.044626e-08\n4 Nonlinear |R| = 5.263572e+06\n0 Linear |R| = 5.263572e+06\n1 Linear |R| = 4.649094e-09\n5 Nonlinear |R| = 1.930216e+06\n0 Linear |R| = 1.930216e+06\n1 Linear |R| = 2.490749e-09\n6 Nonlinear |R| = 2.454784e+06\n0 Linear |R| = 2.454784e+06\n1 Linear |R| = 4.081857e-08\n7 Nonlinear |R| = 1.965131e+09\n0 Linear |R| = 1.965131e+09\n1 Linear |R| = 1.977286e-06\n8 Nonlinear |R| = 5.999012e+05\n0 Linear |R| = 5.999012e+05\n1 Linear |R| = 1.087908e-06\n9 Nonlinear |R| = 6.960520e+05\n0 Linear |R| = 6.960520e+05\n1 Linear |R| = 1.075856e-08\n10 Nonlinear |R| = 1.063886e+06\n0 Linear |R| = 1.063886e+06\n1 Linear |R| = 3.278389e-09\n11 Nonlinear |R| = 5.422805e+08\n0 Linear |R| = 5.422805e+08\n1 Linear |R| = 4.369014e-07\n12 Nonlinear |R| = 7.352211e+06\n0 Linear |R| = 7.352211e+06\n1 Linear |R| = 3.356987e-06\n13 Nonlinear |R| = 4.169012e+09\n0 Linear |R| = 4.169012e+09\n1 Linear |R| = 1.430620e-06\n14 Nonlinear |R| = 9.723472e+09\n0 Linear |R| = 9.723472e+09\n1 Linear |R| = 1.466204e-03\n15 Nonlinear |R| = 7.599592e+11\n0 Linear |R| = 7.599592e+11\n1 Linear |R| = 6.276364e-03\n16 Nonlinear |R| = 1.370462e+13\n0 Linear |R| = 1.370462e+13\n1 Linear |R| = 5.705603e+00\n17 Nonlinear |R| = 1.451590e+16\nNonlinear solve did not converge due to DIVERGED_DTOL iterations 17\nSolve Did NOT Converge!\nAborting as solve did not converge",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11575911",
                          "updatedAt": "2024-12-16T02:09:35Z",
                          "publishedAt": "2024-12-16T02:09:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For steady state (without using a relaxation transient) you need to work on the initialization. The initial condition needs to fall in the region of attraction of the solution, which can be hard to do\nIt's generally easier to use a relaxation-to-steady state transient",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11576090",
                          "updatedAt": "2024-12-16T02:40:33Z",
                          "publishedAt": "2024-12-16T02:40:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "waaizhaq"
                          },
                          "bodyText": "I understand, I think that's what I have for my transient case, where it runs the simulation until it reaches steady state.",
                          "url": "https://github.com/idaholab/moose/discussions/29550#discussioncomment-11576212",
                          "updatedAt": "2024-12-16T03:07:01Z",
                          "publishedAt": "2024-12-16T03:07:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error: Section '[Sphinx]' does not have an associated \"Action\" after Updating MOOSE",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello everyone,\nYesterday I updated MOOSE to the latest version (it had been several months since my last update). After recompiling my custom application successfully, I encountered the following error when running my input file:\ntest.i:79.1: section '[Sphinx]' does not have an associated \"Action\".\n Common causes:\n- you misspelled the Action/section name\n- the app you are running does not support this Action/syntax\n\nThe issue is that I do have this custom action implemented in my application, and it was working fine before the MOOSE update.\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_variable\");\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_kernel\");\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_bc\");\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_aux_variable\");\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_aux_kernel\");\nregisterMooseAction(\"SphinxApp\", SphinxAction, \"add_user_object\");\n\nIs there any recent change in MOOSE\u2019s handling of custom actions or input file parsing that I should be aware of? Or could there be additional steps needed after updating MOOSE to ensure custom actions are recognized?\nAny guidance would be greatly appreciated.\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/29545",
          "updatedAt": "2024-12-16T02:24:04Z",
          "publishedAt": "2024-12-15T08:57:44Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo we have not changed neither of these.\nDo you have in SphixApp.C a call to register SphinxAction to the [Sphinx] block?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/29545#discussioncomment-11572402",
                  "updatedAt": "2024-12-15T14:54:29Z",
                  "publishedAt": "2024-12-15T14:54:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you for your response. After the update, I forgot to modify the autogenerated SphixApp.C. As you pointed out, I indeed didn\u2019t register SphinxAction in SphixApp.C. After making the necessary changes, the issue has been resolved.\nThanks again for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/29545#discussioncomment-11575981",
                          "updatedAt": "2024-12-16T02:24:02Z",
                          "publishedAt": "2024-12-16T02:24:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Grids and convergence",
          "author": {
            "login": "HPL001"
          },
          "bodyText": "I came across a confusing situation. I am trying to reproduce some of the particle sintering phenomena in the paper by running the following input file using combined-opt under module/combined.\nWhen the mesh is set here, the program can compute normally and converge.\n[Mesh] # Generate mesh (7/3D X 4/3D)\n  type = GeneratedMesh\n  dim = 2\n  nx = 70\n  ny = 40\n  xmin = 0\n  xmax = 70.0\n  ymin = 0\n  ymax = 40.0\n  elem_type = QUAD4\n[]\n\nBut when the mesh is set this way, the program no longer converges and diverges.\n[Mesh] # Generate mesh (7/3D X 4/3D)\n  type = GeneratedMesh\n  dim = 2\n  nx = 140\n  ny = 80\n  xmin = 0\n  xmax = 70.0\n  ymin = 0\n  ymax = 40.0\n  elem_type = QUAD4\n[]\n\nAs you can see, I've actually done nothing but encrypt the grid, and I'm confused as to why this is happening.",
          "url": "https://github.com/idaholab/moose/discussions/29538",
          "updatedAt": "2024-12-14T11:54:35Z",
          "publishedAt": "2024-12-13T16:05:45Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "can you please attach the log?\nIt's probably just a matter of selecting solver settings that work for the finer mesh problem",
                  "url": "https://github.com/idaholab/moose/discussions/29538#discussioncomment-11560764",
                  "updatedAt": "2024-12-13T18:33:21Z",
                  "publishedAt": "2024-12-13T18:33:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "HPL001"
                          },
                          "bodyText": "Hello, this is the log file. I saved the whole process, the calculation converges at the beginning, then diverges at about 0.15s, and then gets farther and farther on the way of divergence.\n001.txt",
                          "url": "https://github.com/idaholab/moose/discussions/29538#discussioncomment-11563533",
                          "updatedAt": "2024-12-14T04:00:53Z",
                          "publishedAt": "2024-12-14T04:00:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "set the max linear number of iterations higher. It calls the iteration diverged when it is slowly converging, hitting a max of 30 seemingly.\nyou can also consider turning off the line search with line_search = none as some iterations were failed because of that",
                          "url": "https://github.com/idaholab/moose/discussions/29538#discussioncomment-11563776",
                          "updatedAt": "2024-12-14T05:25:10Z",
                          "publishedAt": "2024-12-14T05:25:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this isnt great\n    cutback_factor = 0.5\n    dt = 0.001\n    growth_factor = 1.1\n\nit cuts down the time step by a lot when it fails, then grows it very slowly when passing. A failed time step every now and then can occur, but it s penalizing the time stepping a lot here",
                          "url": "https://github.com/idaholab/moose/discussions/29538#discussioncomment-11563779",
                          "updatedAt": "2024-12-14T05:26:11Z",
                          "publishedAt": "2024-12-14T05:26:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiple outputs per step - adaptivity",
          "author": {
            "login": "HPL001"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI used the following output Settings, but I didn't get the output for each time step. Instead, I get the output for each iteration of each time step. How should I set this up\uff1f\n[Outputs]\n  exodus = true\n  print_linear_residuals = true\n  execute_on = timestep_end\n  [out]\n    type = VTK # \u8f93\u51fa VTK \u6587\u4ef6\n    time_step_interval = 1 # \u6bcf\u4e2a\u65f6\u95f4\u6b65\u8f93\u51fa\n    file_base = Sintering_output # \u8f93\u51fa\u6587\u4ef6\u7684\u57fa\u7840\u540d\u79f0\n    enable = true\n    execute_on = 'timestep_end'\n  []",
          "url": "https://github.com/idaholab/moose/discussions/29536",
          "updatedAt": "2024-12-20T13:16:04Z",
          "publishedAt": "2024-12-13T04:48:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nremove this it's not needed\n    time_step_interval = 1 # \u6bcf\u4e2a\u65f6\u95f4\u6b65\u8f93\u51fa\n\nWhere are the iterations coming from? From the nonlinear solver or from fixed point iterations with a MultiApp?",
                  "url": "https://github.com/idaholab/moose/discussions/29536#discussioncomment-11552143",
                  "updatedAt": "2024-12-13T04:52:58Z",
                  "publishedAt": "2024-12-13T04:52:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "HPL001"
                          },
                          "bodyText": "Thank you for your reply, specifically, my execution part is this\n[Executioner]\n  type = Transient\n  scheme = BDF2\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_ksp_type\n                        -sub_pc_type -pc_asm_overla'\n  petsc_options_value = 'asm      31       preonly\n                         ilu      2'\n  l_tol = 1e-05\n  nl_max_its = 30\n  l_max_its = 50\n  nl_rel_tol = 1e-07\n  nl_abs_tol = 1e-09\n  start_time = 0.0\n  end_time = 1.0\n  # dt = 0.00125\n\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    cutback_factor = 0.5\n    dt = 0.001\n    growth_factor = 1.1\n    optimal_iterations = 15\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/29536#discussioncomment-11552168",
                          "updatedAt": "2024-12-13T04:55:32Z",
                          "publishedAt": "2024-12-13T04:55:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "i think these multiple files per time step are from steps of adaptivity.\nYou can try to output on timestep begin instead of timestep_end to (maybe) prevent outputting multiple files per time step",
                          "url": "https://github.com/idaholab/moose/discussions/29536#discussioncomment-11552221",
                          "updatedAt": "2024-12-13T05:05:54Z",
                          "publishedAt": "2024-12-13T05:05:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "HPL001"
                          },
                          "bodyText": "Thanks for your reply, I have modified the input file according to your suggestion, but it seems to have no effect.\n[Outputs]\n  exodus = true\n  print_linear_residuals = true\n  execute_on = timestep_end\n  [out]\n    type = VTK\n    file_base = Sintering_output\n    enable = true\n    execute_on = 'timestep_begin'\n  []\n  # [out]\n  #   type = Tecplot\n  #   ascii_append = true\n  # []\n\n  [debug] # report variable residual\n    type = VariableResidualNormsDebugOutput\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/29536#discussioncomment-11552500",
                          "updatedAt": "2024-12-13T05:54:29Z",
                          "publishedAt": "2024-12-13T05:54:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "HPL001"
                          },
                          "bodyText": "@GiudGiud Hello dear developer, can you continue to give me some advice.",
                          "url": "https://github.com/idaholab/moose/discussions/29536#discussioncomment-11557231",
                          "updatedAt": "2024-12-13T13:47:29Z",
                          "publishedAt": "2024-12-13T13:47:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok then we dont have an option to do this. You would need to modify the FEProblemSolve.C class to output at the end of the adaptivity loop, if I am correct that these files are from adaptivity. You can open them all for a time step and check that the only difference is the local mesh refinement.\nHave too many output files is not really preventing you from doing anything though so I would recommend you move on",
                          "url": "https://github.com/idaholab/moose/discussions/29536#discussioncomment-11557978",
                          "updatedAt": "2024-12-13T14:44:27Z",
                          "publishedAt": "2024-12-13T14:44:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "HPL001"
                          },
                          "bodyText": "Thank you for your reply, which is a good solution to my problem",
                          "url": "https://github.com/idaholab/moose/discussions/29536#discussioncomment-11558872",
                          "updatedAt": "2024-12-13T15:56:23Z",
                          "publishedAt": "2024-12-13T15:56:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Symmteric boundary condition in 2D and 3D",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Hello everyone,\nI wanted to just simulate half of the domain in 2d and quarter in 3d thanks to the symmetry of the problem.\nBut I do not know how to apply symmetric boundary condition on a line in 2d and on planes in 3d.\nIn moose I performed simulations in RZ coordinates and specifying axis of symmetry, so I'm wondering whether symmetric boundary condition is also available in moose. Simply using no flux bc is not working in my problem.\nThanks,\nAli",
          "url": "https://github.com/idaholab/moose/discussions/24898",
          "updatedAt": "2024-12-13T08:49:46Z",
          "publishedAt": "2023-07-04T23:29:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis depends on the physics. For example for diffusion, symmetry is simply \"no flux\"\nFor fluid flow with finite volume, symmetry means \"no flux\" but also \"no wall shear stress\"\nWhat physics are you solving?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24898#discussioncomment-6358379",
                  "updatedAt": "2023-07-05T03:56:12Z",
                  "publishedAt": "2023-07-05T03:56:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "I am simulating multiphase flow with coupled phase field (Cahn Hilliard) and Navier stokes. So my variables are vel_x, vel_y, vel_z, p, c (order parameter), w (chemical potential).",
                          "url": "https://github.com/idaholab/moose/discussions/24898#discussioncomment-6366172",
                          "updatedAt": "2023-07-05T18:32:29Z",
                          "publishedAt": "2023-07-05T18:32:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "All finite element right?\nI would think 0 flux would be fine for those to achieve symmetry. You may have to dive into the equations to understand why it's not",
                          "url": "https://github.com/idaholab/moose/discussions/24898#discussioncomment-6368417",
                          "updatedAt": "2023-07-06T00:02:43Z",
                          "publishedAt": "2023-07-06T00:02:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "CAPRICORN12341234"
                          },
                          "bodyText": "\u5982\u679c\u5bf9\u79f0\u8fb9\u754c\u6761\u4ef6\uff0c\u5047\u5982\u5bf9\u79f0\u8fb9\u754c\u5782\u76f4\u4e8ex\u8f74\uff0c\u5219vel_x=0\uff0c\\nabla p  = \\nabla c = \\nabla w = \\nabla v_y = \\nabla v_z =0",
                          "url": "https://github.com/idaholab/moose/discussions/24898#discussioncomment-11553976",
                          "updatedAt": "2024-12-13T08:49:47Z",
                          "publishedAt": "2024-12-13T08:49:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Traction-free vs Stress-free boundary",
          "author": {
            "login": "zzzmx-josh"
          },
          "bodyText": "I understand that when no displacement is prescribed on the boundary (i.e., free boundary conditions), the traction-free condition is defined as:\n$$\\sigma_{ij} \\cdot n_j = 0 \\quad$$,\nwhich implies no normal or tangential traction on the boundary. However, in my simulation, I aim to implement stress-free boundary conditions, where all components of the stress tensor vanish on the boundary:\n$$\\sigma_{ij} = 0$$.\nCould you please advise on how to achieve this in MOOSE? Are there specific settings, constraints, or additional steps required to enforce $$\\sigma_{ij} = 0$$ on the boundary?\nThank you for your time and assistance.",
          "url": "https://github.com/idaholab/moose/discussions/29535",
          "updatedAt": "2024-12-13T07:46:42Z",
          "publishedAt": "2024-12-13T04:21:03Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nStress free boundary should be the default boundary condition when no BC is applied on a boundary\nYou should be able to verify that by exporting the stress material property on a boundary to an auxiliary variable (defined in the whole volume by default, but the auxkernel would be defined only on the boundary)",
                  "url": "https://github.com/idaholab/moose/discussions/29535#discussioncomment-11552135",
                  "updatedAt": "2024-12-13T04:51:34Z",
                  "publishedAt": "2024-12-13T04:51:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zzzmx-josh"
                          },
                          "bodyText": "I\u2019ve now figured it out, Thank you so much for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/29535#discussioncomment-11553333",
                          "updatedAt": "2024-12-13T07:39:54Z",
                          "publishedAt": "2024-12-13T07:39:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Interpolation function in strong form Vs. weak form",
          "author": {
            "login": "ashishdhole"
          },
          "bodyText": "Hello,\nAs moose solves the PDE in weak form. is it possible that the value of any additional driving force in the form of an interpolation function (like  3.eta_i.eta_j.Pz) is different when calculated in moose. If so is there any scaling rule I must follow?\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/29427",
          "updatedAt": "2024-12-13T01:57:48Z",
          "publishedAt": "2024-12-10T05:09:10Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nis it possible that the value of any additional driving force in the form of an interpolation function (like 3.eta_i.eta_j.Pz) is different when calculated in moose.\n\nI'm not sure I understand why it would be different?\nYou can output the contribution of a given kernel to check, using either the deprecated save_in method, or the \"extra_vector_tags\" options, then using a TagVectorAux to output the contribution to the residual to an auxiliary variable",
                  "url": "https://github.com/idaholab/moose/discussions/29427#discussioncomment-11521197",
                  "updatedAt": "2024-12-10T13:40:46Z",
                  "publishedAt": "2024-12-10T13:40:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "in\n\nin theory when the value of m =2, L=1, and k = 4 is used the residual should become zero with the corresponding value of Pz = 0.045 = \u0394G_ij\ni.e. interface energy, \u03c3 = (1/3) sqrt(2mk)\ndriving force for an interface Pd = \u03c3/R # here R is the radius of curvature\nbased on this if R = 30 , \u03c3 = 1.3333 (based on the values of m and k mentioned above)\nPd = 0.04444\nthat means if Pz = 0.045 which is more than Pd, the interface should not move at all.\nThat is the driving foce (1st and third term in above equation) becomes equal to the pinning force (second term in above equation).\nThat is in theory. But when I am solving the PDE in MOOSE, even with Pz=1 the residual never becomes zero.\nThis should not happen.\nThe way I am writing these terms in moose kernel is  as follows\n  Real SumEtaj = 0.0;\n  Real SumEtaj_G = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumEtaj += (*_vals[i])[_qp] * (*_vals[i])[_qp];\n    SumEtaj_G += (*_vals[i])[_qp];\n  }\n\n  Real g = _g[_qp];\n  Real total = (_test[_i][_qp] * _mu[_qp] *\n                (_u[_qp] * _u[_qp] * _u[_qp] - _u[_qp] + 3 * _u[_qp] * SumEtaj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]); //1st and 3rd term in above equation\n\n  Real friction = _test[_i][_qp] * 3 * g * _u[_qp] * SumEtaj_G; //second term in above equation, Pz = g\n\nThe set of equations are correct that means the only possible explanation is that moose is not able to calculate the interpolation function (second term) value correctly.\nUnless you think the equation is wrongly written in the kernel.\nThe same equation and corresponding values of constants were used in analytical model and an FDM model. Both these models shows the desired results except in moose.",
                          "url": "https://github.com/idaholab/moose/discussions/29427#discussioncomment-11524516",
                          "updatedAt": "2024-12-10T18:36:18Z",
                          "publishedAt": "2024-12-10T18:20:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "//1st and 3rd term in above equation\n\nshouldnt the 3rd term have a minus?\nsame for the second term?\nsince the first term has a + sign in both the equation and the implementation (keeping in mind you move it to the LHS so the sign in front of L disappears)",
                          "url": "https://github.com/idaholab/moose/discussions/29427#discussioncomment-11524863",
                          "updatedAt": "2024-12-10T19:06:57Z",
                          "publishedAt": "2024-12-10T19:06:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I remember asking this question in my very early queries long time ago.\n\nAs you can see the way MOOSE implemented this equation has negative sign to the third term of equation, but if you look at the grain growth action kernel, there is no negative sign in ACInterface.\nGrainGrowthAction = TimeDerivative + ACGrGrPoly + ACInterface\nAs for the second term I am putting the '-' sign in the final return\n  Real SumEtaj = 0.0;\n  Real SumEtaj_G = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumEtaj += (*_vals[i])[_qp] * (*_vals[i])[_qp];\n    SumEtaj_G += (*_vals[i])[_qp];\n  }\n\n  Real g = _g[_qp];\n  Real total = (_test[_i][_qp] * _mu[_qp] *\n                (_u[_qp] * _u[_qp] * _u[_qp] - _u[_qp] + 3 * _u[_qp] * SumEtaj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]); //1st and 3rd term in above equation\n\n  Real friction = _test[_i][_qp] * 3 * g * _u[_qp] * SumEtaj_G; //second term in above equation, Pz = g\n\n  const Real sgn = (total > 0) - (total < 0);\n\n  return (total - sgn * friction);",
                          "url": "https://github.com/idaholab/moose/discussions/29427#discussioncomment-11524936",
                          "updatedAt": "2024-12-10T19:20:24Z",
                          "publishedAt": "2024-12-10T19:16:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "As you can see the way MOOSE implemented this equation has negative sign to the third term of equation, but if you look at the grain growth action kernel, there is no negative sign in ACInterface.\n\nThis equation is written with the term on the LHS already. So they have the sign right for the equation they wrote, but your equation has a different sign",
                          "url": "https://github.com/idaholab/moose/discussions/29427#discussioncomment-11525057",
                          "updatedAt": "2024-12-10T19:31:19Z",
                          "publishedAt": "2024-12-10T19:31:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I tried with minus sign. In that case even the normal grain growth does not work\nwith + sign in 3rd term\nFramework Information:\nMOOSE Version:           git commit 19f35c4703 on 2024-10-25\nLibMesh Version:         \nPETSc Version:           3.21.5\nSLEPc Version:           3.21.1\nCurrent Time:            Tue Dec 10 11:32:24 2024\nExecutable Timestamp:    Tue Dec 10 11:31:39 2024\n\nCheckpoint:\n  Wall Time Interval:      Every 3600 s\n  User Checkpoint:         Outputs/checkpoint\n  # Checkpoints Kept:      2\n  Execute On:              TIMESTEP_END \n\nParallelism:\n  Num Processors:          4\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   \n    Total:                 58081\n    Local:                 14653\n    Min/Max/Avg:           14360/14653/14520\n  Elems:                   \n    Total:                 14400\n    Local:                 3600\n    Min/Max/Avg:           3600/3600/3600\n  Num Subdomains:          1\n  Num Partitions:          4\n  Partitioner:             metis\n\nNonlinear System:\n  Num DOFs:                146410\n  Num Local DOFs:          37270\n  Num Constrained DOFs:    2410\n  Local Constrained DOFs:  600\n  Variables:               { \"gr0\" \"gr1\" \"gr2\" \"gr3\" \"gr4\" \"gr5\" \"gr6\" \"gr7\" \"gr8\" \"gr9\" } \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                58082\n  Num Local DOFs:          14654\n  Num Constrained DOFs:    482\n  Local Constrained DOFs:  120\n  Variables:               \"bnds\" { \"unique_grains\" \"var_indices\" } \"phi\" \n  Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\" \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \"CONSTANT\" \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             IterationAdaptiveDT\n  TimeIntegrator:          BDF2\n  Solver Mode:             Preconditioned JFNK\n  PETSc Preconditioner:    hypre boomeramg \n\n\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   1.000000e+02 |   0.000000e+00 |   1.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\n\nTime Step 1, time = 0.1, dt = 0.1\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 2.407867e+01\n      0 Linear |R| = 2.407867e+01\n      1 Linear |R| = 1.146862e+00\n      2 Linear |R| = 9.927316e-02\n      3 Linear |R| = 7.939899e-03\n 1 Nonlinear |R| = 3.172691e+00\n      0 Linear |R| = 3.172691e+00\n      1 Linear |R| = 3.064988e-01\n      2 Linear |R| = 5.739507e-02\n      3 Linear |R| = 1.414087e-02\n      4 Linear |R| = 2.370168e-03\n 2 Nonlinear |R| = 2.885722e-01\n      0 Linear |R| = 2.885722e-01\n      1 Linear |R| = 3.185012e-02\n      2 Linear |R| = 6.540664e-03\n      3 Linear |R| = 1.411937e-03\n      4 Linear |R| = 3.043319e-04\n 3 Nonlinear |R| = 1.874856e-02\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  gr0: 9.102239e-03\n  gr1: 1.037014e-02\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   1.000000e+02 |   0.000000e+00 |   1.000000e+02 |\n|   1.000000e-01 |   2.044920e+05 |   9.861869e+01 |   0.000000e+00 |   1.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nSteady-State Relative Differential Norm: 2.13711\n\nwith minus sign in 3rd term\nFramework Information:\nMOOSE Version:           git commit 19f35c4703 on 2024-10-25\nLibMesh Version:         \nPETSc Version:           3.21.5\nSLEPc Version:           3.21.1\nCurrent Time:            Tue Dec 10 11:34:59 2024\nExecutable Timestamp:    Tue Dec 10 11:34:48 2024\n\nCheckpoint:\n  Wall Time Interval:      Every 3600 s\n  User Checkpoint:         Outputs/checkpoint\n  # Checkpoints Kept:      2\n  Execute On:              TIMESTEP_END \n\nParallelism:\n  Num Processors:          4\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   \n    Total:                 58081\n    Local:                 14653\n    Min/Max/Avg:           14360/14653/14520\n  Elems:                   \n    Total:                 14400\n    Local:                 3600\n    Min/Max/Avg:           3600/3600/3600\n  Num Subdomains:          1\n  Num Partitions:          4\n  Partitioner:             metis\n\nNonlinear System:\n  Num DOFs:                146410\n  Num Local DOFs:          37270\n  Num Constrained DOFs:    2410\n  Local Constrained DOFs:  600\n  Variables:               { \"gr0\" \"gr1\" \"gr2\" \"gr3\" \"gr4\" \"gr5\" \"gr6\" \"gr7\" \"gr8\" \"gr9\" } \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                58082\n  Num Local DOFs:          14654\n  Num Constrained DOFs:    482\n  Local Constrained DOFs:  120\n  Variables:               \"bnds\" { \"unique_grains\" \"var_indices\" } \"phi\" \n  Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\" \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \"CONSTANT\" \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             IterationAdaptiveDT\n  TimeIntegrator:          BDF2\n  Solver Mode:             Preconditioned JFNK\n  PETSc Preconditioner:    hypre boomeramg \n\n\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   1.000000e+02 |   0.000000e+00 |   1.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\n\nTime Step 1, time = 0.1, dt = 0.1\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 6.437778e+01\n      0 Linear |R| = 6.437778e+01\n    Linear solve did not converge due to DIVERGED_NANORINF iterations 0\n  Nonlinear solve did not converge due to DIVERGED_LINEAR_SOLVE iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nSolve failed, cutting timestep.\n\nTime Step 1, time = 0.05, dt = 0.05\n 0 Nonlinear |R| = 6.437778e+01\n      0 Linear |R| = 6.437778e+01\n    Linear solve did not converge due to DIVERGED_NANORINF iterations 0\n  Nonlinear solve did not converge due to DIVERGED_LINEAR_SOLVE iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge\n\n\nwith + sign my kernel behaves same as GrainGrowthAction (exactly same even the timesteps increment)",
                          "url": "https://github.com/idaholab/moose/discussions/29427#discussioncomment-11525106",
                          "updatedAt": "2024-12-10T19:36:08Z",
                          "publishedAt": "2024-12-10T19:36:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "@tonkmr Suggested I should use\nReal total = (_mu[_qp] * (_u[_qp] * _u[_qp] * _u[_qp] - _u[_qp] + 3 * _u[_qp] * SumEtaj)) -\n             (_kappa[_qp] * _second_u[_qp].tr());\n\ninstead of\n  Real total = (_test[_i][_qp] * _mu[_qp] *\n                (_u[_qp] * _u[_qp] * _u[_qp] - _u[_qp] + 3 * _u[_qp] * SumEtaj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]); \n\nbut then in residual when I am using\nReal total = (_test[_i][_qp]  * _mu[_qp] * (_u[_qp] * _u[_qp] * _u[_qp] - _u[_qp] + 3 * _u[_qp] * SumEtaj)) -\n             (_kappa[_qp] * _second_u[_qp].tr()) * _second_test[_i][_qp].tr();\n\nIt doesn't work\neven with higher order element",
                  "url": "https://github.com/idaholab/moose/discussions/29427#discussioncomment-11525468",
                  "updatedAt": "2024-12-10T20:22:09Z",
                  "publishedAt": "2024-12-10T20:21:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Hello @laagesen , can you help me with this problem?\nThank you",
                          "url": "https://github.com/idaholab/moose/discussions/29427#discussioncomment-11551207",
                          "updatedAt": "2024-12-13T01:57:48Z",
                          "publishedAt": "2024-12-13T01:57:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Adding a writable variable to a Kernel",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi all,\nIn the computeQpResidual method in a kernel, I want to save an intermediate value to an aux variable. This won't affect the solve, it is just for post processing reasons.\nI am having trouble properly writing in the aux variable in a way that it is writable.\nFor example\nADReal\nsomeKernel::computeQpResidual(){\n\nADReal value = _grad_test[_i][_qp] * _grad_u[_qp];\n_aux_var[_qp] = value\n\nreturn value * (some function);\n\n}\n\nI want to write to _aux_var[_qp].\nWhat is the correct way to declare this aux variable?",
          "url": "https://github.com/idaholab/moose/discussions/29534",
          "updatedAt": "2024-12-12T21:27:21Z",
          "publishedAt": "2024-12-12T20:55:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nIn the computeQpResidual method in a kernel, I want to save an intermediate value to an aux variable. This won't affect the solve, it is just for post processing reasons.\n\nWe dont typically do that. Auxvariables are computed by auxkernels.\nYou can use this interface to do this and save to a tagged vector\nhttps://mooseframework.inl.gov/source/interfaces/TaggingInterface.html\nThe auxvariable is then used along with a TagVectorAux to retrieve the value that has been saved in the tagged vector",
                  "url": "https://github.com/idaholab/moose/discussions/29534#discussioncomment-11549407",
                  "updatedAt": "2024-12-12T21:05:18Z",
                  "publishedAt": "2024-12-12T21:05:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Ah I always forget about this. Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/29534#discussioncomment-11549422",
                          "updatedAt": "2024-12-12T21:07:14Z",
                          "publishedAt": "2024-12-12T21:07:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "2025 New England MOOSE & Bison Training January 15-16",
          "author": {
            "login": "GiudGiud"
          },
          "bodyText": "The Idaho National Laboratory is providing a MOOSE and a BISON training in January 2025 at University of Massachusetts in Lowell.\nFor the MOOSE workshop on January 15-16:\nMOOSE is an open-source finite element & finite volume framework developed by the DOE national laboratories that is the base for much of the advanced nuclear reactor modeling software. There are also several ongoing projects to develop MOOSE applications for fusion device modeling.\nThe Multiphysics Object Oriented Simulation Environment (MOOSE) Workshop provides an in-depth introduction to the framework. The course is two days in length and covers material starting from the mathematical underpinnings of the framework through advanced features of the MOOSE Multiapps system. The course uses a realistic multiphysics problem that is solved with increasing realism and complexity utilizing the many pluggable systems in the framework. Hands on exercises are supplied so attendees are encouraged to bring their own hardware to participate. More information about MOOSE can be found on our website.\n\n\nFlow simulations of a spent fuel cask and a T-junction using MOOSE\n\nFor BISON workshop on January 17th:\nThe BISON fuel performance team is hosting a one-day, workshop. This workshop is intended to help prospective users get started with the code, provide an overview of the methods to model specific fuel types, and provide practical examples to help users gain experience. Please forward this message to anyone at your institution interested in BISON, fuel performance modeling, or MOOSE-related software.\nWORKSHOP TOPICS\n\u2022 Introduction to thermomechanical fuel performance modeling and multiphysics analysis\n\u2022 Code development principles and contribution of new models\n\u2022 Overview of LWR, TRISO, and Metallic fuel capabilities\n\u2022 Meshing fuel geometries\n\u2022 Simulation output analysis and visualization\nThe registration deadline will be flexible for the MOOSE training but we encourage early registration as space is limited. Registration for the BISON workshop will close January 15th. Access to a BISON license by the training date is not guaranteed. Please email me for any issue or question with registration.\nRegistration link: https://ncrcaims.inl.gov/Identity/Account/TrainingRegistration",
          "url": "https://github.com/idaholab/moose/discussions/28990",
          "updatedAt": "2024-12-12T18:04:41Z",
          "publishedAt": "2024-11-01T18:57:22Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      }
    ]
  }
}