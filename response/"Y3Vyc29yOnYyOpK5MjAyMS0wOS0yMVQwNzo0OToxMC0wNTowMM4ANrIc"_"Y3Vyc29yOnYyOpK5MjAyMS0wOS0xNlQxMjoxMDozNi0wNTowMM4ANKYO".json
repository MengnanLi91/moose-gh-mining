{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wOS0xNlQxMjoxMDozNi0wNTowMM4ANKYO"
    },
    "edges": [
      {
        "node": {
          "title": "A 'ReporterPointSource' is not a registered object",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi, I am trying to apply point source by using Dirac kernel that read the point sources from csv file. I am using the ReporterPointSource object to do that but I am getting an error. This error is as follows:\n\n*** ERROR ***\nA 'ReporterPointSource' is not a registered object.\n\n\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\n\n\nStack frames: 21\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >)\n2: void mooseError<std::__cxx11::basic_string<char, std::char_traits, std::allocator > >(std::__cxx11::basic_string<char, std::char_traits, std::allocator >&&)\n3: Factory::reportUnregisteredError(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&) const\n4: Factory::getValidParams(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&)\n5: MooseObjectAction::MooseObjectAction(InputParameters)\n6: AddDiracKernelAction::AddDiracKernelAction(InputParameters)\n7: /home/aaelmeli/projects/moose/framework/libmoose-opt.so.0(+0x7c9b98) [0x7fa6369f9b98]\n8: std::shared_ptr moose::internal::buildAct(InputParameters const&)\n9: ActionFactory::create(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, InputParameters&)\n10: Parser::walkRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >, hit::Node*)\n11: Parser::walk(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, hit::Node*)\n12: hit::Node::walk(hit::Walker*, hit::NodeType)\n13: hit::Node::walk(hit::Walker*, hit::NodeType)\n14: hit::Node::walk(hit::Walker*, hit::NodeType)\n15: Parser::parse(std::vector<std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::allocator<std::__cxx11::basic_string<char, std::char_traits, std::allocator > > > const&)\n16: MooseApp::setupOptions()\n17: MooseApp::run()\n18: ./first_test-opt(+0x5263) [0x7fa63800d263]\n19: __libc_start_main\n20: ./first_test-opt(+0x54ed) [0x7fa63800d4ed]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\n\nMy minimal input file reproduce this error is as follows:\n[Mesh]\n  type = GeneratedMesh\n   dim = 2\n    xmin=0\n   xmax=1\n   ymin=0\n   ymax=1.0\n   nx = 10\n   ny=10\n[]\n\n[Variables]\n [u]\n   order = FIRST\n   family = LAGRANGE\n []\n[]\n\n\n[Kernels]\n [diff]\n   type = MatDiffusion\n   variable = u\n   diffusivity = _diff2_\n []\n[]\n\n[DiracKernels]\n\n [./diracforce]\n type = ReporterPointSource\n  variable = u\n  value_name = 'csv_reader/u'\n  x_coord_name = csv_reader/x\n  y_coord_name = csv_reader/y\n   z_coord_name = csv_reader/z\n []\n[]\n\n\n[Functions]\n   [./func]\n   type = ParsedFunction\n   value=10\n   [../]\n[]\n[Materials]\n  [./mat_parsed]\n  type = GenericFunctionMaterial\n  prop_names  = '_diff2_'\n  prop_values = 'func'\n  [../]\n[]\n\n[BCs]\n [./BC_left]\n   type = DirichletBC\n   variable = u\n   boundary = 3\n   value= 0\n []\n [./BC_right]\n   type = NeumannBC\n   variable = u\n   boundary = 1\n   value= 1000\n []\n[]\n\n[VectorPostprocessors]\n   [csv_reader]\n   type = CSVReader\n   csv_file = 'zForwardOutput/all_u_0002.csv'\n []\n[]\n[Executioner]\nexecute_on = 'initial timestep_end'\n type = Steady\n solve_type = 'LINEAR'\n[]\n\n\n[Outputs]\n [exodus]\n   file_base = 'ForwardOutput/out_'\n   type = Exodus\n   execute_on = final\n []\n [all_response]\n   file_base = 'ForwardOutput/all_'\n   type = CSV\n   execute_vector_postprocessors_on = initial\n []\n[]\n\n\n\nAny idea on how to fix this?",
          "url": "https://github.com/idaholab/moose/discussions/18845",
          "updatedAt": "2022-07-20T20:01:44Z",
          "publishedAt": "2021-09-17T20:39:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI cant see what's wrong. This is a moose object so it should be always included.\nAre you using a really old version of MOOSE?\nCan you try moving this DiracKernel to another input and see if it works there? Just in case there's something going on with the formatting.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18845#discussioncomment-1358242",
                  "updatedAt": "2022-08-16T10:28:37Z",
                  "publishedAt": "2021-09-20T16:24:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "That object was added about a month ago. Can you make sure your MOOSE is up to date?",
                  "url": "https://github.com/idaholab/moose/discussions/18845#discussioncomment-1358358",
                  "updatedAt": "2022-08-16T10:28:37Z",
                  "publishedAt": "2021-09-20T16:45:35Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "It seems not up-to-date, yes. However, when I updated it to the latest version. I could not build it. I am getting the compiler errors below (in bold).\n\nUsing HIT from /home/aaelmeli/projects/moose/framework/contrib/hit\nCompiling C++ (in opt mode) /home/aaelmeli/projects/moose/framework/build/unity_src/auxkernels_Unity.C...\nCompiling C++ (in opt mode) /home/aaelmeli/projects/moose/framework/build/unity_src/controls_Unity.C...\nCompiling C++ (in opt mode) /home/aaelmeli/projects/moose/framework/build/unity_src/dampers_Unity.C...\nCompiling C++ (in opt mode) /home/aaelmeli/projects/moose/framework/build/unity_src/dgkernels_Unity.C...\nIn file included from /home/aaelmeli/projects/moose/framework/build/unity_src/auxkernels_Unity.C:50:\n/home/aaelmeli/projects/moose/framework/src/auxkernels/SolutionAux.C: In member function 'virtual libMesh::Real SolutionAux::computeValue()':\n/home/aaelmeli/projects/moose/framework/src/auxkernels/SolutionAux.C:97:63: error: 'const class libMesh::Elem' has no member named 'vertex_average'\n97 |       output = _solution_object.pointValue(_t, _current_elem->vertex_average(), _var_name);\n|                                                               ^~~~~~~~~~~~~~\nIn file included from /home/aaelmeli/projects/moose/framework/build/unity_src/auxkernels_Unity.C:52:\n/home/aaelmeli/projects/moose/framework/src/auxkernels/SpatialUserObjectAux.C: In member function 'virtual libMesh::Real SpatialUserObjectAux::computeValue()':\n/home/aaelmeli/projects/moose/framework/src/auxkernels/SpatialUserObjectAux.C:41:53: error: 'const class libMesh::Elem' has no member named 'vertex_average'\n41 |     return _user_object.spatialValue(_current_elem->vertex_average());\n|                                                     ^~~~~~~~~~~~~~\nCompiling C++ (in opt mode) /home/aaelmeli/projects/moose/framework/build/unity_src/dirackernels_Unity.C...\nmake: *** [/home/aaelmeli/projects/moose/framework/build.mk:139: /home/aaelmeli/projects/moose/framework/build/unity_src/auxkernels_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1\nmake: *** Waiting for unfinished jobs....",
                          "url": "https://github.com/idaholab/moose/discussions/18845#discussioncomment-1359173",
                          "updatedAt": "2022-08-16T10:28:37Z",
                          "publishedAt": "2021-09-20T19:52:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "You now need to update your libmesh.\nIf you're using conda:\nconda update --all",
                          "url": "https://github.com/idaholab/moose/discussions/18845#discussioncomment-1359178",
                          "updatedAt": "2022-08-16T10:28:37Z",
                          "publishedAt": "2021-09-20T19:53:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "New user of phase field : How to model multiple grains ?",
          "author": {
            "login": "AlexSacMorane"
          },
          "bodyText": "Dear all,\nI am a totally new user of MOOSE and with my supervisors we would like to use this software for our research. The main goal is to simulate a grains sample which is sheared (2D will be ok for a first step). We are interested in the phase field model implanted in Moose and we are trying to link it with a discrete element modelisation. I have a bit looked into test and example files from Moose but I have some questions :\n\nAs our goal is to have one unconserved variable c by grain, is it possible to automate the input file ? I mean to not write 500 [./c] [../] sections in the Variables part for example if we have 500 grains.\nIs it possible to detect contacts between grains and avoid an overlap between them?\nHow can we apply contact law between grains ? I have seen the function ComputeExternalGrainForceAndTorque but as it is undocumented I do not understand well how it is working\nI have tried to play with the function MultiGrainRigidBodyMotion (modules/phase_field/examples/rigidbodymotion/grain_motion_GT.i) but particles seem to disappear. As it is also undocumented I do not inderstand well how it is working\n\nIf you have some example files concerning those subjects, I will enjoy to read them.\nRegards\nAlexandre Sac--Morane",
          "url": "https://github.com/idaholab/moose/discussions/18838",
          "updatedAt": "2022-06-17T08:07:43Z",
          "publishedAt": "2021-09-16T16:07:03Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Hi Alexandre- welcome to the MOOSE framework!\nMOOSE has a system called Actions which can be used to automate adding other objects to input files. There are multiple actions that have been created to help with grain growth problems. Probably the best thing to do is to look at some example files where they are used. There are several in the directory moose/modules/phase_field/examples/grain_growth/. grain_growth_2D_graintracker.i would be a good one to start with. In this example 100 grains are added but the Action syntax allows for a compact input file.\nWe have a system for representing multiple grains with a reduced number of order parameter called GrainTracker. That system makes sure that grains represented by the same order parameter do not come into contact with each other, and remaps grains to different OP's to prevent that from happening. It's used in the previous example I listed. You can also read documentation here:\nhttps://mooseframework.inl.gov/moose/source/postprocessors/GrainTracker.html\nI'll see if I can ask others to help on the other 2 questions, as I'm not as familiar with the other objects you mentioned offhand...",
                  "url": "https://github.com/idaholab/moose/discussions/18838#discussioncomment-1348279",
                  "updatedAt": "2022-06-17T08:07:44Z",
                  "publishedAt": "2021-09-17T15:59:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AlexSacMorane"
                          },
                          "bodyText": "Hi,\nthanks for your answer. I am checking what you told me and I will let you know if I have other questions about it.",
                          "url": "https://github.com/idaholab/moose/discussions/18838#discussioncomment-1357096",
                          "updatedAt": "2022-06-17T08:07:45Z",
                          "publishedAt": "2021-09-20T13:00:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "SudiptaBiswas"
                  },
                  "bodyText": "Hi Alex,\nThe rigid body motion system allows you to apply forces and torques on particles for a given forces density at the interface. We don't have a direct way to account for contact forces on particles in phase field. You can find details about the rigid-body motion system here, https://link.springer.com/article/10.1007/s10853-017-1846-3",
                  "url": "https://github.com/idaholab/moose/discussions/18838#discussioncomment-1348870",
                  "updatedAt": "2022-06-17T08:08:03Z",
                  "publishedAt": "2021-09-17T18:27:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AlexSacMorane"
                          },
                          "bodyText": "Thanks for your answer. I will read this link.",
                          "url": "https://github.com/idaholab/moose/discussions/18838#discussioncomment-1357107",
                          "updatedAt": "2022-06-17T08:08:03Z",
                          "publishedAt": "2021-09-20T13:02:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Assign properties to refined mesh elements",
          "author": {
            "login": "ritamcj"
          },
          "bodyText": "Hi everyone,\nI am attempting to model nucleation in a multiphase system through a crystal plasticity-phase field model. I looked at refine.txt in which nucleation triggers concentration changes based on the concentration gradient at the element interfaces (GradientJumpIndicator) and also, mesh refinement based on ValueThresholdMarker. For my CP based model, I am inputting Euler angles based on Element ID through ElementPropertyReadFile. Initially, I have 4 elements with unique orientations. With mesh refinement, I need to assign random orientations for the new elements. I kept extra orientations (~5000) in my orientation input file for the same. However, I see the attached error as soon as the mesh is refined due to nucleation. I printed the element ID 'jelem' and it goes to values as high as 160. I think the no. of elements \"nelem\" needs to be updated. Kindly suggest strategies to tackle this problem. I found this discussion somewhat relevant #3080.\nWarm regards,\nRitam",
          "url": "https://github.com/idaholab/moose/discussions/18837",
          "updatedAt": "2022-09-01T10:47:54Z",
          "publishedAt": "2021-09-16T08:32:24Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @ritamcj\nYes, you are right the line:\n_nelem = _mesh.nElem();\nis fixing the number of elements in the constructor of ElementPropertyReadFile, therefore you get the error in:\nElementPropertyReadFile::getElementData\nJust an idea but not sure if that would work,\nwhat happens if you update the number of elements inside ElementPropertyReadFile::getElementData\nMeaning you define another class and you add the line\n_nelem = _mesh.nElem();\nat the beginning of getElementData\nIn that case the number of elements may be updated correctly, but I am not sure, just try.\nI think the problem is that in the constructor the number of elements is assigned only once in the simulation.\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/18837#discussioncomment-1354691",
                  "updatedAt": "2022-09-01T10:47:59Z",
                  "publishedAt": "2021-09-19T21:59:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Nicolo,\nThank you very much for your detailed response. It did work :) I used a dummy variable to read the updated mesh elements as:\nReal\nElementPropertyReadFile::getElementData(const Elem * elem, unsigned int prop_num) const\n{\n  unsigned int num_elem = _mesh.nElem();   \n  \n  unsigned int jelem = elem->id();\n\n  if (jelem >= num_elem)\n    mooseError(\"Element ID\", jelem, \" greater than than total number of element in mesh \", num_elem);\n  return _reader.getData(jelem)[prop_num];\n}\n\nWarm regards,\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/18837#discussioncomment-1355494",
                          "updatedAt": "2022-09-01T10:48:00Z",
                          "publishedAt": "2021-09-20T06:03:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about computeStressDerivative",
          "author": {
            "login": "cooperliu101"
          },
          "bodyText": "Hello everyone,\n\n  \n    \n      moose/modules/tensor_mechanics/src/materials/RadialReturnCreepStressUpdateBase.C\n    \n    \n         Line 63\n      in\n      26948e0\n    \n  \n  \n    \n\n        \n          \n           return -(computeDerivative(effective_trial_stress, scalar) + 1.0) / this->_three_shear_modulus; \n        \n    \n  \n\n\nThe comments said that the method returns the derivative of the creep strain with respect to the von mises stress.\nThe following is the background formula:\n1:  sigma_e_tr=sigma_e+3G*dc\n2:  dc=(sigma_e_tr-sigma_e)/(3G)\n3:  ddc_dsigma_e=-1/(3G)\n4:  R=creep(sigma_e)-dc\n5:  dcreep(sigma_e)_dsigma_e=-(dR_ddc+1)/(3G)\nsigma_e_tr: effective trial stress\nsigma_e: effective stress\nG: shear modulus\ndc: effective creep strain\nR: residual\ncreep(sigma_e): effective creep strain function of sigma_e\ndy_dx: the derivative of y with respect to x\nHere is question:\nThe code in RadialReturnCreepStressUpdateBase.C#L63 is formula 5, why not use formula 3?",
          "url": "https://github.com/idaholab/moose/discussions/18851",
          "updatedAt": "2022-07-07T12:08:56Z",
          "publishedAt": "2021-09-18T05:58:46Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "The method computeStressDerivative is used to compute the consistent tangent operator. See \n  \n    \n      moose/modules/tensor_mechanics/src/materials/RadialReturnStressUpdate.C\n    \n    \n        Lines 112 to 151\n      in\n      26948e0\n    \n  \n  \n    \n\n        \n          \n           template <> \n        \n\n        \n          \n           void \n        \n\n        \n          \n           RadialReturnStressUpdateTempl<false>::computeTangentOperator(Real effective_trial_stress, \n        \n\n        \n          \n                                                                        RankTwoTensor & stress_new, \n        \n\n        \n          \n                                                                        bool compute_full_tangent_operator, \n        \n\n        \n          \n                                                                        RankFourTensor & tangent_operator) \n        \n\n        \n          \n           { \n        \n\n        \n          \n             if (compute_full_tangent_operator && \n        \n\n        \n          \n                 getTangentCalculationMethod() == TangentCalculationMethod::PARTIAL) \n        \n\n        \n          \n             { \n        \n\n        \n          \n               if (MooseUtils::absoluteFuzzyEqual(_scalar_effective_inelastic_strain, 0.0)) \n        \n\n        \n          \n                 tangent_operator.zero(); \n        \n\n        \n          \n               else \n        \n\n        \n          \n               { \n        \n\n        \n          \n                 // mu = _three_shear_modulus / 3.0; \n        \n\n        \n          \n                 // norm_dev_stress = ||s_n+1|| \n        \n\n        \n          \n                 // effective_trial_stress = von mises trial stress = std::sqrt(3.0 / 2.0) * ||s_n+1^trial|| \n        \n\n        \n          \n                 // scalar_effective_inelastic_strain = Delta epsilon^cr_n+1 \n        \n\n        \n          \n                 // deriv = derivative of scalar_effective_inelastic_strain w.r.t. von mises stress \n        \n\n        \n          \n                 // deriv = std::sqrt(3.0 / 2.0) partial Delta epsilon^cr_n+1n over partial ||s_n+1^trial|| \n        \n\n        \n          \n            \n        \n\n        \n          \n                 mooseAssert(_three_shear_modulus != 0.0, \"Shear modulus is zero\"); \n        \n\n        \n          \n            \n        \n\n        \n          \n                 const RankTwoTensor deviatoric_stress = stress_new.deviatoric(); \n        \n\n        \n          \n                 const Real norm_dev_stress = \n        \n\n        \n          \n                     std::sqrt(deviatoric_stress.doubleContraction(deviatoric_stress)); \n        \n\n        \n          \n                 mooseAssert(norm_dev_stress != 0.0, \"Norm of the deviatoric is zero\"); \n        \n\n        \n          \n            \n        \n\n        \n          \n                 const RankTwoTensor flow_direction = deviatoric_stress / norm_dev_stress; \n        \n\n        \n          \n                 const RankFourTensor flow_direction_dyad = flow_direction.outerProduct(flow_direction); \n        \n\n        \n          \n                 const Real deriv = \n        \n\n        \n          \n                     computeStressDerivative(effective_trial_stress, _scalar_effective_inelastic_strain); \n        \n\n        \n          \n                 const Real scalar_one = _three_shear_modulus * _scalar_effective_inelastic_strain / \n        \n\n        \n          \n                                         std::sqrt(1.5) / norm_dev_stress; \n        \n\n        \n          \n            \n        \n\n        \n          \n                 tangent_operator = scalar_one * _deviatoric_projection_four + \n        \n\n        \n          \n                                    (_three_shear_modulus * deriv - scalar_one) * flow_direction_dyad; \n        \n\n        \n          \n               } \n        \n\n        \n          \n             } \n        \n\n        \n          \n           }",
                  "url": "https://github.com/idaholab/moose/discussions/18851#discussioncomment-1352439",
                  "updatedAt": "2022-07-07T12:09:58Z",
                  "publishedAt": "2021-09-19T01:58:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cooperliu101"
                          },
                          "bodyText": "thanks for your reply\uff01\nthe comment says that\n// deriv = derivative of scalar_effective_inelastic_strain w.r.t. von mises stress\nsince the following equation is alway met during the iteration\neffective_trial_stress=effective_stress+3G* scalar_effective_inelastic_strain\uff0cscalar_effective_inelastic_strain w.r.t. von mises stress is -1/3G \uff1f",
                          "url": "https://github.com/idaholab/moose/discussions/18851#discussioncomment-1353336",
                          "updatedAt": "2022-07-07T12:10:18Z",
                          "publishedAt": "2021-09-19T10:36:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Barrier function material in DerivativeMultiPhaseMaterial",
          "author": {
            "login": "LiWen-HUST"
          },
          "bodyText": "Hello all,\nI want to use more than one barrier function material in my PhaseField model. Like in the paper \"Formation path of \u03b4 hydrides in zirconium by multiphase field modeling\" the authors used three different barrier function materials, \"MultiBarrierFunctionMaterial\", \"AsymmetricCrossTermBarrierFunctionMaterial\" and \"ThirdPhaseSuppressionMaterial\". However in the \"DerivativeMultiPhaseMaterial\" material, only one barrier function \"g\" and one prefactor \"W\" can be used. How can I use more than one barrier function in PhaseField module?\nBEST\nLi",
          "url": "https://github.com/idaholab/moose/discussions/16193",
          "updatedAt": "2022-10-03T10:59:47Z",
          "publishedAt": "2020-11-15T05:19:29Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "souravmat-git"
                  },
                  "bodyText": "Hello,\nCheck the following materials to create the barrier function used in the paper mentioned by you.\nmoose/modules/phase_field/src/materials/AsymmetricCrossTermBarrierFunctionMaterial.C\nmoose/modules/phase_field/src/materials/ThirdPhaseSuppressionMaterial.C\nAlso check the following input file:\nmoose/modules/phase_field/test/tests/MultiPhase/asymmetriccrosstermbarrierfunction.i",
                  "url": "https://github.com/idaholab/moose/discussions/16193#discussioncomment-1352573",
                  "updatedAt": "2022-10-03T10:59:56Z",
                  "publishedAt": "2021-09-19T04:26:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "KKS multi phases",
          "author": {
            "login": "LiuPengPeter"
          },
          "bodyText": "Hello everyone,\nI have some questions about the kernel of multi phase. Could anyone help?\n\n\nFor KKS module multi phases model, there is the constraint for order parameters. eta1+eta2+eta3_eta4=1. So n-1 AC equations are needed. WHile, for WBM, every order parameter needs a AC equation.\n\n\nFor  both KKS and WBM multi phases model, the constraint h1+h2+h3+h4=1 must be added by lagrange multiplier technique or free energy penalty term.  If I use the KKS model\uff0c which method is better? SwitchingFunctionPenalty (energy penalty term) seems easier.\n\n\nCould the split form of CH be used in KKS multi phase?\n\n\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/16495",
          "updatedAt": "2022-06-14T11:50:03Z",
          "publishedAt": "2020-12-15T13:11:08Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "souravmat-git"
                  },
                  "bodyText": "Hello,\nThere are two kinds of \"KKS type\" multi-phase-field model\u2014the first is a model by Eiken et al. (see Ref. https://journals.aps.org/pre/abstract/10.1103/PhysRevE.73.066122) and the other is a model by Moelans (see Ref. https://www.sciencedirect.com/science/article/pii/S1359645410007019).\nAnswer to your second question:\nEiken's model will require the constraint on interpolation functions h1+h2+h3+h4=1. However, Moelan's model does not need any such constraint due to the definition of interpolation function. This interpolation function is available in moose (check the material moose/modules/phase_field/src/materials/SwitchingFunctionMultiPhaseMaterial.C)\nYou can also use this function for multi-phase-field \"WBM type\" model.\nAnswer to your first question:\nContrary to Eiken's model, the constraint on eta is not needed in Moelan's model. In Eiken's model this constraint is due to the fact that the interpolation function is equal to the phase-field variable, i.e., h1 = eta1.\nAnswer to your last question:\nTo my understanding, in KKS we simply solve for Fick's diffusion equation (see the Refs.), and therefore the split form is not needed.\nMoreover, this equation is already implemented as a moose kernel (check moose/framework/src/kernels/MatDiffusion.C).\nAlso, check the example input file moose/modules/phase_field/test/tests/KKS_system/kks_multiphase.i\nHope it helps.\nSourav",
                  "url": "https://github.com/idaholab/moose/discussions/16495#discussioncomment-1350118",
                  "updatedAt": "2022-06-14T11:54:46Z",
                  "publishedAt": "2021-09-18T04:41:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Grain boundary projection tensors",
          "author": {
            "login": "wenpeng231024"
          },
          "bodyText": "Dear MOOSE group,\nI try to build the diffusivity of bulk, surface, and grain boundary following the Eqs. (12)-(18) in the paper Modelling Simul. Mater. Sci. Eng. 23 (2015) 045009.\nhttps://iopscience.iop.org/article/10.1088/0965-0393/23/4/045009/meta\nIn MOOSE, how to calculate the GB projection tensors as following? Or is there a related example?\n\n\nThanks.\nPeng",
          "url": "https://github.com/idaholab/moose/discussions/18782",
          "updatedAt": "2023-12-03T06:54:59Z",
          "publishedAt": "2021-09-07T15:59:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@hugary1995 @dschwen",
                  "url": "https://github.com/idaholab/moose/discussions/18782#discussioncomment-1321670",
                  "updatedAt": "2023-12-03T06:55:05Z",
                  "publishedAt": "2021-09-14T04:01:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "The doxygen documentation is very useful in this case. https://mooseframework.inl.gov/docs/doxygen/moose/classRankTwoTensorTempl.html\nFor example, you may use the vectorOuterProduct method to compute Ts. You can construct a second order identity tensor using\nRankTwoTensor I(RankTwoTensor::initIdentity)",
                  "url": "https://github.com/idaholab/moose/discussions/18782#discussioncomment-1323017",
                  "updatedAt": "2023-12-03T06:55:07Z",
                  "publishedAt": "2021-09-14T10:22:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wenpeng231024"
                          },
                          "bodyText": "Many thanks! I will try this.",
                          "url": "https://github.com/idaholab/moose/discussions/18782#discussioncomment-1323774",
                          "updatedAt": "2023-12-03T06:55:08Z",
                          "publishedAt": "2021-09-14T13:13:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "You should be able to use the material PolycrystalDiffusivityTensorBase in the phase-field module:\nmoose/modules/phase_field/src/materials/PolycrystalDiffusivityTensorBase.C",
                  "url": "https://github.com/idaholab/moose/discussions/18782#discussioncomment-1349084",
                  "updatedAt": "2023-12-03T06:55:08Z",
                  "publishedAt": "2021-09-17T19:47:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Elastic Modulus as a variable",
          "author": {
            "login": "alexchen4ai"
          },
          "bodyText": "I am using Automatic Differentiation in Moose.\nI used tensor mechanics modules. The elastic modulus are dependent on another variable. It seems that we could only enter the values of C_{ijkl} as float number. Is there a way to input a coupled variable for C_{ijkl}?\n  [elasticity_tensor]\n    type = ADComputeElasticityTensor\n    C_ijkl = '10868. 2457. 3279. 21613. 5000.'\n    fill_method = axisymmetric_rz\n  []\n\nFor example, I want to enter something like C_ijkl = '10868.*(1-x) 2457. 3279. 21613. 5000.' where x is another variables.\nIt doesn't work. Are there some tricks to do this?",
          "url": "https://github.com/idaholab/moose/discussions/18830",
          "updatedAt": "2022-06-26T08:45:48Z",
          "publishedAt": "2021-09-15T19:41:28Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "souravmat-git"
                  },
                  "bodyText": "Is \"x\" a moose variable or a spatial variable ?\nIf \"x\" is declared as a moose variable then check the following material and input file:\nmoose/modules/tensor_mechanics/src/materials/ComputeConcentrationDependentElasticityTensor.C\nmoose/modules/combined/test/tests/concentration_dependent_elasticity_tensor/\nYou will have to modify \"_elatictity_tensor\" and \"_delasticity_tensor_dc\" in the material file according to your variable-dependent expression for elasticity tensor.",
                  "url": "https://github.com/idaholab/moose/discussions/18830#discussioncomment-1345701",
                  "updatedAt": "2022-06-26T08:45:52Z",
                  "publishedAt": "2021-09-17T05:57:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "Thank you! This helps!",
                          "url": "https://github.com/idaholab/moose/discussions/18830#discussioncomment-1348191",
                          "updatedAt": "2022-06-26T08:46:04Z",
                          "publishedAt": "2021-09-17T15:40:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @AlexCHEN-Engineer\nYou can check this example in my repository, where I set the elasticity tensor as dependent on the temperature:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/ComputeElasticityTensorCPGrain.C\nIn my case temperature is an AuxVariable, but the same can be done with a MOOSE Variable.\nTrust this helps.\nBest Regards,\nNicol\u00f2 Grilli",
                  "url": "https://github.com/idaholab/moose/discussions/18830#discussioncomment-1348137",
                  "updatedAt": "2022-06-26T08:46:04Z",
                  "publishedAt": "2021-09-17T15:28:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "Thank you for sharing and it makes sense!",
                          "url": "https://github.com/idaholab/moose/discussions/18830#discussioncomment-1348190",
                          "updatedAt": "2022-06-26T08:46:18Z",
                          "publishedAt": "2021-09-17T15:40:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can't activate external modules",
          "author": {
            "login": "alexchen4ai"
          },
          "bodyText": "Dear moose experts and users,\nI am creating a new application and I set the tensor_mechanics as yes. However, it doesn't compile when I type \"make -j4\".\n\nI expect there should be more compiling. No kernels in tensor_mechanics is activated. And I tried to use some kernels in tensor_mechanics. But it doesn't work.\nI installed the moose successfully with all tests passed.",
          "url": "https://github.com/idaholab/moose/discussions/18840",
          "updatedAt": "2022-09-13T18:44:47Z",
          "publishedAt": "2021-09-16T18:16:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "So the tensor mechanics linking is missing from the log. We prefer you copy over the test in quotes (add code button) than post screenshots btw\nDid you try to make clobberall before compiling?\nCan you paste your Makefile here?",
                  "url": "https://github.com/idaholab/moose/discussions/18840#discussioncomment-1343816",
                  "updatedAt": "2022-09-13T18:45:02Z",
                  "publishedAt": "2021-09-16T18:18:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "Thank you for your reply. I didn't try make clobberall before compiling. The Makefile is here.\n###############################################################################\n################### MOOSE Application Standard Makefile #######################\n###############################################################################\n#\n# Optional Environment variables\n# MOOSE_DIR        - Root directory of the MOOSE project\n#\n###############################################################################\n# Use the MOOSE submodule if it exists and MOOSE_DIR is not set\nMOOSE_SUBMODULE    := $(CURDIR)/moose\nifneq ($(wildcard $(MOOSE_SUBMODULE)/framework/Makefile),)\n  MOOSE_DIR        ?= $(MOOSE_SUBMODULE)\nelse\n  MOOSE_DIR        ?= $(shell dirname `pwd`)/moose\nendif\n\n# framework\nFRAMEWORK_DIR      := $(MOOSE_DIR)/framework\ninclude $(FRAMEWORK_DIR)/build.mk\ninclude $(FRAMEWORK_DIR)/moose.mk\n\n################################## MODULES ####################################\n# To use certain physics included with MOOSE, set variables below to\n# yes as needed.  Or set ALL_MODULES to yes to turn on everything (overrides\n# other set variables).\n\nALL_MODULES                 := no\n\nCHEMICAL_REACTIONS          := no\nCONTACT                     := no\nEXTERNAL_PETSC_SOLVER       := no\nFLUID_PROPERTIES            := no\nFSI                         := no\nFUNCTIONAL_EXPANSION_TOOLS  := no\nGEOCHEMISTRY                := no\nHEAT_CONDUCTION             := no\nLEVEL_SET                   := no\nMISC                        := no\nNAVIER_STOKES               := no\nPHASE_FIELD                 := no\nPOROUS_FLOW                 := no\nRAY_TRACING                 := no\nRDG                         := no\nRICHARDS                    := no\nSTOCHASTIC_TOOLS            := no\nTENSOR_MECHANICS            := yes\nXFEM                        := no\n\ninclude $(MOOSE_DIR)/modules/modules.mk\n###############################################################################\n\n# dep apps\nAPPLICATION_DIR    := $(CURDIR)\nAPPLICATION_NAME   := farm\nBUILD_EXEC         := yes\nGEN_REVISION       := no\ninclude            $(FRAMEWORK_DIR)/app.mk\n\n###############################################################################\n# Additional special case targets should be added here",
                          "url": "https://github.com/idaholab/moose/discussions/18840#discussioncomment-1343834",
                          "updatedAt": "2022-09-13T18:45:22Z",
                          "publishedAt": "2021-09-16T18:22:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "I tried make clobberall. And it works now! Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18840#discussioncomment-1343847",
                          "updatedAt": "2022-09-13T18:45:46Z",
                          "publishedAt": "2021-09-16T18:25:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "error when use ActivateElementsByPath and mesh adaptivity at the same time",
          "author": {
            "login": "cztkatherine"
          },
          "bodyText": "Dear colleagues,\nIt appears that when we use ActivateElementsByPath and mesh adaptivity at the same time, there would be an error saying:\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Segmentation fault (signal 11)\nWe are able to reproduce this error by adapting the example (modules/combined/test/tests/additive_manufacturing/check_element_addition_2D.i), and a copy of the modified input is attached.\n[Problem]\n  kernel_coverage_check = false\n[]\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    ymin = 0\n    xmax = 1\n    ymax = 0.5\n    nx = 10\n    ny = 10\n  []\n  [bottom_domain]\n    input = gen\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0 0 0'\n    top_right = ' 1 0.1 0'\n    block_id = 1\n  []\n  [top_domain]\n    input = bottom_domain\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0 0.1 0'\n    top_right = '1 0.5 00'\n    block_id = 2\n  []\n  [sidesets]\n    input = top_domain\n    type = SideSetsAroundSubdomainGenerator\n    normal = '1 0 0'\n    block = 1\n    new_boundary = 'moving_interface'\n  []\n[]\n\n[Variables]\n  [temp]\n    block = '1 2'\n    initial_condition = '20'\n  []\n[]\n\n[Functions]\n  [fy]\n    type = ParsedFunction\n    value = '0.2'\n  []\n  [fx]\n    type = ParsedFunction\n    value = 't'\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  automatic_scaling = true\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  line_search = 'none'\n\n  l_max_its = 10\n  nl_max_its = 20\n  nl_rel_tol = 1e-4\n\n  start_time = 0.0\n  end_time = 1\n  dt = 5e-2\n  dtmin = 1e-4\n[]\n\n\n[Adaptivity]\n  marker = Marker3 #this line when commented, switches off adaptivity\n  max_h_level = 3\n  #steps = 2 #this line gets ignored in a transient run\n  [./Indicators]\n    [./Terror]\n      type = GradientJumpIndicator\n      variable = temp\n      outputs = none\n    [../]   \n  [../]\n  [./Markers]\n    [./Marker3]\n      type = ErrorFractionMarker\n      refine = 0.65\n      coarsen = 0.25\n      indicator = Terror\n      outputs = none\n    [../]\n  [../]\n[]\n\n\n[UserObjects]\n  [activated_elem_uo]\n    type = ActivateElementsByPath\n    execute_on = timestep_begin\n    activate_distance = 0.2\n    function_x = fx\n    function_y = fy\n    active_subdomain_id = 1\n    expand_boundary_name = 'moving_interface'\n  []\n[]\n\n[Outputs]\n  exodus = true\nfile_base = ./CheckEleAddition2D/CheckEleAddition2D\n[]\n\nWhen we run with the adaptivity block, the above error appears. If you delete the adaptivity block, the simulation runs successfully.\nCould any one share some thoughts about this conflicts?\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/18284",
          "updatedAt": "2022-08-12T03:17:15Z",
          "publishedAt": "2021-07-07T23:46:03Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "That might be a corner case that has not been fully tested.  @dewenyushu do you have any thoughts?",
                  "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-977039",
                  "updatedAt": "2022-08-12T03:17:25Z",
                  "publishedAt": "2021-07-07T23:50:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "We plan to replace ActivateElementsByPath with the new element subdomain modifiers. I modified your input file to use the CoupledVarThresholdElementSubdomainModifier and it works fine with adaptivity.\nHere is the animation:\nhttps://user-images.githubusercontent.com/31555204/124855357-d5246800-df76-11eb-9ffe-a9d563d93df7.mov\nThe modified input file is attached below.\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    ymin = 0\n    xmax = 1\n    ymax = 0.5\n    nx = 10\n    ny = 10\n  []\n  [bottom_domain]\n    input = gen\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0 0 0'\n    top_right = ' 1 0.1 0'\n    block_id = 1\n  []\n  [top_domain]\n    input = bottom_domain\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0 0.1 0'\n    top_right = '1 0.5 00'\n    block_id = 2\n  []\n  [sidesets]\n    input = top_domain\n    type = SideSetsAroundSubdomainGenerator\n    normal = '1 0 0'\n    block = 1\n    new_boundary = 'moving_interface'\n  []\n[]\n\n[Variables]\n  [temp]\n    block = '1 2'\n    initial_condition = '20'\n  []\n[]\n\n[Kernels]\n  [diff]\n    type = Diffusion\n    variable = temp\n  []\n[]\n\n[BCs]\n  [left]\n    type = DirichletBC\n    variable = temp\n    value = 20\n    boundary = 'left'\n  []\n  [right]\n    type = FunctionDirichletBC\n    variable = temp\n    function = '20+10*t'\n    boundary = right\n  []\n[]\n\n[Functions]\n  [fy]\n    type = ParsedFunction\n    value = '0.2'\n  []\n  [fx]\n    type = ParsedFunction\n    value = 't'\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  automatic_scaling = true\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  line_search = 'none'\n\n  l_max_its = 10\n  nl_max_its = 20\n  nl_rel_tol = 1e-4\n\n  start_time = 0.0\n  end_time = 1\n  dt = 5e-2\n  dtmin = 1e-4\n[]\n\n[Adaptivity]\n  marker = threshold\n  max_h_level = 1\n  [Markers]\n    [threshold]\n      type = ValueThresholdMarker\n      variable = temp\n      refine = 22\n    []\n  []\n[]\n\n[AuxVariables]\n  [dist]\n  []\n[]\n\n[AuxKernels]\n  [dist]\n    type = ParsedAux\n    variable = dist\n    function = 'sqrt((x-t)^2+(y-0.2)^2)'\n    use_xyzt = true\n    execute_on = 'TIMESTEP_BEGIN LINEAR TIMESTEP_END'\n  []\n[]\n\n[UserObjects]\n  [esm]\n    type = CoupledVarThresholdElementSubdomainModifier\n    coupled_var = dist\n    subdomain_id = 1\n    threshold = 0.2\n    criterion_type = BELOW\n    apply_initial_conditions = false\n    moving_boundary_name = 'moving_interface'\n    block = 2\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n[]\n\n[Outputs]\n  exodus = true\n  file_base = ./CheckEleAddition2D/CheckEleAddition2D\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-977418",
                  "updatedAt": "2022-08-12T03:17:25Z",
                  "publishedAt": "2021-07-08T03:00:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "But we should definitely add some regression tests including adaptivity.",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-977420",
                          "updatedAt": "2022-08-12T03:17:46Z",
                          "publishedAt": "2021-07-08T03:02:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dewenyushu"
                  },
                  "bodyText": "@jiangwen84 you're right. The ActivateElementsByPath has not been tested with mesh adaptivity.\n@hugary1995 's suggestion is the right way to go.",
                  "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-979871",
                  "updatedAt": "2022-08-24T19:01:05Z",
                  "publishedAt": "2021-07-08T14:28:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Thank you all @jiangwen84 @hugary1995 @dewenyushu and we will be using CoupledVarThresholdElementSubdomainModifier.\nBest,\nXiang",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980032",
                          "updatedAt": "2022-08-24T19:01:06Z",
                          "publishedAt": "2021-07-08T15:00:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "I just have a quick test, it appears when adaptivity is based on ValueThresholdMarker, both CoupledVarThresholdElementSubdomainModifier and ActivateElementsByPath will work. If we use GradientJumpIndicator, neither of them will work. To be more specific, if we replace the adaptivity block of the input file provide by @hugary1995 using the block below:\n[Adaptivity]\nmarker = Marker3 #this line when commented, switches off adaptivity\nmax_h_level = 3\n[./Indicators]\n[./Terror]\ntype = GradientJumpIndicator\nvariable = temp\noutputs = none\n[../]\n[../]\n[./Markers]\n[./Marker3]\ntype = ErrorFractionMarker\nrefine = 0.65\ncoarsen = 0.25\nindicator = Terror\noutputs = none\n[../]\n[../]\n[]\nThe same error will occur. Could any of you take another look at it? Thank you all.\nBest,\nXiang",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980105",
                          "updatedAt": "2022-08-24T19:01:13Z",
                          "publishedAt": "2021-07-08T15:15:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "This marker doesn't make sense in this problem -- the gradient jump is zero everywhere.",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980124",
                          "updatedAt": "2022-10-07T14:24:06Z",
                          "publishedAt": "2021-07-08T15:19:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Well, it probably implies that there are still some issues when combining ESMs (element subdomain modifier) with AMR (adaptive mesh refinement). If there is a more concrete non-working example, feel free to open an issue.",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980131",
                          "updatedAt": "2022-10-07T14:24:06Z",
                          "publishedAt": "2021-07-08T15:21:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "You are right @hugary1995 about zero temperature gradient in the above input file. I slightly modified your input file as below to change the left BC to a higher temperature to introduce the temperature gradient and same error persists. If switching to the ValueThresholdMarker, then it behaves as expected.\n[Mesh]\n[gen]\ntype = GeneratedMeshGenerator\ndim = 2\nxmin = 0\nymin = 0\nxmax = 1\nymax = 0.5\nnx = 10\nny = 10\n[]\n[bottom_domain]\ninput = gen\ntype = SubdomainBoundingBoxGenerator\nbottom_left = '0 0 0'\ntop_right = ' 1 0.1 0'\nblock_id = 1\n[]\n[top_domain]\ninput = bottom_domain\ntype = SubdomainBoundingBoxGenerator\nbottom_left = '0 0.1 0'\ntop_right = '1 0.5 00'\nblock_id = 2\n[]\n[sidesets]\ninput = top_domain\ntype = SideSetsAroundSubdomainGenerator\nnormal = '1 0 0'\nblock = 1\nnew_boundary = 'moving_interface'\n[]\n[]\n[Variables]\n[temp]\nblock = '1 2'\ninitial_condition = '20'\n[]\n[]\n[Kernels]\n[diff]\ntype = Diffusion\nvariable = temp\n[]\n[]\n[BCs]\n[left]\ntype = DirichletBC\nvariable = temp\nvalue = 50\nboundary = 'left'\n[]\n[right]\ntype = FunctionDirichletBC\nvariable = temp\nfunction = '20+10*t'\nboundary = right\n[]\n[]\n[Functions]\n[fy]\ntype = ParsedFunction\nvalue = '0.2'\n[]\n[fx]\ntype = ParsedFunction\nvalue = 't'\n[]\n[]\n[Preconditioning]\n[smp]\ntype = SMP\nfull = true\n[]\n[]\n[Executioner]\ntype = Transient\nautomatic_scaling = true\nsolve_type = 'NEWTON'\npetsc_options_iname = '-pc_type'\npetsc_options_value = 'lu'\nline_search = 'none'\nl_max_its = 10\nnl_max_its = 20\nnl_rel_tol = 1e-4\nstart_time = 0.0\nend_time = 1\ndt = 5e-2\ndtmin = 1e-4\n[]\n#[Adaptivity]\n#marker = threshold\n#max_h_level = 1\n#[Markers]\n#[threshold]\n#type = ValueThresholdMarker\n#variable = temp\n#refine = 40\n#[]\n#[]\n#[]\n[Adaptivity]\nmarker = Marker3 #this line when commented, switches off adaptivity\nmax_h_level = 3\n[./Indicators]\n[./Terror]\ntype = GradientJumpIndicator\nvariable = temp\noutputs = none\n[../]\n[../]\n[./Markers]\n[./Marker3]\ntype = ErrorFractionMarker\nrefine = 0.65\ncoarsen = 0.25\nindicator = Terror\noutputs = none\n[../]\n[../]\n[]\n[AuxVariables]\n[dist]\n[]\n[]\n[AuxKernels]\n[dist]\ntype = ParsedAux\nvariable = dist\nfunction = 'sqrt((x-t)^2+(y-0.2)^2)'\nuse_xyzt = true\nexecute_on = 'TIMESTEP_BEGIN LINEAR TIMESTEP_END'\n[]\n[]\n[UserObjects]\n[esm]\ntype = CoupledVarThresholdElementSubdomainModifier\ncoupled_var = dist\nsubdomain_id = 1\nthreshold = 0.2\ncriterion_type = BELOW\napply_initial_conditions = false\nmoving_boundary_name = 'moving_interface'\nblock = 2\nexecute_on = 'TIMESTEP_BEGIN'\n[]\n[]\n[Outputs]\nexodus = true\nfile_base = ./CheckEleAddition2D/CheckEleAddition2D\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980203",
                          "updatedAt": "2022-10-07T14:24:06Z",
                          "publishedAt": "2021-07-08T15:34:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Sorry I didn't follow. What did you do to make the temperature gradient jump nonzero?",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980314",
                          "updatedAt": "2022-10-07T14:24:16Z",
                          "publishedAt": "2021-07-08T15:59:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Sorry not making it clear. I simply change the prescribed temperature at the left boundary from 20 to 50. A snapshot of the temperature contour shows the expected temperature gradient if you run without adaptivity or using ValueThresholdMarker.\n\nBest,\nXiang",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980492",
                          "updatedAt": "2022-10-07T14:24:16Z",
                          "publishedAt": "2021-07-08T16:40:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Sorry I think I made a false statement here. The temperature is linearly varying, and the gradient is constant. I will further work on that and post it here.",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-980508",
                          "updatedAt": "2022-10-07T14:24:16Z",
                          "publishedAt": "2021-07-08T16:44:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Hi Gary,\nThe smallest example I can replicate the error I have regarding GradientJumpIndicator based mesh adaptivity  and CoupledVarThresholdElementSubdomainModifier is by combining the example we have with the FunctionPathEllipsoidHeatSource. A copy of the input file is shown below. The simulation will terminate after step 9 due to segmentation fault. Any suggestion is appreciated. Thank you.\nBest,\nXiang\n[Mesh]\n[gen]\ntype = GeneratedMeshGenerator\ndim = 3\nxmin = -5.0\nxmax = 5.0\nnx = 20\nymin = -5.0\nymax = 5.0\nny = 20\nzmin = 0.0\nzmax = 1.0\nnz = 1\n[]\n[left_domain]\ninput = gen\ntype = SubdomainBoundingBoxGenerator\nbottom_left = '-5 -5 0'\ntop_right = ' 0 5 1'\nblock_id = 1\n[]\n[right_domain]\ninput = left_domain\ntype = SubdomainBoundingBoxGenerator\nbottom_left = '0 -5 0'\ntop_right = '5 5  1'\nblock_id = 2\n[]\n[sidesets]\ninput = right_domain\ntype = SideSetsAroundSubdomainGenerator\nnormal = '1 0  0'\nblock = 1\nnew_boundary = 'moving_interface'\n[]\n[]\n[Variables]\n[./temp]\ninitial_condition = 30\n[../]\n[]\n[Kernels]\n[./time]\ntype = ADHeatConductionTimeDerivative\nvariable = temp\n[../]\n[./heat_conduct]\ntype = ADHeatConduction\nvariable = temp\nthermal_conductivity = thermal_conductivity\n[../]\n[./heat_source]\ntype = ADMatHeatSource\nmaterial_property = volumetric_heat\nvariable = temp\n[../]\n[]\n[BCs]\n[./temp_bottom_fix]\ntype = ADDirichletBC\nvariable = temp\nboundary = 1\nvalue = 30\n[../]\n[]\n[Materials]\n[./heat]\ntype = ADHeatConductionMaterial\nspecific_heat = 603\nthermal_conductivity = 10e-2\n[../]\n[./density]\ntype = ADGenericConstantMaterial\nprop_names = 'density'\nprop_values = '4.43e-6'\n[../]\n[./volumetric_heat]\ntype = FunctionPathEllipsoidHeatSource\nrx = 1\nry = 1\nrz = 1\npower = 100\nefficiency = 0.5\nfactor = 2\nfunction_x= path_x\nfunction_y= path_y\nfunction_z= path_z\n[../]\n[]\n[Functions]\n[./path_x]\ntype = ParsedFunction\n#value = 2cos(2.0pit)\nvalue = 2cos(2.0pit)\n[../]\n[./path_y]\ntype = ParsedFunction\nvalue = 2sin(2.0pi*t)\n[../]\n[./path_z]\ntype = ParsedFunction\nvalue = 1.0\n[../]\n[]\n[AuxVariables]\n[dist]\n[]\n[]\n[AuxKernels]\n[dist]\ntype = ParsedAux\nvariable = dist\nfunction = 'sqrt((y+5-t*10)^2+(x-1.5)^2+(z-0.5)^2)'\nuse_xyzt = true\nexecute_on = 'TIMESTEP_BEGIN LINEAR TIMESTEP_END'\n[]\n[]\n[UserObjects]\n[esm]\ntype = CoupledVarThresholdElementSubdomainModifier\ncoupled_var = dist\nsubdomain_id = 1    #--- new ID\nthreshold = 1.5\ncriterion_type = BELOW\napply_initial_conditions = false\nmoving_boundary_name = 'moving_interface'\nblock = 2          #-- old id\nexecute_on = 'TIMESTEP_BEGIN'\n[]\n[]\n[Postprocessors]\n[temp_max]\ntype = ElementExtremeValue\nvariable = temp\n[]\n[temp_min]\ntype = ElementExtremeValue\nvariable = temp\nvalue_type = min\n[]\n[temp_avg]\ntype = ElementAverageValue\nvariable = temp\n[]\n[]\n[Preconditioning]\n[./full]\ntype = SMP\nfull = true\n[../]\n[]\n[Adaptivity]\nmarker = Marker3 #this line when commented, switches off adaptivity\nmax_h_level = 3\n[./Indicators]\n[./Terror]\ntype = GradientJumpIndicator\nvariable = temp\noutputs = none\n[../]\n[../]\n[./Markers]\n[./Marker3]\ntype = ErrorFractionMarker\nrefine = 0.75\ncoarsen = 0.25\nindicator = Terror\noutputs = none\n[../]\n[../]\n[]\n[Executioner]\ntype = Transient\nsolve_type = PJFNK\nnl_rel_tol = 1e-6\nnl_abs_tol = 1e-6\npetsc_options_iname = '-ksp_type -pc_type -pc_factor_mat_solver_package'\npetsc_options_value = 'preonly lu       superlu_dist'\nl_max_its = 100\nend_time = 1\ndt = 0.05\ndtmin = 1e-4\n[]\n[Outputs]\ncsv = true\nexodus = true\nfile_base = ./FunctionHeatSource/FunctionHeatSource\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-995436",
                          "updatedAt": "2022-10-07T14:24:16Z",
                          "publishedAt": "2021-07-12T19:27:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Thanks for reporting that. I've created an issue #18368",
                          "url": "https://github.com/idaholab/moose/discussions/18284#discussioncomment-1015943",
                          "updatedAt": "2022-10-07T14:24:18Z",
                          "publishedAt": "2021-07-17T11:35:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}