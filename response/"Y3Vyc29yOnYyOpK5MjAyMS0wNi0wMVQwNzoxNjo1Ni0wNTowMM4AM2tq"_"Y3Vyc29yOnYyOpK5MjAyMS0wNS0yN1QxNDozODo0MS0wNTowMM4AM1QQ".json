{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNS0yN1QxNDozODo0MS0wNTowMM4AM1QQ"
    },
    "edges": [
      {
        "node": {
          "title": "Coupling variables into FVDirichletBC",
          "author": {
            "login": "ln53"
          },
          "bodyText": "Hi all, I'm trying to create an FV BC which sets velocity at the boundary depending on a variable phi. However when I try to couple phi using adCoupledValue as I would in other BCs/Kernels, I get the error 'adCoupledValue was not declared in this scope'. (I've also tried reading phi into a material property and coupling it that way).\nI can see the Coupleable class is not used at all by FVBoundaryCondition, and I'm also aware that in FV the variable would be defined for the element and not the boundary. But is there any way I can access the variable phi somehow for use in the BC, whether that's just using the value from the element, or somehow interpolating between the ghost elements used by FVDirichletBC?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/17872",
          "updatedAt": "2022-09-01T14:07:57Z",
          "publishedAt": "2021-05-18T14:58:14Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou're right that FVBCs do not inherit the coupleable interface because it does not provide the support for face values, which is what you want to be using in finite volume most of the time.\nYou can add it if you want the cell value, in your boundary condition object.\nOtherwise, use var->getBoundaryFaceValue(face_info)\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17872#discussioncomment-805236",
                  "updatedAt": "2022-09-08T13:41:59Z",
                  "publishedAt": "2021-05-31T04:56:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ln53"
                          },
                          "bodyText": "Thanks for the help",
                          "url": "https://github.com/idaholab/moose/discussions/17872#discussioncomment-809925",
                          "updatedAt": "2022-09-12T10:02:52Z",
                          "publishedAt": "2021-06-01T08:18:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Undefined reference to memcpy@GLIBC_2.14",
          "author": {
            "login": "crb3874"
          },
          "bodyText": "Hello,\nI'm working with a fresh install of conda and MOOSE on an HPC cluster at my university.\nAt the end of installation, I'm attempting to run \"make -j 4\" to compile the tests. When it tries to compile moose/test/src/main.C, it exits with the following errors:\nCompiling C++ (in opt mode) (Removed)/moose/test/src/main.C...\n/lib64/libresolv.so.2: undefined reference to `__sendmmsg@GLIBC_PRIVATE'\n/lib64/libresolv.so.2: undefined reference to `memcpy@GLIBC_2.14'\n/lib64/libresolv.so.2: undefined reference to `__h_errno@GLIBC_PRIVATE'\ncollect2: error: ld returned 1 exit status\nI've looked around - my understanding is that the middle function call here is using version symboling to use the version of memcpy() from GLIBC 2.14. I believe newer versions of GLIBC should be backwards compatible with this feature... I've checked, and the system I'm on is using GLIBC 2.22. Can anyone help me out with this?",
          "url": "https://github.com/idaholab/moose/discussions/17630",
          "updatedAt": "2022-06-02T04:49:38Z",
          "publishedAt": "2021-04-16T21:09:16Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@milljm Have you seen this before?",
                  "url": "https://github.com/idaholab/moose/discussions/17630#discussioncomment-640539",
                  "updatedAt": "2022-06-02T04:49:37Z",
                  "publishedAt": "2021-04-21T15:03:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I have not.\n@crb3874 You may want to try and use your system's compilers instead of Conda's. It may yield better results. Can you explain what system you are using? Arch, version, things like that.",
                          "url": "https://github.com/idaholab/moose/discussions/17630#discussioncomment-640627",
                          "updatedAt": "2022-06-02T04:49:38Z",
                          "publishedAt": "2021-04-21T15:21:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "crb3874"
                          },
                          "bodyText": "Apologies for not following up on this with an update - I ended up starting from scratch by following the instructions at https://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html to build MOOSE without using the Conda environment. This worked much better for me, and I am able to compile the tests and run them. However, I am now having a problem (some of the tests failing) that is unrelated to this issue, so I'm going to open a separate discussion for it.\nThank you for your help with this!",
                          "url": "https://github.com/idaholab/moose/discussions/17630#discussioncomment-808526",
                          "updatedAt": "2022-06-02T04:49:38Z",
                          "publishedAt": "2021-05-31T20:28:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Solution of coupled time dependent nonlinear equations",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "Is there an example MOOSE file that solves a problem similar to the following? :\nd/dt (n1) = C1 x phi x n1\nd/dt (n2) = C2 x phi x n1-C3 x phi x n2\nwhere phi = phi(x,t)",
          "url": "https://github.com/idaholab/moose/discussions/17948",
          "updatedAt": "2021-06-21T16:47:13Z",
          "publishedAt": "2021-05-27T14:56:58Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDo you want to solve for phi (variable) or have it fixed (function) ?\nNot sure we have an example for this case exactly, but a combination of CoupledForce, TimeDerivative kernels (FE or FV) will do the trick.\nbest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17948#discussioncomment-805251",
                  "updatedAt": "2021-05-31T05:06:25Z",
                  "publishedAt": "2021-05-31T05:06:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "I would in a simple case want phi to be a constant value.\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/17948#discussioncomment-807253",
                          "updatedAt": "2021-05-31T14:26:47Z",
                          "publishedAt": "2021-05-31T14:26:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The kernels I mentioned can be used for your case then.\nYou can adapt CoefReaction to make it use a function or store phi as a material property (using a GenericFunctionMaterial) and use MatReaction.",
                          "url": "https://github.com/idaholab/moose/discussions/17948#discussioncomment-808520",
                          "updatedAt": "2021-05-31T20:25:38Z",
                          "publishedAt": "2021-05-31T20:25:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to assign block id for embedded line in GMSH",
          "author": {
            "login": "rksin8"
          },
          "bodyText": "Dear moose users,\nI have a mesh that contains an embedded line. I want to assign properties based on block ID but when I open this mesh in ParaView, I see only one block ID for the surface. How can I create a block ID for the line as well?\nInput for geo file:\nMesh.Algorithm = 1;\nMesh.Optimize = 1;\nlc=50;\nlc2=10;\nPoint(0)={0,0,0,lc};\nPoint(1)={500,0,0,lc};\nPoint(2)={500,500,0,lc};\nPoint(3)={0,500,0,lc};\nPoint(4)={100,250,0,lc2};\nPoint(5)={400,250,0,lc2};\nPoint(6)={175,250,0,lc2};\nPoint(7)={325,250,0,lc2};\nLine (1) ={0,1};\nLine (2) ={1,2};\nLine (3) ={2,3};\nLine (4) ={3,0};\nLine (5) ={4,6};\nLine (6) ={6,7};\nLine (7) ={7,5};\nLine Loop(1) ={1,2,3,4};\nRuled Surface(1) = {1};\nLine {5} In Surface {1};\nLine {6} In Surface {1};\nLine {7} In Surface {1};\nPoint {6} In Surface {1};\nPoint {7} In Surface {1};\nPhysical Surface(1) = {1};\nPhysical Line(\"fracture\") = {6, 5, 7};\nPhysical Line(\"left\") = {4};\nPhysical Line(\"right\") = {2};\nPhysical Line(\"top\") = {3};\nPhysical Line(\"bottom\") = {1};\nPhysical Point(\"injection_well\") = {6};\nPhysical Point(\"production_well\") = {7};\n\nRegards,\nRanjeet",
          "url": "https://github.com/idaholab/moose/discussions/17958",
          "updatedAt": "2022-06-18T18:49:51Z",
          "publishedAt": "2021-05-28T07:47:13Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@lindsayad if you know.\nOtherwise, Ranjeet, if you get the answer from a gmsh forum, please post the answer here to help others.\nThanks",
                  "url": "https://github.com/idaholab/moose/discussions/17958#discussioncomment-805206",
                  "updatedAt": "2022-06-18T18:49:54Z",
                  "publishedAt": "2021-05-31T04:38:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rksin8"
                          },
                          "bodyText": "Thank you for your reply. now we have a solution.",
                          "url": "https://github.com/idaholab/moose/discussions/17958#discussioncomment-807827",
                          "updatedAt": "2022-06-18T18:50:03Z",
                          "publishedAt": "2021-05-31T16:52:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@rksin8 If you want to create a lower dimensional block, you need to make sure that the Physical name contains the string lower_dimensional_block. So if you want \"fracture\" to be a lower dimensional block, then you would do this:\nPhysical Line(\"fracture_lower_dimensional_block\") = {6, 5, 7};",
                  "url": "https://github.com/idaholab/moose/discussions/17958#discussioncomment-807631",
                  "updatedAt": "2022-06-18T18:50:04Z",
                  "publishedAt": "2021-05-31T15:52:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rksin8"
                          },
                          "bodyText": "It worked! Thank you so much.",
                          "url": "https://github.com/idaholab/moose/discussions/17958#discussioncomment-807825",
                          "updatedAt": "2022-06-18T18:50:04Z",
                          "publishedAt": "2021-05-31T16:52:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Awesome! I was just about to ask the same question.",
                          "url": "https://github.com/idaholab/moose/discussions/17958#discussioncomment-808138",
                          "updatedAt": "2022-06-18T18:50:04Z",
                          "publishedAt": "2021-05-31T18:22:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Matlab's ncread is so convenient",
          "author": {
            "login": "hugary1995"
          },
          "bodyText": "I just accidentally deleted an input file, and Matlab's ncread function saved me once again. I hope everyone is aware of this feature.\nIf you still have access to your output exodus file. In Matlab, you can do\nncread('out.e', 'info_records')'\nto get back the input file! Notice the transpose operation in the end.\nI believe you can use scipy.io.netcdf to do the same thing but your mileage may vary.",
          "url": "https://github.com/idaholab/moose/discussions/17852",
          "updatedAt": "2023-09-26T17:51:24Z",
          "publishedAt": "2021-05-16T16:50:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Awesome, thanks @hugary1995",
                  "url": "https://github.com/idaholab/moose/discussions/17852#discussioncomment-745898",
                  "updatedAt": "2023-09-26T17:51:24Z",
                  "publishedAt": "2021-05-16T23:47:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "In MOOSE we have --show-input that will print the input at the beginning of your output log.\nNot as good as getting it from exodus for sure.",
                  "url": "https://github.com/idaholab/moose/discussions/17852#discussioncomment-805288",
                  "updatedAt": "2023-09-26T17:51:24Z",
                  "publishedAt": "2021-05-31T05:24:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Concentration and Temperature Dependent NeumannBC",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "Dear MOOSE Team,\nFor my diffusion and heat model, I am writing a NeumannBC that is concentration and temperature dependent (please see the attached files for a simplified version).\nJust for the simplification, I just write here as:\nreturn -_test[_i][_qp]_u[_qp]_temperature[_qp]/273.15*_normals[_qp];\nIt compiles without \"_normals[_qp].\"\nAlso in the input file, \"variable = u\" needs to be set as:\n[BCs]\n[./right_u]\ntype = AnotherNeumannBC\nvariable = u\ndiffusion_variable = u\nheat_variable = temperature\nboundary = 'right'\n[../]\n[ ]\nIt would be appreciated if anyone could explain why \"_normals[_qp]\" cannot be used\nand \"variable = u\" needs to be set (I think \"diffusion_variable = u\" is enough).\nPlease help me.\nThomas\nIf \"_normals[_qp]\" is included, the error message is:\n~/AnotherNeumannBC.C:39:10: error: no viable conversion from returned value of type 'typename\nboostcopy::enable_if_c<ScalarTraits::value, TypeVector<typename CompareTypes<double, double>::supertype> >::type'\n(aka 'libMesh::TypeVector') to function return type 'libMesh::Real' (aka 'double')\nreturn -_test[_i][_qp]_u[_qp]_temperature[_qp]/273.15*_normals[_qp];\n^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1 error generated.\nAnotherNeumannBC.i.docx\nAnotherNeumannBC.h.docx\nAnotherNeumannBC.C.docx",
          "url": "https://github.com/idaholab/moose/discussions/17869",
          "updatedAt": "2022-06-21T15:09:15Z",
          "publishedAt": "2021-05-18T05:02:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "The BC residual needs to be a scalar, you're retuning a vector. Look at the\nweak form derivation. The normal does not show up in it. You're probably\nthinking intuitively there should be a gradient projected along the normal\n(only you don't have a gradient in there either).\n\u2026\nOn Mon, May 17, 2021, 11:02 PM styyokuda ***@***.***> wrote:\n Dear MOOSE Team,\n For my diffusion and heat model, I am writing a NeumannBC that is\n concentration and temperature dependent (please see the attached files for\n a simplified version).\n Just for the simplification, I just write here as:\n return -_test[_i][_qp]*_u[_qp]*_temperature[_qp]/273.15*_normals[_qp];\n\n It compiles without \"_normals[_qp].\"\n Also in the input file, \"variable = u\" needs to be set as:\n [BCs]\n [./right_u]\n type = AnotherNeumannBC\n variable = u\n diffusion_variable = u\n heat_variable = temperature\n boundary = 'right'\n [../]\n [ ]\n\n It would be appreciated if anyone could explain why \"_normals[_qp]\" cannot\n be used\n and \"variable = u\" needs to be set (I think \"diffusion_variable = u\" is\n enough).\n Please help me.\n Thomas\n\n If \"_normals[_qp]\" is included, the error message is:\n ~/AnotherNeumannBC.C:39:10: error: no viable conversion from returned\n value of type 'typename\n boostcopy::enable_if_c<ScalarTraits::value, TypeVector<typename\n CompareTypes<double, double>::supertype> >::type'\n (aka 'libMesh::TypeVector') to function return type 'libMesh::Real' (aka\n 'double')\n return -_test[_i][_qp]*_u[_qp]*_temperature[_qp]/273.15*_normals[_qp];\n ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n 1 error generated.\n\n AnotherNeumannBC.i.docx\n <https://github.com/idaholab/moose/files/6498427/AnotherNeumannBC.i.docx>\n AnotherNeumannBC.h.docx\n <https://github.com/idaholab/moose/files/6498434/AnotherNeumannBC.h.docx>\n AnotherNeumannBC.C.docx\n <https://github.com/idaholab/moose/files/6498435/AnotherNeumannBC.C.docx>\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#17869>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AABRMPX5P263PMVE4B7M7D3TOHYGRANCNFSM45BXZ3OA>\n .",
                  "url": "https://github.com/idaholab/moose/discussions/17869#discussioncomment-751057",
                  "updatedAt": "2022-06-21T15:09:42Z",
                  "publishedAt": "2021-05-18T05:08:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you very much for a great explanation.\nTwo more questions please.\n(1) In the input, \"variable = u\" is required because \"variable\" is a required parameter for the \"NeumannBC\" object requires (so, I don't need to setup \"diffusion_variable = u\" here).\n(2) I modified the \"NeumannBC\" object here but, more complicated calculations, I can use the \"Material\" object, too.\nPlease let me know if my understanding of the above two is correct.\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17869#discussioncomment-753269",
                          "updatedAt": "2022-06-21T15:09:52Z",
                          "publishedAt": "2021-05-18T14:39:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "indeed. No need to specify the variable twice if it's clear what's the variable\nYou can use Material objects in a modified NeumannBC, just inherit a MaterialPropertyInterface in your BC object",
                          "url": "https://github.com/idaholab/moose/discussions/17869#discussioncomment-805284",
                          "updatedAt": "2022-06-21T15:09:59Z",
                          "publishedAt": "2021-05-31T05:22:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "LineMaterialRealSampler with AD",
          "author": {
            "login": "FloPasselaigue"
          },
          "bodyText": "Hello,\nI am working on an update of the hydrogen in BISON, and so I developed a test case. For this test I check the value of the material 'solubility' along the x axis, using the VectorPostProcessor LineMaterialRealSampler:\n[VectorPostprocessors]\n  [solub]\n    type = LineMaterialRealSampler\n    property = 'solubility'\n    sort_by = x\n    start = '0 2e-4 0'\n    end = '25e-3 2e-4 0'\n    outputs = diff\n  []\n[]\n[Outputs]\n  [profile]\n    type = CSV\n    execute_on = 'final'\n    create_final_symlink = true\n  []\n[]\n\nThe normal test works just fine, however the AD version fails, raising a Bad file descriptor error:\nThe following error occurred in the object \"solubility\", of type \"LineMaterialRealSampler\".\nIn LineMaterialSamplerBase material property: solubility does not exist.\n\nThe only difference between the two versions is that the argument use_automatic_differentiation is set to true (below is the part of interest in the test file)\n  [solubility]\n    type = 'CSVDiff'\n    input = 'solubility.i'\n    csvdiff = 'solubility_profile_solubility_FINAL.csv'\n    rel_err = 1e-2\n    requirement = \"BISON shall be able to compute the effective solubility of hydrogen.\"\n  []\n  [solubilityAD]\n    type = 'CSVDiff'\n    input = 'solubility.i'\n    csvdiff = 'solubility_profile_solubility_FINAL.csv'\n    rel_err = 1e-2\n    requirement = \"BISON shall be able to compute the effective solubility of hydrogen with AD.\"\n    prereq = solubility\n    cli_args = 'CladdingHydrides/hydrides/use_automatic_differentiation=true'\n  []\n\nI tried with another material to output and ran into the same issue, so it doesn't seem to be specific to the solubility material. Maybe I missed something, but I don't think the material names are changed when using AD, or that the VectorPostprocessors classes need an AD equivalent? I have a similar test in which I check the profile of a variable using LineValueSampler and it works, so it seems to be specific to LineMaterialRealSampler.\nIf anyone has a solution I'd really appreciate it.\nThanks for your help,\nFlorian Passelaigue",
          "url": "https://github.com/idaholab/moose/discussions/17857",
          "updatedAt": "2022-08-10T17:44:17Z",
          "publishedAt": "2021-05-17T17:47:06Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "LineMaterialSamplerBase is already templated. But LineMaterialRealSampler is only specialized for Real not ADReal. You would want to add a template parameter bool is_ad in LineMaterialRealSampler, and instantiate it to LineMaterialRealSampler when is_ad = false, and instantiate it to ADLineMaterialRealSampler when is_ad = true.",
                  "url": "https://github.com/idaholab/moose/discussions/17857#discussioncomment-749278",
                  "updatedAt": "2022-08-10T17:45:25Z",
                  "publishedAt": "2021-05-17T17:52:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "FloPasselaigue"
                          },
                          "bodyText": "Thank you for your answer, I took a look but I wouldn't know how to do this modification. I think I found another way to test the implementation without using LineMaterialRealSampler.",
                          "url": "https://github.com/idaholab/moose/discussions/17857#discussioncomment-749992",
                          "updatedAt": "2022-08-10T17:45:33Z",
                          "publishedAt": "2021-05-17T20:53:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can look at the GenericConstantMaterial for examples of AD templating",
                          "url": "https://github.com/idaholab/moose/discussions/17857#discussioncomment-805276",
                          "updatedAt": "2022-08-10T17:45:33Z",
                          "publishedAt": "2021-05-31T05:19:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Ansys mesh cannot be used in moose",
          "author": {
            "login": "liangyu-psi"
          },
          "bodyText": "Bug Description\nThe mesh generated by ICEM or Ansys Mesh cannot be recongized by MOOSE.\nSteps to Reproduce\nThe format of mesh is .msh. It's will cause a dimension error.\nBut when I use Gmsh. Although the format is still .msh, it will be recongized by MOOSE.\nImpact\nIt's not convenient to create a mesh by familiar software. I don't know if the mesh file of Ansys does not meet the MOOSE standard. Hope someone can answer. Many thanks.",
          "url": "https://github.com/idaholab/moose/discussions/17434",
          "updatedAt": "2022-06-28T14:49:13Z",
          "publishedAt": "2021-03-23T10:27:35Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "liangyu-psi"
                  },
                  "bodyText": "Is there anybody know the reason?",
                  "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-534718",
                  "updatedAt": "2022-06-28T14:49:13Z",
                  "publishedAt": "2021-03-26T13:31:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AnthonyB08"
                          },
                          "bodyText": "Is there any update on using Ansys Meshing file for MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-799493",
                          "updatedAt": "2022-06-28T14:49:14Z",
                          "publishedAt": "2021-05-28T19:48:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "You might be confusing a file extension with a mesh format. While both files end in .msh they might not be the same format at all. Is there a different format you could export your mesh to with Ansys?",
                  "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-534719",
                  "updatedAt": "2022-06-28T14:49:14Z",
                  "publishedAt": "2021-03-26T15:07:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "@dschwen This link suggests there are only a handful of export options for ANSYS (.mechdat, .msh, .poly, .cgns, .prj, and .tgf), so I think exporting to ANSYS .msh and converting using meshio (in my other answer) is probably the best bet if ANSYS must be used.",
                          "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-799698",
                          "updatedAt": "2022-06-28T14:49:28Z",
                          "publishedAt": "2021-05-28T20:58:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "There is a python tool, Meshio, that would allow a conversion from the .msh file created by ANSYS to an Exodus .e file which MOOSE can also import. Check out https://pypi.org/project/meshio/",
                  "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-799681",
                  "updatedAt": "2022-06-28T14:49:35Z",
                  "publishedAt": "2021-05-28T20:52:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AnthonyB08"
                          },
                          "bodyText": "I have tried this, but i keeps returning the same error of :\n\nSo then I resorted to importing my .msh into CUBIT and exporting it as a .e",
                          "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-799725",
                          "updatedAt": "2022-06-28T14:49:36Z",
                          "publishedAt": "2021-05-28T21:10:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "Oops - Not a very helpful error is it? Though it appears as though meshio could be treating it as a GMSH .msh file as well, judging from that output. I don't have ANSYS to troubleshoot with, but I'm glad you have a good workaround!",
                          "url": "https://github.com/idaholab/moose/discussions/17434#discussioncomment-799739",
                          "updatedAt": "2022-06-28T14:49:41Z",
                          "publishedAt": "2021-05-28T21:15:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Access to nodal variable value][Postprocessor]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Dear users,\nI just found a way to access nodal variable values in postprocessors like the below (bold).\nBut this method only can access individual nodal id.\nIs there any way to call all nodal variable values in postprocessors?\nOr how can I load a number of nodes in mesh?\nThen, maybe I can use iterations to call all the variable values.\nI have looked through the whole postprocessors in moose but I could not find anything.\n\nReal\nNodalVariableValue::getValue()\n{\nReal value = 0;\nif (_node_ptr && _node_ptr->processor_id() == processor_id())\nvalue = _subproblem.getStandardVariable(_tid, var_name).getNodalValue(*_node_ptr);\ngatherSum(value);\nreturn _scale_factor * value;\n}",
          "url": "https://github.com/idaholab/moose/discussions/17952",
          "updatedAt": "2022-08-01T11:15:51Z",
          "publishedAt": "2021-05-27T16:08:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "Can you describe specifically what you are trying to accomplish? That is, what are you trying to output and when?",
                  "url": "https://github.com/idaholab/moose/discussions/17952#discussioncomment-793951",
                  "updatedAt": "2022-08-01T11:15:54Z",
                  "publishedAt": "2021-05-27T16:20:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "coskrrb2002"
                          },
                          "bodyText": "Dear loganharbour,\nI am trying to make a precipitation of U(VI) in my transient model.\nSo, if U(VI) is reached certain threshold concentration, it will be precipitated via kinetic constant with U(VI) complex.\nTo make this, I need a postprocess every end of time step and this precipiated U(VI) complex should be an accumulated value.\nHence, I would like to access variable value end of each time step for whole nodal value to get concentration of U(VI) and judge whether it is saturated and start to precipitate.\nThen, I want to make the accumulation of U(VI) complex.",
                          "url": "https://github.com/idaholab/moose/discussions/17952#discussioncomment-795975",
                          "updatedAt": "2022-08-01T11:15:55Z",
                          "publishedAt": "2021-05-28T03:47:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "coskrrb2002"
                  },
                  "bodyText": "Oh, I found the way to do this and made it!\nI used the following postprocessors and auxkernel.\nCumulativeValuePostprocessor, PostprocessorAux, and I modified NodalExtremeValue to get nodal value.\nSo, Modified NodalExtremeValue load variable values in nodes, then the CumulativeValuePostprocessor calculated the accumulation of nodal variable values.\nAfter that PostrpocessorAux assigned accumulated values into auxvariables!\nThank you so much loganharbour!",
                  "url": "https://github.com/idaholab/moose/discussions/17952#discussioncomment-796385",
                  "updatedAt": "2022-08-01T11:15:56Z",
                  "publishedAt": "2021-05-28T06:14:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Material Properties as a function of temperature",
          "author": {
            "login": "alikhan-zada"
          },
          "bodyText": "Hello everyone,\nI'm new to MOOSE and I am currently trying to use the Heat Conduction Module. Please bear with my novice question even if they might be very obvious\n\nI want to be able to use the thermal conductivity and specific heat as a function of temperature, something of this sort:\n\nthermal conductivity = 11.82 + 0.0106 T\nspecific heat = 330.9 + 0.563 T - 0.0004015 T^2 + 0.00000009465 T^3\nI have tried doing this using thermal_conductivity_temperature_function in the materials block, but Functions can only take in only (x,y,z,t) as variables.\n[Functions]\n[./k_func]\ntype = ParsedFunction\nvars = temp\nvalue = '11.82 + 0.0106 * temp'\n[../]\n[./c_func]\ntype = ParsedFunction\nvars = temp\nvalue = '330.9 + 0.563 * temp - 0.0004015 * temp * temp + 0.00000009465 *temp * temp * temp'\n[../]\n[] # Functions\n[Materials]\n[./heat]\ntype = ADHeatConductionMaterial\nblock = 0\ntemp = temp\nthermal_conductivity_temperature_function = k_func\nspecific_heat_temperature_function = c_func\n[../]\n[]\nWhich is obviously wrong. Can someone point me in the right direction, please :)\n\n\nMy other question is, how can I link the FunctionPathEllipsoidHeatSource and grain_growth_2D_graintracker together?\nI know there's an implementation of the grain_growth_2D_graintracker where the mobility is a function of temperature. This can be done using multiapps, but which multiapp would be the most suitable for this application? A question similar to this (here) has already been asked in the discussions but the answers are not very helpful.\n\n\nLastly, what are the units of the different constants used in  FunctionPathEllipsoidHeatSource?\n\n\nKind regards,\nAli\nEdit: I was able to link up the two apps, so need to worry about question 2  \ud83d\ude05\ufe0f\nEdit 2: for question 3, units of material properties in the function_ellipsoid_heat_source are as follows:\nSpecific heat = J/(Kg . K)\nThermal Conductivity = W/(mm . K)\nDensity = Kg/mm^3\nPlease correct me if I am wrong. \ud83d\ude05",
          "url": "https://github.com/idaholab/moose/discussions/17820",
          "updatedAt": "2022-08-28T03:53:50Z",
          "publishedAt": "2021-05-13T10:45:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "I would create a new Material that defines the conductivity and specific heat with your desired function coded in the Material object.\nWe do this in Step 5 and 6 of the YouTube tutorial on the front page of mooseframework.org. Click the 'SHOW MORE\" and you will be able to go to the section.\nIn the tutorial we do a linear interpolation based on tabulated data to compute the temperature dependent properties: https://github.com/idaholab/moose/blob/next/tutorials/darcy_thermo_mech/step06_coupled_darcy_heat_conduction/src/materials/PackedColumn.C",
                  "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-734535",
                  "updatedAt": "2022-09-19T03:12:28Z",
                  "publishedAt": "2021-05-13T16:08:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alikhan-zada"
                          },
                          "bodyText": "Thank you Andrew,\nI'll take a look and let you know if I have any more questions.\nCheers,\nAli",
                          "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-736743",
                          "updatedAt": "2022-09-19T03:12:29Z",
                          "publishedAt": "2021-05-14T03:57:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alikhan-zada"
                          },
                          "bodyText": "Hey @aeslaughter, so what if I want to deposit a layer of material after each time the heat source passed from on top of the material?\nSomething like this https://ars.els-cdn.com/content/image/1-s2.0-S0924013618300980-mmc4.gif",
                          "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-769266",
                          "updatedAt": "2022-09-19T03:12:29Z",
                          "publishedAt": "2021-05-21T16:45:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "We do have some developments for this purpose. I would suggest you to look at: https://mooseframework.inl.gov/source/userobject/CoupledVarThresholdElementSubdomainModifier.html\nThe idea is to divide your physical domain into \"active\" and \"inactive\" subdomains, define your physical kernels in the \"active subdomain\" (with 'block = #'), and constantly moving elements from  \"inactive subdomain\" -> \"active subdomain\". (Set the kernel_coverage_check = false in the Problem block if no kernel is defined in the inactive subdomain)\nTo realize layer-by-layer material addition, I would try to set the coupled_var to be the z-position of the element. The threshold value to be the height of the heat source (I guess), below which the elements will be added. If you would like to apply BC at the top of the product as it is growing, then set the moving _boundary_name to be the sideset of the product top surface.\n@hugary1995 please feel free to add/correct me here since you made some great changes to this code :)",
                          "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-783493",
                          "updatedAt": "2022-09-19T03:12:29Z",
                          "publishedAt": "2021-05-25T21:56:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alikhan-zada"
                          },
                          "bodyText": "Thank you @dewenyushu for your answer.\nAs you can see in the gif, there is also a 2-D sectioned area, is it possible to deploy a MultiApp system just in that 2-D section and transfer the value of the heat source?\nWhat I am guessing is that both the Master and the sub app use the TransientMultiApp system and since the scales are not that different use the MultiAppCopyTransfer because I will probably use the same mesh distribution. But I might need to use a different transfer function if I decide to use adaptivity, what would be the best choice in that case?",
                          "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-790893",
                          "updatedAt": "2022-09-19T03:12:31Z",
                          "publishedAt": "2021-05-27T08:32:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Since I am not an expert on multiapp and transfers, @jiangwen84 would you mind answering this question?",
                          "url": "https://github.com/idaholab/moose/discussions/17820#discussioncomment-794848",
                          "updatedAt": "2022-09-19T03:12:33Z",
                          "publishedAt": "2021-05-27T19:38:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}