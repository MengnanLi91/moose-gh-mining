{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNi0xOVQxMDozODoyMC0wNTowMM4AUR87"
    },
    "edges": [
      {
        "node": {
          "title": "Issue with hanging nodes + small strain plasticity",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Hi all,\nI am having issues when combining hanging nodes with a small strain plasticity material. This is not with adaptivity, the mesh starts with hanging nodes and does not change.\nFor testing, I am running a problem in uniaxial tension. The mesh is made and refined using MOOSE.\nI have the following simulation parameters:\n\nTensor mechanics module\n\n\nSmall strain + incremental formulation\n\n\nvolumetric locking correction\nIsotropic elasticity\nPower law hardening\n\nThe refined area of the mesh is designed to yield first.\nI've attached the input file I used(I had to attach it as a .txt file).\ntension_moose.txt\nWhile the plastic strain field looks ok, the stress field contains significant oscillations, as seen in the image attached. These oscillations are always concentrated near the transition zones for mesh refinement.\n\nI have tried this with several iterations on the problem setup (finite strain, no vol lock correction, total formulation) but I see the same stress oscillations each time. Also, I see no oscillations with a purely elastic material.\nAny insight into this issue would be much appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/24759",
          "updatedAt": "2023-06-22T22:24:35Z",
          "publishedAt": "2023-06-21T14:53:29Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@lindsayad @dschwen I think this is tied to a recent conversation.",
                  "url": "https://github.com/idaholab/moose/discussions/24759#discussioncomment-6242987",
                  "updatedAt": "2023-06-21T14:58:57Z",
                  "publishedAt": "2023-06-21T14:58:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Is there an incompatibility with how data interpolation works on hanging nodes and plasticity?",
                          "url": "https://github.com/idaholab/moose/discussions/24759#discussioncomment-6243050",
                          "updatedAt": "2023-06-21T15:05:56Z",
                          "publishedAt": "2023-06-21T15:05:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Do you see oscillations without adaptivity?",
                          "url": "https://github.com/idaholab/moose/discussions/24759#discussioncomment-6244010",
                          "updatedAt": "2023-06-21T16:38:32Z",
                          "publishedAt": "2023-06-21T16:38:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "There is no adaptivity, the mesh intentionally starts with hanging nodes",
                          "url": "https://github.com/idaholab/moose/discussions/24759#discussioncomment-6244167",
                          "updatedAt": "2023-06-21T16:55:05Z",
                          "publishedAt": "2023-06-21T16:55:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "But using unstructured quad mesh refinement does not lead to oscillations",
                          "url": "https://github.com/idaholab/moose/discussions/24759#discussioncomment-6244171",
                          "updatedAt": "2023-06-21T16:55:48Z",
                          "publishedAt": "2023-06-21T16:55:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Adaptivity is not used btw. It s the refineSidesetGenerator.\nDoes it work with a single level of refinement?",
                          "url": "https://github.com/idaholab/moose/discussions/24759#discussioncomment-6244189",
                          "updatedAt": "2023-06-21T16:57:42Z",
                          "publishedAt": "2023-06-21T16:57:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "The oscillations are still present with 1 level of refinement",
                          "url": "https://github.com/idaholab/moose/discussions/24759#discussioncomment-6244422",
                          "updatedAt": "2023-06-21T17:24:39Z",
                          "publishedAt": "2023-06-21T17:24:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok can you try with adaptivity instead of sideset refinement now?\nUse a constant marker boundary-restricted to the boundary of interest\nI apologize in advance if that does not work, I m trying to see if we can get your case going as our user support resources are low right now",
                          "url": "https://github.com/idaholab/moose/discussions/24759#discussioncomment-6244445",
                          "updatedAt": "2023-06-21T17:26:52Z",
                          "publishedAt": "2023-06-21T17:26:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Unfortunately, that gives similar oscillations",
                          "url": "https://github.com/idaholab/moose/discussions/24759#discussioncomment-6244622",
                          "updatedAt": "2023-06-21T17:48:50Z",
                          "publishedAt": "2023-06-21T17:48:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "It seems like we should start making a list of physics that don't play well with hanging nodes :-/",
                          "url": "https://github.com/idaholab/moose/discussions/24759#discussioncomment-6245234",
                          "updatedAt": "2023-06-21T19:11:48Z",
                          "publishedAt": "2023-06-21T19:11:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "What? How? How can this be physics specific? Can you show us the displacement field? Are you sure your solution is tightly converged? The residuals at the hanging nodes seem to converge from opposite signs, so a badly converged solution would exhibit exactly this checkerboarding as far as I can see.",
                          "url": "https://github.com/idaholab/moose/discussions/24759#discussioncomment-6255628",
                          "updatedAt": "2023-06-22T19:38:58Z",
                          "publishedAt": "2023-06-22T19:38:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about CombinerGenerator",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Hi all,\nI am loading in two meshes and combining them into a disjoint mesh using combiner generator using the method showed below.\n[Mesh]\n  [refine]\n    type = FileMeshGenerator\n    file = '../../gold/ref_sec.msh'\n  []\n  [coarse]\n    type = FileMeshGenerator\n    file = '../../gold/coarse_sec2.msh'\n  []\n  [combine]\n    type = CombinerGenerator\n    inputs = 'coarse refine'\n  []\n[]\n\nMy issue is that only the subdomain ID's on the 'coarse' mesh are being preserved. The subdomains on the 'refine' mesh are being discarded by CombinerGenerator. It seems that which ever mesh is listed first in 'inputs' has its subdomain IDs preserved. I need the subdomain IDs on both meshes to be preserved. Is there a workaround for this?\nedit: Note that all of the subdomainIDs between both meshes are unique",
          "url": "https://github.com/idaholab/moose/discussions/24763",
          "updatedAt": "2023-06-22T21:14:18Z",
          "publishedAt": "2023-06-21T17:01:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNot currently. This is a known issue, scheduled to be addressed over the summer.\nFor now you can either modify the generator yourself, or combine the meshes with external software first.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24763#discussioncomment-6244321",
                  "updatedAt": "2023-06-21T17:14:03Z",
                  "publishedAt": "2023-06-21T17:14:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We addressed sideset IDs there #20825\nFor domain ids & names:\nTied to #24577",
                          "url": "https://github.com/idaholab/moose/discussions/24763#discussioncomment-6244397",
                          "updatedAt": "2023-06-21T17:22:11Z",
                          "publishedAt": "2023-06-21T17:22:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Got it, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/24763#discussioncomment-6244429",
                          "updatedAt": "2023-06-21T17:25:39Z",
                          "publishedAt": "2023-06-21T17:25:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MengnanLi91"
                  },
                  "bodyText": "The issue is that these two meshes doesn't have a proper block name. Can you try adding below mesh generator for each mesh and then combine? This should preserve both subdomain names\n[refine_block]\n   type = RenameBlockGenerator\n   input = refine\n   old_block = /*subdomainID here*/\n   new_block = /*block name*/\n []",
                  "url": "https://github.com/idaholab/moose/discussions/24763#discussioncomment-6256266",
                  "updatedAt": "2023-06-22T21:14:18Z",
                  "publishedAt": "2023-06-22T21:14:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Domain names lost with CombinerGenerator",
          "author": {
            "login": "adigc"
          },
          "bodyText": "Hello everyone,\nI have a similar problem with CombinerGenerator as described here: #20823\nSince the discussion is a year old, I am making a new one.\nI am trying to combine two meshes.\n\nMesh 1 : Read in from a .e file (block name : neck)\nMesh 2 : Generated from a GeneratedMeshGenerator (block id: 50)\n\nNow when I am trying to combine these two using CombinerGenerator, the block names and side set names of the second mesh in the inputs are lost.\nCase 1: neck, line\n  [cmbn]\n      type = CombinerGenerator\n      inputs = 'neck line'\n  [] \n\nOutput when running with --mesh-only option\n\nSince neck comes before the line, we can see from the output, the block name neck is preserved.\nCase 2: line, neck\n  [cmbn]\n      type = CombinerGenerator\n      inputs = 'line neck'\n  []\n\nOutput when running with --mesh-only option\n\nSince line comes before neck, we can see from the output, the block name neck is lost.  Similarly, node set names are also lost.\nI am attaching the above mentioned example here :\ncombiner_mesh_example.zip\nAny pointers on how to solve this will be helpful.\nThank you in advance.",
          "url": "https://github.com/idaholab/moose/discussions/24577",
          "updatedAt": "2023-06-24T19:48:01Z",
          "publishedAt": "2023-06-02T13:22:10Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you trying to stitch the meshes?\nOr just have them disconnected in the same simulation?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6071981",
                  "updatedAt": "2023-06-02T13:28:13Z",
                  "publishedAt": "2023-06-02T13:28:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "adigc"
                          },
                          "bodyText": "Hi @GiudGiud\nfor now disconnected, but in my upcoming investigations, I will have to connect their nodes with MPCs probably.",
                          "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6072020",
                          "updatedAt": "2023-06-02T13:31:24Z",
                          "publishedAt": "2023-06-02T13:31:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adigc"
                          },
                          "bodyText": "In the example I provided above, the two mehes overlap. But in a general case they do not.",
                          "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6072178",
                          "updatedAt": "2023-06-02T13:42:56Z",
                          "publishedAt": "2023-06-02T13:42:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We're not going to be able to patch this over the next 2 weeks because of the upcoming training.\nI would recommend you re-create the subdomains you need using other mesh generators, like the ParsedSubdomainGenerator",
                          "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6072786",
                          "updatedAt": "2023-06-02T14:31:14Z",
                          "publishedAt": "2023-06-02T14:31:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adigc"
                          },
                          "bodyText": "@GiudGiud thank you for the reply. I believe that I have found necessary changes to the code for this issue. Is it ok if I make a PR with these changes ?",
                          "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6163407",
                          "updatedAt": "2023-06-13T12:57:41Z",
                          "publishedAt": "2023-06-13T12:57:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "That\u2019s a good idea. We can take a look in a PR",
                          "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6163739",
                          "updatedAt": "2023-06-13T13:29:21Z",
                          "publishedAt": "2023-06-13T13:29:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MengnanLi91"
                  },
                  "bodyText": "I think this issue has already been fixed in #22838.  In your input file [line] doesn't have a proper block name, you will need to use another RenameBlockGenerator to provide a name for \"line\". Then the both subdomains should have names in the end.",
                  "url": "https://github.com/idaholab/moose/discussions/24577#discussioncomment-6256096",
                  "updatedAt": "2023-06-22T20:47:05Z",
                  "publishedAt": "2023-06-22T20:47:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "1D MESH subdomain/block creation",
          "author": {
            "login": "ananthanarasimhanj"
          },
          "bodyText": "I want to perform 1D heat conduction, and it involves two materials. I am now trying to create a mesh, and assign them as made of 2 blocks, to define material properties, and BC. I am not finding relevant guidance to assigning \"type\" for the 1D subdomains to create. Below is the incomplete code for MESH.\n[Mesh]\n  [generated]\n    type = GeneratedMeshGenerator\n    dim = 1\n    nx = 10\n    xmax = 1\n  []\n\n  [air_block]\n    type = \n    input = generated\n    block_id = 1\n    left = 0\n    right = 0.5\n  []\n\n  [water_block]\n    type = \n    input = generated\n    block_id = 2\n    left = 0.5\n    right = 1\n  []\n\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24791",
          "updatedAt": "2023-06-24T19:47:49Z",
          "publishedAt": "2023-06-22T02:17:14Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "You probably want type = SubdomainBoundingBoxGenerator",
                  "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6254578",
                  "updatedAt": "2023-06-22T17:27:05Z",
                  "publishedAt": "2023-06-22T17:27:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ananthanarasimhanj"
                          },
                          "bodyText": "I tried that and it shows error. I am attaching the input file, and the error too.\n[Mesh]\n[generated]\ntype = GeneratedMeshGenerator\ndim = 1\nnx = 10\nxmax = 1\nblock_id = 0\n[]\n[air_block]\ntype = SubdomainBoundingBoxGenerator\ninput = generated\nblock_id = 1\nbottom_left = '0 0 0'\ntop_right = '0.5 0 0'\n[]\n[water_block]\ntype = SubdomainBoundingBoxGenerator\ninput = generated\nblock_id = 2\nbottom_left = '0.5 0 0'\ntop_right = '1 0 0'\n[]\n[]\n[Variables]\n[T]\ninitial_condition = 300.0\n[]\n[]\n[Kernels]\n[heat_conduction]\ntype = HeatConduction\nvariable = T\n[]\n[time_derivative]\ntype = HeatConductionTimeDerivative\nvariable = T\n[]\n[]\n[Materials]\n[thermal1]\ntype = HeatConductionMaterial\nthermal_conductivity = 0.02587 # 20 degree Celcius, W/mK\nspecific_heat = 1006 # Cp, 20 degree Celcius, J/kgK\nblock = 1\n[]\n[thermal2]\ntype = HeatConductionMaterial\nthermal_conductivity = 0.598 # 20 degree Celcius, W/mK\nspecific_heat = 4150 # Cv, 20 degree Celcius, J/kgK\nblock = 2\n[]\n[density1]\ntype = GenericConstantMaterial\nprop_names = 'density'\nprop_values = 1.204 # 20 degree Celcius kg/m3\nblock = 1\n[]\n[density2]\ntype = GenericConstantMaterial\nprop_names = 'density'\nprop_values = 998.19 # 20 degree Celcius kg/m3\nblock = 2\n[]\n[]\n[BCs]\n[t_left]\ntype = DirichletBC\nvariable = T\nvalue = 373.15\nboundary = 'left'\nblock = 1\n[]\n[t_right]\ntype = FunctionNeumannBC\nvariable = T\nfunction = 0\nboundary = 'right'\nblock = 2\n[]\n[]\n[Executioner]\ntype = Transient\nend_time = 4\ndt = 1e-3\n[]\n[VectorPostprocessors]\n[t_sampler]\ntype = LineValueSampler\nvariable = T\nstart_point = '0 0 0'\nend_point = '1 0 0'\nnum_points = 20\nsort_by = x\n[]\n[]\n[Outputs]\nexodus = true\n[csv]\ntype = CSV\nfile_base = hc3_out\nexecute_on = final\n[]\n[]\n*** ERROR ***\nYour MeshGenerator tree contains multiple possible generator outputs :\n\"water_block and one or more of the following from an independent set: \"air_block\"\nThis may be due to a missing dependency or may be intentional. Please either\n\ncheck that all the mesh generators are connected as a tree and culminate in a single final mesh. Having one wrong 'input=mg' parameter is the most common error\nadd additional dependencies to remove the ambiguity if you are using a user-built MeshGenerator\nif you intend to execute a subset of the defined generators (uncommon), select the final MeshGenerator in the [Mesh] block with the \"final_generator\" parameter.",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6254993",
                          "updatedAt": "2023-06-22T18:24:39Z",
                          "publishedAt": "2023-06-22T18:24:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "try\n[water_block]\ntype = SubdomainBoundingBoxGenerator\ninput = air_block\nblock_id = 2\nbottom_left = '0.5 0 0'\ntop_right = '1 0 0'\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6255024",
                          "updatedAt": "2023-06-22T18:29:31Z",
                          "publishedAt": "2023-06-22T18:29:31Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ananthanarasimhanj"
                          },
                          "bodyText": "If the input is air_block, then the coordinates I have mentioned for water_block are outside air_block. Is that fine? I tried this, and I am getting the following error.\n*** ERROR ***\n/home/ananth/projects/hc/hc1/hc3.i:12: unused parameter 'Mesh/generated/block_id'\n/home/ananth/projects/hc/hc1/hc3.i:90: unused parameter 'BCs/t_left/block'\n/home/ananth/projects/hc/hc1/hc3.i:98: unused parameter 'BCs/t_right/block'\nbelow snapshot shows what I want to do.",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6255088",
                          "updatedAt": "2023-06-22T18:37:37Z",
                          "publishedAt": "2023-06-22T18:37:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "These unused parameter errors must be addressed.\nBoundary conditioons apply on boundaries not blocks.\nAnd one of the mesh parameters is wrong too. Please check the object documentation",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6255108",
                          "updatedAt": "2023-06-22T18:40:01Z",
                          "publishedAt": "2023-06-22T18:40:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ananthanarasimhanj"
                          },
                          "bodyText": "Sure. Thanks for the help.",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6255144",
                          "updatedAt": "2023-06-22T18:44:07Z",
                          "publishedAt": "2023-06-22T18:44:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ananthanarasimhanj"
                          },
                          "bodyText": "I tried below code, and it seems working.\n[Mesh]\n  [air_block]\n    type = GeneratedMeshGenerator\n    dim = 1\n    nx = 10\n    xmax = 1\n  []\n\n  [water_block]\n    type = SubdomainBoundingBoxGenerator\n    input = air_block\n    block_id = 1\n    bottom_left = '0.5 0 0'\n    top_right = '1 0 0'\n  []\n[]\n\n[Variables]\n  [T]\n    initial_condition = 300.0\n  []\n[]\n\n[Kernels]\n  [heat_conduction]\n    type = HeatConduction\n    variable = T\n  []\n\n  [time_derivative]\n    type = HeatConductionTimeDerivative\n    variable = T\n  []\n\n[]\n\n[Materials]\n  [thermal1]\n    type = HeatConductionMaterial\n    thermal_conductivity = 0.02587 # 20 degree Celcius, W/mK\n    specific_heat = 1006 # Cp, 20 degree Celcius, J/kgK\n    block = 0\n  []\n\n  [thermal2]\n    type = HeatConductionMaterial\n    thermal_conductivity = 0.598 # 20 degree Celcius, W/mK\n    specific_heat = 4150 # Cv, 20 degree Celcius, J/kgK\n    block = 1\n  []\n\n\n  [density1]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = 1.204 # 20 degree Celcius kg/m3\n    block = 0\n  []\n\n  [density2]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = 998.19 # 20 degree Celcius kg/m3\n    block = 1\n  []\n\n\n[]\n\n[BCs]\n  [t_left]\n    type = DirichletBC\n    variable = T\n    value = 373.15\n    boundary = 'left'\n  []\n\n  [t_right]\n    type = FunctionNeumannBC\n    variable = T\n    function = 0\n    boundary = 'right'\n  []\n\n\n \n[]\n\n[Executioner]\n  type = Transient\n  end_time = 4\n  dt = 1e-3\n[]\n\n[VectorPostprocessors]\n  [t_sampler]\n    type = LineValueSampler\n    variable = T\n    start_point = '0 0 0'\n    end_point = '1 0 0'\n    num_points = 20\n    sort_by = x\n  []\n[]\n\n[Outputs]\n  exodus = true\n  [csv]\n    type = CSV\n    file_base = hc3_out\n    execute_on = final\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24791#discussioncomment-6255205",
                          "updatedAt": "2023-06-22T18:52:24Z",
                          "publishedAt": "2023-06-22T18:51:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Has stitched mesh syntax changed?  Is it compatible with increase AD container size?",
          "author": {
            "login": "EdSheltonUKAEA"
          },
          "bodyText": "I'm sure that a few weeks ago I was running models OK with the stitched mesh given below:\n\n[Mesh]\n[01] # Regular mesh at surface\ntype = GeneratedMeshGenerator\ndim = 1\nxmin = 0 # m\nxmax = 5e-8 # m\nbias_x = 1\nnx = 100 # Element size = 5e-10 m\n[]\n[02] # Biased mesh (for implantation and diffusion)\ntype = GeneratedMeshGenerator\ndim = 1\nxmin = 5e-8 # m\nxmax = 1e-5 # m\nbias_x = 1.111676\nnx = 73 # First element 4.9e-10 m, last element = 1e-6 m\n[]\n[03] # Regular mesh to 0.2 mm\ntype = GeneratedMeshGenerator\ndim = 1\nxmin = 1e-5 # m\nxmax = 2e-4 # m\nbias_x = 1 # m\nnx = 190 # Element size = 1e-6 m\n[]\n[Mesh_stitcher]\ntype = StitchedMeshGenerator\ninputs = '01 02 03'\nstitch_boundaries_pairs = 'right left; right left'\n[]\n[]\n\nI'm trying to run it again now, but get error messages:\n\nIn UnstructuredMesh::stitch_meshes:\nThis mesh has 1 nodes on boundary 1.\nOther mesh has 2 nodes on boundary 2.\nMinimum edge length on both surfaces is 5e-10.\nIn UnstructuredMesh::stitch_meshes:\nFound 1 matching nodes.\n*** ERROR ***\n/home/eshelton/projects/red-kite/problems/HD_3tr_oc616_Ph1Imp_Model.i:38: (Mesh/Mesh_stitcher/stitch_boundaries_pairs):\nBoundary right doesn't exist on the first mesh in Mesh_stitcher\nBoundary names that do exist:\nID : Name\n0 : left\n2 : left\n\nI ran a MOOSE update yesterday.  Has something changed with the StitchedMeshGenerator syntax in the last few weeks which means my old code doesn't work any more.\nThe other thing that might be different is that in the update I needed to increase AD container size to resolve another error message cause by an increase in number of variables.  I ran this line of code before compiling MOOSE.\n\n./configure --with-derivative-size=600 --with-ad-indexing-type=global\n\nCould this have upset the mesh stitcher?",
          "url": "https://github.com/idaholab/moose/discussions/24744",
          "updatedAt": "2023-06-21T14:57:31Z",
          "publishedAt": "2023-06-20T14:31:04Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes it has changed.\nIt used to merge sidesets with the same ids. It does not do it anymore.\nIf you want the previous behavior, please pass as an additional parameter\nprevent_boundary_ids_overlap = false\nThe AD derivative size is a separate topic\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24744#discussioncomment-6231647",
                  "updatedAt": "2023-06-20T14:54:46Z",
                  "publishedAt": "2023-06-20T14:54:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "That's worked great thanks!\nBut has this also changed something with how the mesh is saved in the an ExodusII ouput file?\nWhen I try to apply the mesh and variable values from the final time step in a subsequent phase of analysis, I get this error:\n\nTime Step 0, time = 0\nlibMesh terminating:\nError creating ExodusII/Nemesis mesh file.\n[0] ../src/mesh/exodusII_io_helper.C, line 2299, compiled May 15 2023 at 22:49:10\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n\nIs there a workaround for this?  Or is it some other problem?\nThis is how I import the mesh from the previous model phases.  It used to work before I did the recent MOOSE update.\n\n[Mesh]\ntype = FileMesh\nfile = Ph1Imp_out.e\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24744#discussioncomment-6242366",
                          "updatedAt": "2023-06-21T14:11:00Z",
                          "publishedAt": "2023-06-21T14:01:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nNo that part has not changed.\nIt seems the error is coming from the \"creation\" of a new output exodus file.\nCan you try silencing the Outputs to exodus for now?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24744#discussioncomment-6242840",
                          "updatedAt": "2023-06-21T14:45:23Z",
                          "publishedAt": "2023-06-21T14:45:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Ah - looking at that has fixed it.  Because of some updates to my code I was trying to output to an Exodus file with the same name as I was importing from.  Now I've fixed that - it's working!\nCompletely my error!\nMany thanks for this and the fix to original query.",
                          "url": "https://github.com/idaholab/moose/discussions/24744#discussioncomment-6242891",
                          "updatedAt": "2023-06-21T14:50:28Z",
                          "publishedAt": "2023-06-21T14:50:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Query related to heat conduction time derivative",
          "author": {
            "login": "deepakbiitk"
          },
          "bodyText": "Hi all,\nI am solving a transient heat equation, looking through the warning of HeatConductionTimeDerivative (https://mooseframework.inl.gov/source/kernels/HeatConductionTimeDerivative.html). Do it mean it creates a lumped matrix?\nThanks,\nDeepak",
          "url": "https://github.com/idaholab/moose/discussions/24746",
          "updatedAt": "2023-06-20T23:16:48Z",
          "publishedAt": "2023-06-20T18:14:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "The warning is because this kernel is missing off-diagonal terms for the Jacobian",
                  "url": "https://github.com/idaholab/moose/discussions/24746#discussioncomment-6235802",
                  "updatedAt": "2023-06-20T22:46:19Z",
                  "publishedAt": "2023-06-20T22:46:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "add a tangential force BC",
          "author": {
            "login": "lyyc199586"
          },
          "bodyText": "so I have a inclined boundary and I want to enforce both normal and tangential force on that boundary, there is Pressure to enforece normal one, but the tangential need some extra work.\n\nI would expect I just need to modifiy some code in Pressure BC",
          "url": "https://github.com/idaholab/moose/discussions/24726",
          "updatedAt": "2023-06-20T20:40:21Z",
          "publishedAt": "2023-06-18T12:47:09Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lyyc199586"
                  },
                  "bodyText": "@GiudGiud",
                  "url": "https://github.com/idaholab/moose/discussions/24726#discussioncomment-6209322",
                  "updatedAt": "2023-06-18T12:47:32Z",
                  "publishedAt": "2023-06-18T12:47:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@hugary1995  do you want to add to what you explained here to another OP on a related topic\n#23377 (comment)\nI dont know if there's been additional developments on this over the last 4 months",
                          "url": "https://github.com/idaholab/moose/discussions/24726#discussioncomment-6210360",
                          "updatedAt": "2023-06-18T15:19:22Z",
                          "publishedAt": "2023-06-18T15:19:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Can you be more specific about what issue you are running into while implementing this BC? If you are just requesting a new feature, please open an issue.",
                          "url": "https://github.com/idaholab/moose/discussions/24726#discussioncomment-6212856",
                          "updatedAt": "2023-06-18T22:30:51Z",
                          "publishedAt": "2023-06-18T22:30:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lyyc199586"
                  },
                  "bodyText": "I opend an issue about it #24743",
                  "url": "https://github.com/idaholab/moose/discussions/24726#discussioncomment-6235043",
                  "updatedAt": "2023-06-20T20:40:22Z",
                  "publishedAt": "2023-06-20T20:40:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Operand Error in Custom BC computeQpResidual",
          "author": {
            "login": "smpeyres"
          },
          "bodyText": "I am trying to write a custom boundary condition for Zapdos that allows a user-prescribed flux in SI or similar units and is acceptable with the log-molar format used by the application.\nFrom my work trying to move from strong to weak form, here's what I came up with mathematically (may not show up well in light mode):\n\nI tried to implement this in a .C and .h file, respectively. However, when I try to compile, it doesn't seem to like my usuage of the - sign between the diffusion term and the flux term:\n/home/smpeyres_linux/projects/sean-zapdos/src/bcs/LogDiffusionFluxBC.C: In member function 'virtual ADReal LogDiffusionFluxBC::computeQpResidual()':\n/home/smpeyres_linux/projects/sean-zapdos/src/bcs/LogDiffusionFluxBC.C:47:50: error: no match for 'operator-' (operand types are 'libMesh::CompareTypes<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>'} and 'libMesh::boostcopy::enable_if_c<true, libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> > >::type' {aka 'libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >'})\n\n   47 |          6.022e23 * _normals[_qp] * _grad_u[_qp] - _normals[_qp] * _value;\n      |                                         `\n\nI attached the .C, .h, and full error message in single zipped file.\nOperandError_BC_Zapdos.zip\nAny advice or suggestions? Thank you!\nTagging the Zapdos experts: @cticenhour and @lindsayad",
          "url": "https://github.com/idaholab/moose/discussions/24576",
          "updatedAt": "2023-06-20T04:22:44Z",
          "publishedAt": "2023-06-02T13:18:49Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nfor 'operator-' (\n\noperand types are 'libMesh::CompareTypes<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>'} and \n\n'libMesh::boostcopy::enable_if_c<true, libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> > >::type' {aka 'libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >'})\n\nThis means you are trying to substract a scalar (first one) from a vector\n_normals[_qp] * _grad_u[_qp] is a scalar because of the dot product\n_normals[_qp] * _value is a vector as the product of a vector times a scalar\nwhat are you really trying to compute?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6072039",
                  "updatedAt": "2023-06-02T13:35:26Z",
                  "publishedAt": "2023-06-02T13:32:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Since Gamma is a vector it seems like what you want is for _value to be a vector",
                  "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6092125",
                  "updatedAt": "2023-06-05T15:55:36Z",
                  "publishedAt": "2023-06-05T15:55:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "smpeyres"
                          },
                          "bodyText": "That's what I am thinking too. From the MOOSE framework I see \"ADVectorFunctionDirichletBC\" and \"ADVectorFunctionNeumannBC\". Should I try implementing something like this, and have a \"flux\" function prescribed later in the input file? Or is there something potentially simpler?",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6154782",
                          "updatedAt": "2023-06-12T16:58:13Z",
                          "publishedAt": "2023-06-12T16:58:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Can you just directly use ADVectorFunctionNeumannBC?",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6155427",
                          "updatedAt": "2023-06-12T18:12:58Z",
                          "publishedAt": "2023-06-12T18:12:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpeyres"
                          },
                          "bodyText": "I would, but I am not confident that it would be compatible with the log densities, which have both the scalar value and gradient of the density in the weak form...",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6155876",
                          "updatedAt": "2023-06-12T19:05:23Z",
                          "publishedAt": "2023-06-12T19:05:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "then it sounds like you should write your own object",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6156003",
                          "updatedAt": "2023-06-12T19:22:20Z",
                          "publishedAt": "2023-06-12T19:22:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpeyres"
                          },
                          "bodyText": "Should I write it with  \"ADVectorFunctionDirichletBC\" and \"ADVectorFunctionNeumannBC\" as templates, or is there another BC in some module that would be more fitting?",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6156225",
                          "updatedAt": "2023-06-12T19:54:37Z",
                          "publishedAt": "2023-06-12T19:54:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Seems like Neumann is a pretty good fit as you want to prescribe a flux",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6156358",
                          "updatedAt": "2023-06-12T20:12:27Z",
                          "publishedAt": "2023-06-12T20:12:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "smpeyres"
                          },
                          "bodyText": "Error2_LogDiffusionFluxBC.zip\nI attempted to follow what the Neumann BC was doing, but I got two(?) errors. The first one, regarding '{' might be a consequence of the other error; I don't see anything immediately wrong with my brackets. The other error is again pointing to my computeQpResidual, and doesn't seem to like my exponential function. Any advice? Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6164102",
                          "updatedAt": "2023-06-13T14:02:42Z",
                          "publishedAt": "2023-06-13T14:02:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "has a quick look:\n    _function_z(getFunction(\"function_z\")),\n{ \n\nneeds to become\n    _function_z(getFunction(\"function_z\"))\n{",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6164278",
                          "updatedAt": "2023-06-13T14:20:30Z",
                          "publishedAt": "2023-06-13T14:20:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m not so sure about your computeQpResidual either, shouldnt the function be multiplied by the test function?",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6164302",
                          "updatedAt": "2023-06-13T14:23:08Z",
                          "publishedAt": "2023-06-13T14:23:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Yea your second term is a vector and needs to wind up being a scalar, e.g. just as @GiudGiud suggested you need to multiply by the test function.\nI am a little concerned about the boundary condition you're imposing. When integrating by parts and looking at the result, it seems like you are imposing for your boundary condition:\nflux = some-implicit-diffusive-flux + user-provided-flux",
                          "url": "https://github.com/idaholab/moose/discussions/24576#discussioncomment-6165280",
                          "updatedAt": "2023-06-13T15:49:09Z",
                          "publishedAt": "2023-06-13T15:49:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stress interpolation",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "What methods are available in MOOSE to interpolate stress (or any qp quantity) over the element? Interested in on-the-fly evaluation and saving to the mesh file for postprocessing.",
          "url": "https://github.com/idaholab/moose/discussions/24713",
          "updatedAt": "2023-06-24T19:48:22Z",
          "publishedAt": "2023-06-15T22:49:43Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@jessecarterMOOSE  you could use postprocessors such as the ElementAverageValue, that can average the stress over qp\nsee example here:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/test/tests/CPDamage/damage_growth.i\npostprocessors are evaluated on the fly and can be used to change, for example, the behavior of a material.",
                  "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6209707",
                  "updatedAt": "2023-06-18T13:17:37Z",
                  "publishedAt": "2023-06-18T13:17:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Need to keep a little more fidelity than that.",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6211696",
                          "updatedAt": "2023-06-18T18:48:36Z",
                          "publishedAt": "2023-06-18T18:48:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "by interpret, are you ok with just outputting?\nYou can output element averages with the https://mooseframework.inl.gov/docs//site/source/auxkernels/MaterialRealAux.html\nif you select a different FE family (still elemental) or order, you can get a closer projection",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6211741",
                          "updatedAt": "2023-06-18T18:56:32Z",
                          "publishedAt": "2023-06-18T18:56:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "Guess that should have said \"interpolate\" across the element. Monomials are only approximate, right? Is it least squares fitting? Can the nonlinear variable shape functions be used somehow?\nThen what happens when these discontinuous elemental variables get written to the Exodus file? Is there a different mesh format that will save the raw qp values?\nJust outputting for each element would be useful too for debugging (something like an Abaqus report file)",
                  "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6212171",
                  "updatedAt": "2023-06-18T20:13:34Z",
                  "publishedAt": "2023-06-18T20:13:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm not sure it will let you but if you use the MaterialXXXAux with a different shape function it will do a projection in the backend which amounts to least square fitting. You can look in AuxKernel.C at AuxKernelTempl<ComputeValueType>::compute() to see what it does.\nIt calculates the value of the auxkernel at each qp then tries to fit the auxvariable to those values.\nIt wont save Qp values.\nI dont think we ever save Qp values. We save DOF values.\nIf you want Qp values your best bet is to modify this VPP to do Qps instead of elements, and for tensor material properties instead of Real ones\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/MaterialVectorPostprocessor.html",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6212714",
                          "updatedAt": "2023-06-18T21:59:14Z",
                          "publishedAt": "2023-06-18T21:59:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "How does it reconcile the different nodal values computed by neighboring elements?",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6224177",
                          "updatedAt": "2023-06-19T23:12:56Z",
                          "publishedAt": "2023-06-19T23:12:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "We have this nodal patch recovery system for this exact purpose. It \"interpolates\" over the element (more precisely over a patch of neighboring elements). I am again responsible for the lack of documentation on this :/",
                  "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6212875",
                  "updatedAt": "2023-06-18T22:34:19Z",
                  "publishedAt": "2023-06-18T22:34:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "@hugary1995 this? https://mooseframework.inl.gov/help/finite_element_concepts/nodal_patch_recovery.html",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6213008",
                          "updatedAt": "2023-06-18T23:10:03Z",
                          "publishedAt": "2023-06-18T23:10:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "That's the theory, yes. The new system consists of two types of objects:\n\nNodalPatchRecoveryBase derived userobjects, e.g., NodalPatchRecoveryMaterialProperty, which construct the patch for least squares fitting.\nA \"driver\" object that actually solves the least squares problem and performs the interpolation. See for example NodalPatchRecoveryAux. More specifically, the interpolation happens on this line: https://github.com/idaholab/moose/blob/next/modules/tensor_mechanics/src/auxkernels/NodalPatchRecoveryAux.C#L57, note that *_current_node can be replaced with any point inside the patch (the current element and its point neighbors) to interpolate the property.",
                          "url": "https://github.com/idaholab/moose/discussions/24713#discussioncomment-6213083",
                          "updatedAt": "2023-06-18T23:26:45Z",
                          "publishedAt": "2023-06-18T23:26:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Radiation and Convection Losses",
          "author": {
            "login": "nourriahi"
          },
          "bodyText": "Hello everyone,\nI am trying to model heat conduction using a laser source at the top, as far this is working, I wanted to include convection and radiation losses on the top to account for laser energy losses. I was wondering if moose has developed something to take this into account since I did not find anything so far?\nThanks\nNour",
          "url": "https://github.com/idaholab/moose/discussions/24729",
          "updatedAt": "2023-06-24T19:47:22Z",
          "publishedAt": "2023-06-19T14:29:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can look at adding terms to the boundary condition on top. See\nhttps://mooseframework.inl.gov/source/bcs/ADRadiativeHeatFluxBC.html\nhttps://mooseframework.inl.gov/source/bcs/ADConvectiveHeatFluxBC.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24729#discussioncomment-6220993",
                  "updatedAt": "2023-06-19T15:38:20Z",
                  "publishedAt": "2023-06-19T15:38:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}