{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0xMC0xMFQyMDo1MzoxNy0wNTowMM4AV1Q8"
    },
    "edges": [
      {
        "node": {
          "title": "Resources for Learning FEA in Solid Mechanics",
          "author": {
            "login": "sd-brady"
          },
          "bodyText": "Maybe this isn't the right location for this discussion. If it is not, let me know and I can take it down (or you're welcome to delete it).\nI'd really like to learn more about the nuts and bolts of the mathematical theory behind solid mechanics FEA simulations. I've really been trying hard to read about FEA and plasticity, but it doesn't seem to be \"clicking\" for me yet. I have a good intuition for what is going on in the background but I don't have a great understanding for the actual system of equations and solution sequence that are being solved.\nI have a copy of the \"Introduction to Computational Plasticity\" book that is often referenced here. It does seem like a good book that I'm able to mostly follow, but I just wish there were some more examples and problems to work through. I also have a hard time following complex mathematical proofs without good examples and problems to work through to put it together.\nTo the seasoned moose solid mechanics experts: Is there a certain reference/references, detailed example problem, or university class/classes that helped bridge the gap for you?\nI'm just rambling at this point, but I think a good book idea would be describing in extreme detail one \"cycle\" of a simple 3D solid mechanics FEA problem. It could cover in detail something like a simple 3x3x3 3D mesh with some some simple boundary conditions. It could be broken up similar to how moose presents the Plug-n-Play system (i.e., 1) Compute Strain, 2) Compute the Elasticity Tensor, 3) Compute Stress... etc). The theory could be taught, but also, we could be working towards solving the one simple example problem throughout the book.\nTLDR - I want to understand but don't currently. I'd like to know the best references that helped you see the light.",
          "url": "https://github.com/idaholab/moose/discussions/25725",
          "updatedAt": "2023-10-16T14:36:29Z",
          "publishedAt": "2023-10-12T00:48:35Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Homogenization issue",
          "author": {
            "login": "eduardogrodriguez89"
          },
          "bodyText": "Dear Moose developers,\nI try to understand how the module homogenization works.\nI want to determine the effective properties of two materials, a matrix with fiber.  I tried to replicate this work,\nhttps://drive.google.com/file/d/1w7vnpsZXTdmfo1Rz-jmWnH9NQ06U72n_/view?usp=sharing but the results are different.\nI would like to know what is wrong with the code. If the BCs are correct?\ncode.zip\nthanks",
          "url": "https://github.com/idaholab/moose/discussions/25408",
          "updatedAt": "2023-10-12T02:10:34Z",
          "publishedAt": "2023-09-06T14:37:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Hi, thank you for your post. In order to more easily help, it would be better if you posted your code on github instead of on Google drive or attaching as a zip file",
                  "url": "https://github.com/idaholab/moose/discussions/25408#discussioncomment-6927270",
                  "updatedAt": "2023-09-06T15:23:08Z",
                  "publishedAt": "2023-09-06T15:23:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "eduardogrodriguez89"
                          },
                          "bodyText": "2020_Development of a \ufb01nite element based strain periodicity implementation method.zip\ncsv_file = 'cell_average_values_4'\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n  large_kinematics = false\n  macro_gradient = hvar\n  homogenization_constraint = homogenization\n[]\n\n[Mesh]\n  [base]\n    type = FileMeshGenerator\n    file = 'circle047.msh'\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [hvar]\n    family = SCALAR\n    order = FIRST\n  []\n[]\n\n[AuxVariables]\n  [sxx]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [syy]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [sxy]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [exx]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [eyy]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [exy]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n[]\n\n[AuxKernels]\n  [sxx]\n    type = RankTwoAux\n    variable = sxx\n    rank_two_tensor = pk1_stress\n    index_i = 0\n    index_j = 0\n  []\n  [syy]\n    type = RankTwoAux\n    variable = syy\n    rank_two_tensor = pk1_stress\n    index_i = 1\n    index_j = 1\n  []\n  [sxy]\n    type = RankTwoAux\n    variable = sxy\n    rank_two_tensor = pk1_stress\n    index_i = 0\n    index_j = 1\n  []\n  [exx]\n    type = RankTwoAux\n    variable = exx\n    rank_two_tensor = mechanical_strain\n    index_i = 0\n    index_j = 0\n  []\n  [eyy]\n    type = RankTwoAux\n    variable = eyy\n    rank_two_tensor = mechanical_strain\n    index_i = 1\n    index_j = 1\n  []\n  [exy]\n    type = RankTwoAux\n    variable = exy\n    rank_two_tensor = mechanical_strain\n    index_i = 0\n    index_j = 1\n  []\n[]\n\n[UserObjects]\n  [homogenization]\n    type = HomogenizationConstraint\n    constraint_types = 'stress none none none none none none none none'\n    targets = 'stress11 zero zero zero zero zero'\n    execute_on = 'INITIAL LINEAR NONLINEAR'\n  []\n[]\n\n[Kernels]\n  [sdx]\n    type = HomogenizedTotalLagrangianStressDivergence\n    variable = disp_x\n    component = 0\n  []\n  [sdy]\n    type = HomogenizedTotalLagrangianStressDivergence\n    variable = disp_y\n    component = 1\n  []\n[]\n\n[ScalarKernels]\n  [enforce]\n    type = HomogenizationConstraintScalarKernel\n    variable = hvar\n  []\n[]\n\n[Functions]\n  [strain11]\n    type = ParsedFunction\n    expression = '1.0e-6*t'\n  []\n  [strain22]\n    type = ParsedFunction\n    expression = '-2.0e-2*t'\n  []\n  [strain12]\n    type = ParsedFunction\n    expression = '1.0e-3*t'\n  []\n  [stress11]\n    type = ParsedFunction\n    expression = '1e7*t'\n  []\n  [stress22]\n    type = ParsedFunction\n    expression = '-200*t'\n  []\n  [stress12]\n    type = ParsedFunction\n    expression = '100*t'\n  []\n[]\n\n[BCs]\n  [Periodic]\n    [x]\n      variable = disp_x\n      auto_direction = 'x y'\n    []\n    [y]\n      variable = disp_y\n      auto_direction = 'x y'\n    []\n  []\n  [fiy1_y]\n    type = DirichletBC\n    boundary = Left\n    variable = disp_x\n    value = 0\n  []\n  # [fix1_x]\n  #   type = DirichletBC\n  #   boundary = Left\n  #   variable = disp_y\n  #   value = 0\n  # []\n  [fix1_y]\n    type = DirichletBC\n    boundary = Button\n    variable = disp_y\n    value = 0\n  []\n\n  # [fix2_y]\n  #   type = DirichletBC\n  #   boundary = Top\n  #   variable = disp_y\n  #   value = 0\n  # []\n[]\n\n\nE1 = '68.3e9' #aluminium\nnu1 = '0.3'\nE2 = '379.3e9' #Boron\nnu2 = '0.1'\n\n[Materials]\n  [elastic_tensor_1]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = ${E1}\n    poissons_ratio = ${nu1}\n    block = 'Rectangulo'\n  []\n  [elastic_tensor_2]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = ${E2}\n    poissons_ratio = ${nu2}\n    block = 'Circulo_1'\n  []\n  [compute_stress]\n    type = ComputeLagrangianLinearElasticStress\n  []\n  [compute_strain]\n    type = ComputeLagrangianStrain\n    homogenization_gradient_names = 'homogenization_gradient'\n  []\n  [compute_homogenization_gradient]\n    type = ComputeHomogenizedLagrangianStrain\n  []\n[]\n\n[Postprocessors]\n  [sxx]\n    type = ElementAverageValue\n    variable = sxx\n    execute_on = 'initial timestep_end'\n  []\n  [syy]\n    type = ElementAverageValue\n    variable = syy\n    execute_on = 'initial timestep_end'\n  []\n  [sxy]\n    type = ElementAverageValue\n    variable = sxy\n    execute_on = 'initial timestep_end'\n  []\n  [exx]\n    type = ElementAverageValue\n    variable = exx\n    execute_on = 'initial timestep_end'\n  []\n  [eyy]\n    type = ElementAverageValue\n    variable = eyy\n    execute_on = 'initial timestep_end'\n  []\n  [exy]\n    type = ElementAverageValue\n    variable = exy\n    execute_on = 'initial timestep_end'\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = 'newton'\n  line_search = none\n\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  l_max_its = 2\n  l_tol = 1e-14\n  nl_max_its = 30\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-10\n\n  start_time = 0.0\n  dt = 0.1\n  dtmin = 0.1\n  end_time = 0.5\n  \n[]\n\n[Outputs]\n  [mesh]\n    type = Exodus\n    file_base = ${csv_file}\n  []\n  [average_variable_values]\n    type = CSV\n    execute_on = 'TIMESTEP_END'\n    file_base = ${csv_file}\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/25408#discussioncomment-6930006",
                          "updatedAt": "2023-09-06T20:17:31Z",
                          "publishedAt": "2023-09-06T20:16:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "@reverendbedford developed this homogenization implementation. We have a separate system that you can find by searching for global strain in our docs.",
                  "url": "https://github.com/idaholab/moose/discussions/25408#discussioncomment-6993309",
                  "updatedAt": "2023-09-13T17:41:43Z",
                  "publishedAt": "2023-09-13T17:41:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "reverendbedford"
                  },
                  "bodyText": "Can you post the result you were comparing against? What result were you expecting and what did you get?",
                  "url": "https://github.com/idaholab/moose/discussions/25408#discussioncomment-6993464",
                  "updatedAt": "2023-09-13T18:00:16Z",
                  "publishedAt": "2023-09-13T18:00:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "eduardogrodriguez89"
                          },
                          "bodyText": "In the figure I show the experiment I want to perform. I want to determine the effective properties C_{11}. To do this I restrict the movements as shown in the script.\nMy question is if the constrains are okay? That is, if I want to determine C_{11}, should I only activate the first constraint? and in targets also the first one?",
                          "url": "https://github.com/idaholab/moose/discussions/25408#discussioncomment-7037942",
                          "updatedAt": "2023-09-18T18:06:52Z",
                          "publishedAt": "2023-09-18T18:06:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "reverendbedford"
                          },
                          "bodyText": "Sorry for the delay, busy week.\nIt's tough to tell without the mesh file that you are using, but my guess is that you are over constraining the displacements.  It looks like you are fixing the displacements along the entirety of the \"left\" and \"bottom\" surfaces.  That's too much constraint, it will prevent the microscale from being anything but affine, which isn't what you want.\nInstead pick two nodes in the interior of the domain.  Fix both x and y to zero for the first and fix just y for the second (see crude picture).  Then try running again.",
                          "url": "https://github.com/idaholab/moose/discussions/25408#discussioncomment-7085293",
                          "updatedAt": "2023-09-22T19:57:05Z",
                          "publishedAt": "2023-09-22T19:57:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "eduardogrodriguez89"
                  },
                  "bodyText": "Sorry for the delay.\nI tried again with your suggestion, fixing points 1 and 2, but I'm not getting the result in Table 3.\nI have doubts about:\na) Constrains_types and targets.\nIf I want to obtain de C_11, Should I fix the stress/strain constraint_type in x, and target only in x?\nPoint_1= Fix in \"x\" and \"y\" direction.\nPoint_2= fix in \"y\" direction.\nb) To obtain the value of C_11, I should divide de sxx/exx, obtained from ElementAverageValue?\nC_11= sxx/exx ??? It ok??\nI get these results\nTime Step 5, time = 0.5, dt = 0.1\n 0 Nonlinear |R| = 1.000000e+08\n      0 Linear |R| = 1.000000e+08\n      1 Linear |R| = 2.789850e-07\n 1 Nonlinear |R| = 3.497639e-05\n Solve Converged!\n\nPostprocessor Values:\n+----------------        +----------------      +----------------            +----------------           +----------------         +----------------         +----------------+\n| time                   | exx                   | exy                       | eyy                         | sxx                      | sxy                      | syy            |\n+----------------        +----------------       +----------------           +----------------           +----------------         +----------------         +----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-01 |   6.206073e-04 |   6.358997e-07 |  -2.645817e-18 |   1.000000e+08 |   6.510927e+04 |   2.871875e+07 |\n|   2.000000e-01 |   1.241215e-03 |   1.271799e-06 |   2.462338e-18 |   2.000000e+08 |   1.302185e+05 |   5.743750e+07 |\n|   3.000000e-01 |   1.861822e-03 |   1.907699e-06 |  -7.450714e-19 |   3.000000e+08 |   1.953278e+05 |   8.615625e+07 |\n|   4.000000e-01 |   2.482429e-03 |   2.543599e-06 |  -6.918406e-19 |   4.000000e+08 |   2.604371e+05 |   1.148750e+08 |\n|   5.000000e-01 |   3.103036e-03 |   3.179499e-06 |   6.418657e-19 |   5.000000e+08 |   3.255463e+05 |   1.435938e+08 |\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n\n\nScalar Variable Values:\n+----------------+----------------+\n| time           | hvar           |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-01 |   6.218791e-04 |\n|   2.000000e-01 |   1.243758e-03 |\n|   3.000000e-01 |   1.865637e-03 |\n|   4.000000e-01 |   2.487516e-03 |\n|   5.000000e-01 |   3.109395e-03 |\n+----------------+----------------+\n\nHere is the  code:\ncode.zip\ncsv_file = 'cell_average_values'\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n  large_kinematics = false\n  macro_gradient = hvar\n  homogenization_constraint = homogenization\n[]\n\n[Mesh]\n  [base]\n    type = FileMeshGenerator\n    file = 'RVE_047.msh'\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [hvar]\n    family = SCALAR\n    order = FIRST\n  []\n[]\n\n[AuxVariables]\n  [sxx]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [syy]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [sxy]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [exx]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [eyy]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [exy]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n[]\n\n[AuxKernels]\n  [sxx]\n    type = RankTwoAux\n    variable = sxx\n    rank_two_tensor = pk1_stress\n    index_i = 0\n    index_j = 0\n  []\n  [syy]\n    type = RankTwoAux\n    variable = syy\n    rank_two_tensor = pk1_stress\n    index_i = 1\n    index_j = 1\n  []\n  [sxy]\n    type = RankTwoAux\n    variable = sxy\n    rank_two_tensor = pk1_stress\n    index_i = 0\n    index_j = 1\n  []\n  [exx]\n    type = RankTwoAux\n    variable = exx\n    rank_two_tensor = mechanical_strain\n    index_i = 0\n    index_j = 0\n  []\n  [eyy]\n    type = RankTwoAux\n    variable = eyy\n    rank_two_tensor = mechanical_strain\n    index_i = 1\n    index_j = 1\n  []\n  [exy]\n    type = RankTwoAux\n    variable = exy\n    rank_two_tensor = mechanical_strain\n    index_i = 0\n    index_j = 1\n  []\n[]\n\n[UserObjects]\n  [homogenization]\n    type = HomogenizationConstraint\n  #constraint_types = '    x    xy      0    xy    y     0   0    0    0'\n    #constraint_types = 'stress none none none none none none none none'\n    constraint_types = 'stress none none none none none none none none'\n    targets = 'stress11 0 0'\n    execute_on = 'INITIAL LINEAR NONLINEAR'\n  []\n[]\n\n[Kernels]\n  [sdx]\n    type = HomogenizedTotalLagrangianStressDivergence\n    variable = disp_x\n    component = 0\n  []\n  [sdy]\n    type = HomogenizedTotalLagrangianStressDivergence\n    variable = disp_y\n    component = 1\n  []\n[]\n\n[ScalarKernels]\n  [enforce]\n    type = HomogenizationConstraintScalarKernel\n    variable = hvar\n  []\n[]\n\n[Functions]\n  [strain11]\n    type = ParsedFunction\n    expression = '6.0e-2*t'\n  []\n  [stress11]\n    type = ParsedFunction\n    expression = '1e9*t'\n  []\n[]\n\n[BCs]\n  [Periodic]\n    [x]\n      variable = disp_x\n      auto_direction = 'x y'\n    []\n    [y]\n      variable = disp_y\n      auto_direction = 'x y'\n    []\n  []\n   [fix1_x]\n     type = DirichletBC\n     boundary = 1\n     variable = disp_x\n     value = 0\n   []\n   [fix1_y]\n     type = DirichletBC\n     boundary = 1\n     variable = disp_y\n     value = 0\n   []\n  [fix2_y]\n    type = DirichletBC\n    boundary = 2\n    variable = disp_y\n    value = 0\n  []\n[]\n\nE1 = '68.3e9' #Aluminum\nnu1 = '0.3'\nE2 = '379.3e9' #Boron\nnu2 = '0.1'\n\n[Materials]\n  [elastic_tensor_1]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = ${E1}\n    poissons_ratio = ${nu1}\n    block = 'Rectangulo'\n  []\n  [elastic_tensor_2]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = ${E2}\n    poissons_ratio = ${nu2}\n    block = 'Circulo'\n  []\n\n  [compute_stress]\n    type = ComputeLagrangianLinearElasticStress\n  []\n  [compute_strain]\n    type = ComputeLagrangianStrain\n    homogenization_gradient_names = 'homogenization_gradient'\n  []\n  [compute_homogenization_gradient]\n    type = ComputeHomogenizedLagrangianStrain\n  []\n[]\n\n[Postprocessors]\n  [sxx]\n    type = ElementAverageValue\n    variable = sxx\n    execute_on = 'initial timestep_end'\n  []\n  [syy]\n    type = ElementAverageValue\n    variable = syy\n    execute_on = 'initial timestep_end'\n  []\n  [sxy]\n    type = ElementAverageValue\n    variable = sxy\n    execute_on = 'initial timestep_end'\n  []\n  [exx]\n    type = ElementAverageValue\n    variable = exx\n    execute_on = 'initial timestep_end'\n  []\n  [eyy]\n    type = ElementAverageValue\n    variable = eyy\n    execute_on = 'initial timestep_end'\n  []\n  [exy]\n    type = ElementAverageValue\n    variable = exy\n    execute_on = 'initial timestep_end'\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = 'newton'\n  line_search = none\n\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  l_max_its = 2\n  l_tol = 1e-14\n  nl_max_its = 30\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-10\n\n  start_time = 0.0\n  dt = 0.1\n  dtmin = 0.1\n  end_time = 0.5\n  \n  # [TimeIntegrator]\n  #   type = BDF2\n  # []\n[]\n\n[Outputs]\n  [mesh]\n    type = Exodus\n    file_base = ${csv_file}\n  []\n  [average_variable_values]\n    type = CSV\n    execute_on = 'TIMESTEP_END'\n    file_base = ${csv_file}\n  []\n[]\n``\n\nThe mesh is the same as before.",
                  "url": "https://github.com/idaholab/moose/discussions/25408#discussioncomment-7229935",
                  "updatedAt": "2023-10-09T13:13:17Z",
                  "publishedAt": "2023-10-09T12:23:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "eduardogrodriguez89"
                  },
                  "bodyText": "If I calculate C in the x direction, I get:\nCxx = 5.000000e+08/3.103036e-03 = 161.13 MPa This value is different according to values in table 3, C22=C33=124.3 MPa.",
                  "url": "https://github.com/idaholab/moose/discussions/25408#discussioncomment-7230068",
                  "updatedAt": "2023-10-09T12:37:37Z",
                  "publishedAt": "2023-10-09T12:37:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "reverendbedford"
                          },
                          "bodyText": "Take a look at this input:\ncsv_file = 'cell_average_values'\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Mesh]\n  [base]\n    type = FileMeshGenerator\n    file = 'RVE_047.msh'\n  []\n[]\n\n\n[Modules]\n  [TensorMechanics]\n    [Master]\n      [all]\n        strain = SMALL\n        add_variables = true\n        new_system = true\n        formulation = TOTAL\n        volumetric_locking_correction = false\n        constraint_types = 'strain none none strain strain none none none none'\n        targets = 'strain11 zero zero'\n        generate_output = 'pk1_stress_xx pk1_stress_xy pk1_stress_xz pk1_stress_yx pk1_stress_yy '\n                          'pk1_stress_yz pk1_stress_zx pk1_stress_zy pk1_stress_zz '\n                          'mechanical_strain_xx mechanical_strain_xy mechanical_strain_xz '\n                          'mechanical_strain_yx mechanical_strain_yy mechanical_strain_yz '\n                          'mechanical_strain_zx mechanical_strain_zy mechanical_strain_zz'\n      []\n    []\n  []\n[]\n\n\n\n[Functions]\n  [strain11]\n    type = ConstantFunction\n    value = 1.0\n  []\n  [zero]\n    type = ConstantFunction\n    value = 0.0\n  []\n[]\n\n[BCs]\n  [Periodic]\n    [x]\n      variable = disp_x\n      auto_direction = 'x y'\n    []\n    [y]\n      variable = disp_y\n      auto_direction = 'x y'\n    []\n  []\n   [fix1_x]\n     type = DirichletBC\n     boundary = 1\n     variable = disp_x\n     value = 0\n   []\n   [fix1_y]\n     type = DirichletBC\n     boundary = 1\n     variable = disp_y\n     value = 0\n   []\n  [fix2_y]\n    type = DirichletBC\n    boundary = 2\n    variable = disp_y\n    value = 0\n  []\n[]\n\nE1 = '68.3e3' #Aluminum\nnu1 = '0.3'\nE2 = '379.3e3' #Boron\nnu2 = '0.1'\n\n[Materials]\n  [elastic_tensor_1]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = ${E1}\n    poissons_ratio = ${nu1}\n    block = 'Rectangulo'\n  []\n  [elastic_tensor_2]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = ${E2}\n    poissons_ratio = ${nu2}\n    block = 'Circulo'\n  []\n\n  [compute_stress]\n    type = ComputeLagrangianLinearElasticStress\n  []\n[]\n\n[Postprocessors]\n  [sxx]\n    type = ElementAverageValue\n    variable = pk1_stress_xx\n  []\n  [syy]\n    type = ElementAverageValue\n    variable = pk1_stress_yy\n  []\n  [sxy]\n    type = ElementAverageValue\n    variable = pk1_stress_xy\n  []\n  [szz]\n    type = ElementAverageValue\n    variable = pk1_stress_zz\n  []\n  [exx]\n    type = ElementAverageValue\n    variable = mechanical_strain_xx\n  []\n  [eyy]\n    type = ElementAverageValue\n    variable = mechanical_strain_yy\n  []\n  [exy]\n    type = ElementAverageValue\n    variable = mechanical_strain_xy\n  []\n  [ezz]\n    type = ElementAverageValue\n    variable = mechanical_strain_zz\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Steady\n\n  solve_type = 'newton'\n  line_search = none\n\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  l_max_its = 2\n  l_tol = 1e-14\n  nl_max_its = 30\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-10\n[]\n\n[Outputs]\n  [mesh]\n    type = Exodus\n    file_base = ${csv_file}\n  []\n  [average_variable_values]\n    type = CSV\n    execute_on = 'TIMESTEP_END'\n    file_base = ${csv_file}\n  []\n[]\n\nThere are a few cosmetic changes:\n\nI'm using the action system, which for me is way easier to set things up.\nI'm doing a steady solve as this seems to be linear elastic.\nI'm using a target macroscale strain of 1 to make the division easier\nI changed your units to (presumably) GPa for stress.  I was getting weird convergence issues with our default tolerances for your units, which were probably Pa for stress.  You could fiddle with the tolerances if you like the original units.\n\nThere are two important changes:\n\nFor a 2D small-strain problem you always need to have three constraints and a third order homogenization scalar variable (i.e. three scalar constraints).  That's because in 2D for small strains you have three independent strain components.  We should probably improve the error messages, but at least the action system here won't let you run with the single scalar constraint as you had before.\nTo calculate rows of the stiffness matrix you should apply a single unit strain in one \"generalized direction\" (xx, yy, yz) and zero strain in the other two directions.  The homogenized stresses are then going to be that row of the stiffness matrix directly.  So this example here gives you C11, C12, and C13 from the values of s_xx, s_yy, and s_xy.  You can change the unit strain to the other two directions to read off the rest of the rows of the stiffness tensor.\n\nOne thing to keep in mind is that this is a plane strain problem as you have it setup.  Hopefully that's what you want.",
                          "url": "https://github.com/idaholab/moose/discussions/25408#discussioncomment-7258513",
                          "updatedAt": "2023-10-12T01:59:29Z",
                          "publishedAt": "2023-10-12T01:58:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "reverendbedford"
                          },
                          "bodyText": "Another problem: it looks like you are fixing a \"bad\" point to remove the rigid body modes.  See this output with the displaced mesh:\n\nIt looks like one of your fixed displacements is that upper left point?  Or something else must be off with the mesh.  Your point to fix to remove the rigid body modes can be arbitrary, but they can't be on the outside of the domain where the periodic constraints are applied.",
                          "url": "https://github.com/idaholab/moose/discussions/25408#discussioncomment-7258572",
                          "updatedAt": "2023-10-12T02:06:38Z",
                          "publishedAt": "2023-10-12T02:06:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "reverendbedford"
                          },
                          "bodyText": "Err, if I look in paraview I don't see any nodes in your \"fix1\" and \"fix2\" nodesets.  You may not be constraining any rigid modes, which would explain the convergence issue and the weird displacements in my previous post.",
                          "url": "https://github.com/idaholab/moose/discussions/25408#discussioncomment-7258593",
                          "updatedAt": "2023-10-12T02:10:35Z",
                          "publishedAt": "2023-10-12T02:10:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Flux boundary condition on displaced mesh",
          "author": {
            "login": "NateAM"
          },
          "bodyText": "I would like to implement a flux boundary condition on the displaced mesh. To do this, I was thinking I would be able to simply inherit from IntegratedBC and then implement the correct off-diagonal Jacobians (I know I could also use AD) but the displacements have not been made available. So that the integration occurs over the deformed geometry, how do I extend IntegratedBC to use the displacements? I know TensorMechanics has their pressure kernel but there seems to be a lot more going on there that (at least to me) confuses the issue.",
          "url": "https://github.com/idaholab/moose/discussions/25724",
          "updatedAt": "2023-10-11T23:41:56Z",
          "publishedAt": "2023-10-11T20:43:53Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Two things come to my mind\n\nweak form integration will occur automatically on the deformed geometry as long as you specify use_displaced_mesh = true in your input file for your integrated boundary condition\nWhen discussing implementing off-diagonal Jacobians are you referring to coding the off-diagonal Jacobians with respect to the displacements themselves? E.g. the dependence on JxW, shape function gradients, etc. on the displacement field?",
                  "url": "https://github.com/idaholab/moose/discussions/25724#discussioncomment-7257561",
                  "updatedAt": "2023-10-11T23:01:09Z",
                  "publishedAt": "2023-10-11T23:01:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "NateAM"
                          },
                          "bodyText": "Hi @lindsayad\n\nIs this true even though IntegratedBC doesn't have _displacements defined? How can we associate the jacobian with a specific displacement dof?\nYes, that's what I mean. I've been successful doing this on the volume integral terms and will need to do that for the surface integral too. I know what I need to implement but without the displacement DOF ids I'm stuck. I guess I could define those degrees of freedom and see if it works.",
                          "url": "https://github.com/idaholab/moose/discussions/25724#discussioncomment-7257653",
                          "updatedAt": "2023-10-11T23:21:55Z",
                          "publishedAt": "2023-10-11T23:21:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Is this true even though IntegratedBC doesn't have _displacements defined?\n\nYes.\n\nHow can we associate the jacobian with a specific displacement dof?\n\nA different question and a good one. You could either modify IntegratedBC to do what KernelBase does or you could also do it in your derived class. Either way you want to give yourself a _displacements member.",
                          "url": "https://github.com/idaholab/moose/discussions/25724#discussioncomment-7257695",
                          "updatedAt": "2023-10-11T23:33:44Z",
                          "publishedAt": "2023-10-11T23:32:44Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "NateAM"
                          },
                          "bodyText": "Okay, great! I'll make those changes.\nI think I'll just do it like KernalBase does in my own class. Thanks for the help!",
                          "url": "https://github.com/idaholab/moose/discussions/25724#discussioncomment-7257738",
                          "updatedAt": "2023-10-11T23:41:55Z",
                          "publishedAt": "2023-10-11T23:41:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MUMPS version",
          "author": {
            "login": "heinono1"
          },
          "bodyText": "Hi. I just pulled a new distribution of MOOSE to re-build from scratch. Because of our IT Security trolls, I could not pull MUMPS_5.6.1 from the graal.ens-lyon.fr site and so the installer looked for MUMPS at the anl.gov sites. It turns out the anl.gov sites are not in synch with the ens-lyon.fr site and only had version 5.6.0. Easy fix to just change the version in the install python script but I thought it could be worth to point this out if others run into trouble and don't know how to fix it.",
          "url": "https://github.com/idaholab/moose/discussions/25720",
          "updatedAt": "2023-10-11T18:03:23Z",
          "publishedAt": "2023-10-11T16:26:33Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "What is strange to me, is that I only run into this issue when attempting to build PETSc with MUMPS options while on an Apple Silicon machine. I can't explain why Linux and Intel Macs are fine \ud83d\ude15",
                  "url": "https://github.com/idaholab/moose/discussions/25720#discussioncomment-7254896",
                  "updatedAt": "2023-10-11T16:35:42Z",
                  "publishedAt": "2023-10-11T16:35:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "heinono1"
                          },
                          "bodyText": "Haha I am installing on Linux clusters and a Linux workstation (Ubuntu 22.04) - and I get the errors.....",
                          "url": "https://github.com/idaholab/moose/discussions/25720#discussioncomment-7255626",
                          "updatedAt": "2023-10-11T18:03:24Z",
                          "publishedAt": "2023-10-11T18:03:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "September 2023 Newsletter",
          "author": {
            "login": "cticenhour"
          },
          "bodyText": "The September 2023 MOOSE Newsletter has been released! A summary of the content is below:\n\nMOOSE Improvements\n\nNearest-point layered side integrals for functors added\nRestart system refactoring\nNew JSON reader\nMesh diagnostics introduced\nNew mesh generation capabilities\nNavier-Stokes module improvements\nStochastic tools module improvements\n\n\nlibMesh-level Changes\n\n2023.09.06 update\n\n\nPETSc-level Changes\n\nPETSc updated to 3.19.3\n\n\nBug Fixes and Minor Enhancements",
          "url": "https://github.com/idaholab/moose/discussions/25721",
          "updatedAt": "2023-10-11T16:50:15Z",
          "publishedAt": "2023-10-11T16:50:15Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Thermal hydraulics: pressure fluctuations at small dt",
          "author": {
            "login": "jvwilliams23"
          },
          "bodyText": "I have noticed some behaviour which I would say is non-physical in the thermal hydraulics module. At first I thought it was my own case configuration, but I have iteratively simplified the case all the way back to the tutorials (recent tutorial committed by @licharlot).\nDifferences from tutorial: I reduced the outlet pressure to atmospheric pressure (1e5 Pa), and changed the fluid properties to water (SimpleFluidProperties). I also changed the initial velocity to 0 m/s.\nWhen dt=10 as in the tutorial, the solve converges to steady state on the first step and the pressure drop is positive (pressure at inlet slightly higher than outlet). But when I set dt=1e-4, the flow is transient and the pressure drop fluctuates between positive and negative, then eventually converges to a steady-state solution with a negative pressure drop.\nMy question is, am I misinterpreting the physics here? Or is there some numerical issue? Note that this also appears when I set reversible=false for the inlet BC. I thought it may be a floating point issue, since the flowrate is quite low, but also when I use a higher massflow rate (m_dot_in = 1.0), I get negative pressure-drop at the start and then it converges to a sensible solution with a positive pressure-drop.\nT_in = 300. # K\nm_dot_in = 1e-2 # kg/s\npress = 1e5 # Pa\n\n[GlobalParams]\n  initial_p = ${press}\n  initial_vel = 0.0\n  initial_T = ${T_in}\n  gravity_vector = '0 0 0'\n\n  rdg_slope_reconstruction = minmod\n  scaling_factor_1phase = '1 1e-2 1e-4'\n  closures = thm_closures\n  fp = water\n[]\n\n[FluidProperties]\n  [water]\n    type=SimpleFluidProperties\n  []\n[]\n\n[Closures]\n  [thm_closures]\n    type = Closures1PhaseTHM\n  []\n[]\n\n[Components]\n  [inlet]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan:in'\n    m_dot = ${m_dot_in}\n    T = ${T_in}\n  []\n\n  [core_chan]\n    type = FlowChannel1Phase\n    position = '0 0 0'\n    orientation = '0 0 1'\n    length = 1\n    n_elems = 25\n    A = 7.2548e-3\n    D_h = 7.0636e-2\n  []\n\n  [outlet]\n    type = Outlet1Phase\n    input = 'core_chan:out'\n    p = ${press}\n  []\n[]\n\n[Postprocessors]\n  [core_p_in]\n    type = SideAverageValue\n    boundary = core_chan:in\n    variable = p\n  []\n\n  [core_p_out]\n    type = SideAverageValue\n    boundary = core_chan:out\n    variable = p\n  []\n\n  [core_delta_p]\n    type = ParsedPostprocessor\n    pp_names = 'core_p_in core_p_out'\n    function = 'core_p_in - core_p_out'\n  []\n[]\n\n[Preconditioning]\n  [pc]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  line_search = basic\n\n  end_time=\"1000\"\n  dt=\"1e-04\"\n  # dt=\"10\"\n  dtmin=\"1e-12\"\n\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-8\n  nl_max_its = 25\n  steady_state_detection=\"true\"\n\n[]\n\n[Outputs]\n  vtk=true\n  csv=true\n  print_linear_residuals = false\n[]",
          "url": "https://github.com/idaholab/moose/discussions/25718",
          "updatedAt": "2023-10-12T06:59:12Z",
          "publishedAt": "2023-10-11T15:10:45Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "licharlot"
                  },
                  "bodyText": "Hello,\nI removed steady_state_detection=true. If turned on, as is, it stops the simulation before the actual steady state. If you let it run, it'll converge to steady state, you'll see the pressure drop is not changing anymore, and it has a positive value, which is close to the one you get with dt=10 .(9.45e-3 Pa vs 9.047e-3 Pa).  It is expected that setting a very small dt, you'd observe a transient. The fluid is initially at rest and at t=0, a mass flow rate is imposed. Because THM is solving for compressible flow, it is solving the wave propagation in the domain and you get these negative pressure drops.",
                  "url": "https://github.com/idaholab/moose/discussions/25718#discussioncomment-7254400",
                  "updatedAt": "2023-10-11T15:42:23Z",
                  "publishedAt": "2023-10-11T15:42:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "setting scalar variable parameter in action",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "I have a NodalKernel that needs a coupled scalar variable. The parameter is set like params.addRequiredCoupledVar(\"lambda\") in my MyNodalKernel. It works when I have the kernels and variables all written out in my input file. Now I'm trying to make an action.\nIn my action I create the scalar variable:\nauto params = _factory.getValidParams(\"MooseVariable\");\nparams.set<MooseEnum>(\"order\") = \"FIRST\";\nparams.set<MooseEnum>(\"family\") = \"SCALAR\";\n_problem->addVariable(\"MooseVariable\", \"lambda\", params);\n\nThen when adding the kernel I do:\nstd::string var = \"lambda\";\nif (_current_task == \"add_nodal_kernel\") {\n  if (_problem->hasScalarVariable(var)) {\n    auto params = _factory.getValidParams(\"MyNodalKernel\");\n    params.set<std::vector<VariableName>>(\"lambda\") = {var};  // note this wants a vector for some reason\n    (... more params...)\n    _problem->addNodalKernel(\"MyNodalKernel\", \"foo\", params);\n  }\n}\n\nWhen I go to create the object (_problem->addNodalKernel...) I get an runtime error: Scalar variable 'lambda' does not exist in this system, even though I explicitly tested for it above!\n(Also note the comment above where the parameter needs to be set to a vector of variables. If I just pass the variable itself, the code compiles but I get a different runtime error about \"VariableName should be std::vector...\", but that's a different issue...)",
          "url": "https://github.com/idaholab/moose/discussions/25715",
          "updatedAt": "2023-10-11T15:51:56Z",
          "publishedAt": "2023-10-11T14:27:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "The error about the variable needing to be a vector of variables is:\nAttempting to set parameter \"lambda\" with type (VariableName)\nbut the parameter already exists as type (std::vector<VariableName, std::allocatorVariableName> >)\n\nWhich I get when I do params.set<VariableName>(\"lambda\") = var but I can fix that by passing the variable as a one-item vector as you see above.",
                  "url": "https://github.com/idaholab/moose/discussions/25715#discussioncomment-7253789",
                  "updatedAt": "2023-10-11T14:46:30Z",
                  "publishedAt": "2023-10-11T14:46:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "do this\nparams.set<std::vector<VariableName>>(\"lambda\") = {var};",
                          "url": "https://github.com/idaholab/moose/discussions/25715#discussioncomment-7253927",
                          "updatedAt": "2023-10-11T14:58:16Z",
                          "publishedAt": "2023-10-11T14:58:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Yes, I did that (though it doesn't make sense). That's not my actual issue though.",
                          "url": "https://github.com/idaholab/moose/discussions/25715#discussioncomment-7253949",
                          "updatedAt": "2023-10-11T15:00:33Z",
                          "publishedAt": "2023-10-11T15:00:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the coupleable interface works with vectors of variable names.\nparams.addCoupledVar is roughly the same as\nparams.addParam<std::vector<VariableName>>\nwith a bit of extra checking",
                          "url": "https://github.com/idaholab/moose/discussions/25715#discussioncomment-7254008",
                          "updatedAt": "2023-10-11T15:06:04Z",
                          "publishedAt": "2023-10-11T15:05:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think what you would want here is a setCoupledScalarVar routine. We could add it.\nIt s just a proliferation of APIs that do roughly the same thing",
                          "url": "https://github.com/idaholab/moose/discussions/25715#discussioncomment-7254025",
                          "updatedAt": "2023-10-11T15:07:01Z",
                          "publishedAt": "2023-10-11T15:07:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok getting to your issue now",
                          "url": "https://github.com/idaholab/moose/discussions/25715#discussioncomment-7254032",
                          "updatedAt": "2023-10-11T15:07:42Z",
                          "publishedAt": "2023-10-11T15:07:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you do this instead\ngetProblem().addVariable(\"MooseVariableScalar\", var_name, params);",
                          "url": "https://github.com/idaholab/moose/discussions/25715#discussioncomment-7254125",
                          "updatedAt": "2023-10-11T15:16:25Z",
                          "publishedAt": "2023-10-11T15:16:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "yes that did it!",
                          "url": "https://github.com/idaholab/moose/discussions/25715#discussioncomment-7254191",
                          "updatedAt": "2023-10-11T15:21:40Z",
                          "publishedAt": "2023-10-11T15:21:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "OK, next issue, below that I have a ScalarKernel (actually inherits from NodalScalarKernel), and I set the \"variable\" parameter like: params.set<VariableName>(\"variable\") = lambda;\nI get a runtime error:\nAttempting to set parameter \"variable\" with type (VariableName)\nbut the parameter already exists as type (NonlinearVariableName)\n\nThe error goes away if I change the type to NonlinearVariableName, but this is awkward because the variable is a scalar, which I would imagine is distinctively different from a nonlinear variable.",
                          "url": "https://github.com/idaholab/moose/discussions/25715#discussioncomment-7254248",
                          "updatedAt": "2023-10-11T15:26:46Z",
                          "publishedAt": "2023-10-11T15:26:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "scalar variables can be nonlinear.\nYou ll have to comply with the variable name type haha",
                          "url": "https://github.com/idaholab/moose/discussions/25715#discussioncomment-7254260",
                          "updatedAt": "2023-10-11T15:28:40Z",
                          "publishedAt": "2023-10-11T15:28:40Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Define Material Property as Boundary Condition",
          "author": {
            "login": "FanZhangchen"
          },
          "bodyText": "Hi MOOSE Team,\nThe material property I need to implement in my problem is the slip rate and which is space-dependent, and the boundary condition of my problem is also related to the slip rate. So I have a question about whether the material property could be defined as the boundary condition in MOOSE? Or in other ways, could I get the nodal coordinate to use Boolean to define the boundary conditions inside the material property module?\nBest,\nZC",
          "url": "https://github.com/idaholab/moose/discussions/24106",
          "updatedAt": "2023-10-11T12:04:40Z",
          "publishedAt": "2023-04-18T08:56:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "It depends.\nIf you want to apply a nodal (Dirichlet) BC, there is no straightforward way of accessing material properties from the node. But you can always provide a spatially-varying function in a FunctionDirichletBC.\nIf you want to apply an integrated (Neumann, Robin, etc.) BC, yes you can define the BC as a function of some material properties. See this example: #24108 (comment)",
                  "url": "https://github.com/idaholab/moose/discussions/24106#discussioncomment-5648734",
                  "updatedAt": "2023-04-18T12:55:38Z",
                  "publishedAt": "2023-04-18T12:55:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I said\n\nIf you want to apply a nodal (Dirichlet) BC, there is no straightforward way of accessing material properties from the node.\n\nSo it is technically possible to \"make\" material properties nodal. You'll essentially need an additional layer of projection. Let us know if you want to pursue that option.",
                          "url": "https://github.com/idaholab/moose/discussions/24106#discussioncomment-5648760",
                          "updatedAt": "2023-04-18T12:57:50Z",
                          "publishedAt": "2023-04-18T12:57:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "FanZhangchen"
                          },
                          "bodyText": "Could you give more information about the additional layer of projection?",
                          "url": "https://github.com/idaholab/moose/discussions/24106#discussioncomment-5658779",
                          "updatedAt": "2023-04-19T09:16:26Z",
                          "publishedAt": "2023-04-19T09:16:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@hugary1995",
                          "url": "https://github.com/idaholab/moose/discussions/24106#discussioncomment-5759640",
                          "updatedAt": "2023-04-29T02:45:14Z",
                          "publishedAt": "2023-04-29T02:45:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "iomags2211"
                          },
                          "bodyText": "@hugary1995 can you give more information on this or has it been answered elsewhere?",
                          "url": "https://github.com/idaholab/moose/discussions/24106#discussioncomment-7251642",
                          "updatedAt": "2023-10-11T11:26:23Z",
                          "publishedAt": "2023-10-11T11:26:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You need to extrapolate the material property from quadrature points to nodes. You can do either a least squares fit or an L2 projection.\nFor least squares fit, you can follow what's been done in the nodal patch recovery system.\nFor L2 projection, you need a lower dimensional block on the boundary, and then add a MaterialPropertyValue kernel to perform the projection.",
                          "url": "https://github.com/idaholab/moose/discussions/24106#discussioncomment-7251932",
                          "updatedAt": "2023-10-11T12:04:40Z",
                          "publishedAt": "2023-10-11T12:04:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to set temperature-dependent specific heat capacity",
          "author": {
            "login": "Ali1990dashti"
          },
          "bodyText": "Dear community,\nI want to make specific heat capacity in one of the blocks (the aquifer block) dependent on temperature. I have a .csv containing the temperature and specific heat capacity values. I have read this discussion but still, I could not solve my issue. Implementing the specific heat capacity values as a function also works for me because I can extract a rough function out of values stored in the .csv file. The following is the input file I want to implement the temperature-dependent specific heat capacity on it:\n[Mesh]\n  [annular]\n    type = AnnularMeshGenerator\n    nr = 10\n    rmin = 1.0\n    rmax = 10\n    growth_r = 1.4\n    nt = 4\n    dmin = 0\n    dmax = 90\n  []\n  [make3D]\n    type = MeshExtruderGenerator\n    extrusion_vector = '0 0 12'\n    num_layers = 3\n    bottom_sideset = 'bottom'\n    top_sideset = 'top'\n    input = annular\n  []\n  [shift_down]\n    type = TransformGenerator\n    transform = TRANSLATE\n    vector_value = '0 0 -6'\n    input = make3D\n  []\n  [aquifer]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 1\n    bottom_left = '0 0 -2'\n    top_right = '10 10 2'\n    input = shift_down\n  []\n  [injection_area]\n    type = ParsedGenerateSideset\n    combinatorial_geometry = 'x*x+y*y<1.01'\n    included_subdomain_ids = 1\n    new_sideset_name = 'injection_area'\n    input = 'aquifer'\n  []\n  [rename]\n    type = RenameBlockGenerator\n    old_block = '0 1'\n    new_block = 'caps aquifer'\n    input = 'injection_area'\n  []\n[]\n\n[GlobalParams]\n  PorousFlowDictator = dictator\n[]\n\n[Variables]\n  [porepressure]\n  []\n  [temperature]\n    initial_condition = 293\n    scaling = 1E-8\n  []\n[]\n\n[PorousFlowBasicTHM]\n  porepressure = porepressure\n  temperature = temperature\n  coupling_type = ThermoHydro\n  gravity = '0 0 0'\n  fp = the_simple_fluid\n[]\n\n[BCs]\n  [constant_injection_porepressure]\n    type = DirichletBC\n    variable = porepressure\n    value = 1E6\n    boundary = injection_area\n  []\n  [constant_injection_temperature]\n    type = DirichletBC\n    variable = temperature\n    value = 373\n    boundary = injection_area\n  []\n[]\n\n[FluidProperties]\n  [the_simple_fluid]\n    type = SimpleFluidProperties\n    bulk_modulus = 2E9\n    viscosity = 1.0E-3\n    density0 = 1000.0\n    thermal_expansion = 0.0002\n    cp = 4194\n    cv = 4186\n    porepressure_coefficient = 0\n  []\n[]\n\n[Materials]\n  [porosity]\n    type = PorousFlowPorosity\n    porosity_zero = 0.1\n  []\n  [biot_modulus]\n    type = PorousFlowConstantBiotModulus\n    biot_coefficient = 0.8\n    solid_bulk_compliance = 2E-7\n    fluid_bulk_modulus = 1E7\n  []\n  [permeability_aquifer]\n    type = PorousFlowPermeabilityConst\n    block = aquifer\n    permeability = '1E-14 0 0   0 1E-14 0   0 0 1E-14'\n  []\n  [permeability_caps]\n    type = PorousFlowPermeabilityConst\n    block = caps\n    permeability = '1E-15 0 0   0 1E-15 0   0 0 1E-16'\n  []\n  [thermal_expansion]\n    type = PorousFlowConstantThermalExpansionCoefficient\n    biot_coefficient = 0.8\n    drained_coefficient = 0.003\n    fluid_coefficient = 0.0002\n  []\n  [rock_internal_energy_non_res]\n    type = PorousFlowMatrixInternalEnergy\n    density = 2500.0\n    specific_heat_capacity = 1200.0\n    block = 'caps'\n  []\n  [rock_internal_energy_res]\n    type = PorousFlowMatrixInternalEnergy\n    density = 2500.0\n    specific_heat_capacity = 1200.0 # this is what I want to change\n    block = 'aquifer'\n  []\n  [thermal_conductivity]\n    type = PorousFlowThermalConductivityIdeal\n    dry_thermal_conductivity = '10 0 0  0 10 0  0 0 10'\n    block = 'caps aquifer'\n  []\n[]\n\n[Preconditioning]\n  active = basic\n  [basic]\n    type = SMP\n    full = true\n    petsc_options = '-ksp_diagonal_scale -ksp_diagonal_scale_fix'\n    petsc_options_iname = '-pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap'\n    petsc_options_value = ' asm      lu           NONZERO                   2'\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = Newton\n  end_time = 864000\n  dt = 43200\n  nl_abs_tol = 1E-10\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nThe .csv file is also attached.\nThanks for your support.\nvalues.csv",
          "url": "https://github.com/idaholab/moose/discussions/25688",
          "updatedAt": "2023-10-11T09:03:44Z",
          "publishedAt": "2023-10-09T08:14:50Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "I think you will need to either make a new material that takes a function instead of a single value, or perhaps modify PorousFlowMatrixInternalEnergy to take a function",
                  "url": "https://github.com/idaholab/moose/discussions/25688#discussioncomment-7229196",
                  "updatedAt": "2023-10-09T10:51:07Z",
                  "publishedAt": "2023-10-09T10:51:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For the function, because you have\n\n.csv containing the temperature and specific heat capacity values\n\nI would recommend this one:\nhttps://mooseframework.inl.gov/source/functions/PiecewiseLinear.html\nwith the data_file parameter",
                          "url": "https://github.com/idaholab/moose/discussions/25688#discussioncomment-7230397",
                          "updatedAt": "2023-10-09T13:15:57Z",
                          "publishedAt": "2023-10-09T13:15:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ali1990dashti"
                          },
                          "bodyText": "@GiudGiud\nThanks for your help.\nI have been struggling with .C and .h files of porous flow to convert specific_heat_capacity from a Real into a Function, however I have not progressed due to my naive coding skills. This is the .C file and I only changed params.addRequiredParam<Real> to params.addRequiredParam<FunctionName>:\n#include \"PorousFlowMatrixInternalEnergy.h\"\n\nregisterMooseObject(\"PorousFlowApp\", PorousFlowMatrixInternalEnergy);\n\nInputParameters\nPorousFlowMatrixInternalEnergy::validParams()\n{\n  InputParameters params = PorousFlowMaterialVectorBase::validParams();\n  params.addRequiredParam<FunctionName>(\"specific_heat_capacity\",\n                                \"Specific heat capacity of the rock grains (J/kg/K).\");\n  params.addRequiredParam<Real>(\"density\", \"Density of the rock grains\");\n  params.set<bool>(\"at_nodes\") = true;\n  params.addPrivateParam<std::string>(\"pf_material_type\", \"matrix_internal_energy\");\n  params.addClassDescription(\"This Material calculates the internal energy of solid rock grains, \"\n                             \"which is specific_heat_capacity * density * temperature.  Kernels \"\n                             \"multiply this by (1 - porosity) to find the energy density of the \"\n                             \"porous rock in a rock-fluid system\");\n  return params;\n}\n\nPorousFlowMatrixInternalEnergy::PorousFlowMatrixInternalEnergy(const InputParameters & parameters)\n  : PorousFlowMaterialVectorBase(parameters),\n    _cp(getParam<Real>(\"specific_heat_capacity\")),\n    _density(getParam<Real>(\"density\")),\n    _heat_cap(_cp * _density),\n    _temperature_nodal(getMaterialProperty<Real>(\"PorousFlow_temperature_nodal\")),\n    _dtemperature_nodal_dvar(\n        getMaterialProperty<std::vector<Real>>(\"dPorousFlow_temperature_nodal_dvar\")),\n    _en_nodal(declareProperty<Real>(\"PorousFlow_matrix_internal_energy_nodal\")),\n    _den_nodal_dvar(\n        declareProperty<std::vector<Real>>(\"dPorousFlow_matrix_internal_energy_nodal_dvar\"))\n{\n  if (_nodal_material != true)\n    mooseError(\"PorousFlowMatrixInternalEnergy classes are only defined for at_nodes = true\");\n}\n\nvoid\nPorousFlowMatrixInternalEnergy::initQpStatefulProperties()\n{\n  _en_nodal[_qp] = _heat_cap * _temperature_nodal[_qp];\n}\n\nvoid\nPorousFlowMatrixInternalEnergy::computeQpProperties()\n{\n  _en_nodal[_qp] = _heat_cap * _temperature_nodal[_qp];\n\n  _den_nodal_dvar[_qp].assign(_num_var, 0.0);\n  for (unsigned v = 0; v < _num_var; ++v)\n    _den_nodal_dvar[_qp][v] = _heat_cap * _dtemperature_nodal_dvar[_qp][v];\n}\n\nCan you please tell me how I can change the input file type from double into function?\nAnd in the .h file also I have:\n#pragma once\n\n#include \"PorousFlowMaterialVectorBase.h\"\n\n/**\n * This material computes internal energy (J/m^3) for a rock matrix\n * assuming constant grain density, specific heat capacity, and\n * a linear relationship with temperature.  To get the volumetric\n * heat capacity of the rock in a rock-fluid system, the result must\n * be multiplied by (1 - porosity).\n */\nclass PorousFlowMatrixInternalEnergy : public PorousFlowMaterialVectorBase\n{\npublic:\n  static InputParameters validParams();\n\n  PorousFlowMatrixInternalEnergy(const InputParameters & parameters);\n\nprotected:\n  virtual void initQpStatefulProperties() override;\n  virtual void computeQpProperties() override;\n\n  /// Specific heat capacity of rock grains\n  const Real _cp;\n\n  /// Density of rock grains (equals the density of the matrix if porosity=0)\n  const Real _density;\n\n  /// Heat capacity = _cp * _density\n  const Real _heat_cap;\n\n  /// Temperature at the nodes\n  const MaterialProperty<Real> & _temperature_nodal;\n\n  /// d(temperature at the nodes)/d(PorousFlow variable)\n  const MaterialProperty<std::vector<Real>> & _dtemperature_nodal_dvar;\n\n  /// Matrix internal_energy at the nodes\n  MaterialProperty<Real> & _en_nodal;\n\n  /// d(matrix internal energy)/d(PorousFlow variable)\n  MaterialProperty<std::vector<Real>> & _den_nodal_dvar;\n};\n\nThanks for your time.",
                          "url": "https://github.com/idaholab/moose/discussions/25688#discussioncomment-7230561",
                          "updatedAt": "2023-10-09T13:33:27Z",
                          "publishedAt": "2023-10-09T13:33:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "_cp(getParam<Real>(\"specific_heat_capacity\")),\n\n->\n    _cp(getParam<FunctionName>(\"specific_heat_capacity\")),\n\nThen this wont work:\n    _heat_cap(_cp * _density),\n\njust do that multiplication whenever you use in _heat_cap. And remove the _heat_cap class member maybe\nin the header:\nconst Real _cp;\n\n->\nconst Function & _cp;",
                          "url": "https://github.com/idaholab/moose/discussions/25688#discussioncomment-7231657",
                          "updatedAt": "2023-10-09T15:13:56Z",
                          "publishedAt": "2023-10-09T15:13:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "If this works ok it might be worth pushing it to MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/25688#discussioncomment-7234912",
                          "updatedAt": "2023-10-09T22:51:30Z",
                          "publishedAt": "2023-10-09T22:51:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ali1990dashti"
                          },
                          "bodyText": "Dear @GiudGiud , as you predicted, MOOSE complained about the multiplication:\n_heat_cap(_cp * _density),\nSorry I did not get your solution\n\njust do that multiplication whenever you use in _heat_cap. And remove the _heat_cap class member maybe\n\nShould I simply comment the _heat_cap(_cp * _density), but then _heat_cap is called in the functions at the end of the .C file.\nI tried to convert _density from a Real  to a Function but again MOOSE said I could not multiply two functions and expect a double. I also tried to use do not define the _heat_cap and do the multiplication directly in the functions (like _en_nodal[_qp] = _cp * _density * _temperature_nodal[_qp];) but it raised to the following error:\nUsing HIT from /home/alid/projects/moose/framework/contrib/hit\nChecking if header needs updating: /home/alid/projects/moose/framework/include/base/MooseRevision.h...\nCompiling C++ (in opt mode) /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C...\nIn file included from /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C:37:\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C: In constructor 'PorousFlowMatrixInternalEnergy::PorousFlowMatrixInternalEnergy(const InputParameters&)':\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C:32:31: error: invalid initialization of reference of type 'const Function&' from expression of type 'const FunctionName'\n   32 |     _cp(getParam<FunctionName>(\"specific_heat_capacity\")),\n      |         ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C: In member function 'virtual void PorousFlowMatrixInternalEnergy::initQpStatefulProperties()':\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C:49:24: error: no match for 'operator*' (operand types are 'const Function' and 'const Real' {aka 'const double'})\n   49 |   _en_nodal[_qp] = _cp * _density * _temperature_nodal[_qp];\n      |                    ~~~ ^ ~~~~~~~~\n      |                    |     |\n      |                    |     const Real {aka const double}\n      |                    const Function",
                          "url": "https://github.com/idaholab/moose/discussions/25688#discussioncomment-7237736",
                          "updatedAt": "2023-10-10T12:26:13Z",
                          "publishedAt": "2023-10-10T07:27:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Delete that attribute. You won't be able to define it like this.\nThen wherever that attribute was, it s very easy to compute that multiplication there",
                          "url": "https://github.com/idaholab/moose/discussions/25688#discussioncomment-7240781",
                          "updatedAt": "2023-10-10T12:50:52Z",
                          "publishedAt": "2023-10-10T12:50:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ali1990dashti"
                          },
                          "bodyText": "I tried the following in the .C file:\n#include \"PorousFlowMatrixInternalEnergy.h\"\n\nregisterMooseObject(\"PorousFlowApp\", PorousFlowMatrixInternalEnergy);\n\nInputParameters\nPorousFlowMatrixInternalEnergy::validParams()\n{\n  InputParameters params = PorousFlowMaterialVectorBase::validParams();\n  params.addRequiredParam<FunctionName>(\"specific_heat_capacity\",\n                                \"Specific heat capacity of the rock grains (J/kg/K).\");\n  params.addRequiredParam<Real>(\"density\", \"Density of the rock grains\");\n  params.set<bool>(\"at_nodes\") = true;\n  params.addPrivateParam<std::string>(\"pf_material_type\", \"matrix_internal_energy\");\n  params.addClassDescription(\"This Material calculates the internal energy of solid rock grains, \"\n                             \"which is specific_heat_capacity * density * temperature.  Kernels \"\n                             \"multiply this by (1 - porosity) to find the energy density of the \"\n                             \"porous rock in a rock-fluid system\");\n  return params;\n}\n\nPorousFlowMatrixInternalEnergy::PorousFlowMatrixInternalEnergy(const InputParameters & parameters)\n  : PorousFlowMaterialVectorBase(parameters),\n    _cp(getParam<FunctionName>(\"specific_heat_capacity\")),\n    _density(getParam<Real>(\"density\")),\n    _temperature_nodal(getMaterialProperty<Real>(\"PorousFlow_temperature_nodal\")),\n    _dtemperature_nodal_dvar(\n        getMaterialProperty<std::vector<Real>>(\"dPorousFlow_temperature_nodal_dvar\")),\n    _en_nodal(declareProperty<Real>(\"PorousFlow_matrix_internal_energy_nodal\")),\n    _den_nodal_dvar(\n        declareProperty<std::vector<Real>>(\"dPorousFlow_matrix_internal_energy_nodal_dvar\"))\n{\n  if (_nodal_material != true)\n    mooseError(\"PorousFlowMatrixInternalEnergy classes are only defined for at_nodes = true\");\n}\n\nvoid\nPorousFlowMatrixInternalEnergy::initQpStatefulProperties()\n{\n  _en_nodal[_qp] = _cp * _density * _temperature_nodal[_qp];\n}\n\nvoid\nPorousFlowMatrixInternalEnergy::computeQpProperties()\n{\n  _en_nodal[_qp] = _cp * _density * _temperature_nodal[_qp];\n\n  _den_nodal_dvar[_qp].assign(_num_var, 0.0);\n  for (unsigned v = 0; v < _num_var; ++v)\n    _den_nodal_dvar[_qp][v] = _cp * _density * _dtemperature_nodal_dvar[_qp][v];\n}\n\nAnd in the .h file:\n#pragma once\n\n#include \"PorousFlowMaterialVectorBase.h\"\n\n/**\n * This material computes internal energy (J/m^3) for a rock matrix\n * assuming constant grain density, specific heat capacity, and\n * a linear relationship with temperature.  To get the volumetric\n * heat capacity of the rock in a rock-fluid system, the result must\n * be multiplied by (1 - porosity).\n */\nclass PorousFlowMatrixInternalEnergy : public PorousFlowMaterialVectorBase\n{\npublic:\n  static InputParameters validParams();\n\n  PorousFlowMatrixInternalEnergy(const InputParameters & parameters);\n\nprotected:\n  virtual void initQpStatefulProperties() override;\n  virtual void computeQpProperties() override;\n\n  /// Specific heat capacity of rock grains\n  const Function & _cp;\n\n  /// Density of rock grains (equals the density of the matrix if porosity=0)\n  const Real _density;\n\n  /// Temperature at the nodes\n  const MaterialProperty<Real> & _temperature_nodal;\n\n  /// d(temperature at the nodes)/d(PorousFlow variable)\n  const MaterialProperty<std::vector<Real>> & _dtemperature_nodal_dvar;\n\n  /// Matrix internal_energy at the nodes\n  MaterialProperty<Real> & _en_nodal;\n\n  /// d(matrix internal energy)/d(PorousFlow variable)\n  MaterialProperty<std::vector<Real>> & _den_nodal_dvar;\n};\n\nBut in the compilation the following error raised:\nUsing HIT from /home/alid/projects/moose/framework/contrib/hit\nChecking if header needs updating: /home/alid/projects/moose/framework/include/base/MooseRevision.h...\nCreating Unity /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C\nCompiling C++ (in opt mode) /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C...\nIn file included from /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C:37:\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C: In constructor 'PorousFlowMatrixInternalEnergy::PorousFlowMatrixInternalEnergy(const InputParameters&)':\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C:32:31: error: invalid initialization of reference of type 'const Function&' from expression of type 'const FunctionName'\n   32 |     _cp(getParam<FunctionName>(\"specific_heat_capacity\")),\n      |         ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C: In member function 'virtual void PorousFlowMatrixInternalEnergy::initQpStatefulProperties()':\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C:48:24: error: no match for 'operator*' (operand types are 'const Function' and 'const Real' {aka 'const double'})\n   48 |   _en_nodal[_qp] = _cp * _density * _temperature_nodal[_qp];\n      |                    ~~~ ^ ~~~~~~~~\n      |                    |     |\n      |                    |     const Real {aka const double}\n      |                    const Function\nIn file included from /home/alid/miniconda3/envs/moose/include/petscsystypes.h:229,\n                 from /home/alid/miniconda3/envs/moose/include/petscsys.h:40,\n                 from /home/alid/miniconda3/envs/moose/include/petscbag.h:4,\n                 from /home/alid/miniconda3/envs/moose/include/petsc.h:5,\n                 from /home/alid/miniconda3/envs/moose/libmesh/include/libmesh/petsc_macro.h:66,\n                 from /home/alid/projects/moose/framework/build/header_symlinks/MooseTypes.h:21,\n                 from /home/alid/projects/moose/framework/build/header_symlinks/DataIO.h:14,\n                 from /home/alid/projects/moose/framework/build/header_symlinks/SystemBase.h:14,\n                 from /home/alid/projects/moose/framework/build/header_symlinks/AuxiliarySystem.h:13,\n                 from /home/alid/projects/moose/framework/build/header_symlinks/DerivativeMaterialInterface.h:12,\n                 from /home/alid/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowVariableBase.h:12,\n                 from /home/alid/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlow1PhaseFullySaturated.h:12,\n                 from /home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlow1PhaseFullySaturated.C:10,\n                 from /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C:2:\n...\n...\n...",
                          "url": "https://github.com/idaholab/moose/discussions/25688#discussioncomment-7240869",
                          "updatedAt": "2023-10-10T12:58:20Z",
                          "publishedAt": "2023-10-10T12:58:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You have to evaluate the function. You can't write _cp\nIt has to be _cp( current point , _t)\nI think the current point is something like _q_points[_qp] but please check other objects for an example",
                          "url": "https://github.com/idaholab/moose/discussions/25688#discussioncomment-7241075",
                          "updatedAt": "2023-10-10T13:16:24Z",
                          "publishedAt": "2023-10-10T13:16:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ali1990dashti"
                          },
                          "bodyText": "I found this example a bit like what I want but it is not multiplying the function into a double. Based on another example I used _cp.value(_t, _q_point[_qp]) but it did not work due to the following error:\nUsing HIT from /home/alid/projects/moose/framework/contrib/hit\nChecking if header needs updating: /home/alid/projects/moose/framework/include/base/MooseRevision.h...\nCreating Unity /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C\nCompiling C++ (in opt mode) /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C...\nIn file included from /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C:37:\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C: In constructor 'PorousFlowMatrixInternalEnergy::PorousFlowMatrixInternalEnergy(const InputParameters&)':\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C:32:31: error: invalid initialization of reference of type 'const Function&' from expression of type 'const FunctionName'\n   32 |     _cp(getParam<FunctionName>(\"specific_heat_capacity\")),\n      |         ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C: In member function 'virtual void PorousFlowMatrixInternalEnergy::initQpStatefulProperties()':\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C:48:20: error: invalid use of incomplete type 'const class Function'\n   48 |   _en_nodal[_qp] = _cp.value(_t, _q_point[_qp]) * _density * _temperature_nodal[_qp];\n      |                    ^~~\nIn file included from /home/alid/projects/moose/framework/build/header_symlinks/ResidualObject.h:15,\n                 from /home/alid/projects/moose/framework/build/header_symlinks/KernelBase.h:12,\n                 from /home/alid/projects/moose/framework/build/header_symlinks/DerivativeMaterialInterface.h:16,\n                 from /home/alid/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowVariableBase.h:12,\n                 from /home/alid/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlow1PhaseFullySaturated.h:12,\n                 from /home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlow1PhaseFullySaturated.C:10,\n                 from /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C:2:\n/home/alid/projects/moose/framework/build/header_symlinks/FunctionInterface.h:19:7: note: forward declaration of 'class Function'\n   19 | class Function;\n      |       ^~~~~~~~\nIn file included from /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C:37:\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C: In member function 'virtual void PorousFlowMatrixInternalEnergy::computeQpProperties()':\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C:54:20: error: invalid use of incomplete type 'const class Function'\n   54 |   _en_nodal[_qp] = _cp.value(_t, _q_point[_qp]) * _density * _temperature_nodal[_qp];\n      |                    ^~~\nIn file included from /home/alid/projects/moose/framework/build/header_symlinks/ResidualObject.h:15,\n                 from /home/alid/projects/moose/framework/build/header_symlinks/KernelBase.h:12,\n                 from /home/alid/projects/moose/framework/build/header_symlinks/DerivativeMaterialInterface.h:16,\n                 from /home/alid/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowVariableBase.h:12,\n                 from /home/alid/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlow1PhaseFullySaturated.h:12,\n                 from /home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlow1PhaseFullySaturated.C:10,\n                 from /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C:2:\n/home/alid/projects/moose/framework/build/header_symlinks/FunctionInterface.h:19:7: note: forward declaration of 'class Function'\n   19 | class Function;\n      |       ^~~~~~~~\nIn file included from /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C:37:\n/home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlowMatrixInternalEnergy.C:58:31: error: invalid use of incomplete type 'const class Function'\n   58 |     _den_nodal_dvar[_qp][v] = _cp.value(_t, _q_point[_qp]) * _density * _dtemperature_nodal_dvar[_qp][v];\n      |                               ^~~\nIn file included from /home/alid/projects/moose/framework/build/header_symlinks/ResidualObject.h:15,\n                 from /home/alid/projects/moose/framework/build/header_symlinks/KernelBase.h:12,\n                 from /home/alid/projects/moose/framework/build/header_symlinks/DerivativeMaterialInterface.h:16,\n                 from /home/alid/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowVariableBase.h:12,\n                 from /home/alid/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlow1PhaseFullySaturated.h:12,\n                 from /home/alid/projects/moose/modules/porous_flow/src/materials/PorousFlow1PhaseFullySaturated.C:10,\n                 from /home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.C:2:\n/home/alid/projects/moose/framework/build/header_symlinks/FunctionInterface.h:19:7: note: forward declaration of 'class Function'\n   19 | class Function;\n      |       ^~~~~~~~\n/home/alid/projects/moose/framework/build.mk:122: recipe for target '/home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.x86_64-conda-linux-gnu.opt.lo' failed\nmake: *** [/home/alid/projects/moose/modules/porous_flow/build/unity_src/materials_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1",
                          "url": "https://github.com/idaholab/moose/discussions/25688#discussioncomment-7242415",
                          "updatedAt": "2023-10-10T15:14:31Z",
                          "publishedAt": "2023-10-10T15:14:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh yeah this is wrong\n32 |     _cp(getParam(\"specific_heat_capacity\")),\nshould be something like\n32 |     _cp(getFunction(\"specific_heat_capacity\")),",
                          "url": "https://github.com/idaholab/moose/discussions/25688#discussioncomment-7242496",
                          "updatedAt": "2023-10-10T15:21:56Z",
                          "publishedAt": "2023-10-10T15:21:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Creating a New Diffusion Kernel",
          "author": {
            "login": "jsevic"
          },
          "bodyText": "Hello,\nI have diffusion operator kernel written a few years based on the ExampleConvection coupled kernel example in Example 3. In that kernel I added a coupled parameter for temperature, creating a diffusion operator kernel where thermal conductivity is coupled into as its value is a function of temperature.\nI have tried the same thing from scratch in my latest MOOSE app from, and made the following changes. Since the example convection kernel is coupling some_gradient\n_grad_some_variable(coupledGradient(\"some_gradient\"))\n\nand I want to couple a real value for thermal conductivity, I changed coupledGradient to coupledValue, which is what my old kernel used. Then I changed in the .h file the VariableGradient declaration to VariableValue, and I get a compile error.\nprivate:\nconst VariableGradient & _grad_some_variable;\nMy original function compiles and passes tests this one does not. What am I missing? Any suggestions?\nThese are the errors I get.\nCompiling C++ (in opt mode) /Users/johnsevic/projects/moose/examples/ex03_coupling/build/unity_src/kernels_Unity.C...\nIn file included from /Users/johnsevic/projects/moose/examples/ex03_coupling/build/unity_src/kernels_Unity.C:2:\n/Users/johnsevic/projects/moose/examples/ex03_coupling/src/kernels/ExampleConvection.C:35:10: error: no viable conversion from returned value of type 'typename boostcopy::enable_if_c<ScalarTraits::value, TypeVector<typename CompareTypes<double, double>::supertype>>::type' (aka 'libMesh::TypeVector') to function return type 'libMesh::Real' (aka 'double')\nreturn _test[_i][_qp] * (_grad_some_variable[_qp] * _grad_u[_qp]);\n^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/Users/johnsevic/projects/moose/examples/ex03_coupling/src/kernels/ExampleConvection.C:41:10: error: no viable conversion from returned value of type 'typename boostcopy::enable_if_c<ScalarTraits::value, TypeVector<typename CompareTypes<double, double>::supertype>>::type' (aka 'libMesh::TypeVector') to function return type 'libMesh::Real' (aka 'double')\nreturn _test[_i][_qp] * (_grad_some_variable[_qp] * _grad_phi[_j][_qp]);\n^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n2 errors generated.\nmake: *** [/Users/johnsevic/projects/moose/framework/build.mk:151: /Users/johnsevic/projects/moose/examples/ex03_coupling/build/unity_src/kernels_Unity.aarch64-apple-darwin20.0.0.opt.lo] Error 1",
          "url": "https://github.com/idaholab/moose/discussions/25708",
          "updatedAt": "2023-10-11T01:53:17Z",
          "publishedAt": "2023-10-10T23:50:51Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is a vector now, when it used to be a scalar\nreturn _test[_i][_qp] * (_grad_some_variable[_qp] * _grad_u[_qp])\n\nbefore these, _grad_some_variable[_qp] and  _grad_u[_qp] are vectors so the product is a dot product. Now, one is a real and you end up returning a vector. This makes sense for a convection term in a PDE\nIf you are trying to substitute one into a conductivity, chances are you're modeling diffusion not convection and a diffusion kernel is a better example to follow\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25708#discussioncomment-7247222",
                  "updatedAt": "2023-10-11T00:56:35Z",
                  "publishedAt": "2023-10-11T00:56:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jsevic"
                  },
                  "bodyText": "OK so just to be clear, in this kernel I have changed the following line to include coupledValue instead of coupledGradient, so is this still producing a vector?\n_grad_some_variable(coupledValue(\"some_gradient\"))\nIn the .h file I have...\nVariableValue & _grad_some_variable;\nI did not change the variable name even though it says _grad_some_variable is physically k_thermal that gets coupld.",
                  "url": "https://github.com/idaholab/moose/discussions/25708#discussioncomment-7247319",
                  "updatedAt": "2023-10-11T01:13:37Z",
                  "publishedAt": "2023-10-11T01:12:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no longer a vector. It s getting you Reals now",
                          "url": "https://github.com/idaholab/moose/discussions/25708#discussioncomment-7247349",
                          "updatedAt": "2023-10-11T01:17:28Z",
                          "publishedAt": "2023-10-11T01:17:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jsevic"
                  },
                  "bodyText": "Yes that is what I was thought, so still confused. Eventually I want to implement this weak form\n_grad_u[_qp] * _grad_test[_i][_qp] * _sigma_e[_qp]\nso that's why I had coupledValue for _grad_some_variable and declared this as VariableValue in the .h file. Eventually _grad_some_variable will be the coupled electrical conductivity _sigma_e.",
                  "url": "https://github.com/idaholab/moose/discussions/25708#discussioncomment-7247385",
                  "updatedAt": "2023-10-11T01:24:51Z",
                  "publishedAt": "2023-10-11T01:24:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is fine though?\n_grad_u[_qp] * _grad_test[_i][_qp] is vector times vector -> real\n_sigma_e[_qp] is real I assume",
                          "url": "https://github.com/idaholab/moose/discussions/25708#discussioncomment-7247415",
                          "updatedAt": "2023-10-11T01:30:02Z",
                          "publishedAt": "2023-10-11T01:30:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jsevic"
                  },
                  "bodyText": "Yes that worked in my earlier code. Does the order of operation matter? That may be my mistake? My new code gets the compile error. Yes _sigma_e is real.",
                  "url": "https://github.com/idaholab/moose/discussions/25708#discussioncomment-7247453",
                  "updatedAt": "2023-10-11T01:41:59Z",
                  "publishedAt": "2023-10-11T01:41:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in the code you pasted earlier you have _test not _grad_test. Is that it?",
                          "url": "https://github.com/idaholab/moose/discussions/25708#discussioncomment-7247476",
                          "updatedAt": "2023-10-11T01:46:15Z",
                          "publishedAt": "2023-10-11T01:46:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the order of operation for vector * real * vector or real * vector * vector etc does not matter",
                          "url": "https://github.com/idaholab/moose/discussions/25708#discussioncomment-7247481",
                          "updatedAt": "2023-10-11T01:46:44Z",
                          "publishedAt": "2023-10-11T01:46:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jsevic"
                  },
                  "bodyText": "This worked.\nYes I did add now the _grad_test since I ultimately want the diffusion operator. Maybe that was the issue?\nReal\nExampleConvection::computeQpResidual()\n{\nreturn _grad_u[_qp] * _grad_test[_i][_qp] * _grad_some_variable[_qp];\n}\nReal\nExampleConvection::computeQpJacobian()\n{\nreturn _grad_some_variable[_qp] * _grad_phi[_j][_qp] * _grad_test[_i][_qp];\n}",
                  "url": "https://github.com/idaholab/moose/discussions/25708#discussioncomment-7247507",
                  "updatedAt": "2023-10-11T01:53:18Z",
                  "publishedAt": "2023-10-11T01:53:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}