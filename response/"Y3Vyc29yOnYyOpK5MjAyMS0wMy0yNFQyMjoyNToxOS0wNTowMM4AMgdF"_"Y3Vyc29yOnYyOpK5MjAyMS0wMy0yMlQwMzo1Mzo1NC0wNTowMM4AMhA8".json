{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wMy0yMlQwMzo1Mzo1NC0wNTowMM4AMhA8"
    },
    "edges": [
      {
        "node": {
          "title": "BC setting with Boundary Value Calculation",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "MOOSE Team,\nFor my transient (unsteady) model, I would like to use NeumannBC for the BC setting and the value of flux is obtained in the following 5 steps for one time level with temperature and time step size called in (total concentration = 0 for the initial condition). Please help.\n(1)\tFor temperature \u2264 100[K], temp = constant_A * temperature\n(2)\tFor temperature > 100[K], temp = constant_B * temperature\nthen\n(3)\tconcentration at the current time step = temp * \u2206t\n(where \u2206t = time step size = current time \u2013 previous time)\n(4)\ttotal concentration = total concentration + temp * \u2206t (concentration at the current time step)\n(5)\tFlux = constant_C * total concentration\nSincerely,\nThomas",
          "url": "https://github.com/idaholab/moose/discussions/17373",
          "updatedAt": "2021-03-31T21:16:46Z",
          "publishedAt": "2021-03-18T17:47:54Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "If I was doing this, I would compute the \"total concentration\" in a Material object as a material property. Then create a BC object that accepts a constant input parameter and the material property name.",
                  "url": "https://github.com/idaholab/moose/discussions/17373#discussioncomment-503495",
                  "updatedAt": "2021-03-19T14:32:46Z",
                  "publishedAt": "2021-03-19T14:32:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you Andrew!\nI am still new and learning MOOSE.  Please be patient with me.\nAre you suggesting to modify source code \"Material.C\" in /moose/framework/src/materials to include my 5 steps to calculate \"total concentration?\"\nI was thinking to use \"FunctionNeumannBC\" with \"ParsedFunction\" so that I can put my 5 steps in the input file, which is a lot easier for me. Is this possible?\nPlease let me know.\nSincerely,\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17373#discussioncomment-504329",
                          "updatedAt": "2021-03-19T17:30:15Z",
                          "publishedAt": "2021-03-19T17:30:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "No. You should never need to modify source code of MOOSE. You should be working within your own custom application. I suggest you work through our tutorial: https://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial01_app_development/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/17373#discussioncomment-513387",
                          "updatedAt": "2021-03-22T14:11:21Z",
                          "publishedAt": "2021-03-22T14:11:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you Andrew!\nI apologize for my confusing question.\nMy question is what is the specific Material object you suggest to use (GenericConstantMaterial, GenericFunctionMaterial, or Material.C\" in /moose/framework/src/materials).\nI do appreciate your patience with me.\nSincerely,\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17373#discussioncomment-514452",
                          "updatedAt": "2021-03-22T17:52:40Z",
                          "publishedAt": "2021-03-22T17:52:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "You would start by creating an object that inherits from Material, as done here: https://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial01_app_development/step09_mat_props.html#step-9-develop-a-material-object",
                          "url": "https://github.com/idaholab/moose/discussions/17373#discussioncomment-527807",
                          "updatedAt": "2021-03-25T03:23:47Z",
                          "publishedAt": "2021-03-25T03:23:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cahn-Hilliard and NeumannBC",
          "author": {
            "login": "souzanha"
          },
          "bodyText": "Hi all!\nI'm working with the Cahn-Hilliard kernels and want to include a BC with an outward flux of a species.\nAt the moment, I'm trying with a constant flux using a NeumannBC. The files compile and the solution converges, but the concentration is not changing. Any suggestions to what could be wrong?\n[Mesh]\ntype = GeneratedMesh # Can generate simple lines, rectangles and rectangular prisms\ndim = 2 # Dimension of the mesh\nnx = 100 # Number of elements in the x direction\nny = 100 # Number of elements in the y direction\nxmin = 0\nxmax = 100e-9\nymin= 0\nymax = 100e-9\n[]\n[Variables]\n[./c]\n[../]\n[./w]\n[../]\n[]\n[ICs]\n[./c]\ntype = ConstantIC\nvariable = c\nvalue = 1\n[../]\n[]\n#[BCs]\n#[./right]\n#type = ADButlerVolmerBC\n#variable = c\n#boundary = right\n#w = w\n#[../]\n#[]\n[BCs]\n[./right]\ntype = NeumannBC\nvariable = w\nboundary = right\nvalue = -0.1\n[../]\n[]\n[Materials]\n[./constants]\ntype = GenericConstantMaterial\nprop_names = 'R T omega Vm D'\nprop_values = '8.3145 298 12e3 43.8e-6 1e-15'\n[../]\n[./free_energy]\ntype = DerivativeParsedMaterial\nf_name = f\nargs = 'c'\nconstant_names = 'R T omega Vm'\nconstant_expressions = '8.3145 298 12e3 43.8e-6'\nfunction = '((RT/Vm)(c*plog(c,1e-3)+(1-c)*plog(1-c,1e-3)))+((omega/Vm)c(1-c))'\nderivative_order = 2\n[../]\n[./mobility]\ntype = DerivativeParsedMaterial\nf_name = mob\nfunction = '(c*(1-c)DVm)/(R*T)'\nargs = 'c'\nconstant_names  = 'R T Vm D'\nconstant_expressions = '8.3145 298 43.8e-6 1e-15'\nderivative_order = 1\n[../]\n[]\n**[Kernels]\n[./time]\ntype=CoupledTimeDerivative\nvariable = w\nv = c\n[../]\n[./wres]\ntype=SplitCHWRes\nvariable = w\nmob_name = mob\n[../]\n[./c_res]\ntype=SplitCHParsed\nvariable = c\nw = w\nf_name = f\nkappa_name = 1.68e-10\n[../]\n[]**\n[Preconditioning]\n[./smp]\ntype = SMP\nfull = true\n[../]\n[]\n[Executioner]\ntype = Transient\nscheme = bdf2\nsolve_type = NEWTON\nl_max_its = 30\nnl_max_its = 10\nl_tol = 1.0e-4\nnl_rel_tol = 1.0e-6\nnl_abs_tol = 1.0e-6\ndt = 1e-3\nend_time = 10\n[]\n[Outputs]\ninterval = 1000\nexodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/17345",
          "updatedAt": "2022-06-22T07:33:44Z",
          "publishedAt": "2021-03-17T08:48:23Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "You probably want to apply the NeumannBC on variable c instead of w.",
                  "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494283",
                  "updatedAt": "2022-06-22T07:33:53Z",
                  "publishedAt": "2021-03-17T15:29:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Yes, I've been thinking about that actually. Looking at the Cahn-Hilliard residual, we get a surface term (boundary term) for both the chemical potential and the concentration. The chemical potential and the concentration are both coupled in a way.\nI started out with applying the NeumannBC on c, and did not get a change in the system. Then I found a few examples where other people have applied the flux to w instead.\nIn the end, I would like to use the Butler-Volmer BC I have which induces a flux of ions, and looking at the published work I try to mimic the flux has the same units as the chemical potential and not the concentration term.\nI would be very happy to discuss this :) Thanks for your answer.",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494731",
                          "updatedAt": "2022-06-22T07:33:54Z",
                          "publishedAt": "2021-03-17T17:18:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Either way you should see a mass change. I am curious how do you know there is no change in the system. Did you compute the total mass and look at its change?",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494839",
                          "updatedAt": "2022-06-22T07:33:54Z",
                          "publishedAt": "2021-03-17T17:38:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "I'm sure there are better way to do this .. but I display the system in Vislt and look at the last time-step. The color bar stays at max/min=1. Could it be that the change is so small that it isn't displayed? I tried plotting it across a line, and still get c=1.",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494878",
                          "updatedAt": "2022-06-22T07:33:54Z",
                          "publishedAt": "2021-03-17T17:45:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "So I display the variable c as a 2D graph.",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494882",
                          "updatedAt": "2022-06-22T12:37:16Z",
                          "publishedAt": "2021-03-17T17:46:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "It is better to use a post processor to compute the integral of c over whole domain.\nI made some tests a while ago. jiangwen84@cf52415\ntake a look at modules/phase_field/test/tests/CahnHilliardFluxBC/anisotropic_split.i  in that branch.",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-494946",
                          "updatedAt": "2022-06-22T12:37:14Z",
                          "publishedAt": "2021-03-17T17:58:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Thank you, I'll take a look. I saw some posts regarding the previous CahnHilliardFluxBC but couldn't find any files to look at.\nWhile I have you on the loop, do you mind another question? Its regarding the DerivativeParsedMaterial for the free energy. I have written the function completely underivated (i.e. f_chem(c) and not df/dc that usually goes into the chemical potential), but specified the order to 2. Is this correct?",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-495022",
                          "updatedAt": "2022-06-22T12:37:31Z",
                          "publishedAt": "2021-03-17T18:08:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Correct. The code will compute derivatives up the the order you specify.",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-495098",
                          "updatedAt": "2022-06-22T12:37:31Z",
                          "publishedAt": "2021-03-17T18:24:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Thank you for suggesting the postprocessor, its really handy.\nThis is confusing though, I set the initial condition on c to be 1. However it is 0? It is also increasing (very little) when it actually should decrease due to the negative flux value.\nPostprocessor Values:\n+----------------+----------------+\n| time           | total_solute   |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n|   1.000000e+00 |   1.000000e-14 |\n|   2.000000e+00 |   1.000000e-14 |\n|   3.000000e+00 |   1.000000e-14 |\n|   4.000000e+00 |   1.000000e-14 |\n|   5.000000e+00 |   1.000000e-14 |\n|   6.000000e+00 |   1.000000e-14 |\n|   7.000000e+00 |   1.000000e-14 |\n|   8.000000e+00 |   1.000000e-14 |\n|   9.000000e+00 |   1.000000e-14 |\n|   1.000000e+01 |   1.000000e-14 |\n|   1.100000e+01 |   1.000000e-14 |\n|   1.200000e+01 |   1.000000e-14 |\n|   1.300000e+01 |   1.000000e-14 |\n|   1.400000e+01 |   1.000000e-14 |\n+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-495127",
                          "updatedAt": "2022-06-22T12:37:41Z",
                          "publishedAt": "2021-03-17T18:31:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "From what you showed, the integral of c is 1e-14 and does not change at all.\nLooks like your solution does not actually converge, or not sufficiently. You domain size is too small, and could you change the unit system to make it around 1. It is not necessary but it could make the convergence setup easier.\nYou also need to tight the tolerance a bit, i.e.,\nnl_rel_tol = 1.0e-10\nnl_abs_tol = 1.0e-10",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-495243",
                          "updatedAt": "2022-06-23T14:45:35Z",
                          "publishedAt": "2021-03-17T19:02:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Now it starts to make sense! So the reason I have such a small system is to compare to the published work.\nChanging the tolerance and the size to 1 -> does not converge. Which is a good thing in a way, now I get that something is wrong while knowing something is wrong.\nDo you have any idea for why the initial state doesn't match my input? I'm setting c=1.\nTime Step 0, time = 0\nPostprocessor Values:\n+----------------+----------------+\n| time           | total_solute   |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/17345#discussioncomment-496982",
                          "updatedAt": "2022-06-23T14:45:36Z",
                          "publishedAt": "2021-03-18T07:46:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multigrid Solvers in Moose",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "Does Moose have the ability to solve Finite Element Problems using multi-grid solvers?",
          "url": "https://github.com/idaholab/moose/discussions/17338",
          "updatedAt": "2022-12-13T13:57:45Z",
          "publishedAt": "2021-03-16T21:35:39Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@fdkong could you elaborate on our capabilities.",
                  "url": "https://github.com/idaholab/moose/discussions/17338#discussioncomment-495621",
                  "updatedAt": "2022-12-13T13:57:45Z",
                  "publishedAt": "2021-03-17T20:38:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "Yes, there are several MG solvers available in MOOSE. For Algebraic MG, we can use hypre (-pc_type hypre), ML (-pc_type ml), and GAMG (-pc_type gamg).\nFor geometric MG, we have something in libmesh, but we do not explore much yet.\nWhat is your context? What are you looking for?",
                  "url": "https://github.com/idaholab/moose/discussions/17338#discussioncomment-495689",
                  "updatedAt": "2022-12-13T13:57:45Z",
                  "publishedAt": "2021-03-17T20:48:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "For the combined solution of the equation of motion (F=ma) and the navier stokes, I am seeking to solve each equation in two separate domains then apply the solution to a third domain which is then applied as an initial condition on the navier stokes domain for successive iterations in time.  Here are some additional details that I seek advisement on for implementation in moose. An example of the method applied in moose would be an even greater starting point for my research:\nEmploy a (rough) boundary parametrization which sufficiently describes all large-scale structures with regard to the boundary conditions.\nTreat all fine- scale features as interior objects such that the corresponding components in all matrices and vectors are unknown degrees offreedom which are implicitely incorporated into all iterative solution steps.\nUtilize filtering techniques to project the corresponding vector components onto the subspace of \"correct\" boundary conditions, before and directly after each iterative substep.",
                          "url": "https://github.com/idaholab/moose/discussions/17338#discussioncomment-495985",
                          "updatedAt": "2022-12-13T13:58:22Z",
                          "publishedAt": "2021-03-17T22:15:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "As far as I know, there is no example close to what you want. I might not completely understand your description here.\nYou may explore a multi-app system that allows to solve different physics and transfer solutions from one system to another. After transfer, you can use the transferred solution as the initial guess for the current system. The projection step can be done as part of the transfer, but you might need to implement your customized projection transfer if the existing transfers do not work for you.",
                          "url": "https://github.com/idaholab/moose/discussions/17338#discussioncomment-526497",
                          "updatedAt": "2022-12-13T13:58:27Z",
                          "publishedAt": "2021-03-24T19:24:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you very much for this information. I think that it will provide a good start in the right direction. I will try the multi app approach.",
                          "url": "https://github.com/idaholab/moose/discussions/17338#discussioncomment-527100",
                          "updatedAt": "2022-12-13T13:58:27Z",
                          "publishedAt": "2021-03-24T22:17:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A few questions on the DG Capabilities in MOOSE",
          "author": {
            "login": "pzimbrod"
          },
          "bodyText": "Hi all,\nI'm currently setting up MOOSE to help me model the complex physics within metal additive manufacturing (Powder Bed Fusion, to be precise). As there are a lot of length scales involved, the capabilities of MOOSE are really helping me out and I'm loving the framework and its structure, thanks for the extensive work so far!\nAs I'm also dealing with rather complex advection-diffusion equations and I have a background coming from FV based methods, I was looking into the DG capabilities of MOOSE. My understanding is that it provides a useful formulation for such problems as CG-FEM falls behind on solving hyperbolic PDEs (see e.g. 1,  Theorem 5.3 p.222) and FV has obvious limitations regarding p-refinement (which to my understanding is especially nice when solving in parallel to reduce MPI communication).\nI've looked into the documentation of the DG Kernels along with the test cases and came across a few questions regarding the implementation:\n\nFirst of all, I'm wondering why you need to specify the DG Kernels separately as an addition to a regular kernel, instead of replacing it - see e.g.:\n\n[...]\n[Variables]\n  [./u]\n    order = FIRST\n    family = MONOMIAL\n  [../]\n[]\n\n[Kernels]\n  [./time_u]\n    type = TimeDerivative\n    variable = u\n  [../]\n\n  [./adv_u]\n    implicit = false\n    type = ConservativeAdvection\n    variable = u\n    velocity = '1 0 0'\n  [../]\n[]\n\n[DGKernels]\n  [./dg_advection_u]\n    implicit = false\n    type = DGConvection\n    variable = u\n    velocity = '1 0 0'\n  [../]\n[]\n\n[...]\n(from test/tests/dgkernels/1d_advection_dg/1d_advection_dg.i)\nI stumbled across this as I was trying to modify these simple test cases and noticed the redundant definitions of velocity in this case. Is this a requirement or rather a workaround so the DG schemes fit in nicely with the CG main code of MOOSE?\n\n\nI've looked into the source of some DG Kernels and got the impression that the code uses the same basis for trial and test function, so adhering to the Bubnov instead of Petrov Galerkin method. That would fit into the concept of the \"main\" code as declared here. Is that correct? If so, wouldn't it be more advantageous in terms of assembling the mass matrix to allow for separate function spaces or is this too complicated to implement or otherwise not feasible? Ern and Guermod1 address this issue e.g. in Remark 5.4 p. 225 and in chap. 5.7.\n\n\nWhen looking at the source code and examples, I couldn't find input file entries or info about the upwinding scheme used - which to my knowledge would be required at least for convection-type problems. How is this done in MOOSE? From FV I know some schemes in order to get reasonable tradeoff between diffusivity and stability, e.g. with WENO or TVD schemes (MinMod, SuperBee, etc.). If that's something to still implement into MOOSE, would it be possible to carry these over from the rDG app? I've seen here that some TVD limiters have already been introduced into the rDG scheme. If so, I'd try to do that for myself and when that yields satisfactory results, share the code of course with everyone.\n\n\nLastly, do you guys think that further developing DG Kernels in MOOSE is even worthwhile in comparison with the classic CG-FEM for dealing with hyperbolic PDEs? Surely, CG-FEM (at least as I know it) is better suited for elliptic and parabolic problems, but does anyone know how severe the performance disadvantage for hyperbolic problems is in comparison to e.g. FV or rDG in this case? I'm asking since e.g. in your tutorial sessions (which helped me hugely set foot into the MOOSE ecosystem btw) you deal with advection problems in a fairly confident manner, so I got the impression that problems of such type would not be a big deal for MOOSE. Also, according to your website, even the Navier Stokes app relies on the CG-FEM method which got me wondering quite a bit.\nI know that's a lot of questions, sorry for the long text. Hopefully someone can help shed some light on these topics.\nThanks and have a good weekend,\nPatrick\n\n1: A. Ern, J.-L. Guermond. Theory and Practice of Finite Elements, Springer 2004.",
          "url": "https://github.com/idaholab/moose/discussions/17383",
          "updatedAt": "2022-06-14T22:54:48Z",
          "publishedAt": "2021-03-19T10:25:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad You should probably help out here.",
                  "url": "https://github.com/idaholab/moose/discussions/17383#discussioncomment-503428",
                  "updatedAt": "2022-06-14T22:54:58Z",
                  "publishedAt": "2021-03-19T14:18:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "1. First of all, I'm wondering why you need to specify the DG Kernels separately as an addition to a regular kernel, instead of replacing it - see e.g.:\n\n\nWe use Beatrice Riviere's \"Discontinuous Galerkin Methods for Solving Elliptic and Parabolic Equations: Theory and Implementation\" text for implementing the relatively rudimentary objects you are looking at. The object naming is definitely confusing. One would very reasonably think that DGConvection does everything needed for a DG method...but it doesn't. It instead implements only the convection interior face term. So If you have Riviere's text, DGConvection implements the middle term of equation 4.9. You still need ConservativeAdvection to capture the first term of equation 4.9, e.g. the elemental contributions.\n\n2. I've looked into the source of some DG Kernels and got the impression that the code uses the same basis for trial and test function, so adhering to the Bubnov instead of Petrov Galerkin method. That would fit into the concept of the \"main\" code as declared [here](https://mooseframework.inl.gov/source/problems/FEProblemBase.html#shape_functions). Is that correct? If so, wouldn't it be more advantageous in terms of assembling the mass matrix to allow for separate function spaces or is this too complicated to implement or otherwise not feasible? Ern and Guermod1 address this issue e.g. in Remark 5.4 p. 225 and in chap. 5.7.\n\n\nThis is definitely true for the objects you are looking at. However, an application developer/MOOSE user has complete flexibility to choose the finite element method they wish. An example of this from continuous finite elements draws from the ADKernelStabilized and its child ADKernelSUPG where the user \"strong residual\" (which should look exactly like terms in the non-integrated/strong PDE) is multiplied by velocity * tau * grad_test. Here grad_test is indeed based off the same finite element family and order as the shape function used to evaluate the approximate solution, but this is still a piece of a Petrov-Galerkin method. In general you can write your own kernels, and define computeQpResidual (or its relatives) however you wish. E.g. you are not constrained to multiply by the _test member that corresponds to the Bubnov-Galerkin method.\n\n3\\. When looking at the source code and examples, I couldn't find input file entries or info about the upwinding scheme used - which to my knowledge would be required at least for convection-type problems. How is this done in MOOSE? From FV I know some schemes in order to get reasonable tradeoff between diffusivity and stability, e.g. with WENO or TVD schemes (MinMod, SuperBee, etc.). If that's something to still implement into MOOSE, would it be possible to carry these over from the rDG app? I've seen [here](https://mooseframework.inl.gov/modules/rdg/index.html) that some TVD limiters have already been introduced into the rDG scheme. If so, I'd try to do that for myself and when that yields satisfactory results, share the code of course with everyone.\n\n\nDGConvection uses simple upwinding. We would certainly welcome more advanced convection discretizations in the framework or in our modules. To be honest, the DG kernels that are currently in the framework are probably not used by anyone in \"production\"-level simulations. I do not know too much about our rDG module. Perhaps @andrsd or @joshuahansel can comment more on that. I believe most of rDG development to date has been done with 1D target applications, but I'm not going to say that it won't work in multi-dimensions (simply because I do not know). We have been focusing a lot of development recently on finite volume in MOOSE and we have worked mostly on HLLC for free-flow and porous versions of the Euler equations. I know that rDG has some code for WENO/TVD schemes, including the MinMod and SuperBee that you mentioned.\n\nLastly, do you guys think that further developing DG Kernels in MOOSE is even worthwhile in comparison with the classic CG-FEM for dealing with hyperbolic PDEs? Surely, CG-FEM (at least as I know it) is better suited for elliptic and parabolic problems, but does anyone know how severe the performance disadvantage for hyperbolic problems is in comparison to e.g. FV or rDG in this case? I'm asking since e.g. in your tutorial sessions (which helped me hugely set foot into the MOOSE ecosystem btw) you deal with advection problems in a fairly confident manner, so I got the impression that problems of such type would not be a big deal for MOOSE. Also, according to your website, even the Navier Stokes app relies on the CG-FEM method which got me wondering quite a bit.\n\nI do think that DG/rDG/FV development/use in advection dominated applications is critical/advantageous when compared to CG-FEM. We have done a fair amount of simulation of incompressible Navier-Stokes with CFEM, but I think that in the long haul our discontinuos schemes are going to win out and become the schemes predominantly used by our user-base. CFEM in general struggles around any area of discontinuity whether it be at a corner where you have different boundary conditions meeting, or near shocks. Here is a very relevant figure of CFEM failing to handle the canonical Sod shock-tube problem:\n\nFinite volume development is very heavy right now. I'll point you to the recently merged #15644 and open pull request #17088. I also have a CNSFV branch that I'm currently working on that we'll be submitting a PR to MOOSE for once we receive approval from export control. And with respect to more sophisticated DG/rDG objects compared to those currently in the framework I'll leave that to @andrsd and @joshuahansel",
                  "url": "https://github.com/idaholab/moose/discussions/17383#discussioncomment-519857",
                  "updatedAt": "2022-06-14T22:54:58Z",
                  "publishedAt": "2021-03-23T20:57:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@pzimbrod if you have any follow-on questions, please let me know. We certainly welcome new contributors!!",
                          "url": "https://github.com/idaholab/moose/discussions/17383#discussioncomment-519909",
                          "updatedAt": "2022-06-14T22:56:51Z",
                          "publishedAt": "2021-03-23T21:11:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "When looking at the source code and examples, I couldn't find input file entries or info about the upwinding scheme used\n\nThe rDG module has only implemented the scalar advection equation. Its upwinding scheme is implemented in AEFVUpwindInternalSideFlux, and this is the general strategy - you implement your numerical flux scheme in a flux user object.\n\nFrom FV I know some schemes in order to get reasonable tradeoff between diffusivity and stability, e.g. with WENO or TVD schemes (MinMod, SuperBee, etc.). If that's something to still implement into MOOSE, would it be possible to carry these over from the rDG app?\n\nThere is no generic WENO/TVD capability in the rDG module, just the implementation for the scalar advection equation. The rDG mostly just provides base classes that can be useful for implementing an rDG scheme.",
                  "url": "https://github.com/idaholab/moose/discussions/17383#discussioncomment-520523",
                  "updatedAt": "2022-06-14T22:56:50Z",
                  "publishedAt": "2021-03-23T23:16:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "pzimbrod"
                  },
                  "bodyText": "Thank you both for the valuable insights! Definitely helped me a lot wrapping my head around the DG functionality that's already implemented in MOOSE. I'll look into that subject a little more in the next time and make sure to submit a PR as soon as I get a fruitful solution out of these ideas. I won't dare to make any promises since I come from using OpenFOAM and am rather new to the MOOSE style of getting things done, but definitely will give it a shot.\nPlease keep up the good work, I'd love to see projects like these pick up momentum in all types of applications!",
                  "url": "https://github.com/idaholab/moose/discussions/17383#discussioncomment-521456",
                  "updatedAt": "2022-06-14T22:56:53Z",
                  "publishedAt": "2021-03-24T07:17:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Nonlinear Convergence problem in Phase field",
          "author": {
            "login": "ada-ayy"
          },
          "bodyText": "Dear Moose users:\nI am trying to solve an equation like this:\n\nWhen I set the L to be a constant, it can be well solved.\nHowever, when I try to set L as a function of G (elastic energy, while Gc is the constant critical value), the time step keeps reducing by half. Even if I construct L to be a smooth function of G, it still faces the same problem.\nI have tried to use ParsedMaterial to define the L.\nAlso, I have tried to use AuxVariable/ AuxKernel as below:\n[AuxVariables]\n [./mob]\n  order = CONSTANT\n  family = MONOMIAL\n [../]\n[]\n\n[AuxKernels]\n [./MOB]\n  type =MaterialRealAux\n  property = Fe\n  variable = mob\n [../]\n[]\n\n  [./L]\n    type = ParsedMaterial\n    f_name = L\n    args = 'mob'\n    function = 'if (mob <0.0001, 0, if( mob > 0.002,10,(mob-0.0001)*(mob-0.0001)*(mob-0.002)*(mob-0.002)))'\n    outputs = exodus\n    block = 0\n  [../]\n\nThanks,\nAda",
          "url": "https://github.com/idaholab/moose/discussions/17310",
          "updatedAt": "2023-03-02T08:34:03Z",
          "publishedAt": "2021-03-14T05:09:42Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Ada\nBy the time step keeps reducing by half you mean the non-linear solves are not converging?\nCan you plot the values of L in the domain by converting it to an AuxVariable using a MaterialAuxKernel to see what is happening with L\nI reformatted your code with ``` btw.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17310#discussioncomment-495465",
                  "updatedAt": "2023-03-02T08:34:18Z",
                  "publishedAt": "2021-03-17T19:57:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "Thank you for your reply!\nThis is the distribution of L at t = 0\n\nand this is L at t = 3 (when it gets stuck)\n\n\nAlso, this is the elastic energy Fe at t=3\n\nBy contrast, this is Fe when setting L = constant at 3",
                          "url": "https://github.com/idaholab/moose/discussions/17310#discussioncomment-496776",
                          "updatedAt": "2023-03-02T08:34:21Z",
                          "publishedAt": "2021-03-18T05:55:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "A zero mobility such as this is likely to be a problem when using an implicit time stepping scheme. You could try making your L some very small number like 10^-2 or 10^-3 such that microstructural evolution in the region where G<G_c is negligible. (This is probably more realistic physically anyway because it's unlikely that the mobility of a solute species is identically 0.)  You could also try using an explicit time stepper.",
                          "url": "https://github.com/idaholab/moose/discussions/17310#discussioncomment-504323",
                          "updatedAt": "2023-03-02T08:34:44Z",
                          "publishedAt": "2021-03-19T17:28:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "Thank you for your advice!! I have used 'tanh' as well to solve this problem.",
                          "url": "https://github.com/idaholab/moose/discussions/17310#discussioncomment-521278",
                          "updatedAt": "2023-03-02T08:34:44Z",
                          "publishedAt": "2021-03-24T05:44:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Prefactor of ComputeExtraStressConstant cannot be defined by ParsedFunction",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nFor some reason I cannot define the Prefactor of ComputeExtraStressConstant by ParsedFunction\nI thought it would be straightforward like other properties (density and elastic_tensor), but apparently, it's not.\ncould you please help me have a look?\n[./const_stress]\n  type = ComputeExtraStressConstant\n  block = 1\n  extra_stress_tensor = '1 1 1 0 0 0'\n prefactor = stress_fac1\n[../]\n\nParsedFunction is shown below\n[./stress_fac1]\n  type = ParsedFunction\n  value = 'if(t=2,1e4,1)'\n[../]\n\nerror says One or more Material Properties were not supplied on block 1: stress_fac1\nI reckon it might got something to do with .C file of ComputeExtraStressConstant\nThank you guys,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/17410",
          "updatedAt": "2022-06-15T11:57:38Z",
          "publishedAt": "2021-03-23T05:04:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "For whatever reason, prefactor is a MaterialProperty name.  So you must define something like this\n[Materials]\n  [fac1]\n    type = GenericConstantMaterial\n    prop_names = stress_fac1\n    prop_values = 1234.5\n  []\n\nAlthough the ComputeExtraStressConstant:prefactor says it is Name of material defining additional constant prefactor, i don't see why it needs to be constant.  Perhaps someone can explain the documentation.  It looks like you could also do:\n[Materials]\n  [fac1]\n    type = GenericFunctionMaterial\n    prop_names = stress_fac1\n    prop_values = fac1_fcn\n  []\n[]\n[Functions]\n  [fac1_fcn]\n    type = ParsedFunction\n    value = 'if(t=2,1e4,1)'\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/17410#discussioncomment-516245",
                  "updatedAt": "2022-06-18T21:54:40Z",
                  "publishedAt": "2021-03-23T05:46:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi Andy, thank you, may I ask how does 'GenericFunctionMaterial' knows that I'm calling ComputeExtraStressConstant, I'm a bit confused.",
                          "url": "https://github.com/idaholab/moose/discussions/17410#discussioncomment-516258",
                          "updatedAt": "2022-07-29T10:05:56Z",
                          "publishedAt": "2021-03-23T05:55:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "It doesn't.  GenericFunctionMaterial will calculate a thing called stress_fac1 (the prop_names), regardless of the rest of your input file.  It's up to the ComputeExtraStressConstant to utilize this using its prefactor.  The MOOSE dependency resolver ensures that the GenericFunctionMaterial computes stress_fac1 before it is used by ComputeExtraStressConstant.\nSimilarly, all your other Materials just compute their MaterialProperties, regardless of whether you use them in Kernels etc.  If you really wanted to burden your computer, you could define a million Materials that aren't used by anything, and MOOSE would still compute them.",
                          "url": "https://github.com/idaholab/moose/discussions/17410#discussioncomment-516321",
                          "updatedAt": "2022-07-29T10:05:56Z",
                          "publishedAt": "2021-03-23T06:05:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi Andy, yes, I kinda get it now, basically I need to call both ComputeExtraStressConstant and GenericFunctionMaterial, and it will look like this (very messy though)\n[Materials]\n[./const_stress]\n  type = ComputeExtraStressConstant\n  block = 1\n  extra_stress_tensor = '1 1 1 0 0 0'\n prefactor = stress_fac1\n[../]\n  [fac1]\n    type = GenericFunctionMaterial\n    prop_names = stress_fac1\n    prop_values = fac1_fcn\n  []\n[]\n\n[Functions]\n  [fac1_fcn]\n    type = ParsedFunction\n    value = 'if(t=2,1e4,1)'\n  []\n[]\n\nThank you again for your help! I learn a lot from you here :)\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17410#discussioncomment-516332",
                          "updatedAt": "2022-07-29T10:05:58Z",
                          "publishedAt": "2021-03-23T06:09:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "HeatSource and DerivativeParsedMaterial",
          "author": {
            "login": "hamedattariani"
          },
          "bodyText": "We are solving two coupled transient heat conduction differential equations. The heat source terms (body force) in each equation are functions of temperatures, e.g. A*(T1-T2). So, we used \"HeatSource\" along with \"DerivativeParsedMaterial\" to define the source terms. This implementation does not work, because we see temperature rise, although one sets the heat source to zero. I think this implementation messes up the weak forms. Do I need to write a new kernel for this body force or there is already a kernel for this purpose in MOOSE?\n[./volumetric_heat]\ntype = DerivativeParsedMaterial\nf_name = 'volumetric_heat1'\nargs = 'T1 T2'\nfunction ='(1000)*(T1-T2)'\n[../]",
          "url": "https://github.com/idaholab/moose/discussions/17402",
          "updatedAt": "2022-11-10T21:40:35Z",
          "publishedAt": "2021-03-22T20:19:26Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthere should be an \u2018ambient convection\u2019 kernel of this form in the navier stokes module you may use. I can\u2019t now but I ll have a look later to see if I can post a link to it here\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17402#discussioncomment-515036",
                  "updatedAt": "2022-11-10T21:40:35Z",
                  "publishedAt": "2021-03-22T20:22:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hamedattariani"
                          },
                          "bodyText": "I just looked at the Kernel. \"T_ambient\" is defined as a constant. In our case, T_ambient is the main variable itself.\nThe system of equations is as follow:\nHeat capacityd(T1/dt)=...+(T1-T2)\nHeat capacityd(T2/dt)=...-(T1-T2)",
                          "url": "https://github.com/idaholab/moose/discussions/17402#discussioncomment-515083",
                          "updatedAt": "2022-11-10T21:40:36Z",
                          "publishedAt": "2021-03-22T20:39:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok then you could implement a version with non-constant T_ambient but a coupledVar instead.\nThe finite volume implementation, NSFVEnergyAmbientConvection has it set up that way",
                          "url": "https://github.com/idaholab/moose/discussions/17402#discussioncomment-515285",
                          "updatedAt": "2022-11-10T21:40:37Z",
                          "publishedAt": "2021-03-22T21:36:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Discontinuous boundary conditions",
          "author": {
            "login": "ke7kto"
          },
          "bodyText": "I'm solving a system of coupled equations (heat + diffusion) for a system of concentric rings. There is a gap between the rings, which I would rather not model, that leads to a difference in temperature between the inner-right and outer-left boundaries of the rings. I can specify these as a Dirichlet boundary condition (time-dependent function). I also have a relationship that defines the concentration at either side of the interface as a function of the temperature.\nDo I need to use XFEM to model something like this?  If so, how would I specify a function-based Dirichlet boundary condition, and how would I specify an equilibrium relationship across the boundary?",
          "url": "https://github.com/idaholab/moose/discussions/17363",
          "updatedAt": "2023-03-30T14:01:43Z",
          "publishedAt": "2021-03-17T22:15:10Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "This sounds like something that our Constraints System might handle. I have not used it, perhaps @lindsayad or @bwspenc could verify that I am understanding correctly.",
                  "url": "https://github.com/idaholab/moose/discussions/17363#discussioncomment-503514",
                  "updatedAt": "2023-03-30T14:01:44Z",
                  "publishedAt": "2021-03-19T14:40:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "That looks right. I'll update if/when I get it working.",
                          "url": "https://github.com/idaholab/moose/discussions/17363#discussioncomment-505051",
                          "updatedAt": "2023-03-30T14:01:51Z",
                          "publishedAt": "2021-03-19T21:10:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "I think you're looking for GapHeatTransfer: https://mooseframework.inl.gov/source/bcs/GapHeatTransfer.html",
                  "url": "https://github.com/idaholab/moose/discussions/17363#discussioncomment-509864",
                  "updatedAt": "2023-03-30T14:01:50Z",
                  "publishedAt": "2021-03-21T14:53:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ke7kto"
                          },
                          "bodyText": "That might be a good starting point. Still new here so my terminology might be off, but I would almost describe temperature as an auxiliary variable. I still need to calculate the temperature profile, but I have time-dependent values of the temperature at each edge of each gap. I need to calculate the equilibrium concentration across the gap, assuming fast gas-phase transport. I do have an equation for that. Would you recommend me starting with GapHeatTransfer and extending it?",
                          "url": "https://github.com/idaholab/moose/discussions/17363#discussioncomment-514287",
                          "updatedAt": "2023-03-30T14:01:51Z",
                          "publishedAt": "2021-03-22T17:18:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error running Peacock",
          "author": {
            "login": "ajyano22"
          },
          "bodyText": "Hello,\nI'm pretty new to Moose and Linux in general, I think I have everything set up correctly but I'm still getting errors when trying to run a simulation through peacock. This is the error:\nmoose) [aliyay@aliya-hpspectrex360convertible15ch0xx peacock]$ ./peacock\nNo executable found for method type(s): opt, dbg, oprof, devel\nQXcbConnection: XCB error: 3 (BadWindow), sequence: 2300, resource id: 10515013, major code: 40 (TranslateCoords), minor code: 0\nQXcbConnection: XCB error: 3 (BadWindow), sequence: 2904, resource id: 10517754, major code: 40 (TranslateCoords), minor code: 0\nQXcbConnection: XCB error: 3 (BadWindow), sequence: 3590, resource id: 10519280, major code: 40 (TranslateCoords), minor code: 0\nQXcbConnection: XCB error: 3 (BadWindow), sequence: 3953, resource id: 10526005, major code: 40 (TranslateCoords), minor code: 0\nWARNING\nProblem running '/home/aliyay/projects/moose/modules/combined/practice/workshop2/model_A_equilibrium.i -options_left 0 --json'\nWARNING\nFailed to load json from '/home/aliyay/projects/moose/modules/combined/practice/workshop2/model_A_equilibrium.i': Problem running '/home/aliyay/projects/moose/modules/combined/practice/workshop2/model_A_equilibrium.i -options_left 0 --json'\nError: [Errno 13] Permission denied: '/home/aliyay/projects/moose/modules/combined/practice/workshop2/model_A_equilibrium.i'\nThis says the issue is the permissions but when I check them, it says I should be able to execute these files.\n(moose) [aliyay@aliya-hpspectrex360convertible15ch0xx workshop2]$ ls -la\ntotal 124\ndrwxr-xr-x 3 aliyay aliyay  4096 Mar 17 11:43 .\ndrwxr-xr-x 4 aliyay aliyay  4096 Mar 17 11:26 ..\ndrwx------ 2 aliyay aliyay  4096 Mar 17 11:42 .jitcache\n-rw-r--r-- 1 aliyay aliyay    74 Mar 17 11:43 model_A_eq_1D.csv\n-rw-r--r-- 1 aliyay aliyay 85384 Mar 17 11:43 model_A_eq_1D.e\n-rw-r--r-- 1 aliyay aliyay    13 Mar 17 11:42 model_A_eq_1D_x_direction_0000.csv\n-rw-r--r-- 1 aliyay aliyay  2494 Mar 17 11:43 model_A_eq_1D_x_direction_0001.csv\n-rwxrwxrwx 1 aliyay aliyay  2704 Mar 17 11:23 model_A_equilibrium.i\n-rwxrwxrwx 1 aliyay aliyay  2620 Mar 17 11:23 model_A_growth.i\n-rwxrwxrwx 1 aliyay aliyay  2577 Mar 17 11:23 model_A_shrinkage.i\n-rwxrwxrwx 1 aliyay aliyay  2658 Mar 17 11:23 model_A_shrinkage_n_growth.i\nI'm not sure what the issue is. Any help is appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/17394",
          "updatedAt": "2022-06-30T14:06:27Z",
          "publishedAt": "2021-03-20T21:03:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "You have not compiled your code:  \"No executable found for method type(s): opt, dbg, oprof, devel\". If you are new I suggest working through out tutorial. https://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial01_app_development/index.html",
                  "url": "https://github.com/idaholab/moose/discussions/17394#discussioncomment-513375",
                  "updatedAt": "2022-06-30T14:06:29Z",
                  "publishedAt": "2021-03-22T14:09:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "The error lies in line right after you executed peacock:\nNo executable found for method type(s): opt, dbg, oprof, devel\nWhile you may have built modules, or the the combined module in particular, Peackock does not know how to search that direction. Peacock will search for binaries at your current working directory, and work 'backwards' (parent directory):\n/home/aliyay/projects/moose/python/peacock\n  nope. Go up one directory.\n/home/aliyay/projects/moose/python\n  nope. Go up one directory.\n/home/aliyay/projects/moose\n  nope. Go up one directory. Woops. We hit the root directory, tell the user:\n`No executable found for method type(s): opt, dbg, oprof, devel`\nWhat you need to do, is build the combined module, and then run peacock from either that location, or from the location of your chosen input file (because combined-opt will exist in a parent directory from that location):\ncd /home/aliyay/projects/moose/modules/combined\nmake     # if you haven't done so already\ncd /home/aliyay/projects/moose/modules/combined/practice/workshop2\n/home/aliyay/projects/moose/python/peacock/pecock -i model_A_equilibrium.i\nThat's a lot of paths... Which is why we suggest created a PATH to Peacock so that you can just execute peacock no matter where you are along the file system:\nexport PATH=/home/aliyay/projects/moose/python/peaock:$PATH\ncd /home/aliyay/projects/moose/modules/combined/practice/workshop2\npeacock\n(of course, the same applies: you must have a binary built somewhere in your parent directories).\nI would also suggest throwing that export PATH=/home/aliyay/projects/moose/python/peaock:$PATH in your bash profile, so it is always set.",
                  "url": "https://github.com/idaholab/moose/discussions/17394#discussioncomment-513381",
                  "updatedAt": "2022-06-30T14:06:35Z",
                  "publishedAt": "2021-03-22T14:10:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Water97FluidProperties Problems",
          "author": {
            "login": "YuhangNIU"
          },
          "bodyText": "Hi All,\nI want to use drho_dT in the rho_from_p_T() function in ADMaterial, but when I was typing:\n_\"Real rho, drho_dp, drho_dT;\n_fp.rho_from_p_T(_press[_qp],_temperature[qp],rho,drho_dp,drho_dT)\"\nthe errors occurred:\n\"no matching function for call to 'SinglePhaseFluidProperties::rho_from_p_T.'\"\nand\"candidate expects 2 arguments, 5 provided.\"\nHow can I use drho_dT?\nThanks,\nYuhang",
          "url": "https://github.com/idaholab/moose/discussions/17377",
          "updatedAt": "2022-09-29T12:30:05Z",
          "publishedAt": "2021-03-19T02:44:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSince you are using an ADMaterial you may want to leverage AD to compute the derivatives.\n@lee7632 has a recent fix for these properties and should be able to help\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17377#discussioncomment-501291",
                  "updatedAt": "2022-09-29T12:30:11Z",
                  "publishedAt": "2021-03-19T02:49:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "YuhangNIU"
                          },
                          "bodyText": "Yes. I use the fluid property of drho/dT in ADkernel, thus I need to build it in ADMaterial. I don't know how to use the drho_dT in Water97FluidProperties?",
                          "url": "https://github.com/idaholab/moose/discussions/17377#discussioncomment-501373",
                          "updatedAt": "2023-04-19T21:56:38Z",
                          "publishedAt": "2021-03-19T03:00:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Are _press and _temperature AD variables? If so, that won't work, you would need _press[qp].value() or similar.\nBut if they are AD, then why not use DualReal rho = rho_from_p_T(_press, _temperature) and then rho has the derivative you want?",
                          "url": "https://github.com/idaholab/moose/discussions/17377#discussioncomment-501444",
                          "updatedAt": "2023-04-19T21:56:38Z",
                          "publishedAt": "2021-03-19T03:28:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YuhangNIU"
                          },
                          "bodyText": "Thank you for your replies.\nThe _press and _temprature are AD variables, and _press[qp].value() still doesn't work.\nIf I use DualReal rho = rho_from_p_T(_press, _temperature), the rho can be obtained, but I want to get drho/dT rather than rho.",
                          "url": "https://github.com/idaholab/moose/discussions/17377#discussioncomment-501843",
                          "updatedAt": "2023-04-19T21:56:38Z",
                          "publishedAt": "2021-03-19T06:47:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "I'm pretty sure this would have worked\nReal rho, drho_dp, drho_dT;\n_fp.rho_from_p_T(_press[_qp].value(), _temperature[_qp].value, rho, drho_dp, drho_dT);\n\nand if it doesn't, check for typos.\nBut the\nDualReal rho = rho_from_p_T(_press[_qp],  _temperature[_qp]);\n\ncalculates exactly the same things. You can get the derivate wrt T using\nReal drho_dT = rho.derivatives()[T_index];\n\nwhere T_index is the index of the temperature variable.",
                          "url": "https://github.com/idaholab/moose/discussions/17377#discussioncomment-501900",
                          "updatedAt": "2022-09-29T12:30:12Z",
                          "publishedAt": "2021-03-19T07:20:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YuhangNIU"
                          },
                          "bodyText": "Thank you for your patience!\nFor the first way:\nThe errors in Terminal are as shown:\n_Creating Unity /home/1/projects/zebra/build/unity_src/material_Unity.C\nCompiling C++ (in opt mode) /home/1/projects/zebra/build/unity_src/material_Unity.C...\nIn file included from /home/1/projects/zebra/build/unity_src/material_Unity.C:5:0:\n/home/1/projects/zebra/src/material/TwophaseADMaterial.C: In instantiation of \u2018void TwophaseADMaterial< >::computeQpProperties() [with ComputeStage compute_stage = (ComputeStage)0u]\u2019:\n/home/1/projects/zebra/src/material/TwophaseADMaterial.C:663:1:   required from here\n/home/1/projects/zebra/src/material/TwophaseADMaterial.C:255:3: error: request for member \u2018value\u2019 in \u2018(&((TwophaseADMaterial<(ComputeStage)0u>)this)->TwophaseADMaterial<(ComputeStage)0u>::_press)->MooseArray::operator[](((TwophaseADMaterial<(ComputeStage)0u>)this)->TwophaseADMaterial<(ComputeStage)0u>::.ADMaterial<(ComputeStage)0u>::.Material::_qp)\u2019, which is of non-class type \u2018const double\u2019\n_fp.rho_from_p_T(_press[_qp].value(),_temp_liq[_qp].value(),rho,drho_dp,drho_dT);\n^\n/home/1/projects/zebra/src/material/TwophaseADMaterial.C:255:3: error: request for member \u2018value\u2019 in \u2018(&((TwophaseADMaterial<(ComputeStage)0u>)this)->TwophaseADMaterial<(ComputeStage)0u>::_temp_liq)->MooseArray::operator[](((TwophaseADMaterial<(ComputeStage)0u>)this)->TwophaseADMaterial<(ComputeStage)0u>::.ADMaterial<(ComputeStage)0u>::.Material::qp)\u2019, which is of non-class type \u2018const double\u2019\nmake: *** [/home/1/projects/zebra/build/unity_src/material_Unity.x86_64-pc-linux-gnu.opt.lo] Error 1\nFor the second way:\nHow can I get the index of the temperature variable on the current point(_qp)?\nWhat should I do?\nBest wishes!",
                          "url": "https://github.com/idaholab/moose/discussions/17377#discussioncomment-502043",
                          "updatedAt": "2022-09-29T12:30:21Z",
                          "publishedAt": "2021-03-19T08:11:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "I just checked the first way you tried and it definitely works (it's actually how the AD function is implemented). You must have a typo, or the variables aren't AD, or an old moose version, etc.",
                          "url": "https://github.com/idaholab/moose/discussions/17377#discussioncomment-511436",
                          "updatedAt": "2022-09-29T12:30:24Z",
                          "publishedAt": "2021-03-22T04:02:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Can you make your code available so we can take a look? It might make this easier.",
                          "url": "https://github.com/idaholab/moose/discussions/17377#discussioncomment-511437",
                          "updatedAt": "2022-09-29T12:30:24Z",
                          "publishedAt": "2021-03-22T04:03:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YuhangNIU"
                          },
                          "bodyText": "Thank you for your reply,\nI have solved this problem. Maybe the reason is that I have an old moose version.\nWhen I used MetaPhysicL::raw_value(_press[_qp]) instead of _press[_qp].value(), it worked!\nThank you again for your patience\uff01\nBest wishes!",
                          "url": "https://github.com/idaholab/moose/discussions/17377#discussioncomment-512100",
                          "updatedAt": "2022-09-29T12:30:24Z",
                          "publishedAt": "2021-03-22T08:53:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}