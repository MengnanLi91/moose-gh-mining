{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNy0yMlQwOTo0MDo1Ni0wNTowMM4ANPHp"
    },
    "edges": [
      {
        "node": {
          "title": "Linear solutions to a nonlinear equation",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I am applying the following two kernels, TimeDerivative and BodyForce to solve the equation d/dt(u)=-Cu. The problem is an initial condition problem. The numerical solution from MOOSE results in a linear decrease in u over the time period. The analytical solution results in a exponential decrease in u over time. Is there a better combination of kernels that should be applied in order to get the expected exponential decrease in u?",
          "url": "https://github.com/idaholab/moose/discussions/18417",
          "updatedAt": "2022-08-11T07:36:01Z",
          "publishedAt": "2021-07-23T18:07:21Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think you mean to use CoupledForce. BodyForce is just C not Cu\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18417#discussioncomment-1043790",
                  "updatedAt": "2022-08-11T07:36:00Z",
                  "publishedAt": "2021-07-23T20:38:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you for the assistance. I changed the kernel to a CoupledForce, the result was the same linear trend. I then added Diffusion of the coupled v value of the CoupledForce. The results was also the same as the previous two methods used.",
                          "url": "https://github.com/idaholab/moose/discussions/18417#discussioncomment-1044294",
                          "updatedAt": "2022-08-11T07:36:12Z",
                          "publishedAt": "2021-07-24T01:04:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "How many time steps are you taking?\nDid you specify \u2018v=u\u2019 for the couples force kernel?",
                          "url": "https://github.com/idaholab/moose/discussions/18417#discussioncomment-1044454",
                          "updatedAt": "2022-08-11T07:36:12Z",
                          "publishedAt": "2021-07-24T03:21:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Current 130 time steps. Have used up to 13000 time steps with the same result. I did not set v = u.",
                          "url": "https://github.com/idaholab/moose/discussions/18417#discussioncomment-1044460",
                          "updatedAt": "2022-08-11T07:36:13Z",
                          "publishedAt": "2021-07-24T03:25:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Tried to define v = u. Got the following message: Coupled variable 'v' needs to be different from 'variable' with CoupledForce, consider using Reaction or somethig similar.",
                          "url": "https://github.com/idaholab/moose/discussions/18417#discussioncomment-1044463",
                          "updatedAt": "2024-02-14T19:06:18Z",
                          "publishedAt": "2021-07-24T03:27:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You should use the CoefReaction kernel for the reaction term. https://mooseframework.inl.gov/moose/source/kernels/CoefReaction.html",
                          "url": "https://github.com/idaholab/moose/discussions/18417#discussioncomment-1044468",
                          "updatedAt": "2024-02-14T19:06:19Z",
                          "publishedAt": "2021-07-24T03:35:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "That was the final missing piece, CoefReaction. Thank you both for helping me with this. The trend of the numerical solution is now in proper agreement with the analytical solution.",
                          "url": "https://github.com/idaholab/moose/discussions/18417#discussioncomment-1044486",
                          "updatedAt": "2021-07-24T03:52:20Z",
                          "publishedAt": "2021-07-24T03:51:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "TLWise"
                  },
                  "bodyText": "Implementation of this provided the solutions to the nonlinear trend of the numerical solution:\nhugary1995:   You should use the CoefReaction kernel for the reaction term. https://mooseframework.inl.gov/moose/source/kernels/CoefReaction.html.",
                  "url": "https://github.com/idaholab/moose/discussions/18417#discussioncomment-1045868",
                  "updatedAt": "2022-08-11T07:36:13Z",
                  "publishedAt": "2021-07-24T18:31:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I ll review the documentation to make sure everything is clear. There should not be a confusion between BodyForce/CoupledForce and Reaction.",
                          "url": "https://github.com/idaholab/moose/discussions/18417#discussioncomment-1046355",
                          "updatedAt": "2022-08-11T07:36:15Z",
                          "publishedAt": "2021-07-25T01:00:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question on the KKS AC kernels",
          "author": {
            "login": "xueyang94"
          },
          "bodyText": "Hi everyone,\nThere might be something really simple that I misunderstood, but why both the KKSACBulkC and KKSACBulkF kernels do not have the mobility L multiplied to their residual and on-diagonal Jacobian? Only the off-diagonal Jacobian is multiplied by L. Another kernel for the order parameter, ACInterface however, has the L in its residual and Jacobian functions. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/18329",
          "updatedAt": "2022-06-09T07:53:48Z",
          "publishedAt": "2021-07-14T15:04:33Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@jiangwen84 if you could please help with this question",
                  "url": "https://github.com/idaholab/moose/discussions/18329#discussioncomment-1024824",
                  "updatedAt": "2022-06-09T07:53:48Z",
                  "publishedAt": "2021-07-20T05:19:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "The non split KKS formulation is not recommended for use. Please use the split formulation. The non split has faulty Jacobians.",
                  "url": "https://github.com/idaholab/moose/discussions/18329#discussioncomment-1044173",
                  "updatedAt": "2022-06-09T07:53:50Z",
                  "publishedAt": "2021-07-23T23:52:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Source: I wrote all those classes",
                          "url": "https://github.com/idaholab/moose/discussions/18329#discussioncomment-1044174",
                          "updatedAt": "2022-06-09T07:53:52Z",
                          "publishedAt": "2021-07-23T23:52:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "@dschwen Yes I am indeed using the split formulation by KKSACBulkC, KKSACBulkF, ACInterface, KKSSplitCHCRes, and SplitCHWRes. I am wondering why in the KKSACBulkC and KKSACBulkF, the residual and on-diagonal Jacobian terms are not multiplied by the Allen-Cahn mobility L, and only the off-diagonal Jacobian is multiplied by L?",
                          "url": "https://github.com/idaholab/moose/discussions/18329#discussioncomment-1044253",
                          "updatedAt": "2022-06-09T07:53:52Z",
                          "publishedAt": "2021-07-24T00:29:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Ah, I see, the L is further up in the class hierarchy at\n\n  \n    \n      moose/modules/phase_field/include/kernels/ACBulk.h\n    \n    \n        Lines 84 to 93\n      in\n      7a8db3f\n    \n  \n  \n    \n\n        \n          \n           template <typename T> \n        \n\n        \n          \n           Real \n        \n\n        \n          \n           ACBulk<T>::precomputeQpResidual() \n        \n\n        \n          \n           { \n        \n\n        \n          \n             // Get free energy derivative from function \n        \n\n        \n          \n             Real dFdop = computeDFDOP(Residual); \n        \n\n        \n          \n            \n        \n\n        \n          \n             // Set residual \n        \n\n        \n          \n             return _L[_qp] * dFdop; \n        \n\n        \n          \n           }",
                          "url": "https://github.com/idaholab/moose/discussions/18329#discussioncomment-1045589",
                          "updatedAt": "2022-06-09T07:53:52Z",
                          "publishedAt": "2021-07-24T15:46:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Just follow the call chain. computeDFDOP is what gets overridden by the KKSACBulkC and KKSACBulkF kernels. The offdiagonal Jacobian is handled a bit differently, as it does not use anything from the ACBulk base class, and all contributions (including the L) are implemented there directly.",
                          "url": "https://github.com/idaholab/moose/discussions/18329#discussioncomment-1045594",
                          "updatedAt": "2022-06-14T11:40:31Z",
                          "publishedAt": "2021-07-24T15:48:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "@dschwen Got it. With the local solve approach though, currently the KKS kernels directly inherit from the Kernel class. They just use the computeQpResidual and computeQpJacobian instead of computeDFDOP. In that case, the mobility L needs to be multiplied in the residual and Jacobian. The hierarchy could be changed in the future if needed. Thanks for clearing that up.",
                          "url": "https://github.com/idaholab/moose/discussions/18329#discussioncomment-1046348",
                          "updatedAt": "2022-06-14T11:40:27Z",
                          "publishedAt": "2021-07-25T00:48:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to use the value calculated from postprocessors in the \"DerivativeParsedMaterial\" type \"Material\"",
          "author": {
            "login": "wenpeng231024"
          },
          "bodyText": "Dear MOOSE group,\nI use the order parameter and \"ElementIntegralVariablePostprocessor\" to calculate the bubble size in the Postprocessors.\n[./bubble_area]\ntype = ElementIntegralVariablePostprocessor\nvariable = eta\nexecute_on = 'INITIAL TIMESTEP_END'\n[../]\nThen I try to use this calculated value in the \"DerivativeParsedMaterial\" type \"Material\".\n[R_bubble]\ntype = DerivativeParsedMaterial\nf_name = R_bubble\nfunction = 'sqrt(bubble_area/3.1415926)'\npostprocessor_names = 'bubble_area'\nderivative_order = 1\noutputs = 'exodus'\n[]\nBut this is some error:\nInvalid function\nsqrt(bubble_area/3.1415926)\nin ParsedMaterialHelper.\nSyntax error: Unknown identifier\nDoes anyone know why this happens? It seems like \"DerivativeParsedMaterial\" cannot get the 'bubble_area' from the postprocessor.\nMany thanks,\nPeng",
          "url": "https://github.com/idaholab/moose/discussions/18403",
          "updatedAt": "2022-10-24T13:19:06Z",
          "publishedAt": "2021-07-21T18:49:21Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Peng\nMaybe it s an issue with the derivative order parameter? What derivative are you planning on having?\nThe syntax looks fine to me otherwise\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18403#discussioncomment-1034519",
                  "updatedAt": "2022-10-24T13:19:21Z",
                  "publishedAt": "2021-07-21T19:20:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wenpeng231024"
                          },
                          "bodyText": "Hi Guillaume,\nThanks for your reply. I use ParsedMaterial and try it again. But still have the same error. Maybe the \"postprocessor_names = 'bubble_area'\" in the \"Material\" do not work.\nI found a similar discussion. \"Use a GenericFunctionMaterial to capture the PostProcessor value and add it to ParsedMaterial using the material_property_names parameter\".\n#15784\nIt can work using that approach!\nPeng",
                          "url": "https://github.com/idaholab/moose/discussions/18403#discussioncomment-1034904",
                          "updatedAt": "2022-10-24T13:19:22Z",
                          "publishedAt": "2021-07-21T21:37:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "That's not a satisfactory solution! test/tests/materials/derivative_material_interface/postprocessors.i shows that the postprocessor_names parameter is working. I'm checking out your example now.",
                          "url": "https://github.com/idaholab/moose/discussions/18403#discussioncomment-1037993",
                          "updatedAt": "2022-10-24T13:19:24Z",
                          "publishedAt": "2021-07-22T14:24:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "The input snippet above works for me. Please make sure you are not getting any warnings from your MOOSE app and double check the spelling in your input. You might want to attach a complete input file if possible.",
                  "url": "https://github.com/idaholab/moose/discussions/18403#discussioncomment-1038016",
                  "updatedAt": "2022-10-24T13:19:27Z",
                  "publishedAt": "2021-07-22T14:27:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wenpeng231024"
                          },
                          "bodyText": "I run the example test/tests/materials/derivative_material_interface/postprocessors.i. But I got the error:\nLmod is automatically replacing \"python/3.8\" with \"vtk/8.2.0\".\n\ufffd[31m\n*** ERROR ***\nInvalid function\ntime^2\nin ParsedMaterialHelper.\nSyntax error: Unknown identifier\ufffd[39m\nsrun: Job step aborted: Waiting up to 32 seconds for job step to finish.\n\ufffd[31m\n*** ERROR ***\nInvalid function\ntime^2\nin ParsedMaterialHelper.\nSyntax error: Unknown identifier\ufffd[39m\n\nMPI_ABORT was invoked on rank 0 in communicator MPI_COMM_WORLD\nwith errorcode 1.\nNOTE: invoking MPI_ABORT causes Open MPI to kill all MPI processes.\nYou may or may not see output from other processes, depending on\nexactly when Open MPI kills them.\n\nMPI_ABORT was invoked on rank 1 in communicator MPI_COMM_WORLD\nwith errorcode 1.\nNOTE: invoking MPI_ABORT causes Open MPI to kill all MPI processes.\nYou may or may not see output from other processes, depending on\nexactly when Open MPI kills them.\nslurmstepd: error: *** STEP 5345226.0 ON c0700a-s18 CANCELLED AT 2021-07-22T11:10:42 ***\nsrun: error: c0700a-s18: tasks 0-1: Exited with exit code 1\nIs this the problem with my MOOSE app?",
                          "url": "https://github.com/idaholab/moose/discussions/18403#discussioncomment-1038257",
                          "updatedAt": "2022-10-24T13:19:34Z",
                          "publishedAt": "2021-07-22T15:13:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Ok, step one is to run all the tests in MOOSE. All tests should pass. If they don't, you have a different problem entirely.",
                          "url": "https://github.com/idaholab/moose/discussions/18403#discussioncomment-1038270",
                          "updatedAt": "2022-10-24T13:19:43Z",
                          "publishedAt": "2021-07-22T15:17:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "What system are you on?",
                          "url": "https://github.com/idaholab/moose/discussions/18403#discussioncomment-1045605",
                          "updatedAt": "2022-10-24T13:19:43Z",
                          "publishedAt": "2021-07-24T15:51:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wenpeng231024"
                          },
                          "bodyText": "I update the MOOSE and run it again. It can work now! I think it's because of the version.\nMany thanks.\nPeng",
                          "url": "https://github.com/idaholab/moose/discussions/18403#discussioncomment-1045646",
                          "updatedAt": "2022-10-24T13:19:43Z",
                          "publishedAt": "2021-07-24T16:15:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Initial conditions for multiple blocks",
          "author": {
            "login": "ritamcj"
          },
          "bodyText": "Hi Moose users,\nI am looking into multiphase simulations in which each phase is defined by a block. I would like to assign initial values of a variable to each block, say c=0.6 for block 1 and c=0.4 for block 2. It would look something like:\n[./eta1]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n    variable = c\n    type = ?\n    value = '0.6   0.4'\n    block = '1   2'\n    [../]\n  [../]\n\nWhat could be the type in this code? I tried ConstantIC, ArrayConstantIC, ScalarComponentIC but could not get the syntax right. I would like to avoid Boundingbox as the blocks may not always be box-shaped as attached.\nWarm regards,\nRitam Chatterjee\nIIT Bombay, India",
          "url": "https://github.com/idaholab/moose/discussions/18422",
          "updatedAt": "2022-12-27T12:34:32Z",
          "publishedAt": "2021-07-24T04:37:27Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can follow this example: https://github.com/idaholab/moose/blob/next/test/tests/ics/constant_ic/subdomain_constant_ic_test.i",
                  "url": "https://github.com/idaholab/moose/discussions/18422#discussioncomment-1045547",
                  "updatedAt": "2022-12-27T12:34:42Z",
                  "publishedAt": "2021-07-24T15:16:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Thank you Gary. This works perfect!\nBest regards,\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/18422#discussioncomment-1045583",
                          "updatedAt": "2022-12-27T12:34:42Z",
                          "publishedAt": "2021-07-24T15:42:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Material Derivative with Respect to x",
          "author": {
            "login": "nsundquist"
          },
          "bodyText": "Hi everyone,\nI'm currently trying to create a custom kernel and I need to calculate the derivative of a material with respect to x. I have been using SplitCHCParsed.C as an example to do this.\nThis is the code I have right now for getting the derivative:\nCoefDiffusionMod::CoefDiffusionMod(const InputParameters & parameters) :  DerivativeMaterialInterface<JvarMapKernelInterface<SplitCHCRes>>(parameters), _dFdc(getMaterialPropertyDerivative<Real>(\"m_name\", _var.name())) { }\nReal CoefDiffusionMod::computeDFDC(PFFunctionType type) { return _dFdc[_qp]; }\nI hope someone can shed some light on how to use x in place of _var.name() if it is possible.\nThanks,\nNathan",
          "url": "https://github.com/idaholab/moose/discussions/18415",
          "updatedAt": "2022-06-06T07:30:43Z",
          "publishedAt": "2021-07-22T23:21:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo you're looking for the first component of the gradient. You can't take gradients of material properties in moose right now, but you can use a MaterialRealAux kernel to turn the material property into an aux variable, then get the gradient of that.\nThe only issue is that aux variables do not leverage automatic differentiation, so the Jacobian will no longer be exact just using AD. If this becomes a problem, you can remedy this by re-writing the computeJacobian routine to add the contribution of the gradient of the material property manually.\nPlease do not paste screenshots in your future posts, they are not searchable\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18415#discussioncomment-1039936",
                  "updatedAt": "2022-06-13T20:03:22Z",
                  "publishedAt": "2021-07-22T23:43:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you are on a longer time scale (at least a few months), we are in the midst of developing a new functor-based on-demand material system that will be able to do this.",
                          "url": "https://github.com/idaholab/moose/discussions/18415#discussioncomment-1040164",
                          "updatedAt": "2022-06-13T20:03:22Z",
                          "publishedAt": "2021-07-23T01:39:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Finally 3rd option, inspired by @hugary1995 's idea, you can define a material that is simply grad_F (or dF_dx if you only need the x-derivative) and do the chain rule yourself, using the gradient of each variable this material depends on.",
                          "url": "https://github.com/idaholab/moose/discussions/18415#discussioncomment-1042018",
                          "updatedAt": "2022-06-13T20:03:23Z",
                          "publishedAt": "2021-07-23T11:58:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "@dschwen Do you think it is possible to let derivative parsed material to compute spatial gradient? I am just curious what if we ask the users to provide all coupled variables to args, and then use the chain rule to provide the gradients, like\ndF_dx = dF_da * da_dx + dF_db * db_dx + dF_dc * dc_dx\n\nwhere args = 'a b c'.",
                  "url": "https://github.com/idaholab/moose/discussions/18415#discussioncomment-1040107",
                  "updatedAt": "2022-06-13T20:03:35Z",
                  "publishedAt": "2021-07-23T01:14:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Urgh, I guess then we are ignoring all chain rules associated with inhomogeneous material properties...",
                          "url": "https://github.com/idaholab/moose/discussions/18415#discussioncomment-1040116",
                          "updatedAt": "2022-06-13T20:03:39Z",
                          "publishedAt": "2021-07-23T01:18:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "@hugary1995 DerivativeParsedMaterial has support for chain rule derivatives for inhomogeneous material properties!",
                          "url": "https://github.com/idaholab/moose/discussions/18415#discussioncomment-1044168",
                          "updatedAt": "2022-06-13T20:03:39Z",
                          "publishedAt": "2021-07-23T23:47:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "So in short, it is possible, but it will require a bit more work (as the inhomogeneous material properties require two layers of chain rule derivatives).\nWe're doing the gradient calculation this way routinely in the phase field module!",
                          "url": "https://github.com/idaholab/moose/discussions/18415#discussioncomment-1044170",
                          "updatedAt": "2022-06-13T20:03:39Z",
                          "publishedAt": "2021-07-23T23:49:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Running Chigger to extract images from output files",
          "author": {
            "login": "Amir1361"
          },
          "bodyText": "Hi\nI wrote a python script to extract the images from MOOSE output files. The code works well on my personal computer (Linux), but I get a Segmentation fault when I run it on a cluster computer. I use Chigger as below:\nreader = chigger.exodus.ExodusReader(filepath)\nreader.setOptions(block=['0'])\nresult = chigger.exodus.ExodusResult(reader)\nresult.setOptions(edge_color=[0, 0, 0], variable='c1', block=['0'], cmap='grayscale', local_range=True, camera=camera)\nwindow = chigger.RenderWindow(result, offscreen=True)\nprint(\"after chigger.RenderWindow\")\nimagename =\u201d%s_100hr.jpg\"%folder[4:]\n#window.start()\nprint(\"before window.write, imagename is \",imagename)\nwindow.write(imagename)\nprint(\"after chigger.RenderWindow\")\nThe segmentation error comes up with \"window.write(imagename)\". Could you please help me to solve this problem?\nThanks\nAmir",
          "url": "https://github.com/idaholab/moose/discussions/17320",
          "updatedAt": "2023-07-11T02:19:44Z",
          "publishedAt": "2021-03-15T17:47:30Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "chigger needs an active display for rendering. In theory there should be a way to compile VTK to operate using software rendering. We have tried several times over the years to get that working, but have failed in each attempt.",
                  "url": "https://github.com/idaholab/moose/discussions/17320#discussioncomment-485602",
                  "updatedAt": "2023-07-11T02:19:45Z",
                  "publishedAt": "2021-03-15T19:24:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Amir1361"
                          },
                          "bodyText": "Thank you for your reply. If I understood you correctly, I need to have GUI to run Chigger. So, using offscreen=true in window = chigger.RenderWindow(result, offscreen=True) is not enough, and we will get a segmentation error.",
                          "url": "https://github.com/idaholab/moose/discussions/17320#discussioncomment-485703",
                          "updatedAt": "2024-09-13T13:28:34Z",
                          "publishedAt": "2021-03-15T19:47:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "Correct. The \"offscreen=True\" just doesn't show the window, but still requires openGL and a screen. I need to improve the error message for this case. Better yet figure out how to make it work, but that will be awhile, if ever.",
                          "url": "https://github.com/idaholab/moose/discussions/17320#discussioncomment-485723",
                          "updatedAt": "2024-09-13T13:28:34Z",
                          "publishedAt": "2021-03-15T19:51:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Amir1361"
                          },
                          "bodyText": "Got it! Thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/17320#discussioncomment-485729",
                          "updatedAt": "2024-09-13T15:29:11Z",
                          "publishedAt": "2021-03-15T19:53:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Amir1361"
                  },
                  "bodyText": "@aeslaughter\nHi Andrew,\nI am running the python code based on chigger to extract microstructures from MOOSE output files. I have more than 2000 output folders with 61 output files inside them. In fact, I want to extract more than 120,000 images. The code is doing well on the small number of output directories (less than 50). But when I want to run it for all 2000 directories, I get the following error message:\nwith open(filename, \"a+\") as f: # \"a+\" to make sure it gets created\nOSError: [Errno 5] Input/output error: '/run/user/1001/gvfs/smb-share:server=cifs-prd-01,share=research/MahmoodMamivand/common/CMDLab/Fe_Cr_Co/time_temp_comp/MOOSE_results/run_cr0.05_co0.35_T870/FeCrCo_cr0.05_co0.35_T870_exodus.e-s043'\n\nExodus Library Warning/Error: [vtkexodusII_ex__check_valid_file_id]\nERROR: In \"vtkexodusII_ex_close\", the file id 65536 was not obtained via a call to \"ex_open\" or \"ex_create\".\n\tIt does not refer to a valid open exodus file.\n\tAborting to avoid file corruption or data loss or other potential problems.\n\n65536 is the maximum 16-bit integer + 1, so I'm hitting a limit somewhere. Does the chigger interface have a method to clean up its internals? What is your suggestion? Thank you very much for your consideration,\nSincerely,\nAmir\noutput.txt",
                  "url": "https://github.com/idaholab/moose/discussions/17320#discussioncomment-1016852",
                  "updatedAt": "2024-09-13T15:29:12Z",
                  "publishedAt": "2021-07-17T20:02:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "This is some sort of system limitation and an unsure of the proper fix, I am wondering if it is as easy as changing the ulimit. @milljm has more experience in this realm, perhaps he can chime in.",
                          "url": "https://github.com/idaholab/moose/discussions/17320#discussioncomment-1022538",
                          "updatedAt": "2024-09-13T15:29:13Z",
                          "publishedAt": "2021-07-19T15:26:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Amir1361"
                          },
                          "bodyText": "Thanks for your response. I tried  ulimit before. It doesn't work for me.",
                          "url": "https://github.com/idaholab/moose/discussions/17320#discussioncomment-1022966",
                          "updatedAt": "2024-09-13T15:29:15Z",
                          "publishedAt": "2021-07-19T16:52:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "You might want to try offloading the data onto a hard disk location (if I am reading that mount point correctly /media). Is that a thumb stick?\nOr, try moving the data to a Unix filesystem such as EXT (if it's in fact a SMB mount to a Windows share). The last I heard (which was a long time ago, and I am probably wrong), is reading/writing to NTFS filesystems and the like was experimental.",
                          "url": "https://github.com/idaholab/moose/discussions/17320#discussioncomment-1039949",
                          "updatedAt": "2024-09-13T15:29:15Z",
                          "publishedAt": "2021-07-22T23:50:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Amir1361"
                          },
                          "bodyText": "Thank you Jason, I read the output files from Windows share storage (SMB). It's interesting because it works well when I run it on a small number of output directories (less than 50). I will test your suggestions. Thanks again!",
                          "url": "https://github.com/idaholab/moose/discussions/17320#discussioncomment-1040014",
                          "updatedAt": "2024-09-13T15:29:15Z",
                          "publishedAt": "2021-07-23T00:25:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issue with compiling on WSL with old libmesh version",
          "author": {
            "login": "louisBS"
          },
          "bodyText": "Hi all,\nI'm trying to install MOOSE on a Windows laptop. I've followed the \"Getting Started\" guide on WSL and Conda MOOSE environment installation. To compile my code I have to use an old version of libmesh (2021.01.14 is the last one that works without any conflict to resolve). So I tried to roll back to that version but I have the following warning when doing so:\nVerifying transaction: -\nSafetyError: The package for moose-libmesh located at /home/louis/miniconda3/pkgs/moose-libmesh-2021.01.14-build_1\nappears to be corrupted. The path 'libmesh/include/libmesh/fparser.hh'\nhas an incorrect size.\nreported size: 8484 bytes\nactual size: 8192 bytes\nSafetyError: The package for moose-libmesh located at /home/louis/miniconda3/pkgs/moose-libmesh-2021.01.14-build_1\nappears to be corrupted. The path 'libmesh/include/libmesh/fparser_ad.hh'\nhas an incorrect size.\nreported size: 7394 bytes\nactual size: 4096 bytes\nWhen I try to compile after that I get all sorts of errors with FunctionParser. Do you have any idea of what's wrong? I must add that I already tried to uninstall and reinstall the conda moose environment but I still run into the same issue. Another thing that might be related: the first time I tried to downgrade libmesh to 2021.01.14, I did not see the aforementioned error message and everything went fine during compiling (no error message about FunctionParser) until my computer crashed in the middle of the process...\nThank you,\nLouis",
          "url": "https://github.com/idaholab/moose/discussions/18407",
          "updatedAt": "2023-03-05T00:04:45Z",
          "publishedAt": "2021-07-21T22:32:20Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "I think every issue you are experiencing is due to our recent moose-libmesh dependency problem.\nThe details are available here, as well as the solution: #18378 to that specific issue.\nI would ask that you simply \"Try Again\" by following the advice given in the aforementioned link. Basically, the steps will be:\nconda deactivate\nconda clean --all       # <-- adding this specifically in your case\nconda env remove -n moose\nconda create -n moose moose-libmesh moose-tools\nconda activate moose\nI added an additional step, as you do seem to possibly have a corrupted tarball package. I am not sure how that happened. But they fix is simple.\nAlso note: If conda install takes forever to solve (or begin), I would suggest using mamba. The details of which are also in the link above.",
                  "url": "https://github.com/idaholab/moose/discussions/18407#discussioncomment-1037758",
                  "updatedAt": "2023-03-05T00:04:46Z",
                  "publishedAt": "2021-07-22T13:34:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "louisBS"
                          },
                          "bodyText": "Thank you Jason I will try that :)",
                          "url": "https://github.com/idaholab/moose/discussions/18407#discussioncomment-1037902",
                          "updatedAt": "2021-07-22T14:09:11Z",
                          "publishedAt": "2021-07-22T14:09:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "louisBS"
                          },
                          "bodyText": "So I tried the steps you suggested, including the conda clean --all step, however, I still have the same corrupted package issue when downloading the 2021.01.14 version of moose-libmesh, leading to the same Function Parser related errors when compiling. Do you have any idea of what the issue might be?",
                          "url": "https://github.com/idaholab/moose/discussions/18407#discussioncomment-1038344",
                          "updatedAt": "2021-07-22T15:32:08Z",
                          "publishedAt": "2021-07-22T15:32:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I do not know what is causing the package to become corrupt... We have many machines which are downloading the very same package without error.\nI don't think the package itself is corrupt, but lets test that. Can you curl the file manually, and perform an shasum on it?\ncurl -L -O https://anaconda.org/idaholab/moose-libmesh/2021.07.14/download/linux-64/moose-libmesh-2021.07.14-build_0.tar.bz2\n\n# Your SHA should match mine:\nsha256sum moose-libmesh-2021.07.14-build_0.tar.bz2 \n4da68980e558030de93d658f2ac7ac5ead3f1c2892199f8f172898daa381a1f1  moose-libmesh-2021.07.14-build_0.tar.bz2\nIf the above failed, we are standing up a new server to host our moose packages, if you would like to give that a try:\nconda deactivate\nconda config --remove channels idaholab\nconda config --add channels https://conda.software.inl.gov/public\nconda config --env --set ssl_verify false          # <-- we don't have a proper SSL cert in place just yet\nconda create -n new-moose moose-libmesh\nJust installing moose-libmesh, to quickly test a corrupt package...\nIs your MOOSE repo up-to-date?\ncd moose\ngit fetch origin\ngit rebase origin/master\nOther than the above I don't understand how the file is becoming corrupt. When you're finished troubleshooting, you may want to re-enable SSL:\nconda config --remove channels https://conda.software.inl.gov/public\nconda config --add channels idaholab\nconda config --env --set ssl_verify true",
                          "url": "https://github.com/idaholab/moose/discussions/18407#discussioncomment-1038554",
                          "updatedAt": "2023-03-05T00:04:56Z",
                          "publishedAt": "2021-07-22T16:20:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@milljm I think he is trying to download an older version of libMesh from January.\n@louisBS can you tell us your moose commit hash?",
                          "url": "https://github.com/idaholab/moose/discussions/18407#discussioncomment-1039521",
                          "updatedAt": "2023-03-05T00:04:56Z",
                          "publishedAt": "2021-07-22T20:58:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "@hugary1995 you're right, I didn't see that. I suppose then, why is Conda doing that? The latest available packages have no dependency failures. The steps I outlined in my first response should have worked.\nThis statement sorta threw me for a loop:\nTo compile my code I have to use an old version of libmesh (2021.01.14 is the last one that works without any conflict to resolve)\nI thought the conflict reference was to an actual conflict being caused by Conda packages. Which did happen recently.\nSo, @louisBS you are purposefully installing an older moose-libmesh and getting a corrupted download? I tried the below, but received no errors after installation. Admittedly I am using mamba, not conda, as I no longer have a stomach for the slow solve times (conda install mamba).\n$> mamba create -n testing moose-libmesh=2021.01.14 moose-tools\n<trimmed>\nFinished moose-libmesh                        (00m:17s)              52 MB      3 MB/s\nDownloading  [================================================] (00m:50s)   23.22 MB/s\nExtracting   [================================================] (00m:50s)      58 / 58\nPreparing transaction: done\nVerifying transaction: done\nExecuting transaction: done\n#\n# To activate this environment, use\n#\n#     $ conda activate testing\n#\n# To deactivate an active environment, use\n#\n#     $ conda deactivate",
                          "url": "https://github.com/idaholab/moose/discussions/18407#discussioncomment-1039589",
                          "updatedAt": "2023-03-05T00:05:00Z",
                          "publishedAt": "2021-07-22T21:15:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "louisBS"
                          },
                          "bodyText": "@milljm @hugary1995 Yes, sorry for being unclear, I am indeed purposefully installing an older moose-libmesh. I just solved my problem by installing the same 2021.01.14 version of moose-libmesh but with mamba instead of conda as you suggested. It doesn't make much sense to me but I'm happy it works. Now my code compiles and runs just fine! Thank you for your time and answers guys.\nIf that can be of any interest for future troubleshooting, as I mentioned in my first message, the first time I tried to install libmesh 2021.01.14 a few days ago with conda it went fine (no message about corrupted packages) but my computer crashed while compiling. It's only after restarting my computer and trying to compile again that I got errors when compiling, as well as the message about corrupted package when trying to re-install the 2021.01.14 libmesh. As I just said, using mamba install instead of conda install solved the corrupted package issue.",
                          "url": "https://github.com/idaholab/moose/discussions/18407#discussioncomment-1039778",
                          "updatedAt": "2023-03-05T00:05:00Z",
                          "publishedAt": "2021-07-22T22:37:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "mamba is just full of surprises \ud83c\udf89",
                          "url": "https://github.com/idaholab/moose/discussions/18407#discussioncomment-1039784",
                          "updatedAt": "2023-03-05T00:05:01Z",
                          "publishedAt": "2021-07-22T22:39:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ACMultiInterface kernel: kappa as a function of a variable?",
          "author": {
            "login": "scottedmuller"
          },
          "bodyText": "Hi everyone,\nI'm trying to implement the ACMultiInterface kernel in a 3-phase system and I would like the kappa terms to be functions of a separate order parameter (a different one than the \"eta\" order parameters from the interface). If a kappa term is defined as a DerivativeParsedMaterial as a function of theta (for example), will the changing value of kappa with theta be reflected in the ACMultiInterface kernel? And more importantly, will the ACMultiInterface kernel include the gradient of theta as it computes the divergence of the interface terms? If using a kappa term as a function of another variable is not possible, is there a workaround to get an equivalent effect?\nThanks,\nScott",
          "url": "https://github.com/idaholab/moose/discussions/18299",
          "updatedAt": "2022-06-09T07:55:29Z",
          "publishedAt": "2021-07-10T00:30:06Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "SudiptaBiswas"
                  },
                  "bodyText": "It's not clear to me what you are trying to implement here. Could you please elaborate on the model/formulation? Kernels associated with basic phase-field equations terms are provided here, https://mooseframework.inl.gov/modules/phase_field/Phase_Field_Equations.html\nYou can also check out ACKappaFunction  which considers the derivative of the kappa term.",
                  "url": "https://github.com/idaholab/moose/discussions/18299#discussioncomment-1023108",
                  "updatedAt": "2022-06-09T07:55:30Z",
                  "publishedAt": "2021-07-19T17:23:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "scottedmuller"
                          },
                          "bodyText": "Thank you for the response. I'm trying to implement a non-isothermal system with three distinct non-conserved phases, each of which has its own order parameter (representing the phase volume fraction),\nVariables:\nOrder parameters: phi_1, phi_2, phi_3\nTemperature: T\n\nFor brevity, I'll use phi_q to reference the order parameters in this outline. The free energy is a combination of thermodynamic terms (heat capacity and latent heat with phase changes) and coupled interface terms that may be different between any two phases,\nFree Energy:\nf(phi_q,T) = f_bulk(phi_q,T) + f_interface(phi_q,grad(phi_q))\nf_bulk(phi_q,T) = h(phi_1)*f_1(T) + h(phi_2)*f_2(T) + h(phi_3)*f_3(T)\nf_interface(phi_q,grad(phi_q)) = f_dw(phi_q) + f_grad(phi_q,grad(phi_q))\n\nI felt the ACMultiInterface kernel was most appropriate for f_grad as it handles the complex cross terms between each pair of order parameters and their gradients. I use a CrossTermBarrierFunctionMaterial for the double-well term f_dw. The evolution equations for the order parameters are then straightforward,\nEvolution equation for order parameter q:\ndphi_q/dt + L*df/dphi_q + penalty = 0 ;  q={1,2,3}\n\nThe challenge comes in deriving an evolution equation for temperature. The internal energy can be derived as\nInternal energy:\ne(phi_q,T) = f(phi_q,T) - T*df/dT = e_bulk(phi_q,T) + f_interface(phi_q,grad(phi_q))\n\nNote that the interface term is unchanged in this transformation because df_interface/dT = 0. The time evolution for temperature, with thermal conductivity k, can be expressed as,\nEvolution equation for T:\nde/dT*dT/dt + sum(de/dphi_q*dphi_q/dt + de/d(grad(phi_q))*d(grad(phi_q))/dt,q={1,2,3}) - div(k(phi_q)*grad(T)) = 0\n\nI'm not positive that the grad(phi_q) terms needs to be included here, but I don't feel that I can discard them out of hand. Even if I could, the de/dphi_q terms are themselves quite complicated as they must include portions of the cross terms from f_interface. It may be that the effect of these terms is negligible enough that they can safely be discarded, but I would have to actually set it up in order to verify it, which is what I hope to avoid.\nTo dramatically simplify this problem I could recast f_interface as being a linear function of T. The internal energy would then simply be e(phi_q,T) = e_bulk(phi_q,T) and the evolution equation for T would become\nRecast internal energy and evolution equation for T:\nde_bulk/dT*dT/dt + sum(de_bulk/dphi_q*dphi_q/dt,q={1,2,3}) - div(k(phi_q)*grad(T)) = 0\n\nHere the de_bulk/dphi_q terms are very straightforward. This modified formulation seems mathematically complete to me, and much less taxing computationally. I had hoped to implement it by making the kappa term in the ACMultiInterface kernel a simple linear function of T, but it doesn't seem to be a built-in option, hence my question.\nThe ACKappaFunction you suggested looks promising. I suppose I would use a different ACKappaFunction for each kappa value for a given order parameter. Does that sound right? Looking at ACMultiInterface, do you have any reason to think it can't be used with multiple kappa values each defined by their own ACKappaFunction? Please let me know if you have any other ideas or suggestions. Also, please let me know if you see a problem with my formulation or approach in general. Thanks again for your help!\n-Scott",
                          "url": "https://github.com/idaholab/moose/discussions/18299#discussioncomment-1029004",
                          "updatedAt": "2022-06-09T07:56:59Z",
                          "publishedAt": "2021-07-20T21:31:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "In the 4th equation on https://mooseframework.inl.gov/moose/source/kernels/ACMultiInterface.html you can see that we pulled out Kappa, assuming that it is constant (i.e. has a vanishing gradient). This is consistent with the code in modules/phase_field/src/kernels/ACMultiInterface.C, where no derivatives of the kappas are used.\nFor your application you'd have to redo the derivation and implement the resulting weak form containing the dkappa/dvar derivatives for all variables your kappas depend on (to construct grad(kappa) = sum(grad(var)*dkappa/dvar).",
                  "url": "https://github.com/idaholab/moose/discussions/18299#discussioncomment-1038778",
                  "updatedAt": "2022-06-09T07:57:33Z",
                  "publishedAt": "2021-07-22T17:13:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "scottedmuller"
                          },
                          "bodyText": "That makes sense, and answers my original question. Thanks!\nI'm probably overthinking it. The literature I've reviewed so far doesn't bother including interfacial energy terms with their internal energy when deriving temperature evolution equations for non-isothermal systems. Most seem to treat internal energy as a bulk quantity. I'm not fully convinced and would love to see a justification one way or another. I'd be grateful if you have any other advice related to my problem, or any related literature that deals with it more explicitly.\n-Scott",
                          "url": "https://github.com/idaholab/moose/discussions/18299#discussioncomment-1039769",
                          "updatedAt": "2022-06-09T07:57:34Z",
                          "publishedAt": "2021-07-22T22:34:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "libmesh update",
          "author": {
            "login": "lindsayad"
          },
          "bodyText": "All, we've had a couple of libmesh updates make their way into moose master and into the conda channels in relatively close succession.\nHere are a summary of the changes:\n\nMimic stl and boost constructors in our allocators\nTry changing max order for L2 families\nAdd LumpedMassMatrix class\nTest custom FE reinit\n$LIBMESH_BENCHMARK selection of benchmarking examples\nRB: skip reinit when there are no DOFs on Elem\nCommand-line override of default Metis-vs-Parmetis\ninit_names() at more points\nFix FE side unit tests with --enable-complex\nBegin contains_vertex_of with node equality tests\nchunked_mapvector storage option\nWeaken partitioner_test for SFC on 8+ processors\nBugfix for PR libMesh/libmesh#2940\nRevert \"interior_parent fix on distributed refined multi-elem_dim meshes\"\ninterior_parent fix on distributed refined multi-elem_dim meshes\nRB EIM update\nFix for deprecated warning in SLEPc not-quite-3.15\nUse pool allocator in mapvector\nCheck for gdb in command line in print_trace when compiling with no gdb backtrace by default\nAdd a new functor for sync element integers\nSome cleanup for RB EIM code\nedgeset/nodeset/sideset unit test refactor\nMore contains_vertex_of optimization\nFix distributed p coarsening assertion",
          "url": "https://github.com/idaholab/moose/discussions/18413",
          "updatedAt": "2022-10-07T12:52:12Z",
          "publishedAt": "2021-07-22T21:25:20Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Name of selected MooseEnum item",
          "author": {
            "login": "joe61vette"
          },
          "bodyText": "I would like to use the name (string) of an item selected in a MooseEnum to be a suffix as part of another name.  Let me try to explain.  Given the declaration:\n   const field::FieldEnum _field;\n\nand the initialization in a Material constructor:\n   _field(getParam<MooseEnum>(\"field\").getEnum<field::FieldEnum>()),\n\nI would then like to declare a property like:\n   _alfa(declareADProperty<Real>(\"alfa_\" + name_of(_field_)),\n\nwhere name_of(_field) would be the name associated with the MooseEnum item _field.  _field is (of course) an integer and I have been unable to find how to get the associated name.  I am sure this is due to my minimal understanding of MooseEnum.\nThanks for the help,\nJoe Kelly",
          "url": "https://github.com/idaholab/moose/discussions/18398",
          "updatedAt": "2022-10-13T20:34:52Z",
          "publishedAt": "2021-07-20T21:45:38Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Joe\nFirst do you need to do this:\n_field(getParam(\"field\").getEnumfield::FieldEnum())\nOr could you get by with\n_field(getParam<MooseEnum>(\"field\")),\n?\nThis field enum is a structure you declared right? It inherits from MooseEnum right?\nYou want to use the name() attribute of the enumerated objects. You could retrieve the name using the MooseEnumBase::find(int ...) routine with _field. This might not be the most graceful way though.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18398#discussioncomment-1030379",
                  "updatedAt": "2021-07-21T05:26:39Z",
                  "publishedAt": "2021-07-21T05:26:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Thanks Guillaume.  It appears that \"find(int ...)\" returns the id not the name.  So, I went ahead and added a method:\nstd::string getFieldName(int id)\n{\nswitch (id)\n{\ncase 0:\nreturn \"liquid\";\ncase 1:\n  return \"gas\";\n\ncase 2:\n  return \"drop\";\n\ndefault:\n  mooseError(\"Invalid id for FieldEnum, id = \", id);\n\n}\nJust a bit surprised that there isn't a more generic way to do this in Moose as there seems to be multiple ways to do just about anything.\nJoe",
                          "url": "https://github.com/idaholab/moose/discussions/18398#discussioncomment-1032455",
                          "updatedAt": "2021-07-21T13:08:39Z",
                          "publishedAt": "2021-07-21T13:08:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "find with the id as argument should return an iterator which you should be able to use to call name().\nMooseEnumBase::find(int id) const\n{\n  return std::find_if(\n      _items.begin(), _items.end(), [&id](MooseEnumItem const & item) { return item.id() == id; });\n}\n\n\nAnother option is to call getNames() on the enum and access it at the right position.",
                          "url": "https://github.com/idaholab/moose/discussions/18398#discussioncomment-1032952",
                          "updatedAt": "2021-07-21T14:45:10Z",
                          "publishedAt": "2021-07-21T14:45:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "I got the getNames() option to work.  Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/18398#discussioncomment-1033654",
                          "updatedAt": "2021-07-21T15:51:37Z",
                          "publishedAt": "2021-07-21T15:51:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "just do\n_field_name(getParam<MooseEnum>(\"field\"))\n\nin your initializer list, where _field_name is a const std::string member.",
                  "url": "https://github.com/idaholab/moose/discussions/18398#discussioncomment-1038034",
                  "updatedAt": "2021-07-22T14:31:53Z",
                  "publishedAt": "2021-07-22T14:31:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Thanks Dan.  Could you please mark this as answered?\nJoe",
                          "url": "https://github.com/idaholab/moose/discussions/18398#discussioncomment-1038087",
                          "updatedAt": "2021-07-22T14:40:56Z",
                          "publishedAt": "2021-07-22T14:40:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}