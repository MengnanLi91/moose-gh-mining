{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wMy0wM1QwODoyODo0NS0wNjowMM4ASxVW"
    },
    "edges": [
      {
        "node": {
          "title": "Ray Tracing for Lens Design",
          "author": {
            "login": "mrplants"
          },
          "bodyText": "I'd like to use the ray tracing module to design a system of lenses. Is there a clever way to visualize the rays, themselves, so that I can iterate and focus my design.",
          "url": "https://github.com/idaholab/moose/discussions/23602",
          "updatedAt": "2023-03-04T16:37:05Z",
          "publishedAt": "2023-03-04T12:50:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can output the rays to Exodus\nhttps://mooseframework.inl.gov/source/outputs/RayTracingExodus.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23602#discussioncomment-5202519",
                  "updatedAt": "2023-03-04T15:17:17Z",
                  "publishedAt": "2023-03-04T15:17:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/23602#discussioncomment-5202969",
                          "updatedAt": "2023-03-04T16:37:06Z",
                          "publishedAt": "2023-03-04T16:37:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Does Weak Plane Stress setup work with Dynamic Tensor Mechanics?",
          "author": {
            "login": "chongxiyuan"
          },
          "bodyText": "Hi, I am trying to run 2d problems with plane stress setup. The example modules/tensor_mechanics/test/tests/plane_stress/weak_plane_stress_small.i works fine. But if I try to change the action to DynamicMaster, I get the error\n*** ERROR ***\nAttempting to set parameter \"out_of_plane_strain\" with type (std::vector<VariableName, std::allocator<VariableName> >)\nbut the parameter already exists as type (VariableName)\n\nThe input I am running is modifies from given example changing to DynamicMaster\n[GlobalParams]\n  order = FIRST\n  family = LAGRANGE\n  displacements = 'disp_x disp_y'\n  temperature = temp\n  #out_of_plane_strain = strain_zz\n[]\n\n[Mesh]\n  [./square]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 2\n    ny = 2\n  [../]\n[]\n\n[Variables]\n  [./disp_x]\n  [../]\n  [./disp_y]\n  [../]\n  [./strain_zz]\n  [../]\n[]\n\n[AuxVariables]\n  [./temp]\n  [../]\n  [./nl_strain_zz]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[Postprocessors]\n  [./react_z]\n    type = MaterialTensorIntegral\n    rank_two_tensor = stress\n    index_i = 2\n    index_j = 2\n  [../]\n  [./min_strain_zz]\n    type = NodalExtremeValue\n    variable = strain_zz\n    value_type = min\n  [../]\n  [./max_strain_zz]\n    type = NodalExtremeValue\n    variable = strain_zz\n    value_type = max\n  [../]\n[]\n\n[Modules/TensorMechanics/DynamicMaster]\n  [plane_stress]\n    add_variables= true\n    planar_formulation = WEAK_PLANE_STRESS\n    strain = SMALL\n    generate_output = 'stress_xx stress_xy stress_yy stress_zz strain_xx strain_xy strain_yy'\n    eigenstrain_names = eigenstrain\n    out_of_plane_strain = strain_zz\n  []\n[]\n\n[AuxKernels]\n  [./tempfuncaux]\n    type = FunctionAux\n    variable = temp\n    function = tempfunc\n    use_displaced_mesh = false\n  [../]\n  [./strain_zz]\n    type = RankTwoAux\n    rank_two_tensor = total_strain\n    variable = nl_strain_zz\n    index_i = 2\n    index_j = 2\n  [../]\n[]\n\n[Functions]\n  [./pull]\n    type = PiecewiseLinear\n    x='0     1   100'\n    y='0  0.00  0.00'\n  [../]\n  [./tempfunc]\n    type = ParsedFunction\n    value = '(1 - x) * t'\n  [../]\n[]\n\n[BCs]\n  [./bottomx]\n    type = DirichletBC\n    boundary = 0\n    variable = disp_x\n    value = 0.0\n  [../]\n  [./bottomy]\n    type = DirichletBC\n    boundary = 0\n    variable = disp_y\n    value = 0.0\n  [../]\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    poissons_ratio = 0.3\n    youngs_modulus = 1e6\n  [../]\n  [./thermal_strain]\n    type = ComputeThermalExpansionEigenstrain\n    thermal_expansion_coeff = 0.02\n    stress_free_temperature = 0.5\n    eigenstrain_name = eigenstrain\n  [../]\n  [./stress]\n    type = ComputeLinearElasticStress\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = PJFNK\n  line_search = none\n\n# controls for linear iterations\n  l_max_its = 100\n  l_tol = 1e-06\n\n# controls for nonlinear iterations\n  nl_max_its = 15\n  nl_rel_tol = 1e-14\n  nl_abs_tol = 1e-12\n\n# time control\n  start_time = 0.0\n  dt = 1.0\n  dtmin = 1.0\n  end_time = 2.0\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23469",
          "updatedAt": "2023-03-06T02:49:51Z",
          "publishedAt": "2023-02-17T17:46:35Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@recuero @dschwen on dynamic tensor mechanics master action",
                  "url": "https://github.com/idaholab/moose/discussions/23469#discussioncomment-5013067",
                  "updatedAt": "2023-02-17T17:59:55Z",
                  "publishedAt": "2023-02-17T17:59:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "reed-lfh"
                  },
                  "bodyText": "I just got the same issue. I am trying to switch to the static module. But it looks like the HHT parameter in inertia force does not work in this way.",
                  "url": "https://github.com/idaholab/moose/discussions/23469#discussioncomment-5162867",
                  "updatedAt": "2023-03-01T04:54:31Z",
                  "publishedAt": "2023-03-01T04:54:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Weak plane stress does not work with HHT-alpha yet. Feel free to open an issue if there isn't one already.",
                  "url": "https://github.com/idaholab/moose/discussions/23469#discussioncomment-5201374",
                  "updatedAt": "2023-03-04T11:27:48Z",
                  "publishedAt": "2023-03-04T11:27:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "To clarify, the capabilities are there, it's just the action that needs to be fixed.",
                          "url": "https://github.com/idaholab/moose/discussions/23469#discussioncomment-5202282",
                          "updatedAt": "2023-03-04T14:37:55Z",
                          "publishedAt": "2023-03-04T14:37:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Electromagnetics Kernel for Motor Design",
          "author": {
            "login": "mrplants"
          },
          "bodyText": "Is it possible to use Moose builtin Physics kernels to analyze electric motor/generator designs?  I skimmed the Electromagnetics Module and it seemed focused solely on wave propagation for antenna design, RF, etc.  Is there a kernel that analyzes electromagnetic forces from interacting magnetic fields?\nIf not, any tips on how to put one together?  I'm not a PhD, but can handle my PDEs if absolutely necessary.",
          "url": "https://github.com/idaholab/moose/discussions/23601",
          "updatedAt": "2023-03-04T12:57:54Z",
          "publishedAt": "2023-03-04T00:33:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cticenhour\nCan you please comment on this?\nWe re not far off from modeling coupled EM mechanics right?",
                  "url": "https://github.com/idaholab/moose/discussions/23601#discussioncomment-5198752",
                  "updatedAt": "2023-03-04T00:39:45Z",
                  "publishedAt": "2023-03-04T00:39:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "@GiudGiud was correct, we are interested in developing coupled electro-mechanical capabilities between the electromagnetics module and the tensor (solid) mechanics module, which would involve the creation of an electromagnetic force kernel as a source term in a larger mechanics problem. We may have some funding later in the fall to start performing this work as part of another project, but that is not guaranteed yet. If you wanted to tackle it yourself, feel free to reach out to me; I created the electromagnetic module and am its current lead.\nAs far as tips, since I don't know your background - \"Introduction to Electrodynamics\" by David Griffiths would be a useful book to get started learning the base equations and can be easily found online. Griffith's book talks some about the Lorentz force, which describes the electromagnetic force on a given particle, but in this case we could want the Laplace force. This is the same idea, but described and manifested at the level of currents instead of individual charges. Stepping out from Griffith's book, I have a somewhat harder time passing along a comprehensive single text, but searching around there is an older text on MIT OpenCourseWare on Electromechanical Dynamics that might be useful: Part 1 - Discrete Systems, Part 2 - Fields, Forces, and Motion, and Part 3 - Elastic and Fluid Media. This text is an unknown to me, but did look very wide-ranging at a skim!\nRegarding tips for working with MOOSE and the modules, we have a large number of examples and tutorials that you might want to check out. The main workshop example as well as some of the guided individual examples would show how to make new kernels and objects.\nHopefully this helps get started looking at the problem! Again, feel free to reach out again if you wish to discuss this more.",
                  "url": "https://github.com/idaholab/moose/discussions/23601#discussioncomment-5199461",
                  "updatedAt": "2023-03-04T04:34:34Z",
                  "publishedAt": "2023-03-04T04:34:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/23601#discussioncomment-5201792",
                          "updatedAt": "2023-03-04T12:57:54Z",
                          "publishedAt": "2023-03-04T12:57:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Green-Lagrange strain with Neo-Hookean model",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hi MOOSEers,\nI want to calculate Green-Lagrange strain with Neo-Hookean model, and I found this page https://mooseframework.inl.gov/source/materials/ADComputeGreenLagrangeStrain.html, but it's used for St. Venant-Kirchhoff hyper elasticity model. Are there any modules/examples related to Neo-Hookean model? Thanks!",
          "url": "https://github.com/idaholab/moose/discussions/23503",
          "updatedAt": "2023-06-24T22:24:27Z",
          "publishedAt": "2023-02-21T19:02:09Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Yes, if you've searched within the repo or the website, this class and/or its documentation should pop up https://github.com/idaholab/moose/blob/next/modules/tensor_mechanics/src/materials/lagrangian/ComputeNeoHookeanStress.C\nNote that Neo-Hookean is really a family of strain energy density functions. Our implementation should serve as a good starting point.",
                  "url": "https://github.com/idaholab/moose/discussions/23503#discussioncomment-5084296",
                  "updatedAt": "2023-02-23T04:05:43Z",
                  "publishedAt": "2023-02-23T04:05:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thanks for pointing it out! @hugary1995\nI have a follow-up question:\nwhat's the difference between [ComputeFiniteStrain]+[StressDivergenceTensors] (with use_displaced_mesh = true) and [ComputeLagrangianStrain] + [TotalLagrangianStressDivergence] in MOOSE? I'm confused with the simple setting like\nuse_displaced_mesh = true in [TensorMechanics/MasterAction].  Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/23503#discussioncomment-5090264",
                          "updatedAt": "2023-02-23T16:07:24Z",
                          "publishedAt": "2023-02-23T16:07:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You should not need to set this parameter if you are using the action. The strain calculators always run on the undisplaced mesh. The stress calculators run on the configuration where your properties are defined. The total Lagrangian kernels run on the undisplaced mesh. The incremental Lagrangian kernels run on the displaced mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/23503#discussioncomment-5201406",
                          "updatedAt": "2023-03-04T11:35:47Z",
                          "publishedAt": "2023-03-04T11:35:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Complex modulus in Homogenization kernel",
          "author": null,
          "bodyText": "I am trying to calculate the homogenized properties for a periodic unit cell with complex valued youngs modulus. I tried creating 4 different stress divergence kernels and passing them to the homogenization kernels, but that doesn't seem to work. Has anyone tried to do this or or could guide me on how to do this?\nMy Input File\n2D_homogenization_complex_modulus.txt",
          "url": "https://github.com/idaholab/moose/discussions/23525",
          "updatedAt": "2023-04-07T22:56:20Z",
          "publishedAt": "2023-02-24T05:46:32Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@jiangwen84 @dschwen",
                  "url": "https://github.com/idaholab/moose/discussions/23525#discussioncomment-5125312",
                  "updatedAt": "2023-02-27T16:22:05Z",
                  "publishedAt": "2023-02-27T16:22:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "In general, you need to use different base names for the real and imaginary parts. That's all I can say without seeing the equations you want to solve.",
                  "url": "https://github.com/idaholab/moose/discussions/23525#discussioncomment-5201387",
                  "updatedAt": "2023-03-04T11:31:06Z",
                  "publishedAt": "2023-03-04T11:31:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "how to set a anisotropic eigenstrain",
          "author": {
            "login": "wangzhaohao"
          },
          "bodyText": "Hi, everyone. I need to set a anisotropic eigenstrain (RZ). I find in thermal expansion there used GenericMaterialProperty<is_ad> _eigenstrain  and use addIa to set the isotropic eigenstrain.  but, sorry i don't find another  member function to set in anisotropic eigenstrain. Thanks for you advice.\nzhaohao wang",
          "url": "https://github.com/idaholab/moose/discussions/23595",
          "updatedAt": "2023-03-05T03:02:04Z",
          "publishedAt": "2023-03-03T14:07:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "There's nothing preventing your from setting the components of a RankTwoTensor. Please refer to the doxygen.",
                  "url": "https://github.com/idaholab/moose/discussions/23595#discussioncomment-5201349",
                  "updatedAt": "2023-03-04T11:21:29Z",
                  "publishedAt": "2023-03-04T11:21:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Switching flux direction in interface kernel",
          "author": {
            "login": "lanzam213"
          },
          "bodyText": "I developed an interface kernel that calculates a flux based on the neighbor value and applies that flux to primary and secondary sides as shown below.\nADReal\nADPelletInterfaceKernel::computeQpResidual(Moose::DGResidualType type)\n{\n\n  // positive sign indicates positive flux outward from secondary element (located on left side of interface)\n  \n  ADReal flux = (_neighbor_value[_qp] > _sat ? _k * (_neighbor_value[_qp] - _sat): 0);\n  \n  switch (type)\n  {\n    case Moose::Element:\n      return -flux * _stoich_factor * _test[_i][_qp];\n\n    case Moose::Neighbor:\n      return flux * _test_neighbor[_i][_qp];\n\n    default:\n      return 0.0;\n  }\n}\n\nThe interface kernel works perfectly when the boundary is on the right face of secondary side but not when switched. The problem I'm having is when the primary and secondary elements switch places on the interface boundary.  I'm looking for a way to evaluate the element normal such that I can flip the sign on flux when needed. Any suggestions will be appreciated.\n-Mark\nUPDATE: New testing indicates this is working as is.",
          "url": "https://github.com/idaholab/moose/discussions/23598",
          "updatedAt": "2023-06-24T22:24:17Z",
          "publishedAt": "2023-03-03T19:07:43Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou should have access to _current_elem, _current_side and _current_elem_side in a DGKernel to make these determinations.\nYou could add a parameter to store a normal if it s relatively consistent on the boundary.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23598#discussioncomment-5199118",
                  "updatedAt": "2023-03-04T02:30:43Z",
                  "publishedAt": "2023-03-04T02:30:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "SinglePhaseFluidProperties & AD system",
          "author": {
            "login": "joe61vette"
          },
          "bodyText": "Hi:\nI am writing a very simple fluid property but having trouble getting the AD system to produce the derivatives.  I inherit from SinglePhaseFluidProperties.  The function is:\nADReal ConstantFluidProperties::h_from_p_T(const ADReal & /*p*/, const ADReal & T) const { return _cp * (T - 273.15); }\nwhere _cp is a constant.\nIn my FluidMaterial::computeQpProperties(), I have:\n_h[_qp] = _fluid.h_from_p_T(_p[_qp], _T[_qp]);\nwhere in the constructor initialization:\n_p(adCoupledValue(CRAB::pressure)),\n_T(adCoupledValue(CRAB::T_fluid)),\n_h(declareADProperty(CRAB::enthalpy)),\nWhen I print the values of _h[_qp] and _T[_qp], it shows no derivs:   T = (293.15,{})  h = (83682,{})\nIn the test problem, T is a non-linear variable.  However, in the FluidMaterial validParams, I have:\nparams.addCoupledVar(CRAB::T_fluid, 293.15, \"Fluid temperature (K)\");\nI provided the default to facilitate testing.  Is something wrong with this approach?\nThanks,\nJoe Kelly",
          "url": "https://github.com/idaholab/moose/discussions/23600",
          "updatedAt": "2023-03-04T00:38:36Z",
          "publishedAt": "2023-03-03T20:44:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "joe61vette"
                  },
                  "bodyText": "Glad no one wasted their time on this.  It was my error.  I forgot to specify the temperature variable as a parameter to FluidMaterial.  One bad aspect of using a default rather than addRequiredCoupledVar.\nAt any rate, have a great weekend.",
                  "url": "https://github.com/idaholab/moose/discussions/23600#discussioncomment-5197574",
                  "updatedAt": "2023-03-03T22:20:57Z",
                  "publishedAt": "2023-03-03T22:20:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Have a great weekend too!\nGlad you got it solved",
                          "url": "https://github.com/idaholab/moose/discussions/23600#discussioncomment-5198748",
                          "updatedAt": "2023-03-04T00:38:36Z",
                          "publishedAt": "2023-03-04T00:38:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issues with GrayDiffuseRadiation Convergence",
          "author": {
            "login": "mrplants"
          },
          "bodyText": "I am attempting to use GrayDiffuseRadiation to model the transfer of heat from an outer cylinder (stator) and inner cylinder (rotor).  Here is an illustration of my mesh.  (The orange section is the vacuum):\n\n  \n    \n    \n\n    small_cylinder_recording.mov\n    \n  \n\n  \n\n  \n\n\nHere is my input file:\n[Mesh]\n  type = MeshGeneratorMesh\n  [file_mesh]\n    type = FileMeshGenerator\n    file = cylinder_within_cylinder.msh\n  []\n  [rotor_outer_surface_sideset]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = file_mesh\n    primary_block = 'rotor_volume'\n    paired_block = 'vacuum_volume'\n    new_boundary = 'rotor_outer_surface_sideset'\n  []\n  [stator_inner_surface_sideset]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = rotor_outer_surface_sideset\n    primary_block = 'stator_volume'\n    paired_block = 'vacuum_volume'\n    new_boundary = 'stator_inner_surface_sideset'\n  []\n  []\n\n[Variables]\n  [Temperature]\n  []\n[]\n\n[ICs]\n  [rotor_IC]\n    type = ConstantIC\n    variable = Temperature\n    block = 'rotor_volume'\n    value = 80\n  []\n  [vacuum_IC]\n    type = ConstantIC\n    variable = Temperature \n    block = 'vacuum_volume'\n    value = 80\n  []\n  [stator_IC]\n    type = ConstantIC\n    variable = Temperature \n    block = 'stator_volume'\n    value = 300\n  []\n[]\n\n[Kernels]\n  [heat_conduction]\n    type = HeatConduction\n    variable = Temperature\n  []\n  [heat_conduction_time_derivative]\n    type = HeatConductionTimeDerivative\n    variable = Temperature\n  []\n[]\n\n[GrayDiffuseRadiation]\n  [vacuum_radiation]\n    boundary = 'stator_inner_surface_sideset rotor_outer_surface_sideset'\n    emissivity = '0.03 0.03'\n    n_patches = '2 2'\n    temperature = Temperature\n    ray_tracing_face_type = 'GAUSS'\n  []\n[]\n\n[Materials]\n  [thermal_rotor]\n    type = HeatConductionMaterial\n    thermal_conductivity = 45.0\n    specific_heat = 0.5\n    block = 'rotor_volume'\n  []\n  [thermal_vacuum]\n    type = HeatConductionMaterial\n    thermal_conductivity = 0\n    specific_heat = 0\n    block = 'vacuum_volume'\n  []\n  [thermal_stator]\n    type = HeatConductionMaterial\n    thermal_conductivity = 25.0\n    specific_heat = 1\n    block = 'stator_volume'\n  []\n  [density]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = 8000.0\n  []\n[]\n\n[Executioner]\n  type = Transient\n  end_time = 5\n  dt = 1\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nWhen I run this, it does not converge.  I have searched high and low and cannot fathom what could be wrong in such a simple problem.  What is going on here?",
          "url": "https://github.com/idaholab/moose/discussions/23590",
          "updatedAt": "2023-03-04T00:32:49Z",
          "publishedAt": "2023-03-03T00:34:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "mrplants"
                  },
                  "bodyText": "GitHub won't allow me to upload my mesh (.msh) or input (.i) files.  Any recommendations?",
                  "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5184583",
                  "updatedAt": "2023-03-03T00:36:04Z",
                  "publishedAt": "2023-03-03T00:36:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You should be able to upload them to a repository and share the link to it with us here",
                          "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5184593",
                          "updatedAt": "2023-03-03T00:39:20Z",
                          "publishedAt": "2023-03-03T00:39:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Here you go:\nrepo",
                          "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5184604",
                          "updatedAt": "2023-03-03T00:41:34Z",
                          "publishedAt": "2023-03-03T00:41:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@loganharbour @snschune\nMy guess is that 2x2 patches is not enough for 2 concentric cylinders but you ll know more",
                  "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5184603",
                  "updatedAt": "2023-03-03T00:41:18Z",
                  "publishedAt": "2023-03-03T00:41:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Just tried increasing to 20x20 and it still does not converge.",
                          "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5184614",
                          "updatedAt": "2023-03-03T00:42:56Z",
                          "publishedAt": "2023-03-03T00:42:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "snschune"
                          },
                          "bodyText": "The temperature variable was defined in the vacuum region with cp=0 and k=0 and that led to numerical difficulties.\nThis one should work:\n[Mesh]\n  type = MeshGeneratorMesh\n  [file_mesh]\n    type = FileMeshGenerator\n    file = cylinder_within_cylinder.msh\n  []\n  [rotor_outer_surface_sideset]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = file_mesh\n    primary_block = 'rotor_volume'\n    paired_block = 'vacuum_volume'\n    new_boundary = 'rotor_outer_surface_sideset'\n  []\n  [stator_inner_surface_sideset]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = rotor_outer_surface_sideset\n    primary_block = 'stator_volume'\n    paired_block = 'vacuum_volume'\n    new_boundary = 'stator_inner_surface_sideset'\n  [../]\n  []\n\n[Variables]\n  [Temperature]\n    block = 'rotor_volume stator_volume'\n  []\n[]\n\n[Problem]\n  kernel_coverage_check = false\n  material_coverage_check = false\n[]\n\n[ICs]\n  [rotor_IC]\n    type = ConstantIC\n    variable = Temperature\n    block = 'rotor_volume'\n    value = 80\n  []\n  [stator_IC]\n    type = ConstantIC\n    variable = Temperature\n    block = 'stator_volume'\n    value = 300\n  []\n[]\n\n[Kernels]\n  [heat_conduction]\n    type = HeatConduction\n    variable = Temperature\n  []\n  [heat_conduction_time_derivative]\n    type = HeatConductionTimeDerivative\n    variable = Temperature\n  []\n[]\n\n[GrayDiffuseRadiation]\n  [vacuum_radiation]\n    boundary = 'stator_inner_surface_sideset rotor_outer_surface_sideset'\n    emissivity = '0.03 0.03'\n    n_patches = '2 2'\n    temperature = Temperature\n    ray_tracing_face_type = 'GAUSS'\n    # fixed_temperature_boundary = 'stator_inner_surface_sideset'\n    # fixed_boundary_temperatures = 300\n  []\n[]\n\n[Materials]\n  [thermal_rotor]\n    type = HeatConductionMaterial\n    thermal_conductivity = 45.0\n    specific_heat = 0.5\n    block = 'rotor_volume'\n  []\n  [thermal_stator]\n    type = HeatConductionMaterial\n    thermal_conductivity = 25.0\n    specific_heat = 1\n    block = 'stator_volume'\n  []\n  [density]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = 8000.0\n  []\n[]\n\n# [BCs]\n#  [temperature_stator]\n#    type = DirichletBC\n#    variable = Temperature\n#    value = 300\n#    boundary = 'stator_inner_surface'\n#  []\n# []\n\n[Executioner]\n  type = Transient\n  end_time = 5\n  petsc_options_iname = '-pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = 'hypre     boomeramg      5'\n  dt = 1\n[]\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5185298",
                          "updatedAt": "2023-03-03T02:48:45Z",
                          "publishedAt": "2023-03-03T02:48:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Beautiful.  Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5185313",
                          "updatedAt": "2023-03-03T02:50:58Z",
                          "publishedAt": "2023-03-03T02:50:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mrplants"
                  },
                  "bodyText": "Where can I learn more about the various options here?  For example, I've looked in the documentation and \"patch\" isn't described in detail.  Are there good references where I can learn more about using ray tracing to calculate gray diffuse radiation?",
                  "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5185328",
                  "updatedAt": "2023-03-03T02:53:55Z",
                  "publishedAt": "2023-03-03T02:53:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "snschune"
                          },
                          "bodyText": "We've meant to improve the documentation this year but haven't gotten there yet. Feedback on what is not clear would be helpful.\nWhat we have:\nThe action is described here:\nhttps://mooseframework.inl.gov/syntax/GrayDiffuseRadiation/index.html\nSome info about how view factors are computed:\nhttps://mooseframework.inl.gov/source/userobjects/RayTracingViewFactor.html\nhttps://mooseframework.inl.gov/source/userobjects/ViewFactorRayStudy.html\nPatches are simply regions that get an entry in the view factor matrix. Patches are constructed\nby subdividing sidesets into smaller sidesets. It's a tradeoff between having a view factor between\neach face pair and a view factor between each sideset pair.",
                          "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5185446",
                          "updatedAt": "2023-03-03T03:19:37Z",
                          "publishedAt": "2023-03-03T03:19:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "How do I get an idea for how many patches I need? Seems like 2 or 20 might be not enough.  I tried scaling it up and it would not go any higher than 1400x1400.  There was no major difference in the results at that scale, though.",
                          "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5198700",
                          "updatedAt": "2023-03-04T00:26:51Z",
                          "publishedAt": "2023-03-04T00:26:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "snschune"
                          },
                          "bodyText": "I would handle it like mesh refinement. Do very few, then double it, and then some more and see if the answer stops changing.\nCaveat: the system will work for a moderate number of patches but performance will deteriorate at some point. It's simply the way we deal with patches and how the linear equation for the radiation is solved (essentially in serial). We are going to work on that this year, but it's currently still limited.",
                          "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5198726",
                          "updatedAt": "2023-03-04T00:32:49Z",
                          "publishedAt": "2023-03-04T00:32:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mrplants"
                  },
                  "bodyText": "By the way, huge thanks to all the folks working on this project.  The Moose Framework seems incredibly powerful from what I can tell.  Not a surprise coming from INL, though.  I used to work with the lab when I was a gov't employee years ago and have been nothing but impressed with the kind of inspiring innovative projects you're all working on.  Thank you so much!  I love Moose!",
                  "url": "https://github.com/idaholab/moose/discussions/23590#discussioncomment-5198702",
                  "updatedAt": "2023-03-04T00:26:54Z",
                  "publishedAt": "2023-03-04T00:26:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Read Variable from CSV fiel",
          "author": {
            "login": "fervaldies"
          },
          "bodyText": "Hello, I am trying to change a vector that I have in my input file with a column of an external CSV file. My vectors are x,y, and z coordinates as follow:\ninit_x_coords = '0.010 0.162 0.106 0.010 0.050 0.010 0.150'\ninit_y_coords = '0.04175 0.04725 0.05275 0.05825 0.05825 0.05275 0.04725 0.04175'\ninit_z_coords = '0.016 0.016 0.016 0.016 0.019 0.019 0.019 0.019'\n\nAnd I would like to read them from a CSV file with 3 columns. I tried:\n[VectorPostprocessors]\n  [./Input_Params]\n    type = CSVReader\n    csv_file = Input_Params.csv\n    header = true\n  [../]\n[]\n\nand then:\ninit_x_coords = Input_Params/x_coord\ninit_y_coords = Input_Params/y_coord\ninit_z_coords = Input_Params/z_coord\n\nbut I receive an error like \"cannot convert 'Input_Params/x_coord' to float\"\nAny other option to do this? Thanks in advance.",
          "url": "https://github.com/idaholab/moose/discussions/23592",
          "updatedAt": "2023-06-24T22:24:12Z",
          "publishedAt": "2023-03-03T04:44:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat are the types of these paremeters?\nA RealVectorValue'd parameter will accept a vector from the input file, but not a VectorPostprocessor vector.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23592#discussioncomment-5192410",
                  "updatedAt": "2023-03-03T14:28:45Z",
                  "publishedAt": "2023-03-03T14:28:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}