{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wMy0yM1QxMTowMDozNy0wNTowMM4APGSC"
    },
    "edges": [
      {
        "node": {
          "title": "Sampling variable at a plane in 3D",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi\nI need to sample the solution of a problem in a plane in 3D. I was thinking of something like LineValueSampler but I did not find something similar. So, I have tried to define new nodesets using BoundingBoxNodeSetGenerator, and then try to output the variable on those nodes using VectorPostprocessors but I could not.\nAny suggestions?",
          "url": "https://github.com/idaholab/moose/discussions/20664",
          "updatedAt": "2024-09-27T22:45:22Z",
          "publishedAt": "2022-03-29T23:00:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo you'd want something like PlaneValueSampler?\nWith a regular grid overlaid over the domain?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20664#discussioncomment-2465546",
                  "updatedAt": "2024-09-27T22:45:52Z",
                  "publishedAt": "2022-03-29T23:19:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Hello\nSo you'd want something like PlaneValueSampler? With a regular grid overlaid over the domain?\nGuillaume\n\nYes, exactly.",
                          "url": "https://github.com/idaholab/moose/discussions/20664#discussioncomment-2465551",
                          "updatedAt": "2024-09-27T22:46:04Z",
                          "publishedAt": "2022-03-29T23:21:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Hello\nSo you'd want something like PlaneValueSampler? With a regular grid overlaid over the domain?\nGuillaume\n\nI figured it out. the solution that I have suggested initially worked out, i.e BoundingBoxNodeSetGenerator. The problem was that I was using GeneratedMesh instead of GeneratedMeshGenerator  in the Mesh block.",
                          "url": "https://github.com/idaholab/moose/discussions/20664#discussioncomment-2466480",
                          "updatedAt": "2024-09-27T22:46:09Z",
                          "publishedAt": "2022-03-30T03:25:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm glad. If we ever need a solution for less regular grids we can add a PlaneValueSampler that's not a problem",
                          "url": "https://github.com/idaholab/moose/discussions/20664#discussioncomment-2471160",
                          "updatedAt": "2024-09-27T22:46:14Z",
                          "publishedAt": "2022-03-30T15:45:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cannot rebuild petsc and libmesh on cluster during installation",
          "author": {
            "login": "DaijunHU"
          },
          "bodyText": "Dear All,\nTo update the latest moose version on my HPC cluster, which has already got mpich-3.3 and gcc-9.2, I cancelled the previous moose folder and started from curl-L the mambaforge, and it works fine.\nAfter git clone moose, I find that I cannot update and rebuild the petsc.sh and limesh.sh, while the commands were same as what I used successfully last year.\nThe error told me that:  Requires cmake version 3.18.1 or higher: use --download-cmake\nSo I tried with cmake 3.18 or using the --download-cmake,\nbut the error still exists and here I attach the configure.log, which I did not find out the problem.\nconfigure.log\nI attach my install command here, which was suitable for previous moose installation. Also the error.\nInstallationCommand.txt\nInstallError.txt\nPlease let me know if you have suggestions and can help me back to use moose again on the cluster.\nThank you in advance!\nDaijun",
          "url": "https://github.com/idaholab/moose/discussions/20639",
          "updatedAt": "2022-06-16T21:12:12Z",
          "publishedAt": "2022-03-24T13:33:43Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nconfigure found the right gcc but said it was missing some features.\n-- The C compiler identification is GNU 9.2.0\n-- The CXX compiler identification is GNU 9.2.0\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Check for working C compiler: /home/svu/e0751528/gcc-9.2.0/bin/gcc - skipped\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Check for working CXX compiler: /home/svu/e0751528/gcc-9.2.0/bin/g++ - skipped\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Checking if compiler supports C11 _Thread_local\n-- Checking if compiler supports C11 _Thread_local - yes\n-- Checking if compiler supports needed C++17 constructs\n-- Checking if compiler supports needed C++17 constructs - yes\n-- Checking if compiler supports C++ make_unique\n-- Checking if compiler supports C++ make_unique - no\n-- Checking if compiler supports C++ unique_ptr\n-- Checking if compiler supports C++ unique_ptr - no\n-- Checking if compiler supports C++ filesystem\n-- Checking if compiler supports C++ filesystem - no\nSee also \"/home/svu/e0751528/projects/moose/petsc/arch-moose/externalpackages/cmake-3.20.1/CMakeFiles/CMakeOutput.log\".\nSee also \"/home/svu/e0751528/projects/moose/petsc/arch-moose/externalpackages/cmake-3.20.1/CMakeFiles/CMakeError.log\".\n---------------------------------------------\nError when bootstrapping CMake:\nProblem while running initial CMake\n---------------------------------------------gmake: Warning: File `Makefile' has modification time 0.089 s in the future\ngmake: warning:  Clock skew detected.  Your build may be incomplete.\nCMake Error at CMakeLists.txt:107 (message):\n  The C++ compiler does not support C++11 (e.g.  std::unique_ptr).\n\nIs there a newer cmake module you could load from your HPC platform?\nnever seen this before. @milljm seen this before?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20639#discussioncomment-2430479",
                  "updatedAt": "2022-06-16T21:13:54Z",
                  "publishedAt": "2022-03-24T14:13:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "Using a cmake module won't help; many of our dependencies including libmesh should complain of unique_ptr support doesn't exist",
                          "url": "https://github.com/idaholab/moose/discussions/20639#discussioncomment-2430502",
                          "updatedAt": "2022-06-16T21:14:03Z",
                          "publishedAt": "2022-03-24T14:15:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "What you're doing here (--download-cmake) is the right thing to do.\nHere's where the actual error is:\n-- Checking if compiler supports C11 _Thread_local\n-- Checking if compiler supports C11 _Thread_local - yes\n-- Checking if compiler supports needed C++17 constructs\n-- Checking if compiler supports needed C++17 constructs - yes\n-- Checking if compiler supports C++ make_unique\n-- Checking if compiler supports C++ make_unique - no\n-- Checking if compiler supports C++ unique_ptr\n-- Checking if compiler supports C++ unique_ptr - no\n-- Checking if compiler supports C++ filesystem\n-- Checking if compiler supports C++ filesystem - no\n-- Configuring incomplete, errors occurred!\nSee also \"/home/svu/e0751528/projects/moose/petsc/arch-moose/externalpackages/cmake-3.20.1/CMakeFiles/CMakeOutput.log\".\nSee also \"/home/svu/e0751528/projects/moose/petsc/arch-moose/externalpackages/cmake-3.20.1/CMakeFiles/CMakeError.log\".\n---------------------------------------------\nError when bootstrapping CMake:\nProblem while running initial CMake\n---------------------------------------------\n\n<cut>\n\nCMake Error at CMakeLists.txt:107 (message):\n  The C++ compiler does not support C++11 (e.g.  std::unique_ptr).\n\nIt looks like your compiler doesn't support unique_ptr and make_unique. Are you sure that you're using the same mpich/gcc that you used previously?",
                  "url": "https://github.com/idaholab/moose/discussions/20639#discussioncomment-2430495",
                  "updatedAt": "2022-06-16T21:14:04Z",
                  "publishedAt": "2022-03-24T14:14:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "DaijunHU"
                          },
                          "bodyText": "Thank you for your reply.\nIt is gcc-9.2.0 and mpich-3.3, I have checked with the command which gcc.\nIt is same as what I used previously, because I just cancelled the previous moose folder for this update, but did not remove other parts.",
                          "url": "https://github.com/idaholab/moose/discussions/20639#discussioncomment-2434171",
                          "updatedAt": "2022-06-16T21:14:05Z",
                          "publishedAt": "2022-03-25T01:12:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "The paths present in your configure.log suggest you have several compilers in play;\nIntel 2015\nGCC 7.3.0\nGCC 9.2.0\n\nPlease try and clean this up, as this is most likely the cause. You also mention a Mambaforge installation attempt, yet I see no mention of mambaforge paths anywhere in the log. I do see paths being set to other Python installations however:\nPYTHONPATH=/app1/centos6.3/gnu/Python-3.6.4/lib/python3.6/site-packages:/app1/centos6.3/gnu/Python-3.6.4/lib/python3.6:/app1/centos6.3/gnu/SCIlibs\n\nWarning accessing /home/svu/e0751528/miniconda/bin gives errors: [Errno 2] No such file or directory: '/home/svu/e0751528/miniconda/bin'\n\nWhat troubles me, is that I see the following modules loaded when I was expecting more (gcc-9.2.0, intel).\nLOADEDMODULES=cmake/3.9.3:git-2.7.0:python3.6.4\n\nBasically, we need you to clean this up for us. How are you making these compilers available, and do you have a way to turn them off. We need to start in a sane environment before we can continue.",
                  "url": "https://github.com/idaholab/moose/discussions/20639#discussioncomment-2430545",
                  "updatedAt": "2022-06-16T21:14:04Z",
                  "publishedAt": "2022-03-24T14:20:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "DaijunHU"
                          },
                          "bodyText": "Thank you for your reply.\nIf I do not activate those modules, the git command would not work.\nHere I can attach one configure.log that without any modules loaded.\nconfigure.log",
                          "url": "https://github.com/idaholab/moose/discussions/20639#discussioncomment-2434337",
                          "updatedAt": "2022-06-16T21:14:08Z",
                          "publishedAt": "2022-03-25T01:50:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nIn this log you are using GNU 4.8.5 which is too old\n-- The C compiler identification is GNU 4.8.5\n-- The CXX compiler identification is GNU 4.8.5\n\nyou need to load ONE of these compilers and the associated MPI module.\nOn our HPC infrastructure we can look at modules with these commands, maybe they ll help you find the right compilers/mpi:\nmodule avail\nmodule  spider mpi",
                          "url": "https://github.com/idaholab/moose/discussions/20639#discussioncomment-2449124",
                          "updatedAt": "2022-06-16T21:14:06Z",
                          "publishedAt": "2022-03-28T04:04:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "There is still some noise in your environment. With no modules loaded, you still have MPI and Intel Compilers:\nLD_LIBRARY_PATH=/home/svu/e0751528/mpich-3.3/lib:/app1/centos6.3/gnu/gcc-4.8.2/lib64:/app1/centos6.3/gnu/mvapich2-1.9/lib:/usr/lib64/mpich-3.2/lib:/app1/centos6.3/Intel/xe_2015/composer_xe_2015.3.187/compiler/lib/intel64:/app1/centos6.3/Intel/xe_2015/composer_xe_2015.3.187/mpirt/lib/intel64:/app1/centos6.3/Intel/xe_2015/composer_xe_2015.3.187/ipp/../compiler/lib/intel64:/app1/centos6.3/Intel/xe_2015/composer_xe_2015.3.187/ipp/lib/intel64:/app1/centos6.3/Intel/xe_2015/composer_xe_2015.3.187/ipp/tools/intel64/perfsys:/app1/centos6.3/Intel/xe_2015/composer_xe_2015.3.187/compiler/lib/intel64:/app1/centos6.3/Intel/xe_2015/composer_xe_2015.3.187/mkl/lib/intel64:/app1/centos6.3/Intel/xe_2015/composer_xe_2015.3.187/tbb/lib/intel64/gcc4.4:/app1/centos6.3/Intel/xe_2015/composer_xe_2015.3.187/debugger/libipt/intel64/lib:/app1/ia32-64/iLog/opl50/bin/x86-64_rhel4.0_3.4:/app1/common/Apps/gurobi562/linux64/lib:/app1/ia32-64/meep/meep-1.0.3-parallel-icc/lib\nPATH=/home/svu/e0751528/mpich-3.3/bin:/app1/ia32-64/java/current/bin:/app1/centos6.3/gnu/mvapich2-1.9/bin:/usr/lib64/mpich-3.2/bin:/usr/bin:/app1/centos6.3/Intel/xe_2015/composer_xe_2015.3.187/bin/intel64:/app1/centos6.3/Intel/xe_2015/composer_xe_2015.3.187/debugger/gdb/intel64_mic/bin:/app1/ia32-64/iLog/opl50/bin/x86-64_rhel4.0_3.4:/app1/linux/ILOG/CPLEX_Studio125/cplex/bin/x86-64_sles10_4.1:/app1/common/Apps/gurobi562/linux64/bin:/usr/lib64/qt-3.3/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/svu/e0751528/.dotnet/tools:/opt/pbs/bin:/app1/common/bin:/app1/linux/bin:/app1/ia32-64/g03:/app1/ia32-64/bin:/app1/ia32-64/mrbayes-3.1.2:/app1/ia32-64/phase/phase-2.0-src:/app1/ia32-64/gauss/GAUSS_9.0_Linux_amd_64:/usr/lpp/mmfs/bin:/app1/ia32-64/meep/meep-1.0.3-parallel-icc/bin:/app1/mvapich2/latest/bin:/home/svu/e0751528/bin:/app1/ia32-64/bin:/app1/common/matlab/bin:/app1/centos6.3/jdk1.8.0_05/jre/bin:/opt/pbs/bin:/home/svu/e0751528/.local/bin:/home/svu/e0751528/bin\nCC=mpicc\nCXX=mpicxx\n\nI do see you have no modules loaded. Is having MVAPICH2 with Intel compilers default on this machine?\nLD_LIBRARY_PATH still has a lot going on. Two MPI wrappers and an Intel compiler.\nWhile I do see you have your custom built MPICH available before the system's, the system may still get in the way be means of being picked up by an optional configure check. Lets say 'boost',  is being discovered in your Intel Composer path. Once discovered, the link line will include a path to this installation of boost. And by doing so, will include all the other libraries present at that location as well. Which is the makings for a conflict.\nIf you are unable to avoid loading up this Intel 2015, MVAPICH2 1.9 stack, you may have to take a drastic measure of invoking a new shell free of 'everything' and building it back up with the things you want. If you are familiar with bash, and exporting paths, etc... it is a simple process we can try and walk you through.",
                          "url": "https://github.com/idaholab/moose/discussions/20639#discussioncomment-2453270",
                          "updatedAt": "2022-06-16T21:14:06Z",
                          "publishedAt": "2022-03-28T14:44:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "DaijunHU"
                          },
                          "bodyText": "Thank you all for your help. I have installed moose successfully on my cluster.\nGuillaume's suggestion is helpful that maybe the GNU is too old.\nI restarted from the beginning and found that there was something not included in the path correctly: I was using miniconda but now it is mambaforge after update. During my update I mixed some commands about this and thus the correct compiler is not introduced with correct locations. This may be one reason and I really appreciate all your help on this.\nBest regards,\nDaijun",
                          "url": "https://github.com/idaholab/moose/discussions/20639#discussioncomment-2466660",
                          "updatedAt": "2022-06-16T21:14:19Z",
                          "publishedAt": "2022-03-30T04:11:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Comparison of MOOSE-thermomech and COMSOL",
          "author": {
            "login": "ScouperLH"
          },
          "bodyText": "Hello MOOSE experts,\nRecently I wrote a calculation file using MOOSE's thermomech case and then compared the results with COMSOL, using the same settings (including the same boundary conditions, material parameters, heat source and temperature settings). In addition to the same temperature distribution, the displacement and stress results of the two are very different. Any suggestions to improve the MOOSE results or explain the difference?\nThe MOOSE result:\n\n\n\nThe COMSOL result:\n\n\n\nMy input file, outfile, and COMSOL file is here\nhttps://github.com/ScouperLH/MOOSE-test-thermomech.git",
          "url": "https://github.com/idaholab/moose/discussions/20651",
          "updatedAt": "2022-07-02T17:52:37Z",
          "publishedAt": "2022-03-28T13:44:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ScouperLH"
                  },
                  "bodyText": "the input file:\n[Mesh]\n  [gmg]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 40\n    xmax = 0.40\n    ny = 40\n    ymax = 0.40\n    nz = 4\n    zmax = 0.04\n  []\n \n  [block_1]   #delete\n    type = SubdomainBoundingBoxGenerator\n    input = gmg\n    block_id = 1\n    bottom_left = '0 0 0.02'\n    top_right = '0.40 0.40 0.04'\n  []\n  [block_2]  #heat-source\n    type = SubdomainBoundingBoxGenerator\n    input = block_1\n    block_id = 2\n    bottom_left = '0.18 0.18 0.02'\n    top_right = '0.22 0.22 0.04'\n  []\n  [./ed0]\n     type = BlockDeletionGenerator\n     input = block_2\n      block = 1\n  [../]\n\n\n  \n  [boundary_left_0]\n    type = SideSetsAroundSubdomainGenerator\n    input = ed0\n    block = 0\n    normal = '-1 0 0'\n    new_boundary = 'left_0'\n  []\n  [boundary_bot_0]\n    type = SideSetsAroundSubdomainGenerator\n    input = boundary_left_0\n    block = 0\n    normal = '0 0 -1'\n    new_boundary = 'bot_0'\n  []\n  [boundary_right_0]\n    type = SideSetsAroundSubdomainGenerator\n    input = boundary_bot_0\n    block = 0\n    normal = '1 0 0'\n    new_boundary = 'right_0'\n  []\n  [boundary_front_0]\n    type = SideSetsAroundSubdomainGenerator\n    input = boundary_right_0\n    block = 0\n    normal = '0 -1 0'\n    new_boundary = 'front_0'\n  []\n  [boundary_back_0]\n    type = SideSetsAroundSubdomainGenerator\n    input = boundary_front_0\n    block = 0\n    normal = '0 1 0'\n    new_boundary = 'back_0'\n  []\n  [boundary_top_2]\n    type = SideSetsAroundSubdomainGenerator\n    input = boundary_back_0\n    block = 2\n    normal = '0 0 1'\n    new_boundary = 'top_2'\n  []\n  [boundary_left_2]\n    type = SideSetsAroundSubdomainGenerator\n    input = boundary_top_2\n    block = 2\n    normal = '-1 0 0'\n    new_boundary = 'left_2'\n  []\n  [boundary_right_2]\n    type = SideSetsAroundSubdomainGenerator\n    input = boundary_left_2\n    block = 2\n    normal = '1 0 0'\n    new_boundary = 'right_2'\n  []\n  [boundary_front_2]\n    type = SideSetsAroundSubdomainGenerator\n    input = boundary_right_2\n    block = 2\n    normal = '0 -1 0'\n    new_boundary = 'front_2'\n  []\n  [boundary_back_2]\n    type = SideSetsAroundSubdomainGenerator\n    input = boundary_front_2\n    block = 2\n    normal = '0 1 0'\n    new_boundary = 'back_2'\n  []\n   uniform_refine = 1\n[]\n\n[Variables]\n   [T]\n    block = '0 2'\n    initial_condition = 293\n  []\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n[]\n\n[Kernels]\n  [hc_0]\n    type = HeatConduction\n    variable = T\n    block ='0 2'\n  []\n  [TensorMechanics]\n    displacements = 'disp_x disp_y disp_z'\n  []\n  [source_0]\n    type = HeatSource\n    variable = T\n    function = volumetric_heat\n    block =2\n  []\n[]\n\n[Functions]\n   [./volumetric_heat]\n     type = ParsedFunction\n     value = 9.375e6 #w/m3\n     #i dont know why that volume heat source is 10e-2 of the right value\n     #right value is 9.375e8\n  [../]\n[]\n\n\n[AuxVariables]\n  [./von_mises]\n    #Dependent variable used to visualize the Von Mises stress\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./von_mises_kernel]\n    #Calculates the von mises stress and assigns it to von_mises\n    type = RankTwoScalarAux\n    variable = von_mises\n    rank_two_tensor = stress\n    execute_on = timestep_end\n    scalar_type = VonMisesStress\n  [../]\n[]\n\n\n\n[BCs]\n   [bc_0]\n    type = ConvectiveHeatFluxBC\n    boundary = 'left_0 right_0 back_0 front_0'\n    variable = T\n    heat_transfer_coefficient =  5 # W/K/m^2\n    T_infinity = 300.0\n   []\n   [bc_source_2]\n     type = ConvectiveHeatFluxBC\n     boundary = 'left_2 right_2 back_2 front_2 top_2'\n     variable = T\n     heat_transfer_coefficient = 5 # W/K/m^2\n     T_infinity = 300.0\n    []\n\n  [./bc_cold_0]\n    type = DirichletBC\n    variable = T\n    boundary = 'bot_0'\n    value =293.0\n  [../]\n\n  [disp_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left_0'\n    value = 0.0\n  []\n  [disp_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'front_0'\n    value = 0.0\n  []\n  [disp_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bot_0'\n    value = 0.0\n  []\n[]\n\n[Materials]\n  [cond_2]#reyuan\n    type = GenericConstantMaterial\n    block = 2\n    prop_names = thermal_conductivity\n    prop_values = 54\n  []\n  [cond_0] #lengban\n    type = GenericConstantMaterial\n    block = 0\n    prop_names = thermal_conductivity\n    prop_values = 202.3\n  []\n\n  [elasticity_tensor_reyuan]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 8.85e10\n    poissons_ratio = 0.31\n    block = 2\n  []\n\n  [elasticity_tensor_lengban]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 7.1e10\n    poissons_ratio = 0.33\n    block = 0\n  []\n\n\n  [thermal_strain_reyuan]\n    type = ComputeThermalExpansionEigenstrain\n    thermal_expansion_coeff = 6.4e-6\n    temperature = T\n    stress_free_temperature = 298\n    eigenstrain_name = eigenstrain_reyuan\n    block = 2\n  []\n  [thermal_strain_lengban]\n    type = ComputeThermalExpansionEigenstrain\n    thermal_expansion_coeff = 2.3e-5\n    temperature = T\n    stress_free_temperature = 298\n    eigenstrain_name = eigenstrain_lengban\n    block = 0\n  []\n\n\n  [strain_reyuan]\n    type = ComputeSmallStrain\n    displacements = 'disp_x disp_y disp_z'\n    eigenstrain_names = 'eigenstrain_reyuan'\n    block = 2\n  []\n  [strain_lengban]\n    type = ComputeSmallStrain\n    displacements = 'disp_x disp_y disp_z'\n    eigenstrain_names = 'eigenstrain_lengban'\n    block = 0\n  []\n  [stress] #We use linear elasticity\n    type = ComputeLinearElasticStress\n  []\n\n[]\n\n\n[Executioner]\n  type = Steady\n  #automatic_scaling = true\n\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart'\n  petsc_options_value = 'hypre boomeramg 101'\n\n  l_max_its = 30\n  nl_max_its = 100\n  nl_abs_tol = 1e-14\n  l_tol = 1e-06\n[]\n\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n  []\n[]\n\n[Outputs]\n  file_base = reli9_out\n  perf_graph = true\n  exodus = true\n  csv = false\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/20651#discussioncomment-2452742",
                  "updatedAt": "2022-07-02T17:52:34Z",
                  "publishedAt": "2022-03-28T13:45:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nVisually temperature and displacement look very close to me. Could you please plot the relative difference? You can use paraview filters to perform such comparisons.\nThe VonMises stress does look different, but also it seems the MOOSE results are plotted on a per-element basis (CONST MONOMIAL auxvariable probably) while the COMSOL results are plotted on a continuous basis. So this could be just an artifact of the output, with the colorscale being very skewed due to different maxima reached by different shape functions. I would project the COMSOL result and look at the relative difference again here.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20651#discussioncomment-2453250",
                  "updatedAt": "2022-07-02T17:53:17Z",
                  "publishedAt": "2022-03-28T14:42:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ScouperLH"
                          },
                          "bodyText": "Thank you, sir! I exported the COMSOL results to Paraview for comparison, and used cell data to point data for the MOOSE results. The contour is indeed smoother, but the maximum stress value has not changed, and the gap between them is still quite large. Then I tried to refine the mesh, which worked.",
                          "url": "https://github.com/idaholab/moose/discussions/20651#discussioncomment-2466238",
                          "updatedAt": "2022-07-02T17:53:18Z",
                          "publishedAt": "2022-03-30T02:22:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "If I were you I would double check the units before looking into anything else.\nAlso note that the stress values are extremely sensitive to the way you project them when there are concentrations (like the corners in your model). I wouldn't worry too much if the primary variables (in this case displacements and temperature) are matching. But if you really want to make a comparison, try to be fair. There are a couple of ways to project material properties from quadrature points onto basis suitable for outputting. Monomials are a common choice. MOOSE also has the nodal patch recovery capability to help you construct a local projection. Paraview also provides a \"cell value to point value\" filter that does mostly the same thing.",
                  "url": "https://github.com/idaholab/moose/discussions/20651#discussioncomment-2455881",
                  "updatedAt": "2022-07-02T17:53:49Z",
                  "publishedAt": "2022-03-28T19:51:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ScouperLH"
                          },
                          "bodyText": "Thank you for your suggestion! I checked the unit again and found that there are indeed errors, after fixing them, I tried the method you said, using cell data to point data in paraview, the result did not change, but your suggestion reminded me that the stress is in the concentration area It is very sensitive to the project method, so I tried to refine the mesh and it worked.",
                          "url": "https://github.com/idaholab/moose/discussions/20651#discussioncomment-2466268",
                          "updatedAt": "2022-07-02T17:54:18Z",
                          "publishedAt": "2022-03-30T02:29:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Helgrind errors with perf graph",
          "author": {
            "login": "lindsayad"
          },
          "bodyText": "I get a lot helgrind errors related to the perf graph. Here is an example\n==1236015== ----------------------------------------------------------------\n==1236015== \n==1236015==  Lock at 0x155E1C80 was first observed\n==1236015==    at 0x4C355F8: mutex_lock_WRK (hg_intercepts.c:909)\n==1236015==    by 0x4C394C4: pthread_mutex_lock (hg_intercepts.c:925)\n==1236015==    by 0x860D052: __gthread_mutex_lock (gthr-default.h:749)\n==1236015==    by 0x860D052: lock (std_mutex.h:100)\n==1236015==    by 0x860D052: lock (unique_lock.h:141)\n==1236015==    by 0x860D052: unique_lock (unique_lock.h:71)\n==1236015==    by 0x860D052: PerfGraphLivePrint::start() (PerfGraphLivePrint.C:304)\n==1236015==    by 0x10ACF2BF: execute_native_thread_routine (thread.cc:80)\n==1236015==    by 0x4C381C3: mythread_wrapper (hg_intercepts.c:389)\n==1236015==    by 0xED7B149: start_thread (in /usr/lib64/libpthread-2.28.so)\n==1236015==    by 0x118B0F22: clone (in /usr/lib64/libc-2.28.so)\n==1236015==  Address 0x155e1c80 is 401,040 bytes inside a block of size 401,160 alloc'd\n==1236015==    at 0x4C32976: operator new(unsigned long) (vg_replace_malloc.c:344)\n==1236015==    by 0x856FEAE: make_unique<PerfGraph, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, MooseApp&, bool const&, bool> (unique_ptr.h:857)\n==1236015==    by 0x856FEAE: RestartableData<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, MooseApp&, bool const&, bool> (RestartableData.h:97)\n==1236015==    by 0x856FEAE: make_unique<RestartableData<PerfGraph>, char const (&)[11], MooseApp*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, MooseApp&, bool const&, bool> (unique_ptr.h:857)\n==1236015==    by 0x856FEAE: MooseApp::createRecoverablePerfGraph() (MooseApp.C:2704)\n==1236015==    by 0x8579E32: MooseApp::MooseApp(InputParameters) (MooseApp.C:325)\n==1236015==    by 0x56C7ED5: NavierStokesApp::NavierStokesApp(InputParameters) (NavierStokesApp.C:32)\n==1236015==    by 0x4EB253B: NavierStokesTestApp::NavierStokesTestApp(InputParameters) (NavierStokesTestApp.C:25)\n==1236015==    by 0x4EB5D93: void __gnu_cxx::new_allocator<NavierStokesTestApp>::construct<NavierStokesTestApp, InputParameters const&>(NavierStokesTestApp*, InputParameters const&) [clone .isra.0] (new_allocator.h:147)\n==1236015==    by 0x4EB6308: construct<NavierStokesTestApp, const InputParameters&> (alloc_traits.h:484)\n==1236015==    by 0x4EB6308: _Sp_counted_ptr_inplace<const InputParameters&> (shared_ptr_base.h:548)\n==1236015==    by 0x4EB6308: __shared_count<NavierStokesTestApp, std::allocator<NavierStokesTestApp>, const InputParameters&> (shared_ptr_base.h:679)\n==1236015==    by 0x4EB6308: __shared_ptr<std::allocator<NavierStokesTestApp>, const InputParameters&> (shared_ptr_base.h:1344)\n==1236015==    by 0x4EB6308: shared_ptr<std::allocator<NavierStokesTestApp>, const InputParameters&> (shared_ptr.h:359)\n==1236015==    by 0x4EB6308: allocate_shared<NavierStokesTestApp, std::allocator<NavierStokesTestApp>, const InputParameters&> (shared_ptr.h:702)\n==1236015==    by 0x4EB6308: make_shared<NavierStokesTestApp, const InputParameters&> (shared_ptr.h:718)\n==1236015==    by 0x4EB6308: std::shared_ptr<MooseApp> buildApp<NavierStokesTestApp>(InputParameters const&) (AppFactory.h:51)\n==1236015==    by 0x850953F: AppFactory::createShared(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, InputParameters, int) (AppFactory.C:79)\n==1236015==    by 0x8509C0F: AppFactory::createAppShared(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int, char**, int) (AppFactory.C:47)\n==1236015==    by 0x40265E: main (main.C:30)\n==1236015==  Block was alloc'd by thread #1\n==1236015== \n==1236015== Possible data race during write of size 4 at 0x155E1C04 by thread #1\n==1236015== Locks held: none\n==1236015==    at 0x871151B: store (atomic_base.h:397)\n==1236015==    by 0x871151B: addToExecutionList (PerfGraph.C:176)\n==1236015==    by 0x871151B: PerfGraph::pop() (PerfGraph.C:256)\n==1236015==    by 0x7E4D05B: ~PerfGuard (PerfGuard.h:38)\n==1236015==    by 0x7E4D05B: FEProblemBase::initialSetup() (FEProblemBase.C:754)\n==1236015==    by 0x7F5C81A: Steady::init() (Steady.C:57)\n==1236015==    by 0x85671F2: MooseApp::executeExecutioner() (MooseApp.C:1074)\n==1236015==    by 0x856CE27: MooseApp::run() (MooseApp.C:1460)\n==1236015==    by 0x402687: main (main.C:35)\n==1236015== \n==1236015== This conflicts with a previous read of size 4 by thread #2\n==1236015== Locks held: 1, at address 0x155E1C80\n==1236015==    at 0x860D0A7: load (atomic_base.h:419)\n==1236015==    by 0x860D0A7: operator() (PerfGraphLivePrint.C:325)\n==1236015==    by 0x860D0A7: wait_until<std::chrono::_V2::steady_clock, std::chrono::duration<long int, std::ratio<1, 1000000000> >, PerfGraphLivePrint::start()::<lambda()> > (condition_variable:137)\n==1236015==    by 0x860D0A7: wait_for<double, std::ratio<1>, PerfGraphLivePrint::start()::<lambda()> > (condition_variable:166)\n==1236015==    by 0x860D0A7: PerfGraphLivePrint::start() (PerfGraphLivePrint.C:319)\n==1236015==    by 0x10ACF2BF: execute_native_thread_routine (thread.cc:80)\n==1236015==    by 0x4C381C3: mythread_wrapper (hg_intercepts.c:389)\n==1236015==    by 0xED7B149: start_thread (in /usr/lib64/libpthread-2.28.so)\n==1236015==    by 0x118B0F22: clone (in /usr/lib64/libc-2.28.so)\n==1236015==  Address 0x155e1c04 is 400,916 bytes inside a block of size 401,160 alloc'd\n==1236015==    at 0x4C32976: operator new(unsigned long) (vg_replace_malloc.c:344)\n==1236015==    by 0x856FEAE: make_unique<PerfGraph, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, MooseApp&, bool const&, bool> (unique_ptr.h:857)\n==1236015==    by 0x856FEAE: RestartableData<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, MooseApp&, bool const&, bool> (RestartableData.h:97)\n==1236015==    by 0x856FEAE: make_unique<RestartableData<PerfGraph>, char const (&)[11], MooseApp*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, MooseApp&, bool const&, bool> (unique_ptr.h:857)\n==1236015==    by 0x856FEAE: MooseApp::createRecoverablePerfGraph() (MooseApp.C:2704)\n==1236015==    by 0x8579E32: MooseApp::MooseApp(InputParameters) (MooseApp.C:325)\n==1236015==    by 0x56C7ED5: NavierStokesApp::NavierStokesApp(InputParameters) (NavierStokesApp.C:32)\n==1236015==    by 0x4EB253B: NavierStokesTestApp::NavierStokesTestApp(InputParameters) (NavierStokesTestApp.C:25)\n==1236015==    by 0x4EB5D93: void __gnu_cxx::new_allocator<NavierStokesTestApp>::construct<NavierStokesTestApp, InputParameters const&>(NavierStokesTestApp*, InputParameters const&) [clone .isra.0] (new_allocator.h:147)\n==1236015==    by 0x4EB6308: construct<NavierStokesTestApp, const InputParameters&> (alloc_traits.h:484)\n==1236015==    by 0x4EB6308: _Sp_counted_ptr_inplace<const InputParameters&> (shared_ptr_base.h:548)\n==1236015==    by 0x4EB6308: __shared_count<NavierStokesTestApp, std::allocator<NavierStokesTestApp>, const InputParameters&> (shared_ptr_base.h:679)\n==1236015==    by 0x4EB6308: __shared_ptr<std::allocator<NavierStokesTestApp>, const InputParameters&> (shared_ptr_base.h:1344)\n==1236015==    by 0x4EB6308: shared_ptr<std::allocator<NavierStokesTestApp>, const InputParameters&> (shared_ptr.h:359)\n==1236015==    by 0x4EB6308: allocate_shared<NavierStokesTestApp, std::allocator<NavierStokesTestApp>, const InputParameters&> (shared_ptr.h:702)\n==1236015==    by 0x4EB6308: make_shared<NavierStokesTestApp, const InputParameters&> (shared_ptr.h:718)\n==1236015==    by 0x4EB6308: std::shared_ptr<MooseApp> buildApp<NavierStokesTestApp>(InputParameters const&) (AppFactory.h:51)\n==1236015==    by 0x850953F: AppFactory::createShared(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, InputParameters, int) (AppFactory.C:79)\n==1236015==    by 0x8509C0F: AppFactory::createAppShared(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int, char**, int) (AppFactory.C:47)\n==1236015==    by 0x40265E: main (main.C:30)\n==1236015==  Block was alloc'd by thread #1\n\n@friedmud or maybe @loganharbour are these avoidable?",
          "url": "https://github.com/idaholab/moose/discussions/19443",
          "updatedAt": "2022-06-14T14:01:28Z",
          "publishedAt": "2021-11-21T00:49:38Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "It looks like we just need another lock for the execution list?",
                  "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-1678111",
                  "updatedAt": "2022-06-14T14:01:29Z",
                  "publishedAt": "2021-11-21T18:48:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "This is interesting... we shouldn't need a lock on the Execution List because it uses memory fencing and an atomic to control access to it.  I wonder if it's a limitation in what Hellgrind can detect (maybe it hasn't been upgraded to support C++11 memory fences properly).",
                          "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-1768105",
                          "updatedAt": "2022-06-14T14:01:29Z",
                          "publishedAt": "2021-12-07T18:47:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "We should try a fix for this like @lindsayad implemented in libmesh here: libMesh/libmesh#3128",
                  "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-2128993",
                  "updatedAt": "2022-06-14T14:01:29Z",
                  "publishedAt": "2022-02-07T22:13:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@friedmud can we close this",
                          "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-2234019",
                          "updatedAt": "2022-06-14T14:01:29Z",
                          "publishedAt": "2022-02-23T06:56:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Yes we can",
                          "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-2237160",
                          "updatedAt": "2022-06-14T14:01:34Z",
                          "publishedAt": "2022-02-23T15:05:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Just ran across another one\nWARNING: ThreadSanitizer: data race (pid=4117391)\n  Write of size 4 at 0x7f5f2c35f100 by main thread:\n    #0 PerfGraph::addToExecutionList(unsigned int, PerfGraph::IncrementState, std::chrono::time_point<std::chrono::_V2::steady_clock, std::chrono::duration<long, std::ratio<1l, 1000000000l> > >, long) /home/lindad/projects4/moose/framework/src/utils/PerfGraph.C:157:25 (libmoose-devel.so.0+0x1f65eb5)\n    #1 PerfGraph::pop() /home/lindad/projects4/moose/framework/src/utils/PerfGraph.C:257:5 (libmoose-devel.so.0+0x1f65eb5)\n    #2 PerfGuard::~PerfGuard() /home/lindad/projects4/moose/framework/build/header_symlinks/PerfGuard.h:38:25 (libmoose-devel.so.0+0x17c8cbb)\n    #3 FEProblemBase::solve() /home/lindad/projects4/moose/framework/src/problems/FEProblemBase.C:5063:1 (libmoose-devel.so.0+0x17c8cbb)\n    #4 FEProblemSolve::solve() /home/lindad/projects4/moose/framework/src/executioners/FEProblemSolve.C:226:14 (libmoose-devel.so.0+0xfa33dd)\n    #5 FixedPointSolve::solveStep(double&, double&, std::set<unsigned long, std::less<unsigned long>, std::allocator<unsigned long> > const&) /home/lindad/projects4/moose/framework/src/executioners/FixedPointSolve.C:392:22 (libmoose-devel.so.0+0xfaa782)\n    #6 FixedPointSolve::solve() /home/lindad/projects4/moose/framework/src/executioners/FixedPointSolve.C:273:28 (libmoose-devel.so.0+0xfa8446)\n    #7 TimeStepper::step() /home/lindad/projects4/moose/framework/src/timesteppers/TimeStepper.C:163:52 (libmoose-devel.so.0+0x101d08b)\n    #8 Transient::takeStep(double) /home/lindad/projects4/moose/framework/src/executioners/Transient.C:446:18 (libmoose-devel.so.0+0xfbb451)\n    #9 Transient::execute() /home/lindad/projects4/moose/framework/src/executioners/Transient.C:331:5 (libmoose-devel.so.0+0xfba0ff)\n    #10 MooseApp::executeExecutioner() /home/lindad/projects4/moose/framework/src/base/MooseApp.C:1083:19 (libmoose-devel.so.0+0x1eca831)\n    #11 MooseTestApp::executeExecutioner() /home/lindad/projects4/moose/test/src/base/MooseTestApp.C:83:13 (libmoose_test-devel.so.0+0x9a97a4)\n    #12 MooseApp::run() /home/lindad/projects4/moose/framework/src/base/MooseApp.C:1467:5 (libmoose-devel.so.0+0x1ecef85)\n    #13 main /home/lindad/projects4/moose/test/src/main.C:33:8 (moose_test-devel+0x4bd41d)\n\n  Previous read of size 8 at 0x7f5f2c35f100 by thread T1 (mutexes: write M2042):\n    #0 memcpy <null> (moose_test-devel+0x433f1e)\n    #1 PerfGraphLivePrint::iterateThroughExecutionList() /home/lindad/projects4/moose/framework/src/utils/PerfGraphLivePrint.C:260:41 (libmoose-devel.so.0+0x1f26412)\n    #2 PerfGraphLivePrint::start() /home/lindad/projects4/moose/framework/src/utils/PerfGraphLivePrint.C:379:5 (libmoose-devel.so.0+0x1f26ee5)\n    #3 PerfGraph::PerfGraph(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, MooseApp&, bool, bool)::$_0::operator()() const /home/lindad/projects4/moose/framework/src/utils/PerfGraph.C:54:61 (libmoose-devel.so.0+0x1f685e2)\n    #4 void std::__invoke_impl<void, PerfGraph::PerfGraph(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, MooseApp&, bool, bool)::$_0>(std::__invoke_other, PerfGraph::PerfGraph(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, MooseApp&, bool, bool)::$_0&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/invoke.h:61:14 (libmoose-devel.so.0+0x1f685e2)\n    #5 std::__invoke_result<PerfGraph::PerfGraph(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, MooseApp&, bool, bool)::$_0>::type std::__invoke<PerfGraph::PerfGraph(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, MooseApp&, bool, bool)::$_0>(PerfGraph::PerfGraph(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, MooseApp&, bool, bool)::$_0&&) /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/invoke.h:96:14 (libmoose-devel.so.0+0x1f685e2)\n    #6 void std::thread::_Invoker<std::tuple<PerfGraph::PerfGraph(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, MooseApp&, bool, bool)::$_0> >::_M_invoke<0ul>(std::_Index_tuple<0ul>) /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/std_thread.h:253:13 (libmoose-devel.so.0+0x1f685e2)\n    #7 std::thread::_Invoker<std::tuple<PerfGraph::PerfGraph(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, MooseApp&, bool, bool)::$_0> >::operator()() /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/std_thread.h:260:11 (libmoose-devel.so.0+0x1f685e2)\n    #8 std::thread::_State_impl<std::thread::_Invoker<std::tuple<PerfGraph::PerfGraph(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, MooseApp&, bool, bool)::$_0> > >::_M_run() /usr/bin/../lib/gcc/x86_64-linux-gnu/11/../../../../include/c++/11/bits/std_thread.h:211:13 (libmoose-devel.so.0+0x1f685e2)\n    #9 <null> <null> (libstdc++.so.6+0xda693)",
                          "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-2240054",
                          "updatedAt": "2022-06-14T14:01:33Z",
                          "publishedAt": "2022-02-23T23:18:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Again, I think this is due to TSAN not understanding atomic thread fences I was looking at the old code. These TSAN errors are with the atomic variables release-acquire scheme. Boo. This must be a case where we are hitting the acquire before release in which case there is no syncs-with relationship",
                          "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-2240137",
                          "updatedAt": "2022-07-09T01:01:43Z",
                          "publishedAt": "2022-02-23T23:40:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "acquire before release is not a problem though... because the printing thread just won't see any new info.\nWith the way it's coded there are two options:\n\nYou see an update and all of the data you need for that update has been published by a release.\nYou don't see an update.",
                          "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-2247417",
                          "updatedAt": "2022-07-09T01:01:43Z",
                          "publishedAt": "2022-02-24T23:01:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "Note: there will be LOTS of acquires before release.  The point is not to make one wait on the other... it's to make sure that if one thread says \"there is new data!\" - the other thread can completely read all of that data.",
                          "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-2247428",
                          "updatedAt": "2022-07-09T01:01:43Z",
                          "publishedAt": "2022-02-24T23:03:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Do you think TSAN is reporting a false positive?",
                          "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-2253485",
                          "updatedAt": "2022-07-09T01:01:43Z",
                          "publishedAt": "2022-02-25T19:01:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Just wanted to say that I'm a huge fan of perf graph by the way. It's a very cool capability. And it's clear that even if there are \"errors\" (and maybe there are not), it doesn't affect MOOSE simulations as evidenced by the stability of the test suite. My only motivation here is to try and make it easier to detect data races that do affect MOOSE simulations. So if TSAN is reporting false positives, then that's ok, I can just --disable-perf-graph-live when trying to track down the true threading bugs that cause true issues",
                          "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-2253559",
                          "updatedAt": "2022-07-09T01:01:43Z",
                          "publishedAt": "2022-02-25T19:14:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "@lindsayad thanks - it will be even better once we get these boogie men worked out.  I'm convinced that there is nothing actually wrong... but as long as we can maintain performance and make our tools happy... we may as well.",
                          "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-2274024",
                          "updatedAt": "2022-07-09T01:01:44Z",
                          "publishedAt": "2022-03-01T15:24:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "For my reference, whether false or true positive, the last race trace comes from\ntest/tests/geomsearch/3d_moving_penetration_smoothing/pl_test3nns.i",
                          "url": "https://github.com/idaholab/moose/discussions/19443#discussioncomment-2456637",
                          "updatedAt": "2022-07-09T01:01:44Z",
                          "publishedAt": "2022-03-28T22:11:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "spatial gradient of material",
          "author": {
            "login": "mortezaaesmaeilpour"
          },
          "bodyText": "Dear MOOSE team\nas I know it is easy to use spatial derivatives of main variables (EX: _grad_p(coupledGradient(\"pressure\"))). Is it also possible to easily calculate and use spatial derivatives of material components (like _grad_viscosity)? I know it is possible to calculate the derivative of material over the main variable (https://mooseframework.inl.gov/source/materials/DerivativeMaterialInterface.html). But, here my question is about SPATIAL derivatives, like a derivative of viscosity over X, Y, Z.\nKind regards\nMorteza",
          "url": "https://github.com/idaholab/moose/discussions/20628",
          "updatedAt": "2022-06-28T10:42:38Z",
          "publishedAt": "2022-03-23T13:48:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo there are two options:\n\n\nDefine it yourself in a new material property.\ngrad_mu = dmu/dT grad_T + dmu/dP grad_P\nyou can create a new material that does exactly that.\n\n\nHack the derivative material interface system, using 'x' as a variable or a material property.\nI ll post how to do this later, got to check something first\n\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20628#discussioncomment-2433493",
                  "updatedAt": "2022-06-28T10:42:38Z",
                  "publishedAt": "2022-03-24T22:21:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mortezaaesmaeilpour"
                          },
                          "bodyText": "Yes, I was looking for the second option.",
                          "url": "https://github.com/idaholab/moose/discussions/20628#discussioncomment-2436264",
                          "updatedAt": "2022-06-28T10:42:46Z",
                          "publishedAt": "2022-03-25T09:36:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "simopier"
                          },
                          "bodyText": "Hi @GiudGiud,\nI am currently trying to do something similar in a kernel that would uses the gradient of the hydrostatic stress. The hydrostatic stress is provided as a material property by the tensor mechanics module. Since it can be affected by many variables (displacements, temperature, pressure, etc.), defining its gradient in a new material property can be challenging.\nIn this issue, you hinted at some ongoing development that would allow this. Do you have any updates on that?\nThank you!\nBest,\nPC",
                          "url": "https://github.com/idaholab/moose/discussions/20628#discussioncomment-2440831",
                          "updatedAt": "2022-06-28T10:42:47Z",
                          "publishedAt": "2022-03-25T23:20:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@simopier I was mentioning the functor material property system. It's actually merged in MOOSE. It evaluates material properties (and their gradient, time derivatives etc) on demand, at arbitrary locations.\nIt's quite easy to use but it's not pluggable in the interface for regular material properties. I can point you to some examples if you want to have a look. We currently only use it in the Navier Stokes module.\n@mortezaaesmaeilpour no luck on DerivativeParsedMaterial, it seems to only do symbolic derivations, gives me 0 for the derivatives.\nIf you dont go with 1., you have two other options to compute gradients of material properties:\n\n\nthe functor material system, see this documentation.\nhttps://mooseframework.inl.gov/syntax/Materials/#e36f00e4-37cd-45d4-a2f6-61c87f218c47\nIt'll require some changes in all your material properties.\n\n\nusing automatic differentiation and retrieving the derivative (wrt to a main non linear variable) from the AD number, see this documentation https://mooseframework.inl.gov/moose/modules/phase_field/FunctionMaterials/AutomaticDifferentiation.html",
                          "url": "https://github.com/idaholab/moose/discussions/20628#discussioncomment-2449512",
                          "updatedAt": "2022-06-30T18:04:34Z",
                          "publishedAt": "2022-03-28T05:53:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @mortezaaesmaeilpour\nIn the past, I did the following:\n\ndefine a first monomial AuxVariable, representing the material property that you want to derive\nuse the AuxKernel MaterialStdVectorAux to assign to the first monomial variable the material property\nuse VariableGradientComponent to calculate its derivative and assign it to another constant monomial AuxVariable\ngetMaterialProperty in kernels or materials to import the value of the derivative.\n\nYou can see an example here:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/test/tests/SandfeldZaiser2015/SandfeldLoop.i\nthe auxvariable of interest is called \"dislov\" and \"ddislovdx\" is the derivative.\nI am looking forward to hear from @GiudGiud  about better strategies to do this.\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/20628#discussioncomment-2446271",
                  "updatedAt": "2022-06-30T18:04:35Z",
                  "publishedAt": "2022-03-27T12:41:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mortezaaesmaeilpour"
                          },
                          "bodyText": "Hi @ngrilli\nDo you think It is a good idea to convert a material property to an AuxVariavle and use the spatial derivative of this AuxVariable for the calculations of redial and Jacobians in kernels? I mean the material properties and main variables are supposed to be calculated simultaneously. However, AuxVariables are not included in the main solution matrix.\nKind regards\nMorteza",
                          "url": "https://github.com/idaholab/moose/discussions/20628#discussioncomment-2446568",
                          "updatedAt": "2022-06-30T18:05:09Z",
                          "publishedAt": "2022-03-27T14:12:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @mortezaaesmaeilpour\nIt depends on your specific problem.\nA material property is meant to represent a quantity that can be derived from the problem variables.\nSure material properties and auxvariables are not solved for, in the FEM sense, as you said.\nYou can always substitute material properties with variables and kernels for their evolution equation,\nbut this is not always necessary, it depends on the problem.\nIf it is a \"good\" or \"bad\" idea depends on the numerical problem you are solving for.\nI normally work with plasticity models, in which plastic deformation is set as a material property\nand updated explicitly. Of course, it would be always possible to add it as a variable instead,\nbut that would make the simulation much slower without giving any improvement in the precision.\nIt's up to your specific problem and how people have addressed it in the literature.\nA material property or auxvariable is something you calculate while variables are kept fixed in a time step.\nOn the other hand, variables are updated while material properties are kept fixed.\nYou can think about it as a staggered scheme.\nBest Regards,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/20628#discussioncomment-2457062",
                          "updatedAt": "2022-06-30T18:05:10Z",
                          "publishedAt": "2022-03-29T00:01:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Apply shear traction",
          "author": {
            "login": "ndaman"
          },
          "bodyText": "I feel like I am misunderstanding the pressure BC system, I am trying to apply shear tractions on outer boundary of a 2D square (to compare with the homogenization system with periodic boundaries). The relevant BC's that I have in my input file are:\n[top]\ntype = Pressure\nboundary = top\nfactor = 1\nvariable = disp_x\ncomponent = 0\n[]\n[right]\ntype = Pressure\nboundary = right\nfactor = 1\nvariable = disp_y\ncomponent = 1\n[]\n[bottom]\ntype = Pressure\nboundary = bottom\nfactor = -1\nvariable = disp_x\ncomponent = 0\n[]\n[left]\ntype = Pressure\nboundary = left\nfactor = -1\nvariable = disp_y\ncomponent = 1\n[]\nWhen run this way, the model appears to have no tractions at all. If we focus on just the top (with a normal vector in the positive y direction), how would I apply a traction that acts in the positive x-direction only?",
          "url": "https://github.com/idaholab/moose/discussions/20647",
          "updatedAt": "2022-07-05T18:35:10Z",
          "publishedAt": "2022-03-26T03:26:49Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You want to use NeumannBCs",
                  "url": "https://github.com/idaholab/moose/discussions/20647#discussioncomment-2441476",
                  "updatedAt": "2022-07-05T18:35:21Z",
                  "publishedAt": "2022-03-26T03:41:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ndaman"
                          },
                          "bodyText": "Ah, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/20647#discussioncomment-2443448",
                          "updatedAt": "2022-07-05T18:35:16Z",
                          "publishedAt": "2022-03-26T16:17:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The form of the basis function",
          "author": {
            "login": "nuomi68"
          },
          "bodyText": "How do I change the form of the basis function ? What is its default value? I didn't find  instructions on the official website.I hope someone can answer that,thanks",
          "url": "https://github.com/idaholab/moose/discussions/20624",
          "updatedAt": "2022-04-05T03:13:13Z",
          "publishedAt": "2022-03-23T06:42:19Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can change it for every variable in the [Variables] block. If you want a new one we currently dont support, you ll have to develop in libmesh\nsee\nhttps://mooseframework.inl.gov/source/variables/MooseVariable.html\nPlease note that not every basis works for every problem, some kernels wont expect some exotic basis and you'll probably get a seg fault on the most exotic ones.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20624#discussioncomment-2423387",
                  "updatedAt": "2022-03-23T15:05:11Z",
                  "publishedAt": "2022-03-23T15:05:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "nuomi68"
                          },
                          "bodyText": "It's been very helpful. Thank you very much",
                          "url": "https://github.com/idaholab/moose/discussions/20624#discussioncomment-2443163",
                          "updatedAt": "2022-03-26T14:45:01Z",
                          "publishedAt": "2022-03-26T14:45:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Structure and array implemention in MOOSE",
          "author": {
            "login": "sSajjad90"
          },
          "bodyText": "Hi,\nI was wondering how I could implement  \"structure\" and an \"array\" in ***.C and ***.h files.\nIn the following, you could see a part of the code already written in C++ and I am trying to implement the same code in the moose but I do not know the true argument.\nThanks in advance for your help\nstruct calc\n{\n\tdouble left;\n\tdouble right;\n\tdouble func[5];\n};\n\n\n.\n.\n.\n\tstruct calc domi[500];\n\tdouble f0, f1, f2, f3, f4;\n\n\tint top = 0;\n\tdouble a = aVar;\n\tdouble b = a * 3;\n\tdouble m = 0.5*(a + b);\n\tdouble h = 0.25 * (b - a);\n\n\tdomi[top].left = a;\n\tdomi[top].right = b;\n\tdomi[top].func[0] = Res(a);\n\tdomi[top].func[2] = Res(0.5*(a + b));\n\tdomi[top].func[4] = Res(b);\n\tdomi[top].func[1] = Res((a + h));\n\tdomi[top].func[3] = Res((b - h));\n.\n.\n.\n\n\tf0 = domi[top].func[0];\n\tf1 = domi[top].func[2] ;\n\tf2 = domi[top].func[4];\n\tf3 = domi[top].func[1];\n\tf4 = domi[top].func[3] ;\n.\n.\n.",
          "url": "https://github.com/idaholab/moose/discussions/20635",
          "updatedAt": "2022-08-10T07:22:36Z",
          "publishedAt": "2022-03-24T00:55:03Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "MOOSE is written in C++, so no objections to using structs or arrays.\nOne note though is that it's better to write\n\tdouble f0 = domi[top].func[0];\n\tdouble f1 = domi[top].func[2]; \n...\n\nwhen possible",
                  "url": "https://github.com/idaholab/moose/discussions/20635#discussioncomment-2426797",
                  "updatedAt": "2022-08-10T07:22:40Z",
                  "publishedAt": "2022-03-24T01:32:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Difference between make -j4 and make -j8",
          "author": {
            "login": "npaloskey"
          },
          "bodyText": "Hello!\nI was wondering what the difference between the two commands \"make -j4\" and \"make -j8\" are? In some of the tutorials it instructs you to use make -j4 where as in others it instructs you to use make -j8 to compile.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/20634",
          "updatedAt": "2024-06-12T07:13:33Z",
          "publishedAt": "2022-03-23T23:29:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe number after -j is the number of processes used to build the code. So if you have at least 8 CPU cores on your computer, -j8 should be almost twice as fast as -j4. If you only have 4 CPU cores, then they should be the same roughly.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20634#discussioncomment-2426390",
                  "updatedAt": "2024-06-12T07:13:33Z",
                  "publishedAt": "2022-03-23T23:37:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Conda Packages and MOOSE Submodules Updated (MPICH, PETSc, libMesh)",
          "author": {
            "login": "cticenhour"
          },
          "bodyText": "The moose-mpich conda package was updated yesterday to the MPICH 4.0.1 release, which now relies on conda-forge managed MPICH. This also restores full compatibility with macOS 12.3. On Linux, this change results in an update to GCC 10.3.0. Alongside this change, moose-petsc and the PETSc submodule was updated to 3.16.5, and moose-libmesh and the libMesh submodule was also updated.\nPlease see more detailed information in the March 2022 Newsletter regarding the package versions and builds you will see when updating, as well as a summary of changes in PETSc and libMesh. In your conda moose environment please use the command:\nmamba update --all\n\nAs the conda command equivalent might have trouble with the package dependency resolution due to the moose-mpich changes. If an update is still not achieved, please create a new moose conda environment using our Getting Started instructions.\nIf using the PETSc/libMesh submodules, please run the update_and_rebuild_petsc.sh and update_and_rebuild_libmesh.sh scripts. If any issues are experienced with these updates, please open a new Discussion post. Thanks all!",
          "url": "https://github.com/idaholab/moose/discussions/20630",
          "updatedAt": "2022-08-03T17:12:51Z",
          "publishedAt": "2022-03-23T15:58:08Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      }
    ]
  }
}