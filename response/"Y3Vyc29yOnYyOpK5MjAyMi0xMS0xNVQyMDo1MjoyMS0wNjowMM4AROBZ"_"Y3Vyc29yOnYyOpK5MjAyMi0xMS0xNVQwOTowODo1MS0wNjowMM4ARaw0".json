{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMS0xNVQwOTowODo1MS0wNjowMM4ARaw0"
    },
    "edges": [
      {
        "node": {
          "title": "Error occurs when CZM used no-AD TensorMechanics object with Eigenstrain",
          "author": {
            "login": "echo1115"
          },
          "bodyText": "Hi everyone,\nI run the case in https://github.com/idaholab/moose/blob/dfa17cdbb0/modules/tensor_mechanics/test/tests/cohesive_zone_model/bilinear_mixed.i , but I used no-AD TensorMechanics object, and applied a ThermalExpansionEigenstrain. However, the case failed with the following message :\n*** Info ***\nTensorMechanics Action: selecting 'incremental finite strain' formulation.\ufffd[39m\n\n===================================================================================\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   PID 42920 RUNNING AT ga0408\n=   EXIT CODE: 11\n=   CLEANING UP REMAINING PROCESSES\n=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\n===================================================================================\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Segmentation fault (signal 11)\nThis typically refers to a problem with your application.\nPlease see the FAQ page for debugging suggestions\n\nHere is the modified input:\n[Mesh]\n  [msh]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmax = 1\n    ymax = 2\n    nx = 1\n    ny = 2\n  []\n  [block1]\n    type = SubdomainBoundingBoxGenerator\n    input = 'msh'\n    bottom_left = '0 0 0'\n    top_right = '1 1 0'\n    block_id = 1\n    block_name = 'block1'\n  []\n  [block2]\n    type = SubdomainBoundingBoxGenerator\n    input = 'block1'\n    bottom_left = '0 1 0'\n    top_right = '1 2 0'\n    block_id = 2\n    block_name = 'block2'\n  []\n  [split]\n    type = BreakMeshByBlockGenerator\n    input = block2\n  []\n  [top_node]\n    type = ExtraNodesetGenerator\n    coord = '0 2 0'\n    input = split\n    new_boundary = top_node\n  []\n  [bottom_node]\n    type = ExtraNodesetGenerator\n    coord = '0 0 0'\n    input = top_node\n    new_boundary = bottom_node\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Modules]\n  [TensorMechanics]\n    [Master]\n      generate_output = 'stress_yy'\n      [all]\n        strain = FINITE\n        add_variables = true\n        #use_automatic_differentiation = true\n        decomposition_method = TaylorExpansion\n\n        eigenstrain_names = 'thermal_eigen'\n      []\n    []\n  []\n[]\n\n[BCs]\n  [fix_x]\n    type = DirichletBC\n    preset = true\n    value = 0.0\n    boundary = bottom_node\n    variable = disp_x\n  []\n\n  [fix_top]\n    type = DirichletBC\n    preset = true\n    boundary = top\n    variable = disp_x\n    value = 0\n  []\n\n  [top]\n    type = FunctionDirichletBC\n    boundary = top\n    variable = disp_y\n    function = 'if(t<=0.3,t,if(t<=0.6,0.3-(t-0.3),0.6-t))'\n    preset = true\n  []\n\n  [bottom]\n    type = DirichletBC\n    boundary = bottom\n    variable = disp_y\n    value = 0\n    preset = true\n  []\n[]\n\n[Modules/TensorMechanics/CohesiveZoneMaster]\n  [czm_ik]\n    boundary = 'interface'\n  []\n[]\n\n[Materials]\n  [stress]\n    #type = ADComputeFiniteStrainElasticStress\n    type = ComputeFiniteStrainElasticStress\n  []\n  [elasticity_tensor]\n  #  type = ADComputeElasticityTensor\n    type = ComputeElasticityTensor\n    fill_method = symmetric9\n    C_ijkl = '1.684e5 0.176e5 0.176e5 1.684e5 0.176e5 1.684e5 0.754e5 0.754e5 0.754e5'\n  []\n  [./thermal_expansion_strain]\n    #type = ADComputeThermalExpansionEigenstrain\n    type = ComputeThermalExpansionEigenstrain\n    stress_free_temperature = 800\n    thermal_expansion_coeff = 4.9e-6\n    temperature = 800\n    eigenstrain_name = 'thermal_eigen'\n  [../]\n  [czm]\n    type = BiLinearMixedModeTraction\n    boundary = 'interface'\n    penalty_stiffness = 1e6\n    GI_c = 1e3\n    GII_c = 1e2\n    normal_strength = 1e4\n    shear_strength = 1e3\n    displacements = 'disp_x disp_y'\n    eta = 2.2\n    viscosity = 1e-3\n  []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = 'NEWTON'\n  line_search = none\n\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  automatic_scaling = true\n\n  l_max_its = 2\n  l_tol = 1e-14\n  nl_max_its = 30\n  nl_rel_tol = 1e-50\n  nl_abs_tol = 1e-15\n  start_time = 0.0\n  dt = 0.1\n  end_time = 1.0\n  dtmin = 0.1\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n\nActurally the ThermalExpansionEigenstrain is zero because the temperature  equals to  the stress_free_temperature.\nThe error message is the same in debug mode. Could anyone give me some help? Maybe @hugary1995 @jiangwen84 can give me some suggestions. Thanks in advance.",
          "url": "https://github.com/idaholab/moose/discussions/22576",
          "updatedAt": "2022-11-25T09:48:47Z",
          "publishedAt": "2022-11-03T03:17:04Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is because you are using a number for temperature instead of a variable, and the code expects a variable later on\nPlease use an auxiliary variable for now and I ll make a PR to fix this in the repo today.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4049790",
                  "updatedAt": "2022-11-03T17:43:00Z",
                  "publishedAt": "2022-11-03T17:42:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@GiudGiud  yes, when i change the temperature in ComputeThermalExpansionEigenstrain into an aux variable, it could run successfully.\nHowever, when i used the FunctionIsotropicEigenstrain  to replace the ComputeThermalExpansionEigenstrain  in the input file, the case failed with message: Segmentation fault (core dumped)\nhere is the FunctionIsotropicEigenstrain  and its corresponding function :\n  [thermal_expansion_strain]\n    type = FunctionIsotropicEigenstrain\n    function = eigfunc\n    eigenstrain_name = 'thermal_eigen'\n  []\n\n[Functions]\n  [eigfunc]\n    type = ParsedFunction\n    value = 0.0\n  []\n[]\n\nThen I run it in debug mode, it shows\nTime Step 0, time = 0\nTime Step 1, time = 0.1, dt = 0.1\nThread 1 \"my-dbg\" received signal SIGSEGV, Segmentation fault.\n0x00007ffff3b8c2e6 in __gnu_cxx::__normal_iterator<libMesh::Point const*, std::vector<libMesh::Point, std::allocator<libMesh::Point> > >::__normal_iterator (this=0x7fffffff9df0, \n    __i=<error reading variable>) at /home/ddd/mambaforge3/envs/moose/x86_64-conda-linux-gnu/include/c++/10.3.0/bits/stl_iterator.h:976\n976\t      : _M_current(__i) { }\n\nThe  FunctionIsotropicEigenstrain  comes from https://github.com/idaholab/moose/blob/7df3b095f66fb205a46d4afc6aa4a23e4b394a95/modules/tensor_mechanics/test/src/materials/FunctionIsotropicEigenstrain.C\nI test it because my Eigenstrain class is similar, both inherited the class ComputeEigenstrainBase.C , and using my Eigenstrain class failed with the same error.",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4057496",
                          "updatedAt": "2022-11-04T14:33:57Z",
                          "publishedAt": "2022-11-04T14:33:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not sure.\nCould you please post a full backtrace as well?",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4057762",
                          "updatedAt": "2022-11-04T15:01:29Z",
                          "publishedAt": "2022-11-04T15:00:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "Here is the backtrace :\n(gdb) bt\n#0  0x00007ffff3b8c2e6 in __gnu_cxx::__normal_iterator<libMesh::Point const*, std::vector<libMesh::Point, std::allocator<libMesh::Point> > >::__normal_iterator (\n    this=0x7fffffff9e30, __i=<error reading variable>) at /home/ddd/mambaforge3/envs/moose/x86_64-conda-linux-gnu/include/c++/10.3.0/bits/stl_iterator.h:976\n#1  0x00007ffff3b75fd0 in std::vector<libMesh::Point, std::allocator<libMesh::Point> >::end (this=0x32)\n    at /home/ddd/mambaforge3/envs/moose/x86_64-conda-linux-gnu/include/c++/10.3.0/bits/stl_vector.h:839\n#2  0x00007ffff3b636d7 in std::vector<libMesh::Point, std::allocator<libMesh::Point> >::empty (this=0x32)\n    at /home/ddd/mambaforge3/envs/moose/x86_64-conda-linux-gnu/include/c++/10.3.0/bits/stl_vector.h:1008\n#3  0x00007ffff3b27fa3 in libMesh::QBase::n_points (this=0x12) at /home/ddd/mambaforge3/envs/moose/libmesh/include/libmesh/quadrature.h:128\n#4  0x00007ffff4c211da in Material::computeProperties (this=0x555555c5d5a0) at /home/ddd/projects/moose/framework/src/materials/Material.C:131\n#5  0x00007ffff4b0f353 in MaterialData::reinit<std::vector<std::shared_ptr<MaterialBase>, std::allocator<std::shared_ptr<MaterialBase> > > > (this=0x555555b02ff0, mats=...)\n    at /home/ddd/projects/moose/framework/build/header_symlinks/MaterialData.h:454\n#6  0x00007ffff4ac96c4 in FEProblemBase::reinitMaterialsFace (this=0x555555ae8110, blk_id=1, tid=0, swap_stateful=true, reinit_mats=0x0)\n    at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:3348\n#7  0x00007ffff463b32f in NonlinearThread::onInterface (this=0x7fffffffa560, elem=0x5555559fddc0, side=2, bnd_id=4)\n    at /home/ddd/projects/moose/framework/src/loops/NonlinearThread.C:174\n#8  0x00007ffff4678a85 in ThreadedElementLoopBase<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> >::operator() (this=0x7fffffffa560, \n    range=..., bypass_threading=false) at /home/ddd/projects/moose/framework/build/header_symlinks/ThreadedElementLoopBase.h:266\n#9  0x00007ffff3e5f04a in libMesh::Threads::parallel_reduce<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*>, ComputeResidualThread> (\n    range=..., body=...) at /home/ddd/mambaforge3/envs/moose/libmesh/include/libmesh/threads_pthread.h:380\n#10 0x00007ffff3e2a996 in NonlinearSystemBase::computeResidualInternal (this=0x555555b03510, tags=...) at /home/ddd/projects/moose/framework/src/systems/NonlinearSystemBase.C:1520\n#11 0x00007ffff3e24c25 in NonlinearSystemBase::computeResidualTags (this=0x555555b03510, tags=...) at /home/ddd/projects/moose/framework/src/systems/NonlinearSystemBase.C:743\n#12 0x00007ffff4ae1bc7 in FEProblemBase::computeResidualTags (this=0x555555ae8110, tags=...) at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:5859\n#13 0x00007ffff4ae05d0 in FEProblemBase::computeResidualInternal (this=0x555555ae8110, soln=..., residual=..., tags=...)\n    at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:5697\n#14 0x00007ffff4adf14c in FEProblemBase::computeResidual (this=0x555555ae8110, soln=..., residual=...) at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:5486\n#15 0x00007ffff4adeefc in FEProblemBase::computeResidualSys (this=0x555555ae8110, soln=..., residual=...) at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:5461\n#16 0x00007ffff3e1d6df in NonlinearSystem::solve (this=0x555555b03510) at /home/ddd/projects/moose/framework/src/systems/NonlinearSystem.C:145\n#17 0x00007ffff4adb33c in FEProblemBase::solve (this=0x555555ae8110) at /home/ddd/projects/moose/framework/src/problems/FEProblemBase.C:5198\n#18 0x00007ffff47950d5 in FEProblemSolve::solve (this=0x555555b3a2b8) at /home/ddd/projects/moose/framework/src/executioners/FEProblemSolve.C:260\n#19 0x00007ffff4799513 in FixedPointSolve::solveStep (this=0x555555a501e0, begin_norm=@0x555556025df0: 0, end_norm=@0x555555f41f00: 0, transformed_dofs=...)\n    at /home/ddd/projects/moose/framework/src/executioners/FixedPointSolve.C:393\n#20 0x00007ffff4798912 in FixedPointSolve::solve (this=0x555555a501e0) at /home/ddd/projects/moose/framework/src/executioners/FixedPointSolve.C:274\n#21 0x00007ffff499087c in TimeStepper::step (this=0x555555d92630) at /home/ddd/projects/moose/framework/src/timesteppers/TimeStepper.C:161\n#22 0x00007ffff47a7e96 in Transient::takeStep (this=0x555555b39fc0, input_dt=-1) at /home/ddd/projects/moose/framework/src/executioners/Transient.C:444\n#23 0x00007ffff47a71c6 in Transient::execute (this=0x555555b39fc0) at /home/ddd/projects/moose/framework/src/executioners/Transient.C:329\n#24 0x00007ffff4fde2fa in MooseApp::executeExecutioner (this=0x5555557362b0) at /home/ddd/projects/moose/framework/src/base/MooseApp.C:1101\n#25 0x00007ffff4fe130c in MooseApp::run (this=0x5555557362b0) at /home/ddd/projects/moose/framework/src/base/MooseApp.C:1415\n#26 0x0000555555557739 in main (argc=3, argv=0x7fffffffc378) at /home/ddd/projects/bees_new/src/main.C:33",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4057893",
                          "updatedAt": "2022-11-04T15:14:24Z",
                          "publishedAt": "2022-11-04T15:14:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "nothing obvious to me.\nSeems it needs more digging, and we need to figure out if it s a related problem or not",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4058646",
                          "updatedAt": "2022-11-04T16:20:41Z",
                          "publishedAt": "2022-11-04T16:20:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@hugary1995 do you know who is in charge of CZM?\nGit blame says @arovinelli",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4058657",
                          "updatedAt": "2022-11-04T16:22:07Z",
                          "publishedAt": "2022-11-04T16:22:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@hugary1995 do you know who is in charge of CZM? Git blame says @arovinelli\n\nYes I did developed it at the beginning and the master PR was mine. But I'm not working on it since I moved. @hugary1995 What's the question?",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4058692",
                          "updatedAt": "2022-11-04T16:26:37Z",
                          "publishedAt": "2022-11-04T16:26:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "We need a MFE. @echo1115 can you try adding use_displaced_mesh = false in the FunctionIsotropicEigenstrain object?",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4058783",
                          "updatedAt": "2022-11-04T16:37:05Z",
                          "publishedAt": "2022-11-04T16:37:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@hugary1995  thanks. I followed your suggestion:\n\ntry adding use_displaced_mesh = false in the FunctionIsotropicEigenstrain object\n\nand the case can run now!\nBut I felt it odd, why the calculating is not on displaced mesh\uff1fDoes that means i should set use_displaced_mesh = false in all Eigenstain calculating objects when CZM used?",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4059616",
                          "updatedAt": "2022-11-04T18:15:24Z",
                          "publishedAt": "2022-11-04T18:15:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Does that means i should set use_displaced_mesh = false in all Eigenstain calculating objects when CZM used?\n\nYes. More radically speaking, I'd recommend always defining eigenstrain on the undisplaced mesh. Unless @bwspenc can help me understand why he did it the other way around in FunctionIsotropicEigenstrain.",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4060252",
                          "updatedAt": "2022-11-04T19:31:25Z",
                          "publishedAt": "2022-11-04T19:31:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@hugary1995 Could you tell me why the strain should be applied on undisplaced mesh? To my understanding, the mesh is deformed during  the simulation. Thanks a lot!",
                          "url": "https://github.com/idaholab/moose/discussions/22576#discussioncomment-4063476",
                          "updatedAt": "2022-11-05T12:33:26Z",
                          "publishedAt": "2022-11-05T12:33:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Some questions about Materials and Executioner",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, experts. I have some questions.\n\n\nIn a transient simulation, can I substitute the material properties used at a certain time? My material properties are obtained from a txt file. For example, at 10s, I want to replace the material properties with another txt file, can MOOSE do this?\n\n\nThere are several physics involved in my transient simulation, let's call them A, B, C. Different physics can achieve different convergence tolerances. I mean, nl_rel_tol = 1e-4 might be small enough for A, but nl_rel_tol = 1e-10 for B physics to meet our requirements. However A, B, C are all solved in one input file. So I wonder if MOOSE can set different convergence criteria for different variable groups.\n\n\nDoes MOOSE judge as Solving Converged as long as one of the convergence criteria is met? For example, if I set nl_abs_tol=1e-8 and nl_rel_tol=1e-8 in Executioner, as long as the nonlinear iteration residual meets one of these two criteria, will it be judged as Solving Converged?",
          "url": "https://github.com/idaholab/moose/discussions/22708",
          "updatedAt": "2022-11-16T02:04:24Z",
          "publishedAt": "2022-11-15T15:48:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\n\n\nThere's a few ways to do this.\nOne way is to use the Control system to substitute one material by another. You disable the old one, enable the new one using one to the ConditionalEnableControl objects\nAnother way is to write a checkpoint and reload from that checkpoint in another input file with the updated material\n\n\n\nWe can do this using manual scaling. Scale each variables corresponding to each physics using the scaling_factor parameter in the variables block.\nThe residual is then scaled by this factor. see this porous flow example\nhttps://mooseframework.inl.gov/modules/porous_flow/convergence.html\n\n\n\nYes. As soon as you meet one of the criteria we consider the simulation converged.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22708#discussioncomment-4148196",
                  "updatedAt": "2022-11-15T16:04:40Z",
                  "publishedAt": "2022-11-15T16:04:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thank you, Guillaume. Your suggestions are very helpful.",
                          "url": "https://github.com/idaholab/moose/discussions/22708#discussioncomment-4152363",
                          "updatedAt": "2022-11-16T02:04:25Z",
                          "publishedAt": "2022-11-16T02:04:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Time stepper for very stiff systems",
          "author": {
            "login": "heinono1"
          },
          "bodyText": "John Mangeri and I have been working on a micromagnetic module ('ferret') for MOOSE. Because the norm of the magnetization vector field is conserved at each point in space, we were trying to implement spherical coordinates, as this will automatically eliminate a problem of renormalizing the vector field at each time step (and reduces the DOFs). It turns out, however, that the governing equations, the Landau-Lifshitz-Gilbert equations, are very stiff, in particular in spherical coordinates. We have scoured through different time-integrators and time stepper in MOOSE, but the result always ends up being the same: the solutions become unstable after some time and start to diverge. A particularly sensitive test of solving the equations of motion is to turn the damping, 'alpha', to zero, in which case total energy should be strictly conserved. It is not in spherical coordinates - even with tiny time steps, the energy starts to diverge (increase) after some number of timesteps. It appears that the main cause of these problems is the magnetic exchange coupling. In simple test systems without exchange ('macrospins'), we can make the energy strictly conserved in the absence of damping, but the timesteps have to be tiny, otherwise the energy oscillates (but does not diverge).\nWe are interested in reaching out to the MOOSE community to hear if others have had similar or analogous problems, and what they did to address it. One potential path is to use more timestepper options that are available in PETSc, or other more complicated implicit steppers, but such pathways are beyond my comfort zone to implement in MOOSE.\nI suspect part of why this is a problem may have to do with the nature of weak formulations. In strong formulations I can make (in my own codes as well as others') energy conservation be respected. I am guessing that the elemental form of the nonlinear variables in weak formulation causes the problem: the delicate and precise solutions that you need to preserve norm and energy are possible in strong formulations but get washed out in weak formulation.\nI would be really interested in hearing comments and suggestions from the MOOSE community!",
          "url": "https://github.com/idaholab/moose/discussions/21879",
          "updatedAt": "2022-11-15T21:03:28Z",
          "publishedAt": "2022-08-18T15:06:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cticenhour",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3424273",
                  "updatedAt": "2022-08-18T15:55:04Z",
                  "publishedAt": "2022-08-18T15:55:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@idaholab/moose-team\n@hugary1995 @sapitts",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3424439",
                          "updatedAt": "2022-08-18T16:17:26Z",
                          "publishedAt": "2022-08-18T16:17:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "Pardon my ignorant questions; I don't think I can help but there's a slim chance I could elicit information that might be enough for someone else to help.\nCan you post the weak formulation you're using and the FE space you've chosen?  Also, is there a particular mode you're seeing in the diverging solutions?\nAlso, by spherical coordinates, do you mean that instead of solving for the evolution of M_x,M_y,M_z, you're trying to solve for M_theta and M_phi?  If so ... is there even an upper bound on the stiffness you get from that?  As the polar angle goes to zero, the sensitivity of the azimuthal angle to the actual vector position goes to infinity.  The problem is like gimbal lock, but the solutions I've heard of for gimbal lock (rotation matrices, quaternions) involve exactly the sort of \"extra DoFs + renormalization\" that you're trying to avoid!",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3426896",
                  "updatedAt": "2022-08-18T21:41:35Z",
                  "publishedAt": "2022-08-18T21:41:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Hello,\n\nYou are correct that we are trying to solve for m_theta and m_phi instead\nof for the Cartesian components. What I have been using for test problems\nvery carefully avoid getting theta close to either pole in order to avoid\nissues with approaching singularities at the poles.\n\nI am not sure that there is a particular mode that diverges - I have not\ndone a careful instability analysis. Heuristically, in these small test\nsystems, a few spins start to get unstable and just take off to stupid\nvalues.\n\nThe weak formulation is just a standard weak formulation of the\nLandau-Lifshitz-Gilbert equations, with appropriate partial integrations on\nthe contribution to residuals from the exchange field to move one\nderivative order from the magnetization vector field to the test functions.\nI can send you more details if you want.\n\nCheers,\nOlle\n\u2026\nOn Thu, Aug 18, 2022 at 4:41 PM roystgnr ***@***.***> wrote:\n Pardon my ignorant questions; I don't think I can help but there's a slim\n chance I could elicit information that might be enough for someone else to\n help.\n\n Can you post the weak formulation you're using and the FE space you've\n chosen? Also, is there a particular mode you're seeing in the diverging\n solutions?\n\n Also, by spherical coordinates, do you mean that instead of solving for\n the evolution of M_x,M_y,M_z, you're trying to solve for M_theta and M_phi?\n If so ... is there even an upper bound on the stiffness you get from that?\n As the polar angle goes to zero, the sensitivity of the azimuthal angle to\n the actual vector position goes to infinity. The problem is like gimbal\n lock, but the solutions I've heard of for gimbal lock (rotation matrices,\n quaternions) involve exactly the sort of \"extra DoFs + renormalization\"\n that you're trying to avoid!\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF7TWE3WXOKEXPCTZXDVZ2UZRANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3426931",
                  "updatedAt": "2022-08-18T21:48:04Z",
                  "publishedAt": "2022-08-18T21:48:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "What time integration scheme is typically used in the literature for these problems?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3429452",
                          "updatedAt": "2022-08-19T08:23:17Z",
                          "publishedAt": "2022-08-19T08:23:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Good question. In Cartesian coordinates usually higher-order (explicit)\nRunge-Kutta. I use an implicit Bulirch-Stoer method. For spherical\ncoordinates, the literature is pretty quiet as far as I know. There is an\nold code, MagPar (you can find it on gitHub), that uses spherical\ncoordinates and BDF stepper from SUNDIAL but apparently that does not\nwork so well for a lot of problems.\n\u2026\nOn Fri, Aug 19, 2022 at 3:23 AM Alex Lindsay ***@***.***> wrote:\n What time integration scheme is typically used in the literature for these\n problems?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF22ZZMEFICPHIKDBUDVZ5AABANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3431430",
                  "updatedAt": "2022-08-19T13:15:49Z",
                  "publishedAt": "2022-08-19T13:15:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Have you tried BDF2 in MOOSE? It sounds like maybe you have? When the energy starts to diverge, is that with a constant time step?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3455526",
                          "updatedAt": "2022-08-23T10:59:13Z",
                          "publishedAt": "2022-08-23T10:59:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "That's surprising.  I know a change of variables can screw up your discrete stability, but if your solution is staying well away from the pole singularities I don't see how the stability could easily go from \"fits in the small bounded stability region promised by RK\" to \"unstable even with an implicit method\".  I'm not familiar with Bulirch-Stoer ... but it's in the explicit volume of Hairer & Wanner, and the examples I can find online look explicit too.  You're using a version that's built around the implicit midpoint method instead of the explicit midpoint method?  Any idea what the stability domain looks like?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3460162",
                          "updatedAt": "2022-08-23T20:45:30Z",
                          "publishedAt": "2022-08-23T20:45:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Hi Guillaume,\n\nYes, I have tried BDF2 with adaptive steps. But I have also set the dtmax\nto some ridiculously small time step - system still goes nuts. The problems\nstart not with difficulties diverging but with some number of spins\nbecoming unstable (exchange coupling should keep the spin texture smooth\nbut some spins start to deviate from the smoothness).\n\u2026\n-Olle\nOn Tue, Aug 23, 2022 at 5:59 AM Alex Lindsay ***@***.***> wrote:\n Have you tried BDF2 in MOOSE? It sounds like maybe you have? When the\n energy starts to diverge, is that with a constant time step?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF4GSTMGLBWBG2YCY7LV2SVIXANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3456588",
                  "updatedAt": "2022-08-23T13:15:08Z",
                  "publishedAt": "2022-08-23T13:15:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "linsdayad is actually Alex, I'm Guillaume\nIs there some literature about stabilizing those solves?\nCould you add some sort of diffusive term to those equations?\nWe also have Runge Kunta schemes at various orders btw.\nWhen you say some spins become unstable, how do you diagnose that? Are they a separate variable?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3457092",
                          "updatedAt": "2022-08-23T14:08:51Z",
                          "publishedAt": "2022-08-23T14:08:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Hi,\n\nThe spins are the nonlinear variables. We monitor the instability in\ndifferent ways. Typically, the exchange starts to grow (some neighboring\nspins start to become misaligned) and visually we confirm that misalignment\nof neighboring spins starts. I have tried a variety of steppers. Typically,\nthe Newmarkbeta works the best for when we use a Cartesian representation\nbut that one too becomes unstable in spherical representation.\n\nI am not aware of any particular literature on how to stabilize the solvers\nfor spherical coordinates. It is perhaps possible to add a diffusive term\nto stabilize the equations but it has to be done such that the equations of\nmotion (the physics) are not made unphysical.\n\u2026\nOn Tue, Aug 23, 2022 at 9:09 AM Guillaume Giudicelli < ***@***.***> wrote:\n linsdayad is actually Alex, I'm Guillaume\n\n Is there some literature about stabilizing those solves?\n Could you add some sort of diffusive term to those equations?\n\n We also have Runge Kunta schemes at various orders btw.\n\n When you say some spins become unstable, how do you diagnose that? Are\n they a separate variable?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF3I6QQSTGTZ7DLQWJDV2TLP5ANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3458007",
                  "updatedAt": "2022-08-23T15:52:47Z",
                  "publishedAt": "2022-08-23T15:52:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "how big are the numerical systems btw?\nAnd the linear and nonlinear solves are fine, you never just accept an insufficiently converged solution, this is only a time stepping issue?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3458266",
                          "updatedAt": "2022-08-23T16:14:34Z",
                          "publishedAt": "2022-08-23T16:14:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "The numerical systems range from some 10k DOFs to many (many) millions of\nDOFs. Yes, the linear and nonlinear solvers are fine, it seems to be\nprimarily a time-stepping issue. Of course, as some spin DOFs start to get\nwonky it becomes difficult for the linear and nonlinear solvers to\nconverge, but I believe that is a secondary problem.\n\u2026\nOn Tue, Aug 23, 2022 at 11:14 AM Guillaume Giudicelli < ***@***.***> wrote:\n how big are the numerical systems btw?\n And the linear and nonlinear solves are fine, you never just accept an\n insufficiently converged solution, this is only a time stepping issue?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF7MSJ75CW7WJOZ4TBLV2T2HLANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3459268",
                  "updatedAt": "2022-08-23T18:27:41Z",
                  "publishedAt": "2022-08-23T18:27:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "at 10k DOFs, with some patience, we may be able to use the svd_monitor to check that the problems are actually well conditioned\nIf this is strictly a time-stepping issue, I think we should look at a fourier analysis of the system, then look at which schemes should be stable and why they are not.",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3459424",
                          "updatedAt": "2022-08-23T18:50:45Z",
                          "publishedAt": "2022-08-23T18:50:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I am not familiar with this particular physics you are looking at. But like you said, it sounds like the literature is scarce in this direction. So treating this as a research question, I would first sit down and go through the stability analysis for this discretization. It may very well be the case that the inf-sup condition is okay in cartesian but not in other coordinates.",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3459435",
                          "updatedAt": "2022-08-23T18:52:16Z",
                          "publishedAt": "2022-08-23T18:52:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Hi Gary and Roy,\n\nThanks for your comments. The Bulirch-Stoer stepper I built (for\nfinite-difference and FFT methods) is an implicit one, pretty much straight\nout of Numerical Recipes - for Cartesian coordinates. I have not tried it\nfor spherical coordinates.\n\nI have no idea about stability regions - I have not done any stability\nanalyses.\n\nCheers,\nOlle\n\u2026\nOn Tue, Aug 23, 2022 at 3:45 PM roystgnr ***@***.***> wrote:\n That's surprising. I know a change of variables can screw up your discrete\n stability, but if your solution is staying well away from the pole\n singularities I don't see how the stability could easily go from \"fits in\n the small bounded stability region promised by RK\" to \"unstable even with\n an implicit method\". I'm not familiar with Bulirch-Stoer ... but it's in\n the explicit volume of Hairer & Wanner, and the examples I can find online\n look explicit too. You're using a version that's built around the implicit\n midpoint method instead of the explicit midpoint method? Any idea what the\n stability domain looks like?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF3DRCKFGEDE3ISQ4A3V2UZ7LANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3467754",
                  "updatedAt": "2022-08-24T17:13:59Z",
                  "publishedAt": "2022-08-24T17:13:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mangerij"
                  },
                  "bodyText": "I like the idea of using svd-monitor.\n\nI will try this for a small problem with Cartesian (working just doesn't scale the dof that Olle and company need) and also the spherical formulation (doesn't work/converge at any scale).\n\nGet Outlook for Android<https://aka.ms/AAb9ysg>\n\u2026\n________________________________\nFrom: Olle Heinonen ***@***.***>\nSent: Wednesday, August 24, 2022 8:14:12 PM\nTo: idaholab/moose ***@***.***>\nCc: Subscribed ***@***.***>\nSubject: Re: [idaholab/moose] Time stepper for very stiff systems (Discussion #21879)\n\n\n*Message sent from a system outside of UConn.*\n\n\nHi Gary and Roy,\n\nThanks for your comments. The Bulirch-Stoer stepper I built (for\nfinite-difference and FFT methods) is an implicit one, pretty much straight\nout of Numerical Recipes - for Cartesian coordinates. I have not tried it\nfor spherical coordinates.\n\nI have no idea about stability regions - I have not done any stability\nanalyses.\n\nCheers,\nOlle\nOn Tue, Aug 23, 2022 at 3:45 PM roystgnr ***@***.***> wrote:\n That's surprising. I know a change of variables can screw up your discrete\n stability, but if your solution is staying well away from the pole\n singularities I don't see how the stability could easily go from \"fits in\n the small bounded stability region promised by RK\" to \"unstable even with\n an implicit method\". I'm not familiar with Bulirch-Stoer ... but it's in\n the explicit volume of Hairer & Wanner, and the examples I can find online\n look explicit too. You're using a version that's built around the implicit\n midpoint method instead of the explicit midpoint method? Any idea what the\n stability domain looks like?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEF3DRCKFGEDE3ISQ4A3V2UZ7LANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n--\nOlle Heinonen\n***@***.***\n\n\u2014\nReply to this email directly, view it on GitHub<https://nam10.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fidaholab%2Fmoose%2Fdiscussions%2F21879%23discussioncomment-3467754&data=05%7C01%7C%7Ce381b6528ef146675cdb08da85f4115d%7C17f1a87e2a254eaab9df9d439034b080%7C0%7C0%7C637969580556339427%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=MduqIX1xn6jo2cLDIY9mwe%2FvExe%2FxV6hNqnV8T0P5Nk%3D&reserved=0>, or unsubscribe<https://nam10.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FABZ65FBNSAJKCIU6VUNVKCDV2ZJ6JANCNFSM565RIRGA&data=05%7C01%7C%7Ce381b6528ef146675cdb08da85f4115d%7C17f1a87e2a254eaab9df9d439034b080%7C0%7C0%7C637969580556495676%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C3000%7C%7C%7C&sdata=fkfQaO8%2Fm9e13xfhxxBGEg1HohEs8Uwbgv%2F2gwuOqBU%3D&reserved=0>.\nYou are receiving this because you are subscribed to this thread.Message ID: ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3468024",
                  "updatedAt": "2022-08-24T17:53:00Z",
                  "publishedAt": "2022-08-24T17:52:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "please let us know how it goes.\nI've seen a lot of time-stepping give insufficiently accurate answers but not with a refined timestep, hence the idea to have a look at other parts of the solve",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3539795",
                          "updatedAt": "2022-09-02T19:55:46Z",
                          "publishedAt": "2022-09-02T19:55:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any update on this?",
                          "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3764457",
                          "updatedAt": "2022-09-29T16:29:38Z",
                          "publishedAt": "2022-09-29T16:29:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Hi Guillaume,\n\nNo, have not had time to look into this more - have worked on the\nCartiesian version (which seems to be chugging along pretty nicely now).\n\nCHeers,\nOlle\n\u2026\nOn Thu, Sep 29, 2022 at 11:29 AM Guillaume Giudicelli < ***@***.***> wrote:\n Any update on this?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21879 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AEKZEFYLXQLRWQKI63QXUQTWAW7X3ANCNFSM565RIRGA>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>\n\n\n-- \nOlle Heinonen\n***@***.***",
                  "url": "https://github.com/idaholab/moose/discussions/21879#discussioncomment-3767624",
                  "updatedAt": "2022-09-30T01:40:40Z",
                  "publishedAt": "2022-09-30T01:40:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Found a mistake on EigenProblem.h",
          "author": {
            "login": "doquang"
          },
          "bodyText": "In the rev 6ff6864, @lindsayad added a new method getNonlinearEigenSystem(unsigned int nl_sys_num = 0) into framework/include/problems/EigenProblem.h.\nThe new method is inside a condition #ifdef LIBMESH_HAVE_SLEPC, but its implementation is outside this condition. It prevents to compile on a system that do not have SLEPC.",
          "url": "https://github.com/idaholab/moose/discussions/22622",
          "updatedAt": "2022-11-15T20:05:22Z",
          "publishedAt": "2022-11-08T14:42:34Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Thank you for the report @doquang . I will create an issue for this",
                  "url": "https://github.com/idaholab/moose/discussions/22622#discussioncomment-4090262",
                  "updatedAt": "2022-11-08T19:30:48Z",
                  "publishedAt": "2022-11-08T19:30:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Opened #22628",
                          "url": "https://github.com/idaholab/moose/discussions/22622#discussioncomment-4090306",
                          "updatedAt": "2022-11-08T19:36:08Z",
                          "publishedAt": "2022-11-08T19:36:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Issue is fixed",
                          "url": "https://github.com/idaholab/moose/discussions/22622#discussioncomment-4150176",
                          "updatedAt": "2022-11-15T20:05:23Z",
                          "publishedAt": "2022-11-15T20:05:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Pass subdomain_id as input file into \"ElementSubdomainIDGenerator\"",
          "author": {
            "login": "chunhuizhao478"
          },
          "bodyText": "Hi, I would like assign different element-wise subdomain_id to different portion of mesh. So far I would like to use \"ElementSubdomainIDGenerator\" which allows users to re-assign the subdomain_id. But I don't know how to pass the modified subdomain_id as a .txt file to be read by MOOSE subdomain_id (If I have many elements). Do I need to write a custom object somehow to read file and transfer the data to \"std::vector\" type? Thanks for any suggestions.",
          "url": "https://github.com/idaholab/moose/discussions/22523",
          "updatedAt": "2022-11-15T20:10:26Z",
          "publishedAt": "2022-10-27T22:16:12Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWould there happen to be an easier definition of the subdomains than a CSV file list?\nSomething like x>1 -> subdomain 2, otherwise subdomain 1 for example\nWe support parsed expressions\nhttps://mooseframework.inl.gov/source/meshgenerators/ElementSubdomainIDGenerator.html\nElementSubdomainId will read a really long vector, the size of the number of elements, and assign those subdomain ids to each element in the order of their element ID\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-3986791",
                  "updatedAt": "2022-10-27T22:27:29Z",
                  "publishedAt": "2022-10-27T22:27:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi Guillaume, thanks for your reply. I noticed the parsed expression, however, we would like to create multiple embedded cracks and use CZM for each crack, that means I need to identify the elements just above and below the crack surfaces and assign different subdomain_ids to them and use \"BreakMeshByBlockGenerator\" to create interfaces. Parsed expression may not handle this properly I think.",
                          "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-3986809",
                          "updatedAt": "2022-10-27T22:32:40Z",
                          "publishedAt": "2022-10-27T22:32:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok that s fair.\nWhat are you using to generate the mesh?",
                          "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-3986820",
                          "updatedAt": "2022-10-27T22:35:07Z",
                          "publishedAt": "2022-10-27T22:35:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Currently I try to use Gmsh and read MSH file in MOOSE, then create interface. For the multiple cracks, probably I need to write scripts to get the information I want and seems not going to be easy, then may be I could just copy/paste all the ids to MOOSE, but it's gonna be messy.",
                          "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-3986844",
                          "updatedAt": "2022-10-27T22:42:15Z",
                          "publishedAt": "2022-10-27T22:42:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The solution here could be to write a new object that reads the CSV and does the block assigning. We have a gap in capability on this right now.\nAdding this kind of utility in MOOSE is fairly easy due to existing classes like the DelimitedFileReader",
                          "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-4149415",
                          "updatedAt": "2022-11-15T18:19:06Z",
                          "publishedAt": "2022-11-15T18:19:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks, I could check that. Currently I use MESHIO to extract cracks information and just do copy/paste the modified sudmain ID/element ID, it works for the current need.",
                          "url": "https://github.com/idaholab/moose/discussions/22523#discussioncomment-4149998",
                          "updatedAt": "2022-11-15T19:38:15Z",
                          "publishedAt": "2022-11-15T19:38:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to input the temperature field from FLOW3D into MOOSE to simulate grain evolution",
          "author": {
            "login": "zsren"
          },
          "bodyText": "Hi,\nI am new to MOOSE. I am trying to simulate the grain growth of laser powder bed fusion by utilizing the phase field module in MOOSE. I plan to input the temperature field, which is calculated within a thermal-hydrodynamic simulation from another software FLOW3D, into MOOSE. Is there by any chance an interface to make this coupling possible? Or is there a specific data format, with which FLOW3D should be output, such that MOOSE can recognize? Some existing examples would be super helpful!\nIt would be greatly appreciated for your efforts in making any comments or suggestions!\nZR",
          "url": "https://github.com/idaholab/moose/discussions/22511",
          "updatedAt": "2022-12-10T07:33:16Z",
          "publishedAt": "2022-10-27T06:23:15Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat are all the formats in which you can output data from FLOW3D?\nWhat kind of data is it going to be? A xyz field with a time dependence?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22511#discussioncomment-3982052",
                  "updatedAt": "2022-10-27T13:49:34Z",
                  "publishedAt": "2022-10-27T13:49:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zsren"
                          },
                          "bodyText": "Hi Guillaume,\nThanks so much for your prompt response. As far as I know, FLOW3D can export the X, Y, and Z coordinates with temperature values at a particular timestep in a CSV file.\nZR",
                          "url": "https://github.com/idaholab/moose/discussions/22511#discussioncomment-3990577",
                          "updatedAt": "2022-10-28T08:44:45Z",
                          "publishedAt": "2022-10-28T08:44:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Sorry for the delay.\nPiecewiseConstantFromCSV is the function you will want to use",
                          "url": "https://github.com/idaholab/moose/discussions/22511#discussioncomment-4149818",
                          "updatedAt": "2022-11-15T19:16:51Z",
                          "publishedAt": "2022-11-15T19:16:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to set the value of kappa as a function of X and Y",
          "author": {
            "login": "biaogxb"
          },
          "bodyText": "Hello, I want to define the value of kappa as a function, as shown below\n[Kernels]\n  [./AC_int]\n    type = ACInterface\n    variable = eta\n    kappa_name = kappa_op\n  [../]\n[Materials]\n [./kappa_op]\n    type = ParsedMaterial\n    f_name = kappa_op \n    args = 'x y' \n    function = '2.4+0.12*cos(4*atan2(y,x))'\n  [../]\n\nHowever, the following error occurred:\n*** ERROR ***\nThe following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\nMaterial property 'kappa_op', requested by 'AC_int' is not defined on block 0\nI would like to ask how to correctly set kappa as a function about X and Y. thank you\uff01\uff01\uff01",
          "url": "https://github.com/idaholab/moose/discussions/22013",
          "updatedAt": "2022-11-15T18:20:35Z",
          "publishedAt": "2022-09-06T09:39:18Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont think you need to specify x and y in args, you can just leave them in function\nThe name should have been properly set though. Can you please attach your input file?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3572030",
                  "updatedAt": "2022-09-06T14:40:18Z",
                  "publishedAt": "2022-09-06T14:40:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Thank you for your reply! I want to implement kappa as a function about X and Y. I have added a series of # annotations to the involved parts in the input file so that you can find it more quickly.\nI'm not sure if I can set kappa as a function and operate successfully through my current operation. I tried it. At present, the convergence is not very good. Do you agree with the way I modify this code or do you have a simpler and more correct way to realize the functionalization of kappa?\nI want to set kappa = 2.4 (1 + 0.05 * cos (4* \u03b8\uff09\uff09\nAccording to the following formula:\n\n\n\nthis \u03b8 It is an angle that can be represented by 'x' and 'y', which will change at any time. Therefore, setting kappa as a constant does not satisfy the condition.\nI'm looking forward to your reply. Thank you\uff01\uff1a\uff09",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3580818",
                          "updatedAt": "2022-11-09T07:48:18Z",
                          "publishedAt": "2022-09-07T02:27:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "why do you say x and y will change during time? is the mesh going to displace?\nyou could probably avoid the auxvariable here, and define it directly in the parsed material.",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3581591",
                          "updatedAt": "2022-09-07T05:49:54Z",
                          "publishedAt": "2022-09-07T05:49:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "\u03b8 is the angle between the surface normal vector and the crystallographic orientation.So I modified the code according to my own idea. I want to express this through the coordinates (x, y) of the interface position \u03b8 Angle that changes as the surface grows. but obviously I was wrong. How can I express this \u03b8 ?",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3582150",
                          "updatedAt": "2022-09-07T07:27:03Z",
                          "publishedAt": "2022-09-07T07:26:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So are you modeling the surface explicitly? Is theta a variable then? Or does it never change at a given x,y during the simulation",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3588817",
                          "updatedAt": "2022-09-07T20:32:21Z",
                          "publishedAt": "2022-09-07T20:32:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@laagesen for helping on phase field",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3588823",
                          "updatedAt": "2022-09-07T20:32:44Z",
                          "publishedAt": "2022-09-07T20:32:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "The angle of the surface normal vector is not the same as the way you have drawn theta here. To see this, just draw a normal vector to the surface at the end of one of your arrows and you will see it doesn't point in the same direction as the arrow. (If it did, the outer surface that the arrows point to would be a circle instead of the more complex wavy shape).\nBecause of this, you can't calculate kappa as a function of x and y in your domain. The process is unfortunately more tricky, you will need to calculate the interfacial normal as a function of the gradients of the order parameter. To see an example of how this is done, you can look at  the code in moose/modules/phase_field/src/materials/InterfaceOrientationMaterial.C. You can see how this material is used in a dendritic growth example by running moose/modules/phase_field/examples/anisotropic_interfaces/snow.i.",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3595405",
                          "updatedAt": "2022-09-08T14:28:04Z",
                          "publishedAt": "2022-09-08T14:27:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Thank you for your answer. I will study this example!",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3603052",
                          "updatedAt": "2022-09-09T02:47:36Z",
                          "publishedAt": "2022-09-09T02:47:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "The angle of the surface normal vector is not the same as the way you have drawn theta here. To see this, just draw a normal vector to the surface at the end of one of your arrows and you will see it doesn't point in the same direction as the arrow. (If it did, the outer surface that the arrows point to would be a circle instead of the more complex wavy shape).\nBecause of this, you can't calculate kappa as a function of x and y in your domain. The process is unfortunately more tricky, you will need to calculate the interfacial normal as a function of the gradients of the order parameter. To see an example of how this is done, you can look at the code in moose/modules/phase_field/src/materials/InterfaceOrientationMaterial.C. You can see how this material is used in a dendritic growth example by running moose/modules/phase_field/examples/anisotropic_interfaces/snow.i.\n\nI carefully read the snowflake example and found that the \u2018InterfaceOrientationMaterial\u2019 is used to calculate the kappa\uff08eps in that article\uff09 value I need, so I changed the code for calculating the interface as follows\n[./anisoACinterface] type = ACInterface variable = eta mob_name = M0 kappa_name=eps [../]\n[./material] type = InterfaceOrientationMaterial op = eta [../]\nI don't know why my calculation is not convergent. Can't I directly fill \u2018eps\u2019 into ACInterface as \u2018kappa\u2019\uff1f\nHere is my input file\uff1a\ninput.txt",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-4096882",
                          "updatedAt": "2022-11-09T13:05:19Z",
                          "publishedAt": "2022-11-09T13:05:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "I see you are using some logarithmic terms in your free energy expressions. Those are often problematic in terms of convergence. I would suggest first removing the anisotropy and make sure your model works without it first. If you still have problems without the anisotropy I would be suspicious of the logarithmic terms. You can try using the plog function instead, which substitutes a polynomial function below a user-specified tolerance, or try a parabolic approximation to the logarithmic expression.",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-4149427",
                          "updatedAt": "2022-11-15T18:20:35Z",
                          "publishedAt": "2022-11-15T18:20:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "ParsedMaterial cannot use x and y. Use GenericFunctionMaterial instead.",
                  "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3603060",
                  "updatedAt": "2022-09-09T02:50:02Z",
                  "publishedAt": "2022-09-09T02:50:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Thank you for your answer\uff01",
                          "url": "https://github.com/idaholab/moose/discussions/22013#discussioncomment-3603102",
                          "updatedAt": "2022-09-09T02:58:56Z",
                          "publishedAt": "2022-09-09T02:58:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Some questions about the KDTree.C",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "KDTree.C\nvoid\nKDTree::neighborSearch(Point & query_point,\n                       unsigned int patch_size,\n                       std::vector<std::size_t> & return_index,\n                       std::vector<Real> & return_dist_sqr)\n{\n  return_index.resize(patch_size);\n\n  std::size_t n_result =\n      _kd_tree->knnSearch(&query_point(0), patch_size, return_index.data(), return_dist_sqr.data());\n\n  if (n_result == 0)\n    mooseError(\"Unable to find closest node!\");\n\n  return_index.resize(n_result);\n  return_dist_sqr.resize(n_result);\n}\n\n\nI want to ask where can I find some info about the knnSearch? I didn't find it anywhere else.\nOr can somebody tell me what does the neighborSearch do? How?",
          "url": "https://github.com/idaholab/moose/discussions/22707",
          "updatedAt": "2022-11-15T15:24:28Z",
          "publishedAt": "2022-11-15T14:01:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo a good research to get more information about code is the doxygen\nUnfortunately the moose doxygen doesnt have comments, but you can refer to the nanoflann one for the routines called here\nhttps://jlblancoc.github.io/nanoflann/classnanoflann_1_1KDTreeSingleIndexAdaptor.html#ad16aad67165bce42ecdb742bc5536173\nneighborSearch searches for the closest neighbors of a queried point\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22707#discussioncomment-4147176",
                  "updatedAt": "2022-11-15T14:31:55Z",
                  "publishedAt": "2022-11-15T14:31:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "for the patch_size closest neighbors*",
                          "url": "https://github.com/idaholab/moose/discussions/22707#discussioncomment-4147190",
                          "updatedAt": "2022-11-15T14:33:28Z",
                          "publishedAt": "2022-11-15T14:33:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Oh I got it.  patch_size is the number of the closest neighbors right?\nI have another question, is the concept 'neighbors' blockrestrictable? I mean, a queried point's neighbor can be another point in other block or not?",
                          "url": "https://github.com/idaholab/moose/discussions/22707#discussioncomment-4147433",
                          "updatedAt": "2022-11-15T14:53:57Z",
                          "publishedAt": "2022-11-15T14:53:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "And thank you for telling me about the nanoflann, I haven't browsed this labrary.",
                          "url": "https://github.com/idaholab/moose/discussions/22707#discussioncomment-4147447",
                          "updatedAt": "2022-11-15T14:55:19Z",
                          "publishedAt": "2022-11-15T14:55:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes it is the number of closest neighbors the KDTree search will return.\nThe KDTree can be block-restricted by creating it only with the points from the desired block.",
                          "url": "https://github.com/idaholab/moose/discussions/22707#discussioncomment-4147738",
                          "updatedAt": "2022-11-15T15:24:28Z",
                          "publishedAt": "2022-11-15T15:24:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "FluidProperties doesn't work",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nAfter I updated my moose version, the mistake occurred in my previous case of my application:\n\nI noticed that MOOSE has changed /Modules/FluidProperties/* to /FluidProperties/*, but why does the app in the Modules using FluidProperties not report an error, but my own app does?\nCould anyone kindly help me to figure it out?\nBest regards!\nSomnus",
          "url": "https://github.com/idaholab/moose/discussions/22705",
          "updatedAt": "2023-01-03T23:13:38Z",
          "publishedAt": "2022-11-15T13:03:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid you recompile the app as well after updating or is it the old executable?\nThe new syntax is indeed [FluidProperties] instead of [Modules/FluidProperties]\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22705#discussioncomment-4147297",
                  "updatedAt": "2022-11-15T14:41:17Z",
                  "publishedAt": "2022-11-15T14:41:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Yes, I have recompiled the app. I know that the new syntax is [FluidProperties], which is also used in my input file. Should I uninstall the MOOSE and then reinstall it?",
                          "url": "https://github.com/idaholab/moose/discussions/22705#discussioncomment-4147529",
                          "updatedAt": "2022-11-15T15:02:35Z",
                          "publishedAt": "2022-11-15T15:02:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You could git clean -xfd in the moose folder then re-make\nBe careful that will delete ALL files that are not saved!! So please make sure to commit them first if you have modified MOOSE",
                          "url": "https://github.com/idaholab/moose/discussions/22705#discussioncomment-4147650",
                          "updatedAt": "2022-11-15T15:15:35Z",
                          "publishedAt": "2022-11-15T15:15:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Ok, I will try it. Thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/22705#discussioncomment-4147686",
                          "updatedAt": "2022-11-15T15:19:10Z",
                          "publishedAt": "2022-11-15T15:19:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "What's the difference between nodal variable and elemental variable in Kernel?",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "I didn't find a page about this question. I remember that computeQpResidual() is executed on each each quadrature point and the node value is calculated by the qp point value. So what is the specific difference between nodal and elemental variable?",
          "url": "https://github.com/idaholab/moose/discussions/22686",
          "updatedAt": "2022-11-15T15:08:51Z",
          "publishedAt": "2022-11-14T14:10:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe difference between a nodal and an elemental variable is where the degrees of freedoms (dofs) reside. Both elements and nodes are DoFObject in libmesh, so they can \"hold\" (simplifying) Qp values of a variable.\nA nodal variable may be uniquely defined by its values on nodes (think about a Lagrange variable).\nAn elemental variable is uniquely defined by its values in various places on each element. This allows for discontinuity from one element to another.\nThere are mixed nodal - elemental variables that hold dofs on both elements and nodes.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4137136",
                  "updatedAt": "2022-11-14T14:17:25Z",
                  "publishedAt": "2022-11-14T14:17:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "\"A nodal variable may be uniquely defined by its values on nodes (think about a Lagrange variable).\"\nDoes the \"nodes\" include quadrature point?\nIf doesn't, why we should add [_qp] behind the variable in computeQpResidual()?",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4137315",
                          "updatedAt": "2022-11-14T14:35:44Z",
                          "publishedAt": "2022-11-14T14:35:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Does the \"nodes\" include quadrature point?\nThis depend on the quadrature. Typically not\nIf doesn't, why we should add [_qp] behind the variable in computeQpResidual()?\nIf you want to write a kernel that is valid for more than nodal variabless one reason.",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4137543",
                          "updatedAt": "2022-11-14T14:55:40Z",
                          "publishedAt": "2022-11-14T14:55:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "But when I set the variable first lagrange and I add the code which can output the qp value of variable like\uff1astd<<cout<<_vel\uff3b_qp\uff3d<<endl\uff1b in kernel\uff0cit outputs some values indeed\uff0cI wanna know where does that \u201cqp value\u201d come from\uff1f\nWhen I set 6 nodes in a 1D mesh and set the variable first lagrange\uff0cit outputs 10 values\uff08I think FISRT stands that there are two qp point between two nodes\uff0cand plus the number of the element\uff086-1=5\uff09\uff09.\nI cant understand Orz",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4137802",
                          "updatedAt": "2022-11-14T15:16:24Z",
                          "publishedAt": "2022-11-14T15:16:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "6 nodes -> 5 elements\nIf there's 2 qps per element, then that's how you got 10 values\nThe quadrature point value can be computed by evaluating the shape functions at the quadrature points.",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4138957",
                          "updatedAt": "2022-11-14T17:00:26Z",
                          "publishedAt": "2022-11-14T17:00:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "So when I set a nodal variable, it actually is computed at each node, not quadrature point. The value of quadrature point is computed by evaluating, but can't decide the value of node. And my previous understanding is the way of elemental variable's calculation\n, am I right?\nSo nodal variable: node value decides quadrature point value;\nelemental variable: quadrature point value decides node value.\nCan I simplify it this way?",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4141996",
                          "updatedAt": "2022-11-15T01:19:47Z",
                          "publishedAt": "2022-11-15T01:19:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The values are stored at each node (they are stored in an array, mapped to nodes, we dont store value directly on the mesh objects)\nThe variable values are computed at quadrature points when we evaluate the residual or the Jacobian.\nnodal variable: yes\nelemental variable: no. The node value of an elemental variable may be undefined, because a node is shared by multiple elements and the variable is discontinuous for example\nAlso, the Qp value is not used to compute values. The Qp value is computed by evaluating the shape function(s). The dofs of an elemental variables may relate to arbitrary points on an element, determined by the finite element family and its order\nThis documentation should be helpful\nhttps://mooseframework.inl.gov/help/finite_element_concepts/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4147489",
                          "updatedAt": "2022-11-15T15:14:15Z",
                          "publishedAt": "2022-11-15T14:59:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Thank you a lot! I will check the documentation with your answer :D",
                          "url": "https://github.com/idaholab/moose/discussions/22686#discussioncomment-4147603",
                          "updatedAt": "2022-11-15T15:08:51Z",
                          "publishedAt": "2022-11-15T15:08:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}