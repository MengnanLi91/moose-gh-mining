{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNS0zMVQyMDo0MjoxMS0wNTowMM4AT2JJ"
    },
    "edges": [
      {
        "node": {
          "title": "Function that Defines Diffusion Interior to a Domain",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "Is there an example problem where in 2D a function is defined for a circle or any shape interior to a rectangular domains or similar,where the diffusion is defined by a function of the equation of a circle or any other shape, to be a constant value (by function not mesh shape) interior to the rectangular domain with source and sink boundary conditions defined to drive diffusion through the rectangular domain?",
          "url": "https://github.com/idaholab/moose/discussions/24574",
          "updatedAt": "2023-06-24T22:45:51Z",
          "publishedAt": "2023-06-01T23:30:02Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis seems pretty specific so I m going to say no.\nIf you want a circle mesh with a rectangle around you can use that:\nhttps://mooseframework.inl.gov/source/meshgenerators/ConcentricCircleMeshGenerator.html\nthen stitch a few rectangular meshes around it with those\nhttps://mooseframework.inl.gov/source/meshgenerators/CartesianMeshGenerator.html\nhttps://mooseframework.inl.gov/source/meshgenerators/StitchedMeshGenerator.html\nTo define a function only in a circle, you can use a ParsedFunction with a simple if(x*x + y*y < r*r, this_function, 0)\nWith the mesh generators I pasted you can define different subdomains so you can block restrict source and sink\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24574#discussioncomment-6071023",
                  "updatedAt": "2023-06-02T11:59:35Z",
                  "publishedAt": "2023-06-02T11:59:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Clarification on `generate_core_metadata'",
          "author": {
            "login": "tannhorn"
          },
          "bodyText": "When using the reactor module, does it make sense to set generate_core_metadata = true if the core has only one level of patterning? The code is set to disallow generate_core_metadata = true with PatternedHexMeshGenerator object using PolygonConcentricCircleMeshGenerator objects as pattern inputs.\nHowever, note that if using HexagonConcentricCircleAdaptiveBoundaryMeshGenerator instead of  PolygonConcentricCircleMeshGenerator (basically just replacing the type), core metadata can now be generated. Not sure if this working as intended, either.",
          "url": "https://github.com/idaholab/moose/discussions/24558",
          "updatedAt": "2023-06-24T22:45:45Z",
          "publishedAt": "2023-06-01T08:30:14Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@miaoyinb",
                  "url": "https://github.com/idaholab/moose/discussions/24558#discussioncomment-6060538",
                  "updatedAt": "2023-06-01T12:05:05Z",
                  "publishedAt": "2023-06-01T12:05:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "miaoyinb"
                          },
                          "bodyText": "HexagonConcentricCircleAdaptiveBoundaryMeshGenerator is used to generate a mesh that contains assembly-style metadata, which can be used by PatternedHexMeshGenerator as input unit assembly mesh for a core mesh (generate_core_metadata = true). HexagonConcentricCircleAdaptiveBoundaryMeshGenerator also provides the \"adaptive boundary\" feature, but you do not have to use it.\nMesh generated by PolygonConcentricCircleMeshGenerator only contains pin-style metadata, so it cannot be used as an input unit assembly mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/24558#discussioncomment-6061414",
                          "updatedAt": "2023-06-01T13:34:05Z",
                          "publishedAt": "2023-06-01T13:34:04Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tannhorn"
                          },
                          "bodyText": "Thank you for the answer. However, I am still not sure if I need to generate core_metadata when my core is only singly-heterogeneous (i.e. only a lattice of pins, rather than a lattice of assemblies which themselves comprise of lattices of pins).",
                          "url": "https://github.com/idaholab/moose/discussions/24558#discussioncomment-6068231",
                          "updatedAt": "2023-06-02T06:41:28Z",
                          "publishedAt": "2023-06-02T06:41:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about SpecifiedSmoothCircleIC",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nI have a question about using SpecifiedSmoothCircleIC to set the initial condition of circle. I want to generate a initial condition like this,\n\nIn the most part of the square model, the initial c is set as 0, however, in some small circles, the initial condition should be set as larger values. How can I randomly generate some values for the circle's initial concentration in some range? I saw that in all the examples shown in SpecifiedSmoothCircleIC webpage, the initial concentration can only be set as one specific value. How can I set different values for each circle's concentration? Or I can only set the same value for the two circles?\n\nThank you,\nBest,",
          "url": "https://github.com/idaholab/moose/discussions/24568",
          "updatedAt": "2023-06-24T22:45:38Z",
          "publishedAt": "2023-06-01T19:34:45Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ykvishal"
                  },
                  "bodyText": "You could try with CoupledValueFunctionIC, RandomIC, SpecifiedSmoothCircleIC. Use 1 temp initial variable to populate random values with RandomIC. Then use another temp variable to create circles shown in Fig with SpecifiedSmoothCircleIC; use 1 and 0 values for this case. Finally, user CoupledValueFunctionIC for main variable and multiply two temp variables. I hope that it may work.",
                  "url": "https://github.com/idaholab/moose/discussions/24568#discussioncomment-6065867",
                  "updatedAt": "2023-06-01T22:21:41Z",
                  "publishedAt": "2023-06-01T22:21:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error message 'Variables/c/InitialCondition1' does not have an associated \"Action\".",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nWhen I ran my simulation, i got this error message.\n56: section 'Variables/c/InitialCondition1' does not have an associated \"Action\".\nDid you misspell it?\n68: section 'Variables/c/InitialCondition2' does not have an associated \"Action\".\nDid you misspell it?\n80: section 'Variables/c/InitialCondition3' does not have an associated \"Action\".\nDid you misspell it?\n92: section 'Variables/c/InitialCondition4' does not have an associated \"Action\".\nDid you misspell it?\nWhat is the problem of this? How to correct it?\nI attached my input file here,\nfile.txt\nThank you very much,\nBest,",
          "url": "https://github.com/idaholab/moose/discussions/24572",
          "updatedAt": "2023-06-24T22:45:31Z",
          "publishedAt": "2023-06-01T21:39:26Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPlease follow the tutorial again.\nThese are very basic questions, you are simply not following the syntax of a moose input.\nIf should be something like:\n[Variables]\n  [c]\n    [InitialCondition]\n       type = ...\n    []\n  []\n[]\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24572#discussioncomment-6065781",
                  "updatedAt": "2023-06-01T22:04:21Z",
                  "publishedAt": "2023-06-01T22:04:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "I changed to this and it works now.",
                          "url": "https://github.com/idaholab/moose/discussions/24572#discussioncomment-6065794",
                          "updatedAt": "2023-06-01T22:07:17Z",
                          "publishedAt": "2023-06-01T22:07:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is fine too",
                          "url": "https://github.com/idaholab/moose/discussions/24572#discussioncomment-6065840",
                          "updatedAt": "2023-06-01T22:16:47Z",
                          "publishedAt": "2023-06-01T22:16:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error message\"Task add_mesh_generator is not registered to build MooseMesh derived objects\"",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nWhen I ran my simulation, I got this error message, why is this? How to correct it?\n\nI also attached my input file here.\nfile.txt\nThank you very much,\nBest,",
          "url": "https://github.com/idaholab/moose/discussions/24571",
          "updatedAt": "2023-06-01T21:25:20Z",
          "publishedAt": "2023-06-01T21:14:14Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou need to use GeneratedMeshGenerator not GeneratedMesh\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24571#discussioncomment-6065560",
                  "updatedAt": "2023-06-01T21:25:20Z",
                  "publishedAt": "2023-06-01T21:25:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using Dirac kernels with reporters",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hello,\nI am using a method of perfectly matched discrete layers to solve a simple problem in 2D. Note that I have successfully used the same technique to solve 1D problems and it works fine. But I have huge inconsistent results with the 2D case. The results are blowing up and not converging as expected.\nI have the following results: The sampled variable at the interface before the iteration is u = 3.92415 and 3.88704, xflux = 0.196009 and 0.19600, v = 0 and 0, xflux_v = 0 and 0. After the iteration, u = 3.92415 and 3.88704, xflux = 0.196009 and 0.196009, xflux_v = 0.72031 and 0.72031, v = 67.38297 and 67.37507, xflux_v = 0.72031 and 0.72031.\nThese results are severely not correct and they are obtained from the following files:\nFirst subsystem:\n[Mesh]\n  [./generated]\n    type = CartesianMeshGenerator\n    dim = 2\n    dx = '1 1'\n    ix = '32 1'\n    dy = '0.1'\n    iy = '1'\n    subdomain_id = '1 2'\n  [../]\n[]\n\n\n[Variables]\n  [u]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [xflux]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [yflux]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[Kernels]\n  [diffusion]\n    type = MatDiffusion\n    variable = u\n    diffusivity = 1\n  []\n    [reaction]\n    type =  Reaction\n    variable = u\n    rate = 0.25\n  []\n[]\n\n[AuxKernels]\n  [xfluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = -1\n    variable = xflux\n    diffusion_variable = u\n    component = x\n  []\n  [yfluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = -1\n    variable = yflux\n    diffusion_variable = u\n    component = y\n  []\n\n[]\n\n[DiracKernels]\n  [point_source]\n    type = ConstantPointSource\n    variable = u\n    value = 1\n    point = '0.8 0.0 0'\n    point_not_found_behavior = 'ERROR'\n  []\n\n  \n  [unode1_interface]\n    type = ReporterPointSource\n    variable = u\n    value_name = 'csv_v_interface/v'\n    x_coord_name = 'csv_v_interface/x'\n    y_coord_name = 'csv_v_interface/y'\n    z_coord_name = 'csv_v_interface/z'\n    #point_name = 'csv_v_interface/x'\n    point_not_found_behavior = 'ERROR'\n  []\n  [xfluxnode1_interface]\n    type = ReporterPointSource\n    variable = u\n    value_name = 'csv_flux_interface/xflux_v'\n    x_coord_name = 'csv_flux_interface/x'\n    y_coord_name = 'csv_flux_interface/y'\n    z_coord_name = 'csv_flux_interface/z'\n    point_not_found_behavior = 'ERROR'\n  []\n\n[]\n\n[BCs]\n  [leftBC] \n    type = DirichletBC\n    variable = u\n    boundary = 'left'\n    value = 0\n  []\n  [rightBC] \n    type = DirichletBC\n    variable = u\n    boundary = 'right'\n    value = 0\n  []\n[]\n\n[VectorPostprocessors]\n  [u_interface]\n    type = LineValueSampler\n    variable = 'u'\n    start_point = '0.999999 0 0'\n    end_point = '0.999999 0.099999 0'\n    scaling =   1.0625 #0.033203125   \n    num_points = 2\n    sort_by = x\n  []\n  [flux_interface]\n    type = LineValueSampler\n    variable = 'xflux'\n    start_point = '0.999999 0 0'\n    end_point = '0.999999 0.099999 0'\n    scaling = -0.05  \n    num_points = 2\n    sort_by = x\n  []\n  [csv_v_interface]\n    type = CSVReader\n    csv_file = left_subdomain_pmdl_schwarz_new_out_sub0_v_interface_0001.csv\n  []\n  [csv_flux_interface]\n    type = CSVReader\n    csv_file = left_subdomain_pmdl_schwarz_new_out_sub0_flux_interface_0001.csv\n  []\n[]\n\n\n[Executioner]\n  type = Steady\n  solve_type = 'NEWTON'\n\n  fixed_point_max_its = 1000\n  nl_abs_tol = 1e-10\n  fixed_point_rel_tol = 1e-16\n  fixed_point_abs_tol = 1e-10\n\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n\n  [Quadrature]\n    type = 'GAUSS'\n    custom_blocks = '1 2'    \n    custom_orderX = 'FIRST CONSTANT'\n    custom_orderY = 'FIRST FIRST'\n  []\n\n[]\n\n\n[Outputs]\n  exodus = true\n  csv = true\n  console = true\n[]\n\n\n[MultiApps]\n  [sub]\n    type = FullSolveMultiApp\n    #positions = '0.5 0 0'\n    input_files = 'right_subdomain_pmdl_schwarz_new.i'\n    execute_on = 'timestep_begin'\n  []\n[]\n\n\nSecond subsystem:\n[Mesh]\n  [./generated]\n    type = CartesianMeshGenerator\n    dim = 2\n    dx = '1 1'\n    ix = '1 32'\n    dy = '0.1'\n    iy = '1'\n    subdomain_id = '1 2'\n  [../]\n[]\n\n[Variables]\n  [v]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [xflux_v]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [yflux_v]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[Kernels]\n  [diffusion]\n    type = MatDiffusion\n    variable = v\n    diffusivity = 1\n  []\n  [reaction]\n    type =  Reaction\n    variable = v\n    rate = 0.25\n  []\n[]\n\n[AuxKernels]\n  [xfluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = -1\n    variable = xflux_v\n    diffusion_variable = v\n    component = x\n  []\n  [yfluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = -1\n    variable = yflux_v\n    diffusion_variable = v\n    component = y\n  []\n[]\n\n[DiracKernels]\n  [vnode1_interface]\n    type = ReporterPointSource\n    variable = v\n    value_name = 'csv_u_interface/u'\n    x_coord_name = 'csv_u_interface/x'\n    y_coord_name = 'csv_u_interface/y'\n    z_coord_name = 'csv_u_interface/z'\n    #point_name = 'csv_v_interface/x'\n    point_not_found_behavior = 'ERROR'\n  []\n  [xfluxnode1_interface]\n    type = ReporterPointSource\n    variable = v\n    value_name = 'csv_flux_interface/xflux'\n    x_coord_name = 'csv_flux_interface/x'\n    y_coord_name = 'csv_flux_interface/y'\n    z_coord_name = 'csv_flux_interface/z'\n    #point_name = 'csv_v_interface/x'\n    point_not_found_behavior = 'ERROR'\n  []\n[]\n\n[BCs]\n\n  [leftBC] \n    type = DirichletBC\n    variable = v\n    boundary = 'left'\n    value = 0\n  []\n\n\n[]\n\n[VectorPostprocessors]\n  [v_interface]\n    type = LineValueSampler\n    variable = 'v'\n    start_point = '1.000001 0 0'\n    end_point = '1.000001 0.099999 0'\n    scaling =  1.0625 #0.033203125    \n    num_points = 2\n    sort_by = x\n  []\n  [flux_interface]\n    type = LineValueSampler\n    variable = 'xflux_v'\n    start_point = '1.000001 0 0'\n    end_point = '1.000001 0.099999 0'\n    scaling = 0.05  \n    num_points = 2\n    sort_by = x\n  []\n  [csv_u_interface]\n    type = CSVReader\n    csv_file = left_subdomain_pmdl_schwarz_new_out_u_interface_0001.csv\n  []\n  [csv_flux_interface]\n    type = CSVReader\n    csv_file = left_subdomain_pmdl_schwarz_new_out_flux_interface_0001.csv\n  []\n[]\n\n\n[Executioner]\n  type = Steady\n  solve_type = 'NEWTON'\n\n\n\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n  \n  [Quadrature]\n    type = 'GAUSS'\n    custom_blocks = '1 2'    \n    custom_orderX = 'CONSTANT FIRST'\n    custom_orderY = 'FIRST FIRST'\n  []\n[]\n\n\n\n[Outputs]\n  exodus = true\n  csv = true\n  console = true\n[]\n\nNote that I have a locally modified libmesh that applied quadrature in different directions as I need the midpoint rule in the domain with a unit length discretization.\nI will appreciate why the results obtained from these files are not consistent.\nA simple 1D of the problem is given as follows and I have used the same PMDL technique to solve it without using the reporter since I can simply manually post-process the result to transfer without writing it in a file:\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  nx = 1000\n  xmin = 0\n  xmax = 2\n[]\n\n[Variables]\n  [u]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [flux]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[Kernels]\n  [diffusion]\n    type = MatDiffusion\n    variable = u\n    diffusivity = 1\n  []\n  [reaction]\n    type =  Reaction\n    variable = u\n    rate = 0.25\n  []\n[]\n\n[DiracKernels]\n  [point_source]\n    type = ConstantPointSource\n    variable = u\n    value = 1.0\n    point = '0.8 0 0'\n  []\n[]\n\n[AuxKernels]\n  [fluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = -1\n    variable = flux\n    diffusion_variable = u\n    component = x\n  []\n[]\n\n[BCs]\n [leftBC] \n    type = DirichletBC\n    variable = u\n    boundary = 'left'\n    value = 0\n  []\n  \n[]\n\n\n\n[Executioner]\n\n  type = Steady\n  solve_type = 'PJFNK'\n\n  fixed_point_max_its = 500\n  nl_abs_tol = 1e-10\n  fixed_point_rel_tol = 1e-16\n  fixed_point_abs_tol = 1e-10\n\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\n[Outputs]\n  exodus = true\n  #csv = true\n  console = true\n[]\n\nThank you !!",
          "url": "https://github.com/idaholab/moose/discussions/24437",
          "updatedAt": "2023-06-01T16:49:56Z",
          "publishedAt": "2023-05-21T18:04:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDoes this work fine with a regular quadrature?\nBasically, are the results wrong because of the new quadrature you made? Or is this something else?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24437#discussioncomment-5969395",
                  "updatedAt": "2023-05-22T15:58:56Z",
                  "publishedAt": "2023-05-22T15:58:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "I have a similar issue without specifying the quadrature block. It should be something else.",
                          "url": "https://github.com/idaholab/moose/discussions/24437#discussioncomment-5969492",
                          "updatedAt": "2023-05-22T16:08:53Z",
                          "publishedAt": "2023-05-22T16:08:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So Gauss is the default quadrature anyway, so specifying\n  [Quadrature]\n    type = 'GAUSS'\n    custom_blocks = '1 2'    \n    custom_orderX = 'CONSTANT FIRST'\n    custom_orderY = 'FIRST FIRST'\n  []\n\nonly worked to change the order. If you changed the Gauss quadrature, you would be using the changed one whether you specify it or not.\nI would try a non-modified quadrature first.\nIf you're confident the problems are not coming from your modified quadrature, can you specify what the issue is with the results?",
                          "url": "https://github.com/idaholab/moose/discussions/24437#discussioncomment-5971675",
                          "updatedAt": "2023-05-22T20:52:19Z",
                          "publishedAt": "2023-05-22T20:52:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "I have validated the implementation of the quadrature rule by using it on a rotated simple anisotropic 2D problem in different directions.\nThat being said, consider the results obtained from these files:\n\n\nYou can notice the huge discrepancy between the results. At least, the result should be pretty close to each other and to the reference result\n\nFrom the sampled values before the start of the coupling is u = 3.92415 and 3.88704, xflux = 0.196009 and 0.19600, v = 0 and 0, xflux_v = 0 and 0. After the iteration, both u and xflux values do not change while xflux_v = 0.72031 and 0.72031 and v = 67.38297 and 67.37507. My worry is justified since both u and xflux values do not change even after the simulation, but v has a drastic increase in value.",
                          "url": "https://github.com/idaholab/moose/discussions/24437#discussioncomment-5972241",
                          "updatedAt": "2023-05-22T22:40:06Z",
                          "publishedAt": "2023-05-22T22:38:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are these results converged? Like mesh-wise\nWhat are u & v physically?\nCan you decouple u & v, keeping one constant? To verify the equation for u and v separately",
                          "url": "https://github.com/idaholab/moose/discussions/24437#discussioncomment-5972808",
                          "updatedAt": "2023-05-23T00:40:40Z",
                          "publishedAt": "2023-05-23T00:40:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "Both u and v physically are basically the same variable in two different subdomains.\nSo, I tried by basically a 2D version of a 1D problem with the force equally on the nodes, and comparing it with my 1D result which agrees.\nHowever, that involves me manually postprocessing the result and this method adds several lines to the input files, even for one element (two nodes) in the y-direction.\nThat was why I tried using reporters to allow me to specify any number of discretizations.",
                          "url": "https://github.com/idaholab/moose/discussions/24437#discussioncomment-6001401",
                          "updatedAt": "2023-05-25T14:00:05Z",
                          "publishedAt": "2023-05-25T14:00:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Reporter is a good idea to postprocess.\nI would try to s simplify the problem until you get the expected result. This will help you narrow down where the issue here.",
                          "url": "https://github.com/idaholab/moose/discussions/24437#discussioncomment-6005733",
                          "updatedAt": "2023-05-25T21:18:57Z",
                          "publishedAt": "2023-05-25T21:18:56Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "I tried narrowing down my problem to a simple case of having one element with two nodes in the y-direction. Then I manually post-process the result as I want it, before using the same construct for the VectorPostprocessor, after which I could get several numbers of discretization in the y-direction.\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/24437#discussioncomment-6063626",
                          "updatedAt": "2023-06-01T16:49:57Z",
                          "publishedAt": "2023-06-01T16:49:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The rotation of the elastic tensor",
          "author": {
            "login": "xiekai-mc"
          },
          "bodyText": "In the ComputeElasticityTensor class, it seems that C_ijkl, rotation_matrix and euler angles can only be set to specific values. If the material direction is tangential to the circumference, as shown in the figure, how can I rotate the elasticity tensor accordingly? Is there a convenient method to achieve this?",
          "url": "https://github.com/idaholab/moose/discussions/24565",
          "updatedAt": "2023-06-01T16:35:01Z",
          "publishedAt": "2023-06-01T16:35:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Convergence problem (maybe the Jacobian issue?)",
          "author": {
            "login": "bosxered"
          },
          "bodyText": "Hello Moose experts,\nI have a convergence problem in my input.\nIn detail, I set T(temperature) as an Auxkernel before setting it as a variable.\nAt T=300, 400K, 550K, 600K, and 900K my simulation converges very well.\nHowever, I cannot understand the reason why, at T=450K, and 500K, my simulation does not converge.\nI am curious if the reason is that my own kernel \"NernstElec\" has the wrong QpJacobian.\nSo, the question is\n\nWhy does not my simulation converges? the reason?\nIf the wrong Jacobian is the reason for the problem, can you help me to correct it?\nI am a beginner in this area so I am not sure if my Jacobian is right.\n\nHere is my \"NernstElec.C\" file.\nIt is for the second term of RHS. (N: variable, V(elec): coupled_variable)\n\nFor residual, it calculates (constant)(_grad_test)(_grad_elec)*(N)\n#include \"NernstElec.h\"                                                                                                                                                                     \nregisterMooseObject(\"test7App\",NernstElec);\n\nInputParameters\nNernstElec::validParams()\n{\n  InputParameters params = Kernel::validParams();\n    params.addClassDescription(\"The Laplacian operator ($-\\\\nabla \\\\cdot \\\\nabla u$), with the weak \"\n                                                         \"form of $(\\\\nabla \\\\phi_i, \\\\nabla u_h)$.\");\n    params.addCoupledVar(\"elec\", \"electrical potential\");\n    params.addParam<MaterialPropertyName>(\n            \"eDkT\",\n            \"eDkT\",\n            \"Material property.\");\n    // params.addRequiredCoupledVar(\"conductivity\",\"conductivity\");\n  return params;\n}\n\nNernstElec::NernstElec(const InputParameters & parameters)\n    : Kernel(parameters),\n    _grad_elec(coupledGradient(\"elec\")),\n    _elec_var(coupled(\"elec\")),\n    _elec_cond(getMaterialProperty<Real>(\"eDkT\"))\n\n    // _elec_cond(coupledValue(\"conductivity\"))\n    // _grad_T(coupledGradient(\"Temperature\"))\n{\n}\n\n\n\nReal\nNernstElec::computeQpResidual()\n{\n  return _elec_cond[_qp] * _grad_test[_i][_qp] * _u[_qp] * _grad_elec[_qp];\n}\n\n//Real\n//NernstElec::computeQpJacobian()\n//{\n//  return _elec_cond[_qp] * _grad_test[_i][_qp] * _phi[_j][_qp] * _grad_elec[_qp] ;\n//}\n\nFor your information, I attached my input file.\n########## Global Parameters ########## \nxmax = 35\nymax = 20\n#######################################\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 35\n  ny = 20\n  nz = 0\n  xmin = 0\n  xmax = ${xmax}\n  ymin = 0\n  ymax = ${ymax}\n  zmin = 0\n  zmax = 0\n  elem_type = QUAD8\n[]\n\n[Functions]\n  [./bc_func]\n    type = PiecewiseLinear\n    data_file = './vsweep.csv'\n    format = columns\n    scale_factor = 1.0\n  [../]\n[]\n\n[Variables]\n  [./N]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  [./V]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n[]\n\n[ICs]\n  [./N_IC]\n    type = MultiBoundingBoxIC\n    corners = '0.0 0.0 0   '\n    opposite_corners = '9.0 20.0 0'\n    inside = '1.2'\n    outside = 0.0\n    variable = N\n  [../]\n[]\n\n[BCs]\n  [V_top]\n    type = FunctionDirichletBC\n    variable = V\n    function = bc_func # GND\n    boundary = 'top'\n  []\n\n  [V_bot]\n    type = DirichletBC\n    variable = V\n    value = 0.0\n    boundary = 'bottom'\n  []\n[]\n\n[Kernels]\n\n  ########### Phase-field ############\n\n  [./Matdiff_D_del2_N]\n    type = MatDiffusion\n    variable = N\n    diffusivity = Diff_coeff\n  [../]\n\n  [./Nernst]\n    type = NernstElec\n    variable = N\n    elec = V\n    eDkT = eDkT\n  [../]\n\n\n  [./PFM_time]\n    type = TimeDerivative\n    variable = N\n  [../]\n\n  ########## Phase-field END ##########\n\n  ########## Electrical ###############\n\n  [./Matdiff_sig_del2_V]\n    type = MatDiffusion\n    variable = V\n    diffusivity = 'electrical_conductivity'\n  [../]\n\n  ########## Electrical END ###########\n\n[]\n\n\n\n\n\n[Materials]\n  [./Diff_coeff]\n    type = ParsedMaterial\n    property_name  = Diff_coeff\n    coupled_variables = 'T'\n    constant_names       = 'D0     E_A_D    kB        ' #[eV]  [eV/K]  [K]\n    constant_expressions = '2e+11  1.0      8.617e-5'\n    expression = 'D0*exp(-E_A_D/(kB*T))' #[nm^2/s]\n    outputs = exodus\n  [../]\n\n  [./eDkT]\n    type = ParsedMaterial\n    property_name = eDkT\n    coupled_variables = 'T'\n    constant_names       = 'kB       ' #[V/K]\n    constant_expressions = '8.617e-5'\n    material_property_names = 'Diff_coeff'\n    expression = 'Diff_coeff/(kB*T)' #[nm^2/(s*V)]\n    outputs = exodus\n  [../]\n\n  [./electrical_conductivity_INS]\n    type = ParsedMaterial\n    coupled_variables = 'N E_AC_elec T'\n    property_name = 'electrical_conductivity'\n    constant_names =        'sig_H    sig_L     kB'       \n    constant_expressions =  '1.0e-6   2.860e-4  8.617e-5' #[1/(ohm*nm)] [1/(ohm*nm)] [eV/K]\n#    material_property_names = 'h'\n#    function = '(1/cm_2_nm) * if(eta <= 0.5-w/2,Crys,if(eta<0.5+w/2, Amor + 0.5*(Crys+Amor)*(1.0+cos(pi*(eta-0.5+w/2)/w)),Amor))'  # [1/(ohm*nm)]\n#    function = '(sig_L - sig_H) * eta + sig_H'  # [1/(ohm*nm)]\n#    function = 'if(c <= 0.5-w/2, sig_H, if(c > 0.5+w/2, sig_L, sig_H + 0.5 * (sig_L-sig_H) * (1 - cos(pi/w * (c-0.5+w/2)))))'\n#    expression = 'sig_H*(1-h)+sig_L*h'\n    expression = '((sig_L-sig_H)/1.2*N+sig_H)*exp(-E_AC_elec/(kB*T))'\n    outputs = exodus\n#    block = 2\n  [../]\n\n[]\n\n[AuxVariables]\n\n  [./T]\n    order = CONSTANT\n    family = MONOMIAL\n    [./InitialCondition] #Temperature\n        type = ConstantIC\n        value = 450.0\n    [../]\n  []\n\n  ########## Electric ##########\n  [Ex]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [Ey]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [J]\n    family = NEDELEC_ONE\n    order = FIRST\n  []\n\n  [Jy]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [E_AC_elec]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  ######## Electric END ########\n\n[]\n\n\n[AuxKernels]\n  ########## Electric ##########\n  [Ex_aux]\n    type = PotentialToFieldAux\n    variable = Ex\n    gradient_variable = V\n    sign = negative\n    component = x\n  []\n\n  [Ey_aux]\n    type = PotentialToFieldAux\n    variable = Ey\n    gradient_variable = V\n    sign = negative\n    component = y\n  []\n\n  [current_density]\n    type = CurrentDensity\n    variable = J\n    potential = V\n  []\n\n  [Jy]\n    type = VectorVariableComponentAux\n    variable = Jy\n    vector_variable = J\n    component = y\n  []\n\n  [E_AC_elec_aux]\n    type = ParsedAux\n    variable = E_AC_elec\n    coupled_variables = 'N'\n    constant_names = 'Nth  E_AC'\n    constant_expressions = '0.3  0.05' #[nm^-3] [eV]\n    expression = 'if(N>Nth, 0, -E_AC/Nth*N + E_AC)'\n    execute_on = 'initial linear timestep_end'\n  []\n\n  ######## Electric END ########\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Postprocessors]\n\n  ######## Electric #######\n\n  #  [./Resistance]\n  #    type = FunctionValuePostprocessor\n  #    function = resistance_func\n  #  [../]\n\n  [average_V]\n    type = SideAverageValue\n    variable = V\n    boundary = 'top'\n  []\n\n  [average_Jy]\n    type = SideAverageValue\n    variable = Jy\n    boundary = 'bottom'\n  []\n\n  [Current]\n    type = ParsedPostprocessor\n    function = \"if(average_Jy>0,average_Jy*${xmax}, -average_Jy*${xmax})\"\n    pp_names = average_Jy\n  []\n  ######## Electric END #######\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = 'JFNK'\n\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre      boomeramg'\n\n  l_max_its = 50\n  nl_max_its = 50\n\n  l_tol = 1.0e-4\n  nl_rel_tol = 1.0e-8\n  nl_abs_tol = 1e-8\n\n  start_time = 0.0\n  end_time = 1.0\n  dt = 5e-4\n  dtmin = 1e-7\n\n  automatic_scaling = true\n  compute_scaling_once = false\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  file_base = output\n[]\n\n\nThank you\nJeonghwan",
          "url": "https://github.com/idaholab/moose/discussions/24535",
          "updatedAt": "2023-06-01T16:16:09Z",
          "publishedAt": "2023-05-30T16:17:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Your computeQpJacobian looks fine but you also need a computeQpOffDiagJacobian term for your potential variable.\nReal\nNernstElec::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  if (jvar == _elec_var)\n    return _elec_cond[_qp] * _grad_test[_i][_qp] * _u[_qp] * _grad_phi[_j][_qp];\n  else\n    return 0;\n}",
                  "url": "https://github.com/idaholab/moose/discussions/24535#discussioncomment-6041145",
                  "updatedAt": "2023-05-30T18:15:27Z",
                  "publishedAt": "2023-05-30T18:15:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Thank you very much!\nUnfortunately, I added your suggestion but converging is also failed.\nDo you think still the reason that my simulation does not converge only at 450, 500K is the Jacobian? any other reasons?\nAlso, I would be appreciated it if you teach me where I can find how to calculate and implement Jacobian(also OffDiagJacobian).\nI tried to learn it but the MOOSE tutorial taught me it very briefly or told me to use AD.",
                          "url": "https://github.com/idaholab/moose/discussions/24535#discussioncomment-6043477",
                          "updatedAt": "2023-05-30T23:12:28Z",
                          "publishedAt": "2023-05-30T23:12:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Why don't you use AD?",
                          "url": "https://github.com/idaholab/moose/discussions/24535#discussioncomment-6043516",
                          "updatedAt": "2023-05-30T23:23:21Z",
                          "publishedAt": "2023-05-30T23:23:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "You can use the petsc command line options -snes_test_jacobian -snes_test_jacobian_view to find problems in your Jacobian",
                          "url": "https://github.com/idaholab/moose/discussions/24535#discussioncomment-6043524",
                          "updatedAt": "2023-05-30T23:25:26Z",
                          "publishedAt": "2023-05-30T23:25:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Thank you very much!\nI will try to use AD or check other issues.",
                          "url": "https://github.com/idaholab/moose/discussions/24535#discussioncomment-6048521",
                          "updatedAt": "2023-05-31T10:42:52Z",
                          "publishedAt": "2023-05-31T10:42:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Oh I just noticed something. By default for PJFNK your preconditioning matrix only has diagonal blocks filled. To get the off-diagonal part into the system matrix you need to add this in your input file\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\nThe full = true line will make sure to use the \"full\" matrix, including both on- and off-diagonal blocks",
                          "url": "https://github.com/idaholab/moose/discussions/24535#discussioncomment-6052237",
                          "updatedAt": "2023-05-31T17:21:59Z",
                          "publishedAt": "2023-05-31T17:21:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Thanks for your kindness!!",
                          "url": "https://github.com/idaholab/moose/discussions/24535#discussioncomment-6063334",
                          "updatedAt": "2023-06-01T16:16:09Z",
                          "publishedAt": "2023-06-01T16:16:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Why did I encounter a mistake about segmentation fault?",
          "author": {
            "login": "Moyiqi"
          },
          "bodyText": "Hello everyone,may I ask a question?\nWhen I run the program, I get the following error about segmentation fault. This error still occurs when I change 'motar' to 'panelty'. How can I debug it?\n Using host libthread_db library \"/lib64/libthread_db.so.1\".\n[New Thread 0x7fffe2265700 (LWP 94047)]\n\n\n*** Info ***\nTensorMechanics Action: selecting 'incremental finite strain' formulation.\n\nThread 1 \"dog-dbg\" received signal SIGSEGV, Segmentation fault.\n0x00007fffee6ac0a6 in std::__shared_ptr<NonlinearSystemBase, (__gnu_cxx::_Lock_policy)2>::get (this=0x5565561e90b0)\n    at /home/Lily/.conda/envs/moose/x86_64-conda-linux-gnu/include/c++/10.4.0/bits/shared_ptr_base.h:1330\n1330          { return _M_ptr; }\n\nThe following is my code\uff1a\n[GlobalParams]\n displacements = 'disp_x disp_y disp_z'\n[]\n\n\ninner_outer_radius = 0.00278\ninner_inner_radius = 0.0009\nclad_inner_radius = 0.0028\nclad_outer_radius = 0.00327\n[Mesh]\n  patch_update_strategy = iteration\n  use_displaced_mesh = true\n  patch_size = 1\n  [inner_rod]\n    type = ConcentricCircleMeshGenerator\n    num_sectors = \"2\"\n    radii = '${inner_inner_radius } ${inner_outer_radius}'\n    rings = '1 4'\n    has_outer_square = false\n    preserve_volumes = true\n    portion = full\n  []\n  [rename_inner_inface]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = inner_rod\n    primary_block = 2\n    paired_block = 1\n    new_boundary = '11114'\n  []\n  [3d_inner]\n    type = AdvancedExtruderGenerator\n    input = rename_inner_inface\n    heights = '0.015 0.212 0.015'\n    direction = '0 0 1'\n    num_layers = '1 5 1'\n    top_boundary = 12\n    downward_boundary_source_blocks=\"2;2;2\"\n    downward_boundary_ids= '9999;11;9999'\n    subdomain_swaps=\"2 1;2 10;2 1;\"\n    boundary_swaps = '2 13 ;\n    2 13 11114 14;\n    2 13 '\n  []\n  \n  [inner_Delet]\n    type = BlockDeletionGenerator\n    input = 3d_inner\n    block = 1\n  []\n  [rename_inner_face]\n    type = RenameBoundaryGenerator\n    input = inner_Delet\n    old_boundary = 'outer'\n    new_boundary = '13'\n  []\n  [clad_2d]\n    type = ConcentricCircleMeshGenerator\n    num_sectors = 4\n    radii = '${clad_inner_radius} ${clad_outer_radius}'\n    rings = '1 2'\n    has_outer_square = false\n    preserve_volumes = true\n    portion = full\n  []\n  [rename_cladding_inface]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = clad_2d\n    primary_block = 2\n    paired_block = 1\n    new_boundary = 'cladding_inface'\n  []\n  [delet_inner]\n    type = BlockDeletionGenerator\n    input = rename_cladding_inface\n    block = 1\n  []\n  [3d_mesh]\n    type = AdvancedExtruderGenerator\n    input = delet_inner\n    heights = '0.2455'\n    direction = '0 0 1'\n    num_layers = '9'\n    bottom_boundary = 21\n    top_boundary = 22\n  []\n  [rename_cladding_outface]\n    type = RenameBoundaryGenerator\n    input = 3d_mesh\n    old_boundary = 'outer'\n    new_boundary = 'cladding_outface'\n  []\n  [combined]\n    type = MeshCollectionGenerator\n    inputs = 'rename_inner_face rename_cladding_outface'\n  []\n  [renameblock]\n    type = RenameBlockGenerator\n    input = combined\n    old_block = '10 2'\n    new_block = 'inner cladding'\n  []\n  [rename_Boundary]\n    type = RenameBoundaryGenerator\n    input = renameblock\n    old_boundary = '13 21 14'\n    new_boundary = 'inner_face bottom inner_innner_face '\n  []\n[]\n\n\n\n[Variables]\n  [disp_x]\n    block = '10 2'\n  []\n  [disp_y]\n    block = '10 2'\n  []\n  [disp_z]\n    block = '10 2'\n  []\n[]\n\n\n[Kernels]\n[]\n\n[AuxVariables] \n  [T]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n[Functions]\n  [TFunc]\n    type = PiecewiseLinear\n    x = '0    10'\n    y = '400  1000'\n  []\n[]\n[AuxKernels]\n  [burnup]\n    type = FunctionAux\n    variable = T\n    function = TFunc\n    execute_on = timestep_begin\n  []\n[]\n\n[Contact]\n  [mortar]\n    primary = 'cladding_inface'\n    secondary = 'inner_face'\n    formulation = penalty\n    model = frictionless\n    normal_smoothing_distance = 0.1\n    penalty = 1.0e+7\n  []\n[]\n\n[BCs]\n  [botx]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom inner_innner_face'\n    value = 0.0\n  []\n  [boty]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom inner_innner_face'\n    value = 0.0\n  []\n  [botz]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom inner_innner_face'\n    value = 0.0\n  []\n[]\n\n[Executioner]\n  type = Transient\n  end_time = 10\n  dt = 1\n  dtmin = .01\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = ' lu       superlu_dist'\n  line_search = 'none'\n\n  verbose = true\n  # controls for linear iterations\n  l_max_its = 50\n  l_tol = 8e-3\n\n  # controls for nonlinear iterations\n  nl_max_its = 20\n  nl_rel_tol = 1e-4\n  nl_abs_tol = 1e-10\n  snesmf_reuse_base = false\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n[]\n\n[Materials]\n  [tensor]\n    type = ComputeIsotropicElasticityTensor\n    block = 'inner'\n    youngs_modulus = 2.0e11\n    poissons_ratio = 0.345\n  []\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n    block = 'inner'\n  []\n  [./inner_thermal_strain]\n    type = ComputeThermalExpansionEigenstrain\n    thermal_expansion_coeff = 10e-6\n    stress_free_temperature = 273\n    temperature = T\n    block=inner\n    eigenstrain_name = 'eigenstrain'\n  [../]\n\n  [tensor_1000]\n    type = ComputeIsotropicElasticityTensor\n    block = 'cladding'\n    youngs_modulus =  8.8e10\n    poissons_ratio = 0.34\n  []\n  [stress_1000]\n    type = ComputeFiniteStrainElasticStress\n    block = 'cladding'\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [b1]\n    add_variables = true\n    strain = FINITE\n    block = '10'\n    use_automatic_differentiation = false\n    eigenstrain_names = 'eigenstrain'\n    generate_output = 'stress_xx stress_xy stress_xz stress_yy stress_zz'\n  []\n  [b2]\n    add_variables = true\n    strain = FINITE\n    block = '2'\n    use_automatic_differentiation = false\n    generate_output = 'stress_xx stress_xy stress_xz stress_yy stress_zz'\n  []\n[]\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Postprocessors]\n  [num_nl]\n    type = NumNonlinearIterations\n  []\n  [cumulative]\n    type = CumulativeValuePostprocessor\n    postprocessor = num_nl\n  []\n  [contact]\n    type = ContactDOFSetSize\n    variable = mortar_normal_lm\n    subdomain = 'mortar_secondary_subdomain'\n    execute_on = 'nonlinear timestep_end'\n  []\n[]\n\n\nLily",
          "url": "https://github.com/idaholab/moose/discussions/24557",
          "updatedAt": "2023-06-04T03:28:22Z",
          "publishedAt": "2023-06-01T02:57:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "A segfault should be easy to find using a debugger like gdb on Linux.\nThere s a debugging page on the moose website you can use if you don\u2019t have experience with that",
                  "url": "https://github.com/idaholab/moose/discussions/24557#discussioncomment-6055579",
                  "updatedAt": "2023-06-01T03:13:46Z",
                  "publishedAt": "2023-06-01T03:13:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Need help with parameter study on 10,000 different Voronoi meshes.",
          "author": {
            "login": "gutza1"
          },
          "bodyText": "My team is attempting to run a parameter study that will generate 10,000 different meshes and perform a single time step on each. We have looked at the Parameter study tutorial on the website and have modified the code for our application, but when we attempted to run it, we got an error message claiming that the input file has no actionable object. What could be causing this error?\nSecond, how would one generate a discrete distribution of parameters (e.g. 1, 2, 3...)? We are attempting to do a parameter study where the parameter varied is the random seed number.\nI have included the following code of the input file:\n[ParameterStudy]\n  input = MOOSE_10_grains_Stochastic.i\n  parameters = 'UserObjects/voronoi/rand_seed'\n  # quantities_of_interest = 'T_avg/value q_left/value'\n\n  sampling_type = lhs\n  num_samples = 10000\n  distributions = 'uniform'\n  uniform_lower_bound = 1\n  uniform_upper_bound = 20000\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24393",
          "updatedAt": "2023-06-01T01:42:11Z",
          "publishedAt": "2023-05-16T16:54:28Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@zachmprince",
                  "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5918940",
                  "updatedAt": "2023-05-16T17:04:59Z",
                  "publishedAt": "2023-05-16T17:04:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "So the first issue is probably a bug in the way it automatically determines the multiapp_mode parameter. So I would just set this manually. The safest one is multiapp_mode = batch-reset, but I would need to see the input to suggest the best one.\nFor the discrete sampling, there isn't a way to do this in the sampler. But one thing you can do is have this in MOOSE_10_grains_Stochastic.i:\nrand_seed_real = 0.0 # Dummy value to be replaced by sampling\nrand_seed = ${fparse int(rand_seed_real)}\n\n[UserObjects]\n  [voronoi]\n    ...\n    rand_seed = ${rand_seed} \n  []\n[]\n\nThen you would just perturb rand_seed_real in ParameterStudy/parameters:\n[ParameterStudy]\n  input = MOOSE_10_grains_Stochastic.i\n  multiapp_mode = batch-reset\n  parameters = 'rand_seed_real'\n  # quantities_of_interest = 'T_avg/value q_left/value'\n\n  sampling_type = lhs\n  num_samples = 10000\n  distributions = 'uniform'\n  uniform_lower_bound = 1\n  uniform_upper_bound = 20000\n[]\n\nDoing this requires multiapp_mode = batch-reset.",
                  "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5920319",
                  "updatedAt": "2023-05-16T19:47:22Z",
                  "publishedAt": "2023-05-16T19:47:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "gutza1"
                  },
                  "bodyText": "Unfortunately, we have implemented your fixes and are getting the same error: \"section \"ParameterStudy\" does not have an associated \"Action.\"\"",
                  "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5956095",
                  "updatedAt": "2023-05-20T15:49:33Z",
                  "publishedAt": "2023-05-20T15:49:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "How old is your moose version?\nIs your app including the stochastic tools module?",
                          "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5957510",
                          "updatedAt": "2023-05-20T22:53:27Z",
                          "publishedAt": "2023-05-20T22:53:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gutza1"
                          },
                          "bodyText": "We are using the latest version and have installed the app on the StochasticTools module. He have tried everything and we don't know what to do to fix the issue. We're at the end of our rope. If there anything you can suggest we do, please share it.",
                          "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5961175",
                          "updatedAt": "2023-05-21T19:17:54Z",
                          "publishedAt": "2023-05-21T19:17:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What do you mean by installed the app on the module?\nThis does not seem right. To create an app, you need to use the stork script in moose/scripts and then enable every physics module you need in the Makefile",
                          "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5961768",
                          "updatedAt": "2023-05-21T22:16:25Z",
                          "publishedAt": "2023-05-21T22:16:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gutza1"
                          },
                          "bodyText": "Apologies, I misspoke. I meant that we had enabled the StochasticTools module while running the latest version.",
                          "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5962621",
                          "updatedAt": "2023-05-22T02:34:52Z",
                          "publishedAt": "2023-05-22T02:34:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "And your rebuilt (make) the executable after enabling the module right\nwhat does ldd <your_executable-opt> return (on linux) ?",
                          "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5962709",
                          "updatedAt": "2023-05-22T02:50:27Z",
                          "publishedAt": "2023-05-22T02:50:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gutza1"
                          },
                          "bodyText": "`linux-vdso.so.1 =>\u00a0 (0x00007fffedb02000)\nlibcoupling_xolotl_test-opt.so.0 => /home/muntmda/coupling_xolotl/test/lib/libcoupling_xolotl_test-opt.so.0 (0x00007fffed6d4000)\nlibcoupling_xolotl-opt.so.0 => /home/muntmda/coupling_xolotl/lib/libcoupling_xolotl-opt.so.0 (0x00007fffed48f000)\nlibmodule_loader_with_tm_pf-opt.so.0 => /home/muntmda/coupling_xolotl/moose/modules/module_loader/lib/libmodule_loader_with_tm_pf-opt.so.0 (0x00007fffed280000)\nlibphase_field-opt.so.0 => /home/muntmda/coupling_xolotl/moose/modules/phase_field/lib/libphase_field-opt.so.0 (0x00007fffec938000)\nlibtensor_mechanics-opt.so.0 => /home/muntmda/coupling_xolotl/moose/modules/tensor_mechanics/lib/libtensor_mechanics-opt.so.0 (0x00007fffeba6a000)\nlibmoose-opt.so.0 => /home/muntmda/coupling_xolotl/moose/framework/libmoose-opt.so.0 (0x00007fffe95a4000)\nlibpcre-opt.so.0 => /home/muntmda/coupling_xolotl/moose/framework/contrib/pcre/libpcre-opt.so.0 (0x00007fffe9380000)\nlibhit-opt.so.0 => /home/muntmda/coupling_xolotl/moose/framework/contrib/hit/libhit-opt.so.0 (0x00007fffe9122000)\nlibxolotlInterface.so => /home/muntmda/coupling_xolotl/xolotl/install/lib/libxolotlInterface.so (0x00007fffe8efa000)\nlibmesh_opt.so.0 => /home/muntmda/coupling_xolotl/moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0 (0x00007fffe7921000)\nlibnetcdf.so.13 => /home/muntmda/coupling_xolotl/moose/scripts/../libmesh/installed/lib/libnetcdf.so.13 (0x00007fffe763a000)\nlibtimpi_opt.so.11 => /home/muntmda/coupling_xolotl/moose/scripts/../libmesh/installed/lib/libtimpi_opt.so.11 (0x00007fffe742d000)\nlibmpicxx.so.12 => /apps/local/mvapich2/2.3.7-1-gcc-8.4.0/lib/libmpicxx.so.12 (0x00007fffe720c000)\nlibslepc.so.3.16 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libslepc.so.3.16 (0x00007fffe6ca1000)\nlibpetsc.so.3.16 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libpetsc.so.3.16 (0x00007fffe5447000)\nlibHYPRE-2.23.0.so => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libHYPRE-2.23.0.so (0x00007fffe4e37000)\nlibstrumpack.so => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libstrumpack.so (0x00007fffe43f2000)\nlibsuperlu_dist.so.7 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libsuperlu_dist.so.7 (0x00007fffe40f6000)\nlibhdf5_hl.so.200 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libhdf5_hl.so.200 (0x00007fffe3ed3000)\nlibhdf5.so.200 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libhdf5.so.200 (0x00007fffe388c000)\nlibparmetis.so => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libparmetis.so (0x00007fffe364e000)\nlibmetis.so => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libmetis.so (0x00007fffe33ed000)\nlibX11.so.6 => /lib64/libX11.so.6 (0x00007fffe30af000)\nlibmpifort.so.12 => /apps/local/mvapich2/2.3.7-1-gcc-8.4.0/lib/libmpifort.so.12 (0x00007fffe2e77000)\nlibmpi.so.12 => /apps/local/mvapich2/2.3.7-1-gcc-8.4.0/lib/libmpi.so.12 (0x00007fffe2031000)\nlibnuma.so.1 => /lib64/libnuma.so.1 (0x00007fffe1e25000)\nlibudev.so.1 => /lib64/libudev.so.1 (0x00007fffe1c0f000)\nlibxml2.so.2 => /lib64/libxml2.so.2 (0x00007fffe18a5000)\nlibibmad.so.12 => /lib64/libibmad.so.12 (0x00007fffe1685000)\nlibrdmacm.so.1 => /lib64/librdmacm.so.1 (0x00007fffe1469000)\nlibibumad.so.3 => /lib64/libibumad.so.3 (0x00007fffe125f000)\nlibibverbs.so.1 => /lib64/libibverbs.so.1 (0x00007fffe1046000)\nlibpthread.so.0 => /lib64/libpthread.so.0 (0x00007fffe0e2a000)\nlibgfortran.so.5 => /apps/local/spack/software/gcc-4.8.5/gcc-8.4.0-jacdabugmghmzya2rpfqpym2bpzjomy2/lib64/libgfortran.so.5 (0x00007fffe09b9000)\nlibz.so.1 => /lib64/libz.so.1 (0x00007fffe07a3000)\nlibgcc_s.so.1 => /apps/local/spack/software/gcc-4.8.5/gcc-8.4.0-jacdabugmghmzya2rpfqpym2bpzjomy2/lib64/libgcc_s.so.1 (0x00007fffe058b000)\nlibrt.so.1 => /lib64/librt.so.1 (0x00007fffe0383000)\nlibquadmath.so.0 => /apps/local/spack/software/gcc-4.8.5/gcc-8.4.0-jacdabugmghmzya2rpfqpym2bpzjomy2/lib64/libquadmath.so.0 (0x00007fffe0143000)\nlibstdc++.so.6 => /apps/local/spack/software/gcc-4.8.5/gcc-8.4.0-jacdabugmghmzya2rpfqpym2bpzjomy2/lib64/libstdc++.so.6 (0x00007fffdfdbf000)\nlibdl.so.2 => /lib64/libdl.so.2 (0x00007fffdfbbb000)\nlibm.so.6 => /lib64/libm.so.6 (0x00007fffdf8b9000)\nlibgomp.so.1 => /apps/local/spack/software/gcc-4.8.5/gcc-8.4.0-jacdabugmghmzya2rpfqpym2bpzjomy2/lib64/libgomp.so.1 (0x00007fffdf68b000)\nlibc.so.6 => /lib64/libc.so.6 (0x00007fffdf2bd000)\nlibxolotlSolver.so => /home/muntmda/coupling_xolotl/xolotl/install/lib/libxolotlSolver.so (0x00007fffdf007000)\nlibxolotlIO.so => /home/muntmda/coupling_xolotl/xolotl/install/lib/libxolotlIO.so (0x00007fffdede0000)\nlibxolotlViz.so => /home/muntmda/coupling_xolotl/xolotl/install/lib/libxolotlViz.so (0x00007fffdebcf000)\nlibxolotlCore.so => /home/muntmda/coupling_xolotl/xolotl/install/lib/libxolotlCore.so (0x00007fffde579000)\nlibxolotlPerf.so => /home/muntmda/coupling_xolotl/xolotl/install/lib/libxolotlPerf.so (0x00007fffde35b000)\nlibxolotlFactory.so => /home/muntmda/coupling_xolotl/xolotl/install/lib/libxolotlFactory.so (0x00007fffde14a000)\nlibxolotlOptions.so => /home/muntmda/coupling_xolotl/xolotl/install/lib/libxolotlOptions.so (0x00007fffddf1c000)\nlibboost_program_options.so.1.74.0 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libboost_program_options.so.1.74.0 (0x00007fffddcb4000)\nlibxolotlUtil.so => /home/muntmda/coupling_xolotl/xolotl/install/lib/libxolotlUtil.so (0x00007fffdda78000)\nlibboost_log.so.1.74.0 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libboost_log.so.1.74.0 (0x00007fffdd7ab000)\nlibboost_filesystem.so.1.74.0 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libboost_filesystem.so.1.74.0 (0x00007fffdd58d000)\nlibboost_log_setup.so.1.74.0 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libboost_log_setup.so.1.74.0 (0x00007fffdd2ef000)\nlibboost_thread.so.1.74.0 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libboost_thread.so.1.74.0 (0x00007fffdd0d0000)\nlibboost_date_time.so.1.74.0 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libboost_date_time.so.1.74.0 (0x00007fffdcece000)\nlibboost_regex.so.1.74.0 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libboost_regex.so.1.74.0 (0x00007fffdcc19000)\nlibboost_chrono.so.1.74.0 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libboost_chrono.so.1.74.0 (0x00007fffdca10000)\nlibboost_atomic.so.1.74.0 => /home/muntmda/coupling_xolotl/moose/petsc/arch-moose/lib/libboost_atomic.so.1.74.0 (0x00007fffdc809000)\nlibkokkoscontainers.so.3.7 => /home/muntmda/coupling_xolotl/kokkos/install/lib64/libkokkoscontainers.so.3.7 (0x00007fffdc606000)\nlibkokkoscore.so.3.7 => /home/muntmda/coupling_xolotl/kokkos/install/lib64/libkokkoscore.so.3.7 (0x00007fffdc36d000)\nlibkokkossimd.so.3.7 => /home/muntmda/coupling_xolotl/kokkos/install/lib64/libkokkossimd.so.3.7 (0x00007fffdc16b000)\n/lib64/ld-linux-x86-64.so.2 (0x00007fffed8e3000)\nlibxcb.so.1 => /lib64/libxcb.so.1 (0x00007fffdbf43000)\nlibcap.so.2 => /lib64/libcap.so.2 (0x00007fffdbd3e000)\nlibdw.so.1 => /lib64/libdw.so.1 (0x00007fffdbaed000)\nliblzma.so.5 => /lib64/liblzma.so.5 (0x00007fffdb8c7000)\nlibnl-route-3.so.200 => /lib64/libnl-route-3.so.200 (0x00007fffdb65a000)\nlibnl-3.so.200 => /lib64/libnl-3.so.200 (0x00007fffdb439000)\nlibXau.so.6 => /lib64/libXau.so.6 (0x00007fffdb235000)\nlibattr.so.1 => /lib64/libattr.so.1 (0x00007fffdb030000)\nlibelf.so.1 => /lib64/libelf.so.1 (0x00007fffdae18000)\nlibbz2.so.1 => /lib64/libbz2.so.1 (0x00007fffdac08000)`",
                          "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5979597",
                          "updatedAt": "2023-05-23T15:03:26Z",
                          "publishedAt": "2023-05-23T15:03:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This doesn\u2019t include stochastic tools\ncan you please paste your make file here",
                          "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5979885",
                          "updatedAt": "2023-05-23T15:28:36Z",
                          "publishedAt": "2023-05-23T15:28:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gutza1"
                          },
                          "bodyText": "Here is the makefile, sorry for the delay.\nMakefile.txt",
                          "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5991045",
                          "updatedAt": "2023-05-24T15:02:04Z",
                          "publishedAt": "2023-05-24T15:00:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you git clean -xfd then rebuild?\nyou have the right command in the Makefile to enable stochastic_tools",
                          "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5991900",
                          "updatedAt": "2023-05-24T16:08:49Z",
                          "publishedAt": "2023-05-24T16:08:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gutza1"
                          },
                          "bodyText": "Apologies for the delay. We've been trying to figure out other solutions to the problem, but after seeing a past user who encountered a similar issue, I'm wondering if the problem lies in the base script itself. I've posted it here, please take a look to see if there's anything that wouldn't play well with StochasticTools.\nMOOSE_10_grains_Stochastic.txt",
                          "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-6053969",
                          "updatedAt": "2023-05-31T21:39:47Z",
                          "publishedAt": "2023-05-31T21:39:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "gutza1"
                  },
                  "bodyText": "@zachmprince",
                  "url": "https://github.com/idaholab/moose/discussions/24393#discussioncomment-5957078",
                  "updatedAt": "2023-05-20T20:27:39Z",
                  "publishedAt": "2023-05-20T20:27:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}