{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNC0yOFQyMjowMzoxMi0wNTowMM4ATI54"
    },
    "edges": [
      {
        "node": {
          "title": "Shells: support for quadratic triangular elements (6 nodes)",
          "author": {
            "login": "jmeier"
          },
          "bodyText": "Dear Moose Comunity,\nThis question is abaout support for quadratic triangular elements (6 nodes) for shells.\nIs it correct that Moose does not (yet) have tri6 shell elements ready? If not, are there plans to implement this?\nIn detail:\nI have an MSH-File (gmsh) I import successfully in Moose. The msh contains volume-elements (TRI10), surface-elements (TRI6) and beam-Elements (EDGE3). Moose reads the elements and does not complain. So far, so good.\nI tried to assign a shell-material:\n[Materials]\n  [./sign_elasticity]\n    type = ADComputeIsotropicElasticityTensorShell\n    youngs_modulus = 210E6\n    poissons_ratio = 0.2\n    block = ${volSign}\n    through_thickness_order = SECOND\n  []\n  [./sign_strain]\n    type = ADComputeIncrementalShellStrain\n    block = ${volSign}\n    displacements = 'disp_x disp_y disp_z'\n    rotations = 'rot_x rot_y'\n    thickness = 0.1\n    through_thickness_order = SECOND\n  []\n  [./sign_stress]\n    type = ADComputeShellStress\n    block = ${volSign}\n    through_thickness_order = SECOND\n  []\n[]\n\nNow I get the following error:\n*** ERROR ***\nThe following error occurred in the object \"sign_strain\", of type \"ADComputeIncrementalShellStrain\".\nADComputeIncrementalShellStrain: Shell element is implemented only for linear elements.\n\nThanks\nTag @cticenhour",
          "url": "https://github.com/idaholab/moose/discussions/23874",
          "updatedAt": "2023-05-02T05:13:27Z",
          "publishedAt": "2023-03-28T15:49:39Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "Thanks for moving your question here, @grunerjmeier! Looking at the git blame, I am going to tag @sveerara for comment on this one.\nFor general Tensor Mechanics knowledge, I'll also tag @bwspenc @sapitts.",
                  "url": "https://github.com/idaholab/moose/discussions/23874#discussioncomment-5456204",
                  "updatedAt": "2023-03-28T16:10:31Z",
                  "publishedAt": "2023-03-28T16:10:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@recuero on shell elements",
                          "url": "https://github.com/idaholab/moose/discussions/23874#discussioncomment-5759704",
                          "updatedAt": "2023-04-29T03:05:37Z",
                          "publishedAt": "2023-04-29T03:05:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@jain651",
                          "url": "https://github.com/idaholab/moose/discussions/23874#discussioncomment-5759705",
                          "updatedAt": "2023-04-29T03:05:44Z",
                          "publishedAt": "2023-04-29T03:05:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "To my knowledge, there are no plans for extending the structural element support. The only available shell element is the one documented online: https://mooseframework.inl.gov/modules/tensor_mechanics/ShellElements.html.",
                          "url": "https://github.com/idaholab/moose/discussions/23874#discussioncomment-5759742",
                          "updatedAt": "2023-04-29T03:24:23Z",
                          "publishedAt": "2023-04-29T03:24:22Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Thanks for your answer @recuero.",
                          "url": "https://github.com/idaholab/moose/discussions/23874#discussioncomment-5777001",
                          "updatedAt": "2023-05-02T05:13:25Z",
                          "publishedAt": "2023-05-02T05:13:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "stateful material property for an IC object",
          "author": {
            "login": "steam-simulator"
          },
          "bodyText": "Hello @GiudGiud, can I describe a stateful material property in an IC object? I\u2019m getting the following\nerror: 'declareProperty' was not declared in this scope.\nI have the following in my header and src:\nMaterialProperty<Real> & _b;\nconst MaterialProperty<Real> & _b_old;   \n\n_b(declareProperty<Real>(\"initial_frac\")),\n_b_old(getMaterialPropertyOld<Real>(\"initial_frac_old\")),\n\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/24242",
          "updatedAt": "2023-05-01T22:40:09Z",
          "publishedAt": "2023-05-01T22:28:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nInitial conditions cannot declare material properties.\nOnly a Material object can\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classMaterialBase.html#ac0bb20e3b6934feb9bbe61da109053fc\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24242#discussioncomment-5775586",
                  "updatedAt": "2023-05-01T22:35:52Z",
                  "publishedAt": "2023-05-01T22:35:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "steam-simulator"
                          },
                          "bodyText": "Yeah, I thought so. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24242#discussioncomment-5775602",
                          "updatedAt": "2023-05-01T22:39:52Z",
                          "publishedAt": "2023-05-01T22:39:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MALAMUTE ROM Development: Jacobian Reduction",
          "author": {
            "login": "raj-anant"
          },
          "bodyText": "Dear MOOSE Team,\nWe are developing a ROM for MALAMUTE and are exploring different parts of the problem where we can achieve a reduction. In particular, we are interested in achieving reduction at the level of the Jacobian. However, we had a few concerns about the feasibility of the implementation of any such approach. Specifically, we had the following questions:\n(i) Is it possible to read in an approximate base Jocobian for the problem through a file or generate it through a script inside MOOSE?\n(ii) Is it possible to make small updates to the base Jacobian as the solution evolves using a script inside MOOSE? Essentially, we want to explore bypassing the computation of the Jacobian through AD at each non-linear iteration.\n(iii) Is it possible to bypass PetSci for the solution of the non-linear iteration?\n(iv) Is there a convenient way for dumping the Jacobian to a file every few time steps/iterations? Write now we are using \"-ksp_view_mat\" option, but that dumps the Jacobian directly into the text output file serially at every non-linear iteration, which is very difficult to post-process.\n(v) Similarly, is there a way to dump the residuals to a file every few non-linear iterations? We are looking for the residuals at the start of the iteration, not just the final value after convergence.\nWe would appreciate any help on this.\nThanks,\nAnant",
          "url": "https://github.com/idaholab/moose/discussions/24240",
          "updatedAt": "2023-06-24T22:33:05Z",
          "publishedAt": "2023-05-01T20:05:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cticenhour",
                  "url": "https://github.com/idaholab/moose/discussions/24240#discussioncomment-5774895",
                  "updatedAt": "2023-05-01T20:16:39Z",
                  "publishedAt": "2023-05-01T20:16:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@GiudGiud This is more like framework/solver level question. @raj-anant worked with me, and I do not have sufficient knowledge to answer some of his question. We hope posting those questions here will provide us better directions to approach next.",
                          "url": "https://github.com/idaholab/moose/discussions/24240#discussioncomment-5774950",
                          "updatedAt": "2023-05-01T20:26:33Z",
                          "publishedAt": "2023-05-01T20:26:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "The short answer to all of your questions is sadly no but we welcome contributions.  You can write your own Executioner and SolveObject and FEProblemBase derived objects in which you can do almost anything you want. You could override the Jacobian computation routine from the latter for instance.\nI'll give a little more detail on a few:\niii) You can write your own custom line search if that's what you mean by bypassing PETSc's nonlinear solution. However, you would still be using the built-in KSP in the PETSc SNES object\niv) You could hack in some condition MatView calls within the framework contingent on time step/iteration number etc.\nv) similarly as iv)",
                  "url": "https://github.com/idaholab/moose/discussions/24240#discussioncomment-5774963",
                  "updatedAt": "2023-05-01T20:29:31Z",
                  "publishedAt": "2023-05-01T20:28:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Linking material property to ADDirichletBC",
          "author": {
            "login": "LukeFisherUKAEA"
          },
          "bodyText": "Hello,\nI am looking to bring the output of a MaterialProperty block into an AD Dirichlet boundary condition and wondered if code for this already exists in the BCs library?  I can see that an ADMatNeumann BC exists, but cannot see the same for a Dirichlet condition.  Is there something fundamental (e.g. integrated vs nodal boundary condition type) that would prevent this from working?  For context, we are looking to implement Sieverts Law on a boundary:\n\nwhere\n\nInitially temperature, T, will be implemented as an AuxVariable but we will want to get to the point where we can solve for heat transfer in parallel, meaning T will become a non-linear variable.  The intention would be to calculate the solubility coefficient in a ParsedMaterial block and feed that into a Dirichlet boundary condition to calculate surface concentration, C, with pressure also an AuxVariable.\nAny advice or suggestions would be much appreciated.  Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/23634",
          "updatedAt": "2023-05-01T18:08:09Z",
          "publishedAt": "2023-03-07T09:58:57Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe do not have such a BC currently.\nYou may consider the ADMatchedValueBC for an example.\nUsing AD will simplify the implementation\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23634#discussioncomment-5231226",
                  "updatedAt": "2023-03-07T16:59:13Z",
                  "publishedAt": "2023-03-07T16:59:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Is there something fundamental (e.g. integrated vs nodal boundary condition type) that would prevent this from working?\n\nCorrect. Material properties are stored on quadrature points, and nodal BCs are nodal... The two natural workarounds are:\n\nconvert the nodal BC to integrated BC, for example MatchedValueBC as @GiudGiud suggested.\nproject (extrapolate) the material properties onto the boundary nodes.",
                  "url": "https://github.com/idaholab/moose/discussions/23634#discussioncomment-5291384",
                  "updatedAt": "2023-03-13T13:07:34Z",
                  "publishedAt": "2023-03-13T13:07:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Let's link those threads\n#24106",
                          "url": "https://github.com/idaholab/moose/discussions/23634#discussioncomment-5759727",
                          "updatedAt": "2023-04-29T03:14:45Z",
                          "publishedAt": "2023-04-29T03:14:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "ADMatchedValueBC is also a nodal BC",
                          "url": "https://github.com/idaholab/moose/discussions/23634#discussioncomment-5774009",
                          "updatedAt": "2023-05-01T18:08:09Z",
                          "publishedAt": "2023-05-01T18:08:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "dt suddenly drops to 1e-19 and stops working. How to fix this issue?",
          "author": {
            "login": "K-Komal-98"
          },
          "bodyText": "I am working on a dendrite growth problem.\nThere are two input files:\n\nwithout mechanics. This works well even beyond 17000 time steps\nwith mechanics. This works well upto 169 time steps and suddenly dt reduces to 1e-13.\n\nI have followed the instructions given in this link but couldn't solve the issue: https://mooseframework.inl.gov/application_usage/failed_solves.html\nI am pasting the input files for both the parts and marking the added part in between --------------\nThis is my thesis work. Can you please guide me what can I do to solve this issue?\nInput file for WITHOUT MECHANICS:\ninput file.\nDefine mesh. 2-D system, simulation size 200*200.\n[Mesh]\ntype = GeneratedMesh\ndim = 2\nnx = 200\nxmax =200\nny=200\nymax=200\n[]\nvariables. w: chemical potential, eta: order parameter, pot: applied overpotential.\n[Variables]\n[./w]\n[../]\n[./eta]\n[../]\n[./pot]\n[../]\n[]\nCreating functions for initial conditions.\n[Functions]\n[./ic_func_eta]\ntype = ParsedFunction\nvalue = 0.5*(1.0-1.0*tanh((x-20)2))\n[../]\n[./ic_func_c]\ntype = ParsedFunction\nvalue = 0\n[../]\n[./ic_func_pot]\ntype = ParsedFunction\nvalue = -0.225(1.0-tanh((x-20)*2))\n[../]\n[]\nInitial conditions.\n[ICs]\n[./eta]\nvariable = eta\ntype = FunctionIC\nfunction = ic_func_eta\n[../]\n[./w]\nvariable = w\ntype = FunctionIC\nfunction = ic_func_c\n[../]\n[./pot]\nvariable = pot\ntype = FunctionIC\nfunction = ic_func_pot\n[../]\n[]\nBoundary conditions.\n[BCs]\n[./bottom_eta]\ntype = NeumannBC\nvariable = 'eta'\nboundary = 'bottom'\nvalue = 0\n[../]\n[./top_eta]\ntype = NeumannBC\nvariable = 'eta'\nboundary = 'top'\nvalue = 0\n[../]\n[./left_eta]\ntype = DirichletBC\nvariable = 'eta'\nboundary = 'left'\nvalue = 1\n[../]\n[./right_eta]\ntype = DirichletBC\nvariable = 'eta'\nboundary = 'right'\nvalue = 0\n[../]\n[./bottom_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'bottom'\nvalue = 0\n[../]\n[./top_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'top'\nvalue = 0.0\n[../]\n[./left_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'left'\nvalue = 0\n[../]\n[./right_w]\ntype = DirichletBC\nvariable = 'w'\nboundary = 'right'\nvalue = 0.0\n[../]\n[./left_pot]\ntype = DirichletBC\nvariable = 'pot'\nboundary = 'left'\nvalue = -0.45\n[../]\n[./right_pot]\ntype = DirichletBC\nvariable = 'pot'\nboundary = 'right'\nvalue = 0\n[../]\n[]\n[Kernels]\nFirst part of equation 3 in main text . chi*dw/dt\n[./w_dot]\ntype = SusceptibilityTimeDerivative\nvariable = w\nf_name = chi\nargs = 'w'\n[../]\nIntrinsic diffusion part of equation 3 in main text.\n[./Diffusion1]\ntype = MatDiffusion\nvariable=w\nD_name=D\n[../]\nMigration.\n[./Diffusion2]\ntype = Migration\nvariable = w\ncv=eta\nQ_name = 0.\nQM_name = DN\ncp=pot\n[../]\nCoupling between w and eta.\n[./coupled_etadot]\ntype = CoupledSusceptibilityTimeDerivative\nvariable = w\nv = eta\nf_name = ft\nargs = 'eta'\n[../]\nConduction, left handside of equation 4 in main text.\n[./Cond]\ntype = Conduction\nvariable = pot\ncp=eta\ncv =w\nQ_name = Le1\nQM_name=0.\n[../]\nSource term for Equation 4 in main text.\n[./coupled_pos]\ntype = CoupledSusceptibilityTimeDerivative\nvariable = pot\nv = eta\nf_name = ft2\nargs = 'eta'\n[../]\nBulter-volmer equation, right hand side of Equation 1 in main text.\n[./BV]\ntype = Kinetics\nvariable = eta\nf_name = G\ncp=pot\ncv=eta\n[../]\nDriving force from switching barrier, right hand side of Equation 1 in main text.\n[./AC_bulk]\ntype = AllenCahn\nvariable = eta\nf_name = FF\n[../]\ninterfacial energy\n[./AC_int]\ntype = ACInterface\nvariable = eta\n[../]\n[./Noiseeta]\ntype = LangevinNoise\nvariable = eta\namplitude=0.04\n[../]\ndeta/dt\n[./e_dot]\ntype = TimeDerivative\nvariable = eta\n[../]\n[]\n[Materials]\n[./constants]\ntype = GenericConstantMaterial\nkappa_op: gradient coefficient;  M0:diffucion coefficient of Li+ in electrolyte\nS1, S2 conductivity of electrode and electrolyte; L: kinetic coefficient; Ls: electrochemical kinetic coefficient; B: Barrier height;\nes, el: difference in the chemical potential of lithium and neutral components on the electrode/electrolyte phase at initial equilibrium state;\nus, ul: free energy density of the electrode/electrolyte phases. Defined in Ref. 20 and 26 of the main text; A: prefactor; AA: nF/(R*T);\ndv is the ratio of site density for the electrode/electrolyte phases; ft2: normalized used in Equation 4.\nprop_names  = 'kappa_op  M0     S1    S2     L    Ls       B   es       el    A     ul    us    AA  dv   ft2'\nprop_values = '0.3   317.9   1000000 1.19   6.25   0.001  2.4  -13.8  2.631   1.0   0.0695 13.8   38.69 5.5 0.0074'\n[../]\ngrand potential of electrolyte phase\n[./liquid_GrandPotential]\ntype = DerivativeParsedMaterial\nfunction = 'ul-A*log(1+exp((w-el)/A))'\nargs = 'w'\nf_name = f1\nmaterial_property_names = 'A ul el'\n[../]\ngrand potential of electrode phase\n[./solid_GrandPotential]\ntype = DerivativeParsedMaterial\nfunction = 'us-A*log(1+exp((w-es)/A))'\nargs = 'w'\nf_name = f2\nmaterial_property_names = 'A us es'\n[../]\n#interpolation function h\n[./switching_function]\ntype = SwitchingFunctionMaterial\neta ='eta'\nh_order = HIGH\n[../]\nBarrier function g\n[./barrier_function]\ntype = BarrierFunctionMaterial\neta = eta\n[../]\n[./total_GrandPotential]\ntype = DerivativeTwoPhaseMaterial\nargs = 'w'\neta = eta\nfa_name = f1\nfb_name = f2\nderivative_order = 2\nW = 2.4\n[../]\nCoupling between eta and w\n[./coupled_eta_function]\ntype = DerivativeParsedMaterial\nfunction = '-(csdv-cl)dh'  # in this code cs=-cs h=eta dh=1\nargs = ' w eta'\nf_name = ft\nmaterial_property_names = 'dh:=D[h,eta] h dv cs:=D[f2,w] cl:=D[f1,w]'\nderivative_order = 1\n[../]\n[./susceptibility]\ntype = DerivativeParsedMaterial\nfunction = '-d2F1(1-h)-d2F2hdv'\nargs = 'w'\nf_name = chi\nderivative_order = 1\nmaterial_property_names = 'h dv d2F1:=D[f1,w,w] d2F2:=D[f2,w,w]'\n[../]\n# Mobility defined by Dc/(RT), whereRT is normalized by the chemical potential\n# M0*(1-h) is the effective diffusion coefficient; cl*(1-h) is the ion concentration\n[./Mobility_coefficient]\ntype = DerivativeParsedMaterial\nfunction = '-M0*(1-h)cl(1-h)'  #c is -c\nf_name = D\nargs = 'eta w'\nderivative_order = 1\nmaterial_property_names = ' M0 cl:=D[f1,w] h'\n[../]\nEnergy of the barrier\n[./Free]\ntype = DerivativeParsedMaterial\nf_name = FF\nmaterial_property_names = 'B'\nargs='eta'\nfunction = 'Betaeta*(1-eta)*(1-eta)'\nderivative_order = 1\n[../]\nMigration coefficient.\n[./Migration_coefficient]\ntype = DerivativeParsedMaterial\nfunction = '-cl*(1-h)AAM0*(1-h)'\nargs = 'eta w'\nf_name = DN\nderivative_order = 1\nmaterial_property_names = 'M0 AA cl:=D[f1,w] h'\n[../]\n[./Bultervolmer]\ntype = DerivativeParsedMaterial\nfunction = 'Ls*(exp(potAA/2.)+14.89cl*(1-h)exp(-potAA/2.))*dh'\nargs = 'pot eta w'\nf_name = G\nderivative_order = 1\nmaterial_property_names = 'Ls dh:=D[h,eta] h cl:=D[f1,w] AA'\noutputs = exodus\n[../]\noutput the ion concentration\n[./concentration]\ntype = ParsedMaterial\nf_name = c\nargs='eta w'\nmaterial_property_names = 'h dFl:=D[f1,w]'\nfunction = '-dFl*(1-h)'\noutputs = exodus\n[../]\nEffective conductivity\n[./Le1]\ntype = DerivativeParsedMaterial\nf_name = Le1\nargs = 'eta'\nmaterial_property_names = 'S1 S2 h'\nfunction = 'S1h+S2(1-h)'\nderivative_order = 1\n[../]\n[]\n[GlobalParams]\nenable_jit = false           # Disable JIT\n[]\n[Preconditioning]\n[./SMP]\ntype = SMP\nfull = true\npetsc_options_iname = '-pc_type -ksp_grmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\npetsc_options_value = 'lu      121                  preonly       lu           8'\npetsc_options_value = 'asm      121                  preonly       lu           8'\n[../]\n[]\n[Executioner]\ntype = Transient\nscheme = bdf2\nsolve_type =Newton\nl_max_its = 50\nl_tol = 1e-4\nnl_max_its = 100\nnl_rel_tol = 1e-6\nnl_abs_tol = 1e-6\ndt= 0.001\nend_time = 400\n[TimeStepper]\ntype=IterationAdaptiveDT\noptimal_iterations = 50\niteration_window = 5\nlinear_iteration_ratio = 10\ndt = 1\n[]\n[]\n[Outputs]\nexodus = true\ncsv = true\nexecute_on = 'TIMESTEP_END'\n[./other]        # creates input_other.e output every 30 timestep\ntype = Exodus\ninterval = 30\n[../]\n[]\nInput file for WITH MECHANICS:\ninput file.\n#-------------------------------------------------------------------------\n[GlobalParams]\ndisplacements = 'disp_x disp_y'\n[]\n[Modules/TensorMechanics/Master]\n[./all]\nadd_variables = true\ngenerate_output = 'stress_xy stress_yx stress_xx stress_yy'\neigenstrain_names = 'eigenstrain'\n[../]\n[]\n#--------------------------------------------------------------------------\nDefine mesh. 2-D system, simulation size 200*200.\n[Mesh]\ntype = GeneratedMesh\ndim = 2\nnx = 200\nxmax =200\nny=200\nymax=200\n[]\nvariables. w: chemical potential, eta: order parameter, pot: applied overpotential.\n[Variables]\n[./w]\n[../]\n[./eta]\n[../]\n[./pot]\n[../]\n[]\nCreating functions for initial conditions.\n[Functions]\n[./ic_func_eta]\ntype = ParsedFunction\nvalue = 0.5*(1.0-1.0*tanh((x-20)2))\n[../]\n[./ic_func_c]\ntype = ParsedFunction\nvalue = 0\n[../]\n[./ic_func_pot]\ntype = ParsedFunction\nvalue = -0.225(1.0-tanh((x-20)*2))\n[../]\n[]\nInitial conditions.\n[ICs]\n[./eta]\nvariable = eta\ntype = FunctionIC\nfunction = ic_func_eta\n[../]\n[./w]\nvariable = w\ntype = FunctionIC\nfunction = ic_func_c\n[../]\n[./pot]\nvariable = pot\ntype = FunctionIC\nfunction = ic_func_pot\n[../]\n[]\nBoundary conditions.\n[BCs]\n#--------------------------------------------------------------------------\n[./all_y]\ntype = DirichletBC\nvariable = disp_y\nboundary = 'top bottom left right'\nvalue = 0\n[../]\n[./all_x]\ntype = DirichletBC\nvariable = disp_x\nboundary = 'top bottom left right'\nvalue = 0\n[../]\n#--------------------------------------------------------------------------\n[./bottom_eta]\ntype = NeumannBC\nvariable = 'eta'\nboundary = 'bottom'\nvalue = 0\n[../]\n[./top_eta]\ntype = NeumannBC\nvariable = 'eta'\nboundary = 'top'\nvalue = 0\n[../]\n[./left_eta]\ntype = DirichletBC\nvariable = 'eta'\nboundary = 'left'\nvalue = 1\n[../]\n[./right_eta]\ntype = DirichletBC\nvariable = 'eta'\nboundary = 'right'\nvalue = 0\n[../]\n[./bottom_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'bottom'\nvalue = 0\n[../]\n[./top_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'top'\nvalue = 0.0\n[../]\n[./left_w]\ntype = NeumannBC\nvariable = 'w'\nboundary = 'left'\nvalue = 0\n[../]\n[./right_w]\ntype = DirichletBC\nvariable = 'w'\nboundary = 'right'\nvalue = 0.0\n[../]\n[./left_pot]\ntype = DirichletBC\nvariable = 'pot'\nboundary = 'left'\nvalue = -0.45\n[../]\n[./right_pot]\ntype = DirichletBC\nvariable = 'pot'\nboundary = 'right'\nvalue = 0\n[../]\n[]\n[Kernels]\nFirst part of equation 3 in main text . chi*dw/dt\n[./w_dot]\ntype = SusceptibilityTimeDerivative\nvariable = w\nf_name = chi\nargs = 'w'\n[../]\nIntrinsic diffusion part of equation 3 in main text.\n[./Diffusion1]\ntype = MatDiffusion\nvariable=w\nD_name=D\n[../]\nMigration.\n[./Diffusion2]\ntype = Migration\nvariable = w\ncv=eta\nQ_name = 0.\nQM_name = DN\ncp=pot\n[../]\nCoupling between w and eta.\n[./coupled_etadot]\ntype = CoupledSusceptibilityTimeDerivative\nvariable = w\nv = eta\nf_name = ft\nargs = 'eta'\n[../]\nConduction, left handside of equation 4 in main text.\n[./Cond]\ntype = Conduction\nvariable = pot\ncp=eta\ncv =w\nQ_name = Le1\nQM_name=0.\n[../]\nSource term for Equation 4 in main text.\n[./coupled_pos]\ntype = CoupledSusceptibilityTimeDerivative\nvariable = pot\nv = eta\nf_name = ft2\nargs = 'eta'\n[../]\nBulter-volmer equation, right hand side of Equation 1 in main text.\n[./BV]\ntype = Kinetics\nvariable = eta\nf_name = G\ncp=pot\ncv=eta\n[../]\nDriving force from switching barrier, right hand side of Equation 1 in main text.\n[./AC_bulk]\ntype = AllenCahn\nvariable = eta\nf_name = FF\n[../]\ninterfacial energy\n[./AC_int]\ntype = ACInterface\nvariable = eta\n[../]\n[./Noiseeta]\ntype = LangevinNoise\nvariable = eta\namplitude=0.04\n[../]\ndeta/dt\n[./e_dot]\ntype = TimeDerivative\nvariable = eta\n[../]\n[]\n[Materials]\n[./constants]\ntype = GenericConstantMaterial\nkappa_op: gradient coefficient;  M0:diffucion coefficient of Li+ in electrolyte\nS1, S2 conductivity of electrode and electrolyte; L: kinetic coefficient; Ls: electrochemical kinetic coefficient; B: Barrier height;\nes, el: difference in the chemical potential of lithium and neutral components on the electrode/electrolyte phase at initial equilibrium state;\nus, ul: free energy density of the electrode/electrolyte phases. Defined in Ref. 20 and 26 of the main text; A: prefactor; AA: nF/(R*T);\ndv is the ratio of site density for the electrode/electrolyte phases; ft2: normalized used in Equation 4.\nprop_names  = 'kappa_op  M0     S1    S2     L    Ls       B   es       el    A     ul    us    AA  dv   ft2'\nprop_values = '0.3   317.9   1000000 1.19   6.25   0.001  2.4  -13.8  2.631   1.0   0.0695 13.8   38.69 5.5 0.0074'\n[../]\ngrand potential of electrolyte phase\n[./liquid_GrandPotential]\ntype = DerivativeParsedMaterial\nfunction = 'ul-A*log(1+exp((w-el)/A))'\nargs = 'w'\nf_name = f1\nmaterial_property_names = 'A ul el'\n[../]\ngrand potential of electrode phase\n[./solid_GrandPotential]\ntype = DerivativeParsedMaterial\nfunction = 'us-A*log(1+exp((w-es)/A))'\nargs = 'w'\nf_name = f2\nmaterial_property_names = 'A us es'\n[../]\n#interpolation function h\n[./switching_function]\ntype = SwitchingFunctionMaterial\neta ='eta'\nh_order = HIGH\n[../]\nBarrier function g\n[./barrier_function]\ntype = BarrierFunctionMaterial\neta = eta\n[../]\n[./total_GrandPotential]\ntype = DerivativeTwoPhaseMaterial\nargs = 'w'\neta = eta\nfa_name = f1\nfb_name = f2\nderivative_order = 2\nW = 2.4\n[../]\nCoupling between eta and w\n[./coupled_eta_function]\ntype = DerivativeParsedMaterial\nfunction = '-(csdv-cl)dh'  # in this code cs=-cs h=eta dh=1\nargs = ' w eta'\nf_name = ft\nmaterial_property_names = 'dh:=D[h,eta] h dv cs:=D[f2,w] cl:=D[f1,w]'\nderivative_order = 1\n[../]\n[./susceptibility]\ntype = DerivativeParsedMaterial\nfunction = '-d2F1(1-h)-d2F2hdv'\nargs = 'w'\nf_name = chi\nderivative_order = 1\nmaterial_property_names = 'h dv d2F1:=D[f1,w,w] d2F2:=D[f2,w,w]'\n[../]\n# Mobility defined by Dc/(RT), whereRT is normalized by the chemical potential\n# M0*(1-h) is the effective diffusion coefficient; cl*(1-h) is the ion concentration\n[./Mobility_coefficient]\ntype = DerivativeParsedMaterial\nfunction = '-M0*(1-h)cl(1-h)'  #c is -c\nf_name = D\nargs = 'eta w'\nderivative_order = 1\nmaterial_property_names = ' M0 cl:=D[f1,w] h'\n[../]\nEnergy of the barrier\n[./Free]\ntype = DerivativeParsedMaterial\nf_name = Fc\nmaterial_property_names = 'B'\nargs='eta'\nfunction = 'Betaeta*(1-eta)*(1-eta)'\nderivative_order = 1\n[../]\nMigration coefficient.\n[./Migration_coefficient]\ntype = DerivativeParsedMaterial\nfunction = '-cl*(1-h)AAM0*(1-h)'\nargs = 'eta w'\nf_name = DN\nderivative_order = 1\nmaterial_property_names = 'M0 AA cl:=D[f1,w] h'\n[../]\n[./Bultervolmer]\ntype = DerivativeParsedMaterial\nfunction = 'Ls*(exp(potAA/2.)+14.89cl*(1-h)exp(-potAA/2.))*dh'\nargs = 'pot eta w'\nf_name = G\nderivative_order = 1\nmaterial_property_names = 'Ls dh:=D[h,eta] h cl:=D[f1,w] AA'\noutputs = exodus\n[../]\noutput the ion concentration\n[./concentration]\ntype = ParsedMaterial\nf_name = c\nargs='eta w'\nmaterial_property_names = 'h dFl:=D[f1,w]'\nfunction = '-dFl*(1-h)'\noutputs = exodus\n[../]\nEffective conductivity\n[./Le1]\ntype = DerivativeParsedMaterial\nf_name = Le1\nargs = 'eta'\nmaterial_property_names = 'S1 S2 h'\nfunction = 'S1h+S2(1-h)'\nderivative_order = 1\n[../]\n#---------------------------------------------------------------------------\n[./one_minus_h_eta]\ntype = DerivativeParsedMaterial\nf_name = one_minus_h\nargs = 'eta'\nfunction = '1-h'\nmaterial_property_names = 'h'\n[../]\n[./electrode]\ntype = ComputeIsotropicElasticityTensor\nbase_name = electrode\nyoungs_modulus = 1960\npoissons_ratio = 0.36\n[../]\n[./electrolyte]\n  type = ComputeIsotropicElasticityTensor\n  base_name = electrolyte\n  youngs_modulus = 392.7\n  poissons_ratio = 0.36\n[../]\n\n[./elasticity_tensor]\ntype = CompositeElasticityTensor\nargs = 'eta'\ntensors = 'electrode   electrolyte'\nweights = 'h   one_minus_h'\n[../]\n#Added stress\n#calculate sigma(stress)\n[./stress]\ntype = ComputeLinearElasticStress\n[../]\n#Added eigen strain eta dependency\n#to calculate equation 8\n[./var_dependence]\ntype = DerivativeParsedMaterial\nf_name = var_dep\nargs = 'eta'\nfunction = eta\nderivative_order = 1\n[../]\n[./eigenstrain]\ntype = ComputeVariableEigenstrain\neigen_base = '-0.000866 -0.000773 -0.000529 0.0 0.0 0.0'\nprefactor = var_dep\nargs = 'eta'\neigenstrain_name = eigenstrain\n[../]\n#Added elastic energy block\n[./elastic_free_energy]\ntype = ElasticEnergyMaterial\nf_name = Fe\nargs = 'eta'\nderivative_order = 2\n[../]\n#Added sum of energy block\n[./sum_of_Fc_and_Fe_free_energy]\ntype = DerivativeSumMaterial\nf_name = FF\nsum_materials = 'Fc Fe'\nargs = 'eta'\nderivative_order = 2\n[../]\n[]\n#---------------------------------------------------------------------------\n[GlobalParams]\nenable_jit = false           # Disable JIT\n[]\n#------------------------------------------------------------------------\n[Postprocessors]\n[./liquid_GrandPotential]\ntype = ElementIntegralMaterialProperty\nmat_prop = f1\n[../]\n[./solid_GrandPotential]\ntype = ElementIntegralMaterialProperty\nmat_prop = f2\n[../]\n[./Free]\ntype = ElementIntegralMaterialProperty\nmat_prop = Fc\n[../]\n[./Elastic]\ntype = ElementIntegralMaterialProperty\nmat_prop = Fe\n[../]\n[./Total]\ntype = ElementIntegralMaterialProperty\nmat_prop = FF\n[../]\n[./dt]\ntype = TimestepSize\n[../]\n[./NL_iter]\ntype = NumNonlinearIterations\n[../]\n[./numDOFs]\ntype = NumDOFs\nsystem = NL\n[../]\n[]\n#-------------------------------------------------------------------------\n[Preconditioning]\n[./SMP]\ntype = SMP\nfull = true\npetsc_options_iname = '-pc_type -ksp_grmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\npetsc_options_value = 'lu      121                  preonly       lu           8'\npetsc_options_value = 'asm      121                  preonly       lu           8'\n[../]\n[]\n[Executioner]\ntype = Transient\nscheme = bdf2\nsolve_type =Newton\nl_max_its = 50\nl_tol = 1e-4\nnl_max_its = 100\nnl_rel_tol = 1e-6\nnl_abs_tol = 1e-6\ndt= 0.001\nend_time = 400\n[TimeStepper]\ntype=IterationAdaptiveDT\noptimal_iterations = 50\niteration_window = 5\nlinear_iteration_ratio = 10\ndt = 1\n[]\n[]\n[Outputs]\nexodus = true\ncsv = true\nexecute_on = 'TIMESTEP_END'\n[./other]        # creates input_other.e output every 30 timestep\ntype = Exodus\ninterval = 30\n[../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24231",
          "updatedAt": "2023-04-30T19:21:18Z",
          "publishedAt": "2023-04-30T19:16:27Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "K-Komal-98"
                  },
                  "bodyText": "Preview is not desirable. Hence, starting a new discussion.",
                  "url": "https://github.com/idaholab/moose/discussions/24231#discussioncomment-5767632",
                  "updatedAt": "2023-04-30T19:21:19Z",
                  "publishedAt": "2023-04-30T19:21:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "fictitious Boundaries",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "Is it possible to implement fictitious boundary methods in moose, and are there any examples to demonstrate how?",
          "url": "https://github.com/idaholab/moose/discussions/24211",
          "updatedAt": "2023-06-24T22:32:59Z",
          "publishedAt": "2023-04-28T04:40:11Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDo you have a link? I dont recall what that is\nWhich field is this for?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5754638",
                  "updatedAt": "2023-04-28T13:32:36Z",
                  "publishedAt": "2023-04-28T13:32:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@maxnezdyur",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5754653",
                          "updatedAt": "2023-04-28T13:33:38Z",
                          "publishedAt": "2023-04-28T13:33:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you for inquiring. Here is a paper that discusses the method.\nhttps://www.sciencedirect.com/science/article/abs/pii/S0021999100965422",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5754852",
                          "updatedAt": "2023-04-28T13:47:21Z",
                          "publishedAt": "2023-04-28T13:47:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yes, @maxnezdyur is developing a MOOSE-based app for that.",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5759384",
                          "updatedAt": "2023-04-29T00:52:44Z",
                          "publishedAt": "2023-04-29T00:52:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Will it be made available for beta testers, in particular me? Is there an existing preliminary framework for simple 1D models?",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5759425",
                          "updatedAt": "2023-04-29T01:11:35Z",
                          "publishedAt": "2023-04-29T01:11:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "It's still a work in progress, with a few kinks that need to be taken care of. I want to make it public at the end of the summer. The app is more of an embedded boundary method than the fictitious method you linked, but it should still be helpful, depending on what you are trying to do.",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5761910",
                          "updatedAt": "2023-04-29T14:18:13Z",
                          "publishedAt": "2023-04-29T14:18:13Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "It appears from what you @maxnezdyur are describing, is that implementing FBM can not be easily applied by using existing apps and moose interfaces. An app and custom code has to be created to accomplish it.",
                          "url": "https://github.com/idaholab/moose/discussions/24211#discussioncomment-5763583",
                          "updatedAt": "2023-04-29T20:56:43Z",
                          "publishedAt": "2023-04-29T20:56:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Changing AD material property variable to regular variable",
          "author": {
            "login": "steam-simulator"
          },
          "bodyText": "Hello,\nI\u2019m retrieving an ADmaterial property, but I want to strip the AD from it and convert it to a regular property before using it in my code. How do I do this? I tried using the .value() function but got this error:\nerror: 'const class ADMaterialProperty<RankTwoTensorTempl<double> >' has no member named 'value'; did you mean '_value'?\n 132 |         RankTwoTensor _stress = (_stress_o).value();\n     |                                             ^~~~~\n     |                                             _value\n/home/jay/MOOSE/projects/creep/src/materials/perm.C:133:16: error: no match for 'operator[]' (operand types are 'RankTwoTensor' {aka 'RankTwoTensorTempl<double>'} and 'unsigned int')\n 133 |         _stress[_qp].symmetricEigenvaluesEigenvectors(eigvals, eigvec);\n     |                ^\nIn file included from /home/jay/MOOSE/projects/creep/build/unity_src/materials_Unity.C:4:\n/home/jay/MOOSE/projects/creep/src/materials/perm2.C: In member function 'void perm2Templ<is_ad>::computeQpProperties()':\n/home/jay/MOOSE/projects/creep/src/materials/perm2.C:93:9: error: '_stress' was not declared in this scope; did you mean '_stress_o'?\n  93 |         _stress[_qp].symmetricEigenvaluesEigenvectors(eigvals, eigvec);\n\nI have the following in my header and source:\nconst ADMaterialProperty<RankTwoTensor>& _stress;\n_stress_o(getADMaterialProperty<RankTwoTensor>(_base_name + \"stress\")),\nMy code:\nRankTwoTensor _stress[_qp] = (_stress_o[_qp]).value();\nDo I need to include any special type of header? Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/24215",
          "updatedAt": "2023-04-29T17:58:19Z",
          "publishedAt": "2023-04-28T16:05:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "this should be fine\n(_stress_o[_qp]).value()\nbut\n(_stress_o).value(); is not, you need to index to get the ADReal before stripping the derivative.\nNote that there is already a converter between AD and non AD:\nhttps://mooseframework.inl.gov/source/materials/MaterialADConverter.html",
                  "url": "https://github.com/idaholab/moose/discussions/24215#discussioncomment-5756366",
                  "updatedAt": "2023-04-28T16:09:29Z",
                  "publishedAt": "2023-04-28T16:09:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "or raw_value(_stress_o[_qp])",
                          "url": "https://github.com/idaholab/moose/discussions/24215#discussioncomment-5759346",
                          "updatedAt": "2023-04-29T00:39:45Z",
                          "publishedAt": "2023-04-29T00:39:44Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "steam-simulator"
                          },
                          "bodyText": "Thank you very much, @hugary1995 and @GiudGiud , for the recommendations. In this case, raw_value(_stress_o[_qp]) works best!",
                          "url": "https://github.com/idaholab/moose/discussions/24215#discussioncomment-5762971",
                          "updatedAt": "2023-04-29T17:57:37Z",
                          "publishedAt": "2023-04-29T17:57:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can I solve these coupled differential equations in MOOSE without creating a custom kernel?",
          "author": {
            "login": "K-Komal-98"
          },
          "bodyText": "I have solved a single second order differential equation using the ADMatdiffusion and Reaction kernel. Can you assist me on how to solve this problem with the existing moose kernels?",
          "url": "https://github.com/idaholab/moose/discussions/24059",
          "updatedAt": "2023-04-29T09:21:24Z",
          "publishedAt": "2023-04-13T07:28:03Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe BCs are Dirichlet and Neumann, you can use off-the-shelf MOOSE BCs for this.\nYou ll want to write a new kernels (start from ADCoupledForce) for the u^2, v^2 and u^2 v^2 terms.\nThe second order space derivatives you can use a Diffusion kernel for the one that is in its own equation.\nFor the other one you ll need to create a coupledDiffusion kernel, that has a \"variable\" argument that is different than the variable that gets the second derivative taken from.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24059#discussioncomment-5603609",
                  "updatedAt": "2023-04-13T12:06:41Z",
                  "publishedAt": "2023-04-13T12:06:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "K-Komal-98"
                  },
                  "bodyText": "Can I use ADMatDiffusion kernel for the second order space derivatives. I have written a simple code for a problem attached here. Can you please guide me if this is a correct usage or not?\n\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    nx = 60 \n    xmax = 30\n[]\n[Variables]\n    [u]\n    []\n    [v]\n    []\n[]\n\n[Kernels]\n  [1_diff_u]\n    type = ADMatDiffusion\n    diffusivity = 1\n    variable = u\n  []\n  [1_diff_v]\n    type = ADMatDiffusion\n    diffusivity = 2\n    variable = u\n    v = v\n  []\n  [2_diff_u]\n    type = ADMatDiffusion\n    diffusivity = 3\n    variable = v\n    v = u\n  []\n  [2_diff_v]\n    type = ADMatDiffusion\n    diffusivity = 4\n    variable = v\n  []\n[]\n\n[BCs]\n  [left_u]\n    type = DirichletBC\n    variable = u\n    boundary = left\n    value = 0\n  []\n  [right_u]\n    type = DirichletBC\n    variable = u\n    boundary = right\n    value = 10\n  []\n  [left_v]\n    type = DirichletBC\n    variable = v\n    boundary = left\n    value = 0\n  []\n  [right_v]\n    type = DirichletBC\n    variable = v\n    boundary = right\n    value = 10\n  []\n[]\n[Executioner]\n     type = Steady\n     nl_max_its = 100\n     solve_type = Newton\n[]\n[VectorPostprocessors]\n  [u]\n    type = NodalValueSampler\n    sort_by = id\n    variable = u\n  []\n  [v]\n    type = NodalValueSampler\n    sort_by = id\n    variable = v\n  []\n[]\n[Outputs]\n  [out]\n    type = CSV\n    execute_on = final\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/24059#discussioncomment-5661761",
                  "updatedAt": "2023-04-19T14:59:31Z",
                  "publishedAt": "2023-04-19T14:10:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes this seems fine actually",
                          "url": "https://github.com/idaholab/moose/discussions/24059#discussioncomment-5662274",
                          "updatedAt": "2023-04-19T14:53:54Z",
                          "publishedAt": "2023-04-19T14:53:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "K-Komal-98"
                  },
                  "bodyText": "Thank you",
                  "url": "https://github.com/idaholab/moose/discussions/24059#discussioncomment-5760776",
                  "updatedAt": "2023-04-29T09:21:25Z",
                  "publishedAt": "2023-04-29T09:21:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "a libMesh error in ThreadedElementLoopBase",
          "author": {
            "login": "DYLDYLDYL"
          },
          "bodyText": "Hello\nI'd like to ask you about my \"Solve Did NOT Converge!\" My dt = 10day.\nTime Step 8, time = 6.912e+06, dt = 864000\n 0 Nonlinear |R| = 5.542185e-01\n      0 Linear |R| = 5.542185e-01\n     \u2026\u2026\n      9 Linear |R| = 1.099421e-06\n  Elem Information\n   id()=31, unique_id()=11306, processor_id()=0\n   type()=HEX8\n   dim()=3\n   n_nodes()=8\n   mapping=LAGRANGE_MAP\n    0  Node id()=78, processor_id()=0, Point=(x,y,z)=(0.00347698, 0.000283549, 0.0251831)\n    DoFs=(0/0/312) (0/1/313) (0/2/314) (0/3/315) (1/0/156) (1/1/157) \n    1  Node id()=76, processor_id()=0, Point=(x,y,z)=(0.00340455, 0.00028917, 0.0251833)\n    DoFs=(0/0/304) (0/1/305) (0/2/306) (0/3/307) (1/0/152) (1/1/153) \n   \u2026\u2026\nWe caught a libMesh error in ThreadedElementLoopBase\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n Solve Did NOT Converge!\n\nThanks in advance for your help!",
          "url": "https://github.com/idaholab/moose/discussions/23714",
          "updatedAt": "2023-06-24T22:32:15Z",
          "publishedAt": "2023-03-14T12:00:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSorry we missed this.\nThere's not enough information there, we would need your input file, mesh and what you used to run this\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23714#discussioncomment-5759721",
                  "updatedAt": "2023-04-29T03:12:31Z",
                  "publishedAt": "2023-04-29T03:12:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Modifying BCs",
          "author": {
            "login": "mjyang123"
          },
          "bodyText": "Hi! I am new to Moose, and new to C++ coding. I have this code snippet that describes the boundary condition of a plate, how do I change them so it fits this new image I have attached? I want to try different boundary conditions where my edges are fixed, free, and semi-fixed? How do I modify the codes? The code right now is for free edges. Thank you!\n\n\nThe entire code is:\nE = 2.1e5\nnu = 0.3\nK = '${fparse E/3/(1-2*nu)}'\nG = '${fparse E/2/(1+nu)}'\n\nGc = 2.7\nl = 0.02\n\n[MultiApps]\n  [fracture]\n    type = TransientMultiApp\n    input_files = fracture.i\n    cli_args = 'Gc=${Gc};l=${l}'\n    execute_on = 'TIMESTEP_END'\n  []\n[]\n\n[Transfers]\n  [from_d]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = from_multiapp\n    variable = d\n    source_variable = d\n  []\n  [to_psie_active]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = to_multiapp\n    variable = psie_active\n    source_variable = psie_active\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 30\n    ny = 15\n    ymax = 0.5\n  []\n  [noncrack]\n    type = BoundingBoxNodeSetGenerator\n    input = gen\n    new_boundary = noncrack\n    bottom_left = '0.5 0 0'\n    top_right = '1 0 0'\n  []\n  construct_side_list_from_node_list = true\n[]\n\n[Adaptivity]\n  marker = marker\n  initial_marker = marker\n  initial_steps = 2\n  stop_time = 0\n  max_h_level = 2\n  [Markers]\n    [marker]\n      type = BoxMarker\n      bottom_left = '0.4 0 0'\n      top_right = '1 0.05 0'\n      outside = DO_NOTHING\n      inside = REFINE\n    []\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n[]\n\n[AuxVariables]\n  [fy]\n  []\n  [d]\n  []\n[]\n\n[Kernels]\n  [solid_x]\n    type = ADStressDivergenceTensors\n    variable = disp_x\n    component = 0\n  []\n  [solid_y]\n    type = ADStressDivergenceTensors\n    variable = disp_y\n    component = 1\n    save_in = fy\n  []\n[]\n\n[BCs]\n  [ydisp]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = top\n    function = 't'\n  []\n  [yfix]\n    type = DirichletBC\n    variable = disp_y\n    boundary = noncrack\n    value = 0\n  []\n  [xfix]\n    type = DirichletBC\n    variable = disp_x\n    boundary = top\n    value = 0\n  []\n[]\n\n[Materials]\n  [bulk]\n    type = ADGenericConstantMaterial\n    prop_names = 'K G'\n    prop_values = '${K} ${G}'\n  []\n  [degradation]\n    type = PowerDegradationFunction\n    f_name = g\n    function = (1-d)^p*(1-eta)+eta\n    phase_field = d\n    parameter_names = 'p eta '\n    parameter_values = '2 1e-6'\n  []\n  [strain]\n    type = ADComputeSmallStrain\n  []\n  [elasticity]\n    type = SmallDeformationIsotropicElasticity\n    bulk_modulus = K\n    shear_modulus = G\n    phase_field = d\n    degradation_function = g\n    decomposition = NONE\n    output_properties = 'elastic_strain psie_active'\n    outputs = exodus\n  []\n  [stress]\n    type = ComputeSmallDeformationStress\n    elasticity_model = elasticity\n    output_properties = 'stress'\n    outputs = exodus\n  []\n[]\n\n[Postprocessors]\n  [Fy]\n    type = NodalSum\n    variable = fy\n    boundary = top\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu       superlu_dist                 '\n  automatic_scaling = true\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-10\n\n  dt = 2e-5\n  end_time = 3.5e-3\n\n  fixed_point_max_its = 20\n  accept_on_max_fixed_point_iteration = true\n  fixed_point_rel_tol = 1e-8\n  fixed_point_abs_tol = 1e-10\n[]\n\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23882",
          "updatedAt": "2023-04-29T03:03:33Z",
          "publishedAt": "2023-03-29T12:18:50Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "There should be a tutorial for mode II fracture...",
                  "url": "https://github.com/idaholab/moose/discussions/23882#discussioncomment-5465480",
                  "updatedAt": "2023-03-29T12:40:17Z",
                  "publishedAt": "2023-03-29T12:40:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mjyang123"
                          },
                          "bodyText": "If I want to make the top half fixed, do I modify the code to this:\n[BCs]\n  [xdisp]\n    type = FunctionDirichletBC\n    variable = 'disp_x'\n    boundary = 'top_half_top'\n    value = 0\n  []\n\nJust like the bottom half. Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/23882#discussioncomment-5465810",
                          "updatedAt": "2023-03-29T13:17:28Z",
                          "publishedAt": "2023-03-29T13:17:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}