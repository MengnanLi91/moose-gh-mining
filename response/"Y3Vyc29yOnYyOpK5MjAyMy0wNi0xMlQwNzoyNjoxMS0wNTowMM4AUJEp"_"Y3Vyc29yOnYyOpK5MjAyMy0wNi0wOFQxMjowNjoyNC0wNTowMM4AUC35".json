{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNi0wOFQxMjowNjoyNC0wNTowMM4AUC35"
    },
    "edges": [
      {
        "node": {
          "title": "Question about Adaptivity block setting in MOOSE",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nI was confused about the setting of adaptivity block in MOOSE. In the figure shown below, what does the coarsen factor mean? Does it mean, divided by 0.1 each time?\nSo, for example, if the original grid size is 0.2, then, for this adaptivity block setting, the coarsen factor can be applied for 3 times (because max_h_level is 3), and each time is divided by 0.1? So first time is 0.2/0.1=2, second time is 2/0.1=20, third time is 20/0.1=200. Therefore, the maximum possible grid size we can get is 200? Am I understanding correctly?\n\nThank you very much,\nBest,",
          "url": "https://github.com/idaholab/moose/discussions/24657",
          "updatedAt": "2023-06-24T22:48:42Z",
          "publishedAt": "2023-06-11T03:51:20Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis parameter is forwarded to a libmesh class for mesh refinement\nhttps://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1MeshRefinement.html#ac65900f46067a75f67814fc91ef05d4b\nIt means the fraction of elements to refine.\nSee the class documentation:\nThis method picks the top refine_fraction * n_elem elements for refinement and the bottom coarsen_fraction * n_elem elements for coarsening.\nRefinement is not done in arbitrary increments. A quad or a tri is split in 4 in each step at most. A hex is split in 8 hexes. We dont have any other divisions available (except from refining multiple times)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24657#discussioncomment-6142717",
                  "updatedAt": "2023-06-11T04:03:00Z",
                  "publishedAt": "2023-06-11T04:02:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abc-hy"
                  },
                  "bodyText": "So, you mean that the grid size can only be decreased/refined, it cannot be\nincreased? So the maximum grid size is the original grid size you set, am i\nright?\n\u2026\nOn Sat, Jun 10, 2023 at 11:03 PM Guillaume Giudicelli < ***@***.***> wrote:\n Hello\n\n This parameter is forwarded to a libmesh class for mesh refinement\n\n https://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1MeshRefinement.html#ac65900f46067a75f67814fc91ef05d4b\n\n It means the fraction of elements to refine.\n See the class documentation:\n This method picks the top refine_fraction * n_elem elements for refinement\n and the bottom coarsen_fraction * n_elem elements for coarsening.\n\n Refinement is not done in arbitrary increments. A quad or a tri is split\n in 4 in each step at most. A hex is split in 8 hexes. We dont have any\n other divisions available (except from refining multiple times)\n\n Guillaume\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24657 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/APF2ZCQNLB6KDEIDESFHGW3XKU7P5ANCNFSM6AAAAAAZCCG4LQ>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24657#discussioncomment-6142801",
                  "updatedAt": "2023-06-11T04:45:06Z",
                  "publishedAt": "2023-06-11T04:45:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We can only undo refinement to increase. So you have to start with a mesh as coarse as you ll ever want it to be.",
                          "url": "https://github.com/idaholab/moose/discussions/24657#discussioncomment-6142826",
                          "updatedAt": "2023-06-11T04:55:36Z",
                          "publishedAt": "2023-06-11T04:55:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abc-hy"
                  },
                  "bodyText": "Actually, i wanted to calculate the uncertainty of the model. So i need the\nmaximum possible discretization of x......\nSo the grid size will be divided by the coarsen factor to increase, is that\ncorrect?\n\u2026\nOn Sat, Jun 10, 2023 at 11:55 PM Guillaume Giudicelli < ***@***.***> wrote:\n We can only undo refinement to increase. So you have to start with a mesh\n as you ll ever want it to be.\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24657 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/APF2ZCSBK3TIMCUECGBWEYTXKVFUBANCNFSM6AAAAAAZCCG4LQ>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24657#discussioncomment-6144182",
                  "updatedAt": "2023-06-11T11:56:16Z",
                  "publishedAt": "2023-06-11T11:56:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No it's not correct.\nThe grid size will be divided by 4 (assuming quads) on every step of refinement, at the elements chosen for refinement (depending on the refine_fraction)",
                          "url": "https://github.com/idaholab/moose/discussions/24657#discussioncomment-6144515",
                          "updatedAt": "2023-06-11T13:16:22Z",
                          "publishedAt": "2023-06-11T13:16:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abc-hy"
                  },
                  "bodyText": "SO, grid size will not be increased? What's the use of coarsen_factor?\n\u2026\nOn Sun, Jun 11, 2023 at 8:16\u202fAM Guillaume Giudicelli < ***@***.***> wrote:\n No it's not correct.\n The grid size will be divided by 4 (assuming quads) on every step of\n refinement, at the elements chosen for refinement (depending on the\n refine_fraction)\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24657 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/APF2ZCT7QPWV76IFBYVPAYDXKXAK7ANCNFSM6AAAAAAZCCG4LQ>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24657#discussioncomment-6144652",
                  "updatedAt": "2023-06-11T13:49:06Z",
                  "publishedAt": "2023-06-11T13:49:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abc-hy"
                  },
                  "bodyText": "If grid size cannot be increased, why do we need coarsen factor there?\n\nOn Sun, Jun 11, 2023 at 8:48\u202fAM Haiying Yang ***@***.***>\nwrote:\n\u2026\n SO, grid size will not be increased? What's the use of coarsen_factor?\n\n On Sun, Jun 11, 2023 at 8:16\u202fAM Guillaume Giudicelli <\n ***@***.***> wrote:\n\n> No it's not correct.\n> The grid size will be divided by 4 (assuming quads) on every step of\n> refinement, at the elements chosen for refinement (depending on the\n> refine_fraction)\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <#24657 (reply in thread)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/APF2ZCT7QPWV76IFBYVPAYDXKXAK7ANCNFSM6AAAAAAZCCG4LQ>\n> .\n> You are receiving this because you authored the thread.Message ID:\n> ***@***.***>\n>",
                  "url": "https://github.com/idaholab/moose/discussions/24657#discussioncomment-6144660",
                  "updatedAt": "2023-06-11T13:50:41Z",
                  "publishedAt": "2023-06-11T13:50:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Coarsening is used to undo levels of refinement.\nYou should just try it out on a square problem with dummy variables to see what it does",
                          "url": "https://github.com/idaholab/moose/discussions/24657#discussioncomment-6144698",
                          "updatedAt": "2023-06-11T14:00:13Z",
                          "publishedAt": "2023-06-11T14:00:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "What is the best way to constrain the composition while using CALPHAD type free energy ?",
          "author": {
            "login": "KamalnathOSU"
          },
          "bodyText": "Hi all,\nWhile using CALPHAD free energy in the phase-field governing equations, we don't want the composition to approach 0 or 1 due to the presence of log(c) and log(1-c) terms. From the documentation, it looks like damper system is my best bet. But I have some doubts on it.\n\nI could not decide between BoundingValueElementDamper and BoundingValueNodalDamper. Both of them seem to operate on quadrature points. In what way they are different ?\nHow to decide the value of \"min_damping\" in this case. Is there any general guidance.\nIs there any phase-field examples file which uses damping system ?\n\nP.S: I know that using \"plog\" in the analytical expression of free energy is an alternative but in my case, I cant change the free energy expression.",
          "url": "https://github.com/idaholab/moose/discussions/24629",
          "updatedAt": "2023-06-12T16:22:32Z",
          "publishedAt": "2023-06-08T14:57:57Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI would stick to NodalDamper for a nodal variable (lagrange for example) and element damper for an elemental variable (monomial for example)\nThe type of the damper will determine if the damping factor is computed only once (nodal) or on every qp (element)\nThe of the auxiliary variable for the damper will determine how the auxiliary kernel is executed. Make sure to use the same variable type as c\nAnother option btw is to use the Bounds system\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24629#discussioncomment-6126031",
                  "updatedAt": "2023-06-08T19:41:03Z",
                  "publishedAt": "2023-06-08T19:41:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GuoChi-Li"
                  },
                  "bodyText": "Hello\nIn my simulation, I also have log(c) and log(1-c) terms in my free energy function, which will cause NaN while solving the problem. Therefore, I use [Bounds] to fix it.\nA sample code would be\n[AuxVariables]\n  [./bounds_dummy]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n[Bounds]\n  [./c_upper_bound]\n    type = ConstantBoundsAux\n    variable = bounds_dummy\n    bounded_variable = c\n    bound_type = upper\n    bound_value = 1\n  [../]\n\n  [./c_lower_bound]\n    type = ConstantBoundsAux\n    variable = bounds_dummy\n    bounded_variable = c\n    bound_type = lower\n    bound_value = 0\n  [../]\n\nI actually asked a similar question relating to your question. Here is the link.",
                  "url": "https://github.com/idaholab/moose/discussions/24629#discussioncomment-6142365",
                  "updatedAt": "2023-06-11T01:35:48Z",
                  "publishedAt": "2023-06-11T01:34:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "KamalnathOSU"
                  },
                  "bodyText": "Thank you @GuoChi-Li . I will try that.",
                  "url": "https://github.com/idaholab/moose/discussions/24629#discussioncomment-6142371",
                  "updatedAt": "2023-06-11T01:36:46Z",
                  "publishedAt": "2023-06-11T01:36:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Postprocessor to get coordinates from node id",
          "author": {
            "login": "lyyc199586"
          },
          "bodyText": "Hi all,\nIs there happen to be a postprocessor that can get coordinates form the node id? For example, I can use NodalMaxValueId to get the node id I want, is there a way to output the coords of this node?",
          "url": "https://github.com/idaholab/moose/discussions/24655",
          "updatedAt": "2023-06-24T22:49:01Z",
          "publishedAt": "2023-06-10T17:36:50Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou can use paraview with min/max filters on the node id field to locate that particular node.\nDo you only have one node you care about?\nyou could make a new Positions object and this will output the location of the node that this object selects to JSON\nhttps://mooseframework.inl.gov/syntax/Positions/index.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24655#discussioncomment-6141530",
                  "updatedAt": "2023-06-10T20:05:53Z",
                  "publishedAt": "2023-06-10T20:05:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "I actually want to find a way to track the position of the crack tip in phase field and calculate the velocity in MOOSE. I know I can do it with python and/or paraview, but Positions object might be working for me",
                          "url": "https://github.com/idaholab/moose/discussions/24655#discussioncomment-6141728",
                          "updatedAt": "2023-06-10T22:42:27Z",
                          "publishedAt": "2023-06-10T21:08:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You may want to take look at this paper: https://onlinelibrary.wiley.com/doi/epdf/10.1002/nme.6879\nIf you want to pursue this I can get their source code for you.\nBack to your original question, I think postprocessing the results externally probably is the right way to go, as it's more complicated than just tracking the coordinates of the nodes with phase-field == 1 even if the crack does not branch, unless you know the crack path a priori.",
                          "url": "https://github.com/idaholab/moose/discussions/24655#discussioncomment-6142073",
                          "updatedAt": "2023-06-10T23:11:43Z",
                          "publishedAt": "2023-06-10T23:11:42Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "I and Andre noticed this paper, and he wrote some python code on it.\nI understand that if we want to track random unknown crack tips (like branching, etc), it  will be better to do it externally.  Here I am just trying to track crack tips for very simple cases, e.g. single crack. here is my workaround:\n\nusing a ParsedAux to calculate a distance field to the initial crack tip, say (0, 0): if(d>d_cr, sqrt(x^2+y^2, -100), so that only x(d>d_cr) has a positive distance.\nuse NodalMaxValueId to get id of the node has largest distance\nwrite a PP (like called NodalPosition..) similar to NodalVaribleValue, but just output the coordinates of this node.\n\nI think this at least will work for single crack, enough for me to do some simple tests.\nBut yea, I agree we should move to an external solution finally, if you have their code about that paper that will be so nice!",
                          "url": "https://github.com/idaholab/moose/discussions/24655#discussioncomment-6142130",
                          "updatedAt": "2023-06-10T23:29:51Z",
                          "publishedAt": "2023-06-10T23:29:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Nonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0",
          "author": {
            "login": "jin0123456"
          },
          "bodyText": "Hello, I have a converge error like this:\nsub0: Time Step 2, time = 864000, dt = 864000\nsub0: \nsub0:   Rebuilding Geometric Search Patchessub0: \nsub0:     Reinitializing Because of Geometric Search Objects.                            [ 21.35 s] [ 3055 MB]\nsub0:   Finished Rebuilding Geometric Search Patches                                     [ 21.42 s] [ 3055 MB]\nsub0:  0 Nonlinear |R| = 4.042263e+06\nsub0:   Computing Jacobian                                                               [ 10.95 s] [ 3178 MB]\nsub0:       0 Linear |R| = 4.042263e+06\nsub0:       1 Linear |R| = 4.952770e+02\nExceeded maximum iterations in material return mapping iterations.\nAt element 259184 _qp=3 Coordinates (x,y,z)=(0.00420409,  3.48758,        0) block=8887\nIn 1000 iterations the residual went from 0.000104186 to 0.000104186 in 'CZ_power_law_creep'.\n\nsub0: \nsub0: A MooseException was raised during Auxiliary variable computation.\nsub0: The next solve will fail, the timestep will be reduced, and we will try again.\nsub0: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub0: Finished Solving                                                                   [ 66.05 s] [ 3188 MB]\nsub0:  Solve Did NOT Converge!\nsub0: Aborting as solve did not converge \n\nI changed the form of creep in the Power Law Creep Stress Update as a function.The time step 2 here is the first time step of the tensor mechanics calculation. I used to shorten my steps to 1s but nothing changed. I hope someone could help me solve the problem.Thanks!",
          "url": "https://github.com/idaholab/moose/discussions/24628",
          "updatedAt": "2023-06-24T22:49:15Z",
          "publishedAt": "2023-06-08T09:43:03Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe ll probably need the full input file to look at this.\nDid step 1 converge well?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24628#discussioncomment-6126091",
                  "updatedAt": "2023-06-08T19:46:53Z",
                  "publishedAt": "2023-06-08T19:46:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "Here is the full input file for Tensor Mechanics:\ninit_temp = 565.75 # K\ninit_pressure = 6e6 # Pa\nouter_pressure = 15.5e6\nrad_fuel = 4.096e-3 # m\n[Mesh]\n  type = FileMesh\n  file = geometry/cz_no_butterfly.e\n  coord_type = RZ\n\n  patch_update_strategy = iteration\n[]\n\n[GlobalParams]\n  displacements = 'disp_r disp_z'\n[]\n\n[AuxVariables]\n  [temp]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = ${init_temp}\n  []\n\n  [burnup_per]\n    order = FIRST\n    family = MONOMIAL\n  []\n\n  [porosity]\n    order = FIRST\n    family = MONOMIAL\n  []\n\n## gas release auxkernel\n  [input_material]\n     order = FIRST\n     family = MONOMIAL\n  []\n  [q_v]\n    order = FIRST\n    family = MONOMIAL\n  []\n  [fission_rate]\n    order = FIRST\n    family = MONOMIAL\n  []\n\n  # creep_strain\n  [creep_strain_xx]\n    order = CONSTANT\n    family = MONOMIAL\n  [] \n  [creep_strain_yy]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [creep_strain_xy]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [creep_strain_zz]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[AuxKernels]\n  [burnup_per_aux]\n   type = BurnupPerAux\n   block = 'fuel'\n   q_vol = q_v_fun\n   variable = burnup_per\n  []\n\n  [porosity]\n    type = ParsedAux\n    expression = 0.05\n    variable = porosity\n    block = 'fuel'\n  []\n## gas release auxkernel\n  [gas_release_aux]\n    type = GasReleaseAux\n    burnup = burnup_per\n    q_max = q_max\n    vol_fission = vol_fission\n    TD = 95\n    rad_fuel = ${rad_fuel}\n    variable = input_material\n  []\n  [q_v_aux]\n    type = FunctionAux\n    function = q_v_fun\n    variable = q_v\n  []\n  [fission_rate_aux]\n    type = ParsedAux\n    variable = fission_rate\n    coupled_variables = 'q_v'\n    expression = 'q_v / 3.28451e-11' # 3.28451e-11 is once fission release energy\n  []\n\n  # creep strain\n  #[creep_strain_xx]\n    #type = RankTwoAux\n    #variable = creep_strain_xx\n    #index_i = 0\n    #index_j = 0\n    #rank_two_tensor = creep_strain\n    #block = 'clad'\n  #[]\n  #[creep_strain_yy]\n    #type = RankTwoAux\n    #variable = creep_strain_yy\n    #index_i = 1\n    #index_j = 1\n    #rank_two_tensor = creep_strain\n    #block = 'clad'\n  #[]\n  #[creep_strain_xy]\n    #type = RankTwoAux\n    #variable = creep_strain_xy\n    #index_i = 1\n    #index_j = 0\n    #rank_two_tensor = creep_strain\n    #block = 'clad'\n  #[]\n  #[creep_strain_zz]\n    #type = RankTwoAux\n    #variable = creep_strain_zz\n    #index_i = 2\n    #index_j = 2\n    #rank_two_tensor = creep_strain\n    #block = 'clad'\n  #[]\n[]\n\n[Contact]\n  #active = gap_contact\n  [gap_contact]\n    primary = 'clad_inside'\n    secondary = 'fuel_outer'\n    model = frictionless # \n    penalty = 5e3\n    formulation = penalty\n    tangential_tolerance = 1e-6\n    normal_smoothing_distance = 1e-6\n  []\n  [element]\n    primary = 'element_down'\n    secondary = 'element_top'\n    model = glued\n    penalty = 1e9\n    normalize_penalty = true\n    tangential_tolerance = 1e-3\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  incremental = true\n  [fuel]\n    strain = FINITE\n    add_variables = true\n    eigenstrain_names = 'thermal_expansion_eigenstrain'\n    generate_output = ' stress_zz vonmises_stress'\n    block = 'fuel'\n  []\n  [clad]\n    strain = FINITE\n    add_variables = true\n    eigenstrain_names = 'thermal_expansion_eigenstrain'\n    generate_output = ' stress_zz vonmises_stress'\n    block = 'clad'\n  []\n[]\n\n[Materials]\n  inactive = 'UO2_radial_return_stress UO2_power_law_creep UO2_solid_swelling UO2_gas_swelling'\n  [UO2_density]\n    type = UO2Density\n    temperature = temp\n    block = 'fuel'\n  []\n  [CZ_density]\n    type = CZDensity\n    temperature = temp\n    block = 'clad'\n  []\n  [UO2_elasticity_tensor]\n    type = ComputeVariableIsotropicElasticityTensor\n    args = temp\n    youngs_modulus = youngs_modulus\n    poissons_ratio = poissons_ratio\n    block = 'fuel'\n  []\n  [UO2_elasticity_material]\n    type = UO2ElasticityMaterial\n    temperature = temp\n    density_per = 95\n    block = 'fuel'\n  []\n  [CZ_elasticity_tensor]\n    type = ComputeVariableIsotropicElasticityTensor\n    args = temp\n    youngs_modulus = youngs_modulus\n    poissons_ratio = poissons_ratio\n    block = 'clad'\n  []\n  [CZ_elasticity_material]\n    type = CZElasticityMaterial\n    temperature = temp\n    block = 'clad'\n  []\n  \n  [UO2_thermal_expansion]\n    type = ComputeUO2InstantaneousThermalExpansionEigenstrain\n    stress_free_temperature = 293.\n    temperature = temp\n    eigenstrain_name = thermal_expansion_eigenstrain\n    block = 'fuel'\n  []\n  [UO2_radial_return_stress]\n    type = ComputeMultipleInelasticStress\n    inelastic_models = 'UO2_power_law_creep'\n    tangent_operator = elastic\n    block = 'fuel'\n  []\n  [UO2_power_law_creep]\n    type = UO2CreepStressUpdate\n    temperature = temp\n    fission_rate = fission_rate\n    q_v_fun = q_v_fun\n    density_percent = 95\n    block = 'fuel'\n  []\n  [UO2_solid_swelling]\n    type = ComputeInstantaneousSolidSwellingEigenstrain\n    burnup = burnup_per\n    eigenstrain_name = solid_swelling_eigenstrain\n    block = 'fuel'\n  []\n  [UO2_gas_swelling]\n    type = ComputeInstantaneousGasSwellingEigenstrain\n    burnup = burnup_per\n    temperature = temp\n    eigenstrain_name = gas_swelling_eigenstrain\n    block = 'fuel'\n  []\n  \n  [CZ_thermal_expansion]\n    type = ComputeCZThermalExpansionEigenstrain\n    stress_free_temperature = 293.\n    temperature = temp\n    eigenstrain_name = thermal_expansion_eigenstrain\n    block = 'clad'\n  []\n  [CZ_radial_return_stress]\n    type = ComputeMultipleInelasticStress\n    inelastic_models = 'CZ_power_law_creep'\n    tangent_operator = elastic\n    block = 'clad'\n    internal_solve_full_iteration_history = true\n  []\n  [CZ_power_law_creep]\n    #type = CZPowerLawCreepStressUpdate\n    type = Zr4CreepStressUpdate\n    temperature = temp\n    max_inelastic_increment = 0.01\n    neu_flux_function = neu_flux_fun\n    block = 'clad'\n    absolute_tolerance = 1e-5\n    relative_tolerance = 1e-5\n  []\n  [small_stress]\n    type = ComputeFiniteStrainElasticStress\n    block = 'fuel'\n  []\n[]\n\n[BCs]\n  active = 'inside coolant_pressure pellet_bottom_disp_z'\n\n  [coolant_pressure]\n    type = Pressure\n    function = ${outer_pressure}\n    boundary = outer\n    variable = disp_r\n  []\n  [inside]\n    type = Pressure\n    factor = ${init_pressure}\n    boundary = 'clad_inside fuel_outer'\n    variable = disp_r\n  []\n\n  [CavityPressure]\n    [cavity_pressure]\n      boundary = 'fuel_outer clad_inside plenum_top pin_top pin_bottom'\n      initial_temperature = ${init_temp}\n      temperature = ave_temp_clad_inside_top# use clad top temperature as average temperature\n      material_input = inputmaterial \n      volume = volume_tol\n      initial_pressure = ${init_pressure} \n      R = 8.314472\n      output = ppress\n    []\n  []\n\n  [pellet_bottom_disp_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'pin_bottom'\n    value = 0.0\n    preset = true\n  []\n  [pellet_bottom_disp_r]\n    type = DirichletBC\n    variable = disp_r\n    boundary = 'pin_bottom'\n    value = 0.0\n    preset = true\n  []\n[]\n\n[Functions]\n  [q_v_fun]\n    type = PiecewiseMulticonstant\n    data_file = ./power/A-A17.txt\n    direction = 'left left'\n  []\n  [neu_flux_fun]\n    type = PiecewiseConstant\n    data_file = ./neu_flux/A-A17.txt\n    format = rows\n  []\n[]\n\n[Postprocessors]\n## gas release postprocessors\n  [q_max] ## get the mox volume power\n    type = ElementExtremeValue\n    variable = q_v\n    value_type = max\n  []\n  [vol_fission] ## get the volume fission unit[fission/s]\n    type = ElementIntegralVariablePostprocessor\n    variable = fission_rate\n    block = 'fuel'\n  []\n  [inputmaterial]\n    type = ElementAverageValue\n    variable = input_material\n    block = fuel\n    execute_on = 'timestep_end'\n  []\n  [ave_temp_clad_inside_top]\n    type = SideAverageValue\n  #  boundary = 'plenum_top'\n    boundary = 'clad_inside'\n    execute_on = 'initial linear'\n    variable = temp\n  []\n  [volume_tol]\n    type = InternalVolume\n  #  boundary = 'clad_inside fuel_outer fuel_top plenum_top'\n    boundary = 'clad_inside fuel_outer'\n    execute_on = 'initial linear'\n  []\n[]\n\n[Preconditioning]\n  [smp]\n   type = SMP\n   full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  start_time = 0.\n  end_time = 31536000\n  dt = 864000\n  #[./TimeStepper]\n  #  type = TimeSequenceStepper\n  #  time_sequence = '0 0.001 3600 86400 864000 1728000 2592000 3456000 4320000 5184000 6048000 6912000 7776000\n  #  8640000 9504000 10368000 11232000 12096000 12960000 13824000 14688000 15552000 16416000 17280000 18144000\n  #  19008000 19872000 20736000 21600000 22464000 23328000 24192000 25056000 25920000 26784000 27648000 28512000\n  #  29376000 30240000 31104000 31536000'\n  #[../]\n  nl_abs_tol = 1e-5\n  nl_rel_tol = 1e-5\n  l_tol = 1e-5\n  l_max_its = 30\n  nl_max_its = 30\n\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-pc_type -pc_fator_mat_solver_package'\n  petsc_options_value = 'lu superlu_dist'\n  #petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomerang_max_iter'\n  #petsc_options_value = '201 hypre boomeramg 4'\n  line_search = 'none'\n[]\n\n[Outputs]\n  exodus = true\n  perf_graph = true\n[]\n\n[Debug]\n show_var_residual_norms = true\n[]\n\nThe erro occurs in CZ_power_law_creep which is the returned value of function computeResidualInternal( const GenericReal<is_ad> & effective_trial_stress, const ScalarType & scalar) is a little too big. But I dont know how to fix it.",
                          "url": "https://github.com/idaholab/moose/discussions/24628#discussioncomment-6128010",
                          "updatedAt": "2023-06-09T01:45:12Z",
                          "publishedAt": "2023-06-09T01:45:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "And the first step is thermal conduction calculation which runs quite well.",
                          "url": "https://github.com/idaholab/moose/discussions/24628#discussioncomment-6128024",
                          "updatedAt": "2023-06-09T01:48:14Z",
                          "publishedAt": "2023-06-09T01:48:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you please upload the mesh and the input file to a git repo?\nI cant run this input, I would need this file cz_no_butterfly.e",
                          "url": "https://github.com/idaholab/moose/discussions/24628#discussioncomment-6137216",
                          "updatedAt": "2023-06-09T22:16:14Z",
                          "publishedAt": "2023-06-09T22:16:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jin0123456"
                  },
                  "bodyText": "Here is the thing.\nscalar in computeResidualInternal( const GenericReal<is_ad> & effective_trial_stress, const ScalarType & scalar) is always 0 which means the returned value  creep_rate * _dt - scalar is too big to converge. I dont know how scalar is calculated in this process. But the other creep model I used is well converged and scalar in which isn't always 0.",
                  "url": "https://github.com/idaholab/moose/discussions/24628#discussioncomment-6128321",
                  "updatedAt": "2023-06-09T02:41:00Z",
                  "publishedAt": "2023-06-09T02:40:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@recuero thoughts?",
                          "url": "https://github.com/idaholab/moose/discussions/24628#discussioncomment-6137221",
                          "updatedAt": "2023-06-09T22:17:25Z",
                          "publishedAt": "2023-06-09T22:17:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "@jin0123456 are you using your own creep model?",
                          "url": "https://github.com/idaholab/moose/discussions/24628#discussioncomment-6137343",
                          "updatedAt": "2023-06-09T22:57:19Z",
                          "publishedAt": "2023-06-09T22:57:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "You say you use a function: Can you provide details of your modification?",
                          "url": "https://github.com/idaholab/moose/discussions/24628#discussioncomment-6137486",
                          "updatedAt": "2023-06-09T23:38:52Z",
                          "publishedAt": "2023-06-09T23:38:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "@recuero @GiudGiud  I'm sorry I can't provide this creep model due to confidentiality agreements.\nBut I have solved the problem by shortening the time step so I think maybe my creep rate is too big to converge.",
                          "url": "https://github.com/idaholab/moose/discussions/24628#discussioncomment-6139962",
                          "updatedAt": "2023-06-10T13:09:08Z",
                          "publishedAt": "2023-06-10T13:09:08Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Paraview Error",
          "author": {
            "login": "nourriahi"
          },
          "bodyText": "Hello everyone,\nI am facing a problem with Paraview! I am trying to open moose simulation which is running correctly but I keep having this error message each time :\n\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/24644",
          "updatedAt": "2023-06-12T10:50:48Z",
          "publishedAt": "2023-06-09T15:36:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nTHis does not look right indeed.\nIf you run the mesh only with --mesh-only in the command line, and try to open the mesh_name_in.e file, does it work?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24644#discussioncomment-6136526",
                  "updatedAt": "2023-06-09T20:10:14Z",
                  "publishedAt": "2023-06-09T20:10:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "solutions unconverged for porous structures",
          "author": {
            "login": "chenyuanming223"
          },
          "bodyText": "Dear MOOSE users:\nI want to simulate the uniaxial comp with porous lattice structures using moose. The material model is elastic-plastic model with a small hardening for better convergence. but during simulation, the time-stepping is always reducing the minimal, then stopped for both NEWTON and PJFNK. The input files are attached, could you please help me look at this and give me any suggestions?\nThanks!\ninput_files_zc.zip\nZC",
          "url": "https://github.com/idaholab/moose/discussions/24586",
          "updatedAt": "2023-06-12T08:47:38Z",
          "publishedAt": "2023-06-04T09:10:13Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPlease see our page for troubleshooting failing solves:\nhttps://mooseframework.inl.gov/application_usage/failed_solves.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24586#discussioncomment-6082719",
                  "updatedAt": "2023-06-04T12:59:51Z",
                  "publishedAt": "2023-06-04T12:59:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chenyuanming223"
                          },
                          "bodyText": "Hi Guillaume,\nthanks, for a simple structure generated by moose mesh generator, this input script is good.",
                          "url": "https://github.com/idaholab/moose/discussions/24586#discussioncomment-6082759",
                          "updatedAt": "2023-06-04T13:07:51Z",
                          "publishedAt": "2023-06-04T13:07:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Interesting.\nDo you mind hosting these files, especially the mesh, on a githup repo? Zip isn't a great format for us",
                          "url": "https://github.com/idaholab/moose/discussions/24586#discussioncomment-6082813",
                          "updatedAt": "2023-06-04T13:22:56Z",
                          "publishedAt": "2023-06-04T13:22:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chenyuanming223"
                          },
                          "bodyText": "Hi,\nPlease see this: https://github.com/chenyuanming223/test_moose.git",
                          "url": "https://github.com/idaholab/moose/discussions/24586#discussioncomment-6083004",
                          "updatedAt": "2023-06-04T14:06:34Z",
                          "publishedAt": "2023-06-04T14:06:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Don't use compute_scaling_once=false it's a bad option. Use preset=false on BCs for plasticity models. Use Newton not PJFNK since the Jacobian is exact.",
                          "url": "https://github.com/idaholab/moose/discussions/24586#discussioncomment-6083049",
                          "updatedAt": "2023-06-04T14:14:34Z",
                          "publishedAt": "2023-06-04T14:14:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Linear tet is not a good choice for plasticity either.",
                          "url": "https://github.com/idaholab/moose/discussions/24586#discussioncomment-6083055",
                          "updatedAt": "2023-06-04T14:15:42Z",
                          "publishedAt": "2023-06-04T14:15:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You also need to fiddle with the solver. The default solver is not going to work the best.",
                          "url": "https://github.com/idaholab/moose/discussions/24586#discussioncomment-6083069",
                          "updatedAt": "2023-06-04T14:19:56Z",
                          "publishedAt": "2023-06-04T14:19:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chenyuanming223"
                          },
                          "bodyText": "You also need to fiddle with the solver. The default solver is not going to work the best.\n\nHi Gary,\nYou're right, the nolinear convergence residual is too tight I think, compared with Ansys mechanical (the default relative residual for Force is 0.5%). In moose, we have nl_abs_tol and nl_rel_tol, the solver in this simulation checks according to nl_abs_tol?",
                          "url": "https://github.com/idaholab/moose/discussions/24586#discussioncomment-6087199",
                          "updatedAt": "2023-06-05T07:30:52Z",
                          "publishedAt": "2023-06-05T07:30:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chenyuanming223"
                          },
                          "bodyText": "You also need to fiddle with the solver. The default solver is not going to work the best.\n\nwith the hex8, still the error:\nWe caught a libMesh error in ThreadedElementLoopBase:ERROR: negative Jacobian -2.09741e-06 at point (x,y,z)=( 4.73366,  4.93641, 0.548187) in element 54113\n[7] ../src/fe/fe_map.C, line 1173, compiled Apr 20 2023 at 15:32:26\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nthen timestepdroped",
                          "url": "https://github.com/idaholab/moose/discussions/24586#discussioncomment-6089598",
                          "updatedAt": "2023-06-05T11:38:37Z",
                          "publishedAt": "2023-06-05T11:38:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the solver in this simulation checks according to nl_abs_tol?\n\nIt checks based on both, and the nl_abs_tol default is 1e-50, so it s usually the nl_rel_tol that gets triggered\nIs the HEX8 mesh working on the first time step?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24586#discussioncomment-6090030",
                          "updatedAt": "2023-06-05T12:27:19Z",
                          "publishedAt": "2023-06-05T12:27:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "If you can upload your hex mesh to that repo, I can quickly make the changes for you. I really should add a troubleshoot page for tensor mechanics...",
                          "url": "https://github.com/idaholab/moose/discussions/24586#discussioncomment-6090141",
                          "updatedAt": "2023-06-05T12:39:40Z",
                          "publishedAt": "2023-06-05T12:39:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Hyperelasticity - can we do it in MOOSE?",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Hey folks,\nMy specific question is I'm wondering whether TensorMechanics can model Yeoh hyperelasticity, where the energy density is\n$$\\sum_{n=1}^{3} A_n (I_1 - 3)^n $$\nwith $A_n$ specified by the user, and $I_1$ is the first invariant of the Cauchy-Green deformation tensor.\nMore generally, and probably less usefully, can we model nonlinear elasticity?  Eg, i could differentiate the above with respect to strain to get stress = nonlinear function of strain, and then insert the correct coefficients (=material moduli) into a nonlinear elasticity Material class, if TensorMechanics has one.",
          "url": "https://github.com/idaholab/moose/discussions/24637",
          "updatedAt": "2023-06-11T22:49:36Z",
          "publishedAt": "2023-06-09T01:08:54Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "ya we have\n\nComputeLagrangianStressPK1\nComputeLagrangianStressPK2\nComputeLagrangianStressCauchy\n\nDepending on your stress measure.",
                  "url": "https://github.com/idaholab/moose/discussions/24637#discussioncomment-6128400",
                  "updatedAt": "2023-06-09T02:58:11Z",
                  "publishedAt": "2023-06-09T02:58:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error in using \"TerminateControl\" module",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello MOOSE experts,\nI am trying to put control logic for terminating my simulation when postprocessor value reach certain value. However, I am getting following error.\n*** ERROR ***\nThe parameter \"_thm_problem\" is being retrieved before being set.\n\nPostprocessor\n[Postprocessors]\n  [average_surface_conc]\n    type = SideAverageValue\n    variable = c\n    boundary = 'right'\n  []\n[]\n\n[ControlLogic]\n  [threshold]\n    type = UnitTripControl\n    condition = 'average_surface_conc < conc_ref'\n    symbol_names = 'average_surface_conc'\n    symbol_values = 'average_surface_conc'\n  []\n\n  [terminate]\n    type = TerminateControl\n    input = threshold:state\n    termination_message = 'Surface concentration reached'\n  []\n[]\n\nAny suggestions?\nBest,\nAvtar",
          "url": "https://github.com/idaholab/moose/discussions/24626",
          "updatedAt": "2023-06-08T21:00:22Z",
          "publishedAt": "2023-06-07T22:46:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "This control cannot be used outside of the thermal hydraulics module.\ni made a change request this week to make this clear, it s very unfortunate timing that you tried to use it today, it will be clear in the documentation that that s not possible very soon",
                  "url": "https://github.com/idaholab/moose/discussions/24626#discussioncomment-6116867",
                  "updatedAt": "2023-06-08T00:14:19Z",
                  "publishedAt": "2023-06-08T00:14:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thanks @GiudGiud\nIs there any other way to stop the simulation as soon as following postprocessor reaches certain value?\n[Postprocessors]\n  [average_surface_conc]\n    type = SideAverageValue\n    variable = c\n    boundary = 'right'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24626#discussioncomment-6123911",
                          "updatedAt": "2023-06-08T15:16:43Z",
                          "publishedAt": "2023-06-08T15:16:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Use the Terminator It s designed for that purpose\nhttps://mooseframework.inl.gov/source/userobjects/Terminator.html",
                          "url": "https://github.com/idaholab/moose/discussions/24626#discussioncomment-6125888",
                          "updatedAt": "2023-06-08T19:20:33Z",
                          "publishedAt": "2023-06-08T19:20:32Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thanks @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/24626#discussioncomment-6126619",
                          "updatedAt": "2023-06-08T21:00:22Z",
                          "publishedAt": "2023-06-08T21:00:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Quick question: is there a time derivative with coefficient based on material property?",
          "author": {
            "login": "Nabiel-Abuyazid"
          },
          "bodyText": "Does anybody know of a time derivative kernel that allows a coefficient to be based on a spatially varying material property?\nThanks,\nNabiel",
          "url": "https://github.com/idaholab/moose/discussions/24485",
          "updatedAt": "2023-06-08T19:23:23Z",
          "publishedAt": "2023-05-25T19:02:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo there is not.\nWould be fairly easy to make though, maybe base it on\nhttps://mooseframework.inl.gov/source/kernels/ADCoefCoupledTimeDerivative.html\nIf it s for heat conduction you can also use this\nhttps://mooseframework.inl.gov/source/kernels/ADHeatConductionTimeDerivative.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6004731",
                  "updatedAt": "2023-05-25T19:23:00Z",
                  "publishedAt": "2023-05-25T19:22:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Nabiel-Abuyazid"
                          },
                          "bodyText": "Thanks Guillaume. I'm a novice at this and I have some questions that I hope can be answered simply:\n\nI can imagine that to create the coupled coefficient I can borrow some of the scripts from something like MatDiffusion. But the part that confuses me is that once I have made the .c and corresponding .h file, how would I incorporate it such that it is part of my combined-opt binary?\nI suppose this may be related to the first question: where would be best directories to put my custom kernels?",
                          "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6004763",
                          "updatedAt": "2023-05-25T19:28:13Z",
                          "publishedAt": "2023-05-25T19:28:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ideally you create your own application, then you can add it to the src/ and include/ folders in your app.\nYou could also just add it directly to moose or to a moose module you are using.\n\ndefinitely your own application",
                          "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6004786",
                          "updatedAt": "2023-05-25T19:31:05Z",
                          "publishedAt": "2023-05-25T19:31:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Nabiel-Abuyazid"
                          },
                          "bodyText": "Hi Guillaume,\nI have tried to implement this based on CoefTimeDerivative. However, when I try to make it in my own App, it won't compile properly. I was wondering if you could review my work for my C and header files.\nmy C file:\n#include \"MatTimeDerivative.h\"\n\nregisterMooseObject(\"PlatypusApp\", MatTimeDerivative);\n\nInputParameters\nMatTimeDerivative::validParams()\n{\n  InputParameters params = Kernel::validParams();\n  params.addDeprecatedParam<MaterialPropertyName>(\n      \"G_name\",\n      \"The name of the coefficient\",\n      \"This parameter has been renamed to 'time_coefficient', which is more mnemonic and more conducive \"\n      \"to passing a number literal\");\n  params.addParam<MaterialPropertyName>(\n      \"time_coefficient\", \"G\", \"The coefficient value or material property\");\n  return params;\n}\n\nMatTimeDerivative::MatTimeDerivative(const InputParameters &parameters)\n    : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n      _G(isParamValid(\"G_name\") ? getMaterialProperty<Real>(\"G_name\")\n                                : getMaterialProperty<Real>(\"time_coefficient\"))\n{\n}\n\nReal MatTimeDerivative::computeQpResidual()\n{\n  return _G[_qp] * TimeDerivative::computeQpResidual();\n}\n\nReal MatTimeDerivative::computeQpJacobian()\n{\n  return _G[_qp] * TimeDerivative::computeQpJacobian();\n}\n\nmy header file:\n#pragma once\n\n#include \"TimeDerivative.h\"\n#include \"Kernel.h\"\n#include \"JvarMapInterface.h\"\n#include \"DerivativeMaterialInterface.h\"\n\n/**\n * Time derivative term multiplied by a coefficient\n */\nclass MatTimeDerivative : public TimeDerivative\n{\npublic:\n  static InputParameters validParams();\n\n  MatTimeDerivative(const InputParameters &parameters);\n\nprotected:\n  virtual Real computeQpResidual();\n  virtual Real computeQpJacobian();\n\n  /// The material property the time derivative is multiplied with\n  const MaterialProperty<Real> &_G;\n};",
                          "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6115154",
                          "updatedAt": "2023-06-07T19:08:41Z",
                          "publishedAt": "2023-06-07T19:08:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Nabiel-Abuyazid"
                          },
                          "bodyText": "The make output was having a problem with the DerivativeMaterialInterface<JvarMapKernelInterface>",
                          "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6115272",
                          "updatedAt": "2023-06-07T19:25:37Z",
                          "publishedAt": "2023-06-07T19:25:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\ni dont think you need that. Just use a normal constructor for a kernel\nIf you do want to use that,\nthen in your header, do you have:\nclass MatTimeDerivative : public DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>\n\nwhat is the error exactly?",
                          "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6115402",
                          "updatedAt": "2023-06-07T19:46:01Z",
                          "publishedAt": "2023-06-07T19:43:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Nabiel-Abuyazid"
                          },
                          "bodyText": "What would that look like? I am not familiar with this.",
                          "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6115422",
                          "updatedAt": "2023-06-07T19:44:47Z",
                          "publishedAt": "2023-06-07T19:44:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Nabiel-Abuyazid"
                          },
                          "bodyText": "What would a normal constructor look like?\nTo answer your question, the header does not have that line in it. But here is what the error looks like:\n/Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.C:29:7: error: type 'DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>' is not a direct or virtual base of 'MatTimeDerivative'\n    : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1 error generated.",
                          "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6115709",
                          "updatedAt": "2023-06-07T20:17:34Z",
                          "publishedAt": "2023-06-07T20:17:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "take a look at your header, and make sure the parent classes are the same as in the constructor",
                          "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6115812",
                          "updatedAt": "2023-06-07T20:35:42Z",
                          "publishedAt": "2023-06-07T20:35:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Nabiel-Abuyazid"
                          },
                          "bodyText": "Sorry Guillaume, but could you write it out for me based on the header file I sent you originally?\nI have added the following to my header file to do as you suggested, but now it has returned several more errors:\nclass MatTimeDerivative : public TimeDerivative, DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>\n\nHere are the errors:\n(moose) Nabiels-MacBook-Pro:platypus nabzforcemac$ make -j 8\nRebuilding symlinks in /Users/nabzforcemac/projects/platypus/build/header_symlinks\nCompiling C++ with suffix (in opt mode) /Users/nabzforcemac/projects/moose/modules/module_loader/src/ModulesApp.C...\nCompiling C++ (in opt mode) /Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.C...\nCompiling C++ (in opt mode) /Users/nabzforcemac/projects/platypus/src/base/PlatypusApp.C...\nCompiling C++ (in opt mode) /Users/nabzforcemac/projects/platypus/src/main.C...\nCompiling C++ (in opt mode) /Users/nabzforcemac/projects/platypus/test/src/base/PlatypusTestApp.C...\nCreating resource file\nLinking Library /Users/nabzforcemac/projects/moose/modules/module_loader/lib/libmodule_loader_with-opt.la...\nLinking Library /Users/nabzforcemac/projects/platypus/test/lib/libplatypus_test-opt.la...\n/Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.C:29:7: error: type 'DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>' is not a direct or virtual base of 'MatTimeDerivative'\n    : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n1 error generated.\nmake: *** [/Users/nabzforcemac/projects/moose/framework/build.mk:148: /Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.aarch64-apple-darwin20.0.0.opt.lo] Error 1\n(moose) Nabiels-MacBook-Pro:platypus nabzforcemac$ make -j 8\nCompiling C++ (in opt mode) /Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.C...\n/Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.C:30:10: error: non-static member 'isParamValid' found in multiple base-class subobjects of type 'MooseObject':\n    class MatTimeDerivative -> class TimeDerivative -> class TimeKernel -> class Kernel -> class KernelBase -> class ResidualObject -> class MooseObject\n    class MatTimeDerivative -> DerivativeMaterialInterface<JvarMapKernelInterface<class Kernel> > -> class JvarMapKernelInterface<class Kernel> -> JvarMapInterfaceBase<class Kernel> -> class Kernel -> class KernelBase -> class ResidualObject -> class MooseObject\n      _G(isParamValid(\"G_name\") ? getMaterialProperty<Real>(\"G_name\")\n         ^\n/Users/nabzforcemac/projects/moose/framework/build/header_symlinks/MooseObject.h:129:15: note: member found by ambiguous name lookup\n  inline bool isParamValid(const std::string & name) const { return _pars.isParamValid(name); }\n              ^\n/Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.C:30:35: error: non-static member 'getMaterialProperty' found in multiple base-class subobjects of type 'MaterialPropertyInterface':\n    class MatTimeDerivative -> class TimeDerivative -> class TimeKernel -> class Kernel -> class KernelBase -> class MaterialPropertyInterface\n    class MatTimeDerivative -> DerivativeMaterialInterface<JvarMapKernelInterface<class Kernel> > -> class JvarMapKernelInterface<class Kernel> -> JvarMapInterfaceBase<class Kernel> -> class Kernel -> class KernelBase -> class MaterialPropertyInterface\n      _G(isParamValid(\"G_name\") ? getMaterialProperty<Real>(\"G_name\")\n                                  ^\n/Users/nabzforcemac/projects/moose/framework/build/header_symlinks/MaterialPropertyInterface.h:539:28: note: member found by ambiguous name lookup\nMaterialPropertyInterface::getMaterialProperty(const std::string & name)\n                           ^\n/Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.C:31:35: error: non-static member 'getMaterialProperty' found in multiple base-class subobjects of type 'MaterialPropertyInterface':\n    class MatTimeDerivative -> class TimeDerivative -> class TimeKernel -> class Kernel -> class KernelBase -> class MaterialPropertyInterface\n    class MatTimeDerivative -> DerivativeMaterialInterface<JvarMapKernelInterface<class Kernel> > -> class JvarMapKernelInterface<class Kernel> -> JvarMapInterfaceBase<class Kernel> -> class Kernel -> class KernelBase -> class MaterialPropertyInterface\n                                : getMaterialProperty<Real>(\"time_coefficient\"))\n                                  ^\n/Users/nabzforcemac/projects/moose/framework/build/header_symlinks/MaterialPropertyInterface.h:539:28: note: member found by ambiguous name lookup\nMaterialPropertyInterface::getMaterialProperty(const std::string & name)\n                           ^\n/Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.C:37:13: error: non-static member '_qp' found in multiple base-class subobjects of type 'KernelBase':\n    class MatTimeDerivative -> class TimeDerivative -> class TimeKernel -> class Kernel -> class KernelBase\n    class MatTimeDerivative -> DerivativeMaterialInterface<JvarMapKernelInterface<class Kernel> > -> class JvarMapKernelInterface<class Kernel> -> JvarMapInterfaceBase<class Kernel> -> class Kernel -> class KernelBase\n  return _G[_qp] * TimeDerivative::computeQpResidual();\n            ^\n/Users/nabzforcemac/projects/moose/framework/build/header_symlinks/KernelBase.h:42:16: note: member found by ambiguous name lookup\n  unsigned int _qp;\n               ^\n/Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.C:42:13: error: non-static member '_qp' found in multiple base-class subobjects of type 'KernelBase':\n    class MatTimeDerivative -> class TimeDerivative -> class TimeKernel -> class Kernel -> class KernelBase\n    class MatTimeDerivative -> DerivativeMaterialInterface<JvarMapKernelInterface<class Kernel> > -> class JvarMapKernelInterface<class Kernel> -> JvarMapInterfaceBase<class Kernel> -> class Kernel -> class KernelBase\n  return _G[_qp] * TimeDerivative::computeQpJacobian();\n            ^\n/Users/nabzforcemac/projects/moose/framework/build/header_symlinks/KernelBase.h:42:16: note: member found by ambiguous name lookup\n  unsigned int _qp;\n               ^\nIn file included from /Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.C:10:\nIn file included from /Users/nabzforcemac/projects/platypus/build/header_symlinks/MatTimeDerivative.h:12:\nIn file included from /Users/nabzforcemac/projects/moose/framework/build/header_symlinks/TimeDerivative.h:12:\nIn file included from /Users/nabzforcemac/projects/moose/framework/build/header_symlinks/TimeKernel.h:12:\nIn file included from /Users/nabzforcemac/projects/moose/framework/build/header_symlinks/Kernel.h:12:\nIn file included from /Users/nabzforcemac/projects/moose/framework/build/header_symlinks/KernelBase.h:12:\nIn file included from /Users/nabzforcemac/projects/moose/framework/build/header_symlinks/ResidualObject.h:12:\nIn file included from /Users/nabzforcemac/projects/moose/framework/build/header_symlinks/MooseObject.h:15:\n/Users/nabzforcemac/projects/moose/framework/build/header_symlinks/Registry.h:259:12: error: no viable conversion from returned value of type 'shared_ptr<MatTimeDerivative>' to function return type 'shared_ptr<MooseObject>'\n    return std::make_shared<T>(parameters);\n           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/Users/nabzforcemac/projects/moose/framework/build/header_symlinks/Registry.h:167:24: note: in instantiation of function template specialization 'Registry::build<MatTimeDerivative, MooseObject>' requested here\n    copy._build_ptr = &build<T, MooseObject>;\n                       ^\n/Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.C:12:1: note: in instantiation of function template specialization 'Registry::add<MatTimeDerivative>' requested here\nregisterMooseObject(\"PlatypusApp\", MatTimeDerivative);\n^\n/Users/nabzforcemac/projects/moose/framework/build/header_symlinks/Registry.h:43:17: note: expanded from macro 'registerMooseObject'\n      Registry::add<classname>(                                                                    \\\n                ^\n/Users/nabzforcemac/mambaforge3/envs/moose/bin/../include/c++/v1/__memory/shared_ptr.h:481:23: note: candidate constructor not viable: no known conversion from 'shared_ptr<MatTimeDerivative>' to 'nullptr_t' for 1st argument\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT\n                      ^\n/Users/nabzforcemac/mambaforge3/envs/moose/bin/../include/c++/v1/__memory/shared_ptr.h:633:5: note: candidate constructor not viable: no known conversion from 'shared_ptr<MatTimeDerivative>' to 'const std::shared_ptr<MooseObject> &' for 1st argument\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    ^\n/Users/nabzforcemac/mambaforge3/envs/moose/bin/../include/c++/v1/__memory/shared_ptr.h:652:5: note: candidate constructor not viable: no known conversion from 'shared_ptr<MatTimeDerivative>' to 'std::shared_ptr<MooseObject> &&' for 1st argument\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    ^\n/Users/nabzforcemac/mambaforge3/envs/moose/bin/../include/c++/v1/__type_traits/enable_if.h:23:96: note: candidate template ignored: disabled by 'enable_if' [with _Yp = MatTimeDerivative]\ntemplate <bool _Bp, class _Tp = void> using __enable_if_t _LIBCPP_NODEBUG = typename enable_if<_Bp, _Tp>::type;\n                                                                                               ^\n/Users/nabzforcemac/mambaforge3/envs/moose/bin/../include/c++/v1/__type_traits/enable_if.h:23:96: note: candidate template ignored: disabled by 'enable_if' [with _Yp = MatTimeDerivative]\n/Users/nabzforcemac/mambaforge3/envs/moose/bin/../include/c++/v1/__memory/shared_ptr.h:699:5: note: candidate template ignored: could not match 'unique_ptr' against 'shared_ptr'\n    shared_ptr(unique_ptr<_Yp, _Dp>&& __r)\n    ^\n/Users/nabzforcemac/mambaforge3/envs/moose/bin/../include/c++/v1/__memory/shared_ptr.h:722:5: note: candidate template ignored: could not match 'unique_ptr' against 'shared_ptr'\n    shared_ptr(unique_ptr<_Yp, _Dp>&& __r)\n    ^\n/Users/nabzforcemac/mambaforge3/envs/moose/bin/../include/c++/v1/__memory/shared_ptr.h:497:14: note: explicit constructor is not a candidate\n    explicit shared_ptr(_Yp* __p) : __ptr_(__p) {\n             ^\n/Users/nabzforcemac/mambaforge3/envs/moose/bin/../include/c++/v1/__memory/shared_ptr.h:672:14: note: explicit constructor is not a candidate\n    explicit shared_ptr(const weak_ptr<_Yp>& __r)\n             ^\n6 errors generated.\nmake: *** [/Users/nabzforcemac/projects/moose/framework/build.mk:149: /Users/nabzforcemac/projects/platypus/src/MatTimeDerivative.aarch64-apple-darwin20.0.0.opt.lo] Error 1",
                          "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6115870",
                          "updatedAt": "2023-06-07T20:43:11Z",
                          "publishedAt": "2023-06-07T20:43:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "try this\nclass MatTimeDerivative : public TimeDerivative, public DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>",
                          "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6115957",
                          "updatedAt": "2023-06-08T19:22:40Z",
                          "publishedAt": "2023-06-07T20:56:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Nabiel-Abuyazid"
                  },
                  "bodyText": "I found the HeatCapacityConductionTimeDerivative kernel that does exactly what I want. Thank you for your help. I am closing this discussion now.",
                  "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6124053",
                  "updatedAt": "2023-06-08T15:28:41Z",
                  "publishedAt": "2023-06-08T15:28:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok good!",
                          "url": "https://github.com/idaholab/moose/discussions/24485#discussioncomment-6125909",
                          "updatedAt": "2023-06-08T19:23:23Z",
                          "publishedAt": "2023-06-08T19:23:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unphysical oscillations in tangential forces for contact problem",
          "author": {
            "login": "npurwar93"
          },
          "bodyText": "I am trying to understand the contact module of MOOSE. As a starting problem, I have a very simple setup: a cube block (box) pressed and slided over another one-element rigid block (plane) with friction. I make the plane as rigid by fixing all its nodes.\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  patch_update_strategy = 'iteration'\n  volumetric_locking_correction = true\n[]\n\n[Mesh]\n  [rectangle_body]\n    type = GeneratedMeshGenerator\n    dim = 3\n    xmin= 20\n    xmax = 50\n    ymin = 6\n    ymax = 36\n    zmin = -15\n    zmax = 15\n    nx = 2\n    ny = 2\n    nz = 2\n    elem_type = HEX\n    boundary_name_prefix = 'box'\n  []\n\n  [plane_rigid]\n    type = GeneratedMeshGenerator\n    dim = 3\n    xmin= 0\n    xmax = 100\n    ymin = 0\n    ymax = 5\n    zmin = -50\n    zmax = 50\n    nx = 1\n    ny = 1\n    nz = 1\n    elem_type = HEX\n    boundary_name_prefix = 'plane'\n    boundary_id_offset = 6\n    subdomain_ids = 1\n  []\n\n  [cmbn]\n    type = CombinerGenerator\n    inputs = 'rectangle_body plane_rigid'\n  []\n\n  [cmbn_new]\n    type = RenameBlockGenerator\n    input = cmbn\n    old_block = '0 1'\n    new_block = 'box plane'\n  []\n[]\n\n[Variables]\n    [disp_x]\n    []\n    [disp_y]\n    []\n    [disp_z]\n    []\n[]\n\n[Functions]\n  [ydisp]\n    type = ParsedFunction\n    vars = 't0   t_end  disp'\n    vals = '10.0  20.0    -4'\n    value = 'if (t<t0, 0.0, if (t<t_end, disp*(t-t0)/(t_end-t0), disp))'\n  []\n  [xdisp]\n    type = ParsedFunction\n    vars = 't0   t_end  disp'\n    vals = '20.0  30.0    2'\n    value = 'if (t<t0, 0.0, disp*(t-t0)/(t_end-t0))'\n  []\n[]\n\n[AuxVariables]\n  [./norm_force_x]\n  [../]\n  [./norm_force_y]\n  [../]  \n  [./norm_force_z]\n  [../]  \n  [./tang_force_x]\n  [../]\n  [./tang_force_y]\n  [../]\n  [./tang_force_z]\n  [../]\n[]\n\n[AuxKernels]\n  [./normal_force_x]\n    type = PenetrationAux\n    variable = norm_force_x\n    execute_on = timestep_end\n    quantity = normal_force_x\n    boundary = box_bottom\n    paired_boundary = plane_top\n  [../]\n  [./normal_force_y]\n    type = PenetrationAux\n    variable = norm_force_y\n    execute_on = timestep_end\n    quantity = normal_force_y\n    boundary = box_bottom\n    paired_boundary = plane_top\n  [../]\n  [./normal_force_z]\n    type = PenetrationAux\n    variable = norm_force_z\n    execute_on = timestep_end\n    quantity = normal_force_z\n    boundary = box_bottom\n    paired_boundary = plane_top\n  [../]\n  [./tangential_force_x]\n    type = PenetrationAux\n    variable = tang_force_x\n    execute_on = timestep_end\n    quantity = tangential_force_x\n    boundary = box_bottom\n    paired_boundary = plane_top\n  [../]\n  [./tangential_force_y]\n    type = PenetrationAux\n    variable = tang_force_y\n    execute_on = timestep_end\n    quantity = tangential_force_y\n    boundary = box_bottom\n    paired_boundary = plane_top\n  [../]\n  [./tangential_force_z]\n    type = PenetrationAux\n    variable = tang_force_z\n    execute_on = timestep_end\n    quantity = tangential_force_z\n    boundary = box_bottom\n    paired_boundary = plane_top\n  [../]\n[]\n\n[Modules/TensorMechanics/Master]\n  [./all]\n    add_variables = true\n    strain = FINITE\n  [../]\n[]\n\n[BCs]\n  [xfixed]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'plane_top plane_bottom'\n    value = 0\n  []\n  [yfixed]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'plane_top plane_bottom'\n    value = 0\n  []\n  [zfixed]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'plane_top plane_bottom box_top'\n    value = 0\n  []\n  [ydisp]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = box_top\n    function = ydisp\n    preset = 0\n  []\n  [xdisp]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = box_top\n    function = xdisp\n    preset = 0\n  []\n[]\n\n[Materials]\n  [strain_all]\n    type = ComputeFiniteStrainElasticStress\n    block = 'box plane'\n  []\n\n  [Top]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 5\n    poissons_ratio = 0.49\n    block = 'box'\n  []\n  [Bottom]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 1e6\n    poissons_ratio = 0.3\n    block = 'plane'\n  []\n\n[]\n\n[Contact]\n  [contact_interface]\n    primary = plane_top\n    secondary = box_bottom\n    formulation = penalty\n    model = coulomb\n    friction_coefficient = 0.1\n    normalize_penalty = true\n    penalty = 1e+2\n    normal_smoothing_distance = 0.1\n  []\n[]\n\n[Dampers]\n  [contact_slip]\n    type = ContactSlipDamper\n    secondary = box_bottom\n    primary = plane_top\n    min_damping_factor = 1e-5\n  []\n[]\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  \n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_type'\n  petsc_options_value = 'lu        mumps'\n  line_search = contact\n  automatic_scaling = true\n  contact_line_search_ltol = 1e-3\n  nl_max_its = 100\n  l_max_its = 40\n  start_time = 0.0\n  dt = 0.5\n  end_time = 30.0\n\n  verbose = true\n  nl_rel_tol = 1e-4\n  nl_abs_tol = 1e-4\n[] # Executioner\n\n[Outputs]\n  color = false\n  [out]\n    type = Exodus\n  []\n[] # Outputs\n\n\n\nWhen I look at the output, I see that the tangential forces oscillate unphysically. In the figure below, the average tangential force for the contact surface of the box is shown over time. From time 12.5-20s, the contact is established by pressing the box. After 20s, the box is moved in x-direction. The oscillations in x-component of tangential force is clearly unphysical.\n\nHowever, when I further looked in the code of MechanicalContactConstraint.C in the function computeContactForce, the frictional capacity for the penalty formulation has some different formulation than the literature.\n// Frictional capacity\n// const Real capacity( _friction_coefficient * (pen_force * pinfo->_normal < 0 ?\n// -pen_force * pinfo->_normal : 0) );\nconst Real capacity(_friction_coefficient *\n             (res_vec * pinfo->_normal > 0 ? res_vec * pinfo->_normal : 0));\n\nIt seems that the current frictional capacity for penalty method is actually the one for kinematic formulation. Although the formulation from literature is also written there, but it is commented. Is there a reasoning why the formulation for kinematic method is used in penalty method?\nAlso, when I uncomment the actual penalty formulation for friction capacity, the unphysical oscillations in the results disappear. Is this a bug here?",
          "url": "https://github.com/idaholab/moose/discussions/24562",
          "updatedAt": "2023-06-24T22:49:33Z",
          "publishedAt": "2023-06-01T13:15:01Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@bwspenc @recuero for node-face contact",
                  "url": "https://github.com/idaholab/moose/discussions/24562#discussioncomment-6063646",
                  "updatedAt": "2023-06-01T16:52:00Z",
                  "publishedAt": "2023-06-01T16:51:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "It's hard to know exactly what's happening in the lines of code for your problem. Just a few thoughts:\n\nYou say results are unphysical. Even thought that may be true, what's the expected output for that simulation? It helps to know what to expect for a simple test problem.\n\n\nthe frictional capacity for the penalty formulation has some different formulation than the literature:\n\n\n\nIs the frictional capacity the issue there? I.e. do you get a tangential frictional vector norm larger than the friction coefficient times the normal force?\n\n\n\nwhen I uncomment the actual penalty formulation for friction capacity, the unphysical oscillations in the results disappear. Is this a bug here?\n\n\n\nDo you mean you then get the expected results? You can get non-oscillating results with the wrong physics. Also, I'd try increasing the penalty value to try to obtain closer-to-theory results. Maybe @bwspenc can provide some details on the algorithm.",
                  "url": "https://github.com/idaholab/moose/discussions/24562#discussioncomment-6091756",
                  "updatedAt": "2023-06-05T15:16:17Z",
                  "publishedAt": "2023-06-05T15:16:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "npurwar93"
                          },
                          "bodyText": "The expected output for this simulation would be: a symmetrical deformation of the box and symmetric tangential force distribution at the contact surface when the box is pressed; when it is horizontally moved, at least the direction of the tangential force at the contact surface should be consistent according to the direction of the motion of the box.\n\nCurrently, as visible in the time plot shown above, the direction of the tangential force in x-direction is changing its direction constantly, even when the block is just pressed. Here, I have again plotted (Fig. 1) the x-component of the tangential force at the center node of the contact surface. In Fig. 2, there is no symmetric x-component tangential force distribution at the contact surface.\nFigure 1\n\nFigure 2\n\n\nThen magnitude of the tangential force vector is not larger than the friction coefficient times the normal force.  However, the direction is changing every time step.\nWhen I use the following formulation for computing frictional capacity\n\nconst Real capacity( _friction_coefficient * (pen_force * pinfo->_normal < 0 ?\n-pen_force * pinfo->_normal : 0) );\n\nI get the expected result. The box first deforms with tangential forces developing symmetrically when the box is pressed (Fig. 3) and then maintains consistent direction when it is moved horizontally (as shown in figure 4 below after 20s).\nFigure 3\n\nFigure 4\n\nRegarding increasing the penalty factor, the original frictional capacity formulation still gives these oscillations, but the time step decreases a lot to achieve convergence. With the new (modified) formulation as in point 3 here, after increasing the penalty factor beyond certain value, the Jacobian becomes negative, probably due to very large deformation causing negative volume elements. It is understandable here that for large penalty factor, the frictional capacity would increase accordingly. And for a soft material as used here, it would cause numerical problems.",
                          "url": "https://github.com/idaholab/moose/discussions/24562#discussioncomment-6105164",
                          "updatedAt": "2023-06-06T21:53:40Z",
                          "publishedAt": "2023-06-06T21:53:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I was thinking more along the lines of an analytical solution, but I do agree that, qualitatively, the results with the commented code look more physical. It seems to me that for a penalty method you don't need to use the cached residuals (contact forces) to compute a tangential traction, but I am not fully aware of the details of the algorithms used in node-face.\n\nRegarding increasing the penalty factor, the original frictional capacity formulation still gives these oscillations, but the time step decreases a lot to achieve convergence. With the new (modified) formulation as in point 3 here, after increasing the penalty factor beyond certain value, the Jacobian becomes negative, probably due to very large deformation causing negative volume elements. It is understandable here that for large penalty factor, the frictional capacity would increase accordingly. And for a soft material as used here, it would cause numerical problems.\n\nThat makes sense to me. I mentioned increasing the penalty factor because, if selected too small, it can produce very unphysical results.",
                          "url": "https://github.com/idaholab/moose/discussions/24562#discussioncomment-6112580",
                          "updatedAt": "2023-06-07T14:52:09Z",
                          "publishedAt": "2023-06-07T14:52:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "We'll look into this behavior @npurwar93 (#24632). Thanks for bringing it up.",
                          "url": "https://github.com/idaholab/moose/discussions/24562#discussioncomment-6124948",
                          "updatedAt": "2023-06-08T17:06:24Z",
                          "publishedAt": "2023-06-08T17:06:24Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}