{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0xMC0yMFQwODo0NDoxNC0wNTowMM4AN0xS"
    },
    "edges": [
      {
        "node": {
          "title": "How to know the current time step in material kernel",
          "author": {
            "login": "alexchen4ai"
          },
          "bodyText": "Hi Moose experts, I am currently doing a time dependent problem and I wish to implement the  backward Euler integration by AD differentiation.Is it possible that we can get the value of the current time step in material subroutine?",
          "url": "https://github.com/idaholab/moose/discussions/19179",
          "updatedAt": "2024-11-18T03:14:59Z",
          "publishedAt": "2021-10-22T08:19:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Yes, you can use _t for time and _t_step for time step.",
                  "url": "https://github.com/idaholab/moose/discussions/19179#discussioncomment-1520728",
                  "updatedAt": "2024-11-18T03:14:59Z",
                  "publishedAt": "2021-10-22T12:35:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "Thank you! Could you help explain more? time and time step are from executioner. How can I get the value of _t and _t_step in the material kernel?",
                          "url": "https://github.com/idaholab/moose/discussions/19179#discussioncomment-1522708",
                          "updatedAt": "2024-11-18T03:14:59Z",
                          "publishedAt": "2021-10-22T18:09:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Either in Material or Kernel,  you can directly use _t and _t_step.  They are member variables declared in the base class.",
                          "url": "https://github.com/idaholab/moose/discussions/19179#discussioncomment-1522760",
                          "updatedAt": "2024-11-18T03:14:59Z",
                          "publishedAt": "2021-10-22T18:20:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alexchen4ai"
                          },
                          "bodyText": "Thank you! That makes sense!",
                          "url": "https://github.com/idaholab/moose/discussions/19179#discussioncomment-1522766",
                          "updatedAt": "2024-11-18T03:15:04Z",
                          "publishedAt": "2021-10-22T18:21:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "possibility of running Tensor mechanics problem (with plasticity) using Explicit solvers?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi all, I've been trying to make my mine simulation to be able to run on explicit solver (to match with Abaqus).\nI wonder if MOOSE can do what I want.\nSo far what I've found is that the only Explicit solver from 'TimeIntegrator System' that works with my problem is CentralDifference with lumped.\nHowever, it does not go beyond the 'Static Initialization' step > tho I tried to modify the example problem (elastic) and it works fine, not sure if the problem comes from plasticity.\nCould you please have a look at my input file (attached) and please guide me on this problem, I really could not find many examples on Explicit solvers.\nThank you very much.\nTraiwit\nExplicitMOOSE.zip",
          "url": "https://github.com/idaholab/moose/discussions/17678",
          "updatedAt": "2022-06-15T22:24:45Z",
          "publishedAt": "2021-04-26T06:33:10Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "apparently, the current problem is an instability in the smaller elements (in this case the mine's tunnel), where the larger elements (mine stope) look fine.",
                  "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-662214",
                  "updatedAt": "2022-06-15T22:24:45Z",
                  "publishedAt": "2021-04-26T23:59:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Does it run if you remove plasticity? Are you sure your time step size satisfies CFL conditions?",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-663722",
                          "updatedAt": "2022-06-15T22:24:45Z",
                          "publishedAt": "2021-04-27T10:05:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @hugary1995,\nI could run using both elastic and plastic, esp with very small-time step size, however, at some point, the small elements start to explode (like the figure attached above). Also, it takes so much time when the time step size is small, is there anything that works like mass-scaling in MOOSE?\nIt could run fine if I set implicit=false in the InertialForce kernel OR when I set use_constant_mass = true under TimeIntegrator/type = CentralDifference/lumped >> HOWEVER, disp_ for these cases remain 0, which is incorrect.\nis CFL documented in MOOSE? I tried to follow  https://mooseframework.inl.gov/modules/tensor_mechanics/CriticalTimeStepMath.html for time step size.\ntbh I actually don't know what to do, I tried all the explicit solvers, seem like this is my only option.\nThank you,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-663812",
                          "updatedAt": "2022-06-15T22:24:45Z",
                          "publishedAt": "2021-04-27T10:36:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "@bwspenc - could you answer the question about how to do solid mechanics using explicit timestepping, or nominate someone else?  It's been about 5 years since i ran any explicit stuff, and i know MOOSE has moved on since then.",
                  "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-666545",
                  "updatedAt": "2022-06-15T22:24:47Z",
                  "publishedAt": "2021-04-27T21:09:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Prompting @bwspenc",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-690679",
                          "updatedAt": "2022-06-15T22:24:47Z",
                          "publishedAt": "2021-05-03T22:56:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thank you for reminding @WilkAndy, I kinda give up on this idea of explicit, now I want to relax plasticity so the simulation doesn't crash when the initial stress is too high or the softening is too rapid (5e6 to 5e5 from plastic strain 0 to 1%). I probs should make a new forum regarding this.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-690872",
                          "updatedAt": "2022-06-15T22:24:47Z",
                          "publishedAt": "2021-05-04T00:31:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "Unfortunately, I'm probably not very helpful here. As you've already seen, there is a basic capability, but it is pretty limited -- doesn't work with contact, and the last I heard, it was really slow. If it's not a really short duration impact event, you will likely have better luck with the implicit solver for the time being. We just haven't had much of a driver for developing this by our current programs.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-696365",
                          "updatedAt": "2022-06-15T22:24:47Z",
                          "publishedAt": "2021-05-05T00:18:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LabrosV"
                          },
                          "bodyText": "I am currently using the implicit solver to run some problems, but I'm interested in using the explicit solver to investigate short duration impact events. How basic/limited is the capability? (i.e. I'm looking for an updated manual, if exists.) Currently, there is no need for contact and it's OK if it's not so fast.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-1515309",
                          "updatedAt": "2022-08-30T17:25:52Z",
                          "publishedAt": "2021-10-21T15:55:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@LabrosV, as @bwspenc said above, we haven't looked at this much by ourselves. I see no obvious issue in using the explicit solver with plasticiticty. We are happy to hear about your experience with it.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-1517627",
                          "updatedAt": "2022-08-30T17:25:51Z",
                          "publishedAt": "2021-10-22T01:47:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LabrosV"
                          },
                          "bodyText": "Thank you @hugary1995. I'll take a look and share with you my experience.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-1517667",
                          "updatedAt": "2022-08-30T17:25:57Z",
                          "publishedAt": "2021-10-22T02:00:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @Traiwit\nI attach an example simulation where you can see the settings I use for dynamics simulations:\nCase2ResidualStress4umDynamic.zip\nMy experience is that dynamics simulations in moose work fine without explicit method, just use the PJFNK solver.\nExplicit dynamic simulations are useful for impact or other specialized simulations.\nIf you just want to see the wave dynamics, implicit is fine.\nMy experience is that convergence problem may arise from:\n\n\nNewmark parameters not set to the stable values, see here:\nhttps://mooseframework.inl.gov/modules/tensor_mechanics/Dynamics.html\n\n\nTime step must be set such that it takes about 20 time steps for a wave to cross the smallest element (calculate wave speed analytically). You need to check the same for the load you are applying, if the load is very fast.\n\n\nuse_displaced_mesh = false\nin the kernel leads to more stable simulations, but then it's an approximation\n\n\nCheck that density is set properly\n\n\nThe material model itself is less likely to give problems\nunless you have softening behaviour.\nTrust this helps\nBest Regards,\nNicol\u00f2 Grilli",
                  "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-693419",
                  "updatedAt": "2022-06-15T22:24:48Z",
                  "publishedAt": "2021-05-04T13:53:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thanks @ngrilli I will give it a go tmr morning\nJust wondering is it possible to use use_displaced_mesh = false with a large strain problem? and where should I activate this option? I see it can be placed at most of the [Materials] block.\nThank you\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-693521",
                          "updatedAt": "2022-06-15T22:24:52Z",
                          "publishedAt": "2021-05-04T14:11:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "Currently, you have to use the displaced mesh for finite strain. However, you may be interested in this PR that will allow running without it: #17475\nJust curious -- is the displaced mesh causing you trouble?",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-696369",
                          "updatedAt": "2022-06-15T22:24:52Z",
                          "publishedAt": "2021-05-05T00:20:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@bwspenc I don't think so, I'm just trying all the possible ways to make my simulation works. I am now back to implicit dynamic and trying to work around the plasticity.\nThanks anyway!",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-696374",
                          "updatedAt": "2022-06-15T22:24:52Z",
                          "publishedAt": "2021-05-05T00:24:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "If you're having trouble with plasticity, I would recommend looking at using the automatic differentiation (AD) versions of those models. We know that our Jacobians aren't great with the non-AD versions of the plasticity models, which is surely going to hurt convergence.",
                          "url": "https://github.com/idaholab/moose/discussions/17678#discussioncomment-699109",
                          "updatedAt": "2022-08-30T17:26:47Z",
                          "publishedAt": "2021-05-05T14:43:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Eigensolver executioner w/ cantilever proble (tensor_mechanics)?",
          "author": {
            "login": "mangerij"
          },
          "bodyText": "I have been poking around and was wondering if there is an example in the repo for the standard cantilever problem (bending) but solved with the eigenvalue solver.\nTherefore, one would obtain the modes (frequencies and eigenvectors of displacements for disp_x disp_y disp_z).\nthanks",
          "url": "https://github.com/idaholab/moose/discussions/19077",
          "updatedAt": "2022-06-30T13:39:34Z",
          "publishedAt": "2021-10-12T13:13:18Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc @jiangwen84",
                  "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1478178",
                  "updatedAt": "2022-06-30T13:39:34Z",
                  "publishedAt": "2021-10-14T16:28:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "There isn't an example of this.  The eigensolver doesn't work for mechanics.  I think @cbolisetti has looked into this and might have a branch that solves a problem like this.",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1484407",
                          "updatedAt": "2022-06-30T13:39:38Z",
                          "publishedAt": "2021-10-15T18:42:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "Yes, I don't think we cam solve this with the current moose or TM. @sveerara has created the necessary objects for this but it was never merged.  You can find tests in this branch\nhttps://github.com/sveerara/moose/tree/eigen\nYou'll have to compile with slepC to use this though.",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1499785",
                          "updatedAt": "2022-06-30T13:39:38Z",
                          "publishedAt": "2021-10-19T04:13:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "Very cool. I will poke around. Is there any reason why it wasn't merged?",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1501860",
                          "updatedAt": "2022-06-30T13:39:39Z",
                          "publishedAt": "2021-10-19T11:39:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "I am don't know unfortunately. May be @fdkong knows.",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1515595",
                          "updatedAt": "2022-08-31T06:57:33Z",
                          "publishedAt": "2021-10-21T16:44:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "The eigen solver is general, and it will work for general problems.\nBut the issue we have is that physics kernels such as TM can not really form an exact matrix that is required by SLEPc.  Most of eigen sovlers are based on matrix. We have a matrix-free version, but that generate only one eigenvalue",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1516838",
                          "updatedAt": "2022-08-31T06:57:33Z",
                          "publishedAt": "2021-10-21T20:59:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Now that we have AD, shouldn't the matrix be accurate?",
                          "url": "https://github.com/idaholab/moose/discussions/19077#discussioncomment-1517600",
                          "updatedAt": "2022-11-17T22:29:02Z",
                          "publishedAt": "2021-10-22T01:40:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Recent MOOSE News",
          "author": {
            "login": "aeslaughter"
          },
          "bodyText": "Sep. 2021\nAug. 2021\nJuly 2021",
          "url": "https://github.com/idaholab/moose/discussions/18859",
          "updatedAt": "2021-10-21T21:54:42Z",
          "publishedAt": "2021-09-20T15:13:46Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Building my own element? (cohesive element)",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nMy team at work wants to investigate how to create our own element (cohesive element) by modifying pre-existing elements in moose.\nThis is for us to work around discontinuity in both tensor-mechanics and hydro problems, as we want our workflow to be as close as possible to what we do with Abaqus. ( I know MOOSE has the cohesive zone and the way to work with flow in fracture)\nI suspect that we have to do that via Libmesh and then import it to MOOSE following this method: https://mooseframework.inl.gov/help/faq/faq_build_libmesh.html\nPlease give us some suggestions on where should we start to look into this.\nThank you very much.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/18978",
          "updatedAt": "2022-07-29T15:50:23Z",
          "publishedAt": "2021-10-01T07:33:10Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Traiwit\nDepends, if you want to do this before the calculation you can use the Moose MeshGenerators to do this.\nhttps://mooseframework.inl.gov/syntax/Mesh/\nIf you want to do this during the calculation you can use the adaptivity system to do this.\nhttps://mooseframework.inl.gov/moose/syntax/Adaptivity/\nI dont think we have this feature currently. Note that libmesh does not support arbitraty polyhedra so you will be restricted to the elements supported by libmesh.\nhttps://libmesh.github.io/doxygen/index.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1427374",
                  "updatedAt": "2022-07-29T15:50:45Z",
                  "publishedAt": "2021-10-04T23:55:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think @Traiwit was asking about building his own element type, and I agree with him that seems to be libMesh-level development.",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1427556",
                          "updatedAt": "2022-07-29T15:50:50Z",
                          "publishedAt": "2021-10-05T01:05:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thanks guys,\n@hugary1995 so i should work on libmesh and just import it into MOOSE?\nas I can see they don't have a cohesive element, but they have an element creation there\n\nhttps://libmesh.github.io/examples/introduction_ex1.html",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1429751",
                          "updatedAt": "2022-07-29T15:50:50Z",
                          "publishedAt": "2021-10-05T12:00:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'm not a libMesh guy, @roystgnr is the expert. At the libMesh level, don't think of it as a cohesive element in the context of mechanics, it's just a lower dimensional face element connecting two neighboring volume eelements. @roystgnr can point you in the right direction of building such element.",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1430107",
                          "updatedAt": "2022-07-29T15:51:26Z",
                          "publishedAt": "2021-10-05T13:23:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh is a cohesive element a lower dimensional element between two elements or a merged element made of 2 elements? I thought the latter",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1430309",
                          "updatedAt": "2023-04-18T21:26:03Z",
                          "publishedAt": "2021-10-05T14:05:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Yeah, I'm a little confused there too.\nFor the former case: libMesh does support \"multi-manifold\" meshes, so e.g. you can have a sheet of 2D elements cutting through (or on the boundary of) a 3D mesh.  With Lagrange FE, you can connect the 2D elements to the neighboring elements' 3D nodes if you want their values to always match; with any FE you can have separate elements with their own (unique even if physically overlapping) nodes.\nFor the latter case: the only \"macroelement\" in libMesh is the Clough-Tocher triangle, and that had to be hand-coded (C1 continuity between subelements really constrains the function space there).  We don't have anything to let you create a larger element from a selection of smaller elements at runtime ... though I'd really like to add that someday; multiscale FEM is fantastic for complicated domains.",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1432490",
                          "updatedAt": "2023-04-18T21:26:25Z",
                          "publishedAt": "2021-10-05T21:44:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "oh is a cohesive element a lower-dimensional element between two elements or a merged element made of 2 elements? I thought the latter\n\nI thought it's the first case, but not necessary has to be  'lower dimension, but it has ~0 thickness\n\nhttps://abaqus-docs.mit.edu/2017/English/SIMACAEELMRefMap/simaelm-c-cohesiveusage.htm\nI see @arovinelli asked about this back in 2018, but I reckon Andrea has moved on and created his own version of the cohesive surface instead. https://groups.google.com/g/moose-users/c/hQkaOVbrm88\nbut yeah I would like to use the cohesive element in both hydro and mechanic (and maybe HM coupled) problems.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1433287",
                          "updatedAt": "2023-04-18T21:26:27Z",
                          "publishedAt": "2021-10-06T03:40:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "In my opinion, it is not trivial to add a cohesive element in libMesh and make it work seamlessly with MOOSE. That is the reason we originally implemented the DG-like CZM.  To large extend, the DG-like CZM is equivalent to the traditional CZM implementation in Abaqus.\nMaybe you could let us know why you want to implement traditional CZM? Are there any features that might be missing from the DG-like CZM? If so, we can probably add new features. That would be much easier to do than to reinvent the wheel.",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1433333",
                          "updatedAt": "2023-04-18T21:27:08Z",
                          "publishedAt": "2021-10-06T03:58:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "In my opinion, it is not trivial to add a cohesive element in libMesh and make it work seamlessly with MOOSE. That is the reason we originally implemented the DG-like CZM. To large extend, the DG-like CZM is equivalent to the traditional CZM implementation in Abaqus.\nMaybe you could let us know why you want to implement traditional CZM? Are there any features that might be missing from the DG-like CZM? If so, we can probably add new features. That would be much easier to do than to reinvent the wheel.\n\nHi @jiangwen84 sorry for a late reply, I've been discussing with my team about this.\nFirst of all, we are from Abaqus world where they have a cohesive element and this would be easier to implement to our existing complex meshes.\nSo we want to achieve a continuous solution field across several domains (domains are differently meshed, using tets and wedges). So there is no DG- or XFEM-approach needed. That would already be possible, however, due to the complexity of the discretization problem, we can only achieve those wedges to be flat [zero thickness] (the upper and lower triangle of the wedge share the same positions, but still have individual DOFs).\nThe zero thickness element will also make moose run into problems due to the invalid jacobean. See two pics attached to illustrate this.\n\n\nalthough we want to create an element that has zero thickness, we are not interested in modelling a discontinuity. We need to describe the behaviour of some material between adjacent tet-faces. This zone is in reality very thin compared to the surrounding material and the fact that we model it with zero-thickness in more or less a tweak to make it easier possible to introduce this zone at all.\nthe material we need to model needs its own state variable (damage, porosity etc) which means it must be able to be independently responding from the state of the adjacent surface due to its history.\n#################################################################\nwe previously used wedges elements + NodalConstraints to achieve what we want for the hydro problems using MOOSE, but it would be nicer to have a cohesive element especially for mechanical (and HM) simulations\n\n\n\nThe question now would be, we should we look into in order to create a new element (cohesive element), is there any example? Our team previously have implemented FE element in Abaqus, so as long as we know where to start, we should be able to do it (ofc with your support \ud83d\ude03 )\nKind regards,\nTraiwit\n@GiudGiud @roystgnr @hugary1995 @arovinelli",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1474815",
                          "updatedAt": "2023-04-18T21:27:08Z",
                          "publishedAt": "2021-10-14T06:03:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "So the idea here is that you have an infinitely thin element, e.g. a QUAD4 that's got two pairs of overlapping nodes, but you can't simply use an EDGE2 instead because you need 2 independent degrees of freedom for each variable on each node pair, but you also probably can't use a QUAD4 because the most basic FEM calculations are likely to break in a world where deta/dx or deta/dy is infinite?\nI'd start by just positioning nodes to give you an infinitely thin QUAD4 and then see exactly what breaks.  libMesh does allow nodes to overlap, even from the same element, but I'm sure it'll end up screaming at you at some point when we try to do an inverse_map() and discover the map isn't invertible.  On the other hand, if you don't see any screaming (we don't use inverse_map() willy-nilly, since it's expensive, and we do have elements like pyramids that are usable despite not having an invertible map everywhere) then you might be able to do what you want just by creating your own quadrature rule?",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1484857",
                          "updatedAt": "2023-04-18T21:30:04Z",
                          "publishedAt": "2021-10-15T20:27:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@roystgnr there are specific quadrature rules for cohesive elements that allow nodes to be coincident. So what you describe is correct.",
                          "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1485628",
                          "updatedAt": "2023-04-18T21:30:11Z",
                          "publishedAt": "2021-10-16T01:10:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@Traiwit  I am not fully convinced that we have to use cohesive element for your problems. DG-interface is discontinuous, but with appropriate constraint, the field is continuous before damage.   You can define any stateful material properties, such as damage, porosity, on the interface which are independent of adjacent  surface. In addition, you can probably solve a lower-dimension problem, e.g. fluid, on the interface.\nIn the meantime, I do not want to discourage you from exploring the cohesive element implementation in MOOSE. As @hugary1995 mentioned, creating element should be done in LibMesh and @roystgnr can provide you more insights. If my understanding is correct, the cohesive element can be standard quad in 2D with zero thickness, but the integration will be only performed in the middle line. Therefore, at minimum, the LibMesh needs to support zero thickness element type and new integration scheme for such element. @roystgnr is this hard to do? Thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/18978#discussioncomment-1480307",
                  "updatedAt": "2022-07-29T15:51:25Z",
                  "publishedAt": "2021-10-15T03:12:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "BISON \"Vectors are not the same length\" error",
          "author": {
            "login": "kloibz"
          },
          "bodyText": "New BISONer, first time poster:\nI am trying to run a metallic fuel simulation, but I am getting the above error message saying that \"Vectors are not the same length\" and I am unsure how to debug the error. I am recreating a file based off of a template file that has run and I know that my build of BISON is good because I am able to run the assessment files with no issue. So far I have gone line by line through my input file comparing and trying to find differences, but I am still stuck. Any debugging suggestions or useful interpretations from the error code that could point me to problem area?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/19165",
          "updatedAt": "2023-07-27T16:14:34Z",
          "publishedAt": "2021-10-21T00:50:30Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@kloibz Since this is a Bison related question, I suggest you send an email directly to bison-users@inl.gov We will answer your question there. Thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/19165#discussioncomment-1511814",
                  "updatedAt": "2023-07-27T16:14:34Z",
                  "publishedAt": "2021-10-21T02:46:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "kloibz"
                          },
                          "bodyText": "Okay, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/19165#discussioncomment-1515496",
                          "updatedAt": "2023-07-27T16:14:34Z",
                          "publishedAt": "2021-10-21T16:27:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question on computing a material vector",
          "author": {
            "login": "xueyang94"
          },
          "bodyText": "Hello,\nI am writing a material class, which can compute a vector of material properties, but I couldn't get the initialization right. I have tried _mat_name(declareProperty<std::vector<MaterialPropertyName>>(\"mat_names\")), _mat_prop(_some_num),  and then use a for loop to declare for example _mat_prop[i] = &declareProperty<Real>(_mat_name[i]).   The complier error is no matching constructor for initialization of 'std::vector<MaterialPropertyName>'. (The parent class is DerivativeMaterialInterface<Material>.)\nIs it possible at all for a material class to compute a material vector? If so, what would be the proper initialization and declaration syntax? I did not find an example material that does this. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/19152",
          "updatedAt": "2022-08-22T09:04:04Z",
          "publishedAt": "2021-10-19T17:40:33Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "It's possible. Please have a look at the GenericConstantMaterial, which defines a vector of Real material properties.\nhttps://github.com/idaholab/moose/blob/next/framework/src/materials/GenericConstantMaterial.C\nI think for mat_name you want to initialize the vector of names with a getParam<std::vector < MaterialPropertyName > >\nThen in the constructor body you want to make the calls to declare each property.\nI dont think declareProperty can be called with a vector of names like that, but I could be wrong",
                  "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1505116",
                  "updatedAt": "2022-08-22T09:04:05Z",
                  "publishedAt": "2021-10-19T22:40:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you need a material property vector instead of a vector of material properties, see the answer below",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1508482",
                          "updatedAt": "2022-08-22T09:04:09Z",
                          "publishedAt": "2021-10-20T13:37:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "Update:\nSince the vector of materials is computed in the material class, the _prop_values in GenericConstantMaterial cannot be pre-defined in the input file. However, based on the idea of declaring both the prop_name and prop_value, it is fairly easy to output a vector of material properties like this, in case someone needs it:\nparams.addRequiredParam<std::vector<MaterialPropertyName>>(\"some_names\", \"a description\");\nInitializer:\n_some_names(getParam<std::vector<MaterialPropertyName>>(\"some_names\")),\n_some_prop(_num),\nDeclare prop:\nfor (unsigned int i=0; i<_num; ++i)\n_some_prop[i] = &declareProperty<Real>(_some_names[i]);",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1511688",
                          "updatedAt": "2022-08-22T09:04:22Z",
                          "publishedAt": "2021-10-21T02:12:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Agreed, the treatment of values will have to be different. I m pointing to this material for the handling of the vectors.",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1511903",
                          "updatedAt": "2022-08-22T09:04:24Z",
                          "publishedAt": "2021-10-21T03:12:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @xueyang94\nThis is an example from my repository:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainCrystalPlasticityBackstress.C\nFor instance in the constructor, I declare:\n_rho_for(declareProperty<std::vector>(\"rho_for\")),\nThen I provide the dimension of the vector:\n_rho_for[_qp].resize(_nss);\nbefore starting using it.\nThen I initialise:\nfor (unsigned int i = 0; i < _nss; ++i) // initialise forest dislocation densities\n_rho_for[_qp][i] = _init_rho_for;\nTrust this helps,\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1507922",
                  "updatedAt": "2022-08-22T09:04:25Z",
                  "publishedAt": "2021-10-20T11:56:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "Thanks for your reply. In your repo, _rho_for is declared as a vector of 'Real'. However, I want to declare a vector of material properties, which can be output by name and taken by other materials or kernels in the input file. For example, in the input file, I want to have some_mat = \"mat1, mat2, mat3,..\" as one of my material class's parameters. This is similar but not exactly the same as what your code does. I appreciate your advice.\nXueyang",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1509514",
                          "updatedAt": "2022-08-22T09:04:33Z",
                          "publishedAt": "2021-10-20T16:01:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so you want to build a vector material property from a vector of material properties?\nLike mat1, mat2, mat3 are already defined, and you want to access them by just passing some_mat = \"mat1 mat2 mat3\" to a kernel",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1509759",
                          "updatedAt": "2022-08-22T09:04:33Z",
                          "publishedAt": "2021-10-20T16:39:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "@GiudGiud Not really. mat1, mat2, and mat3 are not already known. They should be computed by myMatClass, where they are the elements of a material vector. In the input file that uses myMatClass, it looks like:\n[something]\ntype = myMatClass\nsome_mat = \"mat1, mat2, mat3\"\n....\n[../]\nThis way, mat1, mat2, and mat3 can be used in the kernels. The diffusion kernel can take mat1 as the diffusivity:\n[Diffusion]\ntype = MatDiffusion\nvariable = u\ndiffusivity = mat1\n[../]\nmat2 and mat3 can also be used somewhere else in the kernels.",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1509970",
                          "updatedAt": "2022-08-22T09:04:34Z",
                          "publishedAt": "2021-10-20T17:19:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This feels like my first post is appropriate then.\nGenericConstantMaterial, GenericFunctionMaterial etc all do something like that.\nThe syntax for GenericConstantMaterial would be:\n[material_name]\n  type = GenericConstantMaterial\n  prop_names = \"mat1 mat2 mat3\"\n  prop_values = \"1 2 43\"\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1510006",
                          "updatedAt": "2022-08-22T09:04:39Z",
                          "publishedAt": "2021-10-20T17:28:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "@GiudGiud Yup, I was about the try the method in your post, but then I found another bug in my code. I am working on fixing that first. I will come back to this if I need more help. Thanks Guillaume!",
                          "url": "https://github.com/idaholab/moose/discussions/19152#discussioncomment-1510195",
                          "updatedAt": "2022-08-22T09:04:39Z",
                          "publishedAt": "2021-10-20T18:15:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cumulative function input every unit of time?",
          "author": {
            "login": "LukeFisherUKAEA"
          },
          "bodyText": "I have an initial condition function defined in a .csv file (e.g. a Gaussian) which is read in using the PiecewiseBilinear function.  I would like this function to be added to the system every time increment (e.g. 1 second), as a cumulative input to a variable.  For context, I am looking at modelling ion implantation and transport in a material, using a specific implantation profile.\nHas anyone succeeded in making this work?  As far as I am aware there is no functionality to \"activate\" a new input every unit time from the PiecewiseBilinear (or other .csv input) function, so I have been looking to see if there are other kernels that achieve this.  Any advice would be much appreciated.\nIt may be better to define this profile as a function within MOOSE, rather than reading in and interpolating from a .csv - this would also be possible.",
          "url": "https://github.com/idaholab/moose/discussions/19157",
          "updatedAt": "2022-10-10T19:49:43Z",
          "publishedAt": "2021-10-20T10:21:42Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Can you store the output of the function into an aux variable, then use an AccumulateAux to the accumulation in another variable ? https://mooseframework.inl.gov/source/auxkernels/AccumulateAux.html",
                  "url": "https://github.com/idaholab/moose/discussions/19157#discussioncomment-1508513",
                  "updatedAt": "2022-10-10T19:49:43Z",
                  "publishedAt": "2021-10-20T13:42:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "LukeFisherUKAEA"
                          },
                          "bodyText": "This looks promising, thanks, although it does return an error stating that the variable I am assigning the accumulation to \"does not exist in this system\".  Additionally, do you know if there is a way to control the rate of accumulation, i.e. time between input \"pulses\", if you like?",
                          "url": "https://github.com/idaholab/moose/discussions/19157#discussioncomment-1508786",
                          "updatedAt": "2022-10-10T19:50:06Z",
                          "publishedAt": "2021-10-20T14:21:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you paste your auxvariables block and your auxkernels block here please?\nAuxKernels can't act on anything else than auxiliary variables.\nNot natively. If you want to make a PR to add a function parameter to AccumulateAux for a rate that would be great.\nIf not, you can also use the SelfAux to save an old copy of the variable, then use a ParsedAux to do the accumulation with a rate",
                          "url": "https://github.com/idaholab/moose/discussions/19157#discussioncomment-1508825",
                          "updatedAt": "2022-10-10T19:50:07Z",
                          "publishedAt": "2021-10-20T14:29:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LukeFisherUKAEA"
                          },
                          "bodyText": "That'll be the issue, as i've just discovered with some experimenting - that AuxKernels will only act on AuxVariables and not non-linear variables.  I'll see what I can do with the ParsedAux.",
                          "url": "https://github.com/idaholab/moose/discussions/19157#discussioncomment-1508867",
                          "updatedAt": "2022-10-10T19:50:07Z",
                          "publishedAt": "2021-10-20T14:36:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "If you are dealing with a nonlinear variable, you need to add a source term. If you tell us the equation you are solving, we can advise you which kernel to use.",
                  "url": "https://github.com/idaholab/moose/discussions/19157#discussioncomment-1511628",
                  "updatedAt": "2022-10-10T19:50:46Z",
                  "publishedAt": "2021-10-21T01:46:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Is the memory usage dependent on the number of objects within the input file?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nI'm wondering if the memory usage is dependent on the number of objects within the input file?\nI was testing my hydro simulation on a large and complex mesh (5mill elements/1.3mill nodes).\nwhen I run the Steady-state test, I could run it with 20+ cores mpi (with 256gb RAM workstation), but then when I tried to run it with transient mode, with 120+ BCs objects and 120+ Control objects (the input file is shown below), the memory usage blew up and I couldn't run it with more than 10 cores mpi.\nBC block\n     [./drain_DRAINSRF_CUMSRFSET_Y2020_M07]\n     type = PorousFlowPiecewiseLinearSinkTC\n     variable = porepressure\n     boundary = 'DRAINSRF_CUMSRFSET_Y2020_M07'\n     pt_vals = '0 1e9'\n     multipliers = '0 1e9'\n     flux_function = 1e5\n     v = min\n      use_mobility = true\n      fluid_phase = 0\n     [../]\n     [./drain_DRAINSRF_CUMSRFSET_Y2020_M11]\n     type = PorousFlowPiecewiseLinearSinkTC\n     variable = porepressure\n     boundary = 'DRAINSRF_CUMSRFSET_Y2020_M11'\n     pt_vals = '0 1e9'\n     multipliers = '0 1e9'\n     flux_function = 1e5\n     v = min\n      use_mobility = true\n      fluid_phase = 0\n     [../]\nControl block\n    [water_grad_drain_DRAINSRF_CUMSRFSET_Y2020_M07]\n    type = ConditionalFunctionEnableControl\n    enable_objects = 'BCs::drain_DRAINSRF_CUMSRFSET_Y2020_M07'\n    conditional_function = 'if(t=5,1,0)'\n    execute_on = 'initial timestep_begin'\n    []\n    [water_grad_drain_DRAINSRF_CUMSRFSET_Y2020_M11]\n    type = ConditionalFunctionEnableControl\n    enable_objects = 'BCs::drain_DRAINSRF_CUMSRFSET_Y2020_M11'\n    conditional_function = 'if(t=6,1,0)'\n    execute_on = 'initial timestep_begin'\n    []\n\nFrom #18930 I remember @GiudGiud mentioned that:\n\nNot all systems in MOOSE are scalable, and MOOSE generally should not scale well with the input file length because every object is created by every process. Then based on the mesh distribution only some of the objects remain active locally.\n\nSo if that's the case, how should I work around this?\nIs it possible to modify the name/value within the block at each time step?\nfor example\nt =1 \n    boundary = 'DRAINSRF_CUMSRFSET_Y2020_M11'\n    enable_objects = 'BCs::drain_DRAINSRF_CUMSRFSET_Y2020_M07'\n    conditional_function = 'if(t=5,1,0)'\nt = 2 \n    boundary = 'DRAINSRF_CUMSRFSET_Y2020_M11'\n    enable_objects = 'BCs::drain_DRAINSRF_CUMSRFSET_Y2020_M11'\n    conditional_function = 'if(t=6,1,0)'\n\nI guess this could be done via Action, but would this solve the problem?\nThis is because at some point we would need to work with more than 500+ control/bc object, overcoming this issue at early stage would be nice.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/19144",
          "updatedAt": "2022-06-21T16:43:07Z",
          "publishedAt": "2021-10-19T01:21:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "Every processor holds its own set of kernels/bcs, etc. I think on average a kernel or a bc cost about 200kB memory (this number may not be very accurate). If we have 500 objects, the memory used for storing these objects on each processor would be 500*200kB=100MB. This memory is not scalable and an overhead. We met the situation in radiation transport and we ended up re-implement the kernels with array variable/kernel, which significantly reduced the number of kernels. I think MOOSE block restriction can introduce significant memory overhead as well if you have lots of mesh blocks (subdomains). In such cases, you may want to consider minimizing the number of mesh blocks by merging some of them without affecting your calculation if possible. Same applies to mesh boundaries. Unfortunately I cannot provide exact numbers to support my solutions here but that should give you a rough idea. Not sure if the latest live print capability can show you where the memory hot spots are. Another useful parameter is Debug/show_actions that can print the memory usage at the beginning of each action. Hope these help.",
                  "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1499405",
                  "updatedAt": "2022-06-21T16:43:08Z",
                  "publishedAt": "2021-10-19T01:35:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think the show_actions log will be important here. 25 gb per rank seems very excessive.",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1499542",
                          "updatedAt": "2022-06-21T16:43:13Z",
                          "publishedAt": "2021-10-19T02:28:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi guys, I'm sending part that the memory is blowing up below, i think it mainly comes from the 400,000 constraints blocks that I got in the action that i created @GiudGiud\na quick note that, I think this mesh I'm using has 1500 subdomains\n[DBG][ACT] TASK ( execute_mesh_generators) TYPE (           ExecuteMeshGenerators) NAME (                ) Memory usage 167MB\n..............................................\n[DBG][ACT] TASK (       recover_meta_data) TYPE (      SetupRecoverFileBaseAction) NAME (                ) Memory usage 4796MB\n[DBG][ACT] TASK (           set_mesh_base) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 4796MB\n[DBG][ACT] TASK (     attach_geometric_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 4796MB\n[DBG][ACT] TASK (               init_mesh) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 4796MB\n[DBG][ACT] TASK (            prepare_mesh) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 4796MB\n[DBG][ACT] TASK (                  add_ic) TYPE (       AddInitialConditionAction) NAME (    porepressure) Memory usage 5269MB\n[DBG][ACT] TASK (          add_constraint) TYPE (                           MPCbe) NAME (           MPCbe) Memory usage 5269MB\n.\n.\n.\nStill Setting Up............\n[DBG][ACT] TASK (     add_preconditioning) TYPE (       SetupPreconditionerAction) NAME (             SMP) Memory usage 19236MB\n[DBG][ACT] TASK (           ready_to_init) TYPE (                     EmptyAction) NAME (                ) Memory usage 19236MB\n[DBG][ACT] TASK (           setup_dampers) TYPE (              SetupDampersAction) NAME (                ) Memory usage 19236MB\n[DBG][ACT] TASK (    setup_residual_debug) TYPE (        SetupResidualDebugAction) NAME (           Debug) Memory usage 19236MB\n[DBG][ACT] TASK (         copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (    porepressure) Memory usage 19236MB\n[DBG][ACT] TASK (          add_aux_kernel) TYPE (            MaterialOutputAction) NAME (                ) Memory usage 19545MB\n[DBG][ACT] TASK (  coupling_functor_check) TYPE (      CouplingFunctorCheckAction) NAME (coupling_functor_check) Memory usage 19545MB\n[DBG][ACT] TASK (            init_problem) TYPE (               InitProblemAction) NAME (                ) Memory usage 19545MB\n\n  Initializing\n    Updating Because Mesh Changed\n      Updating Mesh..\n        Building Node List                                                               [ 10.50 s] [    1 MB]\n        Finished Building Boundary Elements List                                         [  9.16 s] [    0 MB]\n      Still Updating Mesh.                                                               [ 53.11 s] [    1 MB]\n    Finished Updating Because Mesh Changed                                               [ 53.52 s] [  127 MB]\n      Building Node To Elem Map                                                          [  8.43 s] [  304 MB]\n    Still Initializing Equation Systems.....                                             [ 52.58 s] [ 3800 MB]\n[DBG][ACT] TASK (             add_control) TYPE (                AddControlAction) NAME (water_grad_drain_DRAINSRF_CUMSRFSET_Y2012) Memory usage 24030MB\n[DBG][ACT] TASK (             add_control) TYPE (                AddControlAction) NAME (water_grad_drain_DRAINSRF_CUMSRFSET_Y2015) Memory usage 24030MB\n[DBG][ACT] TASK (             add_control) TYPE (                AddControlAction) NAME (water_grad_drain_DRAINSRF_CUMSRFSET_Y2019) Memory usage 24031MB\n[DBG][ACT] TASK (             add_control) TYPE (                AddControlAction) NAME (water_grad_drain_DRAINSRF_CUMSRFSET_Y2020_M07) Memory usage 24031MB\n\nso mesh generator 167 > 4800\nconstraints 5250 > 19000\nInitProblemAction 19000 > 24000\nYeah @GiudGiud looks like it's ~25GB per rank which is mainly from constraints (guess nothing I can do about this unless there is a way to optimise it)",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1499663",
                          "updatedAt": "2022-06-21T16:43:13Z",
                          "publishedAt": "2021-10-19T03:24:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So 5GB roughly for the mesh, and 5GB for the equation system. Then 14GB for the constraints.\nExcept the first two can be split among all processes, while the last one currently is not.\nReworking the constraint to work with a single constraint dealing with large lists of nodes is an option, but it will require modifying the routines handling the contribution to residuals & jacobian.\nI think the easier option here would be to modify your constraints Action to make it only add constraints that are local to each process. So pass a mesh argument to this action and look for the nodes in the local mesh (mesh.get_active_node_ptr_range or something like that) and only add if the constraint is local or partially local to each process.",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1499678",
                          "updatedAt": "2022-06-21T16:43:18Z",
                          "publishedAt": "2021-10-19T03:31:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Except the first two can be split among all processes, while the last one currently is not\n\nwhat do you mean by 'split among all processes', I thought this 5 5 14 gbs are per core already.\n\nI think the easier option here would be to modify your constraints Action to make it only add constraints that are local to each process. So pass a mesh argument to this action and look for the nodes in the local mesh (mesh.get_active_node_ptr_range or something like that) and only add if the constraint is local or partially local to each process.\n\n@GiudGiud I reckon this is the ideal solution, if we do this, let's say we have 10 local meshes, then it will only be 1.4gbs per core? Is there any example of doing this?\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1505330",
                          "updatedAt": "2022-06-21T16:43:51Z",
                          "publishedAt": "2021-10-20T00:11:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not that I know of. @rwcarlsen do you know anyone doing that?\nRoughly. It wont be perfectly split since some constraints will be split between two domains. But it should be pretty close",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1505338",
                          "updatedAt": "2022-06-21T16:43:54Z",
                          "publishedAt": "2021-10-20T00:15:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We've chatted about it and one thing you ll have to be mindful of is not to repartition during the simulation. There may be other difficulties if you end up with a process with 0 constraint, so make sure to have at least one on each process, even if it s inactive (because it uses nodes that are not on the process' mesh)",
                          "url": "https://github.com/idaholab/moose/discussions/19144#discussioncomment-1510958",
                          "updatedAt": "2022-06-21T16:43:55Z",
                          "publishedAt": "2021-10-20T21:34:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mesh file for input",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Hello, I have a question about mesh file for input.\nAfter running a moose, I can export the output file as *.e format, and\nmoose supports *.e file as a mesh(https://mooseframework.inl.gov/source/mesh/FileMesh.html).\nWhat I am curious about is \"if *.e file itself includes several results (e.g., t=0, result1, t=0.1, result2, t=0.2, result 3,...)\",\nhow can I use a mesh at a specific time step?\n(for example, I got a *.e file includes 8 results (time steps), but I want to use the mesh at time step 4)\nI appreciate your help.\nSincerely,\nHokon Kim",
          "url": "https://github.com/idaholab/moose/discussions/19097",
          "updatedAt": "2022-07-09T08:28:00Z",
          "publishedAt": "2021-10-13T22:25:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @hokonkim\nIf what you mean is that you want to use a \"deformed\" mesh from a mechanics simulation,\nthen the way to go is the restart option:\nhttps://mooseframework.inl.gov/application_usage/restart_recover.html\nYou can import the displacement variables from a previous simulation at the last time step\nand then you run a new simulation based on that initial displacement/deformation.\nYou can see an example of restart a mechanics simulation in my github, using the SolutionUserObject:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/test/tests/DeleteElementsRestart/DummyVarRestart.i\nOtherwise if you read the mesh from an .e file, you will always get the mesh from which the previous simulation started,\nif you don't reinitialise the displacement,\nI may be wrong in the case of mesh refinement.\nIf you are not talking about mechanics simulations,\nthen I am not sure what you mean.\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1473767",
                  "updatedAt": "2022-07-07T04:43:56Z",
                  "publishedAt": "2021-10-13T23:15:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "I was taking a look at what you suggested.\nWhat I want to do is \"using deformed mesh after applying postprocessor\"\nSpecifically, at first input file..\n[Materials]\n  [./tpbActivity]\n    type  = ParsedMaterial\n    block = 'PT_TPB_TET4'\n    f_name = 'tpbActivity_S0'\n    postprocessor_names = 'j_YSZ_bottom Poisoned'\n    function = 'if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818), 4818)'\n    args = 'aux_eta_tpb'\n  [../]\n[]    \n\nAfter the first input file, I expected an output file which includes the deformed (postprocessor applied) mesh.\nSo, I made another input file to use this deformed mesh like below.\n[Mesh]\n  [./file]\n    type = FileMeshGenerator\n    file = outputs/tpb_gan0108_2021-10-15-00:26-04.e\n  [../]\n[]\n\n[Materials]\n  [./tpbActivity]\n    type  = ParsedMaterial\n    block = 'PT_TPB_TET4'\n    f_name = 'tpbActivity_S0'\n    function = '4818'\n  [../]\n[]\n\n[UserObjects]\n  [./soln]\n    type = SolutionUserObject\n    mesh = outputs/tpb_gan0108_2021-10-15-00:26-04.e\n    timestep = 'LATEST'\n  [../]\n[]\n\nBut, I'm stuck on how to initialize the \"tpbActivity\" from the previous output file.\nHow can I fix this problem?\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1480960",
                          "updatedAt": "2022-07-07T04:43:59Z",
                          "publishedAt": "2021-10-15T06:20:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What is tpbActivity_S0 ? It's a function that is constant or comes from the previous solution?",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1483441",
                          "updatedAt": "2022-07-07T04:44:02Z",
                          "publishedAt": "2021-10-15T15:12:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "tpbActivity(named as \u201ctpbActivity_S0) is an assigned material property.\nDepending on a certain condition, it would be either activated or deactivated.\nInitializing material property from previous simulation is what I need, I think.",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1483527",
                          "updatedAt": "2022-07-07T04:44:02Z",
                          "publishedAt": "2021-10-15T15:29:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah my bad ParsedMaterial args are not clear. I ll rework that\nYou can use the Controls system to activate / deactivate blocks or control their value.\nhttps://mooseframework.inl.gov/syntax/Controls/index.html\nYou could use a SolutionFunction if the function can be initialized from a field/variable that is defined in the previous simulation\nhttps://mooseframework.inl.gov/source/functions/SolutionFunction.html",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1483860",
                          "updatedAt": "2022-07-09T08:29:03Z",
                          "publishedAt": "2021-10-15T16:43:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Is there a way to store Material properties (ParsedMaterial) and use stored material properties as initial value?\nI tried to store the material properties (MaterialRealAux), but it didn't work...\nI think, if I can store the material property as variable (or aux_variable), then I could use SolutionUserObject...\nAdditionally...(part of input)\nI tried to run an application as below.. but, it didn't work...\nAs far as I know, Output of Material properties is enabled by setting the \"outputs\" parameter.\nCan I extract this value from output(*.e) file and import to another input file?\nWhat will be the best solution for me?\n[Functions]\n  [./aux_eta_tpb_ic]\n    type = SolutionFunction\n    solution = soln_aux_eta_tpb\n  [../]\n[]\n\n[Materials]\n  [./tpbActivity]\n    type  = ParsedMaterial\n    block = 'PT_TPB_TET4'\n    f_name = 'tpbActivity_S0'\n    function = 'if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818), 4818)'\n    args = 'aux_eta_tpb'\n    postprocessor_names = 'j_YSZ_bottom Poisoned'\n    outputs = exodus\n  [../]\n[]\n\n[UserObjects]\n  [./soln_aux_eta_tpb]\n    type = SolutionUserObject\n    mesh = outputs/tpb_gan0108_2021-10-15-18:38-25.e\n    timestep = 'LATEST'\n    system_variables = aux_eta_tpb\n  [../]\n[]\n\n[AuxVariables]\n  [./prev_aux_eta_tpb]\n  [../]\n[]\n\n[AuxKernels]\n  [./soln_eta_tpb]\n    type = SolutionAux\n    solution = soln_aux_eta_tpb\n    variable = prev_aux_eta_tpb\n    direct = true\n    execute_on = 'initial'\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1485972",
                          "updatedAt": "2022-07-09T08:29:03Z",
                          "publishedAt": "2021-10-16T06:00:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can do that., just use a MaterialRealAux to save the material property to an AuxVariable, then it will be saved to the solution file.\nAn other option, a little convoluted, is to save it to exodus (through an aux variable as well, but then you can use outputs='exodus' in the material property) then use that system to reload that into a variable, then into the material property",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1487013",
                          "updatedAt": "2023-09-26T17:36:33Z",
                          "publishedAt": "2021-10-16T14:51:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "When I used MaterialRealAux like below\n[Functions]\n  [./tpbActivity]\n    type  = ParsedMaterial\n    block = 'PT_TPB_TET4'\n    f_name = 'tpbActivity_S0'\n    function = 'if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818), 4818)'\n    args = 'aux_eta_tpb'\n    postprocessor_names = 'j_YSZ_bottom Poisoned'\n    # Make values see at output(*.e) file\n    outputs = exodus\n  [../]\n[]\n\n[AuxVariables]\n  [./cp_tpbActivity_S0]\n  [../]\n[]\n\n[AuxKernels]\n  [./copy_tpbActivity_S0]\n    type = MaterialRealAux\n    property = 'tpbActivity_S0'\n    variable = cp_tpbActivity_S0\n    execute_on = 'initial'\n  [../]\n[]\n\nI got an error like this.\n*** ERROR ***\nThe following error occurred in the object \"copy_tpbActivity_S0\", of type \"MaterialRealAux\".\nNodal AuxKernel 'copy_tpbActivity_S0' attempted to reference material property 'property'\nConsider using an elemental auxiliary variable for 'cp_tpbActivity_S0'.\nAlso, when I tried another way (using exodus file), 'tpbActivity_S0' cannot be specificed..\nI can see the 'tpbActivity_S0' in the output file, but I cannot use that name through SolutionUserObject.\nDid I miss something?",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1487493",
                          "updatedAt": "2023-09-26T17:36:33Z",
                          "publishedAt": "2021-10-16T17:36:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Now, I got a previous \"tpbActivity_S0\" with the input below.\n[UserObjects]\n  [./soln_tpbActivity_S0]\n    type = SolutionUserObject\n    mesh = outputs/tpb_gan0108_2021-10-15-18:38-25.e\n    timestep = 'LATEST'\n    system_variables = tpbActivity_S0\n  [../]\n[]\n\n[AuxVariables]\n  [./prev_tpbActivity_S0]\n    # Specifies the family of FE shape functions to use for this variable.\n    # If the variable family is MONOMIAL then the AuxKernel will behave as an elemental.\n    # Especially, Material property is \"elemental\", not \"nodal\".\n    family = MONOMIAL\n    order = CONSTANT\n    block = 'PT_TPB_TET4'\n  [../]\n[]\n\n[AuxKernels]\n  [./soln_tpbActivity]\n    type = SolutionAux\n    solution = soln_tpbActivity_S0\n    variable = prev_tpbActivity_S0\n    direct = true\n    execute_on = 'initial'\n  [../]\n[]\n\nI am still struggling to initialize material property with \"prev_tpbActivity_S0\".\nI want to use the \"prev_tpbActivity_S0\" as initial material property condition, and\napply the function( 'if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818), 4818)' ) depending on time step.\nI have no idea how to apply both (material initialization & apply function)....\nbecause\n*** ERROR ***\nInvalid function\nif(time_check = 0, prev_tpbActivity_S0, if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818)))\naux_eta_tpb,prev_tpbActivity_S0,time_check,j_YSZ_bottom,Poisoned\nin ParsedMaterialHelper.\nIllegal number of parameters to function\nAre there any tips for me?\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1487911",
                          "updatedAt": "2023-09-26T17:36:36Z",
                          "publishedAt": "2021-10-16T20:59:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So for your first message, last part:\nthe solutionUO and the exodus are completely separate ways of restarting. When needed (and it should be avoidable most of the time) you can restart some fields using one and others using the other, but they act very separately. See more info here:\nhttps://mooseframework.inl.gov/application_usage/restart_recover.html\nFor the second message,\ncan you paste your ParsedMaterial block here? To check the other arguments.\nIt seems one of your if statements is missing an argument, they should all have 3 arguments\nif(time_check = 0, prev_tpbActivity_S0, if(-j_YSZ_bottom > 1, if(aux_eta_tpb > Poisoned, 0, 4818), MISSING option))",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1491463",
                          "updatedAt": "2022-12-08T21:00:07Z",
                          "publishedAt": "2021-10-18T05:25:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Here are some parts of input file.\n\n\nUse original mesh + \"previous result from output(exodus) file\"\n[Mesh]\n  [./file]\n    type = FileMeshGenerator\n    file = outputs/original.inp\n  [../]\n[]\n\n[Materials]\n  [./tpbActivity]\n    type  = ParsedMaterial\n    block = 'PT_TPB_TET4'\n    f_name = 'tpbActivity_S0'\n    # function = 'if(prev_tpbActivity_S0 > 0, if(-j_YSZ_bottom > 1, if(aux_eta_tpb > 0.163 * 0.92, 0, 4818) 4818), 0)'\n    function = 'if(prev_tpbActivity_S0 > 0, if(aux_eta_tpb > Poisoned, 0, 4818), 0)'\n    args = 'aux_eta_tpb prev_tpbActivity_S0'\n    postprocessor_names = 'Poisoned'\n    # Make values see at output(*.e) file\n    outputs = exodus\n  [../]\n[]\n\n[UserObjects]\n  [./soln_tpbActivity_S0]\n    type = SolutionUserObject\n    mesh = outputs/tpb_gan0108_2021-10-15-18:38-25.e\n    timestep = 'LATEST'\n    system_variables = tpbActivity_S0\n  [../]\n[]\n\n\n[AuxVariables]\n  [./aux_eta_tpb]\n    block = 'PT_TPB_TET4'\n  [../]\n\n  [./prev_tpbActivity_S0]\n    # Specifies the family of FE shape functions to use for this variable.\n    # If the variable family is MONOMIAL then the AuxKernel will behave as an elemental.\n    # Especially, Material property is \"elemental\", not \"nodal\".\n    family = MONOMIAL\n    order = CONSTANT\n    block = 'PT_TPB_TET4'\n  [../]\n[]\n\n[AuxKernels]\n  [./eta_tpb]\n    type = ParsedAux\n    variable = aux_eta_tpb\n    block = 'PT_TPB_TET4'\n    function = '-R * T / 4 / F * log(7e-21 / p_O2) - (phi_LSM - phi_YSZ + 0.03607)'\n    constant_names = 'R T F'\n    constant_expressions = '8.3144598 1073 96485.33289' # (J/K/mol), (K), (C/mol)\n    args = 'p_O2 phi_LSM phi_YSZ'\n  [../]\n\n  [./soln_tpbActivity]\n    type = SolutionAux\n    solution = soln_tpbActivity_S0\n    variable = prev_tpbActivity_S0\n    direct = true\n    execute_on = 'initial'\n  [../]\n[]\n\n[Postprocessors]\n  [./eta_total]\n    type = FunctionValuePostprocessor\n    function = 'funcOverpotential'\n    outputs = 'console csv'\n  [../]\n\n  [./Poisoned]\n    type = ParsedPostprocessor\n    function = 'eta_total * 0 + poison * 0.92' # If you want to control the standard for poisoning, then change the number (0 ~ 1.0)\n    pp_names = 'eta_total'\n    constant_names = 'poison'\n    constant_expressions = '0.163'\n    outputs = 'console csv'\n  [../]\n[]\n\n\n\nThis was the best that I can do now.\nStill, I wonder if the function in ParsedMaterial can use the function (commented out).\nI tried.. but it didn't work (MOOSE didn't allow several if statements and several parameters..)\nAre there ways to use several parameters or if-statement?\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/19097#discussioncomment-1503979",
                          "updatedAt": "2023-02-01T13:52:43Z",
                          "publishedAt": "2021-10-19T17:42:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}