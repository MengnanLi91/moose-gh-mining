{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wMy0xNVQyMjowNzoxNi0wNTowMM4AMfdh"
    },
    "edges": [
      {
        "node": {
          "title": "[ADKernel][Custom Kernel Problem][adCoupledGradient error]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Dear Moose users,\nI am trying to make a simple ADKernel in moose application.\nBut I have a problem with adCoupledGradient term!\nWhen I am trying to compile it, the following error has pop up.\nIn file included from /opt/moose/moose/scripts/../libmesh/installed/include/metaphysicl/dualnumberarray.h:32:0,\nfrom /opt/moose/moose/framework/build/header_symlinks/NumberArrayOps.h:14,\nfrom /opt/moose/moose/framework/build/header_symlinks/DualRealOps.h:18,\nfrom /opt/moose/moose/framework/build/header_symlinks/ADReal.h:13,\nfrom /opt/moose/moose/framework/build/header_symlinks/MooseTypes.h:13,\nfrom /opt/moose/moose/framework/build/header_symlinks/InputParameters.h:15,\nfrom /opt/moose/moose/framework/build/header_symlinks/MooseObject.h:13,\nfrom /opt/moose/moose/framework/build/header_symlinks/ResidualObject.h:12,\nfrom /opt/moose/moose/framework/build/header_symlinks/KernelBase.h:12,\nfrom /opt/moose/moose/framework/build/header_symlinks/ADKernel.h:12,\nfrom /home/crud_kaist1/projects/CCA-E/build/header_symlinks/ChargeT.h:3,\nfrom /home/crud_kaist1/projects/CCA-E/src/kernels/ChargeT.C:1,\nfrom /home/crud_kaist1/projects/CCA-E/build/unity_src/kernels_Unity.C:2:\n/opt/moose/moose/scripts/../libmesh/installed/include/metaphysicl/dualnumber_decl.h: In instantiation of \u2018static T MetaPhysicL::DualNumberConstructor<T, D, asd>::value(const T2&) [with T2 = libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::NumberArray<50ul, double>, true> >; T = double; D = MetaPhysicL::NumberArray<50ul, double>; bool asd = true]\u2019:\n/opt/moose/moose/scripts/../libmesh/installed/include/metaphysicl/dualnumber.h:202:53:   required from \u2018MetaPhysicL::DualNumber<T, D, asd>::DualNumber(const T2&) [with T2 = libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::NumberArray<50ul, double>, true> >; T = double; D = MetaPhysicL::NumberArray<50ul, double>; bool asd = true]\u2019\n/home/crud_kaist1/projects/CCA-E/src/kernels/ChargeT.C:39:85:   required from here\n/opt/moose/moose/scripts/../libmesh/installed/include/metaphysicl/dualnumber_decl.h:170:40: error: cannot convert \u2018const libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::NumberArray<50ul, double>, true> >\u2019 to \u2018double\u2019 in return\nstatic T value(const T2& v) { return v; }\n^\n/opt/moose/moose/scripts/../libmesh/installed/include/metaphysicl/dualnumber_decl.h: In static member function \u2018static T MetaPhysicL::DualNumberConstructor<T, D, asd>::value(const T2&) [with T2 = libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::NumberArray<50ul, double>, true> >; T = double; D = MetaPhysicL::NumberArray<50ul, double>; bool asd = true]\u2019:\n/opt/moose/moose/scripts/../libmesh/installed/include/metaphysicl/dualnumber_decl.h:170:43: error: control reaches end of non-void function [-Werror=return-type]\nstatic T value(const T2& v) { return v; }\n^\ncc1plus: some warnings being treated as errors\nmake: *** [/home/crud_kaist1/projects/CCA-E/build/unity_src/kernels_Unity.x86_64-pc-linux-gnu.opt.lo] Error 1\n\nI can't understand what's this error...\nHow can I fix this error?\nIf I eliminate adCoupledGradient terms, the kernel works fine.\nThe following is .c and .h file of my custom ADKernel.\n\n#pragma once\n#include \"ADKernel.h\"\nclass ChargeT;\ntemplate <>\nInputParameters validParams();\nclass ChargeT : public ADKernel\n{\npublic:\nstatic InputParameters validParams();\nChargeT(const InputParameters & parameters);\nprotected:\nvirtual ADReal computeQpResidual();\nconst ADVariableValue & _EP;\nconst ADVariableValue & _T;\nReal _z;\nReal _D;\nconst Real _F;\nconst Real _R;\nconst ADVariableGradient & _grad_EP;\n};\n#include \"ChargeT.h\"\n#include \"MooseVariable.h\"\nregisterMooseObject(\"corrosionApp\",ChargeT);\ntemplate<>\nInputParameters\nvalidParams()\n{\nInputParameters params = validParams();\nparams.addClassDescription(\"Compute the migration term.\");\nparams.addRequiredCoupledVar(\"Potential\", \"Potential of solution\");\nparams.addRequiredCoupledVar(\"Temperature\", \"Temperature of solution\");\nparams.addRequiredParam(\"Charge\", \"Charge of chemical species\");\nparams.addRequiredParam(\"Diffusion_coef\", \"Charge of chemical species\");\nreturn params;\n}\nChargeT::ChargeT(const InputParameters & parameters)\n: ADKernel(parameters),\n_EP(adCoupledValue(\"Potential\")),\n_T(adCoupledValue(\"Temperature\")),\n_z(getParam(\"Charge\")),\n_D(getParam(\"diffusion_coef\")),\n_F(964800),\n_R(8.314),\n_grad_EP(adCoupledGradient(\"Potential\"))\n\n{\n}\nADReal\nChargeT::computeQpResidual()\n{\nreturn -_test[_i][_qp] * _D * _z * _F / ( _R * _T[_qp] ) * _u[_qp]  * _grad_EP[_qp];\n}",
          "url": "https://github.com/idaholab/moose/discussions/16406",
          "updatedAt": "2022-08-26T12:44:54Z",
          "publishedAt": "2020-12-07T07:02:15Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "coskrrb2002"
                  },
                  "bodyText": "Never mind!\nI found my mistake in here",
                  "url": "https://github.com/idaholab/moose/discussions/16406#discussioncomment-148917",
                  "updatedAt": "2022-08-26T12:45:05Z",
                  "publishedAt": "2020-12-07T13:04:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "Can you please post the mistake so others searching the forum can see the answer?",
                          "url": "https://github.com/idaholab/moose/discussions/16406#discussioncomment-149050",
                          "updatedAt": "2022-08-26T12:45:05Z",
                          "publishedAt": "2020-12-07T15:45:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "was probably getParam and addParam missing their template specialization",
                  "url": "https://github.com/idaholab/moose/discussions/16406#discussioncomment-491828",
                  "updatedAt": "2022-08-26T12:45:05Z",
                  "publishedAt": "2021-03-17T03:11:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Changing the name of an input file will affect the results ?!",
          "author": {
            "login": "Xelver"
          },
          "bodyText": "Hey guys,\nI've met a very weird problem recently.\nI built an input file named 'test.i' and it could run well.\nHowever, when I changed its name to 'test_th.i', there was an error 'segmental fault'.\nIf I change its name to 'test_t.i', it ran well again.... (The input file is attached)\ntest_t.txt\nI find the problem very tricky...\nThe version of my MOOSE is: (Ubuntu 16.04)\ncommit db9be3f\nMerge: 07f96ea 6984549\nAuthor: moosetest bou...@inl.gov\nDate:   Mon Mar 11 12:38:45 2019 -0600\nThanks a lot\nFengrui Xiang",
          "url": "https://github.com/idaholab/moose/discussions/16216",
          "updatedAt": "2021-03-17T02:59:51Z",
          "publishedAt": "2020-11-17T01:28:49Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "It might help to see a list of all files in the directory you're running the simulation in.",
                  "url": "https://github.com/idaholab/moose/discussions/16216#discussioncomment-131273",
                  "updatedAt": "2020-11-17T03:10:42Z",
                  "publishedAt": "2020-11-17T03:10:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Xelver"
                          },
                          "bodyText": "Thanks for your reply.\nActually, there's nothing special in the directory. I just created a new App and activated the HeatCondution Modulus.",
                          "url": "https://github.com/idaholab/moose/discussions/16216#discussioncomment-132144",
                          "updatedAt": "2020-11-18T01:06:41Z",
                          "publishedAt": "2020-11-18T01:06:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Closing as stale.\nFor the record, changing the name of the input file does not influence results.",
                  "url": "https://github.com/idaholab/moose/discussions/16216#discussioncomment-491804",
                  "updatedAt": "2021-03-17T02:59:36Z",
                  "publishedAt": "2021-03-17T02:59:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "segmentation fault",
          "author": {
            "login": "Bala-1005"
          },
          "bodyText": "Hello everyone,\nI am combining phase field and crystal plasticity on moose and the simulation seems to be working well for some time and then stops citing segmentation fault. I followed the debugging process given on moose framework website and built a debug object file and then ran the file again. I obtained the following error.\n**Time Step 5, time = 0.023, dt = 0.008\n[New Thread 0x7fffc6eb2700 (LWP 56706)]\n[Thread 0x7fffc6eb2700 (LWP 56706) exited]\n[New Thread 0x7fffc6eb2700 (LWP 56715)]\n[Thread 0x7fffc6eb2700 (LWP 56715) exited]\n[New Thread 0x7fffc6eb2700 (LWP 56719)]\n[Thread 0x7fffc6eb2700 (LWP 56719) exited]\n[New Thread 0x7fffc6eb2700 (LWP 56747)]\n/export/apps/gcc-7.4.0/include/c++/7.4.0/debug/vector:417:\nError: attempt to subscript container with out-of-bounds index 0, but\ncontainer only holds 0 elements.\nObjects involved in the operation:\nsequence \"this\" @ 0x0x208f4c8 {\ntype = std::__debug::vector<RankTwoTensorTempl, std::allocator<RankTwoTensorTempl > >;\n}\nProgram received signal SIGABRT, Aborted.\n0x00007fffdeed1337 in raise () from /lib64/libc.so.6\nMissing separate debuginfos, use: debuginfo-install glibc-2.17-292.el7.x86_64 infinipath-psm-3.3-26_g604758e_open.2.el7.x86_64 libX11-1.6.7-2.el7.x86_64 libXau-1.0.8-2.1.el7.x86_64 libfabric-1.7.0-1.el7.x86_64 libibumad-22.1-3.el7.x86_64 libibverbs-22.1-3.el7.x86_64 libnl3-3.2.28-4.el7.x86_64 libpsm2-11.2.78-1.el7.x86_64 librdmacm-22.1-3.el7.x86_64 libuuid-2.23.2-63.el7.x86_64 libxcb-1.13-1.el7.x86_64 numactl-libs-2.0.12-3.el7_7.1.x86_64 opensm-libs-3.3.21-2.el7.x86_64 zlib-1.2.7-18.el7.x86_64**\nAfter typing where, I get a long list of notifications as below.\n#1  0x00007fffdeed2a28 in abort () from /lib64/libc.so.6\n#2  0x00007fffdfa54593 in __gnu_debug::_Error_formatter::_M_error (\nthis=0x61e420 <__gnu_debug::_Error_formatter::_M_at(char const*, unsigned int)::__formatter>)\nat ../../../../../gcc-7.4.0/libstdc++-v3/src/c++11/debug.cc:1069\n#3  0x00007ffff78d4c71 in std::__debug::vector<RankTwoTensorTempl, std::allocator<RankTwoTensorTempl                                                                                                                         > >::operator[] (this=0x208f4c8, __n=0) at /export/apps/gcc-7.4.0/include/c++/7.4.0/debug/vector:417\n#4  0x00007ffff1e8f2a3 in CrystalPlasticitySlipRateGSS::calcFlowDirection (this=0x1337700, qp=2, flow_direction=...)\nat /home/gnanasbr/temp_projects/moose/modules/tensor_mechanics/src/userobjects/CrystalPlasticitySlipRateGSS.C:162\n#5  0x00007ffff1fc76a2 in FiniteStrainUObasedCP::computeQpStress (this=0x149c310)\nat /home/gnanasbr/temp_projects/moose/modules/tensor_mechanics/src/materials/FiniteStrainUObasedCP.C:231\n#6  0x00007ffff1fa39f2 in ComputeStressBase::computeQpProperties (this=0x149c310)\nat /home/gnanasbr/temp_projects/moose/modules/tensor_mechanics/src/materials/ComputeStressBase.C:52\n.......................................................................................................................\nIt goes to list a number of locations in other source code files.\nI am not sure where I have gone wrong. As far as I can understand the error seems to be in the calcFlowDirection of the CrystalPlasticitySlipRateGSS user object.\nHow do I solve this problem?\nThanks,\nBala",
          "url": "https://github.com/idaholab/moose/discussions/16535",
          "updatedAt": "2022-09-01T10:48:05Z",
          "publishedAt": "2020-12-18T00:50:07Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Bala,\nI'm not an expert in this module however the debug trace seems to point to an out of bounds access in _flow_direction.\nIt's initialized with a material property in the constructor:\n_flow_direction(getMaterialProperty<std::vector<RankTwoTensor>>(_name + \"_flow_direction\"))\nDoes that give you any hint of what is the issue? Can you share a MWE with the issue?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16535#discussioncomment-232096",
                  "updatedAt": "2022-07-04T08:37:36Z",
                  "publishedAt": "2020-12-21T21:54:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "This type of error would lead me to believe that _flow_direction is not a reference when retrieved with getMaterialProperty",
                          "url": "https://github.com/idaholab/moose/discussions/16535#discussioncomment-232431",
                          "updatedAt": "2022-07-04T08:37:31Z",
                          "publishedAt": "2020-12-21T22:53:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "Hello Guillaume and Andrew,\nI understand the issue. But I am not sure why it popped up as I have used the same FiniteCrystalUOBasedCP as shown in one of the examples. And forgive my ignorance, what is an MWE?\nHow do I retrieve _flow_direction as a  reference?\nThanks,\nBala",
                          "url": "https://github.com/idaholab/moose/discussions/16535#discussioncomment-233182",
                          "updatedAt": "2022-07-04T08:37:31Z",
                          "publishedAt": "2020-12-22T03:16:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "MWE = Minimum Working Example",
                          "url": "https://github.com/idaholab/moose/discussions/16535#discussioncomment-233541",
                          "updatedAt": "2022-09-28T01:22:56Z",
                          "publishedAt": "2020-12-22T06:48:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "To use a reference you need the \"&\" as follows in the header:\nconst MaterialProperty<T> & _D;",
                          "url": "https://github.com/idaholab/moose/discussions/16535#discussioncomment-233544",
                          "updatedAt": "2022-09-28T01:22:56Z",
                          "publishedAt": "2020-12-22T06:51:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "Hello Guillaume and Andrew,\nThank you for your inputs.\nI have attached the input file that I used and I was able to run the file successfully for a few time steps beyond which I got the segmentation fault.\nkks_anisotropic_plastic.txt\nAs far as the flow direction goes, I found that it has been called by reference in the calcflowdirection function.\n`void\nCrystalPlasticitySlipRateGSS::calcFlowDirection(unsigned int qp,\nstd::vector & flow_direction) const\n{\nDenseVector mo(LIBMESH_DIM * _variable_size), no(LIBMESH_DIM * _variable_size);\n// Update slip direction and normal with crystal orientation\nfor (unsigned int i = 0; i < _variable_size; ++i)\n{\nfor (unsigned int j = 0; j < LIBMESH_DIM; ++j)\n{\nmo(i * LIBMESH_DIM + j) = 0.0;\nfor (unsigned int k = 0; k < LIBMESH_DIM; ++k)\nmo(i * LIBMESH_DIM + j) =\nmo(i * LIBMESH_DIM + j) + _crysrot[qp](j, k) * _mo(i * LIBMESH_DIM + k);\n}\nfor (unsigned int j = 0; j < LIBMESH_DIM; ++j)\n{\n  no(i * LIBMESH_DIM + j) = 0.0;\n  for (unsigned int k = 0; k < LIBMESH_DIM; ++k)\n    no(i * LIBMESH_DIM + j) =\n        no(i * LIBMESH_DIM + j) + _crysrot[qp](j, k) * _no(i * LIBMESH_DIM + k);\n}\n\n}\n'\nAnd the flow_direction variable was declared in the constructors part as\n_flow_direction(getMaterialProperty<std::vector<RankTwoTensor>>(_name + \"_flow_direction\"))\nThanks,\nBala",
                          "url": "https://github.com/idaholab/moose/discussions/16535#discussioncomment-234966",
                          "updatedAt": "2022-10-06T06:09:14Z",
                          "publishedAt": "2020-12-22T16:14:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "How is flow direction declared in the header?",
                          "url": "https://github.com/idaholab/moose/discussions/16535#discussioncomment-491465",
                          "updatedAt": "2022-10-06T06:09:19Z",
                          "publishedAt": "2021-03-17T00:31:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@Bala-1005 We have not implemented the code in MOOSE to couple crystal plasticity with phase field fracture yet. Some external users have implemented their model in their own branch, and you might want to check with them, i.e. @ngrilli\nAt INL, we have been developing a variational consistent phase field fracture model for crystal plasticity , but it is not ready yet.",
                  "url": "https://github.com/idaholab/moose/discussions/16535#discussioncomment-234992",
                  "updatedAt": "2022-09-28T15:30:23Z",
                  "publishedAt": "2020-12-22T16:32:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "I see. Thank you for the information. But the phase-field coupling here is not for fracture but for solidification. Does it change anything?",
                          "url": "https://github.com/idaholab/moose/discussions/16535#discussioncomment-234997",
                          "updatedAt": "2022-09-28T15:30:23Z",
                          "publishedAt": "2020-12-22T16:36:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "What model are you using for solidification? Are you using the grain tracker? Our CP needs grain orientation information, that is usually provided by users as an input. If you have new grains being generated during solidification, I do not believe our CP can handle that case at this moment.",
                          "url": "https://github.com/idaholab/moose/discussions/16535#discussioncomment-235054",
                          "updatedAt": "2022-09-28T15:30:23Z",
                          "publishedAt": "2020-12-22T17:09:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "I am using KKS model and I am not using grain tracker. I have given grain orientation through interfaceorientationmaterial. And there are no new nucleation events. There is a small region where the phase field corresponds to solid and the phase variable evolves from this initial condition.",
                          "url": "https://github.com/idaholab/moose/discussions/16535#discussioncomment-235153",
                          "updatedAt": "2022-09-28T15:30:24Z",
                          "publishedAt": "2020-12-22T18:01:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Function Plotting as AuxVariable",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Is there an obvious way to plot the 3D results of a function? E.g. ive got a function which is applied as a body force, is there some way using AuxVariable that I can use to plot this data?\ne.g.\n  [heat]\n    type = ADBodyForce\n    variable = temp\n    value = 1e6\n    function = 'exp(-10*(y-0.13))'\n    use_displaced_mesh = false\n  []\n\nIs there an obvious way to do this that I'm missing?",
          "url": "https://github.com/idaholab/moose/discussions/17337",
          "updatedAt": "2021-03-31T21:04:21Z",
          "publishedAt": "2021-03-16T21:21:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUse a functionAux and plot the variable you store the function values in.",
                  "url": "https://github.com/idaholab/moose/discussions/17337#discussioncomment-491276",
                  "updatedAt": "2021-03-16T22:55:40Z",
                  "publishedAt": "2021-03-16T22:55:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "w_advection",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "w (z velocity) is not recognized in NSFVMomentumAdvection, INSFVMomentumPressure , FVDiffusion. What file will I need to modify in order to include w?",
          "url": "https://github.com/idaholab/moose/discussions/17311",
          "updatedAt": "2022-06-16T12:48:54Z",
          "publishedAt": "2021-03-14T15:15:26Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "w should be the variable, not an extra argument, for INSFVMomentumPressure and FVDiffusion.\nCould you please paste here your FVKernel syntax?\nThanks,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17311#discussioncomment-490948",
                  "updatedAt": "2022-06-16T12:48:58Z",
                  "publishedAt": "2021-03-16T21:17:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you for you interest in potentially helping me to solve this issue. Here is the syntax for the FVKernels:\n[FVKernels]\n[mass]\ntype = INSFVMassAdvection\nvariable = pressure\nadvected_interp_method = ${advected_interp_method}\nvelocity_interp_method = ${velocity_interp_method}\nvel = 'velocity'\npressure = pressure\nu = u\nv = v\nw = w\nmu = ${mu}\nrho = ${rho}\n[]\n[u_advection]\ntype = INSFVMomentumAdvection\nvariable = u\nadvected_quantity = 'rhou'\nvel = 'velocity'\nadvected_interp_method = ${advected_interp_method}\nvelocity_interp_method = ${velocity_interp_method}\npressure = pressure\nu = u\nv = v\nw = w\nmu = ${mu}\nrho = ${rho}\n[]\n[u_viscosity]\ntype = FVDiffusion\nvariable = u\ncoeff = ${mu}\n[]\n[u_pressure]\ntype = INSFVMomentumPressure\nvariable = u\nmomentum_component = 'x'\np = pressure\n[]\n[v_advection]\ntype = INSFVMomentumAdvection\nvariable = v\nadvected_quantity = 'rhov'\nvel = 'velocity'\nadvected_interp_method = ${advected_interp_method}\nvelocity_interp_method = ${velocity_interp_method}\npressure = pressure\nu = u\nv = v\nmu = ${mu}\nrho = ${rho}\n[]\n[v_viscosity]\ntype = FVDiffusion\nvariable = v\ncoeff = ${mu}\n[]\n[v_pressure]\ntype = INSFVMomentumPressure\nvariable = v\nmomentum_component = 'y'\np = pressure\n[]\n[w_advection]\ntype = INSFVMomentumAdvection\nvariable = w\nadvected_quantity = 'rhow'\nvel = 'velocity'\nadvected_interp_method = ${advected_interp_method}\nvelocity_interp_method = ${velocity_interp_method}\npressure = pressure\nu = u\nv = v\nw = w\nmu = ${mu}\nrho = ${rho}\n[]\n[w_viscosity]\ntype = FVDiffusion\nvariable = w\ncoeff = ${mu}\n[]\n[w_pressure]\ntype = INSFVMomentumPressure\nvariable = w\nmomentum_component = 'z'\np = pressure\n[]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/17311#discussioncomment-491041",
                          "updatedAt": "2022-06-16T12:49:02Z",
                          "publishedAt": "2021-03-16T21:32:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It looks like you are missing w = 'w' for the v_advection kernel.\nI ll check it more offline",
                          "url": "https://github.com/idaholab/moose/discussions/17311#discussioncomment-491058",
                          "updatedAt": "2022-06-16T12:49:04Z",
                          "publishedAt": "2021-03-16T21:41:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It runs fine for me now when moving those kernels with the fix in an example problem",
                          "url": "https://github.com/idaholab/moose/discussions/17311#discussioncomment-491156",
                          "updatedAt": "2022-06-16T12:49:04Z",
                          "publishedAt": "2021-03-16T22:12:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Wow! That is awesome! Thank you for your sage guidance on this problem.",
                          "url": "https://github.com/idaholab/moose/discussions/17311#discussioncomment-491162",
                          "updatedAt": "2022-06-16T12:49:10Z",
                          "publishedAt": "2021-03-16T22:15:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Latest update libmesh compile failure",
          "author": {
            "login": "srinath-chakravarthy"
          },
          "bodyText": "I updated moose this morning and get the following error on both master and next branches\n/home/srinath/github/moose/scripts/../libmesh/src/solvers/petsc_linear_solver.C: In instantiation of \u2018void libMesh::PetscLinearSolver::get_residual_history(std::vector&) [with T = double]\u2019:\n/home/srinath/github/moose/scripts/../libmesh/src/solvers/petsc_linear_solver.C:1562:16:   required from here\n/home/srinath/github/moose/scripts/../libmesh/src/solvers/petsc_linear_solver.C:1274:39: error: invalid conversion from \u2018const PetscReal**\u2019 {aka \u2018const double**\u2019} to \u2018PetscReal**\u2019 {aka \u2018double**\u2019} [-fpermissive]\n1274 |   ierr = KSPGetResidualHistory(_ksp, &p, &its);\n|                                       ^\n|                                       |\n|                                       const PetscReal** {aka const double**}\nIn file included from /home/srinath/github/petsc/include/petscsnes.h:6,\nfrom /home/srinath/github/petsc/include/petscts.h:7,\nfrom /home/srinath/github/petsc/include/petsc.h:30,\nfrom ./include/libmesh/petsc_macro.h:66,\nfrom ./include/libmesh/petsc_linear_solver.h:27,\nfrom /home/srinath/github/moose/scripts/../libmesh/src/solvers/petsc_linear_solver.C:26:\n/home/srinath/github/petsc/include/petscksp.h:140:55: note:   initializing argument 2 of \u2018PetscErrorCode KSPGetResidualHistory(KSP, PetscReal**, PetscInt*)\u2019\n140 | PETSC_EXTERN PetscErrorCode KSPGetResidualHistory(KSP,PetscReal*[],PetscInt*);\n|                                                       ^~~~~~~~~~~~\n/home/srinath/github/moose/scripts/../libmesh/src/solvers/petsc_linear_solver.C: In instantiation of \u2018libMesh::Real libMesh::PetscLinearSolver::get_initial_residual() [with T = double; libMesh::Real = double]\u2019:\n/home/srinath/github/moose/scripts/../libmesh/src/solvers/petsc_linear_solver.C:1562:16:   required from here\n/home/srinath/github/moose/scripts/../libmesh/src/solvers/petsc_linear_solver.C:1316:39: error: invalid conversion from \u2018const PetscReal**\u2019 {aka \u2018const double**\u2019} to \u2018PetscReal**\u2019 {aka \u2018double**\u2019} [-fpermissive]\n1316 |   ierr = KSPGetResidualHistory(_ksp, &p, &its);\n|                                       ^\n|                                       |\n|                                       const PetscReal** {aka const double**}\nIn file included from /home/srinath/github/petsc/include/petscsnes.h:6,\nfrom /home/srinath/github/petsc/include/petscts.h:7,\nfrom /home/srinath/github/petsc/include/petsc.h:30,\nfrom ./include/libmesh/petsc_macro.h:66,\nfrom ./include/libmesh/petsc_linear_solver.h:27,\nfrom /home/srinath/github/moose/scripts/../libmesh/src/solvers/petsc_linear_solver.C:26:\n/home/srinath/github/petsc/include/petscksp.h:140:55: note:   initializing argument 2 of \u2018PetscErrorCode KSPGetResidualHistory(KSP, PetscReal**, PetscInt*)\u2019",
          "url": "https://github.com/idaholab/moose/discussions/17203",
          "updatedAt": "2022-07-22T21:24:39Z",
          "publishedAt": "2021-03-03T15:36:29Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi\nDoes it work now?\nDId you get the libmesh update through conda update --all ?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17203#discussioncomment-491159",
                  "updatedAt": "2022-07-22T21:24:40Z",
                  "publishedAt": "2021-03-16T22:14:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Simple mesh import problem",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi Folks,\nWeird one, Ive got a simple 2D mesh, with a sideset named pinned (which contains the nodes shown), I have a block defined called steel which contains all the triangles, as shown below.\n\nWhen I run this\n#Tensor Mechanics tutorial: the basics\n\n[Mesh]\n  type = FileMesh \n  file = '../mesh/beam.e'\n  construct_side_list_from_node_list = true\n[]\n \n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n  \n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n[]\n\nI get a segfault,\n0x00007ffff27cd581 in libMesh::BoundaryInfo::build_node_list(libMesh::BoundaryInfo::NodeBCTupleSortBy) const ()\n   from /home/adavis/opt/moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0\nMissing separate debuginfos, use: dnf debuginfo-install hwloc-libs-2.2.0-1.fc33.x86_64 libX11-1.6.12-3.fc33.x86_64 libXau-1.0.9-4.fc33.x86_64 libgcc-10.2.1-9.fc33.x86_64 libgfortran-10.2.1-9.fc33.x86_64 libgomp-10.2.1-9.fc33.x86_64 libpng-1.6.37-6.fc33.x86_64 libquadmath-10.2.1-9.fc33.x86_64 libstdc++-10.2.1-9.fc33.x86_64 libxcb-1.13.1-5.fc33.x86_64 zlib-1.2.11-23.fc33.x86_64\n(gdb) bt\n#0  0x00007ffff27cd581 in libMesh::BoundaryInfo::build_node_list(libMesh::BoundaryInfo::NodeBCTupleSortBy) const ()\n   from /home/adavis/opt/moose/scripts/../libmesh/installed/lib/libmesh_opt.so.0\n#1  0x00007ffff6e21d4e in MooseMesh::buildNodeList() () from /home/adavis/opt/moose/framework/libmoose-opt.so.0\n#2  0x00007ffff6e22780 in MooseMesh::update() () from /home/adavis/opt/moose/framework/libmoose-opt.so.0\n#3  0x00007ffff6e22d4a in MooseMesh::prepare(bool) () from /home/adavis/opt/moose/framework/libmoose-opt.so.0\n#4  0x00007ffff70c6f01 in SetupMeshCompleteAction::act() () from /home/adavis/opt/moose/framework/libmoose-opt.so.0\n#5  0x00007ffff70c1036 in Action::timedAct() () from /home/adavis/opt/moose/framework/libmoose-opt.so.0\n#6  0x00007ffff70c9619 in ActionWarehouse::executeActionsWithAction(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) ()\n   from /home/adavis/opt/moose/framework/libmoose-opt.so.0\n#7  0x00007ffff70cabcf in ActionWarehouse::executeAllActions() () from /home/adavis/opt/moose/framework/libmoose-opt.so.0\n#8  0x00007ffff7a79dff in MooseApp::runInputFile() () from /home/adavis/opt/moose/framework/libmoose-opt.so.0\n#9  0x00007ffff7a79816 in MooseApp::run() () from /home/adavis/opt/moose/framework/libmoose-opt.so.0\n#10 0x00000000004032ab in main ()\n(gdb) quit\n\nAnything obvious that Im doing wrong?",
          "url": "https://github.com/idaholab/moose/discussions/17304",
          "updatedAt": "2022-06-06T14:17:09Z",
          "publishedAt": "2021-03-12T14:47:33Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Nothing obvious to me.\nWith any luck the debug backtrace might give enough information if you could re-run with a debug build.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17304#discussioncomment-491032",
                  "updatedAt": "2022-06-06T14:17:21Z",
                  "publishedAt": "2021-03-16T21:31:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Navier-Stokes Preconditioning for a large problem - move across from mailing list",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi\nSo quick reminder I'm trying to solve a big (by my standards) fluid problem - its 2.4e6 elements - 16.6e6 DOF on 1280 cores, with a pre split mesh. Here is the run dump\nBuilding mesh .                                                                            [  2.22 s]\nInitializing equation system .............................                                 [ 30.02 s]\n\nFramework Information:\nMOOSE Version:           git commit 95fb74e5fe on 2020-10-01\nLibMesh Version:         b51a1fac743ce11a1e65018f25a478241c24ed44\nPETSc Version:           3.13.3\nSLEPc Version:           3.13.3\nCurrent Time:            Fri Nov  6 12:44:48 2020\nExecutable Timestamp:    Thu Oct  1 18:19:58 2020\n\nParallelism:\n  Num Processors:          1280\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           distributed (pre-split)\n  Mesh Dimension:          3\n  Spatial Dimension:       3\n  Nodes:                   \n    Total:                 3336156\n    Local:                 3176\n  Elems:                   \n    Total:                 2406640\n    Local:                 1935\n  Num Subdomains:          1\n  Num Partitions:          1\n  Partitioner:             parmetis\n\nNonlinear System:\n  AD size required:        90\n  Num DOFs:                16680780\n  Num Local DOFs:          15880\n  Variables:               \"velocity\" { \"p\" \"temp_fluid\" } \n  Finite Element Types:    \"LAGRANGE_VEC\" \"LAGRANGE\" \n  Approximation Orders:    \"SECOND\" \"SECOND\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             PostprocessorDT\n  Solver Mode:             NEWTON\n  MOOSE Preconditioner:    FSP\n\nProjecting initial condition .............................................................\n........................................                                                   [102.88 s]\nComputing initial stateful property values ......................                          [ 23.01 s]\nCopying soultions back ...................................................................\n..........................................................................................\n........................                                                                   [182.53 s]\n\nTime Step 0, time = 0\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\n\nPostprocessor Values:\n+----------------+----------------+\n| time           | cfl            |\n+----------------+----------------+\n|   0.000000e+00 |   6.165143e+11 |\n+----------------+----------------+\n\nOutputting out \n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................                                                                 [477.73 s]\n\nTime Step 1, time = 0.01, dt = 0.01\nComputing initial residual .....                                                           [  6.41 s]\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 1.948466e+04\nBuilding node to element map .....................................................         [ 54.57 s]\n      0 Linear |R| = 1.948466e+04\n\nIt's been at that stage for about 10 hours now, maybe even more like 15. When I ran this problem on 640 cores I got an error from petsc (error 9) suggesting a memory problem.\nSo my question is, any advice, different preconditioners?\nThanks\nSee input attached - hmm downside of GH Discussion, can't attach arbitrary files. But here is the input as a txt, also some screens of the geometry.\nfluid_sim-pc-no-t.txt",
          "url": "https://github.com/idaholab/moose/discussions/16113",
          "updatedAt": "2022-06-21T16:48:03Z",
          "publishedAt": "2020-11-07T12:04:37Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "So one thing straightaway that\u2019s not related to your question... please see #16091 and #16089. You should \u2018./configure \u2014with-ad-indexing-type=global\u2019 to avoid all that time spent in initial condition and \u201cstateful property\u201d computation.\nTo your question: I have seen the FSP options that you\u2019re using be fairly expensive in terms of memory and even CPU for large enough problems. I\u2019ve found asm or block Jacobi with sub block LU to be the most effective preconditioner for large INS problems. But I do believe that with some investigation, working with @fdkong , we can get FSP to be successful",
                  "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-123776",
                  "updatedAt": "2022-06-21T16:48:06Z",
                  "publishedAt": "2020-11-07T16:13:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "Yes, we will keep exploring FSP options. We might eventually come up with some good built-in options at the end.",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-126994",
                          "updatedAt": "2022-06-21T16:48:09Z",
                          "publishedAt": "2020-11-11T15:32:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "Ah thats useful, I'll rebuild - there a whole bunch of options that are really useful, I wonder if they should be default?\nSo I'm now on;\n  petsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -sub_pc_factor_levels  -ksp_gmres_restart'\n  petsc_options_value = 'asm      2               ilu          4       200'\n\nThat fails with out of memory,\nTime Step 1, time = 0.01, dt = 0.01\nComputing initial residual .....                                                           [  6.28 s]\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 1.948466e+04\n\n===================================================================================\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   PID 27176 RUNNING AT arm02.ib0.diracarm.le.ac.uk\n=   EXIT CODE: 9\n=   CLEANING UP REMAINING PROCESSES\n=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\n===================================================================================\n\nIm going to try Jacobi next",
                  "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-123804",
                  "updatedAt": "2022-06-21T16:48:13Z",
                  "publishedAt": "2020-11-07T18:07:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "This actually looks like it could be running out of memory during Jacobian assembly since we haven\u2019t yet printed the first linear residual to the screen. I really want to get parallel heap profiling going (#15990). How big of a derivative vector did you configure with?\nSomething I can say is that you\u2019re doing yourself no favors memory-wise by using second order basis. At least it looks like you\u2019re using tets. Still, you will have rows with 50 coupled dofs (5 vars * 10 dofs per elem) instead of potentially 20 coupled dofs (4 dofs per elem). So that has the potential to reduce your memory footprint if you go to first order (you are already using PSPG). If you have significant curvature I would suggest just adding more elements to try and capture it unless that\u2019s untenable for some reason.\nIf you do go to first order you can reconfigure \u2018\u2014with-derivative-size=20\u2019 to try and speed up your calculations just a bit (and potentially further reduce your memory footprint a smidge).",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-123820",
                          "updatedAt": "2022-06-21T16:48:10Z",
                          "publishedAt": "2020-11-07T18:59:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "I'm pretty sure I have derivative-size=180 currently I had a big structural problem which warranted it earlier and I've stuck with it since.\nI can try first order, and I have no issue with adding more elements I'll give that a bash too. Thus far (perhaps for historical reasons) I've tended to use 2nd order for velocity and 1st for pressure, perhaps with the ADINS stuff its no-longer necessary.",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-123824",
                          "updatedAt": "2022-06-21T16:48:10Z",
                          "publishedAt": "2020-11-07T19:10:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The mixed order basis is required for LBB stability if you are not using PSPG. PSPG makes equal-order basis stable. If you ever see a mixed-order basis do better with nonlinear/linear convergence than a PSPG equal-order basis, however, then I would be very interested to hear about it.",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-123833",
                          "updatedAt": "2022-06-21T16:48:10Z",
                          "publishedAt": "2020-11-07T19:53:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "I think you should use sparse AD that uses much less memory and also way faster (at least for one project I have done last month).",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-126999",
                          "updatedAt": "2022-07-12T13:17:44Z",
                          "publishedAt": "2020-11-11T15:35:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "Ok, with 2nd order as before but with\n  petsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -sub_pc_factor_levels  -ksp_gmres_restart'\n  petsc_options_value = 'bjacobi      2               ilu          4       200'\n\nWe now have lift off, well its running at least ;)\n    300 Linear |R| = 1.091458e+02\n  Linear solve did not converge due to DIVERGED_ITS iterations 300\n 1 Nonlinear |R| = 2.581837e+06\n      0 Linear |R| = 2.581837e+06\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC_FAILED due to FACTOR_NOERROR \nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 1\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nTime Step 1, time = 0.005, dt = 0.005\nComputing initial residual .....                                                           [  6.79 s]\n 0 Nonlinear |R| = 3.913081e+04\n\nWe'll see in the morning if it gets anywhere - thanks for the help so far",
                  "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-123876",
                  "updatedAt": "2022-06-21T16:48:09Z",
                  "publishedAt": "2020-11-07T23:15:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Ok, so over night much more progress was made, we're getting through some linear and non-linear iterations now and we're failing to converge, but ive got the timestep set pretty high. I've seen the in past that it needs to take a very small timestep, say 1e-6 seconds, then its happy to take great big 1e-2 size time steps, so this is great progress!",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-124401",
                          "updatedAt": "2022-06-21T16:48:14Z",
                          "publishedAt": "2020-11-08T22:04:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "ILU(4) is quite expensive, and it might already very close to LU. I was wondering if the algorithm will still converge if you switch to use  ILU(3).\nASM uses more memory than bjacobi because of overlapping elements and also duplicated local submatrices",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-127007",
                          "updatedAt": "2022-06-21T16:48:16Z",
                          "publishedAt": "2020-11-11T15:38:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "So good news, I changed 1st order, and its flying now :) Taking great big honking time steps which is great, but im wondering if i should tighten up my tolerances?\nIn terms of iterations im seeing a decent drop in linear residuals and in around 3 or 4 non-linear steps which is great, however... im seeing some weird velocity and temperature excursions,\n\nSo this one shows temp which should be between 300 and 673 K, the walls are at 673 and its injected at 573, but the IC is 300, is this a question of more elements, but the temp should definitely not be greater than 637 or lower than 300 (given some interpolation between nodes) but certainly not in the -1e6 to 1e6 range.\n\nVelocity has some similar problems, we're ramping with time (max(1,t)) and I can forgive velocities in the range 1,4 probably, but there are local excursions to 5e3 m/s\nDoes that indicate that I should lengthen up tolerances or mesh resolution?",
                  "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-124955",
                  "updatedAt": "2022-06-21T16:48:14Z",
                  "publishedAt": "2020-11-09T12:10:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I would try to avoid using nl_abs_tol unless you're stepping towards a steady-state. You may try using nl_rel_tol = 1e-8. But I think the more important part is probably to increase the mesh resolution to try to avoid oscillations in the fields (overshoots and undershoots). What is your Reynolds number? Also I can't quite tell in the temperature visualization with the red patch...is the majority of the domain at 300K? Or is most of the domain below 300 K? I would be much more concerned if we are seeing a majority of the domain go below a physical value as opposed to in some small regions near sharp discontinuities, which continuous FEM is notoriously bad at resolving. SUPG helps, but it's not a silver bullet.",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-125168",
                          "updatedAt": "2022-06-21T16:48:35Z",
                          "publishedAt": "2020-11-09T17:26:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "In general, adaptive time stepper may be helpful here\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 0.5\n    growth_factor = 1.2\n    cutback_factor = 0.8\n  [../]",
                  "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-127012",
                  "updatedAt": "2022-06-21T16:48:31Z",
                  "publishedAt": "2020-11-11T15:41:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mlesueur"
                  },
                  "bodyText": "Hi @makeclean,\nI have just seen your post as I was doing my annual errand on moose-users about: \"is there a better preconditioner for my large simulations of Stokes flow\" \ud83d\ude01 So I'm jumping on the post.\nTo give you some context, I am simulating pressure-driven Stokes flow through complex structures (rock microCT-scans) and I am often dealing with DOFs >1e7.\nI have already discussed preconditioning with @fdkong and the one I am using right now is:\n[FSP]\n    type = FSP\n    petsc_options_iname = '-snes_type -ksp_type -ksp_rtol -ksp_atol -ksp_max_it -snes_atol -snes_rtol -snes_max_it -snes_max_funcs'\n    petsc_options_value = 'newtonls     fgmres     1e-2     1e-15       200       1e-10        1e-15       200           100000'\n    topsplit = 'uv'\n    [uv]\n      petsc_options_iname = '-pc_fieldsplit_schur_fact_type -pc_fieldsplit_schur_precondition'\n      petsc_options_value = 'upper selfp'\n      splitting = 'u v'\n      splitting_type = schur\n    []\n    [u]\n      vars = 'vel_x vel_y vel_z'\n      petsc_options_iname = '-pc_type -ksp_type -pc_hypre_type'\n      petsc_options_value = '  hypre    preonly     boomeramg '\n    []\n    [v]\n      vars = 'p'\n      petsc_options_iname = '-pc_type -ksp_type -sub_pc_type -sub_pc_factor_levels'\n      petsc_options_value = '  jacobi  preonly        ilu            3'\n    []\n  []\nIt shows great performance and I am able to solve 1e7+ DOFs within an hour on 50 processors (also I'm using PSPG with first order elements). Let me know if this works for you!\nStill for me the problem I am facing was mentioned by @lindsayad and @fdkong: the memory usage is off the charts! For example for 1e7 DOFs, it needs 64Gb (even with mesh splitting).\nI would love to have any feedback on whether I can improve this FSP.\nOtherwise I tested also the solutions mentioned here. It is the asm ilu that seemed to give me some good convergence with a low memory usage. HOWEVER, I have a a DIVERGED_LINE_SEARCH error after the second nonlinear iteration, see below. I have tried all the different line search options, or disabling it, but it does not work. Is it maybe because of the 0 in the diagonal of the stokes matrix? Do you think there is a solution to still have the asm ilu working?\nThank you in advance for your help,\nCheers,\nMartin\nComputing initial residual                                                                 [  1.29 s]\n 0 Nonlinear |R| = 1.976305e-04\n      0 Linear |R| = 1.976305e-04\n...\n     26 Linear |R| = 1.017750e-07\n 1 Nonlinear |R| = 9.125860e-05\n      0 Linear |R| = 9.125860e-05\n      1 Linear |R| = 9.125821e-05\n      2 Linear |R| = 9.125519e-05\n      3 Linear |R| = 9.125061e-05\n      4 Linear |R| = 9.123911e-05\n      5 Linear |R| = 9.122871e-05\n      6 Linear |R| = 9.115078e-05\n      7 Linear |R| = 9.111489e-05\n      8 Linear |R| = 9.091965e-05\n      9 Linear |R| = 9.079105e-05\n     10 Linear |R| = 8.967217e-05\n     11 Linear |R| = 8.818694e-05\n     12 Linear |R| = 7.786348e-05\n     13 Linear |R| = 6.424927e-05\n     14 Linear |R| = 3.950608e-05\n     15 Linear |R| = 2.839524e-05\n     16 Linear |R| = 1.836606e-05\n     17 Linear |R| = 1.196996e-05\n     18 Linear |R| = 6.749037e-06\n     19 Linear |R| = 3.362408e-06\n     20 Linear |R| = 1.857514e-06\n     21 Linear |R| = 1.028440e-06\n     22 Linear |R| = 6.480960e-07\n     23 Linear |R| = 3.930797e-07\n     24 Linear |R| = 2.569072e-07\n     25 Linear |R| = 1.634042e-07\n     26 Linear |R| = 1.104569e-07\n     27 Linear |R| = 6.666340e-08\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 1\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nOutlier Variable Residual Norms:\n  vel_x: 8.300333e-05",
                  "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-451036",
                  "updatedAt": "2022-06-21T16:48:44Z",
                  "publishedAt": "2021-03-08T17:46:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "High memory use with FSP...I do not see lu anywhere. @fdkong why would it be taking so much memory relative to asm + ilu?\nAre you using PJFNK or NEWTON? could you run with -ksp_monitor_true_residual and paste in that same solve history? Also are you using the INSAD or INS kernels? Finally, you should not have a zero for any of the diagonals if you are using PSPG.",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-451123",
                          "updatedAt": "2022-06-21T16:49:16Z",
                          "publishedAt": "2021-03-08T18:10:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "In general, I do not expect the FSP memory usage is way more than  that of ASM+ILU.\nIt would be really helpful if @mlesueur   would like to do a heap profiling. With a profiling result, we might have an idea if we are able to improve anything.\nHere are some profiling instructions:  https://mooseframework.inl.gov/application_development/profiling.html",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-451159",
                          "updatedAt": "2022-06-21T16:49:16Z",
                          "publishedAt": "2021-03-08T18:21:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "Nonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 1\nSolve Did NOT Converge!\nAborting as solve did not converge\n\n@mlesueur You could turn off line search, and try it again. Add line_search = none into executioner block",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-451165",
                          "updatedAt": "2022-06-21T16:49:15Z",
                          "publishedAt": "2021-03-08T18:22:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I think @fdkong means to be tagging @mlesueur here. It would be great to see a heap profile for the FSP case (and also for the asm-ilu case for comparison).",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-451197",
                          "updatedAt": "2022-06-21T16:49:36Z",
                          "publishedAt": "2021-03-08T18:34:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "either way I appreciate the ping to remind me of my old problem :)",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-451764",
                          "updatedAt": "2022-06-21T16:49:37Z",
                          "publishedAt": "2021-03-08T21:16:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mlesueur"
                          },
                          "bodyText": "Thank you for your answers, I will update MOOSE and try to do a heap profiling. @lindsayad I use INS kernels and solve with NEWTON. I thought this was the way to use as little memory as possible and reduce CPU time. Is that correct?",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-452816",
                          "updatedAt": "2022-06-21T16:49:37Z",
                          "publishedAt": "2021-03-09T08:09:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mlesueur"
                          },
                          "bodyText": "I have updated moos. Now asm-ilu seems to be working, with a similar memory usage than FSP, at least at 1e6 DOFS. I haven't pushed it further yet.\nFor the profiling, I haven't been able to use gperftools... Is it available with the latest moose version? So I got out the allocations from instruments instead, for both asm-ilu and fsp (https://we.tl/t-y8ndLzbOIv), for a small problem, 72488 DOFS. I don't really know how to read this type of files, but is this comprehensible for you?\nPlease let me know if I can do something else",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-455874",
                          "updatedAt": "2022-06-21T16:49:37Z",
                          "publishedAt": "2021-03-09T15:49:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I use INS kernels and solve with NEWTON. I thought this was the way to use as little memory as possible and reduce CPU time. Is that correct?\n\nThat is correct\n\nNow asm-ilu seems to be working\n\nSo it's converging now without you making any other changes other than updating moose? Did you update your PETSc version?\n\nFor the profiling, I haven't been able to use gperftools... Is it available with the latest moose version?\n\nNo. We used to distribute a package for it, but unfortunately we no longer do that. You would have to build that as well as libunwind most likely. If you are on Mac, it's my experience that gperftools doesn't work that well (maybe @fdkong has experienced otherwise), so instruments may be your best bet. I'll try looking at the traces next time I'm on my laptop",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-456089",
                          "updatedAt": "2022-06-21T16:49:46Z",
                          "publishedAt": "2021-03-09T16:39:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "I have updated moos. Now asm-ilu seems to be working, with a similar memory usage than FSP, at least at 1e6 DOFS. I haven't pushed it further yet.\nFor the profiling, I haven't been able to use gperftools... Is it available with the latest moose version? So I got out the allocations from instruments instead, for both asm-ilu and fsp (https://we.tl/t-y8ndLzbOIv), for a small problem, 72488 DOFS. I don't really know how to read this type of files, but is this comprehensible for you?\nPlease let me know if I can do something else\n\n@mlesueur Thanks for your results. In your test cases, FSP is better than ASM in terms of memory and compute time.\nFSP, simulation time 42.562 s, memory 359 MB\nASM: simulation time 69.562 s,  memory 1030MB.\nThe reason is that you run simulations in serial and ASM is an ILU. ASM is competitive when running in parallel. But you should pick up whatever work better for you.\nI did not see unexpected memory allocations from your profiling results.",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-456336",
                          "updatedAt": "2022-06-21T16:50:04Z",
                          "publishedAt": "2021-03-09T17:43:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mlesueur"
                          },
                          "bodyText": "Thank you @fdkong for the feedback. Happy to know that the FSP looks like my best option. I guess the large memory usage is just normal when you are dealing with large meshes.",
                          "url": "https://github.com/idaholab/moose/discussions/16113#discussioncomment-487734",
                          "updatedAt": "2022-06-21T16:50:05Z",
                          "publishedAt": "2021-03-16T09:38:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Initial conditions questions - (doesn't take second order data, simulation speed)",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi all,\nI have 2 questions regarding MOOSE initial conditions\nFirst question is does 'initial conditions' work as the initial guess forthe solver?  if so, I don't really see much of an imporvement at all, maybe I did something wrong?\nHere is a rough workflow of my simulation: solve a steady state problem > upload file to the next simulation > change the material property (young's modulus/density/possion) of some block IDs > solve a steady state problem > repeat.\nSecond question: I tried to load the 2nd order Auxvariable from .e file\n\n[Mesh]\n[./gen]\n   type = FileMeshGenerator\n     file = gravz_later_step1_Pre_backfilltest.e\n     show_info = true\n     use_for_exodus_restart = true\n     # parallel_type = distributed\n  []\n[]\n\n[AuxVariables]\n  [./s11_aux]\n    order = SECOND\n    family = MONOMIAL\n   initial_from_file_var = s11_aux\n  [../]\n  [./s22_aux]\n    order = SECOND\n    family = MONOMIAL\n   initial_from_file_var = s22_aux\n  [../]\n  [./s33_aux]\n    order = SECOND\n    family = MONOMIAL\n   initial_from_file_var = s33_aux\n  [../]\n[]\n\nand I received this error\nError! Trying to copy elemental solution into a variable that is not of CONSTANT MONOMIAL type.\nIt has no error taking 2nd order variable\n[Variables]\n    [./disp_x]\n      order = SECOND\n      family = LAGRANGE\n       initial_from_file_var = disp_x\n    [../]\n    [./disp_y]\n      order = SECOND\n      family = LAGRANGE\n      initial_from_file_var = disp_y\n    [../]\n    [./disp_z]\n      order = SECOND\n      family = LAGRANGE\n       initial_from_file_var = disp_z\n    [../]\n[]\n\nis there any way to work around this? can I calculate Auxvariable pre and post simulation?\nThank you guys!\nRegards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/17314",
          "updatedAt": "2022-07-01T11:25:22Z",
          "publishedAt": "2021-03-15T04:30:23Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @Traiwit\n\n\nFor time dependent problems, the initial conditions should be the initial guess of the solver.\nNot sure about steady state problems. Initial conditions may not have any effect in that case.\n\n\nNot sure if that is possible. Were the AuxVariables in the imported file also second order monomial?\n\n\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/17314#discussioncomment-482823",
                  "updatedAt": "2022-07-01T11:25:34Z",
                  "publishedAt": "2021-03-15T08:34:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Hang on, although i'm sure you know about initial conditions, @ngrilli , i think your wording is confusing, so for posterity i'll write:\n\nFor Variables, initial conditions are the physical initial conditions of your system.   They are usually well-known.  For instance, displacement = 0, or pressure = atmospheric, or temperature = room_temperature, etc.  For steady simulations, the initial conditions don't matter in principal, because MOOSE will find the solution no-matter what the initial conditions you set (assuming there is a unique solution) but in practice initial conditions are extremely important, since if your ICs are close to the final steady-state solution MOOSE will find it easy to converge, while if you just set random ICs MOOSE will take ages to converge.  In this sense, for steady problems, the ICs can be thought of as \"initial guess\".\nFor AuxVariables, initial conditions can be more complicated.  Firstly, they could be over-written by your AuxKernels so the initial may have no impact.  Secondly, some AuxVariables are simply stores of information and aren't actually used in Kernels/Materials/etc, so have no impact on the solution process, and setting an initial is just for visualisation, etc.  On the other hand, some AuxVariables feed into Kernels/etc, so their initial may be very important, and you should choose something physical (for time-dep problems) or reasonable (for steady problems).",
                          "url": "https://github.com/idaholab/moose/discussions/17314#discussioncomment-483029",
                          "updatedAt": "2022-07-01T11:25:34Z",
                          "publishedAt": "2021-03-15T09:42:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@WilkAndy may I ask a really dumb question,\nIn Tensormechanic, seem like the only variable that goes into the solver is 'disp_', would importing the variable from a file as follow (below) enough to let MOOSE know that I want to use these disp_ as ICs?\nThank you!\n[Variables]\n    [./disp_x]\n      order = SECOND\n      family = LAGRANGE\n       initial_from_file_var = disp_x\n    [../]\n    [./disp_y]\n      order = SECOND\n      family = LAGRANGE\n      initial_from_file_var = disp_y\n    [../]\n    [./disp_z]\n      order = SECOND\n      family = LAGRANGE\n       initial_from_file_var = disp_z\n    [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/17314#discussioncomment-483070",
                          "updatedAt": "2022-07-01T11:25:35Z",
                          "publishedAt": "2021-03-15T09:53:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Yes, that is the syntax you should use to set your displacement ICs.",
                          "url": "https://github.com/idaholab/moose/discussions/17314#discussioncomment-483151",
                          "updatedAt": "2022-07-01T11:25:35Z",
                          "publishedAt": "2021-03-15T10:12:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thank you @WilkAndy ,\nFor the 2nd question: Yes @ngrilli, the input file contains the second order monomial data.",
                          "url": "https://github.com/idaholab/moose/discussions/17314#discussioncomment-483602",
                          "updatedAt": "2023-04-10T19:13:00Z",
                          "publishedAt": "2021-03-15T12:30:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Hey @Traiwit, i just want to highlight the phrase \"assuming there is a unique solution\" in my post above.  Just remember that when you start using plasticity, your solution will be path dependent, eg, will depend on your excavation schedule (and any damping parameters you include).  Eg, if you excavate the entire mine in one big chunk, the overburden will tend to fall down in one big chunk (with failure only above the boundary of your excavation), whereas if you excavate in many small steps, the rock will tend to fail and bulk-up throughout the entire overburden.",
                          "url": "https://github.com/idaholab/moose/discussions/17314#discussioncomment-485877",
                          "updatedAt": "2023-04-10T19:13:00Z",
                          "publishedAt": "2021-03-15T20:47:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@WilkAndy thanks I will keep that in mind, i'm still not happy with my elastic model, might be some time until I can move to plastic model.\nI've been reading the coal-mine example too, I hope everything makes sense eventually :)",
                          "url": "https://github.com/idaholab/moose/discussions/17314#discussioncomment-486988",
                          "updatedAt": "2023-04-10T19:13:04Z",
                          "publishedAt": "2021-03-16T04:44:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about convergence with decreasing residuals",
          "author": {
            "login": "Bala-1005"
          },
          "bodyText": "Hello everyone,\nI have noticed a very weird convergence issue while running my phasefield-mechanics problem on moose. Attached are two parts of the same output file.\nEven though the linear and nonlinear residuals drop in a similar way, one of the time steps returns a message saying the solution has converged but the other returns saying solve has not converged. Why would it happen that way?\nThanks,\nBala\nconverged.txt\nnonconverged.txt",
          "url": "https://github.com/idaholab/moose/discussions/17322",
          "updatedAt": "2022-10-25T02:30:46Z",
          "publishedAt": "2021-03-15T19:11:06Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "Looks like you have the maximum number of nonlinear iterations (nl_max_its) set to 10. Try increasing that value. The other solve probably converged because the default nonlinear tolerance (nl_rel_tol) of 1e-8 was met. The nonconverged solution was just slightly above that value (comparing the last nonlinear residual to the first) as it hit the 10th iteration so it aborted.",
                  "url": "https://github.com/idaholab/moose/discussions/17322#discussioncomment-485670",
                  "updatedAt": "2022-10-25T02:30:51Z",
                  "publishedAt": "2021-03-15T19:41:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "Check out this page:\nhttps://mooseframework.inl.gov/application_usage/failed_solves.html",
                  "url": "https://github.com/idaholab/moose/discussions/17322#discussioncomment-485678",
                  "updatedAt": "2022-10-25T02:31:00Z",
                  "publishedAt": "2021-03-15T19:42:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "Thank you @jessecarterMOOSE . That solved the issue. Just to understand better, when you say the nonlinear relative tolerance was not met in the non converged solution do you mean to say that the difference between the final nonlinear tolerance and the previous nonlinear tolerance?\nAlso, this may be unrelated but I see the letter 'm' in my output file between numbers when it displays the residuals? What does this mean and how do I remove this?\nThanks,\nBala",
                          "url": "https://github.com/idaholab/moose/discussions/17322#discussioncomment-486190",
                          "updatedAt": "2022-10-25T02:31:00Z",
                          "publishedAt": "2021-03-15T22:21:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "It is the ratio of the final nonlinear residual to the first, or rather the 0th, nonlinear residual of the particular step.\nAll that extra junk is color code information that a simple text editor doesn't understand. You can run moose with --no-color to disable color output.",
                          "url": "https://github.com/idaholab/moose/discussions/17322#discussioncomment-486378",
                          "updatedAt": "2022-11-15T13:10:00Z",
                          "publishedAt": "2021-03-15T23:19:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bala-1005"
                          },
                          "bodyText": "Thank you so much @jessecarterMOOSE .",
                          "url": "https://github.com/idaholab/moose/discussions/17322#discussioncomment-486857",
                          "updatedAt": "2022-11-15T13:11:09Z",
                          "publishedAt": "2021-03-16T03:07:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}