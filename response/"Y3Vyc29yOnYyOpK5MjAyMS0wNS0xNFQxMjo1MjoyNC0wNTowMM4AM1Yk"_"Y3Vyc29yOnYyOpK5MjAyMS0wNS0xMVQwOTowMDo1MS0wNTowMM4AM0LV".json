{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNS0xMVQwOTowMDo1MS0wNTowMM4AM0LV"
    },
    "edges": [
      {
        "node": {
          "title": "Thermal Radiation",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi, feel like im bombarding you guys today :). Im trying the new ray tracing based thermal radiation stuff, so I setup my geometry in Cubit as usual, with what I think are appropriate boundaries and so on. I've been trying to use my Cubit generated mesh, but I first hit an error:\n*** ERROR ***\nThis action adds MeshGenerator objects and therefore only works with a MeshGeneratorMesh.\n\nSo I changed my mesh section from\n[Mesh]\n  file = '../mesh/hot-cup.e'\n[]\n\nto\n type = MeshGeneratorMesh\n [bob]\n   type = FileMesh\n   file = '../mesh/hot-pipes.e'\n []\n\nBut I get the error message;\n*** ERROR ***\nTask add_mesh_generator is not registered to build MooseMesh derived objects\n\nI presume from this, I can't use a file based mesh? Looking at the tests that exist for this functionality, it seems that they only use internally generated mesh, just checking, is that right? I can't use an exeternal mesh?",
          "url": "https://github.com/idaholab/moose/discussions/17818",
          "updatedAt": "2022-06-24T02:41:58Z",
          "publishedAt": "2021-05-13T07:57:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "Ah, got it, I need to use\n[Mesh]\n  [bob]\n    type = FileMeshGenerator\n    file = '../mesh/hot-pipes-radiation.e'\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-732681",
                  "updatedAt": "2022-06-24T02:42:31Z",
                  "publishedAt": "2021-05-13T08:29:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Ok, almost there, my geometry is the following;\n\nI have the following boundaries (side sets) defined vol-1 to vol-9 which are the pipes in the middle, I have vol-10 which are the inner walls of the block. I have a further side set called outer-walls which is the exterior boundary. I have a ConvectiveHeatFlux boundary condition on the outside wall.\nMy problem, is it seems I need to define an additional RayBC either reflection or kill on the green (vol-10) side set, but when I do via a RayBCs section, I get an error\n*** ERROR ***\nThe following error occurred in the object \"ray_study_uo_cavity\", of type \"ViewFactorRayStudy\".\n\nRequires one and only one ViewFactorRayBC.\n\nStack frames: 12\n\nWithout it, I get the following error\n*** ERROR ***\nRay on processor 0 and thread 0 failed to trace at line 2137\n\nDon't know what to do with a Ray after it hit an external\nboundary at point (x,y,z)=( 0.37651,   0.4125, -0.0639156)!\n\nWhen hitting an external RayBC, a Ray must either:\n  Be killed by a RayBC\n  Have its trajectory changed by the RayBC\nby at least one of the executed RayBCs.\n\nYou need to either:\n  Kill/change the Ray sooner with RayKernels, internal RayBCs, or a max distance\n  Kill/change the Ray on the boundary with a RayBC\n\nBoundaries that did not have any RayBCs:\n  12 (outer-walls)\n\nMy diffuse radiaiton block looks like this;\n[GrayDiffuseRadiation]\n  [cavity]\n    boundary = 'vol-1 vol-2 vol-3 vol-4 vol-5 vol-6 vol-7 vol-8 vol-9 vol-10'\n    emissivity = '0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9 0.9'\n    n_patches = '10 10 10 10 10 10 10 10 10 10'\n    partitioners = 'centroid centroid centroid centroid centroid centroid centroid centroid centroid centroid'\n    centroid_partitioner_directions = 'radial radial radial radial radial radial radial radial radial radial'\n    temperature = temperature\n    ray_tracing_face_type = 'gauss'\n    view_factor_calculator = 'ray_tracing'\n  []\n[]\n\nSo I guess my question, has a few bits, is my setup sensible, and if so, what should I do about the outer-walls?",
                          "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-732972",
                          "updatedAt": "2022-06-24T02:42:31Z",
                          "publishedAt": "2021-05-13T09:45:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "The orientation of the internal sidesets for this capability are very important. Recall that for interior sidesets, the sideset will be associated with the side of an element, so there are two possible orientations.\nI suspect that what is happening here is that we're tracing rays from vol-10 outward to outer-walls because the orientation is off here, which is definitely not what you want to do. We trace rays based on the half space of the normal and the orientation. The default orientation is that the normals for your internal sidesets point inward to the cavity (see the picture below).\n\nWe probably need to improve the documentation here a bit \ud83d\ude2c",
                          "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-734123",
                          "updatedAt": "2022-06-24T02:42:42Z",
                          "publishedAt": "2021-05-13T14:32:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Thanks @loganharbour I believe the sideset convention above is honored by my geometry? I should point out I don't have any internal sidesets, the region between the cylinders and the start of the hollow brick, is not meshed.\n\n\nOr are you saying, my normals all need reversing?\nI think this requirement may be a little impossible to achieve in some models, given what Cubit does during imprinting and merging, surfaces that become merged can have inconsistent normals in this scheme and I think this will be true of the sidesets they belong to. E.g. two cubes that have an adjacent shared face will have a normal that points in a particular direction, the surface that is shared has a property sense_forward which can be FORWARD or REVERSE. I have no control over this if want to produce a consistent mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-737184",
                          "updatedAt": "2022-06-24T02:43:25Z",
                          "publishedAt": "2021-05-14T07:08:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "I should point out I don't have any internal sidesets, the region between the cylinders and the start of the hollow brick, is not meshed.\n\nAhh, this is actually a bigger issue. With the initial ray tracing capability, we're required to traverse through the mesh even when tracing from a boundary to another boundary. There are plans in the future to look into tracing by checking all possible boundary surfaces instead of requiring a mesh, but we unfortunately don't have time right now to do this.\nIf I recall correctly, @helen-brooks is looking into something that is like this (boundary-to-boundary tracing), but I cannot recall if it is using MOOSE or just libMesh.",
                          "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-738793",
                          "updatedAt": "2022-11-08T17:52:05Z",
                          "publishedAt": "2021-05-14T14:43:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "helen-brooks"
                          },
                          "bodyText": "@loganharbour The project you are referring to is using libMesh to do surface ray-tracing within DAGMC, which @makeclean is aware of since it was his idea. Recently haven't had much time to work on this, though if it's something you or the MOOSE community would be interested in, it might be an argument to put in more resources.",
                          "url": "https://github.com/idaholab/moose/discussions/17818#discussioncomment-739017",
                          "updatedAt": "2022-11-08T17:52:05Z",
                          "publishedAt": "2021-05-14T15:14:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Questions about free energy in the official case DerivativeMultiPhaseMaterial.i",
          "author": {
            "login": "tmewhy"
          },
          "bodyText": "Hi guys\nI am studying the official case DerivativeMultiPhaseMaterial.i.\n\n(modules/phase_field/examples/multiphase/DerivativeMultiPhaseMaterial.i)\n\nIn this case, the free energy is set to F1=(c-1)^2, F2=(c-0.5) ^2, F3=c ^2, the initial conditions set the concentration c to smoothly change from 1 to 0. According to my own understanding, according to the principle of minimizing free energy, c=1, c=0.5, c=0, they should all be balanced phases, but the simulation result is that only c=0.5, c=0 are left.  I\u2019m very confused about this. Is my understanding of free energy not clear enough, or what setting was used in the case to cause c=1 not to be a minimum free energy phase.",
          "url": "https://github.com/idaholab/moose/discussions/17816",
          "updatedAt": "2022-10-03T11:00:02Z",
          "publishedAt": "2021-05-13T07:13:17Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "simopier"
                  },
                  "bodyText": "Hi,\nas you noticed, the phase with c=1 disappears in that simulation, despite c=1 being a minimum for the bulk free energy defined as Fb = h1*F1+h2*F2+h3*F3. This is because the total free energy also includes other sources of energy.\nAs you can see in the input file, it includes:\n\nan energy barrier defined by the MultiBarrierFunctionMaterial block and included in the energy by the free_energy block (g(\u03b7))\nthe cross energies for the order parameters defined in the cross_terms block (the equivalent of \u03ba/2 |\u2207 \u03b7| 2 for a multi-phase system)\nan energy term related to the gradient of the concentration introduced in local_free_energy (\u03ba/2 |\u2207 c| 2)\n\nThe microstructure evolves to reduce the integral of the total free energy, not only the bulk free energy contribution. By loosing the center phase with c=1, the system reduces the interfacial free energy due to the concentration and order parameter gradients.\nI hope that helps!",
                  "url": "https://github.com/idaholab/moose/discussions/17816#discussioncomment-735900",
                  "updatedAt": "2022-10-03T11:00:17Z",
                  "publishedAt": "2021-05-13T21:46:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tmewhy"
                          },
                          "bodyText": "I have fully understood this question through your answer, thank you very much for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/17816#discussioncomment-736376",
                          "updatedAt": "2022-12-12T00:21:17Z",
                          "publishedAt": "2021-05-14T01:30:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "simopier"
                          },
                          "bodyText": "You are welcome!",
                          "url": "https://github.com/idaholab/moose/discussions/17816#discussioncomment-738705",
                          "updatedAt": "2022-12-12T00:21:36Z",
                          "publishedAt": "2021-05-14T14:26:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Get a non-const Function",
          "author": {
            "login": "xuxiaobei1995"
          },
          "bodyText": "Hi all,\nRecently I updated my MOOSE and found that the returned type of getFunction() has been changed from \"Function &\" to \"const Function &\". However in my code I want to get the function and modify its data, which means a non-const Function is needed. Does anyone know the way to realize this? Any suggestion is appreciated.\nXiaobei",
          "url": "https://github.com/idaholab/moose/discussions/17796",
          "updatedAt": "2022-06-01T14:05:56Z",
          "publishedAt": "2021-05-11T14:45:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "See the accepted answer instead of this one.\nHave a look online, or inside MOOSE, for const_cast",
                  "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-725982",
                  "updatedAt": "2022-06-01T14:05:56Z",
                  "publishedAt": "2021-05-11T21:14:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "Thank you Andy! This is just what I need.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-726540",
                          "updatedAt": "2022-06-01T14:06:26Z",
                          "publishedAt": "2021-05-12T01:01:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "I wouldn't recommend this, it is const for a reason. Any object can get a function, thus if it is non-const then any object could change it. You will find yourself in a situation that by adding a Material that uses a function changes the behavior of the function that is also used by some other object.",
                  "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-729334",
                  "updatedAt": "2022-06-01T14:06:26Z",
                  "publishedAt": "2021-05-12T14:05:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I second @aeslaughter 's point. @xuxiaobei1995 if you can let us know what you want to do by \"modifying its data\", we can offer more help.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-733737",
                          "updatedAt": "2022-06-01T14:06:41Z",
                          "publishedAt": "2021-05-13T13:10:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "Thanks for your suggestion! What I want is to give an array to my function. The function is computed based on the array. I added a vector as a data member in the function for storing the array. My previous way is to get the function (using getFunction()) and access the vector directly. Do you know the safer way to implement this? @aeslaughter @hugary1995",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734425",
                          "updatedAt": "2022-06-01T14:06:43Z",
                          "publishedAt": "2021-05-13T15:36:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "What type of object is giving the array to the Function? And when do you need this to happen?",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734484",
                          "updatedAt": "2022-06-01T14:07:01Z",
                          "publishedAt": "2021-05-13T15:52:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "You should probably add a method that takes a const view of your array.\nFunctions really should only be used for simple calls when you always pass a position and time to get a value. I would advise against adding methods to them, because in my opinion you should only be using a Function when it follows through the normal value interfaces that take a point and time.\nI would suggest creating a UserObject that has such a custom method on it (where you pass in your data). You can then couple to this UserObject and call its methods from within your other MooseObject.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734485",
                          "updatedAt": "2022-06-01T14:07:28Z",
                          "publishedAt": "2021-05-13T15:53:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "What type of object is giving the array to the Function? And when do you need this to happen?\n\nIt is a transfer which receives the array from the masterapp. So it happens at TIMESTEP_BEGIN or TIMESTEP_END",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734608",
                          "updatedAt": "2022-06-01T14:07:29Z",
                          "publishedAt": "2021-05-13T16:23:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "You should probably add a method that takes a const view of your array.\nFunctions really should only be used for simple calls when you always pass a position and time to get a value. I would advise against adding methods to them, because in my opinion you should only be using a Function when it follows through the normal value interfaces that take a point and time.\nI would suggest creating a UserObject that has such a custom method on it (where you pass in your data). You can then couple to this UserObject and call its methods from within your other MooseObject.\n\nThanks for your nice advice! It is indeed more reasonable to store the array in a Userobject and let the function couples the userobject to get the data.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734636",
                          "updatedAt": "2022-06-01T14:07:28Z",
                          "publishedAt": "2021-05-13T16:29:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "It is indeed more reasonable to store the array in a Userobject and let the function couples the userobject to get the data.\n\nI don't think you want to store the array in the UserObject. Let's say your data structure that you're passing is a std::vector<Real>, my suggestion is to create a member function on your UO that has a signature something like:\nReal getValue(const std::vector<Real> & data) const;\n\nIn this case, you're passing a const reference to the UO so that it can look at the data, and then create a value based on it. I'm not suggesting that you actually store the data (your array) in the UO. By doing it this way, you only need const access to the UO and can call const methods on it.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734685",
                          "updatedAt": "2022-06-01T14:08:09Z",
                          "publishedAt": "2021-05-13T16:37:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xuxiaobei1995"
                          },
                          "bodyText": "@loganharbour Thank you Logan! I think I know how to do it now.",
                          "url": "https://github.com/idaholab/moose/discussions/17796#discussioncomment-734860",
                          "updatedAt": "2022-06-01T14:08:23Z",
                          "publishedAt": "2021-05-13T17:05:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ADMaterial Problems",
          "author": {
            "login": "YuhangNIU"
          },
          "bodyText": "Hi all\uff0c\nI know the old and older material property values can be obtained through \"getMaterialPropertyOld and getMaterialPropertyOlder\" in non-AD Material. However, could anyone kindly tell me how to get the AD material property value in ADMaterial at the previous time step?\nThanks,\nYuhang",
          "url": "https://github.com/idaholab/moose/discussions/17822",
          "updatedAt": "2023-03-22T08:33:49Z",
          "publishedAt": "2021-05-13T11:40:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "getMaterialPropertyOld and getMaterialPropertyOlder work for AD material properties as well.\nThere is no point in getting old and older material properties with their dual numbers, because all dual numbers will be zero.",
                  "url": "https://github.com/idaholab/moose/discussions/17822#discussioncomment-733673",
                  "updatedAt": "2023-03-22T08:33:49Z",
                  "publishedAt": "2021-05-13T12:54:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Setting value of an AuxVariable in an external program",
          "author": {
            "login": "bielsnohr"
          },
          "bodyText": "I am investigating how my MOOSE app would call an external program by dealing with a simple toy problem. My external program uses libMesh and only has one function that takes a libMesh System, the name of a variable in that system, and then the time step.\nvoid\nsweeping_gaussian(System & sys, const std::string var_name, Real time)\nThis function sets the value of the named variable on each node using the node coordinates.\nMy objective is to use this function to set the value of an AuxVariable within a sub-app that I will then MultiAppCopyTransfer up to the main app. My sub-app defines a FastIonProblem class that inherits from ExternalProblem. It takes the name of the AuxVariable as a Param, and then retrieves the associated underlying libMesh System in the initialiser list. Naively, I then pass that System directly in my call to the external program function above. Given the function directly \"understands\" the native MOOSE format of the System, I don't think there needs to be a separate in-memory representation of the \"ExternalMesh\" like is most other ExternalProblems. Please correct me if wrong on that point.\n#include \"FastIonProblem.h\"\n#include \"sweeping_gaussian.h\"\n\nregisterMooseObject(\"ExternalFastIonApp\", FastIonProblem);\n\nInputParameters\nFastIonProblem::validParams()\n{\n  InputParameters params = ExternalProblem::validParams();\n\n  params.addClassDescription(\"Retrieve fast ion heat fluxes from an external program\");\n  params.addRequiredParam<VariableName>(\n      \"sync_variable\", \"The variable that the external solution will be synced to\");\n  return params;\n}\n\nFastIonProblem::FastIonProblem(const InputParameters & parameters)\n  : ExternalProblem(parameters),\n    _sync_to_var_name(getParam<VariableName>(\"sync_variable\")),\n    _problem_system(getSystem(_sync_to_var_name))\n{\n}\n\n\nvoid\nFastIonProblem::externalSolve()\n{\n  sweeping_gaussian(_problem_system, _sync_to_var_name, time());\n}\nSo far so good, everything compiles, but upon trying to run the MultiApp with this input for the subapp:\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 10\n  ny = 10\n  nz = 10\n[]\n\n[Problem]\n  type = FastIonProblem\n  sync_variable = fi_heat_flux\n[]\n\n[AuxVariables]\n  [fi_heat_flux]\n  []\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 50\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\nI get the following error:\next_fast_ion0: *** ERROR ***\next_fast_ion0: The following error occurred in the object \"MOOSE Problem\", of type \"FastIonProblem\".\next_fast_ion0: \next_fast_ion0: Unable to find a system containing the variable fi_heat_flux\n\nEvidently, the AuxVariable isn't present on the System I am querying and passing to the external program. A few questions related to this:\n\nAm I going about this in the right way?\nIf yes, how do I get the system that the AuxVariable is on? I suspect related to the addExternalVariable() method that can be overridden for ExternalProblem children, but not quite sure how to go about doing that.\n\nThanks in advance!\n\nUPDATE 2021-05-10 17:38 BST\nI have made some progress myself by realising that I probably needed to call getAuxiliarySystem() instead of getSystem(). So, my constructor now looks like:\nFastIonProblem::FastIonProblem(const InputParameters & parameters)\n  : ExternalProblem(parameters),\n    _sync_to_var_name(getParam<VariableName>(\"sync_variable\")),\n    _problem_system(getAuxiliarySystem().system())\n{\n}\nThis gets rid of my previous error, but now I am getting this error:\n[0]PETSC ERROR: Object is in wrong state\n[0]PETSC ERROR: Not for unassembled vector\n...\n[0]PETSC ERROR: #1 VecCopy() line 1557 in /opt/civet/build_1/conda_builds/conda_envs/next-a7feace123/conda-bld/moose-petsc_1611687302001/work/src/vec/vec/interface/vector.c\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n\nI am wondering if this has to do with how I am setting the solution in my external program. This is what the external function looks like:\nvoid\nsweeping_gaussian(System & sys, const std::string var_name, Real time)\n{\n  // Get a constant reference to the mesh object, system number, and variable\n  // number\n  const MeshBase & mesh = sys.get_mesh();\n  const unsigned int & system_number = sys.number();\n  const unsigned short int & variable_number = sys.variable_number(var_name);\n\n  // Boundary information and the left side id\n  BoundaryInfo boundary_info = mesh.get_boundary_info();\n  boundary_id_type left_side = boundary_info.get_id_by_name(\"left\");\n\n  // Temporary variables for loop calculations\n  dof_id_type dof_i;\n  Real gauss;\n\n  // Loop through the local nodes\n  for (const auto & node_ptr : mesh.local_node_ptr_range())\n  {\n    const Node & node = *node_ptr;\n\n    // Check if the node is on the left side\n    if (boundary_info.has_boundary_id(node_ptr, left_side))\n    {\n      // Retrieve the dof_id for this node\n      dof_i = node.dof_number(system_number, variable_number, 0);\n\n      // Set solution vector at this index to some combination of the\n      // coordinate values\n      gauss = 10000.0 * exp(-(pow((node(1) - time / 50) / 0.1, 2)));\n      sys.solution->set(dof_i, gauss);\n    }\n  }\n};",
          "url": "https://github.com/idaholab/moose/discussions/17795",
          "updatedAt": "2022-07-20T14:55:31Z",
          "publishedAt": "2021-05-11T14:08:49Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@roystgnr Can you help with this?",
                  "url": "https://github.com/idaholab/moose/discussions/17795#discussioncomment-729357",
                  "updatedAt": "2022-07-20T14:55:39Z",
                  "publishedAt": "2021-05-12T14:10:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "Do you simply need to close the vector you're setting before you leave your program?  With PETSc (or any other distributed numerics), most write operations are merely initiated by the setter function, not necessarily completed (because you don't want every set() to potentially delay waiting on a network reply).\nYou might try doing a sys.solution->close() (which completes all the set()s) and a sys.update() (which syncs changes from solution to current_local_solution) at the end of sweeping_gaussian()",
                  "url": "https://github.com/idaholab/moose/discussions/17795#discussioncomment-730440",
                  "updatedAt": "2022-07-20T14:55:39Z",
                  "publishedAt": "2021-05-12T17:46:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bielsnohr"
                          },
                          "bodyText": "Yes, not closing the vector in sweeping_gaussian() was indeed the problem. Putting\nsys.solution->close()\nsys.update()\nat the end of the function resolved the error and now my MultiApp runs. Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/17795#discussioncomment-733413",
                          "updatedAt": "2022-07-20T14:55:40Z",
                          "publishedAt": "2021-05-13T11:43:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Accessing shape functions for coupled variables in mixed finite elements for off-diag Jacobian",
          "author": {
            "login": "gridley"
          },
          "bodyText": "From what I can tell, the examples of computeOffDiagJacobian use the same shape and test functions between the primary and coupled variables. I've got a vector kernel that has a coupled scalar variable, so the main variable's shape functions are different from the coupled one's. I know that _phi contains the shape functions for the main variable, which is a vector, but how can I access the shape functions for the coupled scalar variable?\nI need this to get the derivative w.r.t. the term the coupled scalar variable gives in the vector kernel.",
          "url": "https://github.com/idaholab/moose/discussions/17789",
          "updatedAt": "2022-06-29T02:44:14Z",
          "publishedAt": "2021-05-10T14:10:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad Can you help out?",
                  "url": "https://github.com/idaholab/moose/discussions/17789#discussioncomment-729544",
                  "updatedAt": "2022-06-29T02:44:23Z",
                  "publishedAt": "2021-05-12T14:39:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "gridley"
                  },
                  "bodyText": "I think I figured this out as well. It seems you need to use a MooseVariable to access the other shape functions. For example, below, i store a MooseVariable pointer to _p_var and access its scalar shape functions in the computeQpOffDiagJacobian method. I have confirmed this gives the right answer.\n#pragma once\n\n#include \"VectorKernel.h\"\n\n/**\n * This class computes all\n */\nclass INSMomentum : public VectorKernel\n{\npublic:\n  static InputParameters validParams();\n\n  INSMomentum(const InputParameters & parameters);\n\n  virtual ~INSMomentum() {}\n\nprotected:\n  virtual Real computeQpResidual() override;\n  virtual Real computeQpJacobian() override;\n  virtual Real computeQpOffDiagJacobian(unsigned jvar) override;\n\n  const bool _transient;\n\n  // The pressure variable\n  const VariableValue & _p;\n  const VariableGradient & _grad_p;\n  const MooseVariable * _p_var;\n\n  // Velocity time derivatives\n  const VectorVariableValue & _u_dot;\n  const VariableValue & _du_dot_du;\n\n  // Material properties\n  const Real _mu;\n  const Real _rho;\n  const Real _alpha;\n  const Real _nu; // cache this\n};\n#include \"INSMomentum.h\"\n\nregisterMooseObject(\"whaleApp\", INSMomentum);\n\nInputParameters\nINSMomentum::validParams()\n{\n  InputParameters params = VectorKernel::validParams();\n  params.addClassDescription(\"all of the momentum eqn but its time derivative\");\n  params.addRequiredCoupledVar(\"p\", \"pressure\");\n  params.addParam<Real>(\"alpha\", 1, \"Multiplicative factor on the stabilization parameter tau.\");\n  params.addParam<bool>(\"transient\", false, \"whether this is a transient calculation\");\n  params.addRequiredParam<Real>(\"rho\", \"fluid density\");\n  params.addRequiredParam<Real>(\"mu\", \"fluid density\");\n  return params;\n}\n\nINSMomentum::INSMomentum(const InputParameters & params)\n  : VectorKernel(params),\n    _transient(getParam<bool>(\"transient\")),\n    _p(coupledValue(\"p\")),\n    _grad_p(coupledGradient(\"p\")),\n    _p_var(getVar(\"p\", 0)),\n    _u_dot(_transient ? _var.uDot() : _vector_zero),\n    _du_dot_du(_transient ? _var.duDotDu() : _zero),\n    _mu(getParam<Real>(\"mu\")),\n    _rho(getParam<Real>(\"rho\")),\n    _alpha(getParam<Real>(\"alpha\")),\n    _nu(_mu / _rho)\n{\n  if (_p_var == nullptr)\n    mooseError(\"fail to get pressur var?\");\n}\n\nReal\nINSMomentum::computeQpResidual()\n{\n  auto strong_resid_part = _rho * (_u_dot[_qp] + _grad_u[_qp] * _u[_qp]) + _grad_p[_qp];\n  return _test[_i][_qp] * strong_resid_part + _mu * _grad_u[_qp].contract(_grad_test[_i][_qp]) +\n         _u[_qp] * _grad_test[_i][_qp] * strong_resid_part;\n}\n\nReal\nINSMomentum::computeQpJacobian()\n{\n  return _rho * _test[_i][_qp] *\n             (_phi[_j][_qp] * _du_dot_du[_qp] + _grad_u[_qp] * _phi[_j][_qp] +\n              _grad_phi[_j][_qp] * _u[_qp]) +\n         _mu * _grad_phi[_j][_qp].contract(_grad_test[_i][_qp]);\n}\n\nReal\nINSMomentum::computeQpOffDiagJacobian(unsigned jvar)\n{\n  if (jvar == _p_var->number()) {\n    return _test[_i][_qp] * _p_var->gradPhi()[_j][_qp];\n  } else {\n    return 0.0;\n  }\n}",
                  "url": "https://github.com/idaholab/moose/discussions/17789#discussioncomment-729728",
                  "updatedAt": "2022-06-29T02:44:26Z",
                  "publishedAt": "2021-05-12T15:21:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Setting up a block diagonal (blocks separated by variables) preconditioner",
          "author": {
            "login": "gridley"
          },
          "bodyText": "Hi all,\nSo, I have a Jacobian of the form:\n\nNot very surprising, since you could write any matrix like this. The key is that the blocks are separated by the variables. The top row is a pressure Poisson equation, and the bottom row is a momentum equation. I know that A is a Poisson operator, so I'd like to use multigrid here. I'd like to apply block-diagonal preconditioning like:\n\nWhere \\tilde A^{-1}, an approximation to the true inverse of A, comes from one or two applications of boomeramg or the like, and \\tilde D^{-1}, an approximation to the inverse of D, would come from some other as-yet specified preconditioner I know will work well on that type of physics.\nSo, I think there's some way to do this with pcfieldsplit. Could any one point me at an example like this? It seems there is some undocumented Split.h file that may do this. Not sure which is the best way to approach this.\nEDIT: after thinking on this some more, this request maybe doesn't make sense. If anyone recommends reading that explains theory behind the object in Split.h, I'd really like to hear.\nThanks for your time,\nGavin",
          "url": "https://github.com/idaholab/moose/discussions/17775",
          "updatedAt": "2022-10-17T13:22:28Z",
          "publishedAt": "2021-05-07T23:24:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "gridley"
                  },
                  "bodyText": "To partially answer my own question, there are references to explain the different field split approaches in the MOOSE incompressible navier stokes module paper. I'm still not sure whether these are best applied using the Split object in Split.h or via Petsc arguments.\nhttps://arxiv.org/abs/1710.08898",
                  "url": "https://github.com/idaholab/moose/discussions/17775#discussioncomment-718615",
                  "updatedAt": "2022-10-17T13:22:29Z",
                  "publishedAt": "2021-05-10T13:52:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "@fdkong Can you help please?",
                          "url": "https://github.com/idaholab/moose/discussions/17775#discussioncomment-729546",
                          "updatedAt": "2022-10-17T13:22:28Z",
                          "publishedAt": "2021-05-12T14:39:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gridley"
                          },
                          "bodyText": "Hey, I had messaged Fande in the MOOSE slack and think I figured it out. You have to use -pc_type fieldsplit -pc_fieldsplit_type schur -pc_fieldsplit_schur_fact_type diag. Then there are tons of other options to set up the field split solve, but this seems to converge as expected, albeit seeming to have some serious associated overhead with setting up intermediate matrices needed for this approach.",
                          "url": "https://github.com/idaholab/moose/discussions/17775#discussioncomment-729587",
                          "updatedAt": "2022-10-17T13:23:26Z",
                          "publishedAt": "2021-05-12T14:47:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "defineLegacyParams ()",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "MOOSE group,\nI am learning the MOOSE program. Please help me.\nI see in the header file:\ntemplate <>\nInputParameters validParams();\nThen, in the source file:\ndefineLegacyParams (DirichletBC);\nI don't see them for ADDirichletBC.\nPlease let me know why defineLegacyParams (ADDirichletBC) is not needed for the AD version.\nThomas",
          "url": "https://github.com/idaholab/moose/discussions/17798",
          "updatedAt": "2023-05-23T02:14:46Z",
          "publishedAt": "2021-05-11T15:06:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Thomas\nThese is legacy code that is kept only in older object for compatibility with applications that would not have updated the way they use input parameters.\nAll new objects do not need this, and it's probably why the AD version, which came later, does not have it.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17798#discussioncomment-724535",
                  "updatedAt": "2023-05-23T02:14:58Z",
                  "publishedAt": "2021-05-11T15:43:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you very much Guillaume!\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17798#discussioncomment-725336",
                          "updatedAt": "2023-05-23T02:15:10Z",
                          "publishedAt": "2021-05-11T18:24:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "AD material properties vs regular material properties",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hi all, when I run the code which contains block [[Modules/TensorMechanics/Master] [all]], there is an error as follows, do you ever occur the same/similar error and how to correct it?  And what is the difference between AD material properties and regular material properties? Thank you.\n*** ERROR ***\nThe requested AD material property mechanical_strain is declared as a regular material property. Either retrieve it as a regular material property with getMaterialProperty or declare it as an AD property wtih declareADProperty",
          "url": "https://github.com/idaholab/moose/discussions/17786",
          "updatedAt": "2022-10-26T13:36:25Z",
          "publishedAt": "2021-05-10T11:25:48Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "vanwdani"
                  },
                  "bodyText": "I don't know exactly what your input file/code looks like, but I would guess you have enabled the AD system in some fashion.  More about the AD: https://mooseframework.inl.gov/bison/automatic_differentiation/index.html",
                  "url": "https://github.com/idaholab/moose/discussions/17786#discussioncomment-719125",
                  "updatedAt": "2022-10-26T13:36:25Z",
                  "publishedAt": "2021-05-10T15:30:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/17786#discussioncomment-724209",
                          "updatedAt": "2022-10-26T13:36:38Z",
                          "publishedAt": "2021-05-11T14:44:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Libmesh conda compatibility with old moose",
          "author": {
            "login": "louisBS"
          },
          "bodyText": "Hi all,\nI updated my libmesh ( using conda update -all) and now I cannot compile my old moose using the latest libmesh. It's a bit of a pain for me to rebase my moose by resolving all the conflicts, so I wonder if there's any way for me to downgrade my libmesh version using conda to what it was before ?\nThank you very much,\nLouis",
          "url": "https://github.com/idaholab/moose/discussions/17790",
          "updatedAt": "2022-08-10T11:44:09Z",
          "publishedAt": "2021-05-10T20:34:41Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "travismui"
                  },
                  "bodyText": "I believe you can use conda search -i moose-libmesh to find the available versions of libmesh for moose and then use conda install moose-libmesh=<ver> to install a specific version (i.e. moose-libmesh=2021.02.15 to roll back one version). This should also roll back any dependencies like moose-petsc to their correct versions as well, but there may be other packages that you may also need to roll back separately.",
                  "url": "https://github.com/idaholab/moose/discussions/17790#discussioncomment-723950",
                  "updatedAt": "2022-08-10T11:44:32Z",
                  "publishedAt": "2021-05-11T14:00:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}