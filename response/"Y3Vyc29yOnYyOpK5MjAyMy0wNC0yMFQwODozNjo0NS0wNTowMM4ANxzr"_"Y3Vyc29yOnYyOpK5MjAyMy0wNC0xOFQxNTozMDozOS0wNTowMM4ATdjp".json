{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNC0xOFQxNTozMDozOS0wNTowMM4ATdjp"
    },
    "edges": [
      {
        "node": {
          "title": "Supplying element-neighbor pairs for (periodic) interface calculations",
          "author": {
            "login": "ttruster"
          },
          "bodyText": "I am planning some implementations regarding periodic boundary conditions. Though there are several existing methods for them in MOOSE, I feel that adding the weak enforcement using surface integrals has some benefits not yet realized.\nTo start out, I studied the behavior of input files having BreakMeshByBlockGenerator. If the Exodus mesh is written out after calling this command, and then a new input file reads this mesh, then the computed result is different. As mentioned in the discussion here, #18240 (reply in thread), that is because a 'trick' is used in BreakMeshByBlockGenerator whereby the nodes are duplicated and the nodes-to-element connectivity is updated, but the element-neighbor information is not updated (i.e. is retained) internally. So it makes sense that if the modified mesh is written, though it contains a Side-Set, that set is one-sided and lacks the neighbor-element pairing required to recreate the internal state of the memory of the previous analysis.\nMy question is, is the only information I would be required to read in through a text file, the element-neighbor pairing (element ID and faces)? Or is there some other orientation information needed to update the Libmesh quadrature point projections? @arovinelli\nsuggested that only this information would be needed, and gave 4 lines of code for it. If this sounds like the approach, then I'll try hard-coding those lines within a new Mesh-Generator object, and see if that allows the read-in mesh to provide the same result as the original BreakMeshByBlockGenerator result.\nAlternatively, I saw a discussion here, #18580 (reply in thread), about Libmesh periodic features. Are those periodic listings node-based (like multi-point conditions) or face-based? From this discussion #20232, it sounds like they are face-based. I can't easily tell from the source code https://mooseframework.inl.gov/docs/doxygen/libmesh/periodic__boundaries_8C_source.html#l00038 what kind of periodic treatment Libmesh is doing (nodal, penalty, mortar, Nitsche); so suggested reading would help here as well.",
          "url": "https://github.com/idaholab/moose/discussions/22948",
          "updatedAt": "2023-04-20T03:14:01Z",
          "publishedAt": "2022-12-12T19:50:40Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "Question at the bottom about inverse_map.\nSo I was able to verify that reassigning the element-neighbor pair through a Mesh-Generator class was able to restore the connection needed for the cohesive simulation.\nElem * current_elem = mesh->elem_ptr(elem_id);\nElem * neighbor_elem = mesh->elem_ptr(neighbor_id);\ncurrent_elem->set_neighbor(elem_side, neighbor_elem);\nneighbor_elem->set_neighbor(neighbor_side, current_elem);\nThus, maybe on day in the future, we could add a feature to BreakMeshByBlockGenerator to export a CSV list of this data while running, and having another mesh class that reads it back in.\nOn the second topic for periodic BC, I spent an hour looking through the code for how neighbor_data is initialized, and I finally found within the Assembly class the reinitElemAndNeighbor function and within it the Libmesh FEInterface::inverse_map call. That's what I expected to find, because somehow the neighbor quadrature point needs to know which element quadrature point to link up with. The face alone isn't enough; there needs to be some projection/lookup/reorientation that is checked.\nIs anyone familiar with the source code of inverse_map who can discuss how I would add the calculation of a translate/offset during the projection to handle periodic pairs that are parallel but translated (i.e. not adjacent like in usual meshes with Interface Kernels)? I can imagine doing this from the average coordinate of the corner nodes or of the quadrature point coordinates, such that it is internal and doesn't need any change to the argument list.",
                  "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4403244",
                  "updatedAt": "2022-12-14T19:14:58Z",
                  "publishedAt": "2022-12-14T19:14:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@roystgnr @lindsayad  on periodics BCs and FEInterface",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4404652",
                          "updatedAt": "2022-12-14T22:55:53Z",
                          "publishedAt": "2022-12-14T22:55:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "About the element-neighbor pairing: I noticed that BreakMeshByBlockGenerator can output two side sets (one for element and one for neighbor), and they are synced (i.e. the 5th element-face item is the one adjacent to the 5th neighbor-face item). Thus, instead of writing a CSV file and reading that, we could instead just write both sidesets to the .e file generated by --mesh-only. Then when this mesh is read back, a new MeshGenerator object could be run afterward with parameters pointing to the element and neighbor sidesets which then loops through them and sets the pairs into the mesh topology. First, we would need to make sure that the existing cohesive zone input files run fine if add_interface_on_two_sides parameter is true.\nWhen my current work gets done, I can open an issue to incorporate this change, which in short would allow meshes generated using BreakMeshByBlockGenerator to be written with --mesh-only and subsequently read back and updated for new analyses.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4415422",
                          "updatedAt": "2022-12-16T01:06:09Z",
                          "publishedAt": "2022-12-16T01:06:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I assume we can add interfaces on both sides but only run the czm material on one of them. I vaguely recall that's doable, but you want to double check before diving too deep, as we don't want to make the interface model twice expensive.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4415552",
                          "updatedAt": "2022-12-16T01:38:44Z",
                          "publishedAt": "2022-12-16T01:38:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "If there's no mesh refinement going on, and if the periodic variable is scalar-valued (not SCALAR meaning one component per mesh, but \"scalar\" meaning one component per point), things end up being very simple: all the DoFs on one side end up constrained to DoFs on the other side.  If the periodicity is a linear translation, each just has an x_i=x_j one-to-one constraint equation to one DoF on the other side.  If in addition the variable is LAGRANGE then it's just a matter of locating matching nodes; for other variable types we do matching at vertices but we solve little local projections via quadrature for edge and face DoFs.\nThe projections actually become important if there's any h refinement: in that case the fine element DoFs are always constrained to the coarse periodic neighbor rather than the other way around, and the solutions to the projection equations end up being much more interesting than identity matrices.  Even without adaptivity, if the periodicity involves a rotation and the variable type is more complicated than LAGRANGE, then at higher order the way we do DoF indexing can cause the constraint equations to be more of a permutation (albeit again unidirectional).\nAnyway, the inverse_map() calls come from the quadrature evaluations for those projection equations.  But the final enforcement isn't variational; the constrained space just doesn't contain any functions with a discontinuity across the boundary.  And we calculate the constraint equations once when the mesh changes; we don't do those lookups every time we have a residual and/or Jacobian to constrain, we just take the existing sparse constraint matrices and do K^T*r or K^T*J*K.\nSetting neighbor pointers manually is currently undefined behavior.  It might work, in the same sense as an OOB array access might work, but if it ever stops working and your code breaks then you don't get to tell the compiler/library to make it work again, you just get to keep the broken pieces.\nEdit:\n\nadd the calculation of a translate/offset during the projection to handle periodic pairs that are parallel but translated\n\nSorry that after all my rambling I haven't answered the real meat of your question, but I honestly don't understand it.  Periodic pairs that are parallel but translated aren't a weird special case, they're the common case.  The basic PeriodicBoundary class takes a translation vector in its constructor.  MOOSE has its auto_direction trick to auto-determine the translation vector for you, but you can also set a translation vector manually, or even an arbitrary transform_func and inv_transform_func.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4481121",
                          "updatedAt": "2022-12-23T02:15:44Z",
                          "publishedAt": "2022-12-23T02:07:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "Sorry it's taken me some time to get back to this point @roystgnr. The origin of the question is because we are implementing a variational version of enforcing the periodic conditions as opposed to the nodal-constraint (DOF-constrained equations with the K matrix that you mention). I was originally developing this for the MortarConstraint class similar to the tying constraint in https://mooseframework.inl.gov/source/constraints/EqualValueConstraint.html. However, to summarize my response below, that approach won't work easily for tensor-mechanics module because of stateful materials. So instead I'll be using InterfaceKernels, more like https://mooseframework.inl.gov/source/interfacekernels/PenaltyInterfaceDiffusion.html.\nThe physical reason for this: say you are modeling a polycrystalline material and you want to simulate grain boundary sliding or cracking or something, and now the crack runs along the periodic surface. So, that's easy to handle if the interface kernel is already handling the periodic condition; you just add a constitutive model to evolve the size of the discontinuity.\nMy question:\nYou mention that \"Setting neighbor pointers manually is currently undefined behavior\". However, the code compiles and runs fine for me with the four lines I mentioned above. Also, in the source code at https://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1Elem.html#a40980d9226643eb7dfd86b1c150c888e, the set_neighbor function seems to be defined. My assumption is, an element instance is initialized (i.e. when the mesh is first loaded) with an _elemlinks list that has as many entries as facets of the element. If their isn't a neighbor on a facet, then it's left as zero or something. Am I incorrect with that assumption, and the number of neighbors is fixed at the time the mesh is loaded? I notice calls to set_neighbor in ElementDeletionGeneratorBase of Moose that passes a null pointer, and several calls to it within the libmesh source.\nIf this is actually defined, then I'll be opening a discussion on the libmesh forum about including a changed I've made to identify non-adjacent boundary objects, which could be used for such InterfaceKernels mentioned above, and I'll link back to this discussion here.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4832656",
                          "updatedAt": "2023-01-31T17:56:53Z",
                          "publishedAt": "2023-01-31T17:56:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "At some point we need to make a firm design decision on whether we want to continue to evolve support for what I personally see as abuse of the element neighbor concept, or whether we want to think very seriously about how to support stateful material properties in mortar; see my response in another thread. I'm curious for @roystgnr's opinion on this, especially as he is currently working in the stateful material property projection code.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4844079",
                          "updatedAt": "2023-02-01T19:06:58Z",
                          "publishedAt": "2023-02-01T19:06:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "From working on interface methods for a while, my opinion is that there are three somewhat well-delineated categories:\n\nContinuous/conforming meshes and no interface; using multi-point constraints to tie blocks for separate parts or periodic conditions\nConforming or adaptively refined meshes with hanging nodes that have Penalty/Nitsche/Lagrange-multiplier enforcement of weak continuity along the interface. Here, the corner nodes on the coarse mesh are conforming everywhere, even on external boundaries.\nNonconforming interfaces, mesh tying, and contact/friction modeling as well as embedded mesh methods using Penalty/Nitsche/Mortar enforcement of the interface conditions.\n\nThese 3 categories increase in generality of problem class from top to bottom while also increasing in implementation/architecture complexity and projection errors. I've implemented all 3 categories before in my matlab FEM codes and in FEAP. Within MOOSE, I see these 3 mapping onto Kernels, InterfaceKernels, and MortarConstraints respectively. So, the middle category is a compromise in difficulty and generality. The difficulty is moderate since the quadrature point location on each side of the interface is identical once an offset vector (potentially zero) is introduced; I assume that idea works even for adaptively refined meshes and the InterfaceKernels for those. This means that no extra projection or copying of stateful materials from quadrature point locations on opposite sides is needed.\nSo, my suggested restriction is to say that non-adjacent element-neighbor concept would only be permitted for two parent element faces  that geometrically conform after a constant offset vector. This would allow usage of existing InterfaceKernel classes to solve problems with \"gaps\" between the two surfaces, for example finite-thickness cohesive zone (CZM) interfaces in solid mechanics. As an exaggeration of that, I made an example in Dropbox here  that uses one of the Tensor Mechanics CZM test files and adds a 1-unit offset between the interface. The computed behavior (initially linear, then debonding) is identical for the two input files except for the extra separation.\nI'm all for the improvement of the stateful materials for the Mortar method which will help a lot for contact problems and mesh tying, to be able to solve new problems. I just think that the middle category could be extended to its \"limit\" by allowing for the neighbors to be topologically defined (namely, conforming with an offset vector added) rather than solely adjacent.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4894902",
                          "updatedAt": "2023-02-07T15:30:38Z",
                          "publishedAt": "2023-02-07T15:30:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "As I reflect about my wording above, I probably am sounding \"mighty\" that I have experience on interfaces. Okay, fine, but I know my opinion isn't the only one or even the best one. I just advocate it because I'll keep needing to cherry-pick our adaptation in for reach future change in Libmesh/Moose so that our app developments keep working.\nI do want to remind us what got me started on the post, which is sort of the original \"abuse\" of element-neighbor concept that happens in BreakMeshByBlockGenerator. Most other InterfaceKernels act on a conforming mesh with two different variables on opposite sides of an interface that are coupled together; thus the element and neighbor share nodes/connectivity. The BreakMeshByBlockGenerator instead performs node duplications, revises the connectivity on the neighbor side, and keeps the element-neighbor pointers internally in the Moose job execution. Once that mesh is written to Exodus, that runtime connectivity is lost and can't be reloaded/restarted. Thus, the element-neighbor concept was \"abused\". However, it served the purpose for enabling cohesive zone modeling, with the same displacement variables on both sides of the interface yet with discontinuous interpolation. So that's why I feel this change would fall into that same umbrella. And, it would help to solve the lack of restart feature for cohesive modeling, as mentioned elsewhere in this discussion #22948 (reply in thread).",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4899368",
                          "updatedAt": "2023-02-08T00:26:00Z",
                          "publishedAt": "2023-02-08T00:25:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "What happens if the two sides of an \"interface\" live on two processors? I suppose the algebraic ghosting is not too difficult to handle with the relationship managers, but how about other data structures such as the element-neighbor pairs and their offsets? I guess my point is we should take distributed mesh into consideration if we are trying to make a design choice here. CZM is right now the sole limiting factor for scalability in our code.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4900061",
                          "updatedAt": "2023-02-08T02:16:19Z",
                          "publishedAt": "2023-02-08T02:16:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "I would say that the treatment of distributed meshes, neighbors across processors, should be the same either for adjacent or the separated pairs. The neighbor is just indicated by an element pointer, and the offset vector for projecting the quadrature point location is just computed from average coordinates. So, if current CZM or InterfaceKernels work for distributed meshes, then this approach should as well, as long as the neighbor pointer assignment can query across processors.\nWhen I was searching the Libmesh source before implementing my ideas in my repos, I had seen the topological_neighbor method for Elements, which makes reference to Periodic Boundary objects. https://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1Elem.html#ae81b9875caed609205c970d9cc0134a2. I couldn't find a routine in MOOSE that calls this method, and within Libmesh the places I found calling it seemed to be for adaptive meshing or for the creation/destruction of ghost elements, which is what you are referring to. Hopefully @roystgnr can comment on this method, as it might be partially what we need; though it seemed to me that it does a search over all members of a Periodic Boundary, which could be avoided if the pair is recorded once and for all.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4900314",
                          "updatedAt": "2023-02-08T03:01:38Z",
                          "publishedAt": "2023-02-08T03:01:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Do you not want to use mortar?",
                  "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4405162",
                  "updatedAt": "2022-12-15T00:20:40Z",
                  "publishedAt": "2022-12-15T00:20:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "Good question! So, I had forgotten my notes from the summer when talking with @reverendbedford that the Mortar objects don't allow stateful materials. This is an issue for applying PBC using the Nitsche/DG method for Tensor Mechanics using the Mortar approach. So I was developing for the heat conduction/diffusion case using the mortar objects up to now (which you're familiar with that), and then we tried porting to Tensor Mechanics and hit the stateful error message.\nI can add more details later. What the two paths are for getting to our formulation goal is:\n\nAdd stateful materials to mortar objects in the case when quadrature points are fixed for all time (the case for mesh tying such as PBC; NOT the case for contact mechanics). Then add the ability to have a vector offset for the search/projection direction between primary and secondary sides; this is needed for non-rectangular RVE domains.\nUse interface kernels for the PBC Nitsche method and Lagrange multiplier methods, which work for stateful materials. This requires the reading in of element-neighbor pairs (demonstrated above) and the ability for the pair to not be physically adjacent. Obviously the mortar method functions already do that for quadrature points (using projection along the unit outward normal) since the surfaces can be separated. So I just need to access the inverse_map in a similar fashion.\n\nIt seemed to me that, option 2 would require less implementation (as I have existing codes that generates all the needed element-neighbor pairs; just need a MeshGenerator that reads a CSV file of those and updates the mesh). And I can use the diffusion mortar PBC implementations to check the new implementation.",
                  "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4405451",
                  "updatedAt": "2022-12-15T01:28:57Z",
                  "publishedAt": "2022-12-15T01:28:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I had a very similar discussion with Alex a while ago actually. 1 is tough, quoting Alex. Though it might be easier if we assume the mortar mesh never changes. Plus it doesn't require libmesh level changes, unlike option 2 which requires modifying inverse_map().\nI can see how 2 might work as well. Since implementing a mesh generator which enables restarting a CZM simulation also helps many of our simulations, I will also be supportive of option 2.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4405587",
                          "updatedAt": "2022-12-15T01:58:19Z",
                          "publishedAt": "2022-12-15T01:58:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Let's try to respond within relevant threads to keep the discussion thread clear. For cases where the mesh can change, I've often felt that the current way we do stateful material properties is a little disappointing. Yes we have an implementation for projection of material properties, but this would be very natural if the \"stateful properties\" were finite element approximations. Then we have incredibly generic projections (the libMesh GenericProjector for example) immediately at our disposal. Additionally within the mortar method, even if the mortar segments change, the ability to evaluate finite element bases connected to the parent mesh is flawless. So aux variables for instance work \"flawlessly\" with mortar, and you have access to old and older states (up to arbitrarily old states). I quote \"flawlessly\" because it's not quite flawless when you want to do AD as we do not yet have first class capability for storing aux variables with AD information",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4407007",
                          "updatedAt": "2022-12-15T06:15:20Z",
                          "publishedAt": "2022-12-15T06:15:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "For problems in which you do not have mesh adaptivity or something like mortar, the way we do stateful material properties is great... you do not introduce any error by projecting your material property evaluations into a finite element basis approximation.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4407022",
                          "updatedAt": "2022-12-15T06:19:28Z",
                          "publishedAt": "2022-12-15T06:19:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "I started discussing the mortar case sense you brought it up :) but my other problem is that I missed the \"Write a reply\" box.\nThe mortar system was helpful for testing out the weak imposition of periodic conditions, but it is more general than our typical use case which will be conforming mesh tying across the external surfaces. Mortar would allow for non-conforming PBC, but is a bit more expensive due to interface segments and also has a different parallelization compared to Interface Kernels. Also, the topic of stateful materials for constitutive models in tensor mechanics is a lengthy discussion which I agree is off topic here.\nSo, I will up-vote my response above about the element-neighbor pairing and comment on the inverse_map below, which can be moved to a separate discussion and issue.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4415467",
                          "updatedAt": "2022-12-16T01:16:15Z",
                          "publishedAt": "2022-12-16T01:16:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "I'm not sure how inverse_map() works, but if it has access to either the coordinates of 1. nodes of the face or 2. the quadrature points of the face or else 3. the centroid of the face, then the easy way to compute the offset is just to average them and subtract them. That can be done at EVERY interface, since for adjacent ones the offset will be (0,0,0). That way, no flags have to get passed in, at the expense of some vector additions/divisions for each element pair.",
                  "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4405761",
                  "updatedAt": "2022-12-15T02:36:47Z",
                  "publishedAt": "2022-12-15T02:36:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The inverse map solves a normal equation to locate a point in the parametric space. So 1. Yes. 2. It could be any point, not limited to qps. 3. I'm sure that information is indirectly available somehow.\nBut inverse_map() is a performance critical low level routine, you'll probably have to overload it, not modifying the existing implementation which adds any computational cost.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4405791",
                          "updatedAt": "2022-12-15T02:44:50Z",
                          "publishedAt": "2022-12-15T02:44:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "I found the source code with the source code in FEMap::inverse_map() that solves the normal equation you mentioned. So if I look up the data structure of element_data and neighbor_data, I will look for a low-impact way to incorporate the change, which will likely involve a flag and might get handled either in inverse_map or even nicer if in Assembly::reinitElemAndNeighbor.",
                          "url": "https://github.com/idaholab/moose/discussions/22948#discussioncomment-4415490",
                          "updatedAt": "2022-12-16T01:21:41Z",
                          "publishedAt": "2022-12-16T01:21:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Axisymmetric coordinates postprocessing",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Hello everyone,\nI had two questions regarding the axisymmetric coordinates.\n\nLet's say that I solved my problem in RZ coordinates. Now I want to visualize my 2D data in 3D. What is the most convenient way to do it?\nI have a variable which is called \"c\". I want to integrate c over the 3D volume, not the 2D surface. Is there any available kernel for that? This volume integration would be an important part of my work.\n\nThank you,\nAli",
          "url": "https://github.com/idaholab/moose/discussions/24117",
          "updatedAt": "2023-04-29T02:35:05Z",
          "publishedAt": "2023-04-19T01:43:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "You can use Preview, see Rotational Extrusion filter.\nIf you are using PostProcessor, it will automatically account for coordinate system. It does volume integral.",
                  "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655435",
                  "updatedAt": "2023-04-19T02:22:02Z",
                  "publishedAt": "2023-04-19T02:22:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Not Preview, but Paraview :)\nYou may need to \"Extract Surface\" before applying the extrusion filter.",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655536",
                          "updatedAt": "2023-04-19T02:35:40Z",
                          "publishedAt": "2023-04-19T02:35:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "And \"Transform\" filter :-)",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655545",
                          "updatedAt": "2023-04-19T02:37:40Z",
                          "publishedAt": "2023-04-19T02:37:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "I used Paraview. Firstly, I needed to use \"Extract Surface\" and then  \"Rotational Extrusion\".\nThis is part of my input file and I use RZ coordinates. So this one calculates the c volume integral on the domain. Correct?\n\n[Postprocessors]\n  [./c_integral]\n    type = ElementIntegralVariablePostprocessor\n    variable = c\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655866",
                          "updatedAt": "2023-04-19T03:39:46Z",
                          "publishedAt": "2023-04-19T03:39:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Correct. This is over the entire mesh, and in 2D RZ it corresponds to a 3D volume integral because the local element Qp volumes are multiplicated by 2 pi r",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655912",
                          "updatedAt": "2023-04-19T04:07:51Z",
                          "publishedAt": "2023-04-19T03:47:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "No, it doesn't work by multiplying element volumes by 2 pi r, which would yield the wrong answer. There's a coordinate transformation Jacobian which is r.",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655971",
                          "updatedAt": "2023-04-19T04:02:50Z",
                          "publishedAt": "2023-04-19T04:02:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Ok, so because of the Jacobian coordinate transformation, the volume integral would be correctly calculated? Here is my results for c integration (order parameter in the phase field), which is supposed to be conserved. I don't know why I get the oscillation!\n\nThanks,\nAli",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5667379",
                          "updatedAt": "2023-04-19T23:30:27Z",
                          "publishedAt": "2023-04-19T23:30:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what is the X axis here ?",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5667409",
                          "updatedAt": "2023-04-19T23:34:49Z",
                          "publishedAt": "2023-04-19T23:34:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Y axis is c integral, and X axis is time.",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5667419",
                          "updatedAt": "2023-04-19T23:36:01Z",
                          "publishedAt": "2023-04-19T23:36:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "What is your BC? Are you running a C-H equation? It only conserves when zero flux BC is applied for chemical potential variable.",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5667428",
                          "updatedAt": "2023-04-19T23:38:51Z",
                          "publishedAt": "2023-04-19T23:38:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "I am running coupled cahn hilliard navier stokes equation. Chemical potential's BC is neumann BC on all 4 boundaries.",
                          "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5667470",
                          "updatedAt": "2023-04-19T23:48:31Z",
                          "publishedAt": "2023-04-19T23:48:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "alimostafavi24"
                  },
                  "bodyText": "Thank you very much (@jiangwen84 @hugary1995 @GiudGiud )!",
                  "url": "https://github.com/idaholab/moose/discussions/24117#discussioncomment-5655958",
                  "updatedAt": "2023-04-19T03:59:36Z",
                  "publishedAt": "2023-04-19T03:59:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiphase flow model using navier_stokes module.",
          "author": {
            "login": "MashrurShejan"
          },
          "bodyText": "Hi. in sequence with my previous questions I am trying to simulate a multiphase flow of an water jet in the air. Currently my simulation code stands as follows-\nvelocity_x = 2\n\n[Mesh]\n  file = xyz.e\n  construct_side_list_from_node_list=true\n[]\n\n[Problem]\n[]\n\n[AuxVariables]\n  [vel_x]\n  []\n  [vel_y]\n  []\n  [vel_z]\n  []\n[]\n\n[AuxKernels]\n  [vel_x]\n    type = VectorVariableComponentAux\n    variable = vel_x\n    vector_variable = velocity\n    component = 'x'\n  []\n  [vel_y]\n    type = VectorVariableComponentAux\n    variable = vel_y\n    vector_variable = velocity\n    component = 'y'\n  []\n  [vel_z]\n    type = VectorVariableComponentAux\n    variable = vel_z\n    vector_variable = velocity\n    component = 'z'\n  []\n[]\n\n[Variables]\n    [velocity]\n        family = LAGRANGE_VEC\n    []\n    [p]\n    []\n[]\n\n[ICs]\n    [velocity]\n        type = VectorConstantIC\n        x_value = 0\n        y_value = 0\n        z_value = 0\n        variable = velocity\n    []\n[]\n\n[Materials]\n  [fluid_properties]\n    type = ADGenericConstantMaterial\n    prop_names  = 'rho mu'\n    prop_values = '1000 0.001'\n  []\n  \n  [ins_mat]\n    type = INSADTauMaterial\n    velocity = velocity\n    pressure = p\n  []\n[]\n\n[Kernels]\nactive = 'mass_conservation momentum_advection momentum_pressure momentum_viscous momentum_supg mass_pspg momentum_time_derivative'\n    [mass_conservation]\n        type = INSADMass\n        variable = p\n    []\n\n    [momentum_advection]\n        type = INSADMomentumAdvection\n        variable = velocity\n    []\n    [momentum_pressure]\n        type = INSADMomentumPressure\n        variable = velocity\n        pressure = p\n    []\n    [momentum_viscous]\n        type = INSADMomentumViscous\n        variable = velocity\n    []\n\n    [momentum_supg]\n        type = INSADMomentumSUPG\n        variable = velocity\n        velocity = velocity\n    []\n    [mass_pspg]\n        type = INSADMassPSPG\n        variable = p\n    []\n\n    [momentum_time_derivative]\n        type = INSADMomentumTimeDerivative\n        variable = velocity\n    []\n[]\n\n[BCs]\nactive = 'inlet outlet no_slip_wall'\n\n    [inlet]\n        type = VectorDirichletBC\n        values = '${velocity_x} 0 0'\n        variable = velocity\n        boundary = water_inlet #'inlet'\n    []\n    [outlet]\n        type = NeumannBC\n        value = 0\n        variable = p\n        boundary = 'outlet bottom_wall top_wall front_wall back_wall' #'outlet'\n    []\n    [no_slip_wall]\n        type = VectorDirichletBC\n        values = '0 0 0'\n        variable = velocity\n        boundary = 'left_wall1 left_wall2' #'wall'\n[]\n\n[Preconditioning]\n    [precond]\n        type = SMP\n        full = true\n    []\n[]\n\n[Executioner]\n    type = Transient\n    dt = 0.01\n    num_steps = 50\n    solve_type = NEWTON\n    nl_rel_tol = 1e-6\n    nl_max_its = 200\n    l_tol = 1e-6\n    l_max_its = 200\n    automatic_scaling = true\n    line_search = default\n\n    #Petsc options:\n    petsc_options_iname = '-pc_type -pc_factor_shift_type'      \n    petsc_options_value = 'lu       NONZERO'\n[]\n\n[Outputs]\nconsole = true\n[Outputfile]\ntype = VTK\nfile_base = abc\nexecute_on = 'timestep_end'\n[]\n[]\n\nNow, how do incorporate the multiphase flow phenomena with this simulation code?",
          "url": "https://github.com/idaholab/moose/discussions/24130",
          "updatedAt": "2023-04-29T02:35:20Z",
          "publishedAt": "2023-04-19T23:09:08Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "We do not currently have any multiphase flow capability in the navier_stokes module",
                  "url": "https://github.com/idaholab/moose/discussions/24130#discussioncomment-5667319",
                  "updatedAt": "2023-04-19T23:14:26Z",
                  "publishedAt": "2023-04-19T23:14:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "MashrurShejan"
                          },
                          "bodyText": "Thank you for your response. Is there any other approach to combine the fluid flow with multiphase phenomena?",
                          "url": "https://github.com/idaholab/moose/discussions/24130#discussioncomment-5667383",
                          "updatedAt": "2023-04-19T23:31:06Z",
                          "publishedAt": "2023-04-19T23:31:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You would need to create new code to work with INSAD and simulate multiphase flow.",
                          "url": "https://github.com/idaholab/moose/discussions/24130#discussioncomment-5667408",
                          "updatedAt": "2023-04-19T23:34:14Z",
                          "publishedAt": "2023-04-19T23:34:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MashrurShejan"
                          },
                          "bodyText": "can you please elaborate?",
                          "url": "https://github.com/idaholab/moose/discussions/24130#discussioncomment-5667424",
                          "updatedAt": "2023-04-19T23:36:58Z",
                          "publishedAt": "2023-04-19T23:36:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any set of equations can be implemented in MOOSE. If you have a good text book about multiphase flow, you can implement the equations there, just like we implemented the Navier Stokes equations for single phase flow.",
                          "url": "https://github.com/idaholab/moose/discussions/24130#discussioncomment-5667467",
                          "updatedAt": "2023-04-19T23:47:29Z",
                          "publishedAt": "2023-04-19T23:47:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Application not found",
          "author": {
            "login": "nourriahi"
          },
          "bodyText": "Hello,\nI have been trying to run moose on my computer lately, but, unfortunately, I keep having the same error messages while running tests after building, even though, I have tried to apply the suggestions proposed in the troubleshooting section.\nHerein is the test error message :\nmisc/check_error.node_value_off_block ..................................................... [METHOD!=DBG] SKIP\nmisc/check_error.bad_second_order_test .................................................... [METHOD!=DBG] SKIP\noutputs/format.tecplot_bin_test_override ............................................... [TECPLOT!=FALSE] SKIP\nmisc/check_error.coupled_nodal_for_non_nodal_variable: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.coupled_nodal_for_non_nodal_variable: Running command:\nmisc/check_error.coupled_nodal_for_non_nodal_variable:\nmisc/check_error.coupled_nodal_for_non_nodal_variable ......................... FAILED (Application not found)\nmisc/check_error.double_restrict_uo_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.double_restrict_uo_test: Running command:\nmisc/check_error.double_restrict_uo_test:\nmisc/check_error.double_restrict_uo_test ...................................... FAILED (Application not found)\nmisc/check_error.calling_wrong_feproblem_method: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.calling_wrong_feproblem_method: Running command:\nmisc/check_error.calling_wrong_feproblem_method:\nmisc/check_error.calling_wrong_feproblem_method ............................... FAILED (Application not found)\nmisc/check_error.rz_3d_error_check_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.rz_3d_error_check_test: Running command:\nmisc/check_error.rz_3d_error_check_test:\nmisc/check_error.rz_3d_error_check_test ....................................... FAILED (Application not found)\nmisc/check_error.incomplete_fvkernel_block_coverage_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.incomplete_fvkernel_block_coverage_test: Running command:\nmisc/check_error.incomplete_fvkernel_block_coverage_test: ################################################################################\nmisc/check_error.incomplete_fvkernel_block_coverage_test:\nmisc/check_error.incomplete_fvkernel_block_coverage_test: Unable to match the following pattern against the program's output:\nmisc/check_error.incomplete_fvkernel_block_coverage_test:\nmisc/check_error.incomplete_fvkernel_block_coverage_test: The following block\\(s\\) lack an active kernel:\nmisc/check_error.incomplete_fvkernel_block_coverage_test:\nmisc/check_error.incomplete_fvkernel_block_coverage_test: ################################################################################\nmisc/check_error.incomplete_fvkernel_block_coverage_test: Tester failed, reason: EXPECTED ERROR MISSING\nmisc/check_error.incomplete_fvkernel_block_coverage_test:\nmisc/check_error.incomplete_fvkernel_block_coverage_test ...................... FAILED (Application not found)\nmisc/check_error.coupled_nodal_for_non_nodal_variable_old: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.coupled_nodal_for_non_nodal_variable_old: Running command:\nmisc/check_error.coupled_nodal_for_non_nodal_variable_old:\nmisc/check_error.coupled_nodal_for_non_nodal_variable_old ..................... FAILED (Application not found)\nmisc/check_error.dynamic_check_name_block_mismatch_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.dynamic_check_name_block_mismatch_test: Running command:\nmisc/check_error.dynamic_check_name_block_mismatch_test:\nmisc/check_error.dynamic_check_name_block_mismatch_test ....................... FAILED (Application not found)\nsamplers/base.errors/setNumberOfCols ............................................... [METHOD!=DEVEL, DBG] SKIP\nsamplers/base.errors/setNumberOfRows ............................................... [METHOD!=DEVEL, DBG] SKIP\nauxkernels/solution_aux.aux_nonlinear_solution/from_xdr ........................ [--with-dof-id-bytes!=4] SKIP\nproblems/eigen_problem/eigensolvers.no_slepc ............................................. [SLEPC!=FALSE] SKIP\nmisc/check_error.wrong_displacement_order: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.wrong_displacement_order: Running command:\nmisc/check_error.wrong_displacement_order:\nmisc/check_error.wrong_displacement_order ..................................... FAILED (Application not found)\nmisc/check_error.same_name_variable_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.same_name_variable_test: Running command:\nmisc/check_error.same_name_variable_test:\nmisc/check_error.same_name_variable_test ...................................... FAILED (Application not found)\nmisc/check_error.incomplete_fvkernel_variable_coverage_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.incomplete_fvkernel_variable_coverage_test: Running command:\nmisc/check_error.incomplete_fvkernel_variable_coverage_test:\nmisc/check_error.incomplete_fvkernel_variable_coverage_test ................... FAILED (Application not found)\nmisc/check_error.coupled_nodal_for_non_nodal_variable_older: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.coupled_nodal_for_non_nodal_variable_older: Running command:\nmisc/check_error.coupled_nodal_for_non_nodal_variable_older:\nmisc/check_error.coupled_nodal_for_non_nodal_variable_older ................... FAILED (Application not found)\nmisc/check_error.dynamic_check_name_block_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.dynamic_check_name_block_test: Running command:\nmisc/check_error.dynamic_check_name_block_test:\nmisc/check_error.dynamic_check_name_block_test ................................ FAILED (Application not found)\nmisc/check_error.function_conflict: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.function_conflict: Running command:\nmisc/check_error.function_conflict:\nmisc/check_error.function_conflict ............................................ FAILED (Application not found)\nmisc/check_error.subdomain_restricted_auxkernel_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.subdomain_restricted_auxkernel_test: Running command:\nmisc/check_error.subdomain_restricted_auxkernel_test:\nmisc/check_error.subdomain_restricted_auxkernel_test .......................... FAILED (Application not found)\nmisc/check_error.coupled_constant_yet_needs_name: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.coupled_constant_yet_needs_name: Running command:\nmisc/check_error.coupled_constant_yet_needs_name:\nmisc/check_error.coupled_constant_yet_needs_name .............................. FAILED (Application not found)\nmisc/check_error.invalid_elemental_to_nodal_couple_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.invalid_elemental_to_nodal_couple_test: Running command:\nmisc/check_error.invalid_elemental_to_nodal_couple_test:\nmisc/check_error.invalid_elemental_to_nodal_couple_test ....................... FAILED (Application not found)\nmisc/check_error.dynamic_check_name_boundary_mismatch_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.dynamic_check_name_boundary_mismatch_test: Running command:\nmisc/check_error.dynamic_check_name_boundary_mismatch_test:\nmisc/check_error.dynamic_check_name_boundary_mismatch_test .................... FAILED (Application not found)\nmisc/check_error.bad_number: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.bad_number: Running command:\nmisc/check_error.bad_number:\nmisc/check_error.bad_number ................................................... FAILED (Application not found)\nmisc/check_error.subdomain_restricted_kernel_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.subdomain_restricted_kernel_test: Running command:\nmisc/check_error.subdomain_restricted_kernel_test:\nmisc/check_error.subdomain_restricted_kernel_test ............................. FAILED (Application not found)\nmisc/check_error.missing_active_section_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_errormisc/check_error.missing_active_section_test: Running command:\nmisc/check_error.missing_active_section_test:\nmisc/check_error.missing_active_section_test .................................. FAILED (Application not found)\nmisc/check_error.missing_executioner: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.missing_executioner: Running command:\nmisc/check_error.missing_executioner:\nmisc/check_error.missing_executioner .......................................... FAILED (Application not found)\nmisc/check_error.dynamic_check_name_boundary_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.dynamic_check_name_boundary_test: Running command:\nmisc/check_error.dynamic_check_name_boundary_test:\nmisc/check_error.dynamic_check_name_boundary_test ............................. FAILED (Application not found)\nsystem_interfaces.thread/pthread .................................................. [THREADING!=PTHREADS] SKIP\nsystem_interfaces.compiler/clang ...................................................... [COMPILER!=CLANG] SKIP\nsystem_interfaces.partitioner/chaco ....................................................... [CHACO!=TRUE] SKIP\nsystem_interfaces.libraries/boost ......................................................... [BOOST!=TRUE] SKIP\nsystem_interfaces.partitioner/party ....................................................... [PARTY!=TRUE] SKIP\nmisc/check_error.coupling_field_into_scalar: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.coupling_field_into_scalar: Running command:\nmisc/check_error.coupling_field_into_scalar:\nmisc/check_error.coupling_field_into_scalar ................................... FAILED (Application not found)\nmisc/check_error.unused_param_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.unused_param_test: Running command:\nmisc/check_error.unused_param_test:\nmisc/check_error.unused_param_test ............................................ FAILED (Application not found)\nmisc/check_error.missing_coupled_mat_prop_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.missing_coupled_mat_prop_test: Running command:\nmisc/check_error.missing_coupled_mat_prop_test:\nmisc/check_error.missing_coupled_mat_prop_test ................................ FAILED (Application not found)\nmisc/check_error.nodal_bc_on_elemental_var: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.nodal_bc_on_elemental_var: Running command:\nmisc/check_error.nodal_bc_on_elemental_var:\nmisc/check_error.nodal_bc_on_elemental_var .................................... FAILED (Application not found)\nmisc/check_error.linear_interp_material_check: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.linear_interp_material_check: Running command:\nmisc/check_error.linear_interp_material_check:\nmisc/check_error.linear_interp_material_check ................................. FAILED (Application not found)\nmisc/check_error.coupling_scalar_into_field: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.coupling_scalar_into_field: Running command:\nmisc/check_error.coupling_scalar_into_field:\nmisc/check_error.coupling_scalar_into_field ................................... FAILED (Application not found)\nmisc/check_error.unused_param_test_cli: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.unused_param_test_cli: Running command:\nmisc/check_error.unused_param_test_cli:\nmisc/check_error.unused_param_test_cli ........................................ FAILED (Application not found)\nmortar/continuity-3d-non-conforming.continuity_sphere_hex27-debug-mesh [Minimum AD size 200 needed, b...] SKIP\nmortar/continuity-3d-non-conforming.continuity_sphere_hex20 [Minimum AD size 200 needed, but MOOSE is...] SKIP\nmortar/continuity-3d-non-conforming.continuity_tet10 [Minimum AD size 100 needed, but MOOSE is config...] SKIP\nmortar/continuity-3d-non-conforming.continuity_sphere_hex27 [Minimum AD size 200 needed, but MOOSE is...] SKIP\nmisc/check_error.coupled_grad_without_declare: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.coupled_grad_without_declare: Running command:\nmisc/check_error.coupled_grad_without_declare:\nmisc/check_error.coupled_grad_without_declare ................................. FAILED (Application not found)\nmisc/check_error.check_git_lfs_pointer: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.check_git_lfs_pointer: Running command:\nmisc/check_error.check_git_lfs_pointer:\nmisc/check_error.check_git_lfs_pointer ........................................ FAILED (Application not found)\nmisc/check_error.function_file_test1: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.function_file_test1: Running command:\nmisc/check_error.function_file_test1:\nmisc/check_error.function_file_test1 .......................................... FAILED (Application not found)\nmisc/check_error.coupling_nonexistent_field: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.coupling_nonexistent_field: Running command:\nmisc/check_error.coupling_nonexistent_field:\nmisc/check_error.coupling_nonexistent_field ................................... FAILED (Application not found)\nmisc/check_error.unused_param_test_warn: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.unused_param_test_warn: Running command:\nmisc/check_error.unused_param_test_warn:\nmisc/check_error.unused_param_test_warn ....................................... FAILED (Application not found)\nutils/libtorch_nn/ann.libtorch-nn-optimizer/rmsprop .................................... [LIBTORCH!=TRUE] SKIP\nutils/libtorch_nn/ann.libtorch-nn-activation/linear .................................... [LIBTORCH!=TRUE] SKIP\nutils/libtorch_nn/ann.libtorch-nn-activation/sigmoid ................................... [LIBTORCH!=TRUE] SKIP\nutils/libtorch_nn/ann.libtorch-nn-errors/wrong-activation-number ....................... [LIBTORCH!=TRUE] SKIP\nutils/libtorch_nn/ann.libtorch-nn-optimizer/adam ....................................... [LIBTORCH!=TRUE] SKIP\nutils/libtorch_nn/ann.libtorch-nn-errors/wrong-activation .............................. [LIBTORCH!=TRUE] SKIP\nutils/libtorch_nn/ann.libtorch-nn-activation/relu ...................................... [LIBTORCH!=TRUE] SKIP\nutils/libtorch_nn/ann.libtorch-nn-activation/elu ....................................... [LIBTORCH!=TRUE] SKIP\nutils/libtorch_nn/ann.libtorch-nn-optimizer/sgd ........................................ [LIBTORCH!=TRUE] SKIP\nutils/libtorch_nn/ann.libtorch-nn-optimizer/adagrad .................................... [LIBTORCH!=TRUE] SKIP\nutils/libtorch_nn/ann.libtorch-nn-activation/gelu ...................................... [LIBTORCH!=TRUE] SKIP\nutils/libtorch_nn/ann.libtorch-nn-errors/wrong-optimizer ............................... [LIBTORCH!=TRUE] SKIP\nmisc/check_error.missing_function_file_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.missing_function_file_test: Running command:\nmisc/check_error.missing_function_file_test:\nmisc/check_error.missing_function_file_test ................................... FAILED (Application not found)\nmisc/check_error.function_file_test2: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.function_file_test2: Running command:\nmisc/check_error.function_file_test2:\nmisc/check_error.function_file_test2 .......................................... FAILED (Application not found)\nmisc/check_error.coupling_nonexistent_scalar: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_errormisc/check_error.coupling_nonexistent_scalar: Running command:\nmisc/check_error.coupling_nonexistent_scalar:\nmisc/check_error.coupling_nonexistent_scalar .................................. FAILED (Application not found)\nmisc/check_error.steady_no_converge: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.steady_no_converge: Running command:\nmisc/check_error.steady_no_converge:\nmisc/check_error.steady_no_converge ........................................... FAILED (Application not found)\nmisc/check_error.unused_param_test_warn_cli: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.unused_param_test_warn_cli: Running command:\nmisc/check_error.unused_param_test_warn_cli:\nmisc/check_error.unused_param_test_warn_cli ................................... FAILED (Application not found)\nmisc/check_error.missing_function_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.missing_function_test: Running command:\nmisc/check_error.missing_function_test:\nmisc/check_error.missing_function_test ........................................ FAILED (Application not found)\nmisc/check_error.function_file_test3: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.function_file_test3: Running command:\nmisc/check_error.function_file_test3:\nmisc/check_error.function_file_test3 .......................................... FAILED (Application not found)\nmisc/check_error.coupling_itself: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.coupling_itself: Running command:\nmisc/check_error.coupling_itself:\nmisc/check_error.coupling_itself .............................................. FAILED (Application not found)\nfvkernels/mms/advective-outflow.QUICKLimiter .................................................... [HEAVY] SKIP\npartitioners/petsc_partitioner.chaco ............ [PLATFORM!=DARWIN, CHACO!=TRUE, --with-dof-id-bytes!=4] SKIP\npartitioners/petsc_partitioner.party ...................................................... [PARTY!=TRUE] SKIP\nmisc/check_error.range_check_param: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.range_check_param: Running command:\nmisc/check_error.range_check_param:\nmisc/check_error.range_check_param ............................................ FAILED (Application not found)\nmesh/splitting.meshgenerators_acting_on_split .................................. [MESH_MODE!=DISTRIBUTED] SKIP\nmesh/splitting.split_with_distributed_error .................................... [MESH_MODE!=DISTRIBUTED] SKIP\nmisc/check_error.missing_material_prop_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.missing_material_prop_test: Running command:\nmisc/check_error.missing_material_prop_test:\nmisc/check_error.missing_material_prop_test ................................... FAILED (Application not found)\nmisc/check_error.uo_pps_name_collision_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.uo_pps_name_collision_test: Running command:\nmisc/check_error.uo_pps_name_collision_test:\nmisc/check_error.uo_pps_name_collision_test ................................... FAILED (Application not found)\nmisc/check_error.function_file_test4: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.function_file_test4: Running command:\nmisc/check_error.function_file_test4:\nmisc/check_error.function_file_test4 .......................................... FAILED (Application not found)\nmisc/check_error.coupling_itself_ad: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.coupling_itself_ad: Running command:\nmisc/check_error.coupling_itself_ad:\nmisc/check_error.coupling_itself_ad ........................................... FAILED (Application not found)\nmisc/check_error.checked_pointer_param_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.checked_pointer_param_test: Running command:\nmisc/check_error.checked_pointer_param_test:\nmisc/check_error.checked_pointer_param_test ................................... FAILED (Application not found)\nmisc/check_error.uo_vector_pps_name_collision_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.uo_vector_pps_name_collision_test: Running command:\nmisc/check_error.uo_vector_pps_name_collision_test:\nmisc/check_error.uo_vector_pps_name_collision_test ............................ FAILED (Application not found)\ndgkernels/2d_diffusion_dg.proper_ghosting_with_action_parallel_distributed ..... [MESH_MODE!=DISTRIBUTED] SKIP\ndgkernels/2d_diffusion_dg.proper_ghosting_with_action_serial_distributed ....... [MESH_MODE!=DISTRIBUTED] SKIP\ndgkernels/2d_diffusion_dg.no_additional_rms_distributed ........................ [MESH_MODE!=DISTRIBUTED] SKIP\nmortar/periodic_segmental_constraint.penalty_periodic_simple3d [Minimum AD size 100 needed, but MOOSE...] SKIP\nmortar/periodic_segmental_constraint.periodic_aux2d [Minimum AD size 100 needed, but MOOSE is configu...] SKIP\nmortar/periodic_segmental_constraint.periodic_simple2d [Minimum AD size 100 needed, but MOOSE is conf...] SKIP\nmortar/periodic_segmental_constraint.periodic_simple3d [Minimum AD size 100 needed, but MOOSE is conf...] SKIP\nmisc/check_error.missing_material_prop_test2: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_errormisc/check_error.missing_material_prop_test2: Running command:\nmisc/check_error.missing_material_prop_test2:\nmisc/check_error.missing_material_prop_test2 .................................. FAILED (Application not found)\nmisc/check_error.function_file_test5: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.function_file_test5: Running command:\nmisc/check_error.function_file_test5:\nmisc/check_error.function_file_test5 .......................................... FAILED (Application not found)\nTraceback (most recent call last):\n  File \"/home/n_riahi/projets/moose/test/./run_tests\", line 8, in <module>\nmisc/check_error.missing_input: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.missing_input: Running command:\nmisc/check_error.missing_input:     TestHarness.buildAndRun(sys.argv, None, MOOSE_DIR)\n  File \"/home/n_riahi/projets/moose/python/TestHarness/TestHarness.py\", line 181, in buildAndRun\n\nmisc/check_error.missing_input ................................................ FAILED (Application not found)\n    harness.findAndRunTests()\n  File \"/home/n_riahi/projets/moose/python/TestHarness/TestHarness.py\", line 432, in findAndRunTests\nmisc/check_error.add_aux_variable_multiple_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.add_aux_variable_multiple_test: Running command:\nmisc/check_error.add_aux_variable_multiple_test:\nmisc/check_error.add_aux_variable_multiple_test ............................... FAILED (Application not found)\nmisc/check_error.wrong_object_test: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.wrong_object_test: Running command:\nmisc/check_error.wrong_object_test:     self.scheduler.waitFinish()\n\n  File \"/home/n_riahi/projets/moose/python/TestHarness/schedulers/Scheduler.py\", line 180, in waitFinish\nmisc/check_error.wrong_object_test ............................................ FAILED (Application not found)\n    self.__sortAndLaunch()\nrunWorker Exception: Traceback (most recent call last):\n  File \"/home/n_riahi/projets/moose/python/TestHarness/schedulers/Scheduler.py\", line 456, in runJob\n    self.queueJobs(jobs, j_lock)\n  File \"/home/n_riahi/projets/moose/python/TestHarness/schedulers/Scheduler.py\", line 257, in queueJobs\n    self.status_pool.apply_async(self.jobStatus, (job, jobs, j_lock))\n  File \"/home/n_riahi/mambaforge3/envs/moose/lib/python3.10/multiprocessing/pool.py\", line 458, in apply_async\n    self._check_running()\n  File \"/home/n_riahi/mambaforge3/envs/moose/lib/python3.10/multiprocessing/pool.py\", line 353, in _check_running\n    raise ValueError(\"Pool not running\")\nValueError: Pool not running\n  File \"/home/n_riahi/projets/moose/python/TestHarness/schedulers/Scheduler.py\", line 174, in __sortAndLaunch\n    self.queueJobs(jobs, j_lock)\n\n  File \"/home/n_riahi/projets/moose/python/TestHarness/schedulers/Scheduler.py\", line 262, in queueJobs\nmisc/check_error.bad_stateful_material_only_old: Working Directory: /home/n_riahi/projets/moose/test/tests/misc/check_error\nmisc/check_error.bad_stateful_material_only_old: Running command:\nmisc/check_error.bad_stateful_material_only_old:\n    self.run_pool.apply_async(self.runJob, (job, jobs, j_lock))\nmisc/check_error.bad_stateful_material_only_old ............................... FAILED (Application not found)\n  File \"/home/n_riahi/mambaforge3/envs/moose/lib/python3.10/multiprocessing/pool.py\", line 458, in apply_async\n    self._check_running()\n  File \"/home/n_riahi/mambaforge3/envs/moose/lib/python3.10/multiprocessing/pool.py\", line 353, in _check_running\n    raise ValueError(\"Pool not running\")\nValueError: Pool not running",
          "url": "https://github.com/idaholab/moose/discussions/24090",
          "updatedAt": "2023-04-29T02:35:36Z",
          "publishedAt": "2023-04-17T15:12:10Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe code did not build, that s why the test suite is not finding the executable.\nCould you please report on the output of make in moose/tests ?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5638799",
                  "updatedAt": "2023-04-17T15:42:04Z",
                  "publishedAt": "2023-04-17T15:42:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "nourriahi"
                          },
                          "bodyText": "Please find the output:\n(moose) n_riahi@DESKTOP-BBAOPAN:~/projets/moose/test$ make -j 6\nCompiling C++ (in opt mode) /home/n_riahi/projets/moose/framework/build/unity_src/markers_Unity.C...\nCompiling C++ (in opt mode) /home/n_riahi/projets/moose/framework/build/unity_src/bcs_Unity.C...\nCompiling C++ (in opt mode) /home/n_riahi/projets/moose/framework/build/unity_src/executioners_Unity.C...\nCompiling C++ (in opt mode) /home/n_riahi/projets/moose/framework/build/unity_src/multiapps_Unity.C...\nCompiling C++ (in opt mode) /home/n_riahi/projets/moose/framework/build/unity_src/fviks_Unity.C...\nCompiling C++ (in opt mode) /home/n_riahi/projets/moose/framework/build/unity_src/timesteppers_Unity.C...\nx86_64-conda-linux-gnu-c++: fatal error: Killed signal terminated program cc1plus\ncompilation terminated.\nmake: *** [/home/n_riahi/projets/moose/framework/build.mk:144: /home/n_riahi/projets/moose/framework/build/unity_src/executioners_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1\nmake: *** Waiting for unfinished jobs....\nx86_64-conda-linux-gnu-c++: fatal error: Killed signal terminated program cc1plus\ncompilation terminated.\nmake: *** [/home/n_riahi/projets/moose/framework/build.mk:144: /home/n_riahi/projets/moose/framework/build/unity_src/markers_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1\nx86_64-conda-linux-gnu-c++: fatal error: Killed signal terminated program cc1plus\ncompilation terminated.\nmake: *** [/home/n_riahi/projets/moose/framework/build.mk:144: /home/n_riahi/projets/moose/framework/build/unity_src/bcs_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5638907",
                          "updatedAt": "2023-04-17T15:51:34Z",
                          "publishedAt": "2023-04-17T15:51:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It looks like you are running out of memory.\nCan you make -j 1 instead?",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5638939",
                          "updatedAt": "2023-04-17T15:54:06Z",
                          "publishedAt": "2023-04-17T15:53:53Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nourriahi"
                          },
                          "bodyText": "I think I have successfully built and ran moose:\nRan 3601 tests in 4995.1 seconds. Average test time 1.3 seconds, maximum test time 136.7 seconds.\n3601 passed, 259 skipped, 0 pending, 0 failed\n\nI do have 4gb free storage, does moose need more storage space that I need to free it up or is this enough for only heat conduction problems? and do I need to test with -j 6 -j 8 to make everything work correctly for the simulation or -j 1 was only for checking what was the problem coming from?",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5640479",
                          "updatedAt": "2023-04-17T18:49:50Z",
                          "publishedAt": "2023-04-17T18:14:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm not worried about the storage, more about the memory (RAM).\nDo you have 4gb RAM?",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5640725",
                          "updatedAt": "2023-04-17T18:43:01Z",
                          "publishedAt": "2023-04-17T18:43:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "nourriahi"
                  },
                  "bodyText": "No, it\u2019s 8gb RAM\n\u2026\nOn Mon, 17 Apr 2023 at 19:43, Guillaume Giudicelli ***@***.***> wrote:\n I'm not worried about the storage, more about the memory (RAM).\n\n Do you have 4gb RAM?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24090 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/A7HP7HIPY6A4Z3ZM6IE3IPTXBWFL7ANCNFSM6AAAAAAXBKRJCI>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5640752",
                  "updatedAt": "2023-04-17T18:46:25Z",
                  "publishedAt": "2023-04-17T18:46:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can try other -j numbers. Ultimately I think that is the problem though, you were running out of memory building the code.",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5640785",
                          "updatedAt": "2023-04-17T18:50:42Z",
                          "publishedAt": "2023-04-17T18:50:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nourriahi"
                          },
                          "bodyText": "Thanks for your advice, it's working correctly now.\nI was running LaplaceYoungDiffusion example that I built in the same way as on your YouTube tutorial on the summer of 2020, but unfortunately I encountered this problem while running the last step :\n(moose) n_riahi@DESKTOP-BBAOPAN:~/projet/your_app_name/problems$ ../your_app_name-opt -i laplace_young.i\n\n\n*** ERROR ***\nA 'LaplaceYoungDiffusion' is not a registered object.\n\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\n\nStack frames: 21\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)\n2: void mooseError<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&)\n3: Factory::reportUnregisteredError(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const\n4: Factory::getValidParams(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)\n5: MooseObjectAction::MooseObjectAction(InputParameters const&)\n6: AddKernelAction::AddKernelAction(InputParameters const&)\n7: /home/n_riahi/projet/moose/framework/libmoose-opt.so.0(+0x124de48) [0x7f847738ae48]\n8: ActionFactory::create(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, InputParameters&)\n9: Parser::walkRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, hit::Node*)\n10: Parser::walk(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, hit::Node*)\n11: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n12: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n13: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n14: Parser::parse(std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&)\n15: MooseApp::setupOptions()\n16: MooseApp::run()\n17: main\n18: /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7f846f116d90]\n19: __libc_start_main\n20: ../your_app_name-opt(+0x23ef) [0x5603e19713ef]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5651106",
                          "updatedAt": "2023-04-18T20:31:15Z",
                          "publishedAt": "2023-04-18T16:11:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "did you create the object? Did you build the code after?\ncan you link to the step in the tutorial?",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5653544",
                          "updatedAt": "2023-04-18T20:31:36Z",
                          "publishedAt": "2023-04-18T20:31:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "nourriahi"
                  },
                  "bodyText": "Yes, I followed everything step by step\n\u2026\nOn Tue, 18 Apr 2023 at 21:31, Guillaume Giudicelli ***@***.***> wrote:\n did you create the object? Did you build the code after?\n can you link to the step in the tutorial?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24090 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/A7HP7HJDKOYSTI446E5H6B3XB323FANCNFSM6AAAAAAXBKRJCI>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5654293",
                  "updatedAt": "2023-04-18T22:30:17Z",
                  "publishedAt": "2023-04-18T22:30:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what does ls in the directory return?",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5654331",
                          "updatedAt": "2023-04-18T22:39:22Z",
                          "publishedAt": "2023-04-18T22:39:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "nourriahi"
                  },
                  "bodyText": "(moose) ***@***.***:~/projet/your_app_name$ cd include\n(moose) ***@***.***:~/projet/your_app_name/include$ cd kernels\n(moose) ***@***.***:~/projet/your_app_name/include/kernels$ ls\nLaplaceYoungDiffusion.h  LaplaceYoungSource.h\n(moose) ***@***.***:~/projet/your_app_name/include/kernels$ cd\n../../src/kernels\n(moose) ***@***.***:~/projet/your_app_name/src/kernels$ ls\nLaplaceYoungDiffusion.C  LaplaceYoungSource.C\n(moose) ***@***.***:~/projet/your_app_name/problems$  ls\nlaplace_young.i\n\u2026\nOn Tue, 18 Apr 2023 at 23:39, Guillaume Giudicelli ***@***.***> wrote:\n what does ls in the directory return?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24090 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/A7HP7HKRNH6UMQGZDAJPQCDXB4J2JANCNFSM6AAAAAAXBKRJCI>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5654645",
                  "updatedAt": "2023-04-18T23:53:29Z",
                  "publishedAt": "2023-04-18T23:53:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok then most likely the registration of the object failed.\nThere should be a called to registerMooseObject(\"your_app_name\", LaplaceYoungDiffusion) in the LaplaceYoungDiffusion.C` file\nthe \"your_app_name\" part is wrong",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5655744",
                          "updatedAt": "2023-04-19T03:13:59Z",
                          "publishedAt": "2023-04-19T03:13:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nourriahi"
                          },
                          "bodyText": "I am afraid that I didn't get the exact meaning when you said \"the \"your_app_name\" part is wrong\", the source file is exactly the same as the one used in the tutorial:\n#include \"LaplaceYoungDiffusion.h\"\n\nregisterMooseObject(\"your_app_name\", LaplaceYoungDiffusion);\n\nInputParameters\nLaplaceYoungDiffusion::validParams()\n{\n  auto params = ADKernelGrad::validParams();\n  params.addClassDescription(\"Diffusion term for Laplace Young equation.\");\n  return params;\n}\n\nLaplaceYoungDiffusion::LaplaceYoungDiffusion(const InputParameters & parameters) : ADKernelGrad(parameters) {}\n\nADRealVectorValue\nLaplaceYoungDiffusion::precomputeQpResidual()\n{\n  ADReal k= 1./std::sqrt(1 + _grad_u[_qp] * _grad_u[_qp]);\n  return k * _grad_u[_qp];\n}",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5655854",
                          "updatedAt": "2023-04-19T03:45:54Z",
                          "publishedAt": "2023-04-19T03:36:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Well this\nregisterMooseObject(\"your_app_name\", LaplaceYoungDiffusion);\nhas got to be wrong for your case.\nCan you please paste the App file in src/base/....App.C ?",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5655863",
                          "updatedAt": "2023-04-19T03:39:01Z",
                          "publishedAt": "2023-04-19T03:39:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nourriahi"
                          },
                          "bodyText": "I think it's already there :\n\nand the you_app_name file when opened displays the following script:\n#include \"your_app_nameApp.h\"\n#include \"Moose.h\"\n#include \"AppFactory.h\"\n#include \"ModulesApp.h\"\n#include \"MooseSyntax.h\"\nInputParameters\nyour_app_nameApp::validParams()\n{\nInputParameters params = MooseApp::validParams();\nreturn params;\n}\nyour_app_nameApp::your_app_nameApp(InputParameters parameters) : MooseApp(parameters)\n{\nyour_app_nameApp::registerAll(_factory, _action_factory, _syntax);\n}\nyour_app_nameApp::~your_app_nameApp() {}\nvoid\nyour_app_nameApp::registerAll(Factory & f, ActionFactory & af, Syntax & syntax)\n{\nModulesApp::registerAll(f, af, syntax);\nRegistry::registerObjectsTo(f, {\"your_app_nameApp\"});\nRegistry::registerActionsTo(af, {\"your_app_nameApp\"});\n/* register custom execute flags, action syntax, etc. here */\n}\nvoid\nyour_app_nameApp::registerApps()\n{\nregisterApp(your_app_nameApp);\n}\n/***************************************************************************************************\n*********************** Dynamic Library Entry Points - DO NOT MODIFY ******************************\n**************************************************************************************************/\nextern \"C\" void\nyour_app_nameApp__registerAll(Factory & f, ActionFactory & af, Syntax & s)\n{\nyour_app_nameApp::registerAll(f, af, s);\n}\nextern \"C\" void\nyour_app_nameApp__registerApps()\n{\nyour_app_nameApp::registerApps();\n}",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5655962",
                          "updatedAt": "2023-04-19T04:00:21Z",
                          "publishedAt": "2023-04-19T04:00:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so the name of your app is not your_app_name\nit s your_app_nameApp\nso in the object it should be:\nregisterMooseObject(\"your_app_nameApp\", LaplaceYoungDiffusion);",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5655996",
                          "updatedAt": "2023-04-19T04:09:02Z",
                          "publishedAt": "2023-04-19T04:09:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nourriahi"
                          },
                          "bodyText": "I have tried with the same file with the correction suggested but I got the same error message.\nI have created a new file \"nour\" and I followed each step one by one again, at the end I ended up with the same message.\n(moose) n_riahi@DESKTOP-BBAOPAN:~/projet/nour/problems$ ../nour-opt -i laplace_young\n.i\n*** ERROR ***\nA 'LaplaceYoungDiffusion' is not a registered object.\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\nStack frames: 21\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >)\n2: void mooseError<std::__cxx11::basic_string<char, std::char_traits, std::allocator > >(std::__cxx11::basic_string<char, std::char_traits, std::allocator >&&)\n3: Factory::reportUnregisteredError(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&) const\n4: Factory::getValidParams(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&)\n5: MooseObjectAction::MooseObjectAction(InputParameters const&)\n6: AddKernelAction::AddKernelAction(InputParameters const&)\n7: /home/n_riahi/projet/moose/framework/libmoose-opt.so.0(+0x124de48) [0x7f4529c8ae48]\n8: ActionFactory::create(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, InputParameters&)\n9: Parser::walkRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >, hit::Node*)\n10: Parser::walk(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, hit::Node*)\n11: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n12: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n13: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n14: Parser::parse(std::vector<std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::allocator<std::__cxx11::basic_string<char, std::char_traits, std::allocator > > > const&)\n15: MooseApp::setupOptions()\n16: MooseApp::run()\n17: main\n18: /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7f4521a16d90]\n19: __libc_start_main\n20: ../nour-opt(+0x23ef) [0x555e829b83ef]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5663955",
                          "updatedAt": "2023-04-19T16:13:37Z",
                          "publishedAt": "2023-04-19T16:13:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the app name is probably still wrong.\nplease paste the ...App.C file and the object registration line (registerMooseObject)",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5663992",
                          "updatedAt": "2023-04-19T16:16:25Z",
                          "publishedAt": "2023-04-19T16:16:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nourriahi"
                          },
                          "bodyText": "registerMooseObject(\"nourApp\", LaplaceYoungDiffusion);\n#include \"NourApp.h\"\n#include \"Moose.h\"\n#include \"AppFactory.h\"\n#include \"ModulesApp.h\"\n#include \"MooseSyntax.h\"\nInputParameters\nNourApp::validParams()\n{\nInputParameters params = MooseApp::validParams();\nreturn params;\n}\nNourApp::NourApp(InputParameters parameters) : MooseApp(parameters)\n{\nNourApp::registerAll(_factory, _action_factory, _syntax);\n}\nNourApp::~NourApp() {}\nvoid\nNourApp::registerAll(Factory & f, ActionFactory & af, Syntax & syntax)\n{\nModulesApp::registerAll(f, af, syntax);\nRegistry::registerObjectsTo(f, {\"NourApp\"});\nRegistry::registerActionsTo(af, {\"NourApp\"});\n/* register custom execute flags, action syntax, etc. here */\n}\nvoid\nNourApp::registerApps()\n{\nregisterApp(NourApp);\n}\n/***************************************************************************************************\n*********************** Dynamic Library Entry Points - DO NOT MODIFY ******************************\n**************************************************************************************************/\nextern \"C\" void\nNourApp__registerAll(Factory & f, ActionFactory & af, Syntax & s)\n{\nNourApp::registerAll(f, af, s);\n}\nextern \"C\" void\nNourApp__registerApps()\n{\nNourApp::registerApps();\n}",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5664051",
                          "updatedAt": "2023-04-19T16:22:33Z",
                          "publishedAt": "2023-04-19T16:22:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so the app is called NourApp\nand you register to nourApp",
                          "url": "https://github.com/idaholab/moose/discussions/24090#discussioncomment-5664078",
                          "updatedAt": "2023-04-19T16:24:55Z",
                          "publishedAt": "2023-04-19T16:24:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow: output the mass_frac of one component in PorousFlowMassFraction material as real value",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "",
          "url": "https://github.com/idaholab/moose/discussions/23526",
          "updatedAt": "2023-04-19T13:40:30Z",
          "publishedAt": "2023-02-24T14:47:48Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "So the mass fractions should be nonlinear variables in your example so should be in the exodus file (unless you mean something else?)",
                  "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5105228",
                  "updatedAt": "2023-02-24T22:51:36Z",
                  "publishedAt": "2023-02-24T22:51:35Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "In any case, you don't need to modify the code to output any of these things. PorousFlowPropertyAux gives access to virtually every property so you can easily save these to AuxVariables and then do whatever you like with them.",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5105247",
                          "updatedAt": "2023-02-24T22:53:32Z",
                          "publishedAt": "2023-02-24T22:53:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "OK, that's not what I thought you meant!\nIn your case, you don't need to change PorousFlowMassFraction at all. It provides a material property that is a vector of mass fractions of all components in all phases. You can simply get that material property in your kernel and then pick out that phase and component that you want. The PorousFlowMassTimeDerivative kernel does exactly what you are trying to do so take a look at that code for inspiration.",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5106116",
                          "updatedAt": "2023-02-25T02:28:51Z",
                          "publishedAt": "2023-02-25T02:28:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Something that I forgot is that the properties are evaluated at the nodes in that PorousFlowMassTimeDerivative but you most likely want them at the quadrature points in your kernel. So replace _nodal with _qp in the property name and _i with `_qp' when using the property!",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5106175",
                          "updatedAt": "2023-02-25T02:52:06Z",
                          "publishedAt": "2023-02-25T02:52:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "Something that I forgot is that the properties are evaluated at the nodes in that PorousFlowMassTimeDerivative but you most likely want them at the quadrature points in your kernel. So replace _nodal with _qp in the property name and _i with `_qp' when using the property!\n\nOk, I will try that. Thanks again.\nHave a nice weekend,\nJ",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5108817",
                          "updatedAt": "2023-02-25T15:19:39Z",
                          "publishedAt": "2023-02-25T15:19:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "ok",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5127173",
                          "updatedAt": "2023-03-03T19:34:51Z",
                          "publishedAt": "2023-02-27T19:08:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "To allow an arbitrary number of components in an arbitrary number of phases, we construct a 2D vector of mass fractions in PorousFlowMassFraction - basically [[ comp 0 in phase 0], [comp 1 in phase 0]], [[0 in 1], [1 in 1]] for a two-component, two-phase system. These mass fractions could be non-linear variables if they change during the simulation, or could be constant aux variables. This material property is then available in any other kernel, material, AuxKernel etc through the normal material property interface.\nSo, PorousFlowMassFraction takes the mass fractions provided in the mass_fraction_vars parameter, makes a material property PorousFlow_mass_frac_qp, which a kernel can access using\n_mass_fractions(\n        getMaterialProperty<std::vector<std::vector<Real>>>(\"PorousFlow_mass_frac_qp\"))\n\nand the kernel can use the values (that were provided to PorousFlowMAssFraction in the mass_fraction_vars parameter) by indexing into the 2D vector like so for phase and components\n_mass_fractions[_qp][phase][comp]\n\nWe do it this way so that we only have to list the mass fractions in one material in the input file, rather than having to fill them out in multiple places (materials, kernels, auxkernels, post processors).\nAs for your second question about no _u in the kernels, we made a choice to make the kernels so that we could reuse them no matter what the type of the nonlinear variable was. There are several possible choices for the independent variables for multiphase, multicomponent flow. Consider the 2 component, 2 phase case. You can have 2 pressure variables, a pressure and saturation, a pressure and capillary pressure, etc. By not using the variable values directly in the kernels,  the same kernels can be used for any variable choice. We use the materials to pass the variable information through to the kernels.\nHopefully that makes sense?",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5127823",
                          "updatedAt": "2023-02-27T20:28:03Z",
                          "publishedAt": "2023-02-27T20:28:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Wow, Thanks a lot!!!\nRegards,\nJerry",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5131594",
                          "updatedAt": "2023-03-03T19:35:19Z",
                          "publishedAt": "2023-02-27T22:54:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Pretty much. If we didn't do that we would need a version of each kernel for a pressure variable, a version for a saturation variable, a version for a mass fraction variable etc.",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5131646",
                          "updatedAt": "2023-02-27T22:58:52Z",
                          "publishedAt": "2023-02-27T22:58:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Thanks very much Chris!",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5132063",
                          "updatedAt": "2023-02-27T23:06:55Z",
                          "publishedAt": "2023-02-27T23:06:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "To get that I think you would need to alter the code to write it out to the console. I don't think there is an easier way sorry.",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5137558",
                          "updatedAt": "2023-02-28T04:09:50Z",
                          "publishedAt": "2023-02-28T04:09:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "Maybe we should step back and look at what you are trying to achieve? If you could describe it a bit perhaps we can come up with a better solution?",
                  "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5183916",
                  "updatedAt": "2023-03-02T22:31:07Z",
                  "publishedAt": "2023-03-02T22:31:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "Also - I'm getting super confused by the two discussions here - can we spin them out to two threads?",
                  "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5184049",
                  "updatedAt": "2023-03-02T22:49:55Z",
                  "publishedAt": "2023-03-02T22:49:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Ok, thanks Chris.",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5184068",
                          "updatedAt": "2023-03-03T19:33:15Z",
                          "publishedAt": "2023-03-02T22:53:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "You are probably violating mass conservation with that change. Like Joseph, perhaps some details of what you are trying to achieve so we can come up with a better solution.",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5184146",
                          "updatedAt": "2023-03-02T23:08:42Z",
                          "publishedAt": "2023-03-02T23:08:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "You are probably violating mass conservation with that change. Like Joseph, perhaps some details of what you are trying to achieve so we can come up with a better solution.\n\nOK\uff0c thanks for your quick reply Chris.\nit is fixed now",
                          "url": "https://github.com/idaholab/moose/discussions/23526#discussioncomment-5184265",
                          "updatedAt": "2023-03-03T19:33:03Z",
                          "publishedAt": "2023-03-02T23:35:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Errors After Updating MOOSE",
          "author": {
            "login": "hhy2022"
          },
          "bodyText": "Hi, I updated MOOSE package and then try to rebuilt it. Here is the command I used:\nUpdate MOOSE:\ncd ~/projects/moose\ngit fetch origin\ngit rebase origin/master\n\n\nRebuilt MOOSE:\n\ncd ~/projects/moose/test\nmake clobberall\nmake -j4\n./run_tests -j4\n\nThe update process finished successfully, however, when I was trying to recompile it, the error occurred.\n/home/dff/projects/moose/framework/build/header_symlinks/MooseVariableField.h: In instantiation of 'class MooseVariableField<Eigen::Matrix<double, -1, 1> >':\n/home/dff/projects/moose/framework/build/header_symlinks/MooseVariableFE.h:46:7:   required from 'class MooseVariableFE<Eigen::Matrix<double, -1, 1> >'\n/home/dff/projects/moose/framework/build/header_symlinks/Coupleable.h:1718:23:   required from here\n/home/dff/projects/moose/framework/build/header_symlinks/MooseVariableField.h:365:41: error: no members matching 'Moose::FunctorBase<Eigen::Matrix<double, -1, 1> >::evaluateGradient' in 'class Moose::FunctorBase<Eigen::Matrix<double, -1, 1> >'\n  365 |   using Moose::FunctorBase<FunctorArg>::evaluateGradient;\n      |                                         ^~~~~~~~~~~~~~~~\n/home/dff/projects/moose/framework/build/header_symlinks/MooseVariableField.h:369:50: error: no members matching 'Moose::FunctorBase<Eigen::Matrix<double, -1, 1> >::GradientType' in 'class Moose::FunctorBase<Eigen::Matrix<double, -1, 1> >'\n  369 |   using typename Moose::FunctorBase<FunctorArg>::GradientType;\n      |                                                  ^~~~~~~~~~~~\n/home/dff/projects/moose/framework/build/header_symlinks/MooseVariableField.h:381:16: error: no type named 'GradientType' in 'class Moose::FunctorBase<Eigen::Matrix<double, -1, 1> >'\n  381 |   GradientType evaluateGradient(const ElemQpArg & elem_qp, const StateArg & state) const override;\n      |                ^~~~~~~~~~~~~~~~\n/home/dff/projects/moose/framework/build/header_symlinks/MooseVariableField.h:382:16: error: no type named 'GradientType' in 'class Moose::FunctorBase<Eigen::Matrix<double, -1, 1> >'\n  382 |   GradientType evaluateGradient(const ElemSideQpArg & elem_side_qp,\n      |                ^~~~~~~~~~~~~~~~\n/home/dff/projects/moose/framework/build/header_symlinks/MooseVariableField.h:428:37: error: no type named 'GradientType' in 'class Moose::FunctorBase<Eigen::Matrix<double, -1, 1> >'\n  428 |   mutable std::vector<GradientType> _current_elem_qp_functor_gradient;\n      |                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/dff/projects/moose/framework/build/header_symlinks/MooseVariableField.h:443:37: error: no type named 'GradientType' in 'class Moose::FunctorBase<Eigen::Matrix<double, -1, 1> >'\n  443 |   mutable std::vector<GradientType> _current_elem_side_qp_functor_gradient;\n      |                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nI have not idea what is the problem.\nThe reason why I was trying to update MOOSE was because when I used the \"ParsedFunction\" kernel, I found the real function in this kernel was not exactly the same as indicated in the https://mooseframework.inl.gov/source/functions/MooseParsedFunction.html. I could not use \"symbol_names\" relevant. I thought it may because the version difference so I updated MOOSE. Then I met new problem.\nMany thanks for any help.",
          "url": "https://github.com/idaholab/moose/discussions/24105",
          "updatedAt": "2023-04-29T02:44:27Z",
          "publishedAt": "2023-04-18T08:17:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "You probably also need to update your Conda packages:\nmamba activate moose\nmamba update --all\nAs a rule of thumb, when you update your moose repo, you should also update Conda. This is because the moose repo is tied to specific versions of libMesh (provided by our Conda moose-libmesh package).",
                  "url": "https://github.com/idaholab/moose/discussions/24105#discussioncomment-5648815",
                  "updatedAt": "2023-04-18T13:02:43Z",
                  "publishedAt": "2023-04-18T13:02:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou were right to update MOOSE. The parameters names have changed to be more intuitive!\nFirst step would be to update libmesh with mamba update --all.\nIf this is not enough, the second suspect for these issues are old pre-compiled objects.\nLet s run make clobberall then try to build again.\nIf that fails, then SAVE ALL your work (git commit - am for example) then run git clean -xfd in the parent folder (moose/)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24105#discussioncomment-5648851",
                  "updatedAt": "2023-04-18T13:05:41Z",
                  "publishedAt": "2023-04-18T13:05:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hhy2022"
                          },
                          "bodyText": "Thank you for the help. I tried to update libmesh but there were new errors:\n\n/home/dff/projects/moose/framework/build/header_symlinks/MathFVUtils.h:187:44: error: 'TensorTraits' is not a member of 'libMesh::TensorTools'\n  187 |   else if constexpr (libMesh::TensorTools::TensorTraits<T1>::rank == 2)\n      |                                            ^~~~~~~~~~~~\n/home/dff/projects/moose/framework/build/header_symlinks/MathFVUtils.h:187:59: error: expected primary-expression before '>' token\n  187 |   else if constexpr (libMesh::TensorTools::TensorTraits<T1>::rank == 2)\n      |                                                           ^\n/home/dff/projects/moose/framework/build/header_symlinks/MathFVUtils.h:187:62: error: '::rank' has not been declared; did you mean 'std::rank'?\n  187 |   else if constexpr (libMesh::TensorTools::TensorTraits<T1>::rank == 2)\n      |                                                              ^~~~\n      |                                                              std::rank\n\n\nI haven't tried the last method. If I only save all my work in my computer without git (there is some issues with my git commands), will the command git clean -xfd clean my work ?\nThank you!",
                          "url": "https://github.com/idaholab/moose/discussions/24105#discussioncomment-5654983",
                          "updatedAt": "2023-04-19T00:59:54Z",
                          "publishedAt": "2023-04-19T00:59:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what doesmamba list | grep moose return?\nThis error is very old, like from a 5 months old libmesh.\nIt may be that the update failed. in this case, you should just delete the moose mamba environment then re-install, and check what you get for the moose-libmesh package\ngit clean -xfd is very dangerous, it will remove any unsaved work.",
                          "url": "https://github.com/idaholab/moose/discussions/24105#discussioncomment-5655733",
                          "updatedAt": "2023-04-19T03:11:37Z",
                          "publishedAt": "2023-04-19T03:11:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Strain energy density calculation for hyperelastic material",
          "author": {
            "login": "ada-ayy"
          },
          "bodyText": "Hello!\nI am trying to model a composite consisting of a hyperelastic component and an elastic component. \u200bI would like to obtain the strain energy density of this whole system for further applications in PHASE FIELD modeling.\nIs there any convenient way to obtain the strain energy density of a hyperelastic material? Or should I write a code to do this calculation?\nI have tried to use StrainEnergyDensity material, but face the problem of stress definition in the hyperelastic region.\nI use ComputeNeoHookeanStress to model holistic behavior. The following is some of my input:\n\n[Kernels]\n[./sdx]\ntype = TotalLagrangianStressDivergence\nvariable = disp_x\ncomponent = 0\nblock = 'poly_QUAD4'\n[../]\n[sdy]\ntype = TotalLagrangianStressDivergence\nvariable = disp_y\ncomponent = 1\nblock = 'poly_QUAD4'\n[]\n[./TensorMechanics]\ndisplacements = 'disp_x disp_y'\nblock = 'fiber_QUAD4'\n[../]\n[]\n[Materials]\ninactive = 'strain_energy_density'\n[./compute_stress_A]\n# type = ComputeStVenantKirchhoffStress\ntype = ComputeNeoHookeanStress\nlambda = 4000.0\nmu = 6700.0\nblock = 'poly_QUAD4'\n[../]\n[./compute_stress_B]\ntype = ComputeLinearElasticStress\nblock = 'fiber_QUAD4'\n[../]\n[./elasticity_tensor_B]\ntype = ComputeElasticityTensor\nblock = 'fiber_QUAD4'\nfill_method = symmetric9\nC_ijkl = '1.1e6 1e5 0 1e6 0 1e6 .5e6 .2e6 .5e6'\n[../]\n[./compute_strain]\ntype = ComputeLagrangianStrain\n[../]\n[./strain_energy_density]\ntype = StrainEnergyDensity\n[../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24107",
          "updatedAt": "2023-04-19T01:25:38Z",
          "publishedAt": "2023-04-18T09:15:34Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "There is no one universal expression for the strain energy density function in a hyperelastic model, unfortunately. Parsing tensorial quantities is not supported yet in MOOSE. You will have to write some C++ to create a Material object to compute the strain energy density.",
                  "url": "https://github.com/idaholab/moose/discussions/24107#discussioncomment-5648664",
                  "updatedAt": "2023-04-18T12:49:56Z",
                  "publishedAt": "2023-04-18T12:49:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ada-ayy"
                          },
                          "bodyText": "Thanks for your reply! I will try",
                          "url": "https://github.com/idaholab/moose/discussions/24107#discussioncomment-5655094",
                          "updatedAt": "2023-04-19T01:25:38Z",
                          "publishedAt": "2023-04-19T01:25:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Solving contact with multi app transfer",
          "author": {
            "login": "lyyc199586"
          },
          "bodyText": "Hi all, I am trying to solve mechanical contact in the main app and phase field fracture in the sub app.\nIn the mechanical app, a disk is being pressured by two plates from bottom and top:\n\nI followed the tutorial and implemented mortar contact successfully.\nBut when I want to add fracture sub app, I found convergence issue in fixed point iteration\nMain app solve:\n\n\nUpdating geometric search patches\n\n 0 Nonlinear |R| = 1.348002e-07\n Solve Converged!\nfracture0: \nfracture0: Time Step 5, time = 0.25, dt = 0.05\nfracture0:  Solve Skipped!\nFixed point residual norm after TIMESTEP_END MultiApps: 1.348002e-07\n\n 0 Picard |R| = 1.060660e-02\n 1 Picard |R| = 1.348002e-07\n 2 Picard |R| = 1.348002e-07\n 3 Picard |R| = 1.348002e-07\n 4 Picard |R| = 1.348002e-07\n 5 Picard |R| = 1.348002e-07\n 6 Picard |R| = 1.348002e-07\n 7 Picard |R| = 1.348002e-07\n 8 Picard |R| = 1.348002e-07\n 9 Picard |R| = 1.348002e-07\n10 Picard |R| = 1.348002e-07\n11 Picard |R| = 1.348002e-07\n12 Picard |R| = 1.348002e-07\n13 Picard |R| = 1.348002e-07\n14 Picard |R| = 1.348002e-07\n15 Picard |R| = 1.348002e-07\n16 Picard |R| = 1.348002e-07\n17 Picard |R| = 1.348002e-07\n18 Picard |R| = 1.348002e-07\n19 Picard |R| = 1.348002e-07\n20 Picard |R| = 1.348002e-07\n21 Picard |R| = 1.348002e-07\n22 Picard |R| = 1.348002e-07\n23 Picard |R| = 1.348002e-07\n24 Picard |R| = 1.348002e-07\n25 Picard |R| = 1.348002e-07\n26 Picard |R| = 1.348002e-07\n27 Picard |R| = 1.348002e-07\n28 Picard |R| = 1.348002e-07\n29 Picard |R| = 1.348002e-07\n30 Picard |R| = 1.348002e-07\n31 Picard |R| = 1.348002e-07\n32 Picard |R| = 1.348002e-07\n33 Picard |R| = 1.348002e-07\n34 Picard |R| = 1.348002e-07\n35 Picard |R| = 1.348002e-07\n36 Picard |R| = 1.348002e-07\n37 Picard |R| = 1.348002e-07\n38 Picard |R| = 1.348002e-07\n39 Picard |R| = 1.348002e-07\n40 Picard |R| = 1.348002e-07\n41 Picard |R| = 1.348002e-07\n42 Picard |R| = 1.348002e-07\n43 Picard |R| = 1.348002e-07\n44 Picard |R| = 1.348002e-07\n45 Picard |R| = 1.348002e-07\n46 Picard |R| = 1.348002e-07\n47 Picard |R| = 1.348002e-07\n48 Picard |R| = 1.348002e-07\n49 Picard |R| = 1.348002e-07\n50 Picard |R| = 1.348002e-07\n\nFixed point convergence reason: REACH_MAX_ITS\n\nOutlier Variable Residual Norms:\n  top_contact_normal_lm: 1.062290e-07\n\nSince I am only testing the transfer between the main app and the sub app (the sub app is not solved solve = False), I suspect it is caused by multi app transfer. I tried many transfer methods but this still happens. Do you have any suggestions for solving contact with multi app?\n\nps: my input file for main app:\n# BegoStone\nE = 6.16e3\nnu = 0.2\nGc = 3.656e-2\nsigma_ts = 10\nsigma_cs = 80\nl = 0.25\ndelta = 25\n\n# steel (for anvil)\nE_s = 2e5 # 200 GPa\nnu_s = 0.31\n\n# R = 2.9 \nv = 0.05\n\n# ---------------------------------\nK = '${fparse E/3/(1-2*nu)}'\nG = '${fparse E/2/(1+nu)}'\nLambda = '${fparse E*nu/(1+nu)/(1-2*nu)}'\n\nK_s = '${fparse E_s/3/(1-2*nu_s)}'\nG_s = '${fparse E_s/2/(1+nu_s)}'\n\n[MultiApps]\n  [fracture]\n    type = TransientMultiApp\n    input_files = fracture.i\n    cli_args = 'E=${E};K=${K};G=${G};Lambda=${Lambda};Gc=${Gc};l=${l};sigma_ts=${sigma_ts};sigma_cs=${sigma_cs};delta=${delta}'\n    execute_on = 'TIMESTEP_END'\n  []\n[]\n\n[Transfers]\n  [from_d]\n    # type = MultiAppCopyTransfer\n    type = MultiAppGeneralFieldShapeEvaluationTransfer\n    # type = MultiAppMeshFunctionTransfer\n    # type = MultiAppShapeEvaluationTransfer\n    # type = MultiAppGeometricInterpolationTransfer\n    from_multi_app = fracture\n    variable = 'd'\n    source_variable = 'd'\n    # to_blocks = 'disk'\n  []\n  [to_psie_active]\n    type = MultiAppGeneralFieldShapeEvaluationTransfer\n    # type = MultiAppMeshFunctionTransfer\n    # type = MultiAppShapeEvaluationTransfer\n    # type = MultiAppGeometricInterpolationTransfer\n    to_multi_app = fracture\n    variable = 'disp_x disp_y psie_active'\n    source_variable = 'disp_x disp_y psie_active'\n    # from_blocks = 'disk'\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Mesh]\n  coord_type = XYZ\n  [fmg]\n    type = FileMeshGenerator\n    file = '../mesh/disk_mortar_flat_h0.082.msh'\n    show_info = true\n  []\n  [top_arc]\n    type = ParsedGenerateSideset\n    combinatorial_geometry = 'abs(x*x+y*y - 2.9^2) < 0.01 & y> 2.7'\n    new_sideset_name = 'top_arc'\n    input = fmg\n  []\n  [bot_arc]\n    type = ParsedGenerateSideset\n    combinatorial_geometry = 'abs(x*x+y*y - 2.9^2) < 0.01 & y< -2.7'\n    new_sideset_name = 'bot_arc'\n    input = top_arc\n  []\n  [fix_point]\n    type = BoundingBoxNodeSetGenerator\n    input = bot_arc\n    new_boundary = fix_point\n    bottom_left = '-0.1 2.8 0'\n    top_right = '-0.09 2.9 0'\n  []\n  patch_size = 4\n  patch_update_strategy = always\n\n[]\n\n[Contact]\n  [top_contact]\n    primary = top_anvil_bottom\n    secondary = top_arc\n    model = frictionless\n    formulation = mortar\n    correct_edge_dropping = true\n    c_normal = 1e3\n  []\n  [bottom_contact]\n    primary = bottom_anvil_top\n    secondary = bot_arc\n    model = frictionless\n    formulation = mortar\n    correct_edge_dropping = true\n    c_normal = 1e3\n  []\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n[]\n\n[Kernels]\n  [solid_r]\n    type = ADStressDivergenceTensors\n    variable = disp_x\n    component = 0\n    save_in = f_x\n    block = 'disk top_anvil bottom_anvil'\n  []\n  [solid_z]\n    type = ADStressDivergenceTensors\n    variable = disp_y\n    component = 1\n    save_in = f_y\n    block = 'disk top_anvil bottom_anvil'\n  []\n[]\n\n\n[BCs]\n  [top_y]\n    type = ADFunctionDirichletBC\n    variable = disp_y\n    boundary = top_anvil_top\n    function = '-${v}*t'\n  []\n  [top_x]\n    type = ADDirichletBC\n    variable = disp_x\n    boundary = top_anvil_top\n    value = 0\n  []\n  [bottom_y]\n    type = ADFunctionDirichletBC\n    variable = disp_y\n    boundary = bottom_anvil_bottom\n    function = '${v}*t'\n  []\n  [bottom_x]\n    type = ADDirichletBC\n    variable = disp_x\n    boundary = bottom_anvil_bottom\n    value = 0\n  []\n  [fix_top_x]\n    type = ADDirichletBC\n    variable = disp_x\n    boundary = fix_point\n    value = 0\n  []\n[]\n\n[Materials]\n  # bego\n  [bulk_properties_bego]\n    type = ADGenericConstantMaterial\n    prop_names = 'E K G lambda Gc l'\n    prop_values = '${E} ${K} ${G} ${Lambda} ${Gc} ${l}'\n    block = 'disk'\n  []\n  [nodegradation]\n    type = NoDegradation\n    f_name = g\n    function = 1\n    phase_field = d\n    block = 'disk'\n  []\n  [strain_bego]\n    # type = ADComputePlaneSmallStrain\n    # out_of_plane_strain = 'strain_zz'\n    displacements = 'disp_x disp_y'\n    type = ADComputeSmallStrain\n    output_properties = 'total_strain'\n    outputs = exodus\n    block = 'disk'\n  []\n  [elasticity_bego]\n    type = SmallDeformationIsotropicElasticity\n    bulk_modulus = K\n    shear_modulus = G\n    phase_field = d\n    degradation_function = g\n    decomposition = NONE\n    # decomposition = VOLDEV\n    output_properties = 'psie_active'\n    outputs = exodus\n    block = 'disk'\n  []\n  [stress_bego]\n    type = ComputeSmallDeformationStress\n    elasticity_model = elasticity_bego\n    output_properties = 'stress'\n    block = 'disk'\n    outputs = exodus\n  []\n\n  # steel\n  [elasticity_steel]\n    type = ADComputeIsotropicElasticityTensor\n    bulk_modulus = ${K_s}\n    shear_modulus = ${G_s}\n    block = 'top_anvil bottom_anvil'\n  []\n  [stress_steel]\n    type = ADComputeLinearElasticStress\n    block = 'top_anvil bottom_anvil'\n    # outputs = exodus\n  []\n  [strain_steel]\n    type = ADComputeSmallStrain\n    block = 'top_anvil bottom_anvil'\n  []\n[]\n\n\n[Executioner]\n  type = Transient\n\n  # moose tutorial settings\n  solve_type = 'PJFNK'\n  petsc_options = '-snes_ksp_ew'\n\n  petsc_options_iname = '-pc_type -snes_linesearch_type -pc_factor_shift_type '\n                        '-pc_factor_shift_amount'\n  petsc_options_value = 'lu       basic                 NONZERO               1e-15'\n  line_search = 'none'\n  automatic_scaling = true\n  nl_rel_tol = 2e-7\n  nl_abs_tol = 2e-7\n  l_max_its = 40\n  l_abs_tol = 1e-08\n  l_tol = 1e-08\n\n  dt = 0.05\n  end_time = 0.8\n\n\n  fixed_point_max_its = 50\n  accept_on_max_fixed_point_iteration = true\n  fixed_point_rel_tol = 1e-6\n  fixed_point_abs_tol = 1e-8\n\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24116",
          "updatedAt": "2023-04-19T00:10:52Z",
          "publishedAt": "2023-04-18T21:30:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you try adding a relaxation factor to the MultiApp setup?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24116#discussioncomment-5654020",
                  "updatedAt": "2023-04-18T21:33:02Z",
                  "publishedAt": "2023-04-18T21:33:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "After choosing a larger tolerance for fixed point iteration, it converges. Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/24116#discussioncomment-5654766",
                          "updatedAt": "2023-04-19T00:12:17Z",
                          "publishedAt": "2023-04-19T00:10:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "The issue is in the tolerances:\n  nl_rel_tol = 2e-7\n  nl_abs_tol = 2e-7\n  fixed_point_rel_tol = 1e-6\n  fixed_point_abs_tol = 1e-8\nThere's no point in using a fixed point tolerance tighter than the main app nonlinear tolerance. Otherwise, you'll observe exactly what you are seeing here: The main app thinks it's converged, but fixed point iteration thinks the iteration is not making any progress.\nBTW, is this a brazilian disk test that you are trying to simulate? If so, keep me posted :)",
                  "url": "https://github.com/idaholab/moose/discussions/24116#discussioncomment-5654458",
                  "updatedAt": "2023-04-18T23:09:04Z",
                  "publishedAt": "2023-04-18T23:09:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "you are correct, after set fixed_point_abs_tol = 1e-6 it converges.\nYes, it is! we want to use contact module for Brazilian disk test simulations.",
                          "url": "https://github.com/idaholab/moose/discussions/24116#discussioncomment-5654760",
                          "updatedAt": "2023-04-19T00:09:47Z",
                          "publishedAt": "2023-04-19T00:09:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Phase field in axisymmetric coordinates",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Hello everyone,\nBased on the way that phase field kernels in the cahn hilliard split form are developed, can I use them in axisymmetric coordinates or custom kernels must be developed like the navier stokes equation in rz coordinates?\nThanks,\nAli",
          "url": "https://github.com/idaholab/moose/discussions/24073",
          "updatedAt": "2023-04-29T02:44:45Z",
          "publishedAt": "2023-04-14T20:59:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "If you are using split forms (into two second-order equation), kernels will be the same. If you are not, then you need a special kernel for the 4th- order term.",
                  "url": "https://github.com/idaholab/moose/discussions/24073#discussioncomment-5620363",
                  "updatedAt": "2023-04-14T21:27:09Z",
                  "publishedAt": "2023-04-14T21:27:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "I am using the split form and only deal with 2nd order derivative.\nBut are you 100% sure about this? This is the definition of the 1st and 2nd order derivatives of a scalar variable and this completely different with xy coordinates.",
                          "url": "https://github.com/idaholab/moose/discussions/24073#discussioncomment-5620559",
                          "updatedAt": "2023-04-14T22:13:24Z",
                          "publishedAt": "2023-04-14T22:13:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "alimostafavi24"
                  },
                  "bodyText": "I think that phase field cannot be used in axisymmetric coordinates. Because the 2nd order derivative of c is still present in the weak form residual and the definition of which is very different in XY and RZ coordinates. Can someone please confirm that I am correct or not?\n\nThanks,\nAli",
                  "url": "https://github.com/idaholab/moose/discussions/24073#discussioncomment-5625129",
                  "updatedAt": "2023-04-15T19:31:54Z",
                  "publishedAt": "2023-04-15T19:31:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "In RZ we assume the derivatives in theta to be zero. With some work you can prove that the divergence theorem holds in cylindrical coordinates, using which you can arrive at the same weak form. Transforming the integration from cylindrical coordinates to Cartesian requires simply replacing r with x, and an additional coordinate transformation factor r which is accounted for for you in _coord[_qp].",
                          "url": "https://github.com/idaholab/moose/discussions/24073#discussioncomment-5638443",
                          "updatedAt": "2023-04-17T15:11:05Z",
                          "publishedAt": "2023-04-17T15:11:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "I think now I understand your concern. In the plot you show, the residual term has \\Lap c in the SplitCHParsed kernel. The description here is a bit confusing. In the actual code,  the \\Lap c will be transformed into the \\nabla c by taking the integral by part, so only gradient term will be remained. See the code below\nReal\nSplitCHCRes::computeQpResidual()\n{\n  Real residual =\n      SplitCHBase::computeQpResidual(); //(f_prime_zero+e_prime)*_test[_i][_qp] from SplitCHBase\n\n  residual += -_w[_qp] * _test[_i][_qp];\n  residual += _kappa[_qp] * _grad_u[_qp] * _grad_test[_i][_qp];\n\n  return residual;\n}\n\nAfter you understand this, you can follow @hugary1995 's comment to prove the split form will work for RZ coordinate system.",
                          "url": "https://github.com/idaholab/moose/discussions/24073#discussioncomment-5639178",
                          "updatedAt": "2023-04-17T16:13:52Z",
                          "publishedAt": "2023-04-17T16:13:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Yes, exactly! Documentation on the split phase field equations is a bit misleading here! Thank you very much for the help (@jiangwen84 @hugary1995 ).",
                          "url": "https://github.com/idaholab/moose/discussions/24073#discussioncomment-5654637",
                          "updatedAt": "2023-04-18T23:51:28Z",
                          "publishedAt": "2023-04-18T23:51:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mixing ADKernel and Kernel",
          "author": {
            "login": "rks171"
          },
          "bodyText": "I am testing out using the ADTimeKernel in my application in place of TimeKernel.  It is my understanding that it is ok to mix the AD classes and non-AD classes (all of the other kernels in my application are of the non-AD type currently).  After I do this, my test case stops converging.  What is confusing me, however, is that my Preconditioning block defines a \"FDP\" preconditioner.  I thought this meant the Jacobian was numerically calculated, so I was expecting the ADTimeKernel switch to have no impact until I switch to using the AD-calculated Jacobian.  Does the switch have some other impact on the solution?  Is the AD-calculated Jacobian still being used in my solution?",
          "url": "https://github.com/idaholab/moose/discussions/24111",
          "updatedAt": "2023-04-29T02:57:40Z",
          "publishedAt": "2023-04-18T13:39:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "FDP should finite difference the residuals, so the implication here would be that the AD kernel's residuals are different than the non-AD kernels, which would definitely be concerning. Do you have an example input I could try?",
                  "url": "https://github.com/idaholab/moose/discussions/24111#discussioncomment-5650296",
                  "updatedAt": "2023-04-18T15:04:29Z",
                  "publishedAt": "2023-04-18T15:04:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "rks171"
                  },
                  "bodyText": "Unfortunately, this is in a MOOSE application with local changes, so it's not very easy to share an input to reproduce the issue.  Maybe there is a problem with how I am switching out my TimeKernel for ADTimeKernel?  I inherit from ADTimeKernel instead of TimeKernel, comment out the computeQpJacobian and computeQpOffDiagJacobian methods, change the computeQpResidual method to type ADReal, and change all of my Real types to ADReal in the class.  My computeQpResidual method is very simple.  It is only returning _rho_dot[_qp]*_test[_i][_qp].  Are there any other changes I would need to make when making the switch?",
                  "url": "https://github.com/idaholab/moose/discussions/24111#discussioncomment-5652462",
                  "updatedAt": "2023-04-18T18:20:28Z",
                  "publishedAt": "2023-04-18T18:20:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "How are you retrieving the dot variable value? Using couplesDot ?\nThere s an AD version of this to use",
                          "url": "https://github.com/idaholab/moose/discussions/24111#discussioncomment-5652630",
                          "updatedAt": "2023-04-18T20:21:37Z",
                          "publishedAt": "2023-04-18T18:35:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rks171"
                          },
                          "bodyText": "I am using adCoupledDot.",
                          "url": "https://github.com/idaholab/moose/discussions/24111#discussioncomment-5652652",
                          "updatedAt": "2023-04-18T18:38:20Z",
                          "publishedAt": "2023-04-18T18:38:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you share the code with us or is it restricted?",
                          "url": "https://github.com/idaholab/moose/discussions/24111#discussioncomment-5653539",
                          "updatedAt": "2023-04-18T20:30:40Z",
                          "publishedAt": "2023-04-18T20:30:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}