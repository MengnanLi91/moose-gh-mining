{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNi0yM1QxNzoyODowOS0wNTowMM4AM38i"
    },
    "edges": [
      {
        "node": {
          "title": "Issue about recompiling codes in HPC",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Hello!\nAfter I developed several code for MOOSE, I uploaded the code in HPC.\nWhile I tried to recompile the code, I got errors like below.\n\nSo far, even I got an error about \"gfortran\", but actually compiling itself was done successfully.\nBut, this time, I don't know why this happened.\nIs there any suggestions for me?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/18177",
          "updatedAt": "2021-06-25T20:55:35Z",
          "publishedAt": "2021-06-25T20:38:27Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nLooks like you need to make sure you have MPI wrapped compilers available. Depending on which cluster you are working on, they would be available in modules. You would need to load those.\nIf there are no modules and no one set up moose for you on the cluster, then you can follow these instructions:\nhttps://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18177#discussioncomment-922802",
                  "updatedAt": "2021-06-25T20:53:07Z",
                  "publishedAt": "2021-06-25T20:52:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Because I didn't work in HPC so long, I forgot to load module which I needed in HPC.\nAfter loading modules in HPC, recompiling itself was done successfully.\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/18177#discussioncomment-922806",
                          "updatedAt": "2021-06-25T20:55:26Z",
                          "publishedAt": "2021-06-25T20:55:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "supplied material check",
          "author": {
            "login": "mghkorzani"
          },
          "bodyText": "Hi all,\nI have a question regarding material properties.\nI have a pointer material within a new material class (e.g. MatA class). I would like to see if a property name is declared by another material class  or not (e.g. MatB class). How can I check it? Because if the property is declared in MatB class, I can point my pointer material in MatA class to that property in MatB class. Otherwise, I should locally calculate the required property in my MatA class and make my pointer material null.\nI appreciate your helps.\nCheers,\nMaziar",
          "url": "https://github.com/idaholab/moose/discussions/18170",
          "updatedAt": "2022-11-03T17:24:12Z",
          "publishedAt": "2021-06-25T09:47:53Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Maziar\nyou can use getMaterialProperty from a material. I would create the material property in the constructor of the material, then check if it is defined in the current block in the compute properties routine.\nIf defined, then use that value\nIf not use the new material s value.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18170#discussioncomment-921007",
                  "updatedAt": "2022-11-03T17:24:20Z",
                  "publishedAt": "2021-06-25T14:10:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mghkorzani"
                  },
                  "bodyText": "Hi Guillaume,\n\n\n\nThanks for your answer.\n\nThe problem is here. I always use getMaterialProperty to read properties that are defined in other classes. However in this case, if it is not defined in another material class, I will receive an error because I tried to initialize my pointer. I tried hasMaterialProperty but did not work since it is looking for properties that are defined in its own class.\n\nMaybe it is better to explain the real problem:\n\nI try to read the strain rate from the tensor mechanics module. In the case of small strain, it is not declared but for incremental cases, it is declared as a ranktwotensor. I would like to see my material realise it by itself which means:\n\n1. In small non-incremental strain (total strain), I calculate it in my material. -> I already did the calculation.\n\n2. In incremental strain, I just get it from the tensor mechanics material property.  -> I know how to get it and I used it but I need to know in my material constructor that I should get this material or calculate it myself.\n\n\n\nCheers,\n\nMaziar\n\n\n\nFrom: Guillaume Giudicelli ***@***.***>\nSent: Friday, June 25, 2021 4:11 PM\nTo: idaholab/moose ***@***.***>\nCc: Maziar Korzani ***@***.***>; Author ***@***.***>\nSubject: Re: [idaholab/moose] supplied material check (#18170)\n\n\n\nHi Maziar\n\nyou can use getMaterialProperty from a material. I would create the material property in the constructor of the material, then check if it is defined in the current block in the compute properties routine.\n\nIf defined, then use that value\nIf not use the new material s value.\n\nGuillaume\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub <#18170 (comment)> , or unsubscribe <https://github.com/notifications/unsubscribe-auth/AHY7CALWDCMEHDYZE73RNYTTUSE7FANCNFSM47JRUWJA> .  <https://github.com/notifications/beacon/AHY7CALGVXKLVJJXR2WHXJLTUSE7FA5CNFSM47JRUWJKYY3PNVWWK3TUL52HS4DFWFCGS43DOVZXG2LPNZBW63LNMVXHJKTDN5WW2ZLOORPWSZGOAAHA3LY.gif>",
                  "url": "https://github.com/idaholab/moose/discussions/18170#discussioncomment-921225",
                  "updatedAt": "2022-11-03T17:24:43Z",
                  "publishedAt": "2021-06-25T14:57:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nOk thanks for the explanation I thought this was a block restriction issue.\nYou could have a boolean in your material. Or equivalently specify the strain model to the material.\nThen at construction you can use _matprop(_need_to_declare_it ? declareMatprop() : getMaterialProperty() )\nOr something more detailed in the body of the constructor with a mooseError or mooseWarning if not enough information is provided by the user to make the selection.\nIf you try to retrieve a material property and it doesnt exist, it will error out. I dont think there is a way around it, but @rwcarlsen would know more about the material system.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18170#discussioncomment-922279",
                  "updatedAt": "2022-11-03T17:24:42Z",
                  "publishedAt": "2021-06-25T17:44:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "rwcarlsen"
                  },
                  "bodyText": "Normally hasMaterialProperty would do what you want - e.g. something like MaterialProperty<Foo> * foo = hasMaterialProperty(...) ? getMaterialProperty(...) : nullptr.  The problem is that you are doing this within a material object's constructor - and so all the materials might not be constructed yet - so you might get an error even though that property will be defined by another material after.  Also, if you call getMaterialProperty in a different function that runs later (e.g. not the constructor) - then you risk moose not seeing the inter-property dependency.  One workaround might be putting your getMaterialProperty call in the material's constructor body - and surround it with a try-catch.  In the catch - you just make the property be a nullptr and then you know you need to calculate it manually.",
                  "url": "https://github.com/idaholab/moose/discussions/18170#discussioncomment-922646",
                  "updatedAt": "2022-11-03T17:24:29Z",
                  "publishedAt": "2021-06-25T19:54:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mghkorzani"
                  },
                  "bodyText": "Thanks for the help.I set a bool input parameter to be supplied by users with the same name of the tensor mechanics equivalent. So I can set it for the both in my global parameter. Or I should use the approach of the dictator uo as per porous flow module.Have a nice weekend.Sent from my Galaxy\n-------- Original message --------From: Robert Carlsen ***@***.***> Date: 25/6/21  21:55  (GMT+01:00) To: idaholab/moose ***@***.***> Cc: Maziar Korzani ***@***.***>, Author ***@***.***> Subject: Re: [idaholab/moose] supplied material check (#18170) \nNormally hasMaterialProperty would do what you want - e.g. something like MaterialProperty<Foo> * foo = hasMaterialProperty(...) ? getMaterialProperty(...) : nullptr.  The problem is that you are doing this within a material object's constructor - and so all the materials might not be constructed yet - so you might get an error even though that property will be defined by another material after.  Also, if you call getMaterialProperty in a different function that runs later (e.g. not the constructor) - then you risk moose not seeing the inter-property dependency.  One workaround might be putting your getMaterialProperty call in the material's constructor body - and surround it with a try-catch.  In the catch - you just make the property be a nullptr and then you know you need to calculate it manually.\n\n\u2014You are receiving this because you authored the thread.Reply to this email directly, view it on GitHub, or unsubscribe.",
                  "url": "https://github.com/idaholab/moose/discussions/18170#discussioncomment-922778",
                  "updatedAt": "2022-11-03T17:24:29Z",
                  "publishedAt": "2021-06-25T20:44:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Adding Material Property to Custom Kernel",
          "author": {
            "login": "alanchavez86"
          },
          "bodyText": "Hi All!\nI was wondering if I can get some help with adding a material property to a custom kernel that can compute the magnetic potential in the following equation:\n\nM is the magnetization saturation with respect to c1, c2, and c3. (Little bit of context here, I'm using the phase-field method to model the spinodal decomposition of FeCrCo.)\nI modified the CoefDiffusion kernel to calculate \u2207^2\u03c6 = x*y and compared the results to a benchmark from COMSOL with accurate results:\n\nMy goal is to customize my custom kernel so that it can take M as a function from the Materials system and then take the gradient with respect to x (assuming that the magnetic direction is going towards the x direction). Here are my .C and .h files for the custom kernel:\n#include \"NewCoefDiffusion.h\"\n\nregisterMooseObject(\"diffusion\", NewCoefDiffusion);\n\nInputParameters\nNewCoefDiffusion::validParams()\n{\n  InputParameters params = Kernel::validParams();\n  params.addParam<Real>(\"coef\", 0.0, \"Diffusion coefficient\");\n  params.addParam<FunctionName>(\"function\",\n                                \"If provided, the diffusion coefficient will be coef + \"\n                                \"this function.  This is useful for temporally or \"\n                                \"spatially varying diffusivities\");\n  params.addClassDescription(\"Kernel for diffusion with diffusivity = coef + function\");\n  params.addRequiredParam<MaterialPropertyName>(\"m\", \"Base name of the Magnetization Saturation defined in a DertivativeParsedMaterial\");\n  return params;\n}\n\nNewCoefDiffusion::NewCoefDiffusion(const InputParameters & parameters)\n  : Kernel(parameters),\n    _coef(getParam<Real>(\"coef\")),\n    _func(parameters.isParamValid(\"function\") ? &getFunction(\"function\") : NULL),\n    _m(getMaterialPropertyDerivative<Real>(\"m\", _var.name()))\n{\n}\n\nReal\nNewCoefDiffusion::computeQpResidual()\n{\n  Real diffusivity = _coef;\n\n  if (_func)\n    diffusivity += _func->value(_t, _q_point[_qp]);\n\n  return _grad_test[_i][_qp] * -_grad_u[_qp] - _m*grad_test[_i][_qp];\n}\n\nReal\nNewCoefDiffusion::computeQpJacobian()\n{\n  Real diffusivity = _coef;\n\n  if (_func)\n    diffusivity += _func->value(_t, _q_point[_qp]);\n\n  return _grad_test[_i][_qp] * -_grad_phi[_j][_qp] - _m*grad_test[_i][_qp];\n}\n\n\n#pragma once\n\n#include \"Kernel.h\"\n#include \"Function.h\"\n#include \"DerivativeMaterialInterface.h\"\n\nclass NewCoefDiffusion : public Kernel\n{\npublic:\n  static InputParameters validParams();\n\n  NewCoefDiffusion(const InputParameters & parameters);\n\nprotected:\n  virtual Real computeQpResidual();\n  virtual Real computeQpJacobian();\n\nprivate:\n  const Real _coef;\n  const Function * const _func;\n  const MaterialProperty<Real> & _m;\n};\n\n\nI thought following SplitCHParsed.C and SplitCHWRes.C and their implementation of Material properties would be straightforward, but it turns out it's not.\nAny help would be appreciated! Thank you!",
          "url": "https://github.com/idaholab/moose/discussions/18157",
          "updatedAt": "2022-06-06T14:39:26Z",
          "publishedAt": "2021-06-23T22:02:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @alanchavez86\nYou can see an example in this kernel in my repository:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/kernels/ConservativeAdvectionCoupled.C\nI get a material property (a vector) in the kernel using:\n_edge_slip_direction(getMaterialProperty<std::vector>(\"edge_slip_direction\")),\nThis material property is declared in this material:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainCrystalPlasticityDislo.C\nas:\n_edge_slip_direction(declareProperty<std::vector>(\"edge_slip_direction\")),\nand it is calculated inside the material object.\nTrust this helps,\nNicol\u00f2 Grilli\nUniversity of Bristol",
                  "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-913629",
                  "updatedAt": "2022-06-06T14:39:37Z",
                  "publishedAt": "2021-06-24T07:33:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Hey Nicolo, some unsolicited comments: in the example you are using a ton of addCoupledVar. Are you aware that we support vector coupling? I.e. the user can specify multiple coupled variable per addCoupledVar parameter. You can access those with the optional component parameter in coupledValue(\"name\", component) and get the number of coupled components with coupledComponents(\"name\"). The slip direction property should be of type std::vector<RealVectorValue> and be sized to _nss rather than _nss * LIBMESH_DIM.",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-916653",
                          "updatedAt": "2022-06-06T14:39:40Z",
                          "publishedAt": "2021-06-24T16:48:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @dschwen\nYour comment is very useful to improve my code.\nI was not aware of the coupled vectors.\nI was actually looking for that some time ago but I am not enough familiar with the framework.\nCould you point me to an example kernel where vector coupling is implemented?\nMy idea is to develop a continuum dislocation dynamics code in which dislocation densities are variables\nbecause I need to introduce the flux terms, dislocation multiplication, et cetera.\nThen I couple the dislocation density variables with the crystal plasticity material\nby implementing Orowan law and calculating dislocation velocity.\nIndeed, if I could do vector variable coupling, I could develop a general code with an arbitrary number of active slip system,\nwhile now the number of slip systems is fixed.\nI am using the slip direction vector to pass the rotated slip directions of all slip systems\nto the Advection kernel, so that I can implement dislocation flux along arbitrary directions on slip plane in 3D\ndepending on the crystal rotation matrix.\nPlease always write these unsolicited comments.\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-916993",
                          "updatedAt": "2022-06-06T14:39:41Z",
                          "publishedAt": "2021-06-24T18:09:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alanchavez86"
                          },
                          "bodyText": "@ngrilli\nThank you for the suggestion! I went through and followed your kernel from your repository and modified my kernel. Looking into your files, I've noticed that there is a src/materials directory. Would I have to create a new materials directory and possibly add a custom material file?\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-917045",
                          "updatedAt": "2022-06-06T14:39:56Z",
                          "publishedAt": "2021-06-24T18:22:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "@ngrilli , here https://github.com/idaholab/moose/blob/06bc1f73f0d4dfb3d01ce9ba77d6bb97346e07eb/modules/phase_field/src/ics/CoupledValueFunctionIC.C is an example\n\n  \n    \n      moose/modules/phase_field/include/ics/CoupledValueFunctionIC.h\n    \n    \n         Line 28\n      in\n      06bc1f7\n    \n  \n  \n    \n\n        \n          \n           const std::vector<const VariableValue *> _vals; \n        \n    \n  \n\n\n\n  \n    \n      moose/modules/phase_field/src/ics/CoupledValueFunctionIC.C\n    \n    \n        Lines 22 to 24\n      in\n      06bc1f7\n    \n  \n  \n    \n\n        \n          \n           params.addCoupledVar(\"v\", \n        \n\n        \n          \n                                \"List of up to four coupled variables that are substituted for x,y,z, and t \" \n        \n\n        \n          \n                                \"in the coupled function\"); \n        \n    \n  \n\n\n\n  \n    \n      moose/modules/phase_field/src/ics/CoupledValueFunctionIC.C\n    \n    \n         Line 32\n      in\n      06bc1f7\n    \n  \n  \n    \n\n        \n          \n           _vals(coupledValues(\"v\")) \n        \n    \n  \n\n\nInstead of coupledValue(\"name\", component) I'm using the even simpler coupledValues(\"name\") (note the plural) which gets a vector of variable pointers.",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-917765",
                          "updatedAt": "2022-08-18T12:33:28Z",
                          "publishedAt": "2021-06-24T21:40:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @alanchavez86\nI keep the same structure as the MOOSE framework directory system,\ntherefore I include material classes in a /materials/ folder.\nI am not sure if that is compulsory, but I don't see why you should not do that.\nIt's useful for distinguishing material classes from kernel classes.\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-920293",
                          "updatedAt": "2022-08-18T12:34:14Z",
                          "publishedAt": "2021-06-25T11:03:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alanchavez86"
                          },
                          "bodyText": "@ngrilli\nThank you for the clarification. I wasn't aware that you can create your own material classes. I'm still fairly new at creating custom kernels so I didn't think of this at first. I'll try the parts of your code that you mentioned and let you know how it goes!",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-921615",
                          "updatedAt": "2022-08-18T12:40:23Z",
                          "publishedAt": "2021-06-25T16:34:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "At the very least you need to replace _m with _m[_qp].",
                  "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-916657",
                  "updatedAt": "2022-06-06T14:39:44Z",
                  "publishedAt": "2021-06-24T16:50:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Also you calculate diffusivity and never use it.",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-916659",
                          "updatedAt": "2022-06-06T14:39:57Z",
                          "publishedAt": "2021-06-24T16:51:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alanchavez86"
                          },
                          "bodyText": "@dschwen\nThank you for catching those. I must have overlooked those mistakes when modifying the CoefDIffusion kernel.",
                          "url": "https://github.com/idaholab/moose/discussions/18157#discussioncomment-917068",
                          "updatedAt": "2022-06-06T14:39:44Z",
                          "publishedAt": "2021-06-24T18:30:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cannot see Variable in output file",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "After simulation was done, I opened the result(*.e) through Paraview.\n\nHowever, as shown at above, I cannot see one of variables (phi_Ni) I assigned for the simulation.\n\nDuring the simulation, I saw messaged like above.\n\"Outlier Variable Residual Norms\".\nIs this related to not seeing the variable in the output file?",
          "url": "https://github.com/idaholab/moose/discussions/18168",
          "updatedAt": "2023-02-13T10:51:05Z",
          "publishedAt": "2021-06-25T07:48:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthe outlier variable residual norm is not related to not seeing the variable.\nthis is very odd. Unless you have hide = \u2018phi_Ni\u2019 in the output block, I do not understand why it s happening.\nCould you please delete the exodus file and try generating it again? You may be opening an old one or something?\nguillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18168#discussioncomment-921014",
                  "updatedAt": "2023-02-13T10:51:19Z",
                  "publishedAt": "2021-06-25T14:12:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "I read my input file thoroughly.\nI just got a point.\n'phi_Ni' existed at [Variables] and [Postprocessors].\nAfter I changed the name in [Postprocessors], then now I can see the variable in output file.",
                          "url": "https://github.com/idaholab/moose/discussions/18168#discussioncomment-921596",
                          "updatedAt": "2023-02-13T10:51:33Z",
                          "publishedAt": "2021-06-25T16:27:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get the variable values from other elements\uff1f",
          "author": {
            "login": "xiekai-mc"
          },
          "bodyText": "Hello everyone,\nI want to get the variable values from other elements in indicators. And those elements are within a specified distance from the current element. Now I can only get the variable values from the current element with ElementIndicator.\nPlease help me, thanks.",
          "url": "https://github.com/idaholab/moose/discussions/18150",
          "updatedAt": "2022-08-13T19:23:52Z",
          "publishedAt": "2021-06-23T09:58:53Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThat's not a very common need. If I may, what are you trying to do with that?\nYou could hack it and re-init at the neighbor element to get the variables there, but there may be a simpler way if you give us more details on what you want to do.\nEDIT:\nActually it's not too bad for variable values. Use a pointer to the variable instead of the coupled interface to work with the variable, then use\n_var->getElementalValue(const Elem * neighbor, unsigned int index(<-for vectors/arrays) )\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18150#discussioncomment-910945",
                  "updatedAt": "2022-08-13T19:23:52Z",
                  "publishedAt": "2021-06-23T15:53:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiekai-mc"
                          },
                          "bodyText": "Thank you for your reply.  I guess the 'Elem * neighbor' is the element next to the current one.  Is there any way for a pointer to point to an arbitrary element ?",
                          "url": "https://github.com/idaholab/moose/discussions/18150#discussioncomment-920979",
                          "updatedAt": "2022-08-13T19:24:03Z",
                          "publishedAt": "2021-06-25T14:03:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You could have any element as an argument there, the problem is how do you retrieve the pointer in the kernel?\nNeighbor is easy to get to from the attributes of the current element. You could retrieve an arbitrary element pointer from the mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/18150#discussioncomment-920989",
                          "updatedAt": "2022-08-13T19:24:21Z",
                          "publishedAt": "2021-06-25T14:06:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Symbol Lookup Error",
          "author": {
            "login": "ritamcj"
          },
          "bodyText": "Hi everyone,\nI am working with the CoupledGradient API in Moose and attempting to calculate grad(Fp) in the tensor mechanics module where Fp is the plastic deformation gradient. I duplicated the CoupledGradient function and all associated functions in Coupleable.C to try read a double variable instead of a string. I left all original functions unchanged and everything compiled nicely. But when I run my input file, I see a symbol lookup error in the heat conduction module as attached. I checked the error with C++filt and it showed \"non-virtual thunk to SideIntegralPostprocessor::getValue()\". I am unable to understand this error. I would appreciate any guidance to solve this problem.\nThanks and regards,\nRitam Chatterjee",
          "url": "https://github.com/idaholab/moose/discussions/18167",
          "updatedAt": "2022-06-29T12:58:15Z",
          "publishedAt": "2021-06-25T05:49:27Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nfirst thing I would try would be to clean and rebuild just in case something did not get updated from before the modifications. So\n\u2018make clobberall\u2019 then \u2018make\u2019\nthen if that doesn\u2019t work, did you make sure to have an implementation for every single routine you added in coupleable.h ? You did not add any pure virtual ones?\nbest\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18167#discussioncomment-918842",
                  "updatedAt": "2022-06-29T12:58:23Z",
                  "publishedAt": "2021-06-25T06:37:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Guillaume,\nThank you for your response. I tried the clobber make method in both tensor mechanics and heat conduction modules but the error persists. I did not add any pure virtual functions in Coupleable.h but I commented out some statements in my new functions that I felt were not critical to the new approach. Only the old, unaltered functions are being called everywhere in different modules. Can i do something with getValue() in SideIntegralPostProcessor.C that would resolve this?\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/18167#discussioncomment-919158",
                          "updatedAt": "2022-11-16T09:37:52Z",
                          "publishedAt": "2021-06-25T08:14:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ritamcj"
                          },
                          "bodyText": "Hi Guillaume,\nI tried clobber make in the combined module and it worked! Many thanks for your suggestion.\nBest regards,\nRitam",
                          "url": "https://github.com/idaholab/moose/discussions/18167#discussioncomment-920241",
                          "updatedAt": "2022-11-16T09:38:13Z",
                          "publishedAt": "2021-06-25T10:52:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "converting abaqus mesh (.inp) to .e",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nHas anyone ever tried to convert .inp to .e via MOOSE?\nI tried to follow the example in test/tests/mesh/abaqus_input\nHowever, the mesh (.e) I obtained doesn't look correct as some elements are missing (attached - paraview)\nNot too sure what is the problem, .inp looks fine when I view it on Cubit/Abaqus\nPlease let me know if you have any idea.\nNote: I also tried to convert .inp to .e using meshio, also doesn't work as well.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/18147",
          "updatedAt": "2022-06-23T20:26:29Z",
          "publishedAt": "2021-06-23T05:37:11Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I have not. Can you convert it via Paraview instead of via MOOSE?\nThere's got to be some format that is common between Paraview and Abaqus, maybe not inp. Maybe .nas from some quick googling",
                  "url": "https://github.com/idaholab/moose/discussions/18147#discussioncomment-908328",
                  "updatedAt": "2022-07-29T07:18:06Z",
                  "publishedAt": "2021-06-23T06:35:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "unfortunately Paraview doesnt read .inp file",
                          "url": "https://github.com/idaholab/moose/discussions/18147#discussioncomment-918633",
                          "updatedAt": "2022-07-29T07:18:06Z",
                          "publishedAt": "2021-06-25T05:06:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is there another format Abaqus can export that paraview can read?",
                          "url": "https://github.com/idaholab/moose/discussions/18147#discussioncomment-918636",
                          "updatedAt": "2022-07-29T07:18:08Z",
                          "publishedAt": "2021-06-25T05:09:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "@GiudGiud I figured out now, so MOOSE doesn't read some of Abaqus format\nfor example\noriginal .inp file has\n*ELSET, ELSET=DRV_Y2026_M03, GENERATE\n 541205, 541208\n 666835, 666839\n 691109, 691112\n\nit should read from element 541205 to 541208, but instead MOOSE only read 2 elements (541205 and 541208).\nI have to reformat .inp to\n*ELSET, ELSET=DRV_Y2026_M03, GENERATE\n 541205, 541208,1\n 666835, 666839,1\n 691109, 691112,1\n\nso now MOOSE read from element 541205 to 541208",
                  "url": "https://github.com/idaholab/moose/discussions/18147#discussioncomment-918640",
                  "updatedAt": "2022-07-29T07:18:08Z",
                  "publishedAt": "2021-06-25T05:11:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Wrong value when time=0 in output file",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Above pictures are parts of my code.\nWhat I expected was \"phi_Ni = -1.03665 in output file\" when time = 0.\nBut when time=0, phi_Ni = 0 was shown.\n\nWhat do I miss at here?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/18165",
          "updatedAt": "2021-06-24T21:18:41Z",
          "publishedAt": "2021-06-24T20:54:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthe postprocessor is not being executed at the 0th timestep.\nYou need to add execute_on = 'INITIAL timestep_end' to your input file for this postprocessor\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18165#discussioncomment-917595",
                  "updatedAt": "2021-06-24T20:58:36Z",
                  "publishedAt": "2021-06-24T20:58:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "Thanks, it works!",
                          "url": "https://github.com/idaholab/moose/discussions/18165#discussioncomment-917670",
                          "updatedAt": "2021-06-24T21:18:31Z",
                          "publishedAt": "2021-06-24T21:18:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Two mesh domain NS Solution",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I have created a NS model that is composed of two separate mesh domains. The flow for one domain (domain-1) is pressure driven between the inlet and the outlet, walls are treated as no-slip boundary conditions. The second mesh domain is contained in the interior of the first and has different material properties. The problem is transient. I would like to implicitly define within the domain-1  the a no-slip boundary condition based on the outer boundary shape on domain-2. The expectation is that I will be able to observe flow around domain-2 in domain-1. I would then like to translate the viscous stress in domain-1 at the implicit boundary of domain-2 as a boundary force condition in domain-2. This is all done within a single application. Can this be accomplished as described and if so how?\nFallingBall.e.txt\nFallingBall.i.txt",
          "url": "https://github.com/idaholab/moose/discussions/17925",
          "updatedAt": "2022-07-27T20:57:13Z",
          "publishedAt": "2021-05-25T19:01:29Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDo you want to be tracking the interface explicitly or use some sort of volume averaging?\nWe laid out an approach in this discussion\n@fdkong this is another fsi-like problem where the solid block is moving around in the fluid. We should make an example of this.\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-805241",
                  "updatedAt": "2022-07-27T20:57:11Z",
                  "publishedAt": "2021-05-31T05:00:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "I would like to track the effects explicitly in each time step iteration. Ball position establishes moving no-slip boundary for the larger fluid domain. The fluid stress at the ball establishes changing ball position.\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-807285",
                          "updatedAt": "2022-07-27T20:57:11Z",
                          "publishedAt": "2021-05-31T14:34:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok this is very similar to the thread I linked to.\nSo same advice, do you have a satisfactory solution without the ball moving?\nAnd you'll need to set up elastic mesh deformation, to adapt the mesh at every time step",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-808514",
                          "updatedAt": "2022-07-27T20:57:11Z",
                          "publishedAt": "2021-05-31T20:21:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Ok this is very similar to the thread I linked to.\nSo same advice, do you have a satisfactory solution without the ball moving?\nAnd you'll need to set up elastic mesh deformation, to adapt the mesh at every time step\n\nYes, I get very good convergence of the flow solution in the channel. The solution is just absent the blockage and no slip velocity condition that I want to provide by the sphere.\nThank you again for your advise and help.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-808578",
                          "updatedAt": "2022-07-27T20:57:11Z",
                          "publishedAt": "2021-05-31T20:48:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "@TLWise Is domain 2 moving? Does domain 2 deform?\nIf so, it seems like an actual FSI example.",
                  "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-811528",
                  "updatedAt": "2022-07-27T20:57:11Z",
                  "publishedAt": "2021-06-01T15:10:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you for your interest. Domain 2 is not intended to deform, but is expected to move due to forces from domain 1 and vise versa domain 1 to respond to position of domain 2. Almost fsi but without ALE (mesh movement).",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-811550",
                          "updatedAt": "2022-12-13T17:36:52Z",
                          "publishedAt": "2021-06-01T15:15:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "How far domain 2 needs to move? The movement is relatively small or large? It will determine what method we could use.\nALE is referred to as how do we define the fluid domain. Even the domain 2 is rigid, ALE still can be used in domain 1 because domain 2 is moving. One issue with the ALE is that we need to remesh domains  if domain 2 is moving too much (i.e., from the inlet to the outlet). Remeshing is not easy in general, especially in parallel.\nAn alternative way might be immersed boundary method where we do not need to remesh and a fixed mesh is used. But we might lose the interpolation accuracy between domain 1 and domain 2.\nWhat equations are you using to define the movement of domain 2 because of the stress from domain 1?  Is it a simple relation?",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-811665",
                          "updatedAt": "2022-12-13T17:36:52Z",
                          "publishedAt": "2021-06-01T15:38:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "The immersed boundary method appears to be the solution that I am looking to implement. Domain 2 is allowed to move to any extent within the boundaries of domain 1, but is to be constrained to not cross out of the boundaries of domain 1.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-811706",
                          "updatedAt": "2022-12-13T17:36:52Z",
                          "publishedAt": "2021-06-01T15:44:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "The only other influence on domain 2 outside fluid stress is gravity force.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-811715",
                          "updatedAt": "2022-12-13T17:36:53Z",
                          "publishedAt": "2021-06-01T15:46:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@fdkong Immersed boundary method is like a VOF method right?\nOk for domain 2 staying in domain 1, but do you want the domain 2 mesh to move, or do you want to just be tracking relative fractions of 2 and 1 in a fixed mesh?",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-818959",
                          "updatedAt": "2022-12-13T17:36:59Z",
                          "publishedAt": "2021-06-03T05:20:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you for your continued advice and support with this. I would like to observe the motion of domain 2 within domain one. I have been able to run the model, but I have not observed the effects of each domain on the flow and position solutions.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-823016",
                          "updatedAt": "2022-09-12T09:58:23Z",
                          "publishedAt": "2021-06-03T19:14:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "In the model that I have made. The particle mesh already exist as a subdomain as well as the fluid subdomain. The fsi formulation that I am basing my model on uses the SubdomainBoundingBoxGenerator which appears to constrain me to portions of a square or rectangular subdomain vise the circle that I am trying to track. Also is it required that I specify a bounding box coordinate in SubdomainBoundingBoxGenerator since the subdomains are already defined?",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-837360",
                          "updatedAt": "2022-09-12T09:58:24Z",
                          "publishedAt": "2021-06-07T23:39:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any progress on this?\nSubdomainBoundingBoxGen might not be the one you need here. You should have the two blocks defined in the mesh before loading it in MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-899275",
                          "updatedAt": "2022-09-12T09:58:25Z",
                          "publishedAt": "2021-06-21T17:42:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you for remaining engaged in assist with the issue. I had some success using the bounding box approach. What I found in using it, is that the effects of the motion of the bounded region on the mesh deforms the mesh similar to two separate mesh domains with one having motion internal to the other. I need to determine how to do at least two things:\n\nDefine a bounding shape (circle, oval, octagon, etc.) other than a rectangle.\nRedefine the bounding shape in the next time step based on the new translation coordinates of the previous time step.",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-899409",
                          "updatedAt": "2022-09-12T09:58:25Z",
                          "publishedAt": "2021-06-21T18:17:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you will have to add a new mesh generator to do 1. If you could make a parsed expression one I think that would be more valuable than just adding circle. Let us know if you need help with that.\n\nmight be tricky. @fdkong do you know how to have the mesh be reset at every time step and mesh generators be ran again?",
                          "url": "https://github.com/idaholab/moose/discussions/17925#discussioncomment-917105",
                          "updatedAt": "2022-12-13T17:37:50Z",
                          "publishedAt": "2021-06-24T18:42:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Demagnetizing Field and Custom Kernel",
          "author": {
            "login": "alanchavez86"
          },
          "bodyText": "Hi all!\nI've asked a similar question before and received a great discussion! I wanted to run by some thoughts I had for solving for the demagnetizing field of FeCrCo.\nIn the last discussion, I was given a couple equations to work with that resembled ones that I've been working with that make the problem easier to work with:\n\nand\n\nI wanted to make sense of this and computed the weak form of the first equation:\n\nSince I'm trying to calculate for psi, how would I go about creating a custom kernel for that? If I have a custom kernel for \u2207\u22c5M, would I combine that with a kernel for \u2207^2 \u03a8? Also, \u2207^2 \u03a8 is very similar to the diffusion kernel in moose, so would it be alright to use that?\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/17899",
          "updatedAt": "2022-06-17T09:16:54Z",
          "publishedAt": "2021-05-20T18:13:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "alanchavez86"
                  },
                  "bodyText": "In this case, M should be the saturation magnetization (M = M(c)). The first source I'm attaching is from Koyama 2004. I'm assuming I can implement a material property that defines M as Ms*m(r).\nKoyama_2004.pdf\nA custom kernel was created for del M and I was wondering how that would be put together with psi in this equation:\n\nHere is the .C file that I created for del M:\n#include \"MagnetizationVector.h\"\n/**\n\nAll MOOSE based object classes you create must be registered using this macro.  The first\nargument is the name of the App you entered in when running the stork.sh script with an \"App\"\nsuffix. If you ran \"stork.sh Example\", then the argument here becomes \"ExampleApp\". The second\nargument is the name of the C++ class you created.\n*/\nregisterMooseObject(\"fecrcoApp\", MagnetizationVector);\n\n/**\n\nThis function defines the valid parameters for\nthis Kernel and their default values\n*/\ntemplate <>\nInputParameters\nvalidParams()\n{\nInputParameters params = validParams();\nparams.addRequiredParam(\"mag x\", \"X direction Vector\");\nreturn params;\n}\n\nMagnetizationVector::MagnetizationVector(const InputParameters & parameters)\n: // You must call the constructor of the base class first\nKernel(parameters),\nm(getParam(\"mag x\"))\n{\n}\nReal\nMagnetizationVector::computeQpResidual()\n{\n//  RealVectorValue m(_mag_x[_qp]);\nreturn - m*_grad_test[_i][_qp];\n}\nI removed _mag_x[_qp], _mag_y[_qp], and _mag_z[_qp] because I was assuming the vector direction wouldn't matter at higher temperatures. Here is the last part of my .h file that I modified for the custom kernel to compile correctly:\nprivate:\n/**\n\nA vector object for storing the velocity.  Convenient for\ncomputing dot products.\n*/\nRealVectorValue m;\n\nIf my del M custom kernel is correct, could I combine that with the Diffusion kernel to satisfy the Poisson Equation I have and how would that be done? Here is another file that I'm referencing for the demagnetizing energy:\nFeng_2017_Peritectic PF Mag.pdf",
                  "url": "https://github.com/idaholab/moose/discussions/17899#discussioncomment-789262",
                  "updatedAt": "2022-06-17T09:17:26Z",
                  "publishedAt": "2021-05-26T22:13:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@mangerij @cticenhour",
                          "url": "https://github.com/idaholab/moose/discussions/17899#discussioncomment-898911",
                          "updatedAt": "2022-06-17T09:18:02Z",
                          "publishedAt": "2021-06-21T16:24:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "Sorry, I didn't see the first post. I was on a bit of a vacation so sorry for the delay here.\nYeah, this should work. You can have two separate Kernels for the two terms in the Poisson equation (just make sure the signs are right!). The surface terms in the equation either drop out or are handled naturally within MOOSE. As for your pseudo code here:\nNote that m*_grad_test[_i][_qp] should be a dot product because _grad_test[_i][_qp] is a vector (gradient of a scalar function). This is where Koyama2004 confuses me because he seems to be concerned with the vector value of the magnetization.\nAlso, the magnetization should depend explicitly on the concentration. What you could do is write an AuxKernel to calculate the magnetization m = m(c(r)) and then call this AuxVariable in your Kernel for grad*m. I am not sure if you need to calculate the off-diagonal terms for dm/dc in the Kernel for grad\"m -  you might :)",
                          "url": "https://github.com/idaholab/moose/discussions/17899#discussioncomment-903137",
                          "updatedAt": "2022-06-17T09:18:02Z",
                          "publishedAt": "2021-06-22T07:58:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alanchavez86"
                          },
                          "bodyText": "Thanks for the advice John! I just posted a different discussion that me and my colleague are looking into to solve for the magnetic potential! We modified the CoefDiffusion Kernel to take a function and solve for phi with good results. Now the question is how can we can add a material property that can act as the function and solve for phi.",
                          "url": "https://github.com/idaholab/moose/discussions/17899#discussioncomment-912429",
                          "updatedAt": "2022-06-17T09:18:16Z",
                          "publishedAt": "2021-06-23T22:28:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}