{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wMi0xN1QxMTozMTozNC0wNjowMM4AOTc8"
    },
    "edges": [
      {
        "node": {
          "title": "Incorporating density-dependent porous flow for freshwater-seawater system",
          "author": {
            "login": "jwheiss"
          },
          "bodyText": "Hi all,\nI would like to incorporate density-dependent flow in PorousFlow to simulate flow in a coastal aquifer where seawater and freshwater mix (1 solute (total salt) affects fluid density). I want to use a simple linear relationship between fluid density and salt concentration: rho_fluid = rho_fresh + (delta_rho/delta_C) * C\nwhere C is the salt mass of the fluid (max of 35 g/kg for seawater) and delta_rho/delta_C = 0.71.\nMy current model is set up as single fluid density coupled to geomechanics. I attempted to use the example 1phase_convection.i model to inform how to do this, but the example model is more complex with multiple phases and I am having difficulty following the contents of the 1phase_convection.i file since it does not contain line by line comments.  The 2phase_convection model at https://mooseframework.inl.gov/modules/porous_flow/lava_lamp.html has been helpful to a degree - I am looking for help to incorporate a simpler density:concentration relationship in a model with one solute. Has anyone modeled density-dependent flow in a saltwater-freshwater system, or have suggestions for how to incorporate it?\nThanks,\nJames",
          "url": "https://github.com/idaholab/moose/discussions/20334",
          "updatedAt": "2022-07-10T18:48:59Z",
          "publishedAt": "2022-02-17T22:56:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "I don't think that there is anything exactly like you want already in PorousFlow, but it wouldn't be too hard to make a new material that calculates the density according to your requirements.\nI have done something similar to this in the past (specifically for density-driven convective mixing) that predates PorousFlow. You can take a look at what I did here https://github.com/cpgr/numbat - from memory the density is computed just like you want.",
                  "url": "https://github.com/idaholab/moose/discussions/20334#discussioncomment-2201787",
                  "updatedAt": "2022-07-10T18:49:03Z",
                  "publishedAt": "2022-02-18T04:08:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jwheiss"
                          },
                          "bodyText": "Hi, thanks for that link. The 2D.i numbat example problem specifies fluid density in the Materials block as\n[./density]\ntype = NumbatDensity\nconcentration = concentration\nzero_density = 995\ndelta_density = 10.5\nsaturated_concentration = 0.049306\n[../]\nIf I create a new Object in MOOSE equivalent to the NumbatDensity Object in numbat, it should do the trick.\nThanks,\nJames",
                          "url": "https://github.com/idaholab/moose/discussions/20334#discussioncomment-2223515",
                          "updatedAt": "2022-10-06T17:09:59Z",
                          "publishedAt": "2022-02-21T19:19:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Let us know if you run into any issues.",
                          "url": "https://github.com/idaholab/moose/discussions/20334#discussioncomment-2225651",
                          "updatedAt": "2023-03-24T10:34:55Z",
                          "publishedAt": "2022-02-22T04:07:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issues running MOOSE on HPC",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Hi,\nI have compiled Petsc and Libmesh with ./update_and_rebuild_libmesh and update_and_rebuildt_petsc with the following modules loaded\ncmake/3.19.3-rhel8\nPython/3.8.1\nGCC/9.3.0\nMPICH/3.2.1\nMOOSE then compiles without issue.\nHowever, when I try to run a simulation, I am greeted with\n[6] ../src/utils/xdr_cxx.C, line 148, compiled Feb 15 2022 at 23:27:32 ERROR: Functionality is not available. Make sure LIBMESH_HAVE_XDR is defined at build time The XDR interface is not available in this installation\nI am on the most recent commit of MOOSE and I have no issues running simulations locally.\nIs anyone familiar with this error?",
          "url": "https://github.com/idaholab/moose/discussions/20316",
          "updatedAt": "2022-06-21T21:12:09Z",
          "publishedAt": "2022-02-16T16:00:08Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you trying to use the restart functionality or is this coming up out of the blue?\nLocally did you install with the conda/mamba build or still with update_and_rebuild_libmesh ?\nThere should be a log of the libmesh install, in the scripts directory iirc, could you please share it?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20316#discussioncomment-2194286",
                  "updatedAt": "2022-06-21T21:12:10Z",
                  "publishedAt": "2022-02-17T07:16:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Hi,\nThank you for your response.\nLocally I installed with mamba build\nlibmesh_diagnostic.log\nI cannot find the full build log, but I did find the configure log.\nIn the script file, it should be outputting a build log in the scripts directory, but for some reason that did not happen",
                          "url": "https://github.com/idaholab/moose/discussions/20316#discussioncomment-2197511",
                          "updatedAt": "2022-06-21T21:12:17Z",
                          "publishedAt": "2022-02-17T15:10:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Ah, but I do have a combination of the petsc and libmesh build log from a build I did the day before. It should be identical except for the fact that this was built with a slightly older version of GCC.\nmake_raccoon.txt",
                          "url": "https://github.com/idaholab/moose/discussions/20316#discussioncomment-2197583",
                          "updatedAt": "2022-06-21T21:12:12Z",
                          "publishedAt": "2022-02-17T15:21:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "LIBMESH_HAVE_XDR\n\nComes from the system not having libtirpc installed. Basically the rpc.h files specifically. This as a reference: https://bugzilla.redhat.com/show_bug.cgi?id=1537432",
                  "url": "https://github.com/idaholab/moose/discussions/20316#discussioncomment-2198480",
                  "updatedAt": "2022-06-21T21:12:17Z",
                  "publishedAt": "2022-02-17T16:59:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/20316#discussioncomment-2198499",
                          "updatedAt": "2022-06-21T21:12:13Z",
                          "publishedAt": "2022-02-17T17:01:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I hope this is the solution! Please let us know either way \ud83d\ude03. We install the following on our build machines:\nlibtirpc libtirpc-devel",
                          "url": "https://github.com/idaholab/moose/discussions/20316#discussioncomment-2198545",
                          "updatedAt": "2022-06-21T21:12:13Z",
                          "publishedAt": "2022-02-17T17:06:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Hi!\nI went ahead and installed the conda/mamba environment on my HPC and that fixed my issue, so I did not apply this solution.\nI'll go ahead and mark it as the answer in case it helps anyone else!\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/20316#discussioncomment-2223661",
                          "updatedAt": "2022-06-21T21:12:13Z",
                          "publishedAt": "2022-02-21T19:48:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "syncing auxvariable and material computation",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nI would need to retrieve the old and current value of an auxvariable (computed at each linear iteration) inside a material. Is there a way to do so?\nThanks a lot,\nMauro",
          "url": "https://github.com/idaholab/moose/discussions/20250",
          "updatedAt": "2022-09-19T04:07:59Z",
          "publishedAt": "2022-02-08T08:31:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ajacquey"
                  },
                  "bodyText": "Hi Mauro,\nDid you try adding execute_on = 'LINEAR' in your AuxKernel block?\nRetrieving the current value and old values of the AuxVariable in the material can then be done in the normal way with coupledValue and coupledValueOld I suppose.\nCheers,\nAntoine",
                  "url": "https://github.com/idaholab/moose/discussions/20250#discussioncomment-2133986",
                  "updatedAt": "2022-09-19T04:08:00Z",
                  "publishedAt": "2022-02-08T14:56:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Thanks @ajacquey (long time not seeing you). Did try to force the computation at linear (see my original post), but to not avail. I ended up by creating a copy of it via a stateful property. Admit it is not the most elegant solution, but it provides with more freedom for my case at least - I can restrict the actual computation to the end of the time step.\nCiao,\nMauo",
                          "url": "https://github.com/idaholab/moose/discussions/20250#discussioncomment-2139630",
                          "updatedAt": "2022-09-19T04:08:00Z",
                          "publishedAt": "2022-02-09T08:27:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@mcacace material properties are indeed computed before auxiliary variables, e.g. code below, so you do have a dependency issue here. If you didn't want to use a stateful material property, you could use a material property for the current value and then an aux variable to get the old values (using MaterialRealAux as the mechanism to create the old aux values from the current material property). But it sounds like you are content with your work-around, which is great!\ntemplate <typename AuxKernelType>\nvoid\nComputeElemAuxVarsThread<AuxKernelType>::onElement(const Elem * elem)\n{\n  if (_aux_kernels.hasActiveBlockObjects(_subdomain, _tid))\n  {\n    const std::vector<std::shared_ptr<AuxKernelType>> & kernels =\n        _aux_kernels.getActiveBlockObjects(_subdomain, _tid);\n    _fe_problem.prepare(elem, _tid);\n    _fe_problem.reinitElem(elem, _tid);\n\n    // Set up the sentinel so that, even if reinitMaterials() throws, we\n    // still remember to swap back.\n    SwapBackSentinel sentinel(_fe_problem, &FEProblem::swapBackMaterials, _tid, _need_materials);\n\n    if (_need_materials)\n      _fe_problem.reinitMaterials(elem->subdomain_id(), _tid);\n\n    for (const auto & aux : kernels)\n      aux->compute();",
                  "url": "https://github.com/idaholab/moose/discussions/20250#discussioncomment-2223528",
                  "updatedAt": "2022-09-19T04:08:00Z",
                  "publishedAt": "2022-02-21T19:22:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Method of Manufactured Solutions (MMS): running example results in error",
          "author": {
            "login": "klean700c"
          },
          "bodyText": "Dear MOOSE community,\nI tried to run the documented example from https://mooseframework.inl.gov/python/mms.html .\n#!/usr/bin/env python3\n\nimport mms\nfs,ss = mms.evaluate('-div(grad(u))', 'sin(2*pi*x)*sin(2*pi*y)')\nmms.print_fparser(fs)\n\nmms.print_hit(fs, 'force')\nmms.print_hit(ss, 'exact')\n\nI ran the program by\n(base) jan@Jan-ThinkPad:~$ mamba activate moose\n(moose) jan@Jan-ThinkPad:~/projects$ python3 mms_exact.py\n\nUnfortunatelly, it returns the following error message\nTraceback (most recent call last):\n  File \"/home/jan/projects/mms_exact.py\", line 11, in <module>\n    import mms\nModuleNotFoundError: No module named 'mms'\n\nI installed sympy before I ran the code.\nCan you explain me how to implement the mms module?\nI\u00b4m a new user to MOOSE and Ubuntu 18.04.5. Perhaps I did some obvious error, that was not that obvious to me. Although, compiling and testing MOOSE went successful.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/20356",
          "updatedAt": "2022-08-23T20:57:15Z",
          "publishedAt": "2022-02-21T15:46:05Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nmms is one of our packages.\nYou just need to tell Python where to look for that module. We by default dont modify your PYTHONPATH\nso\n export PYTHONPATH=$PYTHONPATH:/home/jan/projects/moose/python\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20356#discussioncomment-2222172",
                  "updatedAt": "2022-08-23T20:57:22Z",
                  "publishedAt": "2022-02-21T15:55:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Is it possible to let the conda environment modify PYTHONPATH for us? I've run into this issue several times already.",
                          "url": "https://github.com/idaholab/moose/discussions/20356#discussioncomment-2223049",
                          "updatedAt": "2022-08-23T20:57:22Z",
                          "publishedAt": "2022-02-21T17:52:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it's certainly possible if we know where people installed moose.\n@milljm what do you think?",
                          "url": "https://github.com/idaholab/moose/discussions/20356#discussioncomment-2223079",
                          "updatedAt": "2023-02-27T19:33:12Z",
                          "publishedAt": "2022-02-21T17:57:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Difficulty setting non-trivial PenaltyDirichletBC with constant monomial",
          "author": {
            "login": "helen-brooks"
          },
          "bodyText": "I seem to be having trouble using ADPenaltyDirichletBC and PenaltyDirichletBC with a constant monomial variable. In an essentially trivial setup (diffusion on 10x10 2D generated mesh), as soon as I set the value of the boundary condition to be anything other than identically zero I get the following error:\n\nlinear solve did not converge due to DIVERGED_PC_FAILED iterations 0\nPC failed due to FACTOR_NUMERIC_ZEROPIVOT\n\nI've played around with both AD and non-AD versions, with various values of the penalty and the value of the BC to no avail. I have definitely managed to get something  like this working in the past, so I wonder if something has changed?\nPlease find my minimal example here:\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  xmin = -1\n  xmax = 1\n  ymin = -1\n  ymax = 1\n  nx = 10\n  ny = 10\n[]\n\n[Variables]\n  [./u]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[Kernels]\n  [./diff]\n    type = ADDiffusion\n    variable = u\n  [../]\n[]\n\n[BCs]\n  [./bc-top]\n    type = ADPenaltyDirichletBC\n    variable = u\n    value = 0\n    boundary = 'top'\n    penalty = 1e5\n  [../]\n  [./bc-bot]\n    type = ADPenaltyDirichletBC\n    variable = u\n    value = 1\n    boundary = 'bottom'\n    penalty = 1e5\n  [../]\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = 'NEWTON'\n[]\n\n[Outputs]\n  execute_on = 'timestep_end'\n  exodus = true\n  csv = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/20355",
          "updatedAt": "2022-06-16T00:15:29Z",
          "publishedAt": "2022-02-21T14:11:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe preconditioner is dying, probably there is a zero pivot / saddle point?\n@lindsayad I dont remember how we investigate that one?\nFor a problem that simple, it's likely the numerical problem is ill-posed. I think it has to do with the CONSTANT MONOMIAL variable type not having the required derivatives for the ADDiffusion kernel. This kernel does an integration by part to compute the laplacian with a first order derivative. You would need information from the neighbors to compute a first derivative, the local shape function (flat) has a 0 derivative.\nThis preconditioner manages to get an answer but the answer seems wrong though. We expect a linear slope from bottom to top right? So this points to the problem I mentioned with the variable type.\n[Executioner]\n  type = Steady\n  solve_type = 'NEWTON'\n  petsc_options_iname = ' -pc_type -pc_factor_shift_type '\n  petsc_options_value = ' lu NONZERO '\n[]\n\nCould you please try with another variable type? Is there any reason you want to be using constant monomials?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20355#discussioncomment-2222437",
                  "updatedAt": "2022-06-16T00:15:31Z",
                  "publishedAt": "2022-02-21T16:32:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "helen-brooks"
                          },
                          "bodyText": "This wasn't for a specific physics problem - I was trying to make a minimal but non-trivial  example using constant monomials. Ironically, this was actually to exemplify to others some of the different element types available in MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/20355#discussioncomment-2222922",
                          "updatedAt": "2022-06-16T00:15:32Z",
                          "publishedAt": "2022-02-21T17:32:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "If you are using a discontinuous basis, then you must use discontinuous Galerkin kernels. As @GiudGiud implied, this problem is indeed very singular as setup. If you run with -pc_type svd -pc_svd_monitor on the command line, 80 of the 100 degrees of freedom are singular. The 20 that are not actually correspond to the degrees of freedom touched by your penalty conditions. It is the internal degrees of freedom that are singular because _grad_test is 0 because the basis is constant within the element, so no matter what your solution is on the interior, the residuals will be 0.\nYou can look in moose/test/tests/dgkernels for some examples of using DGKernels if you wish to continue using a discontinuous basis",
                  "url": "https://github.com/idaholab/moose/discussions/20355#discussioncomment-2222759",
                  "updatedAt": "2022-06-16T00:15:32Z",
                  "publishedAt": "2022-02-21T17:10:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "helen-brooks"
                          },
                          "bodyText": "OK, thanks. I don't think I had appreciated the need to use DGKernels. Now that I come to think of it, I've only used const monomials in aux variables.",
                          "url": "https://github.com/idaholab/moose/discussions/20355#discussioncomment-2222977",
                          "updatedAt": "2022-06-16T00:16:30Z",
                          "publishedAt": "2022-02-21T17:41:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "3D symmetry to full 3D solution",
          "author": {
            "login": "am-tc01"
          },
          "bodyText": "Hi,\nI am trying to convert a 3D symmetric solution to full 3D, read it in a sub-app and Transfer a variable to a main app.\nMy first idea was to simply transform the symmetric solution by changing z coordinate to -z coordinate, so that I get a mirrored version of the original solution, read them both using FileMeshGenerator and stitch them using StitchedMeshGenerator. This didn't work since mirroring probably distorted node order and I got an error of \"Negative Jacobian\". Although not sure if that is the reason, but got this error even though I am not solving for anything in the sub-app.\nAnother way could be that I use/modify MultiAppProjectionTransfer to mirror the mesh and project the data onto the new mesh, but I am not completely sure how to do it or if that is the best solution. Any clue?\nRegards.",
          "url": "https://github.com/idaholab/moose/discussions/20209",
          "updatedAt": "2022-07-13T18:43:31Z",
          "publishedAt": "2022-02-02T14:28:24Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think you are on the right track but I think the restart from exodus will be difficult. Like I dont know that we support restarting from two different exodus files.\nI would create two multiapps, flip one, restart both from exodus (or checkpoint), then do the transfers, each on their respective part of the full 3 D domain.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20209#discussioncomment-2096875",
                  "updatedAt": "2022-07-13T18:43:31Z",
                  "publishedAt": "2022-02-02T15:41:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "am-tc01"
                          },
                          "bodyText": "Hi @GiudGiud\nThanks! Yes I think that sounds more feasible.\nI could also create a full mesh using VTK (I simply flipped the original solution and grouped the data) but when I read it in Moose, I again got the error of Negative Jacobian. The question now is how to flip the solution and what exactly is causing this error?\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/20209#discussioncomment-2098465",
                          "updatedAt": "2022-07-13T18:43:35Z",
                          "publishedAt": "2022-02-02T17:04:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Flip the elements by using a rotation.\nThe negative jacobian is probably because the element ended up with a negative volume with the transform you applied.",
                          "url": "https://github.com/idaholab/moose/discussions/20209#discussioncomment-2098809",
                          "updatedAt": "2022-07-13T18:43:47Z",
                          "publishedAt": "2022-02-02T18:00:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "am-tc01"
                          },
                          "bodyText": "Flip the elements by using a rotation.\nHow can I flip 3D geometry by using rotation? I tried TransformGenerator with Scale = '1 1 -1', but that resulted in the same error.",
                          "url": "https://github.com/idaholab/moose/discussions/20209#discussioncomment-2099483",
                          "updatedAt": "2022-07-13T18:43:47Z",
                          "publishedAt": "2022-02-02T20:11:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Try ROTATE then TRANSLATE",
                          "url": "https://github.com/idaholab/moose/discussions/20209#discussioncomment-2099493",
                          "updatedAt": "2022-07-13T18:44:00Z",
                          "publishedAt": "2022-02-02T20:12:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "am-tc01"
                          },
                          "bodyText": "Thanks! Have tried it already and that doesn't work.\nAttached is the geometry I am trying to flip along XY plane.\ntest1.zip",
                          "url": "https://github.com/idaholab/moose/discussions/20209#discussioncomment-2099583",
                          "updatedAt": "2022-07-13T18:44:00Z",
                          "publishedAt": "2022-02-02T20:25:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nI just had a look and this seemed to stitch the meshes correctly (for 1/4 -> 1/2 of the geometry, might not have done the XY plane precisely)\n[Mesh]\n  [fmg_left]\n    type = FileMeshGenerator\n    file = test1.e\n  []\n  [fmg_right]\n    type = FileMeshGenerator\n    file = test1.e\n  []\n  [rotate]\n    type = TransformGenerator\n    input = 'fmg_right'\n    transform = 'ROTATE'\n    vector_value = '0 -90 0'\n  []\n  [translate]\n    type = TransformGenerator\n    input = 'rotate'\n    transform = 'TRANSLATE'\n    vector_value = '0 -0.001 0.001'\n  []\n  [smg]\n    type = StitchedMeshGenerator\n    inputs = 'fmg_left translate'\n    clear_stitched_boundary_ids = true\n    stitch_boundaries_pairs = 'bottom front'\n    parallel_type = 'replicated'\n  []\n[]\n\nPlease let us know if that ends up working for your case\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/20209#discussioncomment-2126670",
                          "updatedAt": "2022-07-13T18:44:02Z",
                          "publishedAt": "2022-02-07T16:12:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "am-tc01"
                          },
                          "bodyText": "Hi @GiudGiud\nThanks for having a look at it! So what you did now actually rotated the mesh, it didn't truly flip it (look at the temp data closely). I don't think one can flip the mesh by rotating+translating it. You have to change z = -z in order to flip it.\nAnyhow, I have flipped the mesh now and fixed the error with negative Jacobian :) So now I have two files, original and flipped. The problem now is how to read a variable from both these files. I can either stitch them together and restart, but I guess Moose doesn't support that. Another way, like you said earlier, is to restart from two apps (one with original and other with flipped) and then do the transfer, each on their respective part on full 3D domain. Is that possible? I tried it but then one Transfer overwrites the other Transfer such that I have the variable data only from one Transfer. How can I combine the two? Thanks!\nI am attaching the flipped mesh\ntest1_flipped.zip\n.",
                          "url": "https://github.com/idaholab/moose/discussions/20209#discussioncomment-2133206",
                          "updatedAt": "2022-07-13T18:44:37Z",
                          "publishedAt": "2022-02-08T13:13:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Well yes that is true. But dont you have an additional degree of symmetry in there? As in the system is 1/8th symmetry as far as I can see.\nIf that is true, then even without flipping you can leverage that to reconstruct the full solution from the 1/4.\nWe dont have block restricted transfers yet. But you can create two additional (one additional would work actually, but let s do two for simplicity) additional auxiliary variables. Those will be block restricted to each symmetric part of the domain. You will first transfer the fields onto these, then use a ParsedAux or a SelfAux to copy the info from these variables onto the unified one.",
                          "url": "https://github.com/idaholab/moose/discussions/20209#discussioncomment-2134087",
                          "updatedAt": "2022-07-13T18:44:33Z",
                          "publishedAt": "2022-02-08T15:15:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ah really zooming in, it's not 1/8th symmetric.",
                          "url": "https://github.com/idaholab/moose/discussions/20209#discussioncomment-2134140",
                          "updatedAt": "2022-07-13T18:45:00Z",
                          "publishedAt": "2022-02-08T15:22:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "am-tc01"
                          },
                          "bodyText": "We dont have block restricted transfers yet. But you can create two additional (one additional would work actually, but let s do two for simplicity) additional auxiliary variables. Those will be block restricted to each symmetric part of the domain. You will first transfer the fields onto these, then use a ParsedAux or a SelfAux to copy the info from these variables onto the unified one.\n\nThanks for the tip! Yes something like that should work, but if I have two variables that are block restricted (one from each symmetric part), can I combine them using ParsedAux onto a unified variable (which is defined in both blocks)?",
                          "url": "https://github.com/idaholab/moose/discussions/20209#discussioncomment-2180699",
                          "updatedAt": "2022-07-13T18:45:00Z",
                          "publishedAt": "2022-02-15T12:44:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Possible to build pointy grid surrounded by a pointy hexagon via `Reactor` meshing?",
          "author": {
            "login": "veeshy"
          },
          "bodyText": "I want the outer hexagon to have sides parallel to the inner hexagons, is that possible now or should I open a feature request?\n\n[Mesh]\n  [foo]\n    type = HexagonConcentricCircleAdaptiveBoundaryMeshGenerator\n    num_sectors_per_side = '4 4 4 4 4 4'\n    background_intervals = 2\n    hexagon_size = 2\n    is_control_drum = false\n    ring_radii = '1'\n    ring_intervals = '3'\n  []\n\n  [layout]\n    type = PatternedHexMeshGenerator\n    inputs = 'foo'\n    pattern = '   0 0;\n                 0 0 0;\n                  0 0'\n    hexagon_size = 8\n  []\n[]\n\n[Problem]\n  solve = false\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/20338",
          "updatedAt": "2022-07-12T18:28:46Z",
          "publishedAt": "2022-02-18T00:07:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you please try the pattern_boundary=hexagon option?\nIt s documented here:\nhttps://mooseframework.inl.gov/source/meshgenerators/PatternedHexMeshGenerator.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20338#discussioncomment-2201535",
                  "updatedAt": "2022-07-12T18:29:01Z",
                  "publishedAt": "2022-02-18T02:57:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "veeshy"
                          },
                          "bodyText": "That\u2019s the default so that\u2019s what\u2019s shown already. I also tried the rotate input which rotates the whole mesh and not just the background hex (granted the doc does say it\u2019s for the whole mesh)",
                          "url": "https://github.com/idaholab/moose/discussions/20338#discussioncomment-2201876",
                          "updatedAt": "2022-07-12T18:29:01Z",
                          "publishedAt": "2022-02-18T04:36:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok i understand better what you want now.\nYou could try rotating foo, but doubt that s supported.",
                          "url": "https://github.com/idaholab/moose/discussions/20338#discussioncomment-2202055",
                          "updatedAt": "2022-07-12T18:29:00Z",
                          "publishedAt": "2022-02-18T05:34:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I remember the code to build the outer boundary to be fairly flexible, so if it lets you build the pattern with a rotated unit cell you should be ok for building the boundary",
                          "url": "https://github.com/idaholab/moose/discussions/20338#discussioncomment-2202060",
                          "updatedAt": "2022-07-12T18:29:01Z",
                          "publishedAt": "2022-02-18T05:35:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "veeshy"
                  },
                  "bodyText": "Skimming https://www.osti.gov/biblio/1821454 I don\u2019t think I see any flat hex grid surrounded by a flat hex either",
                  "url": "https://github.com/idaholab/moose/discussions/20338#discussioncomment-2201878",
                  "updatedAt": "2022-07-12T18:29:04Z",
                  "publishedAt": "2022-02-18T04:36:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Contact Question",
          "author": {
            "login": "ats5662"
          },
          "bodyText": "Is there an option in moose to define general contact or self contact? I am looking to run a simulation similar to the picture below. Thanks!",
          "url": "https://github.com/idaholab/moose/discussions/20340",
          "updatedAt": "2022-10-13T18:12:23Z",
          "publishedAt": "2022-02-18T03:25:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Unfortunately, MOOSE does not support self contact at this moment.",
                  "url": "https://github.com/idaholab/moose/discussions/20340#discussioncomment-2201675",
                  "updatedAt": "2022-10-13T18:12:23Z",
                  "publishedAt": "2022-02-18T03:34:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about returnMapping functionality",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "I have a question about the returnMappingSolve class.\nI have a set of residual calculations that will return undefined values when a negative value is introduced by the return mapping solve. Obviously, this breaks the solver and leads to the simulation failing.\nIs there any way to prevent the return mapping from suggesting negative values while not harming the convergence of the return mapping?",
          "url": "https://github.com/idaholab/moose/discussions/20297",
          "updatedAt": "2023-07-10T17:36:53Z",
          "publishedAt": "2022-02-14T20:57:01Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@jiangwen84 @hugary1995 any of you know about this particular system? Or knows who knows?",
                  "url": "https://github.com/idaholab/moose/discussions/20297#discussioncomment-2183584",
                  "updatedAt": "2023-07-10T17:36:53Z",
                  "publishedAt": "2022-02-15T19:47:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I discussed with @TheGreatCid offline about this. I'm posting here what we discovered in case this is helpful for anyone in the future:\nIn his case, the yield surface is undefined with negative plastic strain rates. The best way to handle this is to let the return mapping algorithm respect the lower bound of zero. There are several ways to achieve this, e.g. line search, trust region, bisection methods, etc. The SingleVariableReturnMappingSolution class in moose offers an interface to provide lower and upper bounds. He simply needs to set _check_range = true; in the constructor and override the method minimumPermissibleValue:\nvirtual Real minimumPermissibleValue(const Real &) const override { return 0; }\nThen the return mapping will make sure values passed into the computeResidual and computeDerivative methods always respect the lower bound.",
                          "url": "https://github.com/idaholab/moose/discussions/20297#discussioncomment-2198909",
                          "updatedAt": "2023-07-10T17:36:53Z",
                          "publishedAt": "2022-02-17T17:45:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@dschwen is working on adding line search to the return mapping. I believe he also mentioned about setting bounds.",
                          "url": "https://github.com/idaholab/moose/discussions/20297#discussioncomment-2199423",
                          "updatedAt": "2023-07-10T17:36:53Z",
                          "publishedAt": "2022-02-17T19:00:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "More accurate stresses and strain are needed for the calculation not just for visualization",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi\nI have an optimization problem where the gradient is computed as the integral (adjoint_strains x stresses). The stresses and adjoint_strains   are computed through two separate input files. the actual integration required for the gradient computation is carried out in a 3rd separate input file (it is just for post-processing, no need for any solves/factorization). The problem involves point forces (which causes some high stresses concentrations), and since the optimization requires accurate gradient computation, I needed to compute the stresses and strain more accurately (something other than CONSTANT , MONOMIAL). I have tried FIRST MONOMIAL, and I could get better stresses and strains visuals. However, when I upload these stresses and strain into the 3rd input file designated for post-processing, I am getting a segmentation fault (core dumped) message. That 3rd input file (responsible for post-processing) is posted below:\nAny thoughts on how best to compute the gradient of that form? and since this input is only for post-processing, Do I have other computationally cheaper ways to write this input?\n[Mesh]\n        type = GeneratedMesh\n        dim = 2\n        xmin=0\n        xmax=1\n        ymin=0\n        ymax=1\n        nx =100\n        ny=100\n        # displacements = 'uxr uyr uxi uyi'\n[]\n[Variables]\n    [dummy2] #dummy variable, we will not do any solve here, just multiplication, integration, and subtraction.\n    []\n    [dummy3] #dummy variable, we will not do any solve here, just multiplication, integration, and subtraction.\n    []\n[]\n\n[AuxVariables]\n\n    [dummy] #the variable that needed for ComputeVariableIsotropicElasticityTensor \n    []\n    #adjoint solution auxvariables\n    #real stress aux variables\n    [stress_real_xx]\n        order = FIRST\n        family = MONOMIAL\n    []\n    [stress_real_yy]\n        order = FIRST\n        family = MONOMIAL\n    []\n[]\n\n[Kernels]\n    [urealx]\n        type = StressDivergenceTensors\n        variable = dummy2\n        displacements='dummy2 dummy3'\n        component = 0\n        base_name = real\n        #volumetric_locking_correction=True\n    []\n    [urealy]\n        type = StressDivergenceTensors\n        variable = dummy3\n        displacements='dummy2 dummy3'\n        component = 1\n        base_name = real\n        #volumetric_locking_correction=True\n    []\n[]\n\n[AuxKernels]\n    [load_strain_real_xx]#used to reload the adjoint solution from old exudos file resulted from the adjoint solves\n        type = SolutionAux\n        solution = sln_strain_real_xx\n        variable = strain_real_xx\n        direct = true\n    []\n    [load_strain_real_yy]#used to reload the adjoint solution from old exudos file resulted from the adjoint solves\n        type = SolutionAux\n        solution = sln_strain_real_yy\n        variable = strain_real_yy\n        direct = true\n    []\n[]\n\n[UserObjects]\n\n    #load stresses from the forward solve\n    [sln_stress_real_xx]\n      type = SolutionUserObject\n      mesh = '_forward_elastic_waves/forwardsolve.e'\n      system_variables = stress_real_xx\n    []\n    [sln_stress_real_yy]\n      type = SolutionUserObject\n      mesh = '_forward_elastic_waves/forwardsolve.e'\n      system_variables = stress_real_yy\n    []                               \n[]\n\n[Outputs]\n    [exodus]\n        file_base = 'grad_computation_elastic_waves/grad_'\n        type = Exodus\n        execute_on = final\n    []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/19656",
          "updatedAt": "2022-08-18T12:43:57Z",
          "publishedAt": "2021-12-16T22:01:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere's a lot going on here. Could you please remove what's not needed and update the post? You can just set solve=false in the [Problem] to not do a solve, no need for dummy variables.\nWhere is the seg fault happening exactly? Could you please wrap this in a debugger and get us a back trace?\nIf there is a problem with a high variable order that is not supported by some auxkernel or transfer, then recompiling in devel mode (METHOD=devel make) is very likely to catch this.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19656#discussioncomment-2084096",
                  "updatedAt": "2022-08-18T12:44:07Z",
                  "publishedAt": "2022-01-31T19:22:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "@aaelmeli  did you find the problem?  Where did it segfault, is it when it tries to read the data in with the userObject or when you compute one of the auxkernels?  Is the data being read in first monomial data?",
                          "url": "https://github.com/idaholab/moose/discussions/19656#discussioncomment-2184865",
                          "updatedAt": "2022-08-18T12:44:07Z",
                          "publishedAt": "2022-02-16T00:17:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "Hi @lynnmunday\nObviously, I missed @GiudGiud reply, really sorry for that.\nSo the following is the output when running on the devel mode.\nAssertion `sys_elem.n_dofs(sys_num, var_num) > 0' failed\nVariable strain_real_xx has no DoFs on element 0\nat /home/aaelmeli/projects/moose/framework/src/userobject/SolutionUserObject.C, line 404\nStack frames: 30\n0: libMesh::print_trace(std::ostream&)\n1: SolutionUserObject::directValue(libMesh::Elem const*, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const\n2: SolutionAux::computeValue()\n3: AuxKernelTempl<double>::compute()\n4: ComputeElemAuxVarsThread<AuxKernelTempl<double> >::onElement(libMesh::Elem const*)\n5: ThreadedElementLoopBase<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> >::operator()(libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> const&, bool)\n6: void AuxiliarySystem::computeElementalVarsHelper<AuxKernelTempl<double> >(MooseObjectWarehouse<AuxKernelTempl<double> > const&, std::vector<std::vector<MooseVariableFieldBase*, std::allocator<MooseVariableFieldBase*> >, std::allocator<std::vector<MooseVariableFieldBase*, std::allocator<MooseVariableFieldBase*> > > > const&)\n7: AuxiliarySystem::computeElementalVars(MooseEnumItem)\n8: AuxiliarySystem::compute(MooseEnumItem)\n9: FEProblemBase::computeResidualTags(std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n10: FEProblemBase::computeResidualInternal(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n11: FEProblemBase::computeResidualSys(libMesh::NonlinearImplicitSystem&, libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&)\n12: ComputeResidualFunctor::residual(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, libMesh::NonlinearImplicitSystem&)\n13: libmesh_petsc_snes_residual\n14: SNESComputeFunction\n15: /home/aaelmeli/miniconda3/envs/moose/lib/libpetsc.so.3.15(+0xd22bdb) [0x7f0650782bdb]\n16: SNESSolve\n17: libMesh::PetscNonlinearSolver<double>::solve(libMesh::SparseMatrix<double>&, libMesh::NumericVector<double>&, libMesh::NumericVector<double>&, double, unsigned int)\n18: libMesh::NonlinearImplicitSystem::solve()\n19: NonlinearSystem::solve()\n20: FEProblemBase::solve()\n21: FEProblemSolve::solve()\n22: FixedPointSolve::solveStep(double&, double&, std::set<unsigned long, std::less<unsigned long>, std::allocator<unsigned long> > const&)\n23: FixedPointSolve::solve()\n24: Steady::execute()\n25: MooseApp::executeExecutioner()\n26: MooseApp::run()\n27: ./first_test-devel(+0x3153) [0x7f065760b153]\n28: __libc_start_main\n29: ./first_test-devel(+0x33dd) [0x7f065760b3dd]\n[0] /home/aaelmeli/projects/moose/framework/src/userobject/SolutionUserObject.C, line 404, compiled Feb 15 2022 at 21:17:02\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure: Bad file descriptor\n\nSo, I think the error happened when loading the data from the exodus file through the solutionuserobject. In fact, when playing around this, I found this link, where in notes, it is written that exodus does not support higher-order elemental variables \"more than CONSTANT MONOMIAL\".",
                          "url": "https://github.com/idaholab/moose/discussions/19656#discussioncomment-2185504",
                          "updatedAt": "2022-08-18T12:44:07Z",
                          "publishedAt": "2022-02-16T03:08:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "I don't know if this would work but maybe you can oversample your output mesh (test/tests/outputs/oversample/over_sampling_test_gen.i) and then read it in on a finer mesh with constant monomial onto a finer mesh.  Maybe the solutionFunction can be used to interpolate the oversampled output mesh onto higher order element variable. I don't see any tests for this.\nAnother option would be to output your element variables as nodal variables using the nodalPatchRecovery and then do you calculations on nodal variables in the above file.",
                          "url": "https://github.com/idaholab/moose/discussions/19656#discussioncomment-2198804",
                          "updatedAt": "2022-08-18T12:45:40Z",
                          "publishedAt": "2022-02-17T17:31:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}