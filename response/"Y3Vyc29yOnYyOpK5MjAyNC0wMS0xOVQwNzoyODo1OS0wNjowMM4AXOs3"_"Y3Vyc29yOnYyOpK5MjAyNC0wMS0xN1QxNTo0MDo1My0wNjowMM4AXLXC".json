{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wMS0xN1QxNTo0MDo1My0wNjowMM4AXLXC"
    },
    "edges": [
      {
        "node": {
          "title": "Boundary ghost UO of two-phase flow",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nI noticed that the THM has ADBoundaryFlux3EqnGhostVelocityTemperature to calculate ghost variables of single-phase flow. In this file, if it is inlet flow, we use the input temperature. Otherwise, we use the interior temperature value. I wonder if it is two-phase flow (six-equation model), what does it should be? Calculating liquid ghost variables (p, ul, Tl) according to liquid velocity and calculating vapor ghost variables (alpha, ug, Tg) according to vapor velocity? Here is my code:\n  params.addRequiredParam<Real>(\"alpha\", \"Specified void fraction\");\n  params.addRequiredParam<Real>(\"velocity_liq\", \"Specified liquid velocity\");\n  params.addRequiredParam<Real>(\"velocity_vap\", \"Specified vapour velocity\");\n  params.addRequiredParam<Real>(\"temperature_liq\", \"Specified liquid temperature\");\n  params.addRequiredParam<Real>(\"temperature_vap\", \"Specified vapour temperature\");\n\n    _alpha_ghost(getParam<Real>(\"alpha\")),\n    _velocity_liq_ghost(getParam<Real>(\"velocity_liq\")),\n    _velocity_vap_ghost(getParam<Real>(\"velocity_vap\")),\n    _temperature_liq_ghost(getParam<Real>(\"temperature_liq\")),\n    _temperature_vap_ghost(getParam<Real>(\"temperature_vap\")),\n\n\n  if (!_reversible || THM::isInlet(_velocity_liq_ghost, _normal))  \n  {\n    // Pressure is the only quantity coming from the interior\n    W_ghost[THM::PRIM_VAR_PRESSURE] = p_interior;\n    W_ghost[THM::PRIM_VAR_VEL_LIQ] = _velocity_liq_ghost;\n    W_ghost[THM::PRIM_VAR_TEMP_LIQ] = _temperature_liq_ghost;\n  }\n  else  \n  {\n    // Pressure is the only quantity coming from the interior\n    W_ghost[THM::PRIM_VAR_PRESSURE] = p_interior;\n    W_ghost[THM::PRIM_VAR_VEL_LIQ] = _velocity_liq_ghost;\n    W_ghost[THM::PRIM_VAR_TEMP_LIQ] = temp_liq_interior;\n  }\n\n  // vapour phase\n  if (!_reversible || THM::isInlet(_velocity_vap_ghost, _normal))  \n  {\n    W_ghost[THM::PRIM_VAR_VOID_FRACTION] = _alpha_ghost;\n    W_ghost[THM::PRIM_VAR_VEL_VAP] = _velocity_vap_ghost;\n    W_ghost[THM::PRIM_VAR_TEMP_VAP] = _temperature_vap_ghost;\n  }\n  else \n  {\n    W_ghost[THM::PRIM_VAR_VOID_FRACTION] = _alpha_ghost;\n    W_ghost[THM::PRIM_VAR_VEL_VAP] = _velocity_vap_ghost;\n    W_ghost[THM::PRIM_VAR_TEMP_VAP] = temp_vap_interior;\n  }\n\nIs there anything wrong? I'm not sure.",
          "url": "https://github.com/idaholab/moose/discussions/26502",
          "updatedAt": "2024-01-19T04:49:05Z",
          "publishedAt": "2024-01-08T09:09:06Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "SomnusYu"
                  },
                  "bodyText": "@joshuahansel Could you please help me?",
                  "url": "https://github.com/idaholab/moose/discussions/26502#discussioncomment-8168933",
                  "updatedAt": "2024-01-18T12:54:32Z",
                  "publishedAt": "2024-01-18T12:54:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "In RELAP-7 (7-equation model), for checking reversibility, we check the sign of arhouA_liquid + arhouA_vapor, not individually by phase as you've done. However, what you're doing might be ok too. I don't really know. The situation is a bit more complicated than both of these approximations because there are a lot of waves involved. The objective should just be to supply what you know about the ghost state for your situation and have the Riemann solver figure out the appropriate information to use based on its knowledge of the characteristics.",
                  "url": "https://github.com/idaholab/moose/discussions/26502#discussioncomment-8170912",
                  "updatedAt": "2024-01-18T15:42:02Z",
                  "publishedAt": "2024-01-18T15:42:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Thanks a lot! By the way, do you have any reference to deal with this situation :\n\ncheck the sign of arhouA_liquid + arhouA_vapor",
                          "url": "https://github.com/idaholab/moose/discussions/26502#discussioncomment-8177146",
                          "updatedAt": "2024-01-19T05:13:27Z",
                          "publishedAt": "2024-01-19T04:49:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Test fail on rocky Linux 9 HPC cluster",
          "author": {
            "login": "AmbroiseJuston"
          },
          "bodyText": "Hello, i am a student building and testing moose on a HPC cluster running Rocky-9. I have installed moose onto a machine running a wsl on ubuntu before however following the same steps i seem to get 17 failed test (see below).\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test FAILED (ERRMSG)\nfvkernels/mms/skewness-correction/adv-diff-react.average ...................................... FAILED (CRASH)\nfvkernels/mms/skewness-correction/diffusion.average ........................................... FAILED (CRASH)\nmortar/periodic-value.exo .................................................................... FAILED (ERRMSG)\nfvkernels/mms/skewness-correction/adv-diff-react.skewcorrected ................................ FAILED (CRASH)\nmeshgenerators/file_mesh_generator.checkpoint_load_test ...................................... FAILED (ERRMSG)\nmeshgenerators/gmsh.gmsh_test ................................................................ FAILED (ERRMSG)\nmeshgenerators/gmsh_bcs.gmsh_bc_test ......................................................... FAILED (ERRMSG)\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/polycrystal_test . FAILED (ERRMSG)\nfvkernels/mms/skewness-correction/diffusion.skewcorrected ..................................... FAILED (CRASH)\nmisc/ad_curvature.circle_tri6 ................................................................ FAILED (ERRMSG)\nmortar/periodic-value.jac ................................................. FAILED (EXPECTED OUTPUT NOT FOUND)\nrestart/receiver.restart ..................................................................... FAILED (ERRMSG)\nfvkernels/mms/skewness-correction/adv-diff-react.skewcorrected-advection ...................... FAILED (CRASH)\nfvkernels/mms/skewness-correction/two_term_extrapol.skewcorrected ............................. FAILED (CRASH)\nrestart/restart_steady_from_transient.steady_from_transient_restart .......................... FAILED (ERRMSG)\nmeshgenerators/file_mesh_generator.checkpoint_old_prefix .................... FAILED (EXPECTED OUTPUT MISSING)\n--------------------------------------------------------------------------------------------------------------\nRan 4139 tests in 127.6 seconds. Average test time 0.5 seconds, maximum test time 15.7 seconds.\n4122 passed, 94 skipped, 0 pending, 17 FAILED\n\nAny advice on what could be causing it or how to solve it would be appreiciated.\nI did notice another user seemed to have problems with their mpich version and i double checked the provided solution. We currently have 4.1.1, would this be a noticeable difference in version that would cause these failure?",
          "url": "https://github.com/idaholab/moose/discussions/26570",
          "updatedAt": "2024-01-18T19:50:43Z",
          "publishedAt": "2024-01-16T21:06:41Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "We need the more important information above these results in order to figure out why things actually failed.\nThe follow details the information we actually need:\nhttps://mooseframework.inl.gov/help/troubleshooting.html#5e08e4ea-9123-4f2b-b148-f783ab616a5f",
                  "url": "https://github.com/idaholab/moose/discussions/26570#discussioncomment-8149308",
                  "updatedAt": "2024-01-16T21:14:41Z",
                  "publishedAt": "2024-01-16T21:13:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AmbroiseJuston"
                          },
                          "bodyText": "here is the full report for meshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test for example:\n./run_tests -i meshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test \n\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: Working Directory: /home/justona-erau.edu/projects/moose/test/tests/meshgenerators/break_mesh_by_block_generator\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: Running command: /home/justona-erau.edu/projects/moose/test/moose_test-opt -i break_mesh_3D_polycrystal.i --mesh-only --error --error-override --no-gdb-backtrace\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: hwloc/linux: Ignoring PCI device with non-16bit domain.\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: Pass --enable-32bits-pci-domain to configure to support such devices\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: (warning: it would break the library ABI, don't enable unless really needed).\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: Exodus Library Warning/Error: [ex__check_file_type]\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \tERROR: Could not recognize /home/justona-erau.edu/projects/moose/test/tests/meshgenerators/break_mesh_by_block_generator/poly2.msh as a valid Exodus/NetCDF file variant.  Magic value is '$Mes'\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: Exodus Library Warning/Error: [ex_open_int]\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \tERROR: failed to open /home/justona-erau.edu/projects/moose/test/tests/meshgenerators/break_mesh_by_block_generator/poly2.msh of type 0 for reading. Either the file does not exist,\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \tor there is a permission or file format issue.\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \tNetCDF: Unknown file format\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: *** ERROR ***\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: Error opening ExodusII mesh file: /home/justona-erau.edu/projects/moose/test/tests/meshgenerators/break_mesh_by_block_generator/poly2.msh\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: Stack frames: 17\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 0: libMesh::print_trace(std::ostream&)\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 1: libMesh::MacroFunctions::report_error(char const*, int, char const*, char const*, std::ostream&)\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 2: libMesh::ExodusII_IO_Helper::open(char const*, bool)\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 3: libMesh::ExodusII_IO::read(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 4: FileMeshGenerator::generate()\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 5: MeshGenerator::generateInternal()\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 6: MeshGeneratorSystem::executeMeshGenerators()\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 7: Action::timedAct()\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 8: ActionWarehouse::executeActionsWithAction(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 9: ActionWarehouse::executeAllActions()\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 10: MooseApp::runInputFile()\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 11: MooseApp::run()\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 12: /home/justona-erau.edu/projects/moose/test/moose_test-opt(+0x20eb) [0x55729ad610eb]\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 13: main\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 14: /lib64/libc.so.6(+0x3feb0) [0x7f58fa43feb0]\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 15: __libc_start_main\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 16: /home/justona-erau.edu/projects/moose/test/moose_test-opt(+0x2396) [0x55729ad61396]\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: [0] ../src/mesh/exodusII_io_helper.C, line 683, compiled Nov 30 2023 at 16:46:29\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: Stack frames: 9\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 0: libMesh::print_trace(std::ostream&)\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 2: void mooseError<char const*>(char const*&&)\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 3: /home/justona-erau.edu/projects/moose/framework/libmoose-opt.so.0(+0x9e80bd) [0x7f59037e80bd]\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 4: /home/justona-erau.edu/projects/moose/test/moose_test-opt(+0x20eb) [0x55729ad610eb]\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 5: main\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 6: /lib64/libc.so.6(+0x3feb0) [0x7f58fa43feb0]\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 7: __libc_start_main\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: 8: /home/justona-erau.edu/projects/moose/test/moose_test-opt(+0x2396) [0x55729ad61396]\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: application called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: [unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: :\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: system msg for write_line failure : Bad file descriptor\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: ################################################################################\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: Tester failed, reason: ERRMSG\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test: \nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test FAILED (ERRMSG)\n\n\nFinal Test Results:\n--------------------------------------------------------------------------------------------------------------\nmeshgenerators/break_mesh_by_block_generator.break_mesh_by_blocks_generator/3d_polycrystal_test FAILED (ERRMSG)\n\nLet me know if this format is acceptable.",
                          "url": "https://github.com/idaholab/moose/discussions/26570#discussioncomment-8149393",
                          "updatedAt": "2024-01-16T21:30:20Z",
                          "publishedAt": "2024-01-16T21:25:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "@roystgnr Any ideas?\nIt could be MPICH 4.1.1. I know I have had issues with versions greater than 4.0.3 lately. But I don't recall the specific error message.",
                          "url": "https://github.com/idaholab/moose/discussions/26570#discussioncomment-8149453",
                          "updatedAt": "2024-01-16T21:34:57Z",
                          "publishedAt": "2024-01-16T21:34:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This test in particular I dont know.\nThe MMS tests in the list definitely point to MPI, they tend to be run with MPI",
                          "url": "https://github.com/idaholab/moose/discussions/26570#discussioncomment-8149544",
                          "updatedAt": "2024-01-16T21:45:51Z",
                          "publishedAt": "2024-01-16T21:45:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "@AmbroiseJuston Can you paste a few more details from the other tests?",
                          "url": "https://github.com/idaholab/moose/discussions/26570#discussioncomment-8149585",
                          "updatedAt": "2024-01-16T21:52:04Z",
                          "publishedAt": "2024-01-16T21:52:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "The poly2.msh failure looks as if we somehow instructed an ExodusII_IO object to open a non-ExodusII (looks like GMSH?) mesh.\nBut the way we decide to use ExodusII_IO is a really simple search through ...\nOh, no.\nYou're in a directory named justona-erau.edu.  Our stupidly simple search sees \".e\" (and doesn't see \".ele\") and it concludes you've got an Exodus file.\nWe need to fix that.  We can't only count files that end with \".e\", because lots of users end up with files that have timestep numbers or such appended past that, but we can at least make sure that there aren't any directory separator characters in the file name after the \"suffix\".\nIn the meantime ... does your cluster give you a /tmp or /scratch or some other such directory you can use where you can create subdirectories without \".e\" in them?  You wouldn't even have to create a real subdirectory, just a symlink back to your home directory, if that's necessary for reasons of speed or backup policy or whatever.",
                          "url": "https://github.com/idaholab/moose/discussions/26570#discussioncomment-8150029",
                          "updatedAt": "2024-01-16T22:48:45Z",
                          "publishedAt": "2024-01-16T22:48:44Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ah good catch.\nAnd now that you mention it, those mms tests use a .msh file for the mesh. Because that s how we generated the skewed meshes.\n@AmbroiseJuston please rename the folder as Roy says, and we ll fix the problem in libmesh when we can.",
                          "url": "https://github.com/idaholab/moose/discussions/26570#discussioncomment-8151226",
                          "updatedAt": "2024-01-17T02:13:57Z",
                          "publishedAt": "2024-01-17T02:13:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AmbroiseJuston"
                          },
                          "bodyText": "Thank you very much @GiudGiud @roystgnr @milljm for the help, i'll try to do that and see if it fixes the other error too. I'll keep you guys updated if it returns anything more unusual that i can't fix myself.\n@milljm here is other information from the second failed test like you asked:\nRan 1 tests in 3.1 seconds. Average test time 0.2 seconds, maximum test time 0.2 seconds.\n(moose) [justona@lprc-b72-112-fem test]$ ./run_tests --re=fvkernels/mms/skewness-correction/adv-diff-react.average\nfvkernels/mms/skewness-correction/adv-diff-react.average: Working Directory: /home/justona-erau.edu/projects/moose/test/tests/fvkernels/mms/skewness-correction/adv-diff-react\nfvkernels/mms/skewness-correction/adv-diff-react.average: Running command: python3 -m unittest -v test.TestAverageStencil\nfvkernels/mms/skewness-correction/adv-diff-react.average: Running: /home/justona-erau.edu/projects/moose/test/moose_test-opt -i skewed.i Variables/v/face_interp_method=average Mesh/uniform_refine=0\nfvkernels/mms/skewness-correction/adv-diff-react.average: test (test.TestAverageStencil) ... hwloc/linux: Ignoring PCI device with non-16bit domain.\nfvkernels/mms/skewness-correction/adv-diff-react.average: Pass --enable-32bits-pci-domain to configure to support such devices\nfvkernels/mms/skewness-correction/adv-diff-react.average: (warning: it would break the library ABI, don't enable unless really needed).\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average: Exodus Library Warning/Error: [ex__check_file_type]\nfvkernels/mms/skewness-correction/adv-diff-react.average: \tERROR: Could not recognize /home/justona-erau.edu/projects/moose/test/tests/fvkernels/mms/skewness-correction/adv-diff-react/skewed.msh as a valid Exodus/NetCDF file variant.  Magic value is '$Mes'\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average: Exodus Library Warning/Error: [ex_open_int]\nfvkernels/mms/skewness-correction/adv-diff-react.average: \tERROR: failed to open /home/justona-erau.edu/projects/moose/test/tests/fvkernels/mms/skewness-correction/adv-diff-react/skewed.msh of type 0 for reading. Either the file does not exist,\nfvkernels/mms/skewness-correction/adv-diff-react.average: \tor there is a permission or file format issue.\nfvkernels/mms/skewness-correction/adv-diff-react.average: \tNetCDF: Unknown file format\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average: *** ERROR ***\nfvkernels/mms/skewness-correction/adv-diff-react.average: Error opening ExodusII mesh file: /home/justona-erau.edu/projects/moose/test/tests/fvkernels/mms/skewness-correction/adv-diff-react/skewed.msh\nfvkernels/mms/skewness-correction/adv-diff-react.average: Stack frames: 17\nfvkernels/mms/skewness-correction/adv-diff-react.average: 0: libMesh::print_trace(std::ostream&)\nfvkernels/mms/skewness-correction/adv-diff-react.average: 1: libMesh::MacroFunctions::report_error(char const*, int, char const*, char const*, std::ostream&)\nfvkernels/mms/skewness-correction/adv-diff-react.average: 2: libMesh::ExodusII_IO_Helper::open(char const*, bool)\nfvkernels/mms/skewness-correction/adv-diff-react.average: 3: libMesh::ExodusII_IO::read(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&)\nfvkernels/mms/skewness-correction/adv-diff-react.average: 4: FileMeshGenerator::generate()\nfvkernels/mms/skewness-correction/adv-diff-react.average: 5: MeshGenerator::generateInternal()\nfvkernels/mms/skewness-correction/adv-diff-react.average: 6: MeshGeneratorSystem::executeMeshGenerators()\nfvkernels/mms/skewness-correction/adv-diff-react.average: 7: Action::timedAct()\nfvkernels/mms/skewness-correction/adv-diff-react.average: 8: ActionWarehouse::executeActionsWithAction(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&)\nfvkernels/mms/skewness-correction/adv-diff-react.average: 9: ActionWarehouse::executeAllActions()\nfvkernels/mms/skewness-correction/adv-diff-react.average: 10: MooseApp::runInputFile()\nfvkernels/mms/skewness-correction/adv-diff-react.average: 11: MooseApp::run()\nfvkernels/mms/skewness-correction/adv-diff-react.average: 12: /home/justona-erau.edu/projects/moose/test/moose_test-opt(+0x20eb) [0x5648131290eb]\nfvkernels/mms/skewness-correction/adv-diff-react.average: 13: main\nfvkernels/mms/skewness-correction/adv-diff-react.average: 14: /lib64/libc.so.6(+0x3feb0) [0x7ffb8703feb0]\nfvkernels/mms/skewness-correction/adv-diff-react.average: 15: __libc_start_main\nfvkernels/mms/skewness-correction/adv-diff-react.average: 16: /home/justona-erau.edu/projects/moose/test/moose_test-opt(+0x2396) [0x564813129396]\nfvkernels/mms/skewness-correction/adv-diff-react.average: [0] ../src/mesh/exodusII_io_helper.C, line 683, compiled Nov 30 2023 at 16:46:29\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average: Stack frames: 9\nfvkernels/mms/skewness-correction/adv-diff-react.average: 0: libMesh::print_trace(std::ostream&)\nfvkernels/mms/skewness-correction/adv-diff-react.average: 1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >)\nfvkernels/mms/skewness-correction/adv-diff-react.average: 2: void mooseError<char const*>(char const*&&)\nfvkernels/mms/skewness-correction/adv-diff-react.average: 3: /home/justona-erau.edu/projects/moose/framework/libmoose-opt.so.0(+0x9e80bd) [0x7ffb901e80bd]\nfvkernels/mms/skewness-correction/adv-diff-react.average: 4: /home/justona-erau.edu/projects/moose/test/moose_test-opt(+0x20eb) [0x5648131290eb]\nfvkernels/mms/skewness-correction/adv-diff-react.average: 5: main\nfvkernels/mms/skewness-correction/adv-diff-react.average: 6: /lib64/libc.so.6(+0x3feb0) [0x7ffb8703feb0]\nfvkernels/mms/skewness-correction/adv-diff-react.average: 7: __libc_start_main\nfvkernels/mms/skewness-correction/adv-diff-react.average: 8: /home/justona-erau.edu/projects/moose/test/moose_test-opt(+0x2396) [0x564813129396]\nfvkernels/mms/skewness-correction/adv-diff-react.average: application called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\nfvkernels/mms/skewness-correction/adv-diff-react.average: [unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\nfvkernels/mms/skewness-correction/adv-diff-react.average: :\nfvkernels/mms/skewness-correction/adv-diff-react.average: system msg for write_line failure : Bad file descriptor\nfvkernels/mms/skewness-correction/adv-diff-react.average: ERROR\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average: ======================================================================\nfvkernels/mms/skewness-correction/adv-diff-react.average: ERROR: test (test.TestAverageStencil)\nfvkernels/mms/skewness-correction/adv-diff-react.average: ----------------------------------------------------------------------\nfvkernels/mms/skewness-correction/adv-diff-react.average: Traceback (most recent call last):\nfvkernels/mms/skewness-correction/adv-diff-react.average:   File \"/home/justona-erau.edu/projects/moose/test/tests/fvkernels/mms/skewness-correction/adv-diff-react/test.py\", line 7, in test\nfvkernels/mms/skewness-correction/adv-diff-react.average:     df1 = mms.run_spatial('skewed.i', 5, 'Variables/v/face_interp_method=average')\nfvkernels/mms/skewness-correction/adv-diff-react.average:   File \"/home/justona-erau.edu/projects/moose/python/mms/runner.py\", line 133, in run_spatial\nfvkernels/mms/skewness-correction/adv-diff-react.average:     return _runner(*args, rtype=SPATIAL, **kwargs)\nfvkernels/mms/skewness-correction/adv-diff-react.average:   File \"/home/justona-erau.edu/projects/moose/python/mms/runner.py\", line 106, in _runner\nfvkernels/mms/skewness-correction/adv-diff-react.average:     raise IOError(\"The CSV output does not exist: {}\".format(csv))\nfvkernels/mms/skewness-correction/adv-diff-react.average: OSError: The CSV output does not exist: None\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average: ----------------------------------------------------------------------\nfvkernels/mms/skewness-correction/adv-diff-react.average: Ran 1 test in 0.155s\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average: FAILED (errors=1)\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average: Exit Code: 1\nfvkernels/mms/skewness-correction/adv-diff-react.average: ################################################################################\nfvkernels/mms/skewness-correction/adv-diff-react.average: Tester failed, reason: CRASH\nfvkernels/mms/skewness-correction/adv-diff-react.average:\nfvkernels/mms/skewness-correction/adv-diff-react.average ...................................... FAILED (CRASH)\nFinal Test Results:\nfvkernels/mms/skewness-correction/adv-diff-react.average ...................................... FAILED (CRASH)\nRan 1 tests in 4.1 seconds. Average test time 1.0 seconds, maximum test time 1.0 seconds.\n0 passed, 0 skipped, 0 pending, 1 FAILED",
                          "url": "https://github.com/idaholab/moose/discussions/26570#discussioncomment-8172543",
                          "updatedAt": "2024-01-18T17:56:36Z",
                          "publishedAt": "2024-01-18T17:56:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@milljm here is other information from the second failed test like you asked:\n\nsecond test shows the same failure.\nThe failure is in the mesh reader in libmesh.\nThe only thing you can do is rename your folder to not include .e in the name anywhere",
                          "url": "https://github.com/idaholab/moose/discussions/26570#discussioncomment-8173110",
                          "updatedAt": "2024-01-18T18:53:27Z",
                          "publishedAt": "2024-01-18T18:53:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AmbroiseJuston"
                          },
                          "bodyText": "I worked it out and renamed the folder and the tests now all pass. It indeed simply was that it had .e somewhere.",
                          "url": "https://github.com/idaholab/moose/discussions/26570#discussioncomment-8173570",
                          "updatedAt": "2024-01-18T19:50:35Z",
                          "publishedAt": "2024-01-18T19:50:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "variable gradient (_grad_u[_qp]) along one direction",
          "author": {
            "login": "Bearunner"
          },
          "bodyText": "Dear all,\nWe use _grad_u[_qp] to represent the gradient of a variable along all directions in a 3D model.\nHow could we use variable gradient along one direction, e.g., x direction in the kernel?\nThanks.\nB",
          "url": "https://github.com/idaholab/moose/discussions/26587",
          "updatedAt": "2024-01-18T16:07:24Z",
          "publishedAt": "2024-01-18T15:25:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou would index into the vector (_grad_u[_qp]) to retrieve one component\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26587#discussioncomment-8170843",
                  "updatedAt": "2024-01-18T15:36:27Z",
                  "publishedAt": "2024-01-18T15:36:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "like _grad_u[_qp][0]?",
                          "url": "https://github.com/idaholab/moose/discussions/26587#discussioncomment-8170866",
                          "updatedAt": "2024-01-18T15:40:09Z",
                          "publishedAt": "2024-01-18T15:38:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "if (u-T1)/dx is the gradient along the x direction and T1 is a coupled value from other input, how can we write it in kernels?",
                          "url": "https://github.com/idaholab/moose/discussions/26587#discussioncomment-8170955",
                          "updatedAt": "2024-01-18T15:46:13Z",
                          "publishedAt": "2024-01-18T15:46:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "From other input? What does you mean?\n_grad_u[_qp](_component);\n\nnot []",
                          "url": "https://github.com/idaholab/moose/discussions/26587#discussioncomment-8171035",
                          "updatedAt": "2024-01-18T15:52:44Z",
                          "publishedAt": "2024-01-18T15:52:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "Thanks for your answer.\nlambda*\u2207((u-Tres.)/dx).\nwhere Tres. is a coupled value temperature from the reservoir.",
                          "url": "https://github.com/idaholab/moose/discussions/26587#discussioncomment-8171106",
                          "updatedAt": "2024-01-18T21:41:14Z",
                          "publishedAt": "2024-01-18T15:59:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "\u2207((u-Tres.)/dx). ?\ndo you mean\ndiv (\u2207((u-Tres.) )\nin continuous form ?\nor do you mean that you are trying to do some 1D finite differencing?\n(\u2207u- \u2207Tres)  / dx",
                          "url": "https://github.com/idaholab/moose/discussions/26587#discussioncomment-8171205",
                          "updatedAt": "2024-01-18T16:07:25Z",
                          "publishedAt": "2024-01-18T16:07:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Regarding elastic_strain and plastic_strain",
          "author": {
            "login": "RavisCPP"
          },
          "bodyText": "Hi everyone, I am trying to use \"FiniteStrainUOBasedCP\" for one of my problems, and I am able to get outputs for all the stress and strain components. But as soon as I try to get the plastic_strain_zz, effective_plastic_strain and elastic_strain_zz for my analysis, it throws an error:\n\"The following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\nMaterial property 'plastic_strain', requested by 'plastic_strain_zz_all' is not defined on block 0\nMaterial property 'plastic_strain', requested by 'plastic_strain_zz_all_face' is not defined on block 0\nMaterial property 'plastic_strain', requested by 'plastic_strain_zz_all_neighbor' is not defined on block 0\"\nI am also attaching my input files, in this, as per TensorMechanicsMaster syntax, I added elastic_strain_zz and plastic_strain_zz in the generate_output option. If I do not add these two, other outputs are getting generated normally!\ninput_slip_sys.txt\neuler_ang_file.txt\nsave_euler_1.i.txt",
          "url": "https://github.com/idaholab/moose/discussions/26573",
          "updatedAt": "2024-01-18T12:52:33Z",
          "publishedAt": "2024-01-17T11:29:44Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you use the Debug/show material prop parameter to check the names of the material properties?\nOnce you have done that, it s likely you cannot access that material property with the suffix for the components.\nYou need to use some sort of auxkernel that will use the regular name of the material (RankTwoAux is an example) and ask you for the components you want to output\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26573#discussioncomment-8156101",
                  "updatedAt": "2024-01-17T12:24:01Z",
                  "publishedAt": "2024-01-17T12:24:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "RavisCPP"
                  },
                  "bodyText": "Hi, I tried the debugging \"show_material_props = true\" and it gave me a list of all the available material properties. It had the plastic_strain_zz too. Again, same error\nMaterial property 'plastic_strain', requested by 'plastic_strain' is not defined on block 0\nMaterial property 'plastic_strain', requested by 'plastic_strain_zz_all' is not defined on block 0\nSo, as per my understanding, just to ckech, I also tried to take output of elastic strain as:\ngenerate_output = 'stress_xx stress_yy stress_zz stress_xy stress_yz stress_xz strain_xx strain_yy strain_zz strain_xy strain_yz strain_xz elastic_strain_zz'\nSo, it didn't throw any error but the value of elastic strain was 0 everywhere. I think maybe this is happening because plastic_strain is not defined or developed for \"FiniteStrainUObasedCP\" and same for elastic_strain, but since it was defined at some base class, so, it doesn't throw the error.\nsave_euler_2.i.txt\nI have also tried implementing elastic_strain and plastic_strain in UOBasedCP, but I have doubts if that is correct or not:\nelastic_strain:\nvoid\nFiniteStrainUOBasedCP::calcResidual()\n{\n//RankTwoTensor iden(RankTwoTensor::initIdentity), ce, ee, ce_pk2, eqv_slip_incr, pk2_new;\nRankTwoTensor iden(RankTwoTensor::initIdentity), ce, ce_pk2, eqv_slip_incr, pk2_new;\ngetSlipRates();\nif (_err_tol)\nreturn;\nfor (unsigned int i = 0; i < _num_uo_slip_rates; ++i)\n{\nfor (unsigned int j = 0; j < _uo_slip_rates[i]->variableSize(); ++j)\n{\neqv_slip_incr += (_flow_direction[i])[_qp][j] * (_mat_prop_slip_rates[i])[_qp][j] * _dt;\n}\n}\neqv_slip_incr = iden - eqv_slip_incr;\n_fp_inv = _fp_old_inv * eqv_slip_incr;\n_fe = _dfgrd_tmp * _fp_inv;\nce = _fe.transpose() * _fe;\n_elastic_str[_qp] = ce - iden;\n_elastic_str[_qp]*= 0.5;\n//pk2_new = _elasticity_tensor[_qp] * ee;\npk2_new = _elasticity_tensor[_qp] * _elastic_str[_qp];\n_resid = _pk2[_qp] - pk2_new;\n}\nSo, it had elastic_strain defined as ee in local variable, I defined a global variable and defined the elastic_strain like that.\nFor plastic_strain, I did this:\n_pl_str = _pl_str_old;\nfor (unsigned int i = 0; i < _num_uo_slip_rates; ++i)\n{\nfor (unsigned int j = 0; j < _uo_slip_rates[i]->variableSize(); ++j)\n{\nplastic_vel_grad = plastic_vel_grad + (_flow_direction[i])[_qp][j] * (_mat_prop_slip_rates[i])[_qp][j] * _dt;\n}\n}\nplastic_stretching = 0.5 * (plastic_vel_grad + plastic_vel_grad.transpose());\nfor (unsigned int i = 0; i < _num_uo_slip_rates; ++i)\n{\nfor (unsigned int j = 0; j < _uo_slip_rates[i]->variableSize(); ++j)\n{\nflow_dir = (_flow_direction[i])[_qp][j];\nflow_dir_t = flow_dir.transpose();\nflow_dir_symm = 0.5 * (flow_dir + flow_dir_t);\nplastic_strain_crystal_increment = plastic_strain_crystal_increment + ((_mat_prop_slip_rates[i])[_qp][j] * flow_dir_symm) * _dt;\n}\n}\n_pl_str = _pl_str + plastic_strain_crystal_increment;\nAs per my understanding. Is the implementation correct? Or if there is any other way to get plastic strain, it will be really helpful. I am new to moose, but hope to work more towards its development.",
                  "url": "https://github.com/idaholab/moose/discussions/26573#discussioncomment-8168548",
                  "updatedAt": "2024-01-18T12:13:48Z",
                  "publishedAt": "2024-01-18T12:13:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@recuero",
                          "url": "https://github.com/idaholab/moose/discussions/26573#discussioncomment-8168913",
                          "updatedAt": "2024-01-18T12:52:34Z",
                          "publishedAt": "2024-01-18T12:52:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Initial condition for nodal variable on inter-block interface",
          "author": {
            "login": "Wendy-Ji"
          },
          "bodyText": "Hello,\nIn the ICs System section, I saw that nodal variables could be defined on the interface between two blocks. I was wondering whether this worked for changing the mesh.\nI have been using SolutionUserObject and SolutionFunction to read in the final timestep from an existing exodus file to use as an initial condition for a different input file with a different mesh. If I remove blocks from my mesh for the second input file, the variables are read correctly, but if I add blocks to the mesh, I get this error:\n*** ERROR ***\nThe following error occurred in the object \"prev_uo\", of type \"SolutionUserObject\".\n\nFailed to access the data for variable 'dummy' at point (x,y,z)=( 1.04226,     -0.5,      0.5) in the 'prev_uo' SolutionUserObject\n\nThis point seems to be near to the boundary where the block is added. I'm not sure how to set this up correctly to prevent the error. I'm currently using block restrictions on the initial conditions to use the exodus file for the existing block, and to set an initial condition for the added block (see below input files).\nAlso, I've realised this setup does work for elemental variables, so I think I've done something wrong for the nodal variables.\nThank you.\n[Problem]\n  kernel_coverage_check = false \n[]\n\n[Mesh]\n  [load_mesh] \n    type = FileMeshGenerator \n    file = 'block_1_only.e' \n  []\n[]\n\n[Variables] \n  [dummy]\n    family = LAGRANGE\n    order = FIRST\n    initial_condition = 1.0\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  end_time = 2\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n[Problem]\n  kernel_coverage_check = false \n[]\n\n[Mesh]\n  [load_mesh] \n    type = FileMeshGenerator \n    file = 'block_1_2.e' \n  []\n[]\n\n[Variables] \n  [dummy]\n    family = LAGRANGE\n    order = FIRST\n  []\n[]\n\n[ICs]\n  [prev_dummy]\n    type = FunctionIC\n    variable = 'dummy'\n    function = 'prev_func'\n    block = 'block_1'\n  []\n  [init_dummy]\n    type = ConstantIC\n    variable = 'dummy'\n    value = 2\n    block = 'block_2'\n  []\n[]\n\n[Functions]\n  [prev_func]\n    type = SolutionFunction\n    from_variable = 'dummy'\n    solution = 'prev_uo'\n  []\n[]\n\n[UserObjects]\n  [prev_uo]\n    type = SolutionUserObject\n    mesh = 'block_1_init_out.e'\n    timestep = 'LATEST'\n    system_variables = 'dummy'\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  end_time = 2\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/26572",
          "updatedAt": "2024-01-18T05:37:04Z",
          "publishedAt": "2024-01-17T00:15:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe solution user object attempts to read the variable at the desired initial condition locations (depends on the variable type).\nProbably when the blocks are not added, the search ends near a valid value. When the blocks are added, the search ends outside of the valid values in the solution file.\nCan you please make sure all the region it tries to initialize from are within the solution mesh? Maybe block restrict the initial condition to make sure it sits within the solution file mesh extent\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26572#discussioncomment-8151218",
                  "updatedAt": "2024-01-17T02:12:22Z",
                  "publishedAt": "2024-01-17T02:12:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Wendy-Ji"
                          },
                          "bodyText": "Hello,\nIn my input file (in the original post), I have block restricted the initial conditions to 'block_1' and 'block_2', which are the only blocks in the new mesh (block 2 was added, block 1 was the original). The error refers to a point which would lie in block 2. Is there something I have restricted incorrectly? Thank you.\nWendy",
                          "url": "https://github.com/idaholab/moose/discussions/26572#discussioncomment-8151257",
                          "updatedAt": "2024-01-17T02:19:14Z",
                          "publishedAt": "2024-01-17T02:19:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So how is it going to m ow the values in block 2 from the solution file if it was added only in the new mesh?",
                          "url": "https://github.com/idaholab/moose/discussions/26572#discussioncomment-8151585",
                          "updatedAt": "2024-01-17T03:11:02Z",
                          "publishedAt": "2024-01-17T03:11:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wendy-Ji"
                          },
                          "bodyText": "Hello,\nI have separated my initial condition into two sections using block restrictions. One is for the original block 1, which would have values from the solution file, and the other is for the added block 2, which does not have values in the solution file and is instead set to a constant value of 2. I thought this would set the added block to an initial value of 2, but it looks like it's still trying to read it from the solution file, which then gives the error. This did work for elemental variables, so I'm not sure if it has something to do with the nodal variable specifically.\nWendy",
                          "url": "https://github.com/idaholab/moose/discussions/26572#discussioncomment-8151758",
                          "updatedAt": "2024-01-17T03:37:39Z",
                          "publishedAt": "2024-01-17T03:37:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I ll take a look at the end of the week.\nThis doesn't look normal indeed.\nIf you want to keep working with this for now, I would try with a SolutionAux executed on initial instead of a solutionIC.\nIf that does work, I would load the solution in a mesh with a single block in a multiapp. Then transfer the solution from this block in the multiapp to the relevant block in main solve, the one that has both blocks",
                          "url": "https://github.com/idaholab/moose/discussions/26572#discussioncomment-8151910",
                          "updatedAt": "2024-01-17T04:07:40Z",
                          "publishedAt": "2024-01-17T04:07:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wendy-Ji"
                          },
                          "bodyText": "Hello,\nThe SolutionAux executed on initial works, although the variable is now an auxvariable. I'm not sure if that would have any differences to solving it as a variable.\nI'm also not sure I understand the multiapp method you talked about. Is the main app the one with the added block, and the subapp the original mesh? Would the transfer then be something like MultiAppNearestNodeTransfer, and the main app executes after the subapp completes?\nWendy",
                          "url": "https://github.com/idaholab/moose/discussions/26572#discussioncomment-8152386",
                          "updatedAt": "2024-01-17T05:42:33Z",
                          "publishedAt": "2024-01-17T05:42:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ah you are right. SolutionAux only works on auxvariables\nAnd if you plan to solve for that variable, it must be a nonlinear variable not an aux variable\nMultiapp is the way to go for now.\nCreate a simulation which only intializes the variable in one block.\nThen nest that simulation in your main simulation using a FullSolveMultiapp executed on initial.\nThen use the transfers to move the fields from the multiapp to the nonlinear variable",
                          "url": "https://github.com/idaholab/moose/discussions/26572#discussioncomment-8156073",
                          "updatedAt": "2024-01-17T12:21:04Z",
                          "publishedAt": "2024-01-17T12:21:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wendy-Ji"
                          },
                          "bodyText": "Hello,\nThe multiapp setup works for me. I ended up using the MultiAppGeneralFieldNearestLocationTransfer, and the 'from_blocks' and 'to_blocks' parameters to restrict the initial condition to the right block. Thank you for the workaround.\nWendy",
                          "url": "https://github.com/idaholab/moose/discussions/26572#discussioncomment-8165017",
                          "updatedAt": "2024-01-18T05:37:04Z",
                          "publishedAt": "2024-01-18T05:37:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A grain growth problem when only set high GB energy at GB based on `GBAnisotropy`",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nRecently, I used the phase field model by Nele Moelans and created class GBsAnisotropyGG based on GBAnisotropy, with the aim of assigning high grain boundary energy 0.9 at grain boundaries and low grain boundary energy 0.5 inside the grains. This is to prepare for the next step of creating polycrystalline simulations that take into account the anisotropy of grain boundary energy due to misorientation between grains. However, by creating three bicrystal simulations, some problems were found, mainly in the morphology and dynamics of the grain boundary of the circular grain.\nMy question is, from the phase field model modification point of view, is it correct to modify only the grain boundary energy tensor at the grain boundaries? Or perhaps it is a matter of numerical solution of the finite element method. Specifically, the derivative terms within the grains or in the bulk region are involved in the numerical solution of the entire domain and exert an influence on the evolution of the interface.\nIn terms of specific code implementation, I created three bicrystal simulations, Case I with a grain boundary energy of 0.5 for the entire domain, including the grain boundaries and grain interiors, Case II with a grain boundary energy tensor of GBAnisotropy as shown below, and Case III with a grain boundary energy tensor of GBAnisotropy as shown below. And for Case III, it should be noted that the grain boundary energy is only assigned to 0.90 at the grain boundary and 0.50 elsewhere, which can be indirectly derived from the $\\kappa$ cloud below.  For detailed code, input files and results, please see the web page.\n\nMeanwhile, for the understanding of Nele Moelans' multi-order parameter phase field model, I think that the evolution of grain boundary is only related to the grain boundary energy and grain boundary mobility at the grain boundary, so it is reasonable to modify the grain boundary energy at the grain boundary only to reproduce the results of Case II perfectly.\nHowever, the evolution of the output circular grain's area with time shows that the Case III curve is very jittery and close to the Case I curve. My expectation is that the kinetics of Case III and Case II are in perfect agreement. In addition, the shape of the grain boundary of the circular grain in Case III is also very rough and not smooth, which is caused by the numerical inhomogeneity.\n\nAfter that, the key code for the class GBsAnisotropyGG used in Case III is as follows.\n  // get the grain boundary location based on the grainTracker\n  const auto & op_to_grains = _grain_tracker.getVarToFeatureVector(_current_elem->id());\n\n  std::vector<unsigned int> orderParameterIndex;\n\n  for (MooseIndex(op_to_grains) op_index = 0; op_index < op_to_grains.size(); ++op_index)\n  {\n    auto grain_id = op_to_grains[op_index]; // grain id\n\n    if (grain_id == FeatureFloodCount::invalid_id)\n      continue;\n\n    orderParameterIndex.push_back(op_index);\n  }\n\n  // if the quadrature point is located at the grain boundary, then set the grain boundary energy to 0.9\n  if (orderParameterIndex.size() > 1)\n    {\n      for (unsigned int i = 0; i < _op_num -1; ++i)\n        for (unsigned int j = i+1; j < _op_num; ++j)\n          {\n            _sigma[i][j] = 0.9;\n            _sigma[j][i] = _sigma[i][j];\n          }\n    }\nIn general, I try to give the inside of the circular grain low grain boundary energy and the grain boundary region high grain boundary energy. This operation is intended to achieve the same simulation results in terms of grain boundary evolution and kinetic when both at the grain boundary and within the grain have high grain boundary energy. The issue now is that I'm unsure if the appeal's inaccuracy was brought on by changing the phase field model or by a mistake in the numerical solution.\nAny suggestions or recommendations to fix these problems would be greatly appreciated.\nThanks\nwei peng",
          "url": "https://github.com/idaholab/moose/discussions/22254",
          "updatedAt": "2024-01-18T03:46:07Z",
          "publishedAt": "2022-09-28T15:36:18Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen @permcody",
                  "url": "https://github.com/idaholab/moose/discussions/22254#discussioncomment-3781916",
                  "updatedAt": "2022-10-02T15:11:41Z",
                  "publishedAt": "2022-10-02T15:11:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "In theory you could modify the grain boundary energy only at the GB itself, however from a practical standpoint I would not recommend this. In the grain interior where only one order parameter has its equilibrium value of 1 and all other order parameters are 0, there is no driving force for any change to any of the order parameters in the Allen-Cahn equations, so in theory you could set the material parameters to whatever you like and the order parameter still won't chance. However, the problem is, how do you define exactly where you transition from the grain boundary to grain interior happens? It looks like you are relying on the GrainTracker, but the problem is there is some numerical threshold you need to be above to go from a single grain to a GB region. The position where that happens is difficult to pinpoint exactly and dependent on solver tolerance among other factors. I think that is why you are seeing the interface not be circular. It is also often problematic to have large discontinuities in material properties such as you are introducing. So, I would not recommend to make the GB energy different away from GBs.",
                  "url": "https://github.com/idaholab/moose/discussions/22254#discussioncomment-3791268",
                  "updatedAt": "2022-10-03T22:33:54Z",
                  "publishedAt": "2022-10-03T22:33:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you @laagesen for your reply. Base on your advice, I summarize it as two points,\n\nBased on GrainTracker, and the tolerance of the solver and other factors, it is difficult to define where the transitions occure within the grain boundies and grains\nlarge discontinuities in material properties, perhaps casusing problems such as numerical instability, I guess.\n\nand I'm not sure if I understand it correctly.",
                          "url": "https://github.com/idaholab/moose/discussions/22254#discussioncomment-3791752",
                          "updatedAt": "2022-10-04T00:55:46Z",
                          "publishedAt": "2022-10-04T00:55:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "I think your summary captures everything right.",
                          "url": "https://github.com/idaholab/moose/discussions/22254#discussioncomment-3792342",
                          "updatedAt": "2022-10-04T03:05:13Z",
                          "publishedAt": "2022-10-04T03:05:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Good, please forgive me for still trying, the difference is that I want to modify the GB energy tensor of the whole domain in the polycrystalline model. The detailed idea is as follows,\n\nat each quadrature point, obtain the corresponding vector of neighboring grain IDs for each grain ID, and later, according to the neighboring IDs, obtain the corresponding vector of the order parameter ID,\ngive the grain boundary energy tensor\na. If only one order parameter is activated, get the nearest neighboring grain ID according to the coordinates of that point and the sequence of center coordinates of the neighboring grains, and then assign the GB energy tensor,\nb. If at least two order parameter are activated, then the GB energy tensor is assigned, as described above\n\nI think such a strategy can be used to artificially assign the GB energy tensor to different grains (both within the grain and at the GB) as a whole. It can also solve the two problems mentioned above. I can currently output the adjacent grain ID vector, and the next step is to get the index of the order parameter based on the grain ID number. I am not too confident that this will achieve prefetching, and I would appreciate any suggestions you have for this strategy of mine and guidance to accomplish this goal.\nBy the way, my ultimate goal is to combine EBSD and construct a grain growth model considering GB energy aniostropy depend on misorientation.",
                          "url": "https://github.com/idaholab/moose/discussions/22254#discussioncomment-3792534",
                          "updatedAt": "2022-10-04T03:59:52Z",
                          "publishedAt": "2022-10-04T03:59:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Hejie-Guo"
                  },
                  "bodyText": "Hello, dear Wei, I am trying to model the anisotropic grain growth, could you please give some advice.\nI am trying to model elongate temperature-dependent grain growth behavior from experimental obervations. The anisotropic grain growth behavior is similar as the following figures:\n\nI simply modify some moose examples and modeling the temperature-dependent behavior, but did not quite understand how to model the anisotropic grain growth. Here is the result i can get using moose, i just want to anisotropic modeling the shape as the black line.",
                  "url": "https://github.com/idaholab/moose/discussions/22254#discussioncomment-8164497",
                  "updatedAt": "2024-01-18T03:46:08Z",
                  "publishedAt": "2024-01-18T03:46:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Constant strain in cells - thermal strain simulation using Tensor mechanics",
          "author": {
            "login": "HoWilgh"
          },
          "bodyText": "Hi,\nI have built a relatively simple model where I want to use the tensor mechanics module to simulate strain due to thermal expansion.\nThe model is attached and uses MOOSE-internally generated mesh.\nAttached you find also screenshots from the evaluation of the results in Paraview.\nOne can see two main things for the given simulation:\n\nThe displacement ist computed as point-data and the postprocessing using a line plot yields smooth (interpolated) values. See the upper two plots in the screenshot below.\nStrain and stress are computed as 'constant' volumetric (cell-) data and an evaluation over a line through the model yields steps in the strain-values.  See the lower two plots in the screenshot below.\n\nHow to overcome these 'constant'-computed vales for the strain to get as smooth results for the strain as for the displacement.\nThank you in advance,\nHoWil\n#############\nModel:\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n\n# Using internal mesh of MOOSE \n[Mesh]\n    type = GeneratedMesh\n    dim = 3\n    nx = 10\n    xmin = 0.0\n    xmax = 200.0\n    ny = 10\n    ymin = 0.0\n    ymax = 200.0\n    nz = 10\n    zmin = 0.0\n    zmax = 100.0\n    #displacements = 'disp_x disp_y disp_z'\n    second_order = True\n[]\n\n[BCs]  # Roller BC for the outer surfaces\n  [disp_x_right]\n      type = DirichletBC\n      variable = disp_x\n      boundary = right\n      value = 0.0\n  []\n\n  [disp_y_front]\n      type = DirichletBC\n      variable = disp_y\n      boundary = front\n      value = 0.0\n  []\n\n  [disp_z_bottom]\n      type = DirichletBC\n      variable = disp_z\n      boundary = bottom\n      value = 0.0\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    automatic_eigenstrain_names = true\n    strain = SMALL  # Small linearized strain, automatically set to XY coordinates\n    generate_output = 'stress_xx strain_xx' #automatically creates the auxvariables and auxkernels\n    #use_interpolated_state = true\n    # incremental = true\n  []\n[]\n\n[Materials]\n  [elasticity1]\n    type = ComputeElasticityTensor\n    fill_method = symmetric9\n    # C_ijkl = '1111  1122  1133  2222  2233  3333  2323  3131  1212'\n    # C_ijkl = '11    12    13    22    23    33    44    55    66'\n    C_ijkl = '234 92 88 234 88 238 64 64 54'\n    rotation_matrix = '1.0 0.0 0.0\n                      0.0 1.0 0.0\n                      0.0 0.0 1.0'\n  []\n\n  # eigenstrain computation due to temperature\n  [expansion1]\n    type = ComputeEigenstrain\n    eigen_base = '0.000375 0.0 0.0 0.0 0.000375 0.0 0.0 0.0 -0.0031'\n    prefactor = 1.\n    eigenstrain_name = eigenstrain\n  []  \n\n  [stress]\n    type = ComputeLinearElasticStress\n  []\n  \n[]\n\n[Executioner]  # See https://mooseframework.inl.gov/modules/porous_flow/solvers.html\n  type = Steady\n  solve_type = LINEAR\n[]\n\n[Postprocessors]\n  [nodes]\n    type = NumNodes\n  []\n  [elements]\n    type = NumElems\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n#############\nScreenshot of Paraview evaluating the computed results using a Plotoverline-filter:",
          "url": "https://github.com/idaholab/moose/discussions/26563",
          "updatedAt": "2024-01-17T22:20:25Z",
          "publishedAt": "2024-01-16T10:22:45Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere are two options here.\n\nparaview can convert cell data to node data, and plot it linearly.\nor you can use a ProjectionAux in MOOSE to project the output auxiliary variable onto a different FE family, like linear lagrange, that is smoother and still minimize the L2 norm between the two.\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26563#discussioncomment-8162354",
                  "updatedAt": "2024-01-17T22:15:55Z",
                  "publishedAt": "2024-01-17T22:15:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "In addition to @GiudGiud 's suggestion, you can also use https://mooseframework.inl.gov/source/auxkernels/NodalPatchRecoveryAux.html",
                          "url": "https://github.com/idaholab/moose/discussions/26563#discussioncomment-8162394",
                          "updatedAt": "2024-01-17T22:20:26Z",
                          "publishedAt": "2024-01-17T22:20:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Pause/Resume simulation while waiting for files (for coupling with another software) [PropertyReadFile]",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\njust wondering if there anyway that I can pause MOOSE simulation while waiting for files that will be generated (but not yet) on a folder? This is probably related to PropertyReadFile object as well, since it now can read multiple files from a single object/block.\nThe idea will be, we want to do a close coupling between MOOSE (hydro) and our Abaqus (mech) via damage files. The files that we want to exchange with MOOSE can be read via PropertyReadFile, we have done loose coupling before, where we generated 100+ of damage files and let MOOSE-hydro read it at each timestep.\nI will break down the step, and please let me know if it's possible\n\nrun Abaqus mech > produce damage file for t=1 > pause (done)\nrun MOOSE hydro > read damage file for t= 1 > run simulation > produce pwp_1.csv > pause (maybe at timestep_end)\nresume Abaqus mech > taking pwp from MOOSE > produce damage file for t=2 > pause (done)\nresume MOOSE hydro > read damage file for t= 2 > run simulation > produce pwp_2.csv >  > pause\nrepeat\n\nThe pause/resume part in Abaqus is already done by us, but not yet with MOOSE\nProblems I see so far are:\n\neven we know the total number of the files and all the file names, PropertyReadFile wont let us pass the initial setup since all the files are not there.\nWe dont know how to pause/resume MOOSE simulation (not even sure if this is possible)\n\nIf you have any idea on how to overcome this issue please let me know.\nKind regards,\nTraiwit\n@GiudGiud I tag you just in case you know if this possible OR you know someone that has done this before \ud83d\udc4d",
          "url": "https://github.com/idaholab/moose/discussions/26552",
          "updatedAt": "2024-01-17T21:49:06Z",
          "publishedAt": "2024-01-14T23:40:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@friedmud might want to respond since that could be a use for the MooseServer?",
                  "url": "https://github.com/idaholab/moose/discussions/26552#discussioncomment-8126952",
                  "updatedAt": "2024-01-14T23:44:47Z",
                  "publishedAt": "2024-01-14T23:44:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud\nI checked your new PropertyReadFile it almost works in such a way we want\nfirst of all it does not require all the files to be in the folder upfront.\nis there a way to modify it such that instead of splitting out the error because of a particular file isnt there at a particular timestep\nFor example the error below occured at the begining of t=3 (looking for damage 3) when the damage_03.csv isnt there, but the first 2 timesteps were fine.\nTime Step 3, time = 0.00015, dt = 5e-05\n\n*** ERROR ***\nUnable to open file \"/home/moose/Hydro_Krw_test/damage_03.csv\". Check to make sure that it exists and that you have read permission.\n\n\nwe want to make an infinate while loop and keep checking (idk every 5 sec) if the file is there, once it's there break the loop then move on into the solving stage of that timestep.\ndo you think MOOSE can do this?\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/26552#discussioncomment-8150409",
                          "updatedAt": "2024-01-16T23:42:42Z",
                          "publishedAt": "2024-01-16T23:42:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "i think i got it\nvoid PropertyReadFileCoupled::initialize()\n{\n  // Since we read at construction, no need to re-read the file on first initialize\n  if (!_initialize_called_once)\n  {\n    _initialize_called_once = true;\n    return;\n  }\n\n  // Set then read new file, only if we have not reached the last file\n  if (_current_file_index < _prop_file_names.size())\n  {\n    bool file_available = false;\n    while(!file_available)\n    {\n      std::ifstream test(_prop_file_names[_current_file_index]);\n      if(test.good())\n      {\n        // File exists and is readable\n        file_available = true;\n        test.close();\n      }\n      else\n      {\n        // File does not exist or is not readable, wait for 5 seconds\n        std::this_thread::sleep_for(std::chrono::seconds(5));\n      }\n    }\n\n    _reader.setFileName(_prop_file_names[_current_file_index]);\n    readData();\n  }\n  else if (_prop_file_names.size() > 1 && _current_file_index == _prop_file_names.size())\n  {\n    mooseInfo(\"Last file specified has been read. The file will no longer be updated.\");\n  }\n}\n\nthank you @josebastiase again for the idea!",
                          "url": "https://github.com/idaholab/moose/discussions/26552#discussioncomment-8150919",
                          "updatedAt": "2024-01-17T01:22:25Z",
                          "publishedAt": "2024-01-17T01:22:24Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yup this looks like a good solution to me.\nOne comment to make this friendlier to the user here would be to add a perf graph live section.\nThat way if MOOSE starts waiting a long time for that file, the perf graph will start printing a message, then dot dot dots every few seconds, to let you know where and why it is waiting",
                          "url": "https://github.com/idaholab/moose/discussions/26552#discussioncomment-8162188",
                          "updatedAt": "2024-01-17T21:49:06Z",
                          "publishedAt": "2024-01-17T21:49:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "josebastiase"
                  },
                  "bodyText": "Yeah I done that... you dont need to stop/pause the simulations, you have to make MOOSE \"wait\" while ABAQUS is simulating and vice versa. That way, you wont loose time and resources restarting after every time step. You can use an UserObject for that and the ABAQUS python interface.\nFor the files initial time step, I just created \"fake\" data files with the names of the coupling files so PropertyReadFile can pass.\nI hope this makes sense ;)",
                  "url": "https://github.com/idaholab/moose/discussions/26552#discussioncomment-8130152",
                  "updatedAt": "2024-01-15T08:10:36Z",
                  "publishedAt": "2024-01-15T08:10:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @josebastiase\nThank you for your reply! good to know that it's achievable.\nCould you please elaborate:\n\nYou can use an UserObject for that and the ABAQUS python interface.\n\nwhich UserObject did you use to make MOOSE 'wait'? could you please guide me on this or share if you have made one.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/26552#discussioncomment-8130595",
                          "updatedAt": "2024-01-15T08:47:57Z",
                          "publishedAt": "2024-01-15T08:47:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "josebastiase"
                  },
                  "bodyText": "Unfortunately, I dont have access to the files anymore nor to an ABAQUS licence. But you have to write the UserObject yourself with a bit of C+ and do something like: while ABAQUS is simulating - wait.\nif you cannot picture this drop me an email ;)",
                  "url": "https://github.com/idaholab/moose/discussions/26552#discussioncomment-8131111",
                  "updatedAt": "2024-01-15T09:39:41Z",
                  "publishedAt": "2024-01-15T09:39:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi Jose,\nJust sent you an email, I looked around MOOSE site, couldn't find anything related to 'wait' at all\nCheers,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/26552#discussioncomment-8131605",
                          "updatedAt": "2024-01-15T10:33:48Z",
                          "publishedAt": "2024-01-15T10:33:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Moose build errors from libtorch and geomsearch",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Hi,\nThese were some weird errors popping out while building moose (very recent version), when all of the supporting libraries are compiled correctly and located in correct places.  FYI, libtorch has been installed with the script (setup_libtorch.sh) packaged in the bundle and that should work as intended. I am sure some of its sources from the framework folder must as well be compiled in to libmoose correctly. Not quiet sure where i am going wrong. Any advice here would be appreciated.\nLinking Library /rds/project/iris_vol2/rds-ukaea-ap001/arunpb/mooseApp/lib/libhardening_model_app-opt.la...\nLinking Executable /rds/project/iris_vol2/rds-ukaea-ap001/arunpb/mooseApp/hardening_model_app-opt...\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::UndefinedTensorImpl::_singleton'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::div_Scalar::call(at::Tensor const&, c10::Scalar const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::AnyType::get()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::IValue::reportToTensorTypeError() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::detail::torchCheckFail(char const*, char const*, unsigned int, char const*)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::optim::SGDOptions'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::SymInt::promote_to_negative()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchData::GeometricSearchData(SubProblem&, MooseMesh&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::mul_Scalar::call(at::Tensor const&, c10::Scalar const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchInterface::getQuadraturePenetrationLocator(BoundaryName const&, BoundaryName const&, libMesh::Order)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `PenetrationLocator::setNormalSmoothingMethod(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `PenetrationLocator::setTangentialTolerance(double)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::sigmoid::call(at::Tensor const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::operator<<(torch::serialize::OutputArchive&, std::shared_ptr<torch::nn::Module> const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::full_like::call(at::Tensor const&, c10::Scalar const&, c10::optional<c10::ScalarType>, c10::optional<c10::Layout>, c10::optional<c10::Device>, c10::optional<bool>, c10::optional<c10::MemoryFormat>)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::impl::ExcludeDispatchKeyGuard::ExcludeDispatchKeyGuard(c10::DispatchKeySet)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::serialize::OutputArchive::OutputArchive(std::shared_ptr<torch::jit::CompilationUnit>)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::parameters(bool) const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::serialize::InputArchive::load_from(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, c10::optional<c10::Device>)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `double at::Tensor::item<double>() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::to(c10::ScalarType, bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchData::getPenetrationLocator(BoundaryName const&, BoundaryName const&, libMesh::Order)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::data::samplers::DistributedRandomSampler::DistributedRandomSampler(unsigned long, unsigned long, unsigned long, bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::clone_(torch::nn::Module&, c10::optional<c10::Device> const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `typeinfo for torch::nn::LinearImpl'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::TensorBase::is_leaf() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::AdamOptions::AdamOptions(double)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::stack::call(c10::ArrayRef<at::Tensor>, long)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchInterface::GeometricSearchInterface(MooseObject const*)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::copy_::call(at::Tensor&, at::Tensor const&, bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::TensorImpl::throw_data_ptr_access_error() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::RMSpropOptions::RMSpropOptions(double)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `typeinfo for torch::nn::Module'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::gelu::call(at::Tensor const&, c10::basic_string_view<char>)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::AdagradOptions::AdagradOptions(double)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::optim::RMSpropOptions'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::OptimizerParamState::serialize(torch::serialize::InputArchive&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::jit::Method::operator()(std::vector<c10::IValue, std::allocator<c10::IValue> >, std::unordered_map<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, c10::IValue, std::hash<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::equal_to<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const, c10::IValue> > > const&) const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchInterface::getPenetrationLocator(BoundaryName const&, BoundaryName const&, libMesh::Order)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::data::samplers::DistributedSequentialSampler::reset(c10::optional<unsigned long>)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::Warning::Warning(c10::variant<c10::Warning::UserWarning, c10::Warning::DeprecationWarning>, c10::SourceLocation, char const*, bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `caffe2::TypeMeta::typeMetaDatas()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::relu::call(at::Tensor const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `caffe2::TypeMeta::error_unsupported_typemeta(caffe2::TypeMeta)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::OptimizerParamGroup::has_options() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::OptimizerParamGroup::params() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::Module()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::optim::Adam'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `PenetrationLocator::setNormalSmoothingDistance(double)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchInterface::getQuadratureNearestNodeLocator(BoundaryName const&, BoundaryName const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::SGDOptions::SGDOptions(double)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::Optimizer::add_param_group(torch::optim::OptimizerParamGroup const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::optim::Adagrad'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::detail::torchCheckFail(char const*, char const*, unsigned int, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::data::samplers::DistributedRandomSampler'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::LinearImpl::LinearImpl(torch::nn::LinearOptions const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::OptimizerOptions::serialize(torch::serialize::OutputArchive&) const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchInterface::validParams()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::optim::AdagradOptions'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::operator>>(torch::serialize::InputArchive&, std::shared_ptr<torch::nn::Module> const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::optim::AdamOptions'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::save(torch::serialize::OutputArchive&) const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::nn::Module'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::to(c10::Device, c10::ScalarType, bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::to(c10::Device, bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::jit::Object::find_method(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::jit::load(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, c10::optional<c10::Device>, bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::OptimizerParamGroup::options() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::is_serializable() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::LinearImpl::forward(at::Tensor const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::TensorBase::retains_grad() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::zero_grad(bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::serialize::InputArchive::InputArchive()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::mse_loss::call(at::Tensor const&, at::Tensor const&, long)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchInterface::getNearestNodeLocator(BoundaryName const&, BoundaryName const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::OptimizerOptions::set_lr(double)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchData::~GeometricSearchData()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::TensorBase::data() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::serialize::OutputArchive::save_to(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::clone::call(at::Tensor const&, c10::optional<c10::MemoryFormat>)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::optim::SGD'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::Optimizer::zero_grad(bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::data::samplers::DistributedRandomSampler::next(unsigned long)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::autograd::AutogradMeta'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `NearestNodeLocator::nearestNode(unsigned long)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::train(bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::load(torch::serialize::InputArchive&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `typeinfo for torch::optim::OptimizerParamState'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::jit::Method'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchData::clearNearestNodeLocators()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::detach::call(at::Tensor const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::optim::RMSprop'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::OptimizerParamState::serialize(torch::serialize::OutputArchive&) const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchData::update(GeometricSearchData::GeometricSearchType)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::OptimizerOptions::serialize(torch::serialize::InputArchive&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::pretty_print(std::ostream&) const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::named_parameters[abi:cxx11](bool) const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `double* at::TensorBase::data_ptr<double>() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::ListType::get(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, c10::Type::SingletonOrSharedTypePtr<c10::Type>)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::data::samplers::DistributedSequentialSampler::next(unsigned long)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::elu::call(at::Tensor const&, c10::Scalar const&, c10::Scalar const&, c10::Scalar const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `NearestNodeLocator::distance(unsigned long)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `typeinfo for torch::optim::OptimizerOptions'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::optim::Optimizer'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::is_training() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::TensorImpl::grad() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::data::samplers::DistributedSequentialSampler::DistributedSequentialSampler(unsigned long, unsigned long, unsigned long, bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::TensorMaker::make_tensor()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::optim::AdagradParamState'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::warn(c10::Warning const&)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::data::samplers::DistributedRandomSampler::reset(c10::optional<unsigned long>)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchData::reinit()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::transpose_int::call(at::Tensor const&, long, long)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::TensorImpl::set_autograd_meta(std::unique_ptr<c10::AutogradMetaInterface, std::default_delete<c10::AutogradMetaInterface> >)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::AutogradMetaInterface::~AutogradMetaInterface()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchData::updateGhostedElems()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::StringType::get()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::optim::OptimizerOptions::get_lr() const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `vtable for torch::data::samplers::DistributedSequentialSampler'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::_ops::select_int::call(at::Tensor const&, long, c10::SymInt)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `long c10::detail::maybe_wrap_dim_slow<long>(long, long, bool)'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::Module::clone(c10::optional<c10::Device> const&) const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `at::Tensor::_backward(c10::ArrayRef<at::Tensor>, c10::optional<at::Tensor> const&, c10::optional<bool>, bool) const'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `c10::impl::ExcludeDispatchKeyGuard::~ExcludeDispatchKeyGuard()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `GeometricSearchData::maxPatchPercentage()'\n/home/ir-bala2/moose_dev/moose/framework/libmoose-opt.so: undefined reference to `torch::nn::LinearOptions::LinearOptions(long, long)'\nmake: *** [/home/ir-bala2/moose_dev/moose/framework/app.mk:451: /rds/project/iris_vol2/rds-ukaea-ap001/arunpb/mooseApp/hardening_model_app-opt] Error 1",
          "url": "https://github.com/idaholab/moose/discussions/26577",
          "updatedAt": "2024-01-17T21:42:07Z",
          "publishedAt": "2024-01-17T18:17:55Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you starting from a clean moose repository?\nIn general it looks like Torch is not being found at link time.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26577#discussioncomment-8162128",
                  "updatedAt": "2024-01-17T21:42:08Z",
                  "publishedAt": "2024-01-17T21:42:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Help for Auxkernel of Nodal value",
          "author": {
            "login": "bylore"
          },
          "bodyText": "Hi, I am trying to implemente Configurational force in Moose.\nConfiguration force in finite element method is a nodal value which can be calculated by the following formulation.\n\nIt is a integral over the element e, and N^I is the shape function correspnding to node I.\nG_e^I is the configuration force contributing to node I from element e.\n\nI think Auxkernel can compute some nodal values, but i don't know how to add  the nodal values contributing from different adjacent elements together. Could you give some advice? Thank you!\nRef:[1] R. Mueller, G. A. Maugin, Comput. Mech. 2002, 29, 52.",
          "url": "https://github.com/idaholab/moose/discussions/26553",
          "updatedAt": "2024-01-17T21:40:53Z",
          "publishedAt": "2024-01-15T02:32:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think you should be able to use the code developed for nodal patch recovery\nhttps://mooseframework.inl.gov/help/finite_element_concepts/nodal_patch_recovery.html\nto do this.\nlook at the following source files for how to do this\nframework/src/auxkernels/NodalPatchRecovery.C\nframework/src/userobjects/NodalPatchRecoveryBase.C\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26553#discussioncomment-8133006",
                  "updatedAt": "2024-01-15T13:16:09Z",
                  "publishedAt": "2024-01-15T13:16:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "Great\uff0cThank you\uff01",
                          "url": "https://github.com/idaholab/moose/discussions/26553#discussioncomment-8139216",
                          "updatedAt": "2024-01-16T02:44:26Z",
                          "publishedAt": "2024-01-16T02:44:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "Hello\nIn the source code of NodalPatchRecovery.C, it says that\n// Limit current use of NodalPatchRecovery to a single processor\n  if (_communicator.size() > 1)\n    mooseError(\"The nodal patch recovery option, which calculates the Zienkiewicz-Zhu patch \"\n               \"recovery for nodal variables (family = LAGRANGE), is not currently implemented for \"\n               \"parallel runs. Run in serial if you must use the nodal patch capability\");\n\nIf I only utilize some of its code to compute the node value from it element patch as above. Should i worried about this or Can i calculate this for parallel run?",
                          "url": "https://github.com/idaholab/moose/discussions/26553#discussioncomment-8140039",
                          "updatedAt": "2024-01-16T05:55:37Z",
                          "publishedAt": "2024-01-16T05:48:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "NodalPatchRecoveryAux.C seems dosen't have such limitations.",
                          "url": "https://github.com/idaholab/moose/discussions/26553#discussioncomment-8140229",
                          "updatedAt": "2024-01-16T06:21:38Z",
                          "publishedAt": "2024-01-16T06:21:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@hugary1995",
                          "url": "https://github.com/idaholab/moose/discussions/26553#discussioncomment-8144152",
                          "updatedAt": "2024-01-16T13:14:31Z",
                          "publishedAt": "2024-01-16T13:14:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Nodal patch recovery (NPR) and the configurational force (CF) are different. NPR reconstructs a multi-indexing polynomial basis which is then used to interpolate the value at each node. CF assembles all adjacent element integrals into a set.\nWhat they have in common is that they both need to loop over all the adjacent elements of each node. So I would second @GiudGiud 's suggestion -- those two source files are a good place to start.",
                          "url": "https://github.com/idaholab/moose/discussions/26553#discussioncomment-8144606",
                          "updatedAt": "2024-01-16T13:57:23Z",
                          "publishedAt": "2024-01-16T13:57:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "Thanks, i will try it.  An alternative way to calculate nodal configuration force may be : treat it as a Kernel of one arbitrary variable and save this residual in nodal auxiliary variable and cancel the residual of this kernel to the chosen variable by adding a corresponding negative one.",
                          "url": "https://github.com/idaholab/moose/discussions/26553#discussioncomment-8152034",
                          "updatedAt": "2024-01-17T04:30:56Z",
                          "publishedAt": "2024-01-17T04:30:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "AuxKernel storing into an auxvariable will let you compute the contribution to the residual, but not the contribution to the Jacobian (no AD in auxiliary variables to start with).\nYou could look at doing that with a material property though",
                          "url": "https://github.com/idaholab/moose/discussions/26553#discussioncomment-8162116",
                          "updatedAt": "2024-01-17T21:40:54Z",
                          "publishedAt": "2024-01-17T21:40:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}