{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMC0yOFQyMToxMjozOS0wNTowMM4AcLeH"
    },
    "edges": [
      {
        "node": {
          "title": "Large flunctuations of velocities on the fixed boundary",
          "author": {
            "login": "lyyc199586"
          },
          "bodyText": "Hi everyone,\nI am conducting large deformation elastodynamics simulations involving a compressive wave propagating from the left end of a bar. At the left boundary, I apply a displacement boundary condition that ramps up to a fixed displacement value, holding it constant afterward.\nWhile the displacement profile appears correct, I am observing significant fluctuations in the velocity at the left boundary. I expected these velocities to remain relatively small due to the fixed displacement condition following the ramp-up phase. Could these fluctuations be attributed to numerical artifacts, or are there other potential causes for this behavior?\nThank you for any insights.\nanimation of disp_x and vel_x:\n\n  \n    \n    \n\n    disp_vel.mp4\n    \n  \n\n  \n\n  \n\n\nmy input file:\nrho = 1e-6\nhht_alpha = -0.00\nbeta = '${fparse (1-hht_alpha)^2/4}'\ngamma = '${fparse 1/2-hht_alpha}'\n\n[Mesh]\n  [fmg]\n    type = FileMeshGenerator\n    file = './mesh/bar.msh'\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  alpha = ${hht_alpha}\n  beta = ${beta}\n  gamma = ${gamma}\n  large_kinematics = true\n  use_displaced_mesh = false\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n[]\n\n[AuxVariables] \n  [accel_x]\n  []\n  [vel_x]\n  []\n  [accel_y]\n  []\n  [vel_y]\n  []\n  [accel_z]\n  []\n  [vel_z]\n  []\n  [stress_xx]\n    order = CONSTANT\n    family = MONOMIAL\n    [AuxKernel]\n      type = RankTwoAux\n      rank_two_tensor = cauchy_stress\n      index_i = 0\n      index_j = 0\n      execute_on = 'INITIAL TIMESTEP_END'\n    []\n  []\n[]\n\n[Kernels]\n  [solid_x]\n    type = TotalLagrangianStressDivergence\n    variable = disp_x\n    displacements = 'disp_x disp_y disp_z'\n    component = 0\n  []\n  [inertia_x] # M*accel + eta*M*vel\n    type = ADInertialForce\n    variable = disp_x\n    velocity = vel_x\n    acceleration = accel_x\n    density = density\n  []\n  [solid_y]\n    type = TotalLagrangianStressDivergence\n    variable = disp_y\n    displacements = 'disp_x disp_y disp_z'\n    component = 1\n  []\n  [inertia_y] # M*accel + eta*M*vel\n    type = ADInertialForce\n    variable = disp_y\n    velocity = vel_y\n    acceleration = accel_y\n    density = density\n  []\n  [solid_z]\n    type = TotalLagrangianStressDivergence\n    variable = disp_z\n    displacements = 'disp_x disp_y disp_z'\n    component = 2\n  []\n  [inertia_z] # M*accel + eta*M*vel\n    type = ADInertialForce\n    variable = disp_z\n    velocity = vel_z\n    acceleration = accel_z\n    density = density\n  []\n[]\n\n[AuxKernels]\n  [accel_x] # Calculates and stores acceleration at the end of time step\n    type = NewmarkAccelAux\n    variable = accel_x\n    displacement = disp_x\n    velocity = vel_x\n    execute_on = timestep_end\n  []\n  [vel_x] # Calculates and stores velocity at the end of the time step\n    type = NewmarkVelAux\n    variable = vel_x\n    acceleration = accel_x\n    execute_on = timestep_end\n  []\n  [accel_y] # Calculates and stores acceleration at the end of time step\n    type = NewmarkAccelAux\n    variable = accel_y\n    displacement = disp_y\n    velocity = vel_y\n    execute_on = timestep_end\n  []\n  [vel_y] # Calculates and stores velocity at the end of the time step\n    type = NewmarkVelAux\n    variable = vel_y\n    acceleration = accel_y\n    execute_on = timestep_end\n  []\n  [accel_z] # Calculates and stores acceleration at the end of time step\n    type = NewmarkAccelAux\n    variable = accel_z\n    displacement = disp_z\n    velocity = vel_z\n    execute_on = timestep_end\n  []\n  [vel_z] # Calculates and stores velocity at the end of the time step\n    type = NewmarkVelAux\n    variable = vel_z\n    acceleration = accel_z\n    execute_on = timestep_end\n  []\n[]\n\n[Functions]\n  [load]\n    type = ADParsedFunction\n    expression = '0.4*(1-exp(-2.3983e5*t))'\n  []\n[]\n\n[BCs]\n  [left_x]\n    type = ADFunctionDirichletBC\n    boundary = '1'\n    variable = disp_x\n    function = load\n    preset = true\n  []\n[]\n\n[Materials]\n  [bulk]\n    type = ADGenericConstantMaterial\n    prop_names = 'density'\n    prop_values = '${rho}'\n  []\n  [elasticity]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 30000\n    poissons_ratio = 0.2\n  []\n  [stress]\n    type = ComputeLagrangianLinearElasticStress\n    # outputs = 'vtk'\n  []\n  [strain]\n    type = ComputeLagrangianStrain \n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  start_time = 0\n  end_time = 3e-4\n  dt = 1e-6\n  dtmin = 5e-9\n  nl_rel_tol = 1e-6\n  nl_abs_tol = 1e-8\n  l_tol = 1e-6\n  # r_tol = 1e-6\n  # nl_max_its = 20\n  nl_max_its = 500\n  l_max_its = 500\n  line_search = None\n  [TimeIntegrator]\n    type = NewmarkBeta\n    inactive_tsteps = 1\n  []\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/28958",
          "updatedAt": "2024-10-29T17:57:42Z",
          "publishedAt": "2024-10-29T15:18:28Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "maxnezdyur"
                  },
                  "bodyText": "This is very similar to this thread: #22574\nI believe it would be fixed with ramping up your BC or applying an initial condition on your velocity.",
                  "url": "https://github.com/idaholab/moose/discussions/28958#discussioncomment-11089479",
                  "updatedAt": "2024-10-29T16:02:18Z",
                  "publishedAt": "2024-10-29T16:02:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "I will try with IC on velocity",
                          "url": "https://github.com/idaholab/moose/discussions/28958#discussioncomment-11089874",
                          "updatedAt": "2024-10-29T16:29:22Z",
                          "publishedAt": "2024-10-29T16:29:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "humm, the displacement boundary is indeed ramped up from 0 to maximum value using an exponential function, and I tried to set initial velocity to 0, but still see those fluctuations.",
                          "url": "https://github.com/idaholab/moose/discussions/28958#discussioncomment-11090386",
                          "updatedAt": "2024-10-29T17:12:51Z",
                          "publishedAt": "2024-10-29T17:12:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "If there is no change to your problem definition, I believe you will have these artifacts.\nLook at the velocity of your disp bc, if you take the derivative at 0, the velocity is close to 1. So if you imagine the acceleration needed to going from v= 0 to v =1 for any dt-> 0 you can see that the acceleration needed is unbounded. So a ramped BC for your displacement would look like some sigmoid function.",
                          "url": "https://github.com/idaholab/moose/discussions/28958#discussioncomment-11090479",
                          "updatedAt": "2024-10-29T17:23:40Z",
                          "publishedAt": "2024-10-29T17:23:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "ok, I get this part. But why the fluctuation of velocity keeps to exist after the displacement is almost fixed?",
                          "url": "https://github.com/idaholab/moose/discussions/28958#discussioncomment-11090597",
                          "updatedAt": "2024-10-29T17:32:17Z",
                          "publishedAt": "2024-10-29T17:32:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "It's been a while since I looked at this problem, but when you do the math for a simple problem, I think you will be able to see why.  Do the first few time steps manually for a problem with IC = 0 for displacement and velocity. The whole block then has a BC on displacement such that disp = t. When you write out these equations, you should see that how the acceleration and velocity is calculated the velocity will oscillate.",
                          "url": "https://github.com/idaholab/moose/discussions/28958#discussioncomment-11090847",
                          "updatedAt": "2024-10-29T17:57:43Z",
                          "publishedAt": "2024-10-29T17:57:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "section '[FluidProperty]' does not have an associated \"Action\".",
          "author": {
            "login": "SunJianhang678"
          },
          "bodyText": "hello,everyone! I'm trying to develop an application, in which the Water97FluidProperties is used. But after the \"FluidProperties\" block is included in the input file, it runs into an error like \"section '[FluidProperty]' does not have an associated \"Action\".\" How can I solve this problem? Thanks very much!\n\n1dpipeT97.txt",
          "url": "https://github.com/idaholab/moose/discussions/28913",
          "updatedAt": "2024-10-29T13:30:40Z",
          "publishedAt": "2024-10-23T10:40:23Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt should be [FluidProperties] not FluidProperty",
                  "url": "https://github.com/idaholab/moose/discussions/28913#discussioncomment-11028936",
                  "updatedAt": "2024-10-23T12:42:05Z",
                  "publishedAt": "2024-10-23T12:42:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SunJianhang678"
                          },
                          "bodyText": "Thanks! I've tried that and it didn't work. I've also tried to set [FluidProperties] as a sub-block of [Modules], which didn't work either. I'm wondering if I need some settings like a specific \"action\" or turn on a switch in the Makefile to use the [FluidProperties] in an inputfile? Thanks for your patience!",
                          "url": "https://github.com/idaholab/moose/discussions/28913#discussioncomment-11035510",
                          "updatedAt": "2024-10-24T02:11:25Z",
                          "publishedAt": "2024-10-24T02:11:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You also need to turn in the fluid properties module in the Makefile , then make clobberall and recompile",
                          "url": "https://github.com/idaholab/moose/discussions/28913#discussioncomment-11036755",
                          "updatedAt": "2024-10-24T06:03:10Z",
                          "publishedAt": "2024-10-24T06:03:09Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SunJianhang678"
                          },
                          "bodyText": "I cleared the build directory and recompiled, then it didn't give this error reporting again. Thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/28913#discussioncomment-11087426",
                          "updatedAt": "2024-10-29T13:30:41Z",
                          "publishedAt": "2024-10-29T13:30:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to Restart with the Tensor Mechanics Master Action System",
          "author": {
            "login": "DaijunHU"
          },
          "bodyText": "Hello!\nI am currently working on a two-step solid mechanics simulation, where the stress distribution obtained from the first simulation is mapped to a second model for further computation (both models share identical meshes). I am encountering two issues and would appreciate your assistance:\n\n\nIn the first simulation, I used [Modules/TensorMechanics/Master/all] as shown below. However, I am not sure how to carry over the stress components into the second simulation using something similar to initial_from_file_var.\nIs it necessary to record all stress components in AuxVariables and AuxKernels in the first simulation to achieve this restarting?\nSorry that I couldn\u2019t find clear parameters in the documentation for the Tensor Mechanics Master Action System or Restarting and recovering from previous simulations.\nI wanted to try with initial_from_file_var and initial_from_file_timestep in this block, but the error below actually becomes an obstacle.\n\n\nWhile running the 2nd simulation using the  the following .i file, I encountered an error that left me puzzled:\n\n\n\nOnlyMicro80nmRestart.i:34: missing required parameter 'Modules/TensorMechanics/Master/displacements'\nDoc String: \"The nonlinear displacement variables for the problem.\"\n\nI actually specified displacements = 'ux uy uz' as shown by the attached part of my .i file, but the error persists. (I should make it clear that I did not set the displacements in my 1st simulation, so when the error occurs I added this line, but still the same error.)\nThank you for your help in advance and look forward to your reply!\nBest regards,\nDaijun\n> [Mesh]\n>     file = OnlyMicro80nm_out.e\n>     distribution = serial\n> []\n> \n> [Problem]\n>   restart_file_base = OnlyMicro80nm_outcp/LATEST\n>   force_restart = false\n> []\n> \n> [Variables]\n>   [./ux]\n>     order = FIRST\n>     family = LAGRANGE\n>     initial_from_file_var = ux\n>     initial_from_file_timestep = 635\n>   [../]\n> \n>   [./uy]\n>     order = FIRST\n>     family = LAGRANGE\n>     initial_from_file_var = uy\n>     initial_from_file_timestep = 635\n>   [../]\n> \n>   [./uz]\n>     order = FIRST\n>     family = LAGRANGE\n>     initial_from_file_var = uz\n>     initial_from_file_timestep = 635\n>   [../]\n> []\n> \n> [Modules/TensorMechanics/Master/all]\n>   strain = FINITE\n>   displacements = 'ux uy uz'\n>   add_variables = true\n>   generate_output = 'stress_xx stress_yy stress_zz stress_xy stress_xz stress_yz strain_xx strain_yy strain_zz strain_xy strain_xz strain_yz'\n> []\n> \n> [AuxVariables]\n>   [./slip_increment_1]\n>    order = FIRST\n>    family = MONOMIAL\n>     initial_from_file_var = slip_increment_1\n>     initial_from_file_timestep = 635\n>   [../]\n> []",
          "url": "https://github.com/idaholab/moose/discussions/28944",
          "updatedAt": "2024-10-29T03:46:23Z",
          "publishedAt": "2024-10-28T09:31:53Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe stresses are material properties which are not restarted using ICs or using initial_from_file_var parameters.\nYour best bet is to use Checkpoint restart\nhttps://mooseframework.inl.gov/application_usage/restart_recover.html\nThis second error will likely go away if you switched your syntax to the Physics syntax.\nIf it does not, it's asking for diplacements to be nested under Master/ instead of under Master/all\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28944#discussioncomment-11081972",
                  "updatedAt": "2024-10-29T03:08:01Z",
                  "publishedAt": "2024-10-29T03:08:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "DaijunHU"
                          },
                          "bodyText": "Hi Guillaume,\nThank you for your reply!\nI will try the Physics syntax for the 2nd error.\nI am still a bit confused about the Tensor Mechanics Master Action. On the webpage https://mooseframework.inl.gov/syntax/Modules/TensorMechanics/Master/index.html, it is mentioned that it generates aux variables and auxkernels to aid in the output of tensor components. So I think those stress components I added in generate_output = 'stress_xx strain_xx' are not material properties, but a kind of AuxVariables and AuxKernels calculated based on the solid mechanics equations, which should follow the restarting methods of AuxVariables. If I use Checkpoint restart, will all these outputs be automatically inherited into new simulations from the checkpoint file?\nIf so, is strain_xx inheritable? Because I have chosen in Variables to let the displacement inherit the previous simulation, so the strain should be recalculated based on the displacement field at the beginning of the second simulation?\nI'm a bit confused about this, before the Tensor Mechanics Master Action setting came out, I thought my strategy would be to create AuxVaribales and AuxKernels for each stress component and use initial_from_file_var, but not do this for strain_xx since the displacement field is already inherited  .  Now after using Master/all I am a little confused about this.\nI hope you can clear it up for me, thank you very much!\nBest regards,\nDaijun",
                          "url": "https://github.com/idaholab/moose/discussions/28944#discussioncomment-11082103",
                          "updatedAt": "2024-10-29T03:31:17Z",
                          "publishedAt": "2024-10-29T03:31:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "these auxiliary variables are only there for visualization purposes. In the equations, the stress/strain material properties are used",
                          "url": "https://github.com/idaholab/moose/discussions/28944#discussioncomment-11082121",
                          "updatedAt": "2024-10-29T03:32:53Z",
                          "publishedAt": "2024-10-29T03:32:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so the strain should be recalculated based on the displacement field at the beginning of the second simulation?\n\nit probably should but it's not that simple because there are often history effects (plasticity!) in solid mechanics. So the material properties are not restarted that way. They are restarted properly only using Checkpoint",
                          "url": "https://github.com/idaholab/moose/discussions/28944#discussioncomment-11082134",
                          "updatedAt": "2024-10-29T03:34:18Z",
                          "publishedAt": "2024-10-29T03:34:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "DaijunHU"
                          },
                          "bodyText": "Thank you for your answer!\nIf displacements and strain fields are inherited separately, that is, the strain field is inherited as a material property, and the displacement field is inherited manually in  Variables and cannot reflect the historical effect, are there any incompatible parts among them?\nThe displacement field cannot reflect whether there is plasticity in it, but it should still be able to make the material enter the plastic segment according to the material constitutive model we set, becaue the calculation is often driven by the displacements. Is this  a kind of duplication or conflict with the inheritance of the strain field?",
                          "url": "https://github.com/idaholab/moose/discussions/28944#discussioncomment-11082170",
                          "updatedAt": "2024-10-29T03:43:50Z",
                          "publishedAt": "2024-10-29T03:43:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you use checkpoint to inherit both, displacements and strain will be consistent.\nIf you use checkpoint for strain and set the displacements differently, using ICs or another file (with the SolutionUO for example), then they wont be consistent and the results will be affected.",
                          "url": "https://github.com/idaholab/moose/discussions/28944#discussioncomment-11082181",
                          "updatedAt": "2024-10-29T03:46:24Z",
                          "publishedAt": "2024-10-29T03:46:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Finite Strain and in echelon dynamics test",
          "author": {
            "login": "amassaf"
          },
          "bodyText": "Hello,\nWe have trouble working with dynamics in finite strains when using initial conditions on displacement. In fact we can see the correct displacement at the first increment while the strain and stress computations are wrong. This in echelon test works fine in small strain even when coupled with phase field fracture. I wonder if it's because of the strain initialization at the ComputeFiniteStrain ? Thanks for any help.",
          "url": "https://github.com/idaholab/moose/discussions/28865",
          "updatedAt": "2024-10-29T03:19:39Z",
          "publishedAt": "2024-10-16T14:45:09Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "selarem"
                  },
                  "bodyText": "Any help on this issue ?",
                  "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-10973484",
                  "updatedAt": "2024-10-17T15:47:16Z",
                  "publishedAt": "2024-10-17T15:47:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "amassaf"
                  },
                  "bodyText": "When using an initial condition like :\n[Variables]\n  [./disp_x]\n  [./InitialCondition]\n      type = FunctionIC\n      function = initial_cond_func_x\n    [../]\n  [../]\n  [./disp_y]\n  [./InitialCondition]\n      type = FunctionIC\n      function = initial_cond_func_y\n    [../]\n  [../]\n[]\n\n[Functions]\n[./initial_cond_func_x]\n    type = SolutionFunction\n    solution = s0\n    from_variable = 'disp_x'\n[../]\n [./initial_cond_func_y]\n    type = SolutionFunction\n    solution = s0\n    from_variable = 'disp_y'\n[../]\n[]\n\n[UserObjects]\n  [./s0]\n    type = SolutionUserObject\n    mesh = Finitehalf_elastic_960_out.e #half_elastic_960_out.e\n    timestep = LATEST\n    execute_on = initial\n  [../]\n[]\n\nAnd with the Material block as:\n[Materials]\n [./elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 3.09e9\n    poissons_ratio = 0.35\n  [../]\n[./elasticStrain]\n    type = ComputeFiniteStrainElasticStress\n  [../]\n[]\n\nWe got correct displacements but stress and strain are null which is strange.",
                  "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-11007011",
                  "updatedAt": "2024-10-21T15:28:02Z",
                  "publishedAt": "2024-10-21T15:28:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "amassaf"
                          },
                          "bodyText": "could this be due to the initialization in the 'ComputeFiniteStrain.C' or 'ComputeIncrementalStrainBase.C'",
                          "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-11007031",
                          "updatedAt": "2024-10-21T15:29:40Z",
                          "publishedAt": "2024-10-21T15:29:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYou need to use a proper restart using Checkpoints to restart stateful material properties.\nYou can't use solution user objects to restart just some variables. Unless you put in more objects from the ProjectedMaterialPropertyStorage (or some name like this) action.",
                          "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-11007168",
                          "updatedAt": "2024-10-21T15:42:01Z",
                          "publishedAt": "2024-10-21T15:42:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "amassaf"
                          },
                          "bodyText": "Ok thanks! I did this using Checkpoint and restart_file_base but I got this error:\n*** ERROR ***\nThe stateful material property 'elastic_strain' was declared in ComputeFiniteStrainElasticStress \"elasticStrain\" but was not declared in that object on checkpoint.\n\nThis is not currently supported due to ambiguity.\n\nPlease contact the development team on GitHub if you desire this capability.\n\nI don't even understand what this capability is. Both the original file and the new restart file have a ComputeFiniteStrainElasticStress object.",
                          "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-11018743",
                          "updatedAt": "2024-10-22T15:09:06Z",
                          "publishedAt": "2024-10-22T15:09:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Does it have exactly the same name? And same suffix/prefix (if those are used) for material properties?",
                          "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-11019987",
                          "updatedAt": "2024-10-22T17:07:07Z",
                          "publishedAt": "2024-10-22T17:07:07Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "Now the error is :\n*** ERROR ***\nThe stateful material properties in ComputeLinearElasticPFFractureStress \"elastic\" that are being restarted do not match the stored properties in the same material object from the checkpoint.\n\nCheckpointed stateful properties:\n - hist\n\nCurrent stateful properties:\n - hist\n - stress\n\nWe use the same material in both computations.",
                          "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-11028840",
                          "updatedAt": "2024-10-23T12:38:26Z",
                          "publishedAt": "2024-10-23T12:33:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Some option must be different.\nCan you paste the Materials and GlobalParams blocks in both simulations?",
                          "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-11028916",
                          "updatedAt": "2024-10-23T12:39:54Z",
                          "publishedAt": "2024-10-23T12:39:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "Everything is the same only the Modules:\nThe first (to import) is quasistatic:\n[Physics/SolidMechanics/QuasiStatic]\n  [all]\n    strain = small \n    add_variables = true\n    extra_vector_tags = 'kernel_residual'\n    additional_generate_output = 'stress_xx stress_xy stress_yy'\n  []\n[]\n\n\nand the main that imports :\n[Modules]\n  [./TensorMechanics/DynamicMaster]\n      [all]\n        add_variables = true\n        hht_alpha =-0.333\n        newmark_beta = 0.44 #0.3025\n        newmark_gamma =0.83\n        strain = small \n        density = 1180 \n        additional_generate_output = 'stress_yy stress_xy stress_xx'\n       extra_vector_tags = 'kernel_residual'\n      []\n  [../]\n[]\n\n\nSome option must be different. Can you paste the Materials and GlobalParams blocks in both simulations?",
                          "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-11029114",
                          "updatedAt": "2024-10-23T12:57:04Z",
                          "publishedAt": "2024-10-23T12:57:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the executioner is a Transient for both cases too?",
                          "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-11029169",
                          "updatedAt": "2024-10-23T13:02:09Z",
                          "publishedAt": "2024-10-23T13:02:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "the executioner is a Transient for both cases too?\n\nyes, for both :\n[Executioner]\n  type = Transient\nsolve_type = newton\npetsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'",
                          "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-11029473",
                          "updatedAt": "2024-10-23T13:31:18Z",
                          "publishedAt": "2024-10-23T13:31:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you paste this object of type ComputeLinearElasticPFFractureStress?\nthe Materials block you posted was different",
                          "url": "https://github.com/idaholab/moose/discussions/28865#discussioncomment-11029619",
                          "updatedAt": "2024-10-23T13:42:04Z",
                          "publishedAt": "2024-10-23T13:42:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Difference in function boundary condition solution to expected values",
          "author": {
            "login": "AmbroiseJuston"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nGood afternoon,\nI am working on a problem which required me changing a boundary condition to simulate different test conditions. Basically i am doing an IV plot of an electrical component.\nWe were trying to validate which way would better represent sweeping the IV plane (from 0v to 1v) and had some questions on why certain results diverged.\nOption 1: we can manually solve for steady state (~10 units of time) and then use the final state as the IC of the next simulation, increasing the voltage by a certain amount (0.1 for example).\nOption 2: we can used a piecewise function and create a discrete stair function with increments of 0.1 after x time (~10 units of time to let it each steady state at that condition.\nOption 3: create another piecewise function but linearly increasing from 0 to 1 and then back down.\nI can see how option 3 would be different that then other solutions however what i do not understand if how options 1 and 2 diverge because in my mind they are equivalent in the long run. The difference is if we do the step manually or as a discrete step function.\nIs there a difference between how MOOSE would evaluate the results for options 1 and 2?\nThe step function being used is shown below:\n   [./bc_function_step]\n    type = PiecewiseLinear\n    y = '0 0 0.001  0.001  0.01  0.01  0.1   0.1  0.2   0.2  0.3   0.3  0.4  0.4  0.5   0.5  0.6  0.6  0.7   0.7 0.8  0.8 0.9   0.9 1      1'\n    x = '0 5 5.001  15    15.001  25  25.001  35 35.001 45  45.001 55  55.001 65 65.001 75  75.001 85 85.001 95 95.001 105 105.001 115 115.001 125'\n    scale_factor = 1.0\n  [../]\n\nand the code that reads in the .e as the new IC for the simulation is defined here:\n[UserObjects]\n  [exo_soln]\n    type = SolutionUserObject\n    mesh = 'etpf-23_test_out_IC23.e'\n    system_variables = 'c'\n    timestep = LATEST\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/28735",
          "updatedAt": "2024-10-29T03:15:56Z",
          "publishedAt": "2024-10-01T00:38:56Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you using pseudo timesteps in all these simulations? So timesteps but with no time derivative kernel so a steady state is reached on every time step?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28735#discussioncomment-10803563",
                  "updatedAt": "2024-10-01T00:57:17Z",
                  "publishedAt": "2024-10-01T00:57:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AmbroiseJuston"
                          },
                          "bodyText": "there is a time derivative kernel included and we are running until it reaches to steady-state if that was the question",
                          "url": "https://github.com/idaholab/moose/discussions/28735#discussioncomment-10813915",
                          "updatedAt": "2024-10-01T21:42:33Z",
                          "publishedAt": "2024-10-01T21:42:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I could see the time integration error be different in option 1 and 2.\nhow different are they? And how do you know the solution is at steady state after 10 units of time? did you use the built-in steady state detection?",
                          "url": "https://github.com/idaholab/moose/discussions/28735#discussioncomment-10814156",
                          "updatedAt": "2024-10-01T22:24:41Z",
                          "publishedAt": "2024-10-01T22:24:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AmbroiseJuston"
                          },
                          "bodyText": "They are off by around 80-120%, depending on the voltage at the step.\nWe have data showing that once it runs for around 5-10 ns of simulation time, the current (the quantity of interest) in the system reaches an equilibrium. To make sure, we are running for 20-30ns of simulation time. We know there is a built-in steady state solver, but this is mostly reusing the code of when we were interested in running for a certain amount of time. We also wanted to have more control over when the application ends while doing the sweep.",
                          "url": "https://github.com/idaholab/moose/discussions/28735#discussioncomment-10823181",
                          "updatedAt": "2024-10-02T16:42:13Z",
                          "publishedAt": "2024-10-02T16:41:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "how are you comparing the two solutions? visually using the exodus file at the last time step (that part is important of course)\n\nWe know there is a built-in steady state solver\n\nit should be as easy as setting the executioner type to \"Steady\" and passing \"--allow-unused\" on the command line for the unused executiner parameters.\nThis might tell you which solution has unexpected results",
                          "url": "https://github.com/idaholab/moose/discussions/28735#discussioncomment-10826128",
                          "updatedAt": "2024-10-02T23:26:54Z",
                          "publishedAt": "2024-10-02T23:26:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AmbroiseJuston"
                          },
                          "bodyText": "Both visually and we are comparing the current that passes through the sample. The conductivity are comparable between options. The biggest difference is that difference in steady state current which should be same same if the conditions are identical between the options.\nWe can't just move it to a steady solve because one of our kernels on chemical potential uses some features from the transient solver.",
                          "url": "https://github.com/idaholab/moose/discussions/28735#discussioncomment-10861305",
                          "updatedAt": "2024-10-06T22:10:16Z",
                          "publishedAt": "2024-10-06T22:08:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@cticenhour do you see why that could be? Or can you think of someone who does electronics w/ moose?",
                          "url": "https://github.com/idaholab/moose/discussions/28735#discussioncomment-10862636",
                          "updatedAt": "2024-10-07T04:11:18Z",
                          "publishedAt": "2024-10-07T04:11:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AmbroiseJuston"
                          },
                          "bodyText": "For some clarification, we are using phase-field for this type of analysis in case that helps",
                          "url": "https://github.com/idaholab/moose/discussions/28735#discussioncomment-10894536",
                          "updatedAt": "2024-10-09T15:58:04Z",
                          "publishedAt": "2024-10-09T15:58:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so phase field + electronics.  Is phase field to compute the conductivities / material properties?\nI wonder if @mangerij could help us here?\n@csdechant do you know about this field?",
                          "url": "https://github.com/idaholab/moose/discussions/28735#discussioncomment-10903189",
                          "updatedAt": "2024-10-10T11:28:28Z",
                          "publishedAt": "2024-10-10T11:28:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AmbroiseJuston"
                          },
                          "bodyText": "Phase field is used for the analysis of memristors. For some more context, we also ran some tests with the energy function kernel to see if the problem was it was not actually reaching a system steady state, but it seems to. Also, when stepping the BC in voltage, there is no accompanying increase in the energy function at the same time as (we think) we should expect the same is true when doing it by hand it seems.",
                          "url": "https://github.com/idaholab/moose/discussions/28735#discussioncomment-10921489",
                          "updatedAt": "2024-10-12T08:25:19Z",
                          "publishedAt": "2024-10-12T08:25:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so you're saying you are finding a missing coupling effect?\nHow is the coupling performed? In a single-system approach or with multiapps?\nIf in a single system approach, any auxiliary variable involved in the coupling ? (these can introduce lag)\nIf a multiapp approach, did you turn on fixed point iterations?",
                          "url": "https://github.com/idaholab/moose/discussions/28735#discussioncomment-10923353",
                          "updatedAt": "2024-10-12T15:29:34Z",
                          "publishedAt": "2024-10-12T15:29:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Constraints for array variable on boundaries",
          "author": {
            "login": "pj131611"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nGreetings!\nI'm looking for a constraint function that constrain the boundary value of the same variable through multiple boundaries. But the problem is I'm working with array variables and I couldn't find a constraint for array. So my question is does such function exist? If not, would it be reasonable to write a constraint function that inherit from EqualValueBoundaryConstraint or TiedValueConstraint but with array variable and component as input?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/28860",
          "updatedAt": "2024-10-29T03:10:16Z",
          "publishedAt": "2024-10-16T02:00:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo I don't think we have that at the moment but feel free to implement it.\nPlease let us know if you hit any difficulties doing so",
                  "url": "https://github.com/idaholab/moose/discussions/28860#discussioncomment-10954230",
                  "updatedAt": "2024-10-16T02:41:51Z",
                  "publishedAt": "2024-10-16T02:41:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pj131611"
                          },
                          "bodyText": "Cool. I started with inherit from Constraint class and replace the variable with arraymoosevariable and here comes the first problem while testing:\n*** ERROR ***\nUnknown type of Constraint object\n\nAfter doing a little bit of digging around, it seems like I need add this new constraint into Constraint Warehouse and objects, which will make me re-make moose. Is there a way to avoid this? It takes way too long to re-make the whole moose framework.",
                          "url": "https://github.com/idaholab/moose/discussions/28860#discussioncomment-10956142",
                          "updatedAt": "2024-10-16T07:28:20Z",
                          "publishedAt": "2024-10-16T07:28:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nthe Constraint class should be the base class for your new objects most likely.\nIt only brings a variable parameter which you can use and some background calls to the subproblem to trigger the right kind of re-iniit.\nIf you inherit from the Constraint class, your object will be added to the Constraint warehouse as expected",
                          "url": "https://github.com/idaholab/moose/discussions/28860#discussioncomment-10959214",
                          "updatedAt": "2024-10-16T12:08:52Z",
                          "publishedAt": "2024-10-16T12:08:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pj131611"
                          },
                          "bodyText": "Hi there!\nA surprising problem arise while I'm trying to simplify the mesh: Is there a way to convert the input unstructured mesh(triangles and simplex) to structured mesh(squares and cubes)? It seems a lot easier to play with structured mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/28860#discussioncomment-11070382",
                          "updatedAt": "2024-10-28T03:43:11Z",
                          "publishedAt": "2024-10-28T03:43:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not in a general way. Most shapes described with unstructured mesh cannot be described with structured meshes\nYou can generate simple structured meshes with this:\nhttps://mooseframework.inl.gov/source/meshgenerators/CartesianMeshGenerator.html\nUnder the hood they are still represented as unstructured meshes though. MOOSE does not support the libmesh structured mesh",
                          "url": "https://github.com/idaholab/moose/discussions/28860#discussioncomment-11082003",
                          "updatedAt": "2024-10-29T03:10:17Z",
                          "publishedAt": "2024-10-29T03:10:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to Update Boundary Name Dynamically During a Simulation in MOOSE",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi everyone,\nI\u2019m trying to implement a feature where the boundary name can be updated dynamically during the simulation. Below is an example of the boundary condition I\u2019m working with:\n[bc_topol0000_LGFlux]\n  type = PorousFlowPiecewiseLinearSink\n  variable = porepressure_L1\n  boundary = 'topol_new'\n  pt_vals = '-1e9 1e9'\n  multipliers = '-1e9 1e9'\n  flux_function = 1e-2\n  PT_shift = AuxFx_rhogh\n  fluid_phase = 0\n  use_mobility = false\n  use_relperm = false\n[]\n\nMy goal is to change the boundary name (e.g., from 'topol_new' to something else) based on simulation time or other control logic.\nI have a few ideas but need some guidance on how to implement this:\n\n\nUse [Controls] to update the boundary name dynamically.\n\n\nCreate a custom BC class that updates the boundary name based on a list of boundaries and their associated times.\nHere\u2019s a starting point of my custom class idea:\n\n\nvoid PorousFlowBEH_PiecewiseLinearSink::updateBoundary()\n{\n  Real current_time = _fe_problem.time();  // Get the current simulation time\n\n  for (size_t i = 0; i < _time_per_boundary.size(); ++i)\n  {\n    if (current_time <= _time_per_boundary[i])\n    {\n      _current_boundary_index = i;\n      break;\n    }\n  }\n\n  const BoundaryName & active_boundary = _boundaries[_current_boundary_index];\n\n  _console << \"Current time: \" << current_time << std::endl\n           << \"Active boundary: \" << active_boundary << std::endl\n           << std::flush;\n}\n\nIn my new BC block, I\u2019d like to specify multiple boundaries and the time points at which they should change:\n[bc_topol0000_LGFlux]\n  type = PorousFlowBEH_PiecewiseLinearSink\n  variable = porepressure_L1\n  boundary = 'TOPOLSRF_F000_EQUIL'\n  boundaries = 'TOPOLSRF_F000_EQUIL TOPOLSRF_F001_PITX1_DMP1 TOPOLSRF_F002_PITX2_PITF1 TOPOLSRF_F003_PITX3_DMP2'\n  time_per_boundary = '0 1 2 3'\n  pt_vals = '-1e9 1e9'\n  multipliers = '-1e9 1e9'\n  flux_function = 1\n  char_elem_length_n = charElLength_M0\n  PT_shift = AuxFx_rhogh\n  fluid_phase = 0\n  use_mobility = true\n  use_relperm = false\n[]\n\nQuestions:\n\n\nHow can I get access to the 'boundary' property within my custom BC class so I can update it dynamically?\n\n\nIs it possible to leverage the [Controls] system to handle this kind of boundary update, or would a new custom class be the better approach?\n\n\nThank you!\nTraiwit\nnote: i'm aware of the option that having multiple BC and use multiple  [ConditionalFunctionEnableControl]\nHowever, we have more than 200+ steps/BCs, we find that having many objects on very large scale simulation is not very optimal",
          "url": "https://github.com/idaholab/moose/discussions/28849",
          "updatedAt": "2024-10-29T03:01:39Z",
          "publishedAt": "2024-10-15T08:57:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo are you trying to update the boundary name in the mesh? (e.g. the new one does not exist at the beginning)\nOr change the boundary on which the BC is active?\n\nUse [Controls] to update the boundary name dynamically.\n\nThat's not currently controllable. To control a parameter, it has to be declared controllable in the validParams.\nHere considering there are conversions done between the names and ids in the initialization of the boundary-restrictable interface, you would need to re-initialize the boundary-restrictable-derived object every time.\n\nHow can I get access to the 'boundary' property within my custom BC class so I can update it dynamically?\n\nBoundary restriction is currently fixed.\n\nHowever, we have more than 200+ steps/BCs, we find that having many objects on very large scale simulation is not very optimal\n\nIt's not optimal but if you are worried about readability, you can stash additional objects in separate files using input files includes.\nSomething like:\n!include all_bcs.i",
                  "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-10947899",
                  "updatedAt": "2024-10-15T13:12:10Z",
                  "publishedAt": "2024-10-15T13:12:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Hi @GiudGiud\n\nSo are you trying to update the boundary name in the mesh? (e.g. the new one does not exist at the beginning)\nOr change the boundary on which the BC is active?\n\nchange the boundary on which the BC is active, this is what I want to do\nnoted, i had an idea last night:\nuse UO to read vector of surface names with respect to time and generate a container surface name\nso the surface that feed into BC is always the same (the container surface name), but nodeset/sides will be different at each step.\nwill give this a try and keep you updated",
                  "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-10953242",
                  "updatedAt": "2024-10-15T23:19:07Z",
                  "publishedAt": "2024-10-15T23:19:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "josebastiase"
                          },
                          "bodyText": "Hi Traiwit,\nI actually had the same issue a couple of months ago. I ended up writing a Python script to generate a CSV with the active/inactive schedule for the boundary conditions, which I then imported into MOOSE using Functions and Controls. After that, I wrote another script to generate the longer MOOSE input file automatically.\nThis method worked well for me, but a bit tedious.",
                          "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-10956157",
                          "updatedAt": "2024-10-16T07:30:47Z",
                          "publishedAt": "2024-10-16T07:30:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi guys,\nyeh so i manage to do it, below is the summary of how it works\nThe UpdateSurfaceTimeBased object dynamically switches between predefined boundary surfaces at specific time points during the simulation. It performs a 1:1 copy of the sides from the selected surface to a new \"container boundary\", clearing any pre-existing sides in the target boundary each time a switch occurs. The copied boundary sides (container boundary) can then be used for applying boundary conditions\nwhere the input file block will look like this:\n    [./update_surface]\n      type = UpdateSurfaceTimeBased\n      surface_list = 'TOPOLSRF_F000_EQUIL TOPOLSRF_F001_PITX1_DMP1 TOPOLSRF_F002_PITX2_PITF1 TOPOLSRF_F003_PITX3_DMP2'\n      time_per_surface = '0 1 2 3'\n      new_boundary_id = 10005                         // container surface ID\n      new_boundary_name = topol_time_new  // container surface name\n      execute_on = 'TIMESTEP_BEGIN'\n    [../]\n\n#include \"UpdateSurfaceTimeBased.h\"\n#include \"MooseMeshUtils.h\"\n#include \"libmesh/mesh.h\"\n\nregisterMooseObject(\"moose_behApp\", UpdateSurfaceTimeBased);\n\nInputParameters\nUpdateSurfaceTimeBased::validParams()\n{\n  InputParameters params = DomainUserObject::validParams();\n\n  params.addRequiredParam<std::vector<BoundaryName>>(\"surface_list\", \n      \"List of surfaces to switch between based on time.\");\n  params.addRequiredParam<std::vector<Real>>(\"time_per_surface\", \n      \"Time points to switch surfaces.\");\n  params.addRequiredParam<BoundaryName>(\"new_boundary_name\", \n      \"The name of the new boundary.\");\n  params.addRequiredParam<BoundaryID>(\"new_boundary_id\", \n      \"The ID of the new boundary.\");\n\n  return params;\n}\n\nUpdateSurfaceTimeBased::UpdateSurfaceTimeBased(const InputParameters & parameters)\n  : DomainUserObject(parameters),\n    _pid(_communicator.rank()),\n    _neighbor_side(_assembly.neighborSide()),\n    _surface_list(getParam<std::vector<BoundaryName>>(\"surface_list\")),\n    _time_per_surface(getParam<std::vector<Real>>(\"time_per_surface\")),\n    _new_boundary_name(getParam<BoundaryName>(\"new_boundary_name\")),\n    _new_boundary_id(getParam<BoundaryID>(\"new_boundary_id\")),\n    _boundary_info(_mesh.getMesh().get_boundary_info())\n{\n\n}\n\nvoid UpdateSurfaceTimeBased::initialize()\n{\n  _remove.clear();\n  updateBoundary();  // Select and copy the appropriate boundary based on time\n}\n\nvoid UpdateSurfaceTimeBased::updateBoundary()\n{\n  Real current_time = _fe_problem.time();\n  unsigned int surface_index = 0;\n\n  // Find the correct surface based on the current time\n  for (size_t i = 0; i < _time_per_surface.size(); ++i)\n  {\n    if (current_time <= _time_per_surface[i])\n    {\n      surface_index = i;\n      break;\n    }\n  }\n\n  const BoundaryName & selected_surface = _surface_list[surface_index];\n  const BoundaryID selected_id = MooseMeshUtils::getBoundaryID(selected_surface, _mesh.getMesh());\n\n  // Copy the selected surface to the new boundary\n  copyBoundaryData(selected_id, _new_boundary_id);\n  _boundary_info.sideset_name(_new_boundary_id) = _new_boundary_name;\n\n\n  _console << \"Selected surface: \" << selected_surface << \" selected_id: \" << selected_id\n           << \" copied to new boundary: \" << _new_boundary_name << \" _new_boundary_id: \" << _new_boundary_id\n           << \" at time: \" << current_time << std::endl;\n}\n\nvoid UpdateSurfaceTimeBased::copyBoundaryData(BoundaryID from, BoundaryID to)\n{\n  // _remove.clear();\n\n  _console << \" copyBoundaryData selected_id: \" << from << \" to\" << to << std::endl;\n  const auto & mesh = _mesh.getMesh();\n  const unsigned int n_elem = mesh.n_elem();\n\n  // Clear the target boundary before copying\n   // Clear the 'to' boundary before copying from 'from'\n  // clearBoundary(to);\n\n  // Iterate over all elements to copy sides from 'from' to 'to'\n  for (unsigned int i = 0; i < n_elem; ++i)\n  {\n    const Elem * elem = mesh.elem_ptr(i);\n    for (unsigned int side = 0; side < elem->n_sides(); ++side)\n    {\n      if (_boundary_info.has_boundary_id(elem, side, from))\n      {\n        _boundary_info.add_side(elem, side, to);\n      }\n    }\n  }\n\n  // Set the name of the new boundary\n  _boundary_info.sideset_name(to) = _new_boundary_name;\n}\n\nvoid UpdateSurfaceTimeBased::finalize()\n{\n  updateBoundary(); \n  synchronizeBoundaryInfo(_mesh);\n}\n\n\nvoid \nUpdateSurfaceTimeBased::threadJoin(const UserObject & uo)\n{\n  const auto & other = static_cast<const UpdateSurfaceTimeBased &>(uo);\n  for (const auto & [pid, list] : other._remove)\n    _remove[pid].insert(_remove[pid].end(), list.begin(), list.end());\n}\n\nvoid \nUpdateSurfaceTimeBased::synchronizeBoundaryInfo(MooseMesh & mesh)\n{\n  mesh.getMesh().get_boundary_info().parallel_sync_side_ids();\n  mesh.getMesh().get_boundary_info().parallel_sync_node_ids();\n  mesh.buildNodeListFromSideList();\n}\n\n// void UpdateSurfaceTimeBased::clearBoundary(BoundaryID to)\n// {\n//   const auto & mesh = _mesh.getMesh();\n//   const unsigned int n_elem = mesh.n_elem();\n\n//   // Remove all sides associated with the 'to' boundary\n//   for (unsigned int i = 0; i < n_elem; ++i)\n//   {\n//     const Elem * elem = mesh.elem_ptr(i);\n//     for (unsigned int side = 0; side < elem->n_sides(); ++side)\n//     {\n//       if (_boundary_info.has_boundary_id(elem, side, to))\n//       {\n//         _boundary_info.remove_side(elem, side, to);\n//       }\n//     }\n//   }\n\n//   // Remove all nodes associated with the 'to' boundary\n//   auto & nodeset_map = _boundary_info.get_nodeset_map();\n//   std::vector<const Node *> nodes_to_remove;\n//   for (const auto & pair : nodeset_map)\n//   {\n//     if (pair.second == to)\n//       nodes_to_remove.push_back(pair.first);\n//   }\n\n//   for (const auto node : nodes_to_remove)\n//     _boundary_info.remove_node(node, to);\n// }",
                          "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-10958626",
                          "updatedAt": "2024-10-16T11:08:28Z",
                          "publishedAt": "2024-10-16T11:08:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you will want your objects to be boundary restricted to these new boundaries (as well as the old one?) from the very start.",
                          "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-10959182",
                          "updatedAt": "2024-10-16T12:06:28Z",
                          "publishedAt": "2024-10-16T12:06:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "to be boundary restricted to these new boundaries\n\nHi @GiudGiud i dont get this, could you please explain?\nThank you!",
                          "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-10965130",
                          "updatedAt": "2024-10-16T23:08:39Z",
                          "publishedAt": "2024-10-16T23:08:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "While you can change boundaries dynamically, you cannot change the boundary restriction of an object.\nSo either you already set the boundary restriction to work for the whole simulation, or you use multiple objects and turn some on/off as the boundaries change",
                          "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-10965549",
                          "updatedAt": "2024-10-17T00:39:18Z",
                          "publishedAt": "2024-10-17T00:39:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud, I tested it, it kinda works fine (for now),\nso below is my BC, while the boundary name (topol_time_new) stays the same, the nodes and sides inside this boundary can change dynamically due to UpdateSurfaceTimeBased.\nI guess, this is the first case you mentioned.\n [bc_topol0000_LGFlux]\n    type = PorousFlowPiecewiseLinearSink\n    variable = porepressure_L1\n    boundary = 'topol_time_new'\n    pt_vals = '-1e9 1e9'\n    multipliers = '-1e9 1e9'\n    flux_function = 1\n    PT_shift = -98100   # in Pa, ie., -9810.N/m3*-10m\n    fluid_phase = 0\n    use_mobility = true   # default is false\n    use_relperm = false    # default is false\n  []",
                          "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-10965588",
                          "updatedAt": "2024-10-17T00:48:15Z",
                          "publishedAt": "2024-10-17T00:48:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if the name / id stays the same this should work",
                          "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-10965789",
                          "updatedAt": "2024-10-17T01:25:48Z",
                          "publishedAt": "2024-10-17T01:25:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if the name / id stays the same this should work",
                          "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-10965793",
                          "updatedAt": "2024-10-17T01:26:33Z",
                          "publishedAt": "2024-10-17T01:26:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Yulongggggg"
                  },
                  "bodyText": "Hi Traiwit, I am also a mining engineering PhD student using MOOSE to simulate the tunneling process, can I ask you some questions regarding MOOSE recently, I have been working on simulating the excavation process in plasticity , may I have your email?",
                  "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-11006805",
                  "updatedAt": "2024-10-21T15:09:10Z",
                  "publishedAt": "2024-10-21T15:09:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @Yulongggggg\nFor mech simulation we still use Abaqus since MOOSE explicit is still much slower\nbut if you have any question re: MOOSE hydro-mining related, please feel free to tag me.\nnote: for hydro-mech we do 2 ways coupling between MOOSE and Abaqus.",
                          "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-11047088",
                          "updatedAt": "2024-10-25T02:02:30Z",
                          "publishedAt": "2024-10-25T02:02:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We have a new time integrator for explicit maybe that will help enough?\nIt's called DirectCentralDifference\nWhat have you been using for time integration?\nThis might be minor I dont know",
                          "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-11081888",
                          "updatedAt": "2024-10-29T02:51:47Z",
                          "publishedAt": "2024-10-29T02:51:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud\nThanks, originally I used CentralDifference, with solve_type=lumped\nI will check this out and give you an update on performance\nbeen giving up on this a couple times already",
                          "url": "https://github.com/idaholab/moose/discussions/28849#discussioncomment-11081942",
                          "updatedAt": "2024-10-29T03:01:39Z",
                          "publishedAt": "2024-10-29T03:01:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Equations of States Methods Missing",
          "author": {
            "login": "JonathanEdelmanS"
          },
          "bodyText": "I am trying to simulate the flow of CO2 through a pipe, using CO2's properties instead of Helium in the example. Are these fluid properties being worked on to be made more complete?\nI would like to use this class, and before implementing the missing method myself I would like to know if anybody else is working on it, or otherwise if I do implement the method, how can I contribute that to MOOSE?\nWhen trying to run the code, I get the following error:\n`The fluid properties class 'CO2FluidProperties' has not implemented the method below. If your application requires this method, you must either implement it or use a different fluid properties class.\nvirtual Real SinglePhaseFluidProperties::e_from_p_rho(Real, Real) const`\nBelow is the .i file, which is modules/thermal_hydraulics/tutorials/single_phase_flow/01_flow_channel.i\nwhere I changed the fluid property from an IdealGasFluidProperties to a CO2FluidProperties:\nm_dot_in = 1e-2 # kg/s\npress = 10e5 # Pa\n\n[GlobalParams]\n  initial_p = ${press}\n  initial_vel = 0.0001\n  initial_T = ${T_in}\n  gravity_vector = '0 0 0'\n\n  rdg_slope_reconstruction = minmod\n  scaling_factor_1phase = '1 1e-2 1e-4'\n  closures = thm_closures\n  fp = he\n[]\n\n[FluidProperties]\n  [he]\n    type = CO2FluidProperties\n  []\n[]\n\n[Closures]\n  [thm_closures]\n    type = Closures1PhaseTHM\n  []\n[]\n\n[Components]\n  [inlet]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan:in'\n    m_dot = ${m_dot_in}\n    T = ${T_in}\n  []\n\n  [core_chan]\n    type = FlowChannel1Phase\n    position = '0 0 0'\n    orientation = '0 0 1'\n    length = 1\n    n_elems = 25\n    A = 7.2548e-3\n    D_h = 7.0636e-2\n  []\n\n  [outlet]\n    type = Outlet1Phase\n    input = 'core_chan:out'\n    p = ${press}\n  []\n[]\n\n[Postprocessors]\n  [core_p_in]\n    type = SideAverageValue\n    boundary = core_chan:in\n    variable = p\n  []\n\n  [core_p_out]\n    type = SideAverageValue\n    boundary = core_chan:out\n    variable = p\n  []\n\n  [core_delta_p]\n    type = ParsedPostprocessor\n    pp_names = 'core_p_in core_p_out'\n    expression = 'core_p_in - core_p_out'\n  []\n[]\n\n[Preconditioning]\n  [pc]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  line_search = basic\n\n  start_time = 0\n  end_time = 1000\n  dt = 10\n\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-8\n  nl_max_its = 25\n\n[]\n\n[Outputs]\n  exodus = true\n\n  [console]\n    type = Console\n    max_rows = 1\n    outlier_variable_norms = false\n  []\n  print_linear_residuals = false\n[]```",
          "url": "https://github.com/idaholab/moose/discussions/28920",
          "updatedAt": "2024-10-29T02:38:40Z",
          "publishedAt": "2024-10-23T21:18:32Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThese routines are implemented on a per need basis.\nFor co2 the better option here is to download the external fluid property submodule for carbon dioxide. See the website page for external FPS for more details",
                  "url": "https://github.com/idaholab/moose/discussions/28920#discussioncomment-11034707",
                  "updatedAt": "2024-10-23T23:27:47Z",
                  "publishedAt": "2024-10-23T23:27:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "JonathanEdelmanS"
                          },
                          "bodyText": "Thank you for your response!\nWe want to simulate that the CO2 is injected at the temperature of liquid storage and is pumped downhole so it reaches supercritical state at a depth of hundreds of meters. We want to detect phase changes or the formation of hydrates,  but we don't need to accurately model phase change, only detect possible phase changes from a default gas/supercritical state.\nWould these external fluid properties accurately model supercritical CO2?",
                          "url": "https://github.com/idaholab/moose/discussions/28920#discussioncomment-11056015",
                          "updatedAt": "2024-10-25T18:49:41Z",
                          "publishedAt": "2024-10-25T18:49:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the external CO2 fluid property module contains properties for both liquid and vapor CO2. I think it's your best bet\nhttps://github.com/idaholab/carbon_dioxide/tree/devel\nI'm not sure for supercritical. Is the HEM model good for that? What do you need that's different from a vapor model that's extended up to the condensation limit?",
                          "url": "https://github.com/idaholab/moose/discussions/28920#discussioncomment-11081813",
                          "updatedAt": "2024-10-29T02:38:41Z",
                          "publishedAt": "2024-10-29T02:38:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "I Get the Following Error When Performing Make -j 6 in the modules folder of MOOSE.",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\n\"MooseApp.C:1132:42: warning: ignoring returned value of type 'PetscErrorCode', declared with attribute 'nodiscard' [-Wunused-result]  1132 |     Moose::PetscSupport::petscSetupOutput(_command_line.get()); \"\n(Optional) code in question / simulation log / errors\nNo response\nEncountering Errors? Please include diagnostic output\nNo response",
          "url": "https://github.com/idaholab/moose/discussions/28934",
          "updatedAt": "2024-10-29T02:34:22Z",
          "publishedAt": "2024-10-25T19:10:08Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is just a warning.\nWe are fixing it in a coming PR. Thanks for reporting\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28934#discussioncomment-11081798",
                  "updatedAt": "2024-10-29T02:34:22Z",
                  "publishedAt": "2024-10-29T02:34:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Transferring Field Between FEM and FVM in MOOSE MultiApp Structure",
          "author": {
            "login": "mahdipasaie"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A Navier Stokes is the most appropriate category for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (avoid screenshots if possible, triple back quotes before/after pasted text, etc)\n\nI\u2019m working on a multi-physics example in MOOSE, where I\u2019m using the Finite Element Method (FEM) to solve the heat equation and the Finite Volume Method (FVM) to solve fluid flow.\nSo far, I\u2019ve successfully set up and solved:\n\nLid-driven cavity problem (in fluid_flow.i using FVM) for fluid flow.\nHeat conduction between a hot left wall and a cold right wall (in heat_conduction.i using FEM).\n\nI was able to transfer the velocity field from the FVM sub-app back to the FEM parent app using MOOSE\u2019s transfer system. This allowed me to compute the advection term in the heat equation accurately.\nNow, I\u2019m trying to transfer the temperature field T from the FEM parent app to an auxiliary field in the FVM sub-app, but I encounter an error.\nError Message:\nCannot find variable Tf for Ttrans Transfer\n\nwhere in the heat_conduction.i I have:\n  [./Ttrans]\n    type = MultiAppGeometricInterpolationTransfer\n    to_multi_app = fluid\n    source_variable = T\n    variable = Tf \n  [../]\n\nand in the fluid_flow.i (FVM ) file I have :\n[AuxVariables]\n [Tf]\n   # type = MooseVariableFVReal\n []\n[]\n\nTo provide more context, here\u2019s the GitHub repository with my setup:\nhttps://github.com/mahdipasaie/moose_coupled_heat_fluid.git.\nAny insights on the requirements or additional configurations for transferring fields between FEM and FVM apps in MOOSE would be greatly appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/28949",
          "updatedAt": "2024-10-29T02:16:15Z",
          "publishedAt": "2024-10-28T19:36:08Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "mahdipasaie"
                  },
                  "bodyText": "I had a syntax issue!  I fixed that and now is working.",
                  "url": "https://github.com/idaholab/moose/discussions/28949#discussioncomment-11081664",
                  "updatedAt": "2024-10-29T02:10:44Z",
                  "publishedAt": "2024-10-29T02:10:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}