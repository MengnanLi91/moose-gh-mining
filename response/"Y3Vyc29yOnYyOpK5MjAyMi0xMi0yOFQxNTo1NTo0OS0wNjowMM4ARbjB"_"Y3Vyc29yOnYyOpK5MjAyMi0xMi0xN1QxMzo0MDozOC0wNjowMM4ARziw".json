{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMi0xN1QxMzo0MDozOC0wNjowMM4ARziw"
    },
    "edges": [
      {
        "node": {
          "title": "Computing Updated J2stress from Updated  stress computed by RadialReturnstressUpdate",
          "author": {
            "login": "navier-rgb"
          },
          "bodyText": "Hello,\nIs it possible to call the updated stress (i.e., \u2018stress_new\u2019) already computed by the RadialReturnstressUpdate class into my child class? I\u2019m inheriting from RadialReturnCreepstressupdate, and I want to compute a \u2018J2\u2019 stress using this updated stress (stress_new). Any clue on how to go about this? These are part of my code:\nvirtual Real computeUpdatedJ2stress(GenericRankTwoTensor<is_ad>& stress_new);\ntemplate <bool is_ad>\nReal\ncreep2Templ<is_ad>::computeUpdatedJ2stress(GenericRankTwoTensor<is_ad>& stress_new)\n\n{\n    RankTwoTensor deviator_stress = stress_new.deviatoric();\n// compute the J2 stress\n  Real dev_stress_squared =\n      deviator_stress.doubleContraction(deviator_stress);\n\n  return  dev_stress_squared/2;\n}\n\nI\u2019m getting the following error:\nCreating Unity /home/dre11/MOOSE/projects/dracorex/build/unity_src/material_Unity.C\nCompiling C++ (in opt mode) /home/dre11/MOOSE/projects/dracorex/build/unity_src/material_Unity.C...\nIn file included from /home/dre11/mambaforge3/envs/moose/libmesh/include/libmesh/tensor_value.h:24,\n                 from /home/dre11/MOOSE/projects/moose/framework/build/header_symlinks/RankTwoTensor.h:22,\n                 from /home/dre11/MOOSE/projects/moose/framework/build/header_symlinks/DataIO.h:18,\n                 from /home/dre11/MOOSE/projects/moose/framework/build/header_symlinks/MaterialProperty.h:17,\n                 from /home/dre11/MOOSE/projects/moose/framework/build/header_symlinks/MaterialData.h:12,\n                 from /home/dre11/MOOSE/projects/moose/framework/build/header_symlinks/BlockRestrictable.h:15,\n                 from /home/dre11/MOOSE/projects/moose/framework/build/header_symlinks/MaterialBase.h:14,\n                 from /home/dre11/MOOSE/projects/moose/framework/build/header_symlinks/Material.h:13,\n                 from /home/dre11/MOOSE/projects/moose/modules/tensor_mechanics/build/header_symlinks/StressUpdateBase.h:14,\n                 from /home/dre11/MOOSE/projects/moose/modules/tensor_mechanics/build/header_symlinks/RadialReturnStressUpdate.h:12,\n                 from /home/dre11/MOOSE/projects/moose/modules/tensor_mechanics/build/header_symlinks/RadialReturnCreepStressUpdateBase.h:12,\n                 from /home/dre11/MOOSE/projects/dracorex/build/header_symlinks/HouLux.h:12,\n                 from /home/dre11/MOOSE/projects/dracorex/src/material/HouLux.C:10,\n                 from /home/dre11/MOOSE/projects/dracorex/build/unity_src/material_Unity.C:2:\n/home/dre11/mambaforge3/envs/moose/libmesh/include/libmesh/type_tensor.h: In instantiation of 'libMesh::TypeTensor<T>::TypeTensor(const libMesh::TypeTensor<T2>&) [with T2 = MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>; T = double]':\n/home/dre11/mambaforge3/envs/moose/libmesh/include/libmesh/tensor_value.h:262:19:   required from 'libMesh::TensorValue<T>::TensorValue(const libMesh::TensorValue<T2>&) [with T2 = MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>; T = double]'\n/home/dre11/MOOSE/projects/moose/framework/build/header_symlinks/RankTwoTensor.h:177:74:   required from 'RankTwoTensorTempl< <template-parameter-1-1> >::RankTwoTensorTempl(const RankTwoTensorTempl<T2>&) [with T2 = MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>; T = double]'\n/home/dre11/MOOSE/projects/dracorex/src/material/modLubby2.C:84:19:   required from 'libMesh::Real modLubby2Templ<is_ad>::computeUpdatedJ2stress(GenericRankTwoTensor<is_ad>&) [with bool is_ad = true; libMesh::Real = double; GenericRankTwoTensor<is_ad> = RankTwoTensorTempl<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >]'\n/home/dre11/MOOSE/projects/dracorex/src/material/modLubby2.C:220:16:   required from here\n/home/dre11/mambaforge3/envs/moose/libmesh/include/libmesh/type_tensor.h:627:27: error: cannot convert 'const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>' to 'double' in assignment\n  627 |     _coords[i] = p._coords[i];\n      |                  ~~~~~~~~~^\n      |                           |\n      |                           const MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>\nmake: *** [/home/dre11/MOOSE/projects/moose/framework/build.mk:145: /home/dre11/MOOSE/projects/dracorex/build/unity_src/material_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1",
          "url": "https://github.com/idaholab/moose/discussions/23036",
          "updatedAt": "2022-12-29T00:23:47Z",
          "publishedAt": "2022-12-28T20:19:24Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe error you are getting is simply about forbidding a conversion from an AD number to a regular number.\nYou ll need to change the lines mentioned\n/home/dre11/MOOSE/projects/dracorex/src/material/modLubby2.C:84:19:   required from 'libMesh::Real modLubby2Templ<is_ad>::computeUpdatedJ2stress(GenericRankTwoTensor<is_ad>&) [with bool is_ad = true; libMesh::Real = double; GenericRankTwoTensor<is_ad> = RankTwoTensorTempl<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >]'\n/home/dre11/MOOSE/projects/dracorex/src/material/modLubby2.C:220:16:   required from here\n\nto use AD numbers. It might be just writing ADReal instead of Real\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23036#discussioncomment-4510611",
                  "updatedAt": "2022-12-28T20:27:27Z",
                  "publishedAt": "2022-12-28T20:27:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "static schedule and dynamic schedule of multi-threading in moose",
          "author": {
            "login": "xiaoruiqi"
          },
          "bodyText": "I've found that the multi-threading used in moose is static scheduled, which becomes rather inefficient when the number of elements is not divisible by the number of threads. All of the additional elements will be assigned to the last thread. Is it possible to turn the static scheduled multi-threading to dynamic scheduled one?  @roystgnr",
          "url": "https://github.com/idaholab/moose/discussions/22987",
          "updatedAt": "2023-02-04T07:19:07Z",
          "publishedAt": "2022-12-16T12:42:54Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I think that imbalance gets smeared out as # elements >> # threads. Dynamic scheduling also comes with its own cost.",
                  "url": "https://github.com/idaholab/moose/discussions/22987#discussioncomment-4421420",
                  "updatedAt": "2022-12-16T13:18:30Z",
                  "publishedAt": "2022-12-16T13:18:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiaoruiqi"
                          },
                          "bodyText": "Dear hugary1995,\nI really agree with you, however, when # threads comes close to # elements, this imbalance will make great waste of CPU time, using dynamic scheduling should be a better choice. Could you please show me how to change the static scheduling to dynamic scheduling? I'm not very familiar with the source code at this point.",
                          "url": "https://github.com/idaholab/moose/discussions/22987#discussioncomment-4421706",
                          "updatedAt": "2022-12-16T13:55:00Z",
                          "publishedAt": "2022-12-16T13:54:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Search for Threads::parallel_reduce in FEProblemBase.C. The ranges are created by libmesh.\nI don't have opinions on how we should do this, and I guess I need to see some profiling results to convince myself that \"this imbalance will make greate waste of CPU time\", plus I don't think # threads ~= # elements is a typical use case anyways...\nTagging @roystgnr for his opinions on this.",
                          "url": "https://github.com/idaholab/moose/discussions/22987#discussioncomment-4423170",
                          "updatedAt": "2022-12-16T15:06:47Z",
                          "publishedAt": "2022-12-16T15:06:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "My understanding is that libmesh isn't set up with dynamic scheduling at all, but again @roystgnr may prove me wrong.\nAs a separate note, dynamic repartitioning is doable, although I don't think that's what you are after here.",
                          "url": "https://github.com/idaholab/moose/discussions/22987#discussioncomment-4423192",
                          "updatedAt": "2022-12-16T15:10:13Z",
                          "publishedAt": "2022-12-16T15:10:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiaoruiqi"
                          },
                          "bodyText": "Thanks for your information, I'll do some research on this problem.",
                          "url": "https://github.com/idaholab/moose/discussions/22987#discussioncomment-4423733",
                          "updatedAt": "2022-12-16T15:52:12Z",
                          "publishedAt": "2022-12-16T15:52:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you have so few elements that the number of threads is getting close, then it s likely enough to run in serial.",
                          "url": "https://github.com/idaholab/moose/discussions/22987#discussioncomment-4423985",
                          "updatedAt": "2022-12-16T16:00:27Z",
                          "publishedAt": "2022-12-16T16:00:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Scheduling should depend on your underlying threading model.  We don't do anything fancy at the libMesh level, but IIRC e.g. TBB will split a range into more sub-ranges than you have threads, and will hand off sub-ranges to whichever threads are ready for them as soon as they're ready, so even if your subranges aren't all equally expensive you'll still end up doing a roughly equal amount of work on each processor.  (\"roughly\" here hides ugly details, of course - make subranges too large and the split doesn't end up being as even, make them too small and overhead increases inversely with size, and I have no idea how TBB decides)\nI can't imagine any of this makes any difference when N_threads \u2248 N_elem, though.  Unless you're running a subscale model inside each element or something similarly expensive, just talking back and forth within a thread pool probably has enough overhead that you'd be better off not threading at all than trying to divide up work that finely.\nAll that said, \"All of the additional elements will be assigned to the last thread\" should almost never happen.  If we have N threads and N*Q+R (R<N) elements, even the most basic static split ought to be running Q+1 elements on each of R threads and Q on each of N-R, not Q+R on one thread and Q on N-1 threads.  If we can reproduce the former behavior, that's either a bug ... or, ironically, it could be caused by dynamic splitting, if the subrange size got chosen exceptionally poorly.",
                          "url": "https://github.com/idaholab/moose/discussions/22987#discussioncomment-4480025",
                          "updatedAt": "2022-12-22T23:01:42Z",
                          "publishedAt": "2022-12-22T23:01:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiaoruiqi"
                          },
                          "bodyText": "Yes, you're correct! I'm actually running a multi-scale simulation. And because the simulation inside each element is really computationally expensive, I can clearly observe through htop command that Q+R elements were handled by one thread.",
                          "url": "https://github.com/idaholab/moose/discussions/22987#discussioncomment-4481534",
                          "updatedAt": "2022-12-23T04:23:03Z",
                          "publishedAt": "2022-12-23T04:23:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Is your libMesh build using TBB or pthreads as the backend?  Could you post a stack trace?",
                          "url": "https://github.com/idaholab/moose/discussions/22987#discussioncomment-4505590",
                          "updatedAt": "2022-12-28T01:12:05Z",
                          "publishedAt": "2022-12-28T01:12:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to retrive the element number through which ray is passing in ray tracing module",
          "author": {
            "login": "an-singh"
          },
          "bodyText": "Hello friends,\nI want to do ray tracing through the geometry and retrive the list of element numbers  through which ray is passing for each ray in study.",
          "url": "https://github.com/idaholab/moose/discussions/22893",
          "updatedAt": "2023-02-04T07:19:35Z",
          "publishedAt": "2022-12-06T12:46:12Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont think we have that already made, though @loganharbour might know better\nI would make a new vector postprocessor that would have one vector for each ray and the vector would be filled with the element IDs.\nYou can look at https://mooseframework.inl.gov/moose/source/vectorpostprocessors/PerProcessorRayTracingResultsVectorPostprocessor.html\nfor inspiration.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22893#discussioncomment-4323408",
                  "updatedAt": "2022-12-06T14:03:14Z",
                  "publishedAt": "2022-12-06T14:03:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "an-singh"
                  },
                  "bodyText": "Hello GiudGiud,\nHow will it work with \"RepeatableRayStudy\" UserObject  for tracing the rays.",
                  "url": "https://github.com/idaholab/moose/discussions/22893#discussioncomment-4324068",
                  "updatedAt": "2022-12-06T15:10:03Z",
                  "publishedAt": "2022-12-06T15:10:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can try one of the examples in the page for the VPP\nIt should work in any ray tracing study.\nThe Ray can keep a lot of additional data that will help you backtrack which elements it crossed\nIn the study you will want to set always_cache_traces= true\nhttps://mooseframework.inl.gov/source/userobjects/RepeatableRayStudy.html",
                          "url": "https://github.com/idaholab/moose/discussions/22893#discussioncomment-4324400",
                          "updatedAt": "2022-12-06T16:27:56Z",
                          "publishedAt": "2022-12-06T15:44:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "an-singh"
                  },
                  "bodyText": "can you please specify which example is helpful in getting element ID during ray tracing ......",
                  "url": "https://github.com/idaholab/moose/discussions/22893#discussioncomment-4324810",
                  "updatedAt": "2022-12-06T16:25:21Z",
                  "publishedAt": "2022-12-06T16:25:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "as I mentioned, to the best of my knowledge this has not been done before.",
                          "url": "https://github.com/idaholab/moose/discussions/22893#discussioncomment-4324831",
                          "updatedAt": "2022-12-06T16:28:00Z",
                          "publishedAt": "2022-12-06T16:27:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "@an-singh can you please tell me what the purpose of doing this is?\nI can describe how you would go about doing this, but I would prefer to have a little more context first.",
                  "url": "https://github.com/idaholab/moose/discussions/22893#discussioncomment-4327777",
                  "updatedAt": "2022-12-06T23:30:05Z",
                  "publishedAt": "2022-12-06T23:30:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "an-singh"
                          },
                          "bodyText": "I have written a code to sove neutron transport equation using method of characteristics in fortran 90. To add more flexibility and design options in terms of geometry treatment and ray tracing I want to use moose framework. It will be very helpful in my research.",
                          "url": "https://github.com/idaholab/moose/discussions/22893#discussioncomment-4332255",
                          "updatedAt": "2022-12-07T11:59:44Z",
                          "publishedAt": "2022-12-07T11:59:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "an-singh"
                          },
                          "bodyText": "i am still waiting for your reply @loganharbour.",
                          "url": "https://github.com/idaholab/moose/discussions/22893#discussioncomment-4349029",
                          "updatedAt": "2022-12-09T05:11:38Z",
                          "publishedAt": "2022-12-09T05:11:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "an-singh"
                          },
                          "bodyText": "It is somewhat disheartening that I have not received a response after two weeks.",
                          "url": "https://github.com/idaholab/moose/discussions/22893#discussioncomment-4497560",
                          "updatedAt": "2022-12-26T12:41:06Z",
                          "publishedAt": "2022-12-26T12:41:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error in using advanced restart",
          "author": {
            "login": "DYLDYLDYL"
          },
          "bodyText": "Hi!\nI want to use advanced restart.  But when I  set file = _out.e, it will still start at time step 1. So I wonder how to set file and restart_file_base.\n[Mesh]\n  file = out_cp/0010_mesh.cpr    \n  distribution = serial    ## it shows \"unused parameter 'Mesh/distribution' \"\n[]\n[Problem]\n  restart_file_base = out_cp/LATEST \n[]\n\nThanks in advance for your help!",
          "url": "https://github.com/idaholab/moose/discussions/22941",
          "updatedAt": "2023-01-03T23:46:29Z",
          "publishedAt": "2022-12-12T14:36:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou should be able to use the original mesh file in [Mesh] and then just set the restart_file_base to LATEST and get the latest time step.\nNote that it will start counting at time step 1 regardless. But the initial condition will be from the latest in the file\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22941#discussioncomment-4380496",
                  "updatedAt": "2022-12-12T16:14:50Z",
                  "publishedAt": "2022-12-12T16:14:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "DYLDYLDYL"
                          },
                          "bodyText": "Thanks\uff01\nI use the original mesh file and restart_file_base = test_out/0008, it shows 'Unable to open file test_out/0008.rd-0'.\nIf restart_file_base = test_out, it shows 'Unable to open file test_out.rd-0'.\ntest_out.e is my ofiginal output, it has run 8 time steps.",
                          "url": "https://github.com/idaholab/moose/discussions/22941#discussioncomment-4386794",
                          "updatedAt": "2022-12-13T07:20:01Z",
                          "publishedAt": "2022-12-13T07:20:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is why it s easiest to just specify latest after the folder name.",
                          "url": "https://github.com/idaholab/moose/discussions/22941#discussioncomment-4387187",
                          "updatedAt": "2022-12-13T08:22:47Z",
                          "publishedAt": "2022-12-13T08:22:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you dont want to use latest, this is the syntax\nrestart_file_base = system_1d_checkpoint_cp/1179\nsystem_1d_checkpoint_cp is the folder where the restart files got saved",
                          "url": "https://github.com/idaholab/moose/discussions/22941#discussioncomment-4390354",
                          "updatedAt": "2022-12-13T13:51:03Z",
                          "publishedAt": "2022-12-13T13:51:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "DYLDYLDYL"
                          },
                          "bodyText": "Thanks!\nIs 1179 a time step\uff1f",
                          "url": "https://github.com/idaholab/moose/discussions/22941#discussioncomment-4490236",
                          "updatedAt": "2022-12-24T09:55:04Z",
                          "publishedAt": "2022-12-24T09:55:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes. 1179 was the timestep of interest for my simulation",
                          "url": "https://github.com/idaholab/moose/discussions/22941#discussioncomment-4490475",
                          "updatedAt": "2022-12-24T11:26:02Z",
                          "publishedAt": "2022-12-24T11:26:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "DYLDYLDYL"
                          },
                          "bodyText": "Thanks\uff01",
                          "url": "https://github.com/idaholab/moose/discussions/22941#discussioncomment-4496713",
                          "updatedAt": "2022-12-26T08:43:14Z",
                          "publishedAt": "2022-12-26T08:43:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "error: no matching function for call to 'FEProblemBase::assembly(THREAD_ID&, int)",
          "author": {
            "login": "batodon"
          },
          "bodyText": "Hello,\nI\u2019m assigning a THREAD_ID typedef to some variables (_curr_node and _curr_element), but I keep getting the following no matching function call when I try to compile. Could you please help?\n/home/batodon/MOOSE/projects/ergs/src/materials/PFEMBase.C:94:38: error: no matching function for call to 'FEProblemBase::assembly(THREAD_ID&, int)'\n   94 |     _curr_node(problem.assembly(tid,0).node()),\n      |                                      ^\nIn file included from /home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/UserObjectInterface.h:14,\n                 from /home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/MaterialBase.h:21,\n                 from /home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/Material.h:13,\n                 from /home/batodon/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowMaterial.h:12,\n                 from /home/batodon/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowMaterialVectorBase.h:12,\n                 from /home/batodon/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowPermeabilityBase.h:12,\n                 from /home/batodon/MOOSE/projects/ergs/build/header_symlinks/PFEMBase.h:3,\n                 from /home/batodon/MOOSE/projects/ergs/src/materials/PFEMBase.C:1,\n                 from /home/batodon/MOOSE/projects/ergs/build/unity_src/materials_Unity.C:2:\n/home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/FEProblemBase.h:330:14: note: candidate: 'virtual Assembly& FEProblemBase::assembly(THREAD_ID)'\n  330 |   Assembly & assembly(THREAD_ID tid) override\n      |              ^~~~~~~~\n/home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/FEProblemBase.h:330:14: note:   candidate expects 1 argument, 2 provided\n/home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/FEProblemBase.h:335:20: note: candidate: 'virtual const Assembly& FEProblemBase::assembly(THREAD_ID) const'\n  335 |   const Assembly & assembly(THREAD_ID tid) const override\n      |                    ^~~~~~~~\n/home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/FEProblemBase.h:335:20: note:   candidate expects 1 argument, 2 provided\nIn file included from /home/batodon/MOOSE/projects/ergs/build/unity_src/materials_Unity.C:2:\n/home/batodon/MOOSE/projects/ergs/src/materials/PFEMBase.C:95:41: error: no matching function for call to 'FEProblemBase::assembly(THREAD_ID&, int)'\n   95 |     _curr_element(problem.assembly(tid,0).elem()),\n\nHere is my declaration:\n\t  FEProblemBase & problem;\n\t  THREAD_ID tid;\n\nAnd part of my destructor:\n    problem(*getCheckedPointerParam<FEProblemBase *>(\"_fe_problem_base\")),\n    tid(getParam<THREAD_ID>(\"_tid\")),\n    _curr_node(problem.assembly(tid,0).node()),\n    _curr_element(problem.assembly(tid,0).elem()),\n\nThe problem seems to come from the arguments to _curr_node and _curr_element. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/22996",
          "updatedAt": "2022-12-23T22:00:14Z",
          "publishedAt": "2022-12-20T16:22:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think you just need problem.assembly(tid), no 0\nWhat does that return ?",
                  "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4460607",
                  "updatedAt": "2022-12-20T16:45:57Z",
                  "publishedAt": "2022-12-20T16:45:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Thanks, @GiudGiud. I already tried it. It compiled but I had a segmentation fault when I run my input file.",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4460631",
                          "updatedAt": "2022-12-20T16:48:40Z",
                          "publishedAt": "2022-12-20T16:48:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it might not come from that though\ncan you run this in a debugger\nhttps://mooseframework.inl.gov/application_development/debugging.html",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4460715",
                          "updatedAt": "2022-12-20T17:00:56Z",
                          "publishedAt": "2022-12-20T17:00:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Hi @GiudGiud. Any help? I hit a 'virtual memory exhausted' when building in a dbg mode:\n{standard input}: virtual memory exhausted: Cannot allocate memory\nvirtual memory exhausted: Cannot allocate memory\nvirtual memory exhausted: Cannot allocate memory\nAssembler messages:\n{standard input}:709029: Fatal error: bfd_make_empty_symbol: memory exhausted\n{standard input}:709029: Fatal error: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/.libs/userobjects_Unity.x86_64-conda-linux-gnu.dbg.o: memory exhausted\nvirtual memory exhausted: Cannot allocate memory\nvirtual memory exhausted: Cannot allocate memory\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/materials_lagrangian_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1\nmake: *** Waiting for unfinished jobs....\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/userobjects_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/materials_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/materials_cohesive_zone_model_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/materials_crystal_plasticity_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1\nmake: *** [/home/batodon/MOOSE/projects/moose/framework/build.mk:144: /home/batodon/MOOSE/projects/moose/modules/tensor_mechanics/build/unity_src/bcs_Unity.x86_64-conda-linux-gnu.dbg.lo] Error 1",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4461253",
                          "updatedAt": "2022-12-20T18:21:18Z",
                          "publishedAt": "2022-12-20T18:16:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you build with a single process?\nMETHOD=dbg make -j 1",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4461270",
                          "updatedAt": "2022-12-20T18:19:52Z",
                          "publishedAt": "2022-12-20T18:19:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Not quite sure if I'm getting the correct backtrace, but here is the error from debugging. I can't find the location (to either the header/src file) for my problem.\n*** ERROR ***\n\nStack frames: 7\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)\n2: void mooseError<char const*>(char const*&&)\n3: MooseApp::run()\n4: main\n5: __libc_start_main\n6: /home/batodon/MOOSE/projects/ergs/ergs-dbg(+0x3079) [0x555555557079]\n\nThread 1 \"ergs-dbg\" hit Breakpoint 1, 0x00007fffea061cc0 in PMPI_Abort () from /home/batodon/mambaforge3/envs/moose/lib/libmpi.so.12\n(gdb) bt\n#0  0x00007fffea061cc0 in PMPI_Abort () from /home/batodon/mambaforge3/envs/moose/lib/libmpi.so.12\n#1  0x00007ffff4a75bab in moose::internal::mooseErrorRaw (msg=..., prefix=...)\n    at /home/batodon/MOOSE/projects/moose/framework/src/base/MooseError.C:83\n#2  0x00007ffff5f21ff5 in mooseError<char const*> () at /home/batodon/MOOSE/projects/moose/framework/build/header_symlinks/MooseError.h:258\n#3  0x00007ffff4a165a9 in MooseApp::run (this=0x5555557474a0) at /home/batodon/MOOSE/projects/moose/framework/src/base/MooseApp.C:1406\n#4  0x0000555555557739 in main (argc=3, argv=0x7fffffffbed8) at /home/batodon/MOOSE/projects/ergs/src/main.C:33",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4461480",
                          "updatedAt": "2022-12-20T18:50:19Z",
                          "publishedAt": "2022-12-20T18:50:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This error with no message is often a libmesh error.\nThe backtrace shows line 1406 in the mooseApp file\nWhat is it for your current moose version?\nFor me it s the errorCheck, but for you it might be something else",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4462029",
                          "updatedAt": "2022-12-20T20:26:10Z",
                          "publishedAt": "2022-12-20T20:26:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Thanks @GiudGiud. This is what I have on line 1406 of mooseApp.C file:\nmooseError(err.what());",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4462108",
                          "updatedAt": "2022-12-20T20:42:45Z",
                          "publishedAt": "2022-12-20T20:42:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok so an initialSetup() is failing with a libmesh_error and it s being caught there/\nYou ll need to set a breakpoint on libmesh_error, then generate a backtrace there",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4462116",
                          "updatedAt": "2022-12-20T20:46:20Z",
                          "publishedAt": "2022-12-20T20:46:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Sorry, I got  No stack.  as  backtrace after setting a breakpoint on libmesh_error.",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4462148",
                          "updatedAt": "2022-12-20T21:09:38Z",
                          "publishedAt": "2022-12-20T20:54:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you ll need to catch the breakpoint to have a stack.\nno stock means it ran to completion",
                          "url": "https://github.com/idaholab/moose/discussions/22996#discussioncomment-4462205",
                          "updatedAt": "2022-12-20T21:04:59Z",
                          "publishedAt": "2022-12-20T21:04:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fracture propagation in natural fractured reservoir",
          "author": {
            "login": "miraboreasumr"
          },
          "bodyText": "Hello,\nI have a naturally fractured reservoir, and I have the location of the natural fractures (EDFM?)\nWhat are the modules I should learn if I want to study the natural fracture propagation while injecting fluid into the fractures?",
          "url": "https://github.com/idaholab/moose/discussions/23017",
          "updatedAt": "2023-01-03T23:46:48Z",
          "publishedAt": "2022-12-22T16:45:27Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "For reservoir modeling, you want to look at porous_flow ( https://mooseframework.inl.gov/modules/porous_flow/index.html ). They have a few examples of flow through fractures, see https://mooseframework.inl.gov/modules/porous_flow/flow_through_fractured_media.html.\nhttps://mooseframework.inl.gov/modules/porous_flow/multiapp_fracture_flow_PorousFlow_3D.html might be closest approach to the EDFM approach you mentioned. However, I do not think that is capable of modeling fracture propagation yet.",
                  "url": "https://github.com/idaholab/moose/discussions/23017#discussioncomment-4477475",
                  "updatedAt": "2022-12-22T17:05:44Z",
                  "publishedAt": "2022-12-22T17:05:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "miraboreasumr"
                          },
                          "bodyText": "So no way to do fracture propagation?",
                          "url": "https://github.com/idaholab/moose/discussions/23017#discussioncomment-4477510",
                          "updatedAt": "2022-12-22T17:08:34Z",
                          "publishedAt": "2022-12-22T17:08:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Which methods do you want to use for fracture propagation? Does EDFM support crack propagation? I am working on the implementation of a phase-field fracture models for hydraulic fracturing within porous flow module. Is that something you are interested in? I might be able to have it ready in January.",
                          "url": "https://github.com/idaholab/moose/discussions/23017#discussioncomment-4478377",
                          "updatedAt": "2022-12-22T18:30:16Z",
                          "publishedAt": "2022-12-22T18:30:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "miraboreasumr"
                          },
                          "bodyText": "Thanks for the reply. EDFM+XFEM (Extended finite element method) can do fracture propagation. If your phase-field models can handle when there are natural fractures (EDFM or inner boundary?), and propagation, I will be interested in it.",
                          "url": "https://github.com/idaholab/moose/discussions/23017#discussioncomment-4480347",
                          "updatedAt": "2022-12-23T00:21:15Z",
                          "publishedAt": "2022-12-23T00:21:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stress based damage model",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello MOOSE Experts,\nI want to implement a simple stress based damage model for my simulation.\nFor example,\nif von-Mises stress for any element >= threshold value\ndamage =1\nelse\ndamage=0\nend\nCan you please locate me a suitable example to do so?\nI shall be very thankful.\nBest,\nAvtar",
          "url": "https://github.com/idaholab/moose/discussions/23013",
          "updatedAt": "2023-06-24T19:55:00Z",
          "publishedAt": "2022-12-22T07:10:35Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you looking at cracking?\nStress thresholds are used for some of the models there, you could take a look\nhttps://mooseframework.inl.gov/moose/source/materials/ComputeSmearedCrackingStress.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23013#discussioncomment-4476467",
                  "updatedAt": "2022-12-22T15:05:43Z",
                  "publishedAt": "2022-12-22T15:05:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "And also look at DamageBase class.",
                          "url": "https://github.com/idaholab/moose/discussions/23013#discussioncomment-4477495",
                          "updatedAt": "2022-12-22T17:07:08Z",
                          "publishedAt": "2022-12-22T17:07:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Compiling libmesh with vtk",
          "author": {
            "login": "drebbel1z"
          },
          "bodyText": "I am trying to install libmesh with vtk.\nI have been able to install vtk from source,  but when I input \"./scripts/update_and_rebuild_libmesh.sh --with-vtk-lib=/projects/vtk_install/lib64 --with-vtk-include=/projects/vtk_install/include/vtk-9.2\"  into the terminal, the installation still proceeds without vtk (See below)\nchecking ~/projects/vtk_install/include/vtk-9.2/vtkConfigure.h usability... no\nchecking ~/projects/vtk_install/include/vtk-9.2/vtkConfigure.h presence... no\nchecking for ~/projects/vtk_install/include/vtk-9.2/vtkConfigure.h... no\nVTK header files not found!\n<<< Configuring library without VTK support >>>\n\nI checked the named folder and there is no vtkConfigure.h present. I however found vtkPythonConfigure.h. Are these related?\nHow do I fix this and be able to compile libmesh with vtk?\nI already found this site: https://groups.google.com/g/moose-users/c/Kb6s_LWcEnU\nIt helped me with installing vtk, but I am currently stuck.\nI configured vtk using\ncmake  -DCMAKE_INSTALL_PREFIX=~/projects/vtk_install -DCMAKE_BUILD_TYPE=Release -DVTK_Group_Rendering=OFF -DVTK_WRAP_PYTHON=ON -Wno-dev $HOME/projects/vtk\nas suggested by the site.",
          "url": "https://github.com/idaholab/moose/discussions/22975",
          "updatedAt": "2023-02-04T07:19:55Z",
          "publishedAt": "2022-12-15T21:20:05Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "drebbel1z"
                  },
                  "bodyText": "@GiudGiud, any help?",
                  "url": "https://github.com/idaholab/moose/discussions/22975#discussioncomment-4435416",
                  "updatedAt": "2022-12-17T05:30:28Z",
                  "publishedAt": "2022-12-17T05:30:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\n@milljm knows these things better than I do\nWhy did you pass -Wno-dev to the vtk install?\nSo this is on a cluster right, you are not using conda anywhere? I d probably just download VTK in a conda environment with just that\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22975#discussioncomment-4437208",
                          "updatedAt": "2022-12-17T11:26:58Z",
                          "publishedAt": "2022-12-17T11:26:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "doquang"
                          },
                          "bodyText": "libmesh requires a VTK which MPI supported. Have you compile your VTK with option -DVTK_USE_MPI:BOOL=ON ?",
                          "url": "https://github.com/idaholab/moose/discussions/22975#discussioncomment-4437238",
                          "updatedAt": "2022-12-17T11:36:34Z",
                          "publishedAt": "2022-12-17T11:36:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "drebbel1z"
                          },
                          "bodyText": "@doquang  I just did. I still can't find the vtkConfigure.h file in the include directory\n@GiudGiud I tried the conda installation but I have not had much luck with that. That is why I installed vtk separately. wrt to the conda installation, it compiles and builds fine, except for this warning: unsupported GNU_PROPERTY_TYPE. And none of the tests pass.",
                          "url": "https://github.com/idaholab/moose/discussions/22975#discussioncomment-4437780",
                          "updatedAt": "2022-12-17T14:12:31Z",
                          "publishedAt": "2022-12-17T14:12:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I would not use ~/... use absolute paths to your vtk/lib and vtk/include/vtk-<version> directories. Some times ~ are treated as literal characters...",
                          "url": "https://github.com/idaholab/moose/discussions/22975#discussioncomment-4450439",
                          "updatedAt": "2022-12-19T16:19:55Z",
                          "publishedAt": "2022-12-19T16:19:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Maybe there are some bugs in navier stokes modules",
          "author": {
            "login": "suqingji"
          },
          "bodyText": "Dear developers,\nI am developing the RANS k-omega turbulence model based on MOOSE FEM. Now my k-omega codes can be used to simulate some simple cases. But in other complex cases, the convergence of the code is difficult. So I find some bugs(maybe which is a normal phenomenon but I think it is abnormal) in laminar simulation when I debug my turbulence codes.\nHere is the list about the bugs(Please allow me to call it a bug).\n\nIn a 3D-lid-driven test case, I found that the convergence progress is different on different scale grid unless the variables are scaled.\n\nfor example,\nIf I change the L  params by multiplying factor 1000 with type = TransformGenerator, at the same time  I change the \\mu(Dynamic viscosity)  params by multiplying factor 1000, so the Reynolds number and Euler number are the same. And I also make time step dt becoming 1000 times. So the Strauhal number is the same, too. In other words, the above two problems are the same. So that the convergence progress should be the same in theory. But It is amazing to me that the convergence progress is different.\nMaybe you will tell me that it does not matter. But in fact in complex problems especially in Thermal Hydraulics, the problem may become  Solve Did NOT Converge!\n\n\ntips: In the above problem, I use AD rather than by hand to compute Jacobian.\n\nAlso in a 3D-lid-driven test case\n\nNow I use by hand rather than AD to compute Jacobian. And the conditions are exactly the same as list 1. So that the solution should be the same in theory. And the converge or not converge should be the same in theory. But It is amazing to me that the convergence is different. In AD the problem is converged but in by hand the problem is not converged. If I change the SUPG/PSPG params alpha in the input file the problem becomes converged. Those are unbelievable.\nIt sounds crazy, and it doesn't make sense in theory, but I've actually found these problems, so it feels like some bugs to me.\nBest regards.\nQINGJI SU",
          "url": "https://github.com/idaholab/moose/discussions/21996",
          "updatedAt": "2022-12-18T20:58:20Z",
          "publishedAt": "2022-09-02T09:34:28Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "I would have to see the hand-coded and AD inputs in order to understand why you are getting different behavior between the two cases.\nRegarding the scaling ... I believe what you are seeing there is a consequence of the fact that degrees of freedom controlled by Dirichlet boundary conditions are included in the nonlinear system. So as you scale your physics rows, your Dirichlet rows remain unscaled and so you have different operators",
                  "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3539420",
                  "updatedAt": "2022-09-02T18:52:15Z",
                  "publishedAt": "2022-09-02T18:52:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "A way to circumvent this is to apply scaling to the physics rows. You can either supply it manually to Variables sub-blocks via the scaling parameter, or you can use automatic_scaling in the Executioner block:\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  # Run for 100+ timesteps to reach steady state.                                                                     \n  num_steps = 1\n  dt = 0.5\n  dtmin = 0.5\n  petsc_options_iname = '-pc_type -sub_pc_factor_levels -ksp_gmres_restart'\n  petsc_options_value = 'asm      6                     200'\n  line_search = 'none'\n  nl_rel_tol = 1e-12\n  nl_abs_tol = 1e-13\n  nl_max_its = 6\n  automatic_scaling = true\n  verbose = true\n  off_diagonals_in_auto_scaling = true\n[]\n\nThe last parameter off_diagonals_in_auto_scaling is important since the pressure equation has zero (or potentially small if doing PSPG) on-diagonals. So for instance I ran an INS cavity simulation with no scaling of dt/h/mu and then a simulation in which I scaled dt/h/mu by 10, and these are the convergence histories using automatic scaling of the physics rows:\nh/mu/dt scaled by 10\nTime Step 0, time = 0\n\nTime Step 1, time = 5\n          old time = 0\n                dt = 5\n            old dt = 5\n\n\nPerforming automatic scaling calculation\n\nAutomatic scaling factors:\n  velocity: 0.00830258\n  p: 0.03\n\n\n 0 Nonlinear |R| = 1.457738e+00\n      0 Linear |R| = 1.457738e+00\n      1 Linear |R| = 5.039948e-17\n 1 Nonlinear |R| = 5.679814e-03\n      0 Linear |R| = 5.679814e-03\n      1 Linear |R| = 1.589405e-18\n 2 Nonlinear |R| = 7.112778e-08\n      0 Linear |R| = 7.112778e-08\n      1 Linear |R| = 1.398928e-23\n 3 Nonlinear |R| = 8.071238e-17\n Solve Converged!\n\nh/mu/dt scaled by 1\nTime Step 0, time = 0\n\nTime Step 1, time = 0.5\n          old time = 0\n                dt = 0.5\n            old dt = 0.5\n\n\nPerforming automatic scaling calculation\n\nAutomatic scaling factors:\n  velocity: 0.0830258\n  p: 0.3\n\n\n 0 Nonlinear |R| = 1.457738e+00\n      0 Linear |R| = 1.457738e+00\n      1 Linear |R| = 8.947181e-17\n 1 Nonlinear |R| = 5.679814e-03\n      0 Linear |R| = 5.679814e-03\n      1 Linear |R| = 1.280724e-18\n 2 Nonlinear |R| = 7.112778e-08\n      0 Linear |R| = 7.112778e-08\n      1 Linear |R| = 1.370400e-23\n 3 Nonlinear |R| = 4.196560e-17\n Solve Converged!\n\nYou can see that with the scaling, the resulting solves are identical",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3540334",
                          "updatedAt": "2022-09-02T22:09:48Z",
                          "publishedAt": "2022-09-02T22:08:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Hi @lindsayad,\nThank you for your reply.\nYour opinion is right about the first problem. However, there is another question about the first problem.\nIn a complex problem,  there is a linear solver error after using automatic_scaling = true.\n\nIf I remove the code of automatic_scaling = true, the problem could be solved. That is a strange phenomenon. Therefore I hardly use automatic_scaling = true. But I must admit that in some problems the problem convergence progress becomes better if I use automatic_scaling = true.  So I am very tangled if I should use automatic_scaling = true.\nBest regrads.\nQINGJI SU",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3541933",
                          "updatedAt": "2022-09-03T09:57:49Z",
                          "publishedAt": "2022-09-03T09:51:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "About the second problem, Here are my test case input files.\nAD:\nconst_num = 1.e0\nconst_dt = 1.e-1\nconst_mu = ${const_num}\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    xmin = 0\n    xmax = ${const_num}\n    ymin = 0\n    ymax = ${const_num}\n    zmin = 0\n    zmax = ${const_num}\n    nx = 10\n    ny = 10\n    nz = 10\n  []\n  [./corner_node]\n    type = ExtraNodesetGenerator\n    new_boundary = 'pinned_node'\n    nodes = '0'\n    input = gen\n  [../]\n[]\n[Variables]\n  [./velocity]\n    family = LAGRANGE_VEC\n  [../]\n  [./p]\n  [../]\n[]\n[ICs]\n  [velocity]\n    type = VectorConstantIC\n    x_value = 1e-15\n    y_value = 1e-15\n    variable = velocity\n  []\n[]\n[Kernels]\n  [./mass]\n    type = INSADMass\n    variable = p\n  [../]\n  [./mass_pspg]\n    type = INSADMassPSPG\n    variable = p\n  [../]\n  [./momentum_time]\n    type = INSADMomentumTimeDerivative\n    variable = velocity\n  [../]\n  [./momentum_convection]\n    type = INSADMomentumAdvection\n    variable = velocity\n  [../]\n  [./momentum_viscous]\n    type = INSADMomentumViscous\n    variable = velocity\n  [../]\n  [./momentum_pressure]\n    type = INSADMomentumPressure\n    variable = velocity\n    pressure = p\n    integrate_p_by_parts = true\n  [../]\n  [./momentum_supg]\n    type = INSADMomentumSUPG\n    variable = velocity\n    velocity = velocity\n  [../]\n[]\n[BCs]\n  [./no_slip]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'bottom right left front back'\n  [../]\n  [./lid]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'top'\n    function_x = '1'\n  [../]\n  [./pressure_pin]\n    type = DirichletBC\n    variable = p\n    boundary = 'pinned_node'\n    value = 0\n  [../]\n[]\n[Materials]\n  [./const]\n    type = ADGenericConstantMaterial\n    prop_names = 'rho      mu                 cp k'\n    prop_values = '1e4     ${const_mu}       1  1e4'\n  [../]\n  [ins_mat]\n    type = INSADTauMaterial\n    velocity = velocity\n    pressure = p\n    alpha = 1\n  []\n[]\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  num_steps = 1\n  dt = ${const_dt}\n  petsc_options_iname = '-pc_type -sub_pc_factor_levels -ksp_gmres_restart'\n  petsc_options_value = 'lu      2                     200'\n  line_search = 'none'\n  nl_rel_tol = 1e-4\n  nl_abs_tol =  1e-7\n  nl_max_its = 60\n  automatic_scaling = true\n  verbose = true\n  off_diagonals_in_auto_scaling = true\n[]\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]\n\nno AD rather than by hand:\nconst_num = 1.\nconst_dt = 1.e-1\n# const_scaling = 1e0\n\nvel_x = vel_x\nvel_y = vel_y\nvel_z = vel_z\npressure = p\n[GlobalParams]\n  pspg = true\n  supg = true\n  u = vel_x\n  v = vel_y\n  w = vel_z\n  pressure = p\n  integrate_p_by_parts = true\n  alpha = 1\n[]\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    xmin = 0\n    xmax = ${const_num}\n    ymin = 0\n    ymax = ${const_num}\n    zmin = 0\n    zmax = ${const_num}\n    nx = 10\n    ny = 10\n    nz = 10\n  []\n  [./corner_node]\n    type = ExtraNodesetGenerator\n    new_boundary = 'pinned_node'\n    nodes = '0'\n    input = gen\n  [../]\n[]\n\n[Variables]\n  [./vel_x]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./vel_y]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./vel_z]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./p]\n    # scaling = ${const_scaling}\n  [../]\n[]\n\n[Kernels]\n  [mass]\n    type = INSMass\n    variable = p\n  []\n  # x-momentum, time\n  [x_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_x}\n  []\n  # x-momentum, space\n  [x_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_x}\n    component = 0\n  []\n  # y-momentum, time\n  [y_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_y}\n  []\n  # y-momentum, space\n  [y_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_y}\n    component = 1\n  []\n  # z-momentum, time\n  [z_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_z}\n  []\n  # z-momentum, space\n  [z_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_z}\n    component = 2\n  []\n[]\n\n[BCs]\n  [no_slip_x]\n    type = DirichletBC\n    variable = ${vel_x}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [no_slip_y]\n    type = DirichletBC\n    variable = ${vel_y}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [no_slip_z]\n    type = DirichletBC\n    variable = ${vel_z}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [./lid_x]\n    type = DirichletBC\n    variable = ${vel_x}\n    boundary = 'top'\n    value = 1.\n  [../]\n  [./lid_y]\n    type = DirichletBC\n    variable = ${vel_y}\n    boundary = 'top'\n    value = 0.\n  [../]\n  [./lid_z]\n    type = DirichletBC\n    variable = ${vel_z}\n    boundary = 'top'\n    value = 0.\n  [../]\n\n  [./pressure_pin]\n    type = DirichletBC\n    variable = ${pressure}\n    boundary = 'pinned_node'\n    value = 0\n  [../]\n[]\n\n[Materials]\n  [./const]\n    type = GenericConstantMaterial\n    prop_names = 'rho      mu               '\n    prop_values = '1e4     ${const_num}     '\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  num_steps = 1\n  dt = ${const_dt}\n  petsc_options_iname = '-pc_type -sub_pc_factor_levels -ksp_gmres_restart'\n  petsc_options_value = 'lu       2                     200'\n  line_search = 'none'\n  nl_rel_tol = 1e-4\n  nl_abs_tol =  1e-7\n  nl_max_its = 60\n\n  automatic_scaling = true\n  verbose = true\n  off_diagonals_in_auto_scaling = true\n[]\n\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]\n\n# [Debug]\n#   show_var_residual_norms = true\n# []\n\n\nThe AD and by hand codes in the Navier-stokes module have been checked by me. But I have not found the bugs' reason.\nThanks,\nQINGJI SU",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3541966",
                          "updatedAt": "2022-09-03T10:08:06Z",
                          "publishedAt": "2022-09-03T10:08:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "This hand-coded input version converges about as well as the AD version. The changes were\n\nscaling grouping for velocity variables (this happens naturally for the vector velocity variable used in AD)\nsetting preset = false which applies to the Dirichlet boundary conditions. Vector Dirichlet boundary conditions do not have the preset option, e.g. they are never preset, whereas preset = true is the default for non-vector Dirichlet boundary conditions\nsetting transient_term = true in the GlobalParams block. This adds the transient term into the strong residual used for SUPG and PSPG. This happens automatically for AD\n\nconst_num = 1.\nconst_dt = 1.e-1\n# const_scaling = 1e0\n\nvel_x = vel_x\nvel_y = vel_y\nvel_z = vel_z\npressure = p\n[GlobalParams]\n  pspg = true\n  supg = true\n  u = vel_x\n  v = vel_y\n  w = vel_z\n  pressure = p\n  integrate_p_by_parts = true\n  alpha = 1\n  transient_term = true\n  preset = false\n[]\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    xmin = 0\n    xmax = ${const_num}\n    ymin = 0\n    ymax = ${const_num}\n    zmin = 0\n    zmax = ${const_num}\n    nx = 10\n    ny = 10\n    nz = 10\n  []\n  [./corner_node]\n    type = ExtraNodesetGenerator\n    new_boundary = 'pinned_node'\n    nodes = '0'\n    input = gen\n  [../]\n[]\n\n[Variables]\n  [./vel_x]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./vel_y]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./vel_z]\n    # scaling = ${const_scaling}\n    [InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    []\n  [../]\n  [./p]\n    # scaling = ${const_scaling}\n  [../]\n[]\n\n[Kernels]\n  [mass]\n    type = INSMass\n    variable = p\n  []\n  # x-momentum, time\n  [x_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_x}\n  []\n  # x-momentum, space\n  [x_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_x}\n    component = 0\n  []\n  # y-momentum, time\n  [y_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_y}\n  []\n  # y-momentum, space\n  [y_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_y}\n    component = 1\n  []\n  # z-momentum, time\n  [z_momentum_time]\n    type = INSMomentumTimeDerivative\n    variable = ${vel_z}\n  []\n  # z-momentum, space\n  [z_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = ${vel_z}\n    component = 2\n  []\n[]\n\n[BCs]\n  [no_slip_x]\n    type = DirichletBC\n    variable = ${vel_x}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [no_slip_y]\n    type = DirichletBC\n    variable = ${vel_y}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [no_slip_z]\n    type = DirichletBC\n    variable = ${vel_z}\n    boundary = 'bottom right left front back'\n    value = 0.\n  []\n  [./lid_x]\n    type = DirichletBC\n    variable = ${vel_x}\n    boundary = 'top'\n    value = 1.\n  [../]\n  [./lid_y]\n    type = DirichletBC\n    variable = ${vel_y}\n    boundary = 'top'\n    value = 0.\n  [../]\n  [./lid_z]\n    type = DirichletBC\n    variable = ${vel_z}\n    boundary = 'top'\n    value = 0.\n  [../]\n\n  [./pressure_pin]\n    type = DirichletBC\n    variable = ${pressure}\n    boundary = 'pinned_node'\n    value = 0\n  [../]\n[]\n\n[Materials]\n  [./const]\n    type = GenericConstantMaterial\n    prop_names = 'rho      mu               '\n    prop_values = '1e4     ${const_num}     '\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  num_steps = 1\n  dt = ${const_dt}\n  petsc_options_iname = '-pc_type -sub_pc_factor_levels -ksp_gmres_restart'\n  petsc_options_value = 'lu       2                     200'\n  line_search = 'none'\n  nl_rel_tol = 1e-4\n  nl_abs_tol =  1e-7\n  nl_max_its = 60\n\n  automatic_scaling = true\n  verbose = true\n  off_diagonals_in_auto_scaling = true\n  scaling_group_variables = 'vel_x vel_y vel_z; p'\n[]\n\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]\n\n# [Debug]\n#   show_var_residual_norms = true\n# []",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3577091",
                          "updatedAt": "2022-09-06T17:44:13Z",
                          "publishedAt": "2022-09-06T17:44:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If I remove the code of automatic_scaling = true, the problem could be solved. That is a strange phenomenon. Therefore I hardly use automatic_scaling = true. But I must admit that in some problems the problem convergence progress becomes better if I use automatic_scaling = true. So I am very tangled if I should use automatic_scaling = true.\n\nYea automatic scaling is not a silver bullet. Sometimes it is helpful and sometimes it's not. I would suggest always grouping like variables into the scaling computation, like I did in the input above with the scaling_group_variables parameter. If a problem does not solve well with automatic scaling and solve_type = NEWTON, then I would suggest running with -pc_type svd -pc_svd_monitor on a problem with 1000 dofs or less and see whether the problem is well-posed.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3577406",
                          "updatedAt": "2022-09-06T17:47:25Z",
                          "publishedAt": "2022-09-06T17:47:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "I got it, your answer is helpful to me. Thank you very much.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3583901",
                          "updatedAt": "2022-09-07T11:03:42Z",
                          "publishedAt": "2022-09-07T11:03:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "you're welcome! Thanks for your good questions!",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3585490",
                          "updatedAt": "2022-09-07T14:00:53Z",
                          "publishedAt": "2022-09-07T14:00:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "suqingji"
                  },
                  "bodyText": "Hi @lindsayad,\nPlease forgive me for bothering you again.\nI encountered a convergence problem when I simulated a flow problem.\nIf I use the INSAD to simulate:\n19 Nonlinear |R| = 8.042014e-16\n\n    |residual|_2 of individual variables:\n                   velocity: 6.55322e-16\n                   p:        4.66147e-16\n  Linear solve did not converge due to DIVERGED_NANORINF iterations 0\nNonlinear solve did not converge due to DIVERGED_LINEAR_SOLVE iterations 19\n\n Solve Did NOT Converge!\n\n  Finished Solving                                                                       [225.63 s] [   81 MB]\n\n\nAborting as solve did not converge\n\nFinished Executing\n\nIf I use INS to simulate:\n60 Nonlinear |R| = 8.810293e-16\n\n    |residual|_2 of individual variables:\n                      vel_x: 4.27504e-16\n                      vel_y: 4.32017e-16\n                      vel_z: 4.25759e-16\n                      p:     4.74914e-16\nNonlinear solve did not converge due to DIVERGED_MAX_IT iterations 60\n\n Solve Did NOT Converge!\n\n  Finished Solving                                                                       [614.75 s] [   84 MB]\n\n\nAborting as solve did not converge\n\nFinished Executing\n\nIn fact, the output on the screen if I use INS is normal because of my nl_ral_tol , nl_abs_tol and nl_max_its setup. However, the output on the screen, if I use INSAD, is abnormal for Linear solve did not converge due to DIVERGED_NANORINF iterations 0.\nAs I know, the reason for DIVERGED_NANORINF is that divide by zero when the program solves the Linear equations. That means there are zeros on the diagonal of the matrix. But the same problem if I use the INS rather than INSAD the situations did not happen.\nSo I suspect that there are some bugs when the AD build the jacobian matrix.\nHere are my input files:\nINSAD:\n[Mesh]\n  [./gen]\n    type = FileMeshGenerator\n    file = dvi-exodus.exo\n  [../]\n  [inlet_left]\n    type = ParsedGenerateSideset\n    input = gen\n    combinatorial_geometry = 'abs(x + 1500) < 1e-4'\n    new_sideset_name = 'inlet_left'\n  []\n  [inlet_right]\n    type = ParsedGenerateSideset\n    input = inlet_left\n    combinatorial_geometry = 'abs(x - 1500) < 1e-4'\n    new_sideset_name = 'inlet_right'\n  []\n  [./scale]\n    type = TransformGenerator\n    input = inlet_right\n    transform = SCALE\n    vector_value ='1e-03 1e-03 1e-03'\n  []\n[]\n\n[Modules]\n  [IncompressibleNavierStokes]\n    equation_type = steady-state\n    \n    velocity_boundary = 'WALL-CORE WALL-DOWN WALL-DVI WALL-HEAT WALL-INLET WALL-NOHEAT WALL-UP inlet_left   inlet_right  INLET-DVI'\n    velocity_function = '0 0 0     0 0 0     0 0 0    0 0 0     0 0 0      0 0 0       0 0 0   1 0 0        -1 0 0       4.09 0 -2.87'\n    \n    initial_velocity = '1e-15 1e-15 1'\n    add_standard_velocity_variables_for_ad = false\n\n    density_name = rho\n    dynamic_viscosity_name = mu\n\n    use_ad = true\n    laplace = true\n    family = LAGRANGE\n    order = FIRST\n\n    add_temperature_equation = false\n\n    alpha = 1\n    supg = true\n    pspg = true\n  []\n[]\n\n[BCs]\n  [./outlet]\n    type = DirichletBC\n    variable = p\n    boundary = 'OUTLET'\n    value = 0\n  [../]\n[]\n[Debug]\n   show_var_residual_norms = true\n[]\n\n[Materials]\n  [./user_defined]\n    type = ADGenericConstantMaterial\n    block = FLUID\n    prop_names = 'rho mu cp k'\n    prop_values = '1 1e-02 4.179e3 0.58 '\n  [../]\n[]\n[Executioner]\n  type = Steady\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type -sub_pc_type -ksp_gmres_restart'\n  petsc_options_value = 'bjacobi  asm          200'\n  line_search = 'none'\n  nl_rel_tol = 1e-20\n  nl_max_its = 60\n[]\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n  []\n[]\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]\n\nINS:\n[Mesh]\n  [./gen]\n    type = FileMeshGenerator\n    file = dvi-exodus.exo\n  [../]\n  [inlet_left]\n    type = ParsedGenerateSideset\n    input = gen\n    combinatorial_geometry = 'abs(x + 1500) < 1e-4'\n    new_sideset_name = 'inlet_left'\n  []\n  [inlet_right]\n    type = ParsedGenerateSideset\n    input = inlet_left\n    combinatorial_geometry = 'abs(x - 1500) < 1e-4'\n    new_sideset_name = 'inlet_right'\n  []\n  [./scale]\n    type = TransformGenerator\n    input = inlet_right\n    transform = SCALE\n    vector_value ='1e-03 1e-03 1e-03'\n  []\n[]\n[Variables]\n  [./vel_x]\n    [./InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    [../]\n  [../]\n  [./vel_y]\n    [./InitialCondition]\n      type = ConstantIC\n      value = 1e-15\n    [../]\n  [../]\n  [./vel_z]\n    [./InitialCondition]\n      type = ConstantIC\n      value = 1\n    [../]\n  [../]\n  [./p]\n  [../]\n[]\n[Kernels]\n  # mass\n  [./mass]\n    type = INSMass\n    variable = p\n    u = vel_x\n    v = vel_y\n    w = vel_z\n    pressure = p\n  [../]\n  # x-momentum, space\n  [./x_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    w = vel_z\n    pressure = p\n    component = 0\n  [../]\n  # y-momentum, space\n  [./y_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    w = vel_z\n    pressure = p\n    component = 1\n  [../]\n  # z-momentum, space\n  [./z_momentum_space]\n    type = INSMomentumLaplaceForm\n    variable = vel_z\n    u = vel_x\n    v = vel_y\n    w = vel_z\n    pressure = p\n    component = 2\n  [../]\n[]\n\n[BCs]\n  [./x_no_slip]\n    type = DirichletBC\n    variable = vel_x\n    boundary = 'WALL-CORE WALL-DOWN WALL-DVI WALL-HEAT WALL-INLET WALL-NOHEAT WALL-UP'\n    value = 0.0\n  [../]\n  [./y_no_slip]\n    type = DirichletBC\n    variable = vel_y\n    boundary = 'WALL-CORE WALL-DOWN WALL-DVI WALL-HEAT WALL-INLET WALL-NOHEAT WALL-UP'\n    value = 0.0\n  [../]\n  [./z_no_slip]\n    type = DirichletBC\n    variable = vel_z\n    boundary = 'WALL-CORE WALL-DOWN WALL-DVI WALL-HEAT WALL-INLET WALL-NOHEAT WALL-UP'\n    value = 0.0\n  [../]\n\n  [./x_in_left]\n    type = DirichletBC\n    variable = vel_x\n    boundary = 'inlet_left'\n    value = 1\n  [../]\n  [./y_in_left]\n    type = DirichletBC\n    variable = vel_y\n    boundary = 'inlet_left'\n    value = 0.0\n  [../]\n  [./z_in_left]\n    type = DirichletBC\n    variable = vel_z\n    boundary = 'inlet_left'\n    value = 0.0\n  [../]\n  \n  [./x_in_right]\n    type = DirichletBC\n    variable = vel_x\n    boundary = 'inlet_right'\n    value = -1\n  [../]\n  [./y_in_right]\n    type = DirichletBC\n    variable = vel_y\n    boundary = 'inlet_right'\n    value = 0.0\n  [../]\n  [./z_in_right]\n    type = DirichletBC\n    variable = vel_z\n    boundary = 'inlet_right'\n    value = 0.0\n  [../]\n  \n  [./x_in_dvi]\n    type = DirichletBC\n    variable = vel_x\n    boundary = 'INLET-DVI'\n    value = 4.09\n  [../]\n  [./y_in_dvi]\n    type = DirichletBC\n    variable = vel_y\n    boundary = 'INLET-DVI'\n    value = 0.0\n  [../]\n  [./z_in_dvi]\n    type = DirichletBC\n    variable = vel_z\n    boundary = 'INLET-DVI'\n    value = -2.87\n  [../]\n  \n  [./outlet]\n    type = DirichletBC\n    variable = p\n    boundary = 'OUTLET'\n    value = 0\n  [../]\n[]\n[Debug]\n   show_var_residual_norms = true\n[]\n\n[Materials]\n  [./user_defined]\n    type = GenericConstantMaterial\n    block = FLUID\n    prop_names = 'rho mu cp k'\n    prop_values = '1 1e-02 4.179e3 0.58 '\n  [../]\n[]\n[GlobalParams]\n  gravity = '0 0 0'\n  supg = true\n  pspg = true\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type -sub_pc_type -ksp_gmres_restart'\n  petsc_options_value = 'bjacobi  asm          200'\n  line_search = 'none'\n  nl_rel_tol = 1e-20\n  nl_max_its = 60\n[]\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n  []\n[]\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n[]\n\nThanks and best wishes.",
                  "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3877143",
                  "updatedAt": "2022-10-14T08:50:19Z",
                  "publishedAt": "2022-10-14T08:44:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You've reached residuals around 1e-16. This is very converged. You need to relax the convergence criteria to accept the solution.\nnl_rel_tol of 1e-20 is incredibly tight.\nWe cannot converge solutions down to infinitely small residuals. There are floating point precision issues at these levels.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3878923",
                          "updatedAt": "2022-10-14T12:54:30Z",
                          "publishedAt": "2022-10-14T12:54:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Hi, @GiudGiud\nIn this question, I deliberately set the residuals so small to find this problem. As I mentioned above, INS did not encounter the problem. Only in INSAD, the problem can be found.\nIn fact, if the problem diverged for the res_abs_tol set too small, the information on the screen should be DIVERGED_MAX_IT rather than DIVERGED_NANORINF.\nSo in order to prove the AD bug, I add some to the input file as:\n[Preconditioning]\n  [./fdp]\n    type = FDP\n    full = true\n  [../]\n[]\n\nIn a way, the jacobian matrix is built by FDP, So in a way, the jacobian matrix is completely accurate. As I had expected the screen show me DIVERGED_MAX_IT rather than DIVERGED_NANORINF\nAll in all, So I suspect that there are some bugs when the AD builds the jacobian matrix.\nTo say the least, it would not matter if the problem happen in rel so small. But unfortunately, There is the same problem in some situations when rel is not so small.\nIt's a really strange question, and I expect you don't quite believe it exists.\nThanks and best wishes.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879443",
                          "updatedAt": "2022-10-14T13:51:41Z",
                          "publishedAt": "2022-10-14T13:51:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Using AD the Jacobian is naturally correct you do not need to use FDP.\nYour preconditioner is on the weaker side. You could using a different one to see if that fixes the problem",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879474",
                          "updatedAt": "2022-10-14T13:55:42Z",
                          "publishedAt": "2022-10-14T13:55:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh do you mean you switched INSAD to FDP and then the problem went away?",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879476",
                          "updatedAt": "2022-10-14T13:56:22Z",
                          "publishedAt": "2022-10-14T13:56:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so an INF is not necessarily a bug. You do not have guaranteed convergence with this pre-conditionner.\na Nan would be more concerning. To find those, you will want to compile in devel mode (METHOD=devel make) then run with --trap-fpe on the command line",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879512",
                          "updatedAt": "2022-10-14T14:00:49Z",
                          "publishedAt": "2022-10-14T14:00:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "I must say yes.\nI set INS or INSAD with FDP, the problem is normal absolutely. Only when I set INSAD without FDP and set solve_type = 'NEWTON', does the screen show me DIVERGED_NANORINF.\nSo please believe my suspece.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879517",
                          "updatedAt": "2022-10-14T14:01:33Z",
                          "publishedAt": "2022-10-14T14:01:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "DIVERGED_NANORINF is not a problem. DIVERGED_NANORINF is just a facade. The problem is why show DIVERGED_NANORINF. As I know, the reason for DIVERGED_NANORINF is that divided by zero when the program solves the Linear equations. That means there are zeros on the diagonal of the matrix.\nSo It is the only reason appearing zeros on the diagonal of the matrix.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879562",
                          "updatedAt": "2022-10-14T14:06:03Z",
                          "publishedAt": "2022-10-14T14:06:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So there's a PETSc option to print the matrix you may use to check that.\n-ksp_view_mat\nThe alternative is to use the tagging interface to print contributions to the jacobian of each kernel. See moose/test/tests/tag for examples.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879861",
                          "updatedAt": "2022-10-14T14:38:04Z",
                          "publishedAt": "2022-10-14T14:38:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "ok, thanks for your help",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3879911",
                          "updatedAt": "2022-10-14T14:42:56Z",
                          "publishedAt": "2022-10-14T14:42:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Yea this DIVERGED reason investigation is not how I would go about diagnosing a bad Jacobian at all. On a well scaled problem with < 1000 dofs or so you should run -snes_test_jacobian. On a really small problem you can run with -snes_test_jacobian -snes_test_jacobian_view to see the differences between the user and finite difference Jacobian. Note that this needs to be performed on a well scaled problem because the finite difference Jacobian is susceptible to floating point errors",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-3880600",
                          "updatedAt": "2022-10-14T16:09:55Z",
                          "publishedAt": "2022-10-14T16:04:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "suqingji"
                  },
                  "bodyText": "Hi @lindsayad\nPlease forgive me for bothering you again.\nWhen I debugged I found a problem in MOOSE. Now please admit me introduce the problem to you.\nFirstly, let us consider a transient heat conduction problem. Here is the PDE of the heat conduction problem.\n\nIf we consider the problem as one dimension. Set the params as:\nkappa = 0.59\nrho = 1000\ncp = 4.2e3\nLx = 1\ndx = 0.01\nnx = 100\ndt = 10\nAnd Set boundary conditions as:\nT_left = 1\nT_right = 0\nNow, let us create an input file. Here are the details of the input file.\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 1\n    nx = 100\n  []\n[]\n\n[Variables]\n  [./T]\n  [../]\n[]\n\n[Kernels]\n  [./heat]\n    type = ADHeatConduction\n    variable = T\n  [../]\n  [./heat_ie]\n    type = ADHeatConductionTimeDerivative\n    variable = T\n  [../]\n[]\n\n[Materials]\n  [./const]\n    type = ADGenericConstantMaterial\n    prop_names = 'density   specific_heat     thermal_conductivity'\n    prop_values = '1000     4.2e3             0.59'\n  [../]\n[]\n\n[BCs]\n [./left]\n   type = DirichletBC\n   variable = T\n   boundary = left\n   value = 1\n [../]\n [./right]\n   type = DirichletBC\n   variable = T\n   boundary = right\n   value = 0\n [../]\n[]\n[Preconditioning]\n  [./fdp]\n    type = FDP\n    full = true\n  [../]\n[]\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n\n  dt = 10\n  end_time = 10\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nThe solution is shown here:\n\nObviously, there are some values that are bigger than 1 and smaller than 0.\nIn fact, this is an abnormal phenomenon.\nSecondly, let me prove my comment.\nI write a program for the question through the libMesh which also is the MOOSE's underlying framework.\nThis is the plot calculated by libMesh:\n\nAt last, I use python to write a program for the question through the finite difference method\nThis is the plot calculated by FDM with Python:\n\nSo, I suspect that there are some bugs in the Time Derivative part in MOOSE.\nThanks.",
                  "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4128789",
                  "updatedAt": "2022-11-13T15:33:50Z",
                  "publishedAt": "2022-11-13T15:33:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This looks like a really steep gradient to develop.\nhave you tried smaller time steps and a finer mesh?",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4129192",
                          "updatedAt": "2022-11-13T16:59:39Z",
                          "publishedAt": "2022-11-13T16:59:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Yes, this is a really steep gradient problem. But this is a transient diffusion problem without convection. In theory, generally, there is no oscillation problem in the diffusion problem.\nSo that finer mesh is not first choose. And if I tried smaller time steps the oscillation will be more serious in MOOSE. But if I use FDM FVM or FEM by libMesh, there is not oscillation problem.\nSo that I suspect that there are some bugs in the Time Derivative part in MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4131478",
                          "updatedAt": "2022-11-14T03:22:15Z",
                          "publishedAt": "2022-11-14T03:22:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "You initial condition is zero (the default), which does not satisfy your boundary condition. Not sure whether it will cause issue for the solution at infinity.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4137552",
                          "updatedAt": "2022-11-14T14:56:11Z",
                          "publishedAt": "2022-11-14T14:56:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Your time step size is way too small. You can see @hugary1995's answer at #22528 (reply in thread). Your characteristic time considering your element size is ~700 seconds but you are taking a time step that is 70 times smaller than that. You are bound to create boundary shocks under those conditions. So I would certainly not conclude that there is a bug in TimeDerivative. If you want to share your libMesh code, then I'd be happy to explore why you're getting fortuitious behavior there",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4139405",
                          "updatedAt": "2022-11-14T17:53:23Z",
                          "publishedAt": "2022-11-14T17:53:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Hi, Thanks for your reply. @YaqiWang @lindsayad @GiudGiud\nI got the reason why the 'abnormal' phenomenon come.\nBecause CG FEM in the transient diffusion problem is not a positive preserve scheme.\nThe root reason is that when dealing with transient terms, there are some values that will contribute to off-diagonal. That will cause the matrix not to meet the positive preserve conditions. This is a special problem which is only come in FEM.\nBut if we use FDM or FVM, the problem will not come.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4143003",
                          "updatedAt": "2022-11-15T10:44:59Z",
                          "publishedAt": "2022-11-15T05:16:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "While that's theoretically true, the result you showed is simply a manifestation of some poor choices made in your model definition. The consequence will appear in different forms in FEM, FDM, and FVM.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4145590",
                          "updatedAt": "2022-11-15T11:34:55Z",
                          "publishedAt": "2022-11-15T11:34:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Hi, @hugary1995\nThanks for your reply.\nIn this question, the problem maybe is not important because we can use finer mesh or select a bigger time stepper. But the problem similar to other problems is very important, especially in some temperature shock problems.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4146037",
                          "updatedAt": "2022-11-15T12:34:54Z",
                          "publishedAt": "2022-11-15T12:34:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay, good to know.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4146086",
                          "updatedAt": "2022-11-15T12:41:09Z",
                          "publishedAt": "2022-11-15T12:41:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "suqingji"
                          },
                          "bodyText": "Hi, @lindsayad, @GiudGiud, @YaqiWang\nAs I mentioned above, in the transient diffusion problem there is an oscillation problem. This is caused by CG FEM's non-local conservation.\nFortunately, there is a method that can be used to solve the problem. The method is lumping the transient term. I also found that in the PorousFlow module there is a class that has implemented the lumped transient term. Here is the detail page.\nBut unfortunately, in the Navier-Stokes module, if I want to couple a variable using some codes such as &adCoupledDot(\"temperature\"), there is no lumped coupled method. I try to add the method to Base Class, but I failed.\nWould you like to add the method to the class Coupleable.\nThanks. Best wishes.",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4436378",
                          "updatedAt": "2022-12-17T06:48:29Z",
                          "publishedAt": "2022-12-17T06:48:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nWhich method are you missing in Coupleable? adCoupledDot does exist\nThe massLumpedTimeDerivative would likely only be added to NS if useful, coupleable is a very general framework-wide class\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21996#discussioncomment-4437221",
                          "updatedAt": "2022-12-17T11:30:16Z",
                          "publishedAt": "2022-12-17T11:30:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Random values based on space and time",
          "author": {
            "login": "batodon"
          },
          "bodyText": "Hello,\nIs there a function in moose to generate a random value as a function of space and time (i.e., [_qp] and _dt)? In other words, the function will take the arguments of space and time. I tried using the c++ rand() function, but it only gives a random value between two extreme values. Is there any moose example having such a function? Any help is deeply appreciated. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/22971",
          "updatedAt": "2022-12-17T22:46:10Z",
          "publishedAt": "2022-12-15T18:08:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "You ll want to have a look at the random interface\nhttps://mooseframework.inl.gov/source/interfaces/RandomInterface.html\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classRandomInterface.html",
                  "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4412427",
                  "updatedAt": "2022-12-15T18:12:12Z",
                  "publishedAt": "2022-12-15T18:12:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the randomIC is an example using it",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4412432",
                          "updatedAt": "2022-12-15T18:12:29Z",
                          "publishedAt": "2022-12-15T18:12:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Hi @GiudGiud. Thanks for the suggestion. I took a look at the RandomInterface class. It seems the getRandomReal() or getRandomLong() functions generate the same random numbers for \u2018all\u2019 elements within the domain at a \u2018snapshot.\u2019 I mean, all the elements within the domain will have the same random numbers at a snapshot. What I\u2019m looking for, though, is a function that generates different random numbers for all the different elements at a snapshot (or single step). That is, element 1 should have a random value different from element 2 at a single step. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4413253",
                          "updatedAt": "2022-12-15T20:10:56Z",
                          "publishedAt": "2022-12-15T20:10:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it should not be like that. have a look at RandomIC, it s spatially random",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4413281",
                          "updatedAt": "2022-12-15T20:13:41Z",
                          "publishedAt": "2022-12-15T20:13:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Gotcha! Thanks, a lot @GiudGiud.",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4413428",
                          "updatedAt": "2022-12-15T20:43:28Z",
                          "publishedAt": "2022-12-15T20:43:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Hello @GiudGiud\nI had to re-open this ticket since I did not achieve success with my simulation. Maybe, I did not properly communicate my objective for using the random values. What I really want to achieve is to rotate each element using a unique random angle of rotation for that element. I had previously rotated my model using a single rotation angle for all elements. However, I find it challenging to do the same thing using different rotation angles for all elements simultaneously. Yes, the RandomIC generates spatially varied field data for a given variable, but I wonder how I can apply this to my objective. The following code shows how I\u2019m using the RandomInterface class, but this approach only generates a single random rotation angle at a time. I believe this is incorrect, considering my objective. Please, do you have any suggestions on how to approach this problem? Thanks.\n// Whether to use spatially random angle of rotation at each timestep or a fixed angle of rotation.\n    Real  _randm_rad_xy;\n    Real  _randm_rad_yz;\n      if (_distribution)\n        {\n          _randm_rad_xy = _distribution->quantile(getRandomReal());\n          _randm_rad_yz = _distribution->quantile(getRandomReal());\n        }\n      else\n          {\n            _randm_rad_xy = getRandomReal() * (_max - _min) + _min;\n            _randm_rad_yz = getRandomReal() * (_max - _min) + _min;\n          }\n\n      Real  _rad_xy;\n      Real  _rad_yz;\n          if (_Random_field)\n        // Get the spatially random rotation angle (in radians) for each element at each timestep.\n          {\n            _rad_xy = _randm_rad_xy;\n            _rad_yz = _randm_rad_yz;\n          }\n          else\n        // Get the fixed (or user-specified) rotation angle for all elements in the domain at each timestep.\n          {\n          _rad_xy = _fix_rad_xy;\n          _rad_yz = _fix_rad_yz;\n          }",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4424770",
                          "updatedAt": "2022-12-16T16:45:42Z",
                          "publishedAt": "2022-12-16T16:42:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nI did not mean for you to use the RandomIC, sorry for the misunderstanding.\nI meant for you to look at the code in the RandomIC to extract the appropriate API calls from the randomInterface()\nIt uses\n    return generateRandom() * (_max - _min) + _min;\n\nThis generateRandom() is different at every quadrature point. I think it should be different every time you call it, so it can be different in time, in space etc.\nDoes this work for you?",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4434234",
                          "updatedAt": "2022-12-17T03:21:55Z",
                          "publishedAt": "2022-12-17T03:21:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "Hi @GiudGiud. Yeah, I got a bit confused. I'll work around it and let you know shortly. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4438301",
                          "updatedAt": "2022-12-17T16:26:48Z",
                          "publishedAt": "2022-12-17T16:26:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "batodon"
                          },
                          "bodyText": "I fixed it! It compiles, beautifully...",
                          "url": "https://github.com/idaholab/moose/discussions/22971#discussioncomment-4439027",
                          "updatedAt": "2022-12-17T19:40:39Z",
                          "publishedAt": "2022-12-17T19:40:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}