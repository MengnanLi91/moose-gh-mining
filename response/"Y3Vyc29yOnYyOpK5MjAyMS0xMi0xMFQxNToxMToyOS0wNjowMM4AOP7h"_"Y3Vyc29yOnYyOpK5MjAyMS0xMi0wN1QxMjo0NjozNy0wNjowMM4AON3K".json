{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0xMi0wN1QxMjo0NjozNy0wNjowMM4AON3K"
    },
    "edges": [
      {
        "node": {
          "title": "INSFV Memory Usage",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi All\nQuick one, a colleague pointed out that he was seeing high memory usage in INSFV, so I took @ChrocheMisawa 's problem as posted in #17760 and cracked up the refinement. Im seeing huge memory increases for memory usage\n\nSuggesting 1e6 elements being 200 Gb of memory! That doesnt seem right, thats huge a post on the OpenFOAM forum (apples and elephants comparison) suggests 1e6 elements ~ 1 Gb of memory, so even accounting for the AD cost, this seems expensive.\nThanks\nAndy",
          "url": "https://github.com/idaholab/moose/discussions/17874",
          "updatedAt": "2022-07-06T15:40:16Z",
          "publishedAt": "2021-05-18T18:13:39Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "Are you running these tests with ReplicatedMesh or DistributedMesh? Note that the former keeps a full copy of the mesh on every processor rank when running in parallel. You can imagine how this can get pretty expensive. For larger problems spread across more ranks, you should be using DistributedMesh. We also have the ability to pre-split the mesh to avoid startup spikes in both terms of memory and time. We can run tens of millions of elements using just hundreds of MBs on each rank in this fashion.\n[Mesh]\n    ...\n    parallel_type = distributed\n[]\n\nHere is some information on presplitting:\nhttps://mooseframework.inl.gov/syntax/Mesh/splitting.html",
                  "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-763707",
                  "updatedAt": "2022-07-06T15:40:15Z",
                  "publishedAt": "2021-05-20T14:40:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "I should've pointed out this is in serial",
                  "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-763742",
                  "updatedAt": "2022-07-06T15:40:14Z",
                  "publishedAt": "2021-05-20T14:47:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think it's gmres that is building a very large krylov base in this example. How many linear iterations is this case doing per non-linear iteration?\nThe LU sub-preconditioner also may not help.\nWithout profiling for memory it's hard to give you a definite answer. Thanks for reporting this.",
                  "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-763758",
                  "updatedAt": "2022-07-06T15:40:14Z",
                  "publishedAt": "2021-05-20T14:51:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "I tried hypre euclid, but that was a no go. See the image below, its the same problem once at a default resolution, and the 2nd refined further, results from gperf",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-764725",
                          "updatedAt": "2022-07-06T15:40:14Z",
                          "publishedAt": "2021-05-20T18:01:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "18 linear iterations per non-linear iteration, 3 non-linear iterations for convergence",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-764736",
                          "updatedAt": "2022-07-06T15:40:14Z",
                          "publishedAt": "2021-05-20T18:02:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok it's clear from gperf that the gradient caching on each face is the culprit.\nMaybe we should re-consider that choice. I ll bring it up at the next FV meeting\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-764743",
                          "updatedAt": "2022-07-07T11:06:07Z",
                          "publishedAt": "2021-05-20T18:04:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "I like that you said this was a quick one \ud83d\ude06 So yea @GiudGiud is working on this in in #18009 and in #18012. You did point out that the OpenFOAM to MOOSE comparison is apples to elephants and that's good. Because after eliminating the caching @GiudGiud 's profiles show that at least 60% of remaining memory allocation comes out of PETSc. 34% of that is a matrix alone and there's a pretty good chance that the referenced OpenFOAM case is using explicit time integration. Some of the remaining PETSc memory will be that minimum of 30 GMRES vectors (perhaps more if you increase the restart) unless you are using a different -ksp_type. You will still have a mass matrix with explicit time integration but for our spatial discretization of the time derivative term the matrix is purely diagonal and we actually have non-PETSc-based methods for solving this (no explicit matrix storage nor GMRES iterations required!).\nReally appreciate this discussion as it will seriously cut down on our FV memory usage. It would be good to do some more serious profile comparisons to OpenFOAM moving forward where we use the same solution methods because we want to be in the same ballpark for sure. I would be shocked if we ever \"beat\" them, but yea in the same ballpark is where I want us to be.",
                  "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-835140",
                  "updatedAt": "2022-07-07T11:06:07Z",
                  "publishedAt": "2021-06-07T14:16:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Glad to be of use :) When they get approved I have someone at our end to do a thorough OpenFOAM/MOOSE FV comparison.",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-835443",
                          "updatedAt": "2022-07-07T11:06:07Z",
                          "publishedAt": "2021-06-07T15:17:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I will prepare myself to feel embarrassed then haha. But this will be great to help us to continue to grow/improve",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-835680",
                          "updatedAt": "2022-07-07T11:06:06Z",
                          "publishedAt": "2021-06-07T16:03:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@makeclean this PR got merged if you still want to look at openFOAM vs moose FV.\nWe now don't cache face gradients or values by default.\nWe still cache element gradients everywhere and face values on extrapolated boundary conditions (velocity inlet, pressure outlet)",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-1579138",
                          "updatedAt": "2022-07-07T11:06:06Z",
                          "publishedAt": "2021-11-02T22:48:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Closing this. Situation has largely improved with the caching PRs.",
                          "url": "https://github.com/idaholab/moose/discussions/17874#discussioncomment-1787454",
                          "updatedAt": "2022-07-07T11:08:31Z",
                          "publishedAt": "2021-12-10T18:31:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Compiling apps together",
          "author": {
            "login": "rtaylo45"
          },
          "bodyText": "Hello,\nI have a problem were I am compiling two moose apps together and i am getting a linking error:\nLinking Library /home/qt5/projects/mole/test/lib/libmole_test-opt.la...\nlibtool:   error: cannot find the library '/home/qt5/projects/mole/test/lib/libmole_test-opt.la' or unhandled argument '/home/qt5/projects/mole/test/lib/libmole_test-opt.la'\n\nThis is what my make file looks like:\n# Set up MOOSE framework\nifeq ($(wildcard $(MOOSE_DIR)/framework/Makefile),)\n  $(error MOOSE framework was not found!  Please set MOOSE_DIR to the MOOSE directory!)\nendif\nFRAMEWORK_DIR      := $(MOOSE_DIR)/framework\ninclude $(FRAMEWORK_DIR)/build.mk\ninclude $(FRAMEWORK_DIR)/moose.mk\n\n################################## MODULES ####################################\n# To use certain physics included with MOOSE, set variables below to\n# yes as needed.  Or set ALL_MODULES to yes to turn on everything (overrides\n# other set variables).\n\nALL_MODULES                 := no\n\nCHEMICAL_REACTIONS          := yes\nCONTACT                     := no\nEXTERNAL_PETSC_SOLVER       := no\nFLUID_PROPERTIES            := no\nFUNCTIONAL_EXPANSION_TOOLS  := no\nHEAT_CONDUCTION             := no\nLEVEL_SET                   := yes\nMISC                        := no\nNAVIER_STOKES               := no\nPHASE_FIELD                 := yes\nPOROUS_FLOW                 := no\nRDG                         := no\nRICHARDS                    := no\nSOLID_MECHANICS             := no\nSTOCHASTIC_TOOLS            := no\nTENSOR_MECHANICS            := no\nXFEM                        := no\n\n# Modify modules for SAM\nifneq ($(wildcard $(SAM_DIR)/Makefile),)\n  # Sam will need these modules\n  FLUID_PROPERTIES := yes\n  HEAT_CONDUCTION  := yes\n  TENSOR_MECHANICS := yes\nendif\n\ninclude $(MOOSE_DIR)/modules/modules.mk\n\n############################## SAM ############################################\nifneq ($(wildcard $(SAM_DIR)/Makefile),)\n  APPLICATION_DIR     := ${SAM_DIR}\n  APPLICATION_NAME    := sam\n  BUILD_EXEC          := yes\n  include             $(FRAMEWORK_DIR)/app.mk\n  ADDITIONAL_INCLUDES += -I$(SAM_DIR)/include/base\n  ADDITIONAL_CPPFLAGS += -DSAM_ENABLED\n  ADDITIONAL_LIBS     += $(SAM_DIR)/lib/libsam-$(METHOD).la\nendif\n\n############################## MOLE ############################################\nAPPLICATION_DIR    := $(CURDIR)\nAPPLICATION_NAME   := mole\nBUILD_EXEC         := yes\nGEN_REVISION       := no\nDEP_APPS           := $(shell $(FRAMEWORK_DIR)/scripts/find_dep_apps.py $(APPLICATION_NAME))\ninclude            $(FRAMEWORK_DIR)/app.mk\n\n###############################################################################\n# Additional special case targets should be added here\n\nI thought i got this working a few months ago but I can't remember if i did anything to the Makefile. Im compiling both codes with MOOSE commit 00fa7c0.",
          "url": "https://github.com/idaholab/moose/discussions/18684",
          "updatedAt": "2022-05-31T15:07:10Z",
          "publishedAt": "2021-08-23T19:44:36Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think you may be missing\nBUILD_TEST_OBJECTS_LIB := yes in your if_SAM loop\n?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1224740",
                  "updatedAt": "2022-05-31T15:07:15Z",
                  "publishedAt": "2021-08-23T22:48:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "So that did not help. Whats interesting is that if i try to recompile it right after it fails to compile the first time. It works. The first time i try to compile it, it says that it cannot find libmole_test-opt.la but if i look in the folder it was looking in, its there. So when i compile it again, it finds the library.",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1255572",
                          "updatedAt": "2022-05-31T15:07:11Z",
                          "publishedAt": "2021-08-30T18:24:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Let's look at the output of make -n and see in what order things are being linked. You could email it to me if you dont want to share it here",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1289017",
                          "updatedAt": "2022-05-31T15:07:11Z",
                          "publishedAt": "2021-09-07T05:03:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Zack, A few things which may or may not help:\n\nYou should never need to touch the main.C file. If you think you need to, you are working outside of our intended system.\nYour Makefile seems a little bit complicated. We've really tried to simplify the necessary blocks you need when compiling applications together. If the dependent MOOSE application is required, the block should be this simple:\n\n# SAM\nSAM_DIR            ?= $(CURDIR)/SAM\nAPPLICATION_DIR    := $(SAM_DIR)\nAPPLICATION_NAME   := sam\ninclude            $(FRAMEWORK_DIR)/app.mk\n\nFor optional dependencies, it does get a bit more complex since you have to create compiler defines and use several preprocessor commands as you've done.\nOne other big difference is that we normally don't build \"execs\" for anything but the final application. While I can't see why that would be the problem it's related to the \"test\" library that you are getting so maybe. Perhaps a variable we expect to only be defined once is getting defined multiple times (again, our system expects only a single exec).\nThe test library should be built only for the final application it's normally not linked in anywhere except for that final application. The intent is that you can have test objects that don't pollute scope further up the stream. Try taking that line out and see if we can get further.\nWe should chat about getting access at the INL. I think it would be very helpful. We can setup a government use agreement very quickly. It doesn't have to go through full technology deployment process for another lab to get it.",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1471162",
                          "updatedAt": "2022-05-31T15:07:19Z",
                          "publishedAt": "2021-10-13T14:02:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "I made the changes to the Makefile as you suggested and the code compiles as it should with no errors. I reverted back my changes made in the main.C file. So i changed from using the moleApp object to the original moleTestApp object. I have a set of test that run for SAM/Mole coupled which failed because it was not able to find the Actions/kernels.. etc. that should be provided by SAM. I also tried running the test files with mole-opt exc and i get the same failure. If i made the changes to the  main.C file to use the moleApp object instead of moleTestApp it works. I would like to note that we changes to the moleApp.C file  for special cases when SAM is compiled with Mole. These changes include:\nInputParameters\nmoleApp::validParams()\n{\n  auto params = MooseApp::validParams();\n#ifdef SAM_ENABLED\n  params += SamApp::validParams();\n#endif\n\n  // Class description\n  params.addClassDescription(\"The moleApp class creates an instance of a mole \"\n    \"solver, which solves various species transport related problems for \"\n    \"molten salt reactors.\");\n\n  return params;\n}\n\nmoleApp::moleApp(InputParameters parameters)\n#ifdef SAM_ENABLED\n  : SamApp(parameters)\n#else\n  : MooseApp(parameters)\n#endif\n{\n  moleApp::registerAll(_factory, _action_factory, _syntax);\n}\n\nvoid\nmoleApp::registerAll(Factory & f, ActionFactory & af, Syntax & s)\n{\n  ModulesApp::registerAll(f, af, s);\n  Registry::registerObjectsTo(f, {\"moleApp\"});\n  Registry::registerActionsTo(af, {\"moleApp\"});\n\n  /* register custom execute flags, action syntax, etc. here */\n  associateSyntaxInner(s, af);\n#ifdef SAM_ENABLED\n  SamApp::registerAll(f, af, s);\n#endif\n}\n\nWould these changes also need to be included in the moleTestApp.C file? Why does the main.C file use the moleTestApp object and not the moleApp object?",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1472594",
                          "updatedAt": "2022-06-21T20:51:52Z",
                          "publishedAt": "2021-10-13T18:04:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Some of the changes (like registering from SAMApp) will be included because moleTestApp::registerAll calls moleApp::registerAll.\nSame for validParams, moleTestApp gets its validParam from moleApp\nThe only change I can see that doesnt propagate is moleApp inheriting from SamApp, since moleTestApp does not inherit from moleApp.\nWhat do you need that for?",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1472667",
                          "updatedAt": "2022-06-21T20:52:19Z",
                          "publishedAt": "2021-10-13T18:18:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "We thought it would be required to have the SAM app kerenels/actions available to Mole so that we could use them in the input file. I came into this project after the initial work was done. So i did not add this part",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1472745",
                          "updatedAt": "2022-06-21T20:52:20Z",
                          "publishedAt": "2021-10-13T18:35:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "I changed the moleTestApp object to inherit from SamApp like I did with molApp and everything seems to work. Thought, I don't really like having to inherit from the SamApp.",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1472870",
                          "updatedAt": "2022-06-21T20:52:20Z",
                          "publishedAt": "2021-10-13T19:03:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you should not need that, but I just went to check and BlueCrab (the ultimate combined app) does that (inheriting from SamApp too).\nSo it is what it is..\nOk glad to hear that. Please let us know if any more issues arise",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1472896",
                          "updatedAt": "2022-06-21T20:52:22Z",
                          "publishedAt": "2021-10-13T19:08:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aarograh"
                          },
                          "bodyText": "@GiudGiud (or any other MOOSE dev) I have been working with @rtaylo45 and others on development of our Mole app.  This issue has arisen again because we are attempting to couple with several different codes. and a couple different developers ended up pursuing this different ways.\nI have a couple questions.  First, a \"clean\" moleApp will have class moleApp : public MooseApp and class moleTestApp : public MooseApp.  As Zack mentioned, we modified the first of those to be class moleApp : public SamApp.  What I don't understand is this: moleTestApp can properly use moleApp objects just fine, but it cannot use SamApp objects (unless we have it also inherit from SamApp).  However, moleTestApp does not inherit from moleApp.  I do not understand why it can successfully use all the mole objects but cannot use the Sam objects?  Especially since moleApp does all the objects and app registrations for Sam as well.  If you could provide some additional clarity on exactly what the expectations are, that woudl be helpful.  I want to prevent this kind of thing:\n#ifdef APP1_ENABLED && APP2_ENABLED && APP3_ENABLED\n  class moleApp : public app1, public app2, public app3\n#elseif APP1_ENABLED && APP2_ENABLED\n  class moleApp : public app1, public app2\n#elseif APP1_ENABLED && APP3_ENABLED\n  class moleApp : public app1, public app3\n...\netc.\n...\nObviously that gets silly after awhile.  And furthermore, having to make this same set of changes in both moleApp and moleTestApp is 1) annoying and redundant, and 2) confusing to me.\nThe second question I have concerns the test objects.  It's unclear to me exactly what kinds of objects this might be?  I'm envisioning special post-processors, problems, or executioners to operate the application in an abnormal way for testing, but I've never made use of such a setup.  Is there useful documentation/examples of what such test objects might be?  It's possible that we may not use them, in which case we may take the simple approach of modifying main.C to just use moleApp instead of moleTestApp.  However, I do not want to make this change without first understanding possible issues we may encounter as a results.",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1786441",
                          "updatedAt": "2022-06-21T20:52:26Z",
                          "publishedAt": "2021-12-10T15:43:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nA partial response to your questions:\n\nIf you dont do this:\n\n#ifdef APP1_ENABLED && APP2_ENABLED && APP3_ENABLED\n  class moleApp : public app1, public app2, public app3\n#elseif APP1_ENABLED && APP2_ENABLED\n  class moleApp : public app1, public app2\n#elseif APP1_ENABLED && APP3_ENABLED\n  class moleApp : public app1, public app3\n...\netc.\n\nhow is the compiler going to know what a SamApp is when Sam is not enabled?\nIf you choose to work with inheritance (and one alternative is dynamic loading), then you have to do this imo.\n@andrsd may advise you better here, he is in charge of another combined application.\nNote that for the test app, it calls the registering routines from the main app, see there for example\nhttps://github.com/idaholab/TMAP8/blob/devel/test/src/base/TMAPTestApp.C\nI dont see why test apps could not inherit from the main app, but i have not tried this setup.\n\nTest objects are for reaching hard-to-reach statements in the code, to make sure they work. We really need them.\nYou can see a bunch of them in moose/test/src",
                          "url": "https://github.com/idaholab/moose/discussions/18684#discussioncomment-1787083",
                          "updatedAt": "2022-06-21T20:52:44Z",
                          "publishedAt": "2021-12-10T17:24:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to assign different grain boundary mobility to different grains ?",
          "author": {
            "login": "zengfy-hust"
          },
          "bodyText": "Hello everyone:\nI would like to make some changes by assign different GB mobility to different grains like https://www.mdpi.com/1996-1944/12/24/4048/htm,which makes the misorientation angle as an  threshold,I looked up in moose repository and found some cases like this ,the GB mobilities .I would like to assign more grains (more than 100),how can I make this ? thank you .any suggesstion would be fine !",
          "url": "https://github.com/idaholab/moose/discussions/19459",
          "updatedAt": "2022-06-16T02:39:04Z",
          "publishedAt": "2021-11-23T03:45:34Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen",
                  "url": "https://github.com/idaholab/moose/discussions/19459#discussioncomment-1742106",
                  "updatedAt": "2022-06-16T02:39:05Z",
                  "publishedAt": "2021-12-03T06:44:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "We don't have anisotropic mobilities exactly like this currently implemented in MOOSE- the most closely related example shows what happens when different grains have different mobiliites:\nmoose/modules/phase_field/test/tests/GBAnisotropy/test2.i",
                  "url": "https://github.com/idaholab/moose/discussions/19459#discussioncomment-1776052",
                  "updatedAt": "2022-06-16T02:39:14Z",
                  "publishedAt": "2021-12-09T00:25:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Enquiry about using interface diffusion coefficient calculated by DFT in phase field",
          "author": {
            "login": "ZhigangPu"
          },
          "bodyText": "Dear,\nI have a question about phase field that bothers me a lot.\nUsually in phase field, people use an interpolation function to give the diffusion coefficient at the interface(interpolate the coefficient between phase A and phase B). But if through DFT calculation, I can clearly compute the diffusion coefficient at the interface, is there a way I can use the calculated coefficient instead of the interpolation one? If there is a way, then the physical property at the interface may be more meaningful. Also, we can explore more nanoscale factors\u2019 influence on the microstructure evolution through coupling between DFT and PF.\nAny response is highly appreciated!\nBest wishes,\nzhigang",
          "url": "https://github.com/idaholab/moose/discussions/19545",
          "updatedAt": "2022-12-22T05:34:18Z",
          "publishedAt": "2021-12-04T11:38:13Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Are you talking about the \"Multi-scale simulation\" animation on the gallery page? MOOSE uses the MultiApp system to achieve this.",
                  "url": "https://github.com/idaholab/moose/discussions/19545#discussioncomment-1772050",
                  "updatedAt": "2022-12-22T05:34:19Z",
                  "publishedAt": "2021-12-08T11:40:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "You could create an interpolation function that is non-zero only in the interface, then multiply that by the diffusion coefficient. For example, say you have a two-phase system with represented by an order parameter eta that is 1 in the alpha phase and 0 in the beta phase. As you said, normally the diffusivity between the two phases would be represented by function like D_alpha * h + D_beta * (1-h), where h is an interpolation function. If the diffusivity at the interface is much larger than in the bulk, you could make the total diffusivity as D_alpha * h + D_beta * (1-h) + D_int * eta^2 * (1-eta)^2, so that the contribution from interfacial diffusivity is only non-zero at the interface.",
                          "url": "https://github.com/idaholab/moose/discussions/19545#discussioncomment-1776043",
                          "updatedAt": "2022-12-22T05:34:20Z",
                          "publishedAt": "2021-12-09T00:20:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Convergence Issues",
          "author": {
            "login": "edwardXZ06"
          },
          "bodyText": "Bug Description\nI have used current UMAT interface to run a bug free simple hyperelastic umat file, yet the convergence perform really bad no matter I use Newton or PJFNK.\nDoes this mean for the nonlinear problem, we shall specify the Jacobian ourselves, considering this interface has not been built to work with the AD?\nSteps to Reproduce\n\nImpact",
          "url": "https://github.com/idaholab/moose/discussions/18502",
          "updatedAt": "2022-06-20T08:40:31Z",
          "publishedAt": "2021-08-03T02:03:22Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "I'm converting this over to a discussion. If it turns out there is an actual bug in the implementation we can move it back.",
                  "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122886",
                  "updatedAt": "2022-06-20T08:40:36Z",
                  "publishedAt": "2021-08-03T02:12:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "edwardXZ06"
                          },
                          "bodyText": "Of course. Here is my fortran file, which has been tested on Abaqus multiple times, and I have confidence on its DDSDDE derivation as well. This is a NeoHookean hyperelastic umat. For the i file, I just change the elastic.i that you tested for the finite strain elastic umat, by just calling this fortran.\n       SUBROUTINE UMAT(STRESS,STATEV,DDSDDE,SSE,SPD,SCD,\n     1 RPL,DDSDDT,DRPLDE,DRPLDT,\n     2 STRAN,DSTRAN,TIME,DTIME,TEMP,DTEMP,PREDEF,DPRED,CMNAME,\n     3 NDI,NSHR,NTENS,NSTATV,PROPS,NPROPS,COORDS,DROT,PNEWDT,\n     4 CELENTCELENT,DFGRD0,DFGRD1,NOEL,NPT,LAYER,KSPT,KSTEP,KINC)\nC\n      CHARACTER*80 CMNAME\n      DIMENSION STRESS(NTENS),STATEV(NSTATV),\n     1 DDSDDE(NTENS,NTENS),DDSDDT(NTENS),DRPLDE(NTENS),\n     2 STRAN(NTENS),DSTRAN(NTENS),TIME(2),PREDEF(1),DPRED(1),\n     3 PROPS(NPROPS),COORDS(3),DROT(3,3),DFGRD0(3,3),DFGRD1(3,3)\nC\n      DIMENSION DTAU_VEC(6),DLEFT_CAUCHY(6),\n     1 DTAU_MAT(3,3),DEYE(3,3),DPDF(3,3,3,3)\n\t  REAL DJN0, DJN1\n      PARAMETER (ONE=1.0D0,TWO=2.0D0,THREE=3.0D0,SIX=6.0D0,\n     1 SMALL=1.D-12,DHALF=0.5D0,ZERO=0.0D0)\nC\nC -----------------------------------------------------------\nC     UMAT FOR ISOTROPIC NEOHOOKEAN FINTE STRAIN ELASTICITY\nC     GENERAL 3D FORMULATION\nC -----------------------------------------------------------\nC     STRESS CONVENTION:\nC     STRESS(1) - SIGMA_11\nC     STRESS(2) - SIGMA_22\nC     STRESS(3) - SIGMA_33\nC     STRESS(4) - SIGMA_12\nC     STRESS(5) - SIGMA_13\nC     STRESS(6) - SIGMA_23\nC -----------------------------------------------------------\nC     PROPERTIES:\nC     PROPS(1) - DLAMBDA\nC     PROPS(2) - DMU\nC -----------------------------------------------------------\nC     INTERNAL STATE VARIABLES: NONE? STRAINS?\nC     STATEV(1) \nC -----------------------------------------------------------\nC\nC...CALCULATE JACOBIAN AT TIME N0 AND N1\n      DJN0=DFGRD0(1,1)*(DFGRD0(2,2)*DFGRD0(3,3)-\n     1     DFGRD0(2,3)*DFGRD0(3,2))-\n     1     DFGRD0(1,2)*(DFGRD0(2,1)*DFGRD0(3,3)-\n     1     DFGRD0(2,3)*DFGRD0(3,1))+\n     1     DFGRD0(1,3)*(DFGRD0(2,1)*DFGRD0(3,2)-\n     1     DFGRD0(2,2)*DFGRD0(3,1))\n      DJN1=DFGRD1(1,1)*(DFGRD1(2,2)*DFGRD1(3,3)-\n     1     DFGRD1(2,3)*DFGRD1(3,2))-\n     1     DFGRD1(1,2)*(DFGRD1(2,1)*DFGRD1(3,3)-\n     1     DFGRD1(2,3)*DFGRD1(3,1))+\n     1     DFGRD1(1,3)*(DFGRD1(2,1)*DFGRD1(3,2)-\n     1     DFGRD1(2,2)*DFGRD1(3,1))\nC\nC...RECOVER ISVs\nC\nC...ELASTIC PARAMETERS\n      DLAMBDA=PROPS(1)\n      DMU=PROPS(2)\nC      WRITE(*,*) 'DMU = ',DMU\nC\nC...IDENTITY 3X3 MATRIX\n      DO 10 K1=1,3\n        DO 20 K2=1,3\n           IF (K2.NE.K1) THEN \n            DEYE(K2,K1)=ZERO\n           ELSE \n            DEYE(K2,K1)=ONE\n           ENDIF\n 20     CONTINUE\n 10   CONTINUE\nC\nC...LEFT CAUCHY-GREEN VECTOR\nC\n      DLEFT_CAUCHY(1) = DFGRD1(1,1)*DFGRD1(1,1)\n     1 + DFGRD1(1,2)*DFGRD1(1,2) + DFGRD1(1,3)*DFGRD1(1,3)\n      DLEFT_CAUCHY(2) = DFGRD1(2,1)*DFGRD1(2,1)\n     1 + DFGRD1(2,2)*DFGRD1(2,2) + DFGRD1(2,3)*DFGRD1(2,3)\n      DLEFT_CAUCHY(3) = DFGRD1(3,1)*DFGRD1(3,1)\n     1 + DFGRD1(3,2)*DFGRD1(3,2) + DFGRD1(3,3)*DFGRD1(3,3)\n      DLEFT_CAUCHY(4) = DFGRD1(1,1)*DFGRD1(2,1)\n     1 + DFGRD1(1,2)*DFGRD1(2,2) + DFGRD1(1,3)*DFGRD1(2,3)\n      DLEFT_CAUCHY(5) = DFGRD1(1,1)*DFGRD1(3,1)\n     1 + DFGRD1(1,2)*DFGRD1(3,2) + DFGRD1(1,3)*DFGRD1(3,3)\n      DLEFT_CAUCHY(6) = DFGRD1(2,1)*DFGRD1(3,1)\n     1 + DFGRD1(2,2)*DFGRD1(3,2) + DFGRD1(2,3)*DFGRD1(3,3)\nC\nC...KIRCHHOFF STRESS VECTOR\nC\n       DO 30 K1=1,6\n         DTAU_VEC(K1) = DMU*DLEFT_CAUCHY(K1)\n 30   CONTINUE\n      DTAU_VEC(1) = DTAU_VEC(1) + DLAMBDA*LOG(DJN1) - DMU\n      DTAU_VEC(2) = DTAU_VEC(2) + DLAMBDA*LOG(DJN1) - DMU\n      DTAU_VEC(3) = DTAU_VEC(3) + DLAMBDA*LOG(DJN1) - DMU\nC\nC...CAUCHY STRESS VECTOR (should there be a rotation?)\nC\n       DO 40 K1=1,6\n         STRESS(K1) = DTAU_VEC(K1)/DJN1\n 40   CONTINUE\nc      WRITE(*,*) 'DTAU_VEC = ',DTAU_VEC\nc\t  WRITE(*,*) 'DJN1 = ',DJN1\nC\nC...KIRCHHOFF STRESS MATRIX\nC\n      DTAU_MAT(1,1) = DTAU_VEC(1)\n      DTAU_MAT(1,2) = DTAU_VEC(4)\n      DTAU_MAT(1,3) = DTAU_VEC(5)\n      DTAU_MAT(2,1) = DTAU_VEC(4)\n      DTAU_MAT(2,2) = DTAU_VEC(2)\n      DTAU_MAT(2,3) = DTAU_VEC(6)\n      DTAU_MAT(3,1) = DTAU_VEC(5)\n      DTAU_MAT(3,2) = DTAU_VEC(6)\n      DTAU_MAT(3,3) = DTAU_VEC(3)\n\nC...TANGENT MATRIX 6X6\nC\n      DDSDDE(1,1)=(TWO*DTAU_MAT(1,1)+DLAMBDA-\n     1    TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n      DDSDDE(1,2)=(DLAMBDA)/DJN1\n      DDSDDE(1,3)=(DLAMBDA)/DJN1\n      DDSDDE(1,4)=(DTAU_MAT(2,1))/DJN1\n      DDSDDE(1,5)=(DTAU_MAT(3,1))/DJN1\n      DDSDDE(1,6)=ZERO\nC\n      DDSDDE(2,1)=DDSDDE(1,2)\n      DDSDDE(2,2)=(TWO*DTAU_MAT(2,2)+DLAMBDA-\n     1    TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n      DDSDDE(2,3)=(DLAMBDA)/DJN1\n      DDSDDE(2,4)=(DTAU_MAT(2,1))/DJN1\n      DDSDDE(2,5)=ZERO\n      DDSDDE(2,6)=(DTAU_MAT(3,2))/DJN1\nC\n      DDSDDE(3,1)=DDSDDE(1,3)\n      DDSDDE(3,2)=DDSDDE(2,3)\n      DDSDDE(3,3)=(TWO*DTAU_MAT(3,3)+DLAMBDA-\n     1    TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n      DDSDDE(3,4)=ZERO\n      DDSDDE(3,5)=(DTAU_MAT(3,1))/DJN1\n      DDSDDE(3,6)=(DTAU_MAT(3,2))/DJN1\nC\n      DDSDDE(4,1)=DDSDDE(1,4)\n      DDSDDE(4,2)=DDSDDE(2,4)\n      DDSDDE(4,3)=DDSDDE(3,4)\n      DDSDDE(4,4)=(DTAU_MAT(2,2)+DTAU_MAT(1,1)\n     1    -TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n      DDSDDE(4,5)=(DTAU_MAT(3,2))/DJN1\n      DDSDDE(4,6)=ZERO\nC\n      DDSDDE(5,1)=DDSDDE(1,5)\n      DDSDDE(5,2)=DDSDDE(2,5)\n      DDSDDE(5,3)=DDSDDE(3,5)\n      DDSDDE(5,4)=DDSDDE(4,5)\n      DDSDDE(5,5)=(DTAU_MAT(3,3)+DTAU_MAT(1,1)\n     1    -TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n      DDSDDE(5,6)=(DTAU_MAT(1,2))/DJN1\nC\n      DDSDDE(6,1)=DDSDDE(1,6)\n      DDSDDE(6,2)=DDSDDE(2,6)\n      DDSDDE(6,3)=DDSDDE(3,6)\n      DDSDDE(6,4)=DDSDDE(4,6)\n      DDSDDE(6,5)=DDSDDE(5,6)\n      DDSDDE(6,6)=(DTAU_MAT(3,3)+DTAU_MAT(2,2)\n     1    -TWO*(DLAMBDA*LOG(DJN1)-DMU))/DJN1\n\t \n\t  DO 130 K1=1,NDI\n        DO 140 K2=1,NDI\n            IF (DDSDDE(K1,K2).NE.ZERO) THEN \n\t\t\t\tDDSDDE(K1,K2)=-DDSDDE(K1,K2)\n\t\t\tENDIF\n140     CONTINUE\n130   CONTINUE\nC\nC     WRITE(*,*) 'STRESS(2) = ',STRESS(2)\n      RETURN\n      END\nC",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122919",
                          "updatedAt": "2022-06-20T08:40:37Z",
                          "publishedAt": "2021-08-03T02:27:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Alrighty. I'll check this out tomorrow. Could you also share your MOOSE input please? Have you added an SMP preconditioner block with full=true (that should added automatically be default when using NEWTON, but not with PJFNK). I'm assuming you're doing very large deformation? I found our Jacobian lacking in those scenarios when not using AD.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122928",
                          "updatedAt": "2022-06-20T08:40:50Z",
                          "publishedAt": "2021-08-03T02:33:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "oh, I see, you're using elastic.i... That answers my questions.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122930",
                          "updatedAt": "2022-06-20T08:40:49Z",
                          "publishedAt": "2021-08-03T02:34:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "edwardXZ06"
                          },
                          "bodyText": "Yes, the SMP condition is included and I have tried NEWTON as well, still cannot converge. This umat is designed for large deformation, but I started with very small deformation can still cannot converge.\nMany thanks! It will be a great news if I don't need manually input the Jacobian since I am even going to couple with temperature or other physics with this umat interface as well.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122945",
                          "updatedAt": "2022-07-21T21:15:49Z",
                          "publishedAt": "2021-08-03T02:40:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Your UMAT expects the two Lame constants, where our elastic.f expects Young's modulus and Poisson's ration. Did you convert those inputs when you ran the modified elastic.i file?",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122951",
                          "updatedAt": "2022-07-21T21:15:49Z",
                          "publishedAt": "2021-08-03T02:42:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Enabling forward mode automatic differentiation support for UMAT files will not be easy. It would be a custom extension of the UMAT interface and will only work with C++ UMAT files, as we rely on operator overloading provided by the MetaPhysicL library.\nIt might actually be worth your time to look into implementing these models in \"native\" MOOSE code.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122957",
                          "updatedAt": "2022-07-21T21:15:49Z",
                          "publishedAt": "2021-08-03T02:45:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "edwardXZ06"
                          },
                          "bodyText": "Since this is displacement controlled BVP, the parameters don't matter, you can use test '75 75', but I think any real number should be able to run if converges well.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122960",
                          "updatedAt": "2022-07-21T21:15:50Z",
                          "publishedAt": "2021-08-03T02:48:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "edwardXZ06"
                          },
                          "bodyText": "I see. Then probably I need to calculate and supply material Jacobian to MOOSE eventually. Actually, I understand right now you use DDSDDE for Jacobian is just a rough estimate, since DDSDDE represents derivative of stress wrt strain, while Jacobian is the derivative of stress equilibrium function wrt displacement, that might explain it always converges well for linear problem, but might not work for the nonlinear one.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122968",
                          "updatedAt": "2022-07-21T21:15:49Z",
                          "publishedAt": "2021-08-03T02:53:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Wow, that input file just bombs! Inverted elements right away :-(",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122974",
                          "updatedAt": "2022-07-21T21:15:49Z",
                          "publishedAt": "2021-08-03T02:55:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    xmin = -0.5\n    xmax = 0.5\n    ymin = -0.5\n    ymax = 0.5\n    zmin = -0.5\n    zmax = 0.5\n    nx = 5\n    ny = 5\n  []\n[]\n\n[Functions]\n  [top_pull]\n    type = ParsedFunction\n    value = t/100\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = FINITE\n  []\n[]\n\n[BCs]\n  [y_pull_function]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = top\n    function = top_pull\n  []\n  [x_bot]\n    type = DirichletBC\n    variable = disp_x\n    boundary = left\n    value = 0.0\n  []\n  [y_bot]\n    type = DirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0.0\n  []\n  [z_bot]\n    type = DirichletBC\n    variable = disp_z\n    boundary = front\n    value = 0.0\n  []\n[]\n\n[Materials]\n  [umat]\n    type = AbaqusUMATStress\n    constant_properties = '75 75'\n    plugin = 'plugins/edward'\n    num_state_vars = 0\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n\n  # petsc_options = '-snes_ksp_ew'\n  # petsc_options_iname = '-ksp_gmres_restart'\n  # petsc_options_value = '101'\n  petsc_options_iname = '-pc_type -sub_pc_type   -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm       lu            nonzero'\n\n  line_search = 'none'\n\n  l_max_its = 100\n  nl_max_its = 100\n  nl_rel_tol = 1e-12\n  nl_abs_tol = 1e-10\n  l_tol = 1e-6\n  start_time = 0.0\n  num_steps = 30\n  dt = 1e-6\n  dtmin = 1e-6\n[]\n\n[Preconditioning]\n  [smp]\n    type = FDP\n    full = true\n  []\n[]\n\n[Outputs]\n  exodus = true\n  execute_on = 'INITIAL TIMESTEP_END NONLINEAR LINEAR'\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1126141",
                          "updatedAt": "2022-07-21T21:15:50Z",
                          "publishedAt": "2021-08-03T15:57:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Hm, running this with\n./tensor_mechanics-opt -i edward.i -snes_test_jacobian -snes_force_iteration\n\nshows an abysmal Jacobian. So thaer emight be a bug after all.\nTime Step 0, time = 0\n\nTime Step 1, time = 1e-06, dt = 1e-06\n 0 Nonlinear |R| = 0.000000e+00\n  ---------- Testing Jacobian -------------\n  Run with -snes_test_jacobian_view and optionally -snes_test_jacobian <threshold> to show difference\n    of hand-coded and finite difference Jacobian entries greater than <threshold>.\n  Testing hand-coded Jacobian, if (for double precision runs) ||J - Jfd||_F/||J||_F is\n    O(1.e-8), the hand-coded Jacobian is probably correct.\n  ||J - Jfd||_F/||J||_F = 0.999811, ||J - Jfd||_F = 205.818\n      0 Linear |R| = 0.000000e+00\n 1 Nonlinear |R| = 0.000000e+00\n Solve Converged!\n\nTime Step 2, time = 2e-06, dt = 1e-06\n 0 Nonlinear |R| = 5.303301e-07\n  ---------- Testing Jacobian -------------\n  ||J - Jfd||_F/||J||_F = 0.999811, ||J - Jfd||_F = 205.818\n      0 Linear |R| = 5.303301e-07\n      1 Linear |R| = 1.317381e-14\n 1 Nonlinear |R| = 1.483677e-14\n Solve Converged!\n\nTime Step 3, time = 3e-06, dt = 1e-06\n 0 Nonlinear |R| = 6.783279e+10\n  ---------- Testing Jacobian -------------\n  ||J - Jfd||_F/||J||_F = 34.3538, ||J - Jfd||_F = 2.52089e+18\n      0 Linear |R| = 6.783279e+10\n      1 Linear |R| = 3.919297e+09\n  Elem Information\n[...]\n\n(thats where it inverts)",
                  "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122984",
                  "updatedAt": "2022-06-20T08:40:50Z",
                  "publishedAt": "2021-08-03T03:00:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Wait.. this doesn't even converge with a finite difference preconditioner and a direct solver...",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1122994",
                          "updatedAt": "2022-06-20T08:41:00Z",
                          "publishedAt": "2021-08-03T03:05:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "edwardXZ06"
                          },
                          "bodyText": "I guess the main reason is the mathematical difference between global Jacobian and DDSDDE, but the transition between these two is not that intimidating, if we know required information from shape function, like the B matrix, derivative of shape function in reference coordinates, etc...\nBTW, I saw there are examples of hyperelastic-creep model under tensor mechanics module, and that input file doesn't even supply any manual Jacobian, if my understanding is correct.",
                          "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1123019",
                          "updatedAt": "2022-06-20T08:41:06Z",
                          "publishedAt": "2021-08-03T03:16:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "@dschwen I have a stupid question, I couldn't even find UMAT in my MOOSE folder? is this an extension? how can I install it?\nIt would be very interesting to integrate MOOSE with Abaqus.\nKind regards,\nTraiwit",
                  "url": "https://github.com/idaholab/moose/discussions/18502#discussioncomment-1166640",
                  "updatedAt": "2022-06-20T08:41:06Z",
                  "publishedAt": "2021-08-13T05:36:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fixing mesh without affecting the calculation",
          "author": {
            "login": "souzanha"
          },
          "bodyText": "Hi!\nI have a system with and outward flux on one boundary. This flux nucleates a new phase at that specific boundary and I use the tensor mechanics module to see how the mechanical energy affects the evolution of the interface.\nIt could be that I'm doing it incorrectly, but I started without any Dirichlet BCs on the edges and then get a change in my geometry.\nBut using Dirichlet conditions on the edge affects the simulation results. This makes sense, as I'm keeping the nodes there at constant value 0. Is there a way to fix the mesh in position without me affecting the results?\nThese are the conditions that I'm using:\n##DISPLACEMENT BOUNDARY CONDITIONS, zero total shear and constant volume\n  [./bottom_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom_edge'\n    value = 0\n  [../]\n  [./top_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'top_edge'\n    value = 0\n  [../]\n  [./left_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left_edge'\n    value = 0\n  [../]\n  [./right_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'right_edge'\n    value = 0\n  [../]\n\n##PERIODIC BOUNDARY CONDITIONS, TOP BOTTOM\n   [./Periodic]\n    [./pbc_c]\n      variable = c\n      auto_direction = 'y'\n    [../]\n\n    [./pbc_w]\n      variable = w\n      auto_direction = 'y'\n    [../]\n  [../]\n\n  [./right_w]\n     type = ADFluxFunction (my own)\n     variable = w\n     boundary = right_edge\n [../]\n\n  [./left_w]\n     type = NeumannBC\n     variable = w\n     boundary = left_edge\n     value = 0\n [../]\n\n  [./left_c]\n     type = NeumannBC\n     variable = c\n     boundary = left_edge\n     value = 0\n [../]\n\n  #total free free energy (chemical + elastic)\n  [./total_free_energy]\n    type = DerivativeSumMaterial\n    f_name = f_tot\n    sum_materials = 'f_chem f_elast'\n    args = 'c'\n    derivative_order=2\n  [../]\n\n  [./elasticity_tensor]\n    type = ComputeElasticityTensor\n    C_ijkl = '157 51 53 0 0 0 171 33 0 0 0 0 0 0 0 38 0 0 49 0 52' #unitless\n    fill_method = symmetric21 #general symmetry\n  [../]\n\n  [./eigenstrain] #nocomplaints\n   type = ComputeVariableEigenstrain\n   material_property_names = 'e0_11 e0_22 e0_33'\n   #eigen_base = 'e0_11 e0_22 e0_33 0 0 0' #cannot convert to float\n   eigen_base = '0.05 0.036 -0.019 0 0 0' #eps0, Vegard\u2019s law coefficients\n   prefactor = var_dep #the prefactor is defined in a derivative\n   args = 'c'\n   eigenstrain_name = eigenstrain\n  [../]\n\n  [./var_dependence]\n   type = DerivativeParsedMaterial\n   function = 'c' #0.5*c^2\n   args = 'c'\n   output_properties = 'var_dep'\n   f_name = var_dep\n   enable_jit = true #Enable just-in-time compilation of function expressions for faster evaluation\n   derivative_order = 2\n  [../]\n\n  [./strain]\n   type =  ComputeIncrementalSmallStrain #ComputeSmallStrain #strain, without composition part. eps=1/2*(u*nabla+nablau)\n   displacements = 'disp_x disp_y'\n   eigenstrain_names = eigenstrain #eigenstrains to be applied in this strain calculation. Substracts the eigenstrain from the total strain = mechanical strain.\n  [../]\n\n  [./stress]\n   type = ComputeFiniteStrainElasticStress #ComputeLinearElasticStress #sigma=C*mechanical strain = total strain\n  [../]",
          "url": "https://github.com/idaholab/moose/discussions/19315",
          "updatedAt": "2022-07-11T06:06:56Z",
          "publishedAt": "2021-11-08T11:10:52Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think I'd try pinning a single node first.\nPlease see how to do this here\nhttps://mooseframework.inl.gov/modules/tensor_mechanics/tutorials/introduction/step03a.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19315#discussioncomment-1742061",
                  "updatedAt": "2022-07-11T06:06:58Z",
                  "publishedAt": "2021-12-03T06:31:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "I see! Sounds like a very nice approach, I will try it.  Thank you for the suggestion and the link",
                          "url": "https://github.com/idaholab/moose/discussions/19315#discussioncomment-1757414",
                          "updatedAt": "2022-07-11T06:06:58Z",
                          "publishedAt": "2021-12-06T12:55:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "This is an issue with your formulation rather than with the tensor mechanics module. You need to first think about what boundary conditions you really want for the control volume.\nIf this is something at macroscale, you can apply boundary conditions that make sense on that structure. Depending on the actual problem, pinning a single node may or may not be your best choice.\nIf this is an RVE, you may choose traditional KUBC or SUBCs. If you choose SUBC then you need to pin an additional node to remove rigid body modes. Alternatively, you can constrain the RVE to have a prescribed homogenized strain/stress. The global strain system in the tensor mechanics module helps you do that.",
                  "url": "https://github.com/idaholab/moose/discussions/19315#discussioncomment-1772027",
                  "updatedAt": "2022-07-11T06:06:58Z",
                  "publishedAt": "2021-12-08T11:34:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Let material properties of non-mentioned blocks equal to 0",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nis there a cleaner way to let material properties of non-mentioned blocks equal to 0, I know the messy way (shown below)\n  [./excav_perm1]\n    type = GenericConstantMaterial\n    prop_names  = excav_perm\n    prop_values = 1\n    block = 1\n  [../]\n\n  [./unmined_perm1]\n    type = GenericConstantMaterial\n    prop_names  = excav_perm\n    prop_values = 0\n    block = '2 3 4 5 6'\n  [../]\n\nbut is it possible to just define the property on a particular block(s), OR define 2 values in a single object for example\n[./excav_perm1]\n   type = GenericConstantMaterial\n   prop_names  = excav_perm\n   prop_values_1 = 1\n   blocks_prop_1 = 1\n\n   prop_values_2 = 0\n   blocks_prop_2 = '2 3 4 5 6'\n [../]\n\nNot sure where to start, should it be somewhere in the .C file?\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/19470",
          "updatedAt": "2022-08-19T11:57:13Z",
          "publishedAt": "2021-11-24T05:43:08Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Traiwit\nIs this what you're looking for\nhttps://mooseframework.inl.gov/source/materials/PiecewiseConstantByBlockMaterial.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19470#discussioncomment-1691736",
                  "updatedAt": "2022-07-11T20:56:28Z",
                  "publishedAt": "2021-11-24T06:06:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is the material used in all blocks btw? When not used you can just omit it.",
                          "url": "https://github.com/idaholab/moose/discussions/19470#discussioncomment-1691739",
                          "updatedAt": "2022-07-11T20:56:28Z",
                          "publishedAt": "2021-11-24T06:09:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aprilnovak"
                          },
                          "bodyText": "You might need to set material_coverage_check = false in the [Problem] block if by omitting your [unmined_perm1] block you wouldn't otherwise have any materials at all on blocks 2 3 4 5 6.",
                          "url": "https://github.com/idaholab/moose/discussions/19470#discussioncomment-1697231",
                          "updatedAt": "2022-07-11T20:56:29Z",
                          "publishedAt": "2021-11-25T00:29:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud, sorry for the late reply, I was busy with other stuff early today.\nIs this a new material object? I couldn't find it in my MOOSE dir, I try to look for an example now sure how to input subdomain_to_prop_value\n\nso in this case, if I have 100+ blocks, I have to list all of them here, right?\n@aprilnovak noted, i learned that when I first try to use [Controls] with [Materials], it ignores the duplicated materials, but it doesn't ignore the unassigned materials, unfortunately.\n\nIs the material used in all blocks btw? When not used you can just omit it.\n\nno, I actually want to only assign the properties to the mined blocks, and the unmined blocks the properties would be 0\nKind regards,\ntraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/19470#discussioncomment-1697928",
                          "updatedAt": "2022-07-11T20:56:28Z",
                          "publishedAt": "2021-11-25T05:17:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It s not new but I renamed it recently. In your version MOOSE it s still call FVPropValPerSubdomain or something like that\nYou have to list all the ones you want to define a value for yes",
                          "url": "https://github.com/idaholab/moose/discussions/19470#discussioncomment-1697931",
                          "updatedAt": "2022-08-19T11:57:46Z",
                          "publishedAt": "2021-11-25T05:21:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud\nit doesnt seem to work from my end, not sure if I got the right syntax?\n[./excav_poro1]\n   type = FVPropValPerSubdomainMaterial\n   prop_name  = 'excav_poro'\n   subdomain_to_prop_value =  'ALL_TET10 1\n                               DRIVE1_TET10 1\n                               DRIVE2_TET10 1\n                               DRIVE3_TET10 1\n                               DRIVE4_TET10 1\n                               FLOOR_TET10 1\n                               STOPE2_TET10 1\n                               STOPE3_TET10 1\n                               STOPE4_TET10 1\n                               WALLS_TET10 1'\n [../]\n\nAuxVar/AuxKernel couldn't pick it up\n[./excav_poro]\norder = CONSTANT\nfamily = MONOMIAL\n[../]\n[./excav_poro]\n    type = MaterialRealAux\n    property = excav_poro\n    variable = excav_poro\n  [../]\n\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/19470#discussioncomment-1713186",
                          "updatedAt": "2022-08-19T11:57:46Z",
                          "publishedAt": "2021-11-29T01:04:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "I think FVPropValPerSubdomainMaterial only works with FV kernels\njust wondering if PiecewiseConstantByBlockMaterial has been merged yet?",
                          "url": "https://github.com/idaholab/moose/discussions/19470#discussioncomment-1713195",
                          "updatedAt": "2022-08-19T11:57:49Z",
                          "publishedAt": "2021-11-29T01:08:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There s no distinction between FV and FE kernels for auxkernels, because there is no (face) flux kernel for the auxiliary system.\nPiecewiseConstantByBlockMaterial is indeed merged but it s just a rename so that wont help you.\nWhat's the error message you get when you say it cant pick it up",
                          "url": "https://github.com/idaholab/moose/discussions/19470#discussioncomment-1713211",
                          "updatedAt": "2022-08-19T11:57:48Z",
                          "publishedAt": "2021-11-29T01:16:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@GiudGiud, my bad I thought I pasted it earlier\nMaterial property 'excav_poro', requested by 'excav_poro' is not defined on block ALL_TET10\nMaterial property 'excav_poro', requested by 'excav_poro' is not defined on block DRIVE1_TET10\nMaterial property 'excav_poro', requested by 'excav_poro' is not defined on block DRIVE2_TET10\nMaterial property 'excav_poro', requested by 'excav_poro' is not defined on block DRIVE3_TET10\nMaterial property 'excav_poro', requested by 'excav_poro' is not defined on block DRIVE4_TET10\nMaterial property 'excav_poro', requested by 'excav_poro' is not defined on block FLOOR_TET10\nMaterial property 'excav_poro', requested by 'excav_poro' is not defined on block STOPE2_TET10\nMaterial property 'excav_poro', requested by 'excav_poro' is not defined on block STOPE3_TET10\nMaterial property 'excav_poro', requested by 'excav_poro' is not defined on block STOPE4_TET10\nMaterial property 'excav_poro', requested by 'excav_poro' is not defined on block WALLS_TET10",
                          "url": "https://github.com/idaholab/moose/discussions/19470#discussioncomment-1713219",
                          "updatedAt": "2022-08-19T11:57:49Z",
                          "publishedAt": "2021-11-29T01:18:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Could be an AD thing, like FVPropVal may be defining AD properties\nI ll check later.",
                          "url": "https://github.com/idaholab/moose/discussions/19470#discussioncomment-1713251",
                          "updatedAt": "2022-08-19T11:57:50Z",
                          "publishedAt": "2021-11-29T01:35:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Noted, Thanks @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/19470#discussioncomment-1713253",
                          "updatedAt": "2022-08-19T11:57:50Z",
                          "publishedAt": "2021-11-29T01:36:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "./therm_soln_compare.py",
          "author": {
            "login": "wowodejiajia"
          },
          "bodyText": "Dear MOOSE developers,\nI'm studying tutorials of heat_conduction. In the last step - Comparison of results.\nIt is executed by typing: ./therm_soln_compare.py\nfrom the directory where the problems are run.\nIt can not generate an image called therm_soln_compare.png with line plots for these three cases.",
          "url": "https://github.com/idaholab/moose/discussions/19577",
          "updatedAt": "2022-07-06T07:21:02Z",
          "publishedAt": "2021-12-08T02:26:45Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\njust tried and it worked fine.\nDid you run all input files in the folder? Can you give us the output of ls -l in that folder ?\nHere s the plot",
                  "url": "https://github.com/idaholab/moose/discussions/19577#discussioncomment-1769983",
                  "updatedAt": "2022-07-06T07:21:02Z",
                  "publishedAt": "2021-12-08T02:46:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wowodejiajia"
                          },
                          "bodyText": "-bash: ./therm_soln_compare.py: No such file or directory",
                          "url": "https://github.com/idaholab/moose/discussions/19577#discussioncomment-1770058",
                          "updatedAt": "2021-12-08T03:04:07Z",
                          "publishedAt": "2021-12-08T03:04:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I saw the directory list in my email but it s not here??\nthe file should be there. Can you please give us the output of ls -l and pwd ?\nthis is the ./therm_soln_compare.py script btw\n#!/usr/bin/env python\nimport matplotlib\nmatplotlib.use('Agg')\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndata02a=pd.read_csv('therm_step02a_out_t_sampler_0006.csv')\ndata03=pd.read_csv('therm_step03_out_t_sampler_0006.csv')\ndata03a=pd.read_csv('therm_step03a_out_t_sampler_0006.csv')\n\nplt.figure(figsize=(6.0,4.5))\nax=plt.gca()\n\ndata02a.plot(ax=ax, x='x', y='T',label='Conduction (step02a)')\ndata03.plot(ax=ax, x='x', y='T',label='Conduction + Time Deriv. (step03)')\ndata03a.plot(ax=ax, x='x', y='T',label='Conduction + Time Deriv. + Volumetric (step03a)')\n\nax.set_xlabel(\"Position\")\nax.set_ylabel(\"Temperature\")\n\nplt.savefig('therm_soln_compare.png', bbox_inches='tight', pad_inches=0.1)",
                          "url": "https://github.com/idaholab/moose/discussions/19577#discussioncomment-1770171",
                          "updatedAt": "2021-12-08T03:41:49Z",
                          "publishedAt": "2021-12-08T03:41:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wowodejiajia"
                          },
                          "bodyText": "I don't have the therm_soln_compare.py file. Just put the files in the folder.\nThank you.",
                          "url": "https://github.com/idaholab/moose/discussions/19577#discussioncomment-1770190",
                          "updatedAt": "2021-12-08T03:49:10Z",
                          "publishedAt": "2021-12-08T03:49:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Functor mu_rampdown",
          "author": {
            "login": "erikgus94"
          },
          "bodyText": "After the last update I have gotten an error related to the functor 'mu_rampdown'.\n\nAs I understand there now, as the error message says, a functor for 'mu_rampdown' included in GeneralFunctorFluidProps. My question is, do I have to include GeneralFunctorFluidProps to use 'mu_rampdown'? Because when I do I get another error message which will be my next question depending on the answer to this one.\nInput file below:\n[Mesh]\n  [cmg]\n    type = CartesianMeshGenerator\n    dim = 3\n    dx = '0.05 0.4 0.05'\n    dy = '0.05 0.4 0.05'\n    dz = '0.05'\n    ix = '8 48 8'\n    iy = '8 48 8'\n    iz = '8'\n    subdomain_id = '0 0 0\n                    0 1 0\n                    0 0 0'\n  []\n  [delete_center]\n    type = BlockDeletionGenerator\n    input = 'cmg'\n    block = 1\n  []\n  [add_inlet1]\n    type = ParsedGenerateSideset\n    input = 'delete_center'\n    combinatorial_geometry = 'x<0.05 & y>0.49999'\n    new_sideset_name = 'inlet1'\n  []\n  [add_inlet2]\n    type = ParsedGenerateSideset\n    input = 'add_inlet1'\n    combinatorial_geometry = 'x>0.45 & y>0.49999'\n    new_sideset_name = 'inlet2'\n  []\n  [add_outlet]\n    type = ParsedGenerateSideset\n    input = 'add_inlet2'\n    combinatorial_geometry = '(x>0.45 | x<0.05) & y<0.00001'\n    new_sideset_name = 'outlet'\n  []\n  [add_wall_top]\n    type = ParsedGenerateSideset\n    input = 'add_outlet'\n    combinatorial_geometry = 'x>0.05 & x<0.45 & (y>0.49999 | (y<0.450001 & y>0.3))'\n    new_sideset_name = 'walls_top'\n  []\n  [add_wall_bot]\n    type = ParsedGenerateSideset\n    input = 'add_wall_top'\n    combinatorial_geometry = 'x>0.05 & x<0.45 & (y<0.00001 | (y>0.049999 & y<0.1))'\n    new_sideset_name = 'walls_bottom'\n  []\n  [add_wall_left]\n    type = ParsedGenerateSideset\n    input = 'add_wall_bot'\n    combinatorial_geometry = '(x<0.00001 | (y>0.04999 & y<0.449999 & x>0.049999 & x<0.2))'\n    new_sideset_name = 'walls_left'\n  []\n  [add_wall_right]\n    type = ParsedGenerateSideset\n    input = 'add_wall_left'\n    combinatorial_geometry = '(x>0.49999 | (y>0.04999 & y<0.449999 & x>0.3 & x<0.450001))'\n    new_sideset_name = 'walls_right'\n    show_info = true\n  []\n[]\n\nmu = 0.001241                   # The viscosity [Pa*s]\nrho = 1611                      # Density [kg/m\u00b3]\nk = 1.10                        # Thermal conductivity [W/m*K]\ncp = 2097.8                     # Specific heat capacity [J/kg*K]\nalpha = 0.0003035               # Thermal expansion\ntemp_ref = 873.15               # Reference temperature for the thermal expansion law\n\nvel = 'velocity'\nvelocity_interp_method = 'rc'\nadvected_interp_method = 'upwind'\ncold_temp = 660\nhot_temp = 740\n\nIC_u = 9e-3\nIC_v = 9e-3\n\n[Variables]\n  [u]\n    type = INSFVVelocityVariable\n    cache_cell_gradients = false\n  []\n  [v]\n    type = INSFVVelocityVariable\n    cache_cell_gradients = false\n  []\n  [w]\n    type = INSFVVelocityVariable\n    cache_cell_gradients = false\n  []\n  [pressure]\n    type = INSFVPressureVariable\n    cache_cell_gradients = false\n  []\n  [T]\n    type = INSFVEnergyVariable\n    cache_cell_gradients = false\n    scaling = 1e-4\n  []\n  [lambda]\n    family = SCALAR\n    order = FIRST\n  []\n[]\n\n\n[AuxVariables]\n  [U]\n    order = CONSTANT\n    family = MONOMIAL\n    fv = true\n    cache_cell_gradients = false\n  []\n  [mixing_len]\n    type = MooseVariableFVReal\n    cache_cell_gradients = false\n  []\n[]\n\n[ICs]\n  [temperature_gradient]\n    type = FunctionIC\n    variable = T\n    function = 'gradient_temp'\n  []\n  [v_gradient]\n    type = FunctionIC\n    variable = v\n    function = 'gradient_v'\n  []\n  [u_gradient]\n    type = FunctionIC\n    variable = u\n    function = 'gradient_u'\n  []\n[]\n\n[Functions]\n  # linear temperature profile for initialization\n  [gradient_temp]\n    type = ParsedFunction\n    value = 'if(y<0.05, hot_temp, if(y>0.45, cold_temp, hot_temp - (hot_temp-cold_temp) * y / 0.45))'\n    vars = 'cold_temp hot_temp'\n    vals = '${cold_temp} ${hot_temp}'\n  []\n  [gradient_v]\n    type = ParsedFunction\n    value = 'if(x<0.04375 & x>0.00625 & y>0.05 & y<0.45, IC_v,\n    if(x>0.45625 & x<0.49375 & y>0.05 & y<0.45, -IC_v,\n    if(x<0.04375 & x>0.00625 & y>0.01 & y<0.05, IC_v * y / 0.05,\n    if(x>0.45625 & x<0.49375 & y>0.01 & y<0.05, -IC_v * y / 0.05,\n    if(x<0.04375 & x>0.00625 & y>0.45 & y<0.49, IC_v - IC_v * (y - 0.45) / 0.05,\n    if(x>0.45625 & x<0.49375 & y>0.45 & y<0.49, -IC_v + IC_v * (y - 0.45) / 0.05,\n    0))))))'\n    vars = 'IC_v'\n    vals = '${IC_v}'\n  []\n  [gradient_u]\n    type = ParsedFunction\n    value = 'if(y<0.04375 & y>0.00625 & x>0.05 & x<0.45, -IC_u * (1 - (y/0.05)/3),\n    if(y>0.45625 & y<0.49375 & x>0.05 & x<0.45, IC_u * (2/3 - ((0.45 - y)/0.05)/3),\n    if(y<0.04375 & y>0.00625 & x>0.01 & x<0.05, -IC_u * x / 0.05,\n    if(y>0.45625 & y<0.49375 & x>0.01 & x<0.05, IC_u * x / 0.05,\n    if(y<0.04375 & y>0.00625 & x>0.45 & x<0.49, -IC_u + IC_u * (x - 0.45) / 0.05,\n    if(y>0.45625 & y<0.49375 & x>0.45 & x<0.49, IC_u - IC_u * (x - 0.45) / 0.05,\n    0))))))'\n    vars = 'IC_u'\n    vals = '${IC_u}'\n  []\n[]\n\n[AuxKernels]\n  [mag]\n    type = VectorMagnitudeAux\n    variable = U\n    x = u\n    y = v\n    z = w\n    execute_on = 'initial timestep_end'\n  []\n  inactive = 'mixing_len'\n  [mixing_len]\n    type = WallDistanceMixingLengthAux\n    walls = 'walls_top walls_bottom walls_sides inlet1 inlet2 outlet'\n    variable = mixing_len\n    execute_on = 'initial timestep_end'\n    delta = 0.5\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    vel = ${vel}\n    advected_interp_method = ${advected_interp_method}\n    velocity_interp_method = ${velocity_interp_method}\n    u = u\n    v = v\n    w = w\n    pressure = pressure\n    mu = 'mu'\n    rho = ${rho}\n  []\n  [mean_zero_pressure]\n    type = FVScalarLagrangeMultiplier\n    variable = pressure\n    lambda = lambda\n  []\n\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = 'u'\n    rho = ${rho}\n  []\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = u\n    advected_quantity = 'rhou'\n    vel = ${vel}\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n    pressure = pressure\n    u = u\n    v = v\n    w = w\n    mu = 'mu'\n    rho = ${rho}\n  []\n  [u_viscosity]\n    type = FVDiffusion\n    variable = u\n    coeff = ${mu}\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = u\n    momentum_component = 'x'\n    pressure = pressure\n  []\n  [u_turb]\n    type = INSFVMixingLengthReynoldsStress\n    variable = u\n    rho = ${rho}\n    mixing_length = mixing_len\n    momentum_component = 'x'\n    u = u\n    v = v\n    w = w\n  []\n\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = v\n    rho = ${rho}\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = v\n    advected_quantity = 'rhov'\n    vel = ${vel}\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n    pressure = pressure\n    u = u\n    v = v\n    w = w\n    mu = 'mu'\n    rho = ${rho}\n  []\n  [v_viscosity]\n    type = FVDiffusion\n    variable = v\n    coeff = ${mu}\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = v\n    momentum_component = 'y'\n    pressure = pressure\n  []\n  [v_turb]\n    type = INSFVMixingLengthReynoldsStress\n    variable = v\n    rho = ${rho}\n    mixing_length = mixing_len\n    momentum_component = 'y'\n    u = u\n    v = v\n    w = w\n  []\n  [v_buoyancy]\n    type = INSFVMomentumBoussinesq\n    variable = v\n    T_fluid = T\n    gravity = '0 -9.82 0'\n    rho = ${rho}\n    ref_temperature = ${temp_ref}\n    momentum_component = 'y'\n  []\n  [v_gravity]\n    type = INSFVMomentumGravity\n    variable = v\n    gravity = '0 -9.82 0'\n    rho = ${rho}\n    momentum_component = 'y'\n  []\n\n  [w_time]\n    type = INSFVMomentumTimeDerivative\n    variable = w\n    rho = ${rho}\n  []\n  [w_advection]\n    type = INSFVMomentumAdvection\n    variable = w\n    advected_quantity = 'rhow'\n    vel = ${vel}\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n    pressure = pressure\n    u = u\n    v = v\n    w = w\n    mu = 'mu'\n    rho = ${rho}\n  []\n  [w_viscosity]\n    type = FVDiffusion\n    variable = w\n    coeff = ${mu}\n  []\n  [w_pressure]\n    type = INSFVMomentumPressure\n    variable = w\n    momentum_component = 'z'\n    pressure = pressure\n  []\n  [w_turb]\n    type = INSFVMixingLengthReynoldsStress\n    variable = w\n    rho = ${rho}\n    mixing_length = mixing_len\n    momentum_component = 'z'\n    u = u\n    v = v\n    w = w\n  []\n\n  [temp_time]\n    type = INSFVEnergyTimeDerivative\n    variable = T\n    rho = ${rho}\n    cp_name = 'cp'\n  []\n  [temp_conduction]\n    type = FVDiffusion\n    coeff = 'k'\n    variable = T\n  []\n  [temp_advection]\n    type = INSFVEnergyAdvection\n    variable = T\n    vel = ${vel}\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n    pressure = pressure\n    u = u\n    v = v\n    w = w\n    mu = 'mu'\n    rho = ${rho}\n  []\n  [temp_turb]\n    type = WCNSFVMixingLengthEnergyDiffusion\n    variable = T\n    rho = ${rho}\n    cp = 'cp'\n    mixing_length = mixing_len\n    schmidt_number = 0.5\n    u = u\n    v = v\n    w = w\n  []\n[]\n\n[ScalarKernels]\n  [mean_zero_pressure_lm]\n    type = AverageValueConstraint\n    variable = lambda\n    pp_name = pressure_integral\n    value = 0\n  []\n[]\n\n[FVBCs]\n [no_slip_x]\n   type = INSFVNoSlipWallBC\n   variable = u\n   boundary = 'walls_top walls_right walls_bottom walls_left inlet1 inlet2 outlet back front'\n   function = 0\n []\n [no_slip_y]\n   type = INSFVNoSlipWallBC\n   variable = v\n   boundary = 'walls_top walls_right walls_bottom walls_left inlet1 inlet2 outlet back front'\n   function = 0\n  []\n  [no_slip_z]\n   type = INSFVNoSlipWallBC\n   variable = w\n   boundary = 'walls_top walls_right walls_bottom walls_left inlet1 inlet2 outlet back front'\n   function = 0\n  []\n\n  [T_hot]\n    type = FVDirichletBC\n    variable = 'T'\n    boundary = 'walls_bottom'\n    value = ${hot_temp}\n  []\n\n  [T_cold]\n    type = FVDirichletBC\n    variable = 'T'\n    boundary = 'walls_top'\n    value = ${cold_temp}\n  []\n[]\n\n[Functions]\n  [mu_rampdown]\n    type = PiecewiseLinear\n    x = '0.1 1 2 3'\n    y = '${fparse 1e3*mu} ${fparse 1e2*mu} ${fparse 1e1*mu} ${mu}'\n  []\n[]\n\n[Postprocessors]\n  # To watch the rampdown\n  [mu]\n    type = FunctionValuePostprocessor\n    function = mu_rampdown\n  []\n  # To evaluate convergence (visual inspection still necessary!)\n  [average_temperature]\n    type = ElementAverageValue\n    variable = T\n  []\n  [average_velocity_v]\n    type = ElementAverageValue\n    variable = v\n  []\n  [average_velocity_u]\n    type = ElementAverageValue\n    variable = u\n  []\n  [average_pressure]\n    type = ElementAverageValue\n    variable = pressure\n  []\n  [pressure_integral]\n    type = ElementIntegralVariablePostprocessor\n    variable = pressure\n    execute_on = linear\n  []\n[]\n\n\n[Materials]\n  [const_functor]\n    type = ADGenericConstantFunctorMaterial\n    prop_names = 'cp k alpha_b'\n    prop_values = '${cp} ${k} ${alpha}'\n  []\n  [mu_functor]\n    type = ADGenericFunctionFunctorMaterial\n    prop_names = 'mu'\n    prop_values = 'mu_rampdown'\n  []\n  [ins_fv]\n    type = INSFVMaterial\n    u = 'u'\n    v = 'v'\n    w = 'w'\n    pressure = 'pressure'\n    temperature = 'T'\n    rho = ${rho}\n  []\n[]\n\n[Executioner]\n  type = Transient\n  dt = 0.01\n  dtmax = 1\n  # 1s after the end of the mu_rampdown\n  # going further could be required to relax the system to steady state further\n  end_time = 4\n  timestep_tolerance = 1e-5\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_pc_type -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm             1200                ilu           NONZERO'\n  nl_rel_tol = 1e-5\n  nl_abs_tol = 1e-5\n  line_search = 'none'\n  #automatic_scaling = true\n  off_diagonals_in_auto_scaling = true\n[]\n[Debug]\n  show_var_residual_norms = true\n[]\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/19488",
          "updatedAt": "2022-06-23T15:23:36Z",
          "publishedAt": "2021-11-25T14:17:11Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nA viscosity rampdown can be performed without the GeneralFunctorFluidProps if you have constant fluid properties or define them differently.\n\nIf you want to use fluid properties with a rampdown, this parameter is actually completely ignored right now. I ll push a fix soon.\n\nYou cannot do what you did, which is specify a mu_rampdown functor and use generalFunctorFluidPropsrties, because the mu_rampdown is a function right not a functor material property.\n\nOnce I m done with the fix I ll post back here with the correct syntax.\nIf you have access to Pronghorn, the fix is there already in PronghornFluidProps.\n\nGuillaume\n\u2026\n Le 25 nov. 2021 \u00e0 08:17, Erik Gustafsson ***@***.***> a \u00e9crit :\n\n \ufeff\n After the last update I have gotten an error related to the functor 'mu_rampdown'.\n\n\n As I understand there now, as the error message says, a functor for 'mu_rampdown' included in GeneralFunctorFluidProps. My question is, do I have to include GeneralFunctorFluidProps to use 'mu_rampdown'? Because when I do I get another error message which will be my next question depending on the answer to this one.\n\n Input file below:\n\n [Mesh]\n   [cmg]\n     type = CartesianMeshGenerator\n     dim = 3\n     dx = '0.05 0.4 0.05'\n     dy = '0.05 0.4 0.05'\n     dz = '0.05'\n     ix = '8 48 8'\n     iy = '8 48 8'\n     iz = '8'\n     subdomain_id = '0 0 0\n                     0 1 0\n                     0 0 0'\n   []\n   [delete_center]\n     type = BlockDeletionGenerator\n     input = 'cmg'\n     block = 1\n   []\n   [add_inlet1]\n     type = ParsedGenerateSideset\n     input = 'delete_center'\n     combinatorial_geometry = 'x<0.05 & y>0.49999'\n     new_sideset_name = 'inlet1'\n   []\n   [add_inlet2]\n     type = ParsedGenerateSideset\n     input = 'add_inlet1'\n     combinatorial_geometry = 'x>0.45 & y>0.49999'\n     new_sideset_name = 'inlet2'\n   []\n   [add_outlet]\n     type = ParsedGenerateSideset\n     input = 'add_inlet2'\n     combinatorial_geometry = '(x>0.45 | x<0.05) & y<0.00001'\n     new_sideset_name = 'outlet'\n   []\n   [add_wall_top]\n     type = ParsedGenerateSideset\n     input = 'add_outlet'\n     combinatorial_geometry = 'x>0.05 & x<0.45 & (y>0.49999 | (y<0.450001 & y>0.3))'\n     new_sideset_name = 'walls_top'\n   []\n   [add_wall_bot]\n     type = ParsedGenerateSideset\n     input = 'add_wall_top'\n     combinatorial_geometry = 'x>0.05 & x<0.45 & (y<0.00001 | (y>0.049999 & y<0.1))'\n     new_sideset_name = 'walls_bottom'\n   []\n   [add_wall_left]\n     type = ParsedGenerateSideset\n     input = 'add_wall_bot'\n     combinatorial_geometry = '(x<0.00001 | (y>0.04999 & y<0.449999 & x>0.049999 & x<0.2))'\n     new_sideset_name = 'walls_left'\n   []\n   [add_wall_right]\n     type = ParsedGenerateSideset\n     input = 'add_wall_left'\n     combinatorial_geometry = '(x>0.49999 | (y>0.04999 & y<0.449999 & x>0.3 & x<0.450001))'\n     new_sideset_name = 'walls_right'\n     show_info = true\n   []\n []\n\n mu = 0.001241                   # The viscosity [Pa*s]\n rho = 1611                      # Density [kg/m\u00b3]\n k = 1.10                        # Thermal conductivity [W/m*K]\n cp = 2097.8                     # Specific heat capacity [J/kg*K]\n alpha = 0.0003035               # Thermal expansion\n temp_ref = 873.15               # Reference temperature for the thermal expansion law\n\n vel = 'velocity'\n velocity_interp_method = 'rc'\n advected_interp_method = 'upwind'\n cold_temp = 660\n hot_temp = 740\n\n IC_u = 9e-3\n IC_v = 9e-3\n\n [Variables]\n   [u]\n     type = INSFVVelocityVariable\n     cache_cell_gradients = false\n   []\n   [v]\n     type = INSFVVelocityVariable\n     cache_cell_gradients = false\n   []\n   [w]\n     type = INSFVVelocityVariable\n     cache_cell_gradients = false\n   []\n   [pressure]\n     type = INSFVPressureVariable\n     cache_cell_gradients = false\n   []\n   [T]\n     type = INSFVEnergyVariable\n     cache_cell_gradients = false\n     scaling = 1e-4\n   []\n   [lambda]\n     family = SCALAR\n     order = FIRST\n   []\n []\n\n\n [AuxVariables]\n   [U]\n     order = CONSTANT\n     family = MONOMIAL\n     fv = true\n     cache_cell_gradients = false\n   []\n   [mixing_len]\n     type = MooseVariableFVReal\n     cache_cell_gradients = false\n   []\n []\n\n [ICs]\n   [temperature_gradient]\n     type = FunctionIC\n     variable = T\n     function = 'gradient_temp'\n   []\n   [v_gradient]\n     type = FunctionIC\n     variable = v\n     function = 'gradient_v'\n   []\n   [u_gradient]\n     type = FunctionIC\n     variable = u\n     function = 'gradient_u'\n   []\n []\n\n [Functions]\n   # linear temperature profile for initialization\n   [gradient_temp]\n     type = ParsedFunction\n     value = 'if(y<0.05, hot_temp, if(y>0.45, cold_temp, hot_temp - (hot_temp-cold_temp) * y / 0.45))'\n     vars = 'cold_temp hot_temp'\n     vals = '${cold_temp} ${hot_temp}'\n   []\n   [gradient_v]\n     type = ParsedFunction\n     value = 'if(x<0.04375 & x>0.00625 & y>0.05 & y<0.45, IC_v,\n     if(x>0.45625 & x<0.49375 & y>0.05 & y<0.45, -IC_v,\n     if(x<0.04375 & x>0.00625 & y>0.01 & y<0.05, IC_v * y / 0.05,\n     if(x>0.45625 & x<0.49375 & y>0.01 & y<0.05, -IC_v * y / 0.05,\n     if(x<0.04375 & x>0.00625 & y>0.45 & y<0.49, IC_v - IC_v * (y - 0.45) / 0.05,\n     if(x>0.45625 & x<0.49375 & y>0.45 & y<0.49, -IC_v + IC_v * (y - 0.45) / 0.05,\n     0))))))'\n     vars = 'IC_v'\n     vals = '${IC_v}'\n   []\n   [gradient_u]\n     type = ParsedFunction\n     value = 'if(y<0.04375 & y>0.00625 & x>0.05 & x<0.45, -IC_u * (1 - (y/0.05)/3),\n     if(y>0.45625 & y<0.49375 & x>0.05 & x<0.45, IC_u * (2/3 - ((0.45 - y)/0.05)/3),\n     if(y<0.04375 & y>0.00625 & x>0.01 & x<0.05, -IC_u * x / 0.05,\n     if(y>0.45625 & y<0.49375 & x>0.01 & x<0.05, IC_u * x / 0.05,\n     if(y<0.04375 & y>0.00625 & x>0.45 & x<0.49, -IC_u + IC_u * (x - 0.45) / 0.05,\n     if(y>0.45625 & y<0.49375 & x>0.45 & x<0.49, IC_u - IC_u * (x - 0.45) / 0.05,\n     0))))))'\n     vars = 'IC_u'\n     vals = '${IC_u}'\n   []\n []\n\n [AuxKernels]\n   [mag]\n     type = VectorMagnitudeAux\n     variable = U\n     x = u\n     y = v\n     z = w\n     execute_on = 'initial timestep_end'\n   []\n   inactive = 'mixing_len'\n   [mixing_len]\n     type = WallDistanceMixingLengthAux\n     walls = 'walls_top walls_bottom walls_sides inlet1 inlet2 outlet'\n     variable = mixing_len\n     execute_on = 'initial timestep_end'\n     delta = 0.5\n   []\n []\n\n [FVKernels]\n   [mass]\n     type = INSFVMassAdvection\n     variable = pressure\n     vel = ${vel}\n     advected_interp_method = ${advected_interp_method}\n     velocity_interp_method = ${velocity_interp_method}\n     u = u\n     v = v\n     w = w\n     pressure = pressure\n     mu = 'mu'\n     rho = ${rho}\n   []\n   [mean_zero_pressure]\n     type = FVScalarLagrangeMultiplier\n     variable = pressure\n     lambda = lambda\n   []\n\n   [u_time]\n     type = INSFVMomentumTimeDerivative\n     variable = 'u'\n     rho = ${rho}\n   []\n   [u_advection]\n     type = INSFVMomentumAdvection\n     variable = u\n     advected_quantity = 'rhou'\n     vel = ${vel}\n     velocity_interp_method = ${velocity_interp_method}\n     advected_interp_method = ${advected_interp_method}\n     pressure = pressure\n     u = u\n     v = v\n     w = w\n     mu = 'mu'\n     rho = ${rho}\n   []\n   [u_viscosity]\n     type = FVDiffusion\n     variable = u\n     coeff = ${mu}\n   []\n   [u_pressure]\n     type = INSFVMomentumPressure\n     variable = u\n     momentum_component = 'x'\n     pressure = pressure\n   []\n   [u_turb]\n     type = INSFVMixingLengthReynoldsStress\n     variable = u\n     rho = ${rho}\n     mixing_length = mixing_len\n     momentum_component = 'x'\n     u = u\n     v = v\n     w = w\n   []\n\n   [v_time]\n     type = INSFVMomentumTimeDerivative\n     variable = v\n     rho = ${rho}\n   []\n   [v_advection]\n     type = INSFVMomentumAdvection\n     variable = v\n     advected_quantity = 'rhov'\n     vel = ${vel}\n     velocity_interp_method = ${velocity_interp_method}\n     advected_interp_method = ${advected_interp_method}\n     pressure = pressure\n     u = u\n     v = v\n     w = w\n     mu = 'mu'\n     rho = ${rho}\n   []\n   [v_viscosity]\n     type = FVDiffusion\n     variable = v\n     coeff = ${mu}\n   []\n   [v_pressure]\n     type = INSFVMomentumPressure\n     variable = v\n     momentum_component = 'y'\n     pressure = pressure\n   []\n   [v_turb]\n     type = INSFVMixingLengthReynoldsStress\n     variable = v\n     rho = ${rho}\n     mixing_length = mixing_len\n     momentum_component = 'y'\n     u = u\n     v = v\n     w = w\n   []\n   [v_buoyancy]\n     type = INSFVMomentumBoussinesq\n     variable = v\n     T_fluid = T\n     gravity = '0 -9.82 0'\n     rho = ${rho}\n     ref_temperature = ${temp_ref}\n     momentum_component = 'y'\n   []\n   [v_gravity]\n     type = INSFVMomentumGravity\n     variable = v\n     gravity = '0 -9.82 0'\n     rho = ${rho}\n     momentum_component = 'y'\n   []\n\n   [w_time]\n     type = INSFVMomentumTimeDerivative\n     variable = w\n     rho = ${rho}\n   []\n   [w_advection]\n     type = INSFVMomentumAdvection\n     variable = w\n     advected_quantity = 'rhow'\n     vel = ${vel}\n     velocity_interp_method = ${velocity_interp_method}\n     advected_interp_method = ${advected_interp_method}\n     pressure = pressure\n     u = u\n     v = v\n     w = w\n     mu = 'mu'\n     rho = ${rho}\n   []\n   [w_viscosity]\n     type = FVDiffusion\n     variable = w\n     coeff = ${mu}\n   []\n   [w_pressure]\n     type = INSFVMomentumPressure\n     variable = w\n     momentum_component = 'z'\n     pressure = pressure\n   []\n   [w_turb]\n     type = INSFVMixingLengthReynoldsStress\n     variable = w\n     rho = ${rho}\n     mixing_length = mixing_len\n     momentum_component = 'z'\n     u = u\n     v = v\n     w = w\n   []\n\n   [temp_time]\n     type = INSFVEnergyTimeDerivative\n     variable = T\n     rho = ${rho}\n     cp_name = 'cp'\n   []\n   [temp_conduction]\n     type = FVDiffusion\n     coeff = 'k'\n     variable = T\n   []\n   [temp_advection]\n     type = INSFVEnergyAdvection\n     variable = T\n     vel = ${vel}\n     velocity_interp_method = ${velocity_interp_method}\n     advected_interp_method = ${advected_interp_method}\n     pressure = pressure\n     u = u\n     v = v\n     w = w\n     mu = 'mu'\n     rho = ${rho}\n   []\n   [temp_turb]\n     type = WCNSFVMixingLengthEnergyDiffusion\n     variable = T\n     rho = ${rho}\n     cp = 'cp'\n     mixing_length = mixing_len\n     schmidt_number = 0.5\n     u = u\n     v = v\n     w = w\n   []\n []\n\n [ScalarKernels]\n   [mean_zero_pressure_lm]\n     type = AverageValueConstraint\n     variable = lambda\n     pp_name = pressure_integral\n     value = 0\n   []\n []\n\n [FVBCs]\n  [no_slip_x]\n    type = INSFVNoSlipWallBC\n    variable = u\n    boundary = 'walls_top walls_right walls_bottom walls_left inlet1 inlet2 outlet back front'\n    function = 0\n  []\n  [no_slip_y]\n    type = INSFVNoSlipWallBC\n    variable = v\n    boundary = 'walls_top walls_right walls_bottom walls_left inlet1 inlet2 outlet back front'\n    function = 0\n   []\n   [no_slip_z]\n    type = INSFVNoSlipWallBC\n    variable = w\n    boundary = 'walls_top walls_right walls_bottom walls_left inlet1 inlet2 outlet back front'\n    function = 0\n   []\n\n   [T_hot]\n     type = FVDirichletBC\n     variable = 'T'\n     boundary = 'walls_bottom'\n     value = ${hot_temp}\n   []\n\n   [T_cold]\n     type = FVDirichletBC\n     variable = 'T'\n     boundary = 'walls_top'\n     value = ${cold_temp}\n   []\n []\n\n [Functions]\n   [mu_rampdown]\n     type = PiecewiseLinear\n     x = '0.1 1 2 3'\n     y = '${fparse 1e3*mu} ${fparse 1e2*mu} ${fparse 1e1*mu} ${mu}'\n   []\n []\n\n [Postprocessors]\n   # To watch the rampdown\n   [mu]\n     type = FunctionValuePostprocessor\n     function = mu_rampdown\n   []\n   # To evaluate convergence (visual inspection still necessary!)\n   [average_temperature]\n     type = ElementAverageValue\n     variable = T\n   []\n   [average_velocity_v]\n     type = ElementAverageValue\n     variable = v\n   []\n   [average_velocity_u]\n     type = ElementAverageValue\n     variable = u\n   []\n   [average_pressure]\n     type = ElementAverageValue\n     variable = pressure\n   []\n   [pressure_integral]\n     type = ElementIntegralVariablePostprocessor\n     variable = pressure\n     execute_on = linear\n   []\n []\n\n\n [Materials]\n   [const_functor]\n     type = ADGenericConstantFunctorMaterial\n     prop_names = 'cp k alpha_b'\n     prop_values = '${cp} ${k} ${alpha}'\n   []\n   [mu_functor]\n     type = ADGenericFunctionFunctorMaterial\n     prop_names = 'mu'\n     prop_values = 'mu_rampdown'\n   []\n   [ins_fv]\n     type = INSFVMaterial\n     u = 'u'\n     v = 'v'\n     w = 'w'\n     pressure = 'pressure'\n     temperature = 'T'\n     rho = ${rho}\n   []\n []\n\n [Executioner]\n   type = Transient\n   dt = 0.01\n   dtmax = 1\n   # 1s after the end of the mu_rampdown\n   # going further could be required to relax the system to steady state further\n   end_time = 4\n   timestep_tolerance = 1e-5\n   solve_type = 'NEWTON'\n   petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_pc_type -sub_pc_factor_shift_type'\n   petsc_options_value = 'asm             1200                ilu           NONZERO'\n   nl_rel_tol = 1e-5\n   nl_abs_tol = 1e-5\n   line_search = 'none'\n   #automatic_scaling = true\n   off_diagonals_in_auto_scaling = true\n []\n [Debug]\n   show_var_residual_norms = true\n []\n [Outputs]\n   exodus = true\n []\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n Triage notifications on the go with GitHub Mobile for iOS or Android.",
                  "url": "https://github.com/idaholab/moose/discussions/19488#discussioncomment-1701123",
                  "updatedAt": "2022-06-23T15:24:08Z",
                  "publishedAt": "2021-11-25T15:30:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "to be clear this is just a conflict with the names. If you rename viscosity in all the block (mu = 'other_name') that require it, you can let GeneralFunctorFluidProps define a 'mu' viscosity functor material property, and not use it but use the 'other_name' viscosity functor material property instead.\nPatch is here, #19490, not merged yet",
                          "url": "https://github.com/idaholab/moose/discussions/19488#discussioncomment-1711876",
                          "updatedAt": "2022-06-23T15:24:08Z",
                          "publishedAt": "2021-11-28T15:33:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "erikgus94"
                          },
                          "bodyText": "Hi @GiudGiud,\nThanks for the reply and the clarification!\nI'm not sure what you mean. If I define a functor called 'mu' but don't use it. Then define a ADGenericFunctorMaterial called 'other_name' which uses the ''other_name_rampdown' function and replaces 'mu' in all blocks. Then I get the same error as before but saying that 'other_name_rampdown' already exists.\nMaybe you could explain more clearly how to make a functor material property to depend on a function?",
                          "url": "https://github.com/idaholab/moose/discussions/19488#discussioncomment-1715275",
                          "updatedAt": "2022-06-23T15:24:07Z",
                          "publishedAt": "2021-11-29T11:15:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There can only be a single instance of a name across all functor types (eg functions, matprops and variables). Can you make sure the function name is different than the functor material property name (the one defined in ADGenericFunctorMaterial) ?\nUsing the (AD)GenericFunctorMaterial is the correct way to call a function in a functor material property.\nAs a side note, you could also not use a (AD)GenericFunctorMaterial and use the function directly in all the kernels. The functor system lets you do that",
                          "url": "https://github.com/idaholab/moose/discussions/19488#discussioncomment-1716447",
                          "updatedAt": "2022-06-23T15:24:08Z",
                          "publishedAt": "2021-11-29T14:59:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "umm I think you ll run into trouble because PiecewiseLinear is not an AD function. @lindsayad I think we need a way to convert functors",
                          "url": "https://github.com/idaholab/moose/discussions/19488#discussioncomment-1716582",
                          "updatedAt": "2022-06-23T15:24:41Z",
                          "publishedAt": "2021-11-29T15:18:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "erikgus94"
                          },
                          "bodyText": "I don't think the problem is PiecewiseLinear. This worked just fine before the update.\nAlso I made sure that the function does not have the same name as any of the functors and I tried to call the function directly in the kernels. The problem is the same. Here is what I wrote:\n  [const_functor]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k mu alpha_b'\n    prop_values = '${cp} ${k} ${mur} ${alpha}'\n  []\n\n[Functions]\n [other_name_rampdown]\n  type = PiecewiseLinear\n  x = '0.1 1 2 3'\n  y = '${fparse 1e3*other_name} ${fparse 1e2*other_name} ${fparse 1e1*other_name} ${other_name}'\n []\n[]\n\n[FVKernels]\n [mass]\n   type = INSFVMassAdvection\n   variable = pressure\n   vel = ${vel}\n   advected_interp_method = ${advected_interp_method}\n   velocity_interp_method = ${velocity_interp_method}\n   u = u\n   v = v\n   w = w\n   pressure = pressure\n   mu = 'other_name_rampdown'\n   rho = ${rho}\n []",
                          "url": "https://github.com/idaholab/moose/discussions/19488#discussioncomment-1716654",
                          "updatedAt": "2022-06-23T15:24:41Z",
                          "publishedAt": "2021-11-29T15:28:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok so you ll get a conflict between the GeneralFunctorFluidProps and this one\n  [const_functor]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k mu alpha_b'\n    prop_values = '${cp} ${k} ${mur} ${alpha}'\n  []\n\nbecause they both define mu as a functor",
                          "url": "https://github.com/idaholab/moose/discussions/19488#discussioncomment-1716665",
                          "updatedAt": "2022-06-23T15:24:46Z",
                          "publishedAt": "2021-11-29T15:29:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "erikgus94"
                          },
                          "bodyText": "Okay, now there is no functor anywhere named mu. cp and k are called directly in the kernels as constants (not named the same as the functors cp and k from GeneralFunctorFluidProps). mu in the kernels calls the function for mu rampdown which is not named as any other functor. The error message is still the same. Here is the materials block as it looks now, just random inputs as the properties are not used.\n[Modules]\n  [FluidProperties]\n    [fp]\n      type = FlibeFluidProperties\n    []\n  []\n[]\n\n[Materials]\n  [const_functor]\n    type = ADGenericFunctorMaterial\n    prop_names = 'alpha_b'\n    prop_values = '${alpha}'\n  []\n  [ins_fv]\n    type = INSFVMaterial\n    u = 'u'\n    v = 'v'\n    w = 'w'\n    pressure = 'pressure'\n    temperature = 'T'\n    rho = ${rho}\n  []\n  [fluid_props_to_mat_props]\n    type = GeneralFunctorFluidProps\n    fp = fp\n    pressure = 3000\n    T_fluid = 300\n    speed = 1\n    characteristic_length = 1\n    porosity = 1\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/19488#discussioncomment-1716913",
                          "updatedAt": "2022-06-23T15:24:53Z",
                          "publishedAt": "2021-11-29T16:12:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "GeneralFunctorFluidProps defines a 'mu' functor. It s good that there is no other.\nCan you remind me of the error? Is it the one in the first post?\nThat one is basically: \"an AD functor is requested but I only found other types of functors with the same name\".\nSo I think in your case, mu_rampdown is a normal functor, the code is requesting an AD one",
                          "url": "https://github.com/idaholab/moose/discussions/19488#discussioncomment-1717036",
                          "updatedAt": "2022-06-23T15:25:03Z",
                          "publishedAt": "2021-11-29T16:32:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the solution to that will be to use an ADFunction. One of the very few ones we have is the ADParsedFunction\nSame docs as ParsedFunction:\nhttps://mooseframework.inl.gov/moose/source/functions/MooseParsedFunction.html",
                          "url": "https://github.com/idaholab/moose/discussions/19488#discussioncomment-1717042",
                          "updatedAt": "2022-06-23T15:25:03Z",
                          "publishedAt": "2021-11-29T16:33:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "erikgus94"
                          },
                          "bodyText": "Exactly, this is how it look right now:\n\nThe function for mu rampdown is called fisk_ramper",
                          "url": "https://github.com/idaholab/moose/discussions/19488#discussioncomment-1717053",
                          "updatedAt": "2022-06-23T15:25:03Z",
                          "publishedAt": "2021-11-29T16:36:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Action to generate Global params",
          "author": {
            "login": "KhaledNabilSharafeldin"
          },
          "bodyText": "Hello,\nSo currently i'm putting together an action to initialise a lot of variables, auxVariables, and ultimately form global params with the names of these variables. I'm aware of the global params action, but I am not sure how to add it to my action.\nso far what i'm doing is adding the variables when the _current_task = \"add_aux_variable\" and _current_task = \"add_variable\", similar to PolycrystalVariablesAction.\nhowever, I'm not sure how to set the global parameters in the custom action.\nhere's the code I'm using:\nregisterMooseAction(\"CustomApp\", CustomVariablesAction, \"set_global_params\");\n\nvoid\nCustomVariablesAction::act()\n{\n \n  if (_current_task = \"set_global_params\")\n  {\n    auto globalparams = _factory.getValidParams(\"GlobalParamsAction\");\n    globalparams.addParam<std::string>(\"rho_vars\") = _rho_vars;\n    globalparams.addParam<std::string>(\"rho_virt_vars\") = _rho_virt_vars;\n  }\n}\n\nThank you in advance.",
          "url": "https://github.com/idaholab/moose/discussions/19563",
          "updatedAt": "2022-06-02T14:36:12Z",
          "publishedAt": "2021-12-07T02:23:29Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "vanwdani"
                  },
                  "bodyText": "Well, there are a couple of ways to do this.  The GlobalParamAction needs to know what the the expected inputParameter will be on the left side of your conditional statement and the given name on the right.  A typical example would be something like\n[GlobalParams] temperature = temperature []\nThis works well for manually creating input files, but not as well for action creation.  Adding the parameters like you have shown is usually done within the InputParameters section of the Action.  Once these parameters have been defined, then they are available for the user to enter within the corresponding Action block.  This would be something like:\n[MyAction] rho_vars = \"whatever_you_enter\" []\nSo for this action since you are already creating the Variables, and AuxVariables, and the InitialConditions if they have any, you already know what the names will be.  I think you should be able to pass these names directly to whatever class needs them, be it a Material, BC, PostProcessor, or another Action.  If this isn't the case and you want the names from the GlobalParams block to define the names created and then passed, cli_args is probably the easiest route.\nhttps://mooseframework.inl.gov/application_usage/input_syntax.html",
                  "url": "https://github.com/idaholab/moose/discussions/19563#discussioncomment-1766531",
                  "updatedAt": "2022-06-02T14:36:14Z",
                  "publishedAt": "2021-12-07T16:03:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "I do have the names generated by the code, and stored in one string space separated similar to the one passed in the input file\nstd::string _rho_vars = \"var1a var1b var1c var2a \"\n\nwhat I just understood was that this:\n    auto globalparams = _factory.getValidParams(\"GlobalParamsAction\");\n    globalparams.addParam<std::string>(\"rho_vars\") = _rho_vars;\n\nonly CREATES the rho_vars but doesnt fill in the values, is that correct?\nalso, I'm populating this string _rho_vars during add_variable and add_aux_variable, so does set_global_params get called before or after these time flags?\nthank you for your reply!",
                          "url": "https://github.com/idaholab/moose/discussions/19563#discussioncomment-1767947",
                          "updatedAt": "2022-06-02T14:36:28Z",
                          "publishedAt": "2021-12-07T18:21:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vanwdani"
                          },
                          "bodyText": "auto globalparams = _factory.getValidParams(\"GlobalParamsAction\");\nglobalparams.addParam<std::string>(\"rho_vars\") = _rho_vars;\n\nThe 1st line is getting the already defined inputParameters from the GlobalParamsAction, which looking at the file is basically on the the inputParameters of Action.C.  The 2nd line is not placed in the right area.  This should be done within a InputParameters block within the class before initialization.  What this does is says, \"this class is expecting the user to give me the names of the rho variables.\"  You've already created those names within the action, so you can't directly input them.\nSo the question is:  Where are these parameters going to be applied?\nIf you already know where these need to go, you can create the needed classes within your action.  Just like you've used add_variable, you can utilize add_material or add_bc, etc.  Then it's easily done with something like\nauto type = NAME_OF_CLASS;\nauto params = _factory.getValidParams(type);\nparams.set<TYPE_OF_INPUT_PARAMETER_EXPECTED_BY_CLASS>(\"NAME_WITHIN_CLASS) = _rho_vars;\n_problem->addMaterial(type, NAME_OF_BLOCK_YOU_CHOOSE, params);",
                          "url": "https://github.com/idaholab/moose/discussions/19563#discussioncomment-1768098",
                          "updatedAt": "2022-06-02T14:36:24Z",
                          "publishedAt": "2021-12-07T18:46:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}