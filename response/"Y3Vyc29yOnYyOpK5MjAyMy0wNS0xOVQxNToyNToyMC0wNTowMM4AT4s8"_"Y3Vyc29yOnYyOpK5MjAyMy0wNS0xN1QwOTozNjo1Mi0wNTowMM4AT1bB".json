{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNS0xN1QwOTozNjo1Mi0wNTowMM4AT1bB"
    },
    "edges": [
      {
        "node": {
          "title": "Iterative problem",
          "author": {
            "login": "gabburgio"
          },
          "bodyText": "Hello everyone\nI am trying to build an app that implements the procedure to calculate the SPH factors described in https://www.sciencedirect.com/science/article/pii/S0306454919300040 .\nFor the solution aspect, https://www.sciencedirect.com/science/article/pii/S0306454917303079 is also useful.\nMy question is, what MOOSE features are best for this purpose?\nThe procedure is based on iterations in which the multigroup neutron diffusion equation is solved, and then the obtained flux and current values are used to calculate corrective factors for material properties and boundary conditions, and possible source terms with which to solve it again, until convergence of the factors.\nIs it possible to achieve this simply using actions, by having an action that adds problems until convergence?\nShould I use \"MultiApps\" with a single subapplication?\nCan a ReferenceResidualProblem work instead?\nThanks for your time\nGabriele",
          "url": "https://github.com/idaholab/moose/discussions/24124",
          "updatedAt": "2023-05-19T17:57:20Z",
          "publishedAt": "2023-04-19T17:10:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@vincentlaboure @YaqiWang @snschune do you guys want to weigh-in here?",
                  "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5664785",
                  "updatedAt": "2023-04-19T17:33:18Z",
                  "publishedAt": "2023-04-19T17:33:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I would recommend setting this up either as an optimization problem with the optimization module https://mooseframework.inl.gov/modules/optimization/index.html\nOr just do fixed point iterations and use a parametric study from the stochastic tools module\nhttps://mooseframework.inl.gov/syntax/ParameterStudy/index.html\nFor very large SPH factor problems, there is large scale more complex machinery in Griffin to compute the SPH factors (I can find the paper if needed).\nI have used successfully fixed point iterations to get SPH factors with OpenMOC.\nHow many factors are you trying to determine?",
                  "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5664834",
                  "updatedAt": "2023-04-19T17:37:56Z",
                  "publishedAt": "2023-04-19T17:37:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "vincentlaboure"
                  },
                  "bodyText": "The approach described in https://www.sciencedirect.com/science/article/pii/S0306454919300040 is relatively straightforward to perform in MOOSE as the equivalence (SPH, DF or SPH-DF) problem is recast into a steady-state source-free Newton formulation. In Griffin (previously, in Rattlesnake), we then just use a Steady executioner and solve for the fluxes (which the SPH or discontinuity factors are a by-product of).\nFor more complicated problems with tough convergence, it can be useful to first perform a few traditional SPH iterations (as described in Section 2.2.1 of https://www.sciencedirect.com/science/article/pii/S0306454917303079) to provide a good initial guess. Griffin has a dedicated solver to do that is fairly close to a Steady executioner.",
                  "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5664963",
                  "updatedAt": "2023-04-19T17:53:26Z",
                  "publishedAt": "2023-04-19T17:52:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "gabburgio"
                  },
                  "bodyText": "Thanks for the pointers!\nI am now implementing the SPH-PJFNK and I have a couple followup questions:\nIf I understood correctly, the SPH factors are supposed to be incorporated in the material properties. I tried to achieve this by passing an ElementIntegralArrayVariablePostprocessor to the material as a parameter and then using it while computing material properties:\n#include \"DummySPHMaterial.h\"\n\nregisterMooseObject(\"pertApp\",DummySPHMaterial);\n\nInputParameters\nDummySPHMaterial::validParams()\n{\n    InputParameters params = Material::validParams();\n    \n    params.addRequiredParam<RealEigenVector>(\"ref_diffusivity\",\"Serpent 2 diffusion coefficient for each energy group in this material (used as starting value in the iteration)\");\n    params.addRequiredParam<RealEigenVector>(\"ref_sigma_r\",\"Serpent 2 removal cross section for each energy group in this material\");\n    \n    params.addRequiredParam<RealEigenVector>(\"ref_phi_mg\",\"reference flux integrated over the material region\");\n    params.addRequiredParam<PostprocessorValue>(\"zone_integrator\",\"ElementIntegralArrayVariablePostprocessor to calculate the flux integral over the material zone\");   \n    \n    // params.set<MooseEnum>(\"constant_on\") = \"SUBDOMAIN\";\n    \n    return params;\n}\n\nDummySPHMaterial::DummySPHMaterial(const InputParameters & parameters) :\n    Material(parameters),\n    _v_diffusivity(     getParam<RealEigenVector>(\"ref_diffusivity\")),\n    _v_sigma_r(         getParam<RealEigenVector>(\"ref_sigma_r\")),\n    _v_ref_phi_mg(  getParam<RealEigenVector>(\"ref_phi_mg\")),\n    _zone_integrator(    getPostprocessorValue(\"zone_integrator\")),\n\n    _diffusivity(       declareProperty<RealEigenVector>(\"Dummy_diffusivity\")),\n    _sigma_r(           declareProperty<RealEigenVector>(\"Dummy_sigma_r\"))\n\n{\n}\n\n\nvoid\nDummySPHMaterial::computeQpProperties()\n{\n\n\n    for(int i=0; i< _v_diffusivity.size(); i++ ) \n    {\n    _zone_integrator.setParameters(\"component\",i); \n    _diffusivity[_qp][i]    = (_v_ref_phi_mg[i]/_zone_integrator)*_v_diffusivity[i];\n    _sigma_r[_qp][i]           = (_v_ref_phi_mg[i]/_zone_integrator)*_v_sigma_r[i];\n    }\n}\n\nThis however doesn't compile because I am just passing the postprocessor value.\nI don't understand how to pass the postprocessor itself as the parameter, and whether that is feasible in the first place.\nI also thought about somehow integrating the component explicitly while computing material properties, but I'm not sure how to achieve that.\nI also have a somewhat theoretical question: is it correct to say that the reason the SPH-PJFNK is feasible in moose is that, during each step of the linear solve, the Krylov subspace that is used is actually constructed using powers of the Jacobian approximation obtained with the \"latest iteration\" of the residual matrix, i.e. a version in which material properties that depend on the solution have been reevaluated with the values of the solution at the previous krylov step?",
                  "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5701137",
                  "updatedAt": "2023-04-23T17:10:20Z",
                  "publishedAt": "2023-04-23T17:10:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nyou can pass a PostprocessorName then use the getPostprocessorValueByName routine and store this in a reference (that part is really important)\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5701253",
                          "updatedAt": "2023-04-23T17:31:26Z",
                          "publishedAt": "2023-04-23T17:31:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "also <RealEigenVector> isnt what's usually used for vector. We use std::vector<Real>.\nFinally, are you writing the equations in terms of the SPH factors being the nonlinear variables?\nBecause otherwise I don't see how this is SPH-PJFNK",
                          "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5702959",
                          "updatedAt": "2023-04-24T00:54:27Z",
                          "publishedAt": "2023-04-24T00:54:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gabburgio"
                          },
                          "bodyText": "The approach (which is necessary unless I misunderstood how SPH-PJFNK is implemented in MOOSE) was to insert the SPH factors in the material property evaluation.\nSo for a given material, instead of it producing a cross section property Sigma, I wanted to have it produce a property mu*Sigma, where mu is the SPH factor, calculated as mu = (phi_ref)/(phi).\nClearly, to do so the material would have had to take as parameters the reference fluxes, the flux array variable itself, and possibly a postprocessor with which to perform the integrals (although maybe it would have worked better to just instantiate a postprocessor as an attribute of the material object).\nTo my understanding, this would have resulted in the material property being recalculated (i.e. the residual matrix being reassembled) at all linear/nonlinear steps while solving for the flux (hence the question about the matrix used for the Krylov spaces).\nThis is what I assumed @vincentlaboure meant when talking about a steady-state source free reformulation (in that all terms of the equations would be brought to the left hand side, instead of first building the source as in traditional SPH, and the problem itself would be just a (nonlinear, because of the dependence of the material properties on the flux) steady one).\nThis might all be nonsense to be frank, I am dealing with a lot of black boxes here.\nFor instance I don't know if it possible to have a postprocessor calculate an integral at every iteration of the solver.\nThe fact that properties are recalculated at every calculation step I got from the \"material system\" page on the MOOSE site:\n\"The properties are produced on demand, thus the computed values are always up to date. For example, a property that relies on a solution variable (e.g., thermal conductivity as function of temperature) will be computed with the current temperature during the solve iterations, so the properties are tightly coupled.\"\nThe overall approach is what I gathered from the \"Algorithm 2\" box in https://www.sciencedirect.com/science/article/pii/S0306454917303079\nI should mention that I only wanted to apply this to problems with vacuum boundary, so no normalization was required.\nI also didn't insert all necessary physical properties in the example I provided, just diffusivity and removal cross-section for simplicity, but clearly the real thing should also have the other parameters appearing in the multigroup diffusion equation.",
                          "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5708703",
                          "updatedAt": "2023-04-24T13:57:40Z",
                          "publishedAt": "2023-04-24T13:53:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For instance I don't know if it possible to have a postprocessor calculate an integral at every iteration of the solver.\n\nSee the execute_on parameter of the postprocessor. It s set by default to end of the timestep for execution, but you can make it be on linear or nonlinear iterations\n\nTo my understanding, this would have resulted in the material property being recalculated (i.e. the residual matrix being reassembled) at all linear/nonlinear steps\n\nThis is the default as well for PJFNK / Newton.",
                          "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5708771",
                          "updatedAt": "2023-04-24T13:58:18Z",
                          "publishedAt": "2023-04-24T13:58:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vincentlaboure"
                          },
                          "bodyText": "This might all be nonsense to be frank, I am dealing with a lot of black boxes here.\n\nI think your understanding is pretty good. The nonlinear variables are indeed the fluxes (which is equivalent to solving for the SPH factors but with the advantage of having a very similar formulation when we compute and use the SPH factors).\nRegarding your implementation, I'm sure you can make it work that way but the trickiest part of the implementation is to make sure you can keep track of which reference flux goes to which part of the domain (at least if you are targeting large problems with lots of SPH regions). We use an extra element integer in the mesh to do that. Then you can have a single ElementUserObject performing the flux integration at each linear iteration over all the SPH regions.",
                          "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5709431",
                          "updatedAt": "2023-04-24T14:51:15Z",
                          "publishedAt": "2023-04-24T14:51:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "The postprocessors or the ElementUserObject performing the integration of fluxes on SPH regions can have execute_on parameter equal to linear or nonlinear as said by @GiudGiud. In the former, cross sections depends on SPH factors which depends on flux, thus we introduce nonlinearity in the residual evaluation, PJFNK is using Newton iteration to solve this nonlinear problem. In the later, Newton iteration is equivalent with SPH iteration, i.e. at each iteration or linear solve, SPH factors are fixed. If you do need to evaluate discontinuity factors on vacuum boundaries, you may want to consider using DomainUserObject so that you can put volumetric flux integration and surface partial current integration in one place. Wish you a success on this implementation.",
                          "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5724131",
                          "updatedAt": "2023-04-25T20:00:25Z",
                          "publishedAt": "2023-04-25T20:00:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gabburgio"
                          },
                          "bodyText": "Many thanks to all of you for your advice.\nI have managed to put together what I think is a basic working version, about which I have a few more questions:\n-For the postprocessors, I have been using   execute_on = 'LINEAR NONLINEAR' because it seems to me to do what is described in the paper. Is this correct?\n-I was not sure on how to go about implementing an initial source for the first iteration (like in the paper), so to avoid getting a trivial solution I decided to simply set an initial condition for the variable as a constant equal to the average flux over the whole geometry, like:\n[Variables]\n[./flux]\n    type = ArrayMooseVariable\n    components = 2\n    initial_condition = '1.5 1.5'\n[../]\n[]\n\nAm I correct in assuming that this sets the all the FE coefficients for the first PJFNK iteration to 1.5?\nIs there any more sensible way to do this, for instance using a finite element interpolation of a piecewise constant function that is equal to the average flux on the various homogenized zones (which for me coincide with material blocks)?\nI looked at the function system but I haven't found much.\n-I have been using RealEigenVector and RealEigenMatrix as types for the material properties because it is more convenient for manipulations, e.g.:\n   _chi_nu_sigma_f[_qp]    = (1/_k_ref)*_v_chi.array()* (_v_nu_sigma_f.array()*sph_factors.array()).transpose();\n  \nfor (int j =0;  j< _v_diffusivity.size(); j++)\n  {\n      _sigma_s[_qp].row(j)    = (_v_sigma_s.row(j).array())*sph_factors.array();\n  }\n\n\nIs there any reason not to do this?\n-I can calculate the sph factors from the reference fluxes and the postprocessor values, but it would be nice if there was an ArrayMaterialPropertyIntegralPostprocessor like the one to integrate array variables.\nIf I want that I have to code it myself right?",
                          "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5793409",
                          "updatedAt": "2023-05-07T15:54:36Z",
                          "publishedAt": "2023-05-03T16:35:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "For the postprocessors, I have been using  execute_on = 'LINEAR NONLINEAR'\n\nTypically just having linear is ok. I assume that having an extra evaluation at the beginning of each Newton iteration does not change things.\n\nAm I correct in assuming that this sets the all the FE coefficients for the first PJFNK iteration to 1.5?\n\nIt does set the initial values to the flux variables. The meaning of FE coefficients depends on the shape function family. For LAGRANGE, yes, all coefficients will be the values at the nodes, thus equal to 1.5. You can implement your own InitialCondition to use the reference flux to initialize the flux in a more sensible way. Or you can start from the simple initialization with few SPH iterations.\n\nIs there any reason not to do this?\n\nYou can use gperftools (MOOSE has a documentation page on how to do it) to do some profiling if performance is a concern. But I doubt this can cause issue.\n\nIf I want that I have to code it myself right?\n\nYes, if it is missing in MOOSE. But if you think that can be generally useful and can be maintained in framework, please feel free to contribute by sending in a pull request to MOOSE repository on github.",
                          "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5795537",
                          "updatedAt": "2023-05-03T18:49:01Z",
                          "publishedAt": "2023-05-03T18:48:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "gabburgio"
                  },
                  "bodyText": "I now have an implementation of PJFNK-SPH-DF that works for very simple problems, but doesn't seem to converge for a more complicated one, and I would like to try to add the traditional sph iterations at the beginning.\nIs this best accomplished by using stateful material properties on the source terms?\nI am now using ArrayConstantICs to initialize the flux to its average value on the homogenized zone. Is this likely to be too coarse?\nShould the vacuum BC term be part of the source in the picard iteration?\nThanks again\nGabriele",
                  "url": "https://github.com/idaholab/moose/discussions/24124#discussioncomment-5951264",
                  "updatedAt": "2023-05-19T17:57:21Z",
                  "publishedAt": "2023-05-19T17:57:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Spatially dependent coefficient of thermal expansion (CTE) for calculating eigen strain",
          "author": {
            "login": "chakra34"
          },
          "bodyText": "Following the discussion in , #21785, which considers temperature dependent CTE, I was wondering whether I can also pass this material property as a function of space, for example linearly varying with coordinate 'z'.\nTo do this I tried the following:\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 150e6\n    poissons_ratio = 0.3\n  [../]\n  [./small_stress]\n    type = ComputeFiniteStrainElasticStress\n  [../]\n  \n  [./thermal_expansion_strain]\n    type = ComputeInstantaneousThermalExpansionFunctionEigenstrain\n    thermal_expansion_function = cte_func_inst\n    stress_free_temperature = 0.0\n    temperature = temp\n    eigenstrain_name = eigenstrain\n  [../]\n[]\n\n[Functions]\n\n  [./cte_func_inst]\n    type = ParsedFunction\n    value = '1e-4*(z+1)'\n  [../]\n\n  [./temp_function]\n    type  = ParsedFunction\n    value = 100.0\n  [../]\n \n[]\n\nBut I don't see any difference in the eigenstrain, most likely because the CTE should be a function of temperature and not space. I was wondering whether it is possible to allow the CTE to be position dependent via using ParsedFunc/ParsedAux/ParsedMaterial.\nI did try using ParsedMaterial and write the above expression, but it also gave an error, which in my understanding also points to the notion that the ParsedMaterial function should also be dependent on a coupled variable (temperature) instead of space.\nIn my actual problem I will have a time and space varying temperature field in the body as well as was hoping for a spatially variable CTE.\nPlease let me know your thoughts, and again any help is greatly appreciated :)\n-Aritra",
          "url": "https://github.com/idaholab/moose/discussions/24417",
          "updatedAt": "2023-05-18T16:57:37Z",
          "publishedAt": "2023-05-18T14:36:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I dont think this is can be done through the input file.\nThe creators of this object meant to model the influence of temperature. The functions are queried with a temperature argument, not a spatial coordinate.\nYou can easily adapt the source code to use Z or any function of Z though. So in that way yes it is very possible to allow the CTE to depend on position.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24417#discussioncomment-5940778",
                  "updatedAt": "2023-05-18T16:57:37Z",
                  "publishedAt": "2023-05-18T16:57:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Slow convergence of plasticity model",
          "author": {
            "login": "tairoon1"
          },
          "bodyText": "Hi everyone,\nI have been trying to use tensor mechanics to simulate a plasticity example, but somehow experience extremely slow convergence using Newton solver. I tried to make a minimal example, can someone please take a look at my input file, here?\nI have two materials, the matrix has a von Mises isotropic hardening model, the fiber is linear elastic. I want to use small strain formulation. The loading is applied uniaxially until time=0.5 and then unloading until time=1. During plastic deformation, it would sometimes take over 100 nonlinear iterations for Newton to converge and there is definitely no quadratic convergence. Is that normal behavior?\nThanks in advance.",
          "url": "https://github.com/idaholab/moose/discussions/16905",
          "updatedAt": "2023-05-18T06:08:38Z",
          "publishedAt": "2021-02-05T15:26:37Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI had a quick look at your input. The non linear relative error convergence criterion seems really small.\nCan you please have a look at https://mooseframework.inl.gov/modules/tensor_mechanics/Convergence.html to see if it needs to be adjusted.\nHave not worked on plasticity for a while now, do you expect the small strain formulation to be valid for a 30% displacement? (mesh is 1 by 1 and right_displacement_x goes to 0.3).\nI don't know how much the non linear iteration count may be reduced, it depends on your problem's non-linearity. To mitigate this cost, you could try adaptive time stepping to reduce the number of time steps, consequently reducing the number of non-linear solves. And you could add pre-conditionning to make your linear solves inverting the Jacobian faster.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-356890",
                  "updatedAt": "2022-06-20T08:43:05Z",
                  "publishedAt": "2021-02-10T15:08:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "Hi, thanks for your response. Actually, I am using the absolute error convergence criterion to converge (10^-10) which should be fine, I believe.\nThe result is definitely unphysical and wrong, but this was also meant more as an academic example. The same happens when I would take only 3% strain with a yield stress of 1/10.\nWell, the thing is, even if I set the fiber to the same material as the matrix, i.e. the material is homogeneous, the slow convergence still appears, so the problem should not be very nonlinear... Another thing that I noticed is, the more plastic strain there is, the more nonlinear iterations are needed for a timestep to converge. An example of the convergence behavior is below. Can you please take a more thorough look? I do not really understand what is happening.\nTime Step 36, time = 0.36, dt = 0.01\n0 Nonlinear |R| = 3.286335e-02\n1 Nonlinear |R| = 9.414443e-04\n2 Nonlinear |R| = 4.019062e-04\n3 Nonlinear |R| = 2.413215e-04\n4 Nonlinear |R| = 1.647919e-04\n5 Nonlinear |R| = 1.191983e-04\n6 Nonlinear |R| = 8.981290e-05\n7 Nonlinear |R| = 6.902610e-05\n8 Nonlinear |R| = 5.399464e-05\n9 Nonlinear |R| = 4.289745e-05\n10 Nonlinear |R| = 3.447887e-05\n11 Nonlinear |R| = 2.795538e-05\n12 Nonlinear |R| = 2.282174e-05\n13 Nonlinear |R| = 1.873410e-05\n14 Nonlinear |R| = 1.545260e-05\n15 Nonlinear |R| = 1.279490e-05\n16 Nonlinear |R| = 1.062149e-05\n17 Nonlinear |R| = 8.845436e-06\n18 Nonlinear |R| = 7.387003e-06\n19 Nonlinear |R| = 6.184153e-06\n20 Nonlinear |R| = 5.188392e-06\n21 Nonlinear |R| = 4.361392e-06\n22 Nonlinear |R| = 3.672593e-06\n23 Nonlinear |R| = 3.097446e-06\n24 Nonlinear |R| = 2.616114e-06\n25 Nonlinear |R| = 2.212475e-06\n26 Nonlinear |R| = 1.873369e-06\n27 Nonlinear |R| = 1.588007e-06\n28 Nonlinear |R| = 1.347508e-06\n29 Nonlinear |R| = 1.144539e-06\n30 Nonlinear |R| = 9.730259e-07\n31 Nonlinear |R| = 8.279240e-07\n32 Nonlinear |R| = 7.050327e-07\n33 Nonlinear |R| = 6.008464e-07\n34 Nonlinear |R| = 5.124338e-07\n35 Nonlinear |R| = 4.373398e-07\n36 Nonlinear |R| = 3.735039e-07\n37 Nonlinear |R| = 3.191944e-07\n38 Nonlinear |R| = 2.729543e-07\n39 Nonlinear |R| = 2.335556e-07\n40 Nonlinear |R| = 1.999625e-07\n41 Nonlinear |R| = 1.713000e-07\n42 Nonlinear |R| = 1.468283e-07\n43 Nonlinear |R| = 1.259216e-07\n44 Nonlinear |R| = 1.080495e-07\n45 Nonlinear |R| = 9.276236e-08\n46 Nonlinear |R| = 7.967877e-08\n47 Nonlinear |R| = 6.847478e-08\n48 Nonlinear |R| = 5.887508e-08\n49 Nonlinear |R| = 5.064552e-08\n50 Nonlinear |R| = 4.358684e-08\n51 Nonlinear |R| = 3.752934e-08\n52 Nonlinear |R| = 3.232840e-08\n53 Nonlinear |R| = 2.786069e-08\n54 Nonlinear |R| = 2.402099e-08\n55 Nonlinear |R| = 2.071945e-08\n56 Nonlinear |R| = 1.787932e-08\n57 Nonlinear |R| = 1.543500e-08\n58 Nonlinear |R| = 1.333037e-08\n59 Nonlinear |R| = 1.151743e-08\n60 Nonlinear |R| = 9.955062e-09\n61 Nonlinear |R| = 8.608056e-09\n62 Nonlinear |R| = 7.446233e-09\n63 Nonlinear |R| = 6.443716e-09\n64 Nonlinear |R| = 5.578305e-09\n65 Nonlinear |R| = 4.830943e-09\n66 Nonlinear |R| = 4.185269e-09\n67 Nonlinear |R| = 3.627225e-09\n68 Nonlinear |R| = 3.144729e-09\n69 Nonlinear |R| = 2.727393e-09\n70 Nonlinear |R| = 2.366277e-09\n71 Nonlinear |R| = 2.053691e-09\n72 Nonlinear |R| = 1.783012e-09\n73 Nonlinear |R| = 1.548535e-09\n74 Nonlinear |R| = 1.345344e-09\n75 Nonlinear |R| = 1.169201e-09\n76 Nonlinear |R| = 1.016452e-09\n77 Nonlinear |R| = 8.839422e-10\n78 Nonlinear |R| = 7.689509e-10\n79 Nonlinear |R| = 6.691275e-10\n80 Nonlinear |R| = 5.824420e-10\n81 Nonlinear |R| = 5.071402e-10\n82 Nonlinear |R| = 4.417056e-10\n83 Nonlinear |R| = 3.848266e-10\n84 Nonlinear |R| = 3.353688e-10\n85 Nonlinear |R| = 2.923503e-10\n86 Nonlinear |R| = 2.549210e-10\n87 Nonlinear |R| = 2.223447e-10\n88 Nonlinear |R| = 1.939836e-10\n89 Nonlinear |R| = 1.692849e-10\n90 Nonlinear |R| = 1.477694e-10\n91 Nonlinear |R| = 1.290213e-10\n92 Nonlinear |R| = 1.126800e-10\n93 Nonlinear |R| = 9.843259e-11\nSolve Converged!",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-356973",
                          "updatedAt": "2022-06-20T08:43:05Z",
                          "publishedAt": "2021-02-10T15:32:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Plastic strain is non linear so it causing an increase in non-linear iterations is not surprising.\nYou seem to be obtaining a linear convergence (roughly 10x reduction every 15 iterations). I would examine the Jacobian to see if it's exact on a smaller problem. That would reduce your convergence rate from quadratic to linear.\nYou can use the command line options -snes_test_jacobian -snes_test_jacobian_view but the problem should be really small so the output is understandable.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-357105",
                          "updatedAt": "2022-06-20T08:43:11Z",
                          "publishedAt": "2021-02-10T16:08:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "srinath-chakravarthy"
                          },
                          "bodyText": "I am getting non-linear convergence within 2 non-linear iterations with your input file, but using the Tensor-mechanics master action instead of the full input file you have. It is recommended to use the MasterAction in most cases i think. Here is the input file\n[Mesh]\nfile = mat_fiber.msh\nuse_displaced_mesh = false\n[]\n[GlobalParams]\ndisplacements = 'disp_x disp_y'\n[]\n[Variables]\n[./disp_x]\n[../]\n[./disp_y]\n[../]\n[]\n[Functions]\n[./Exx]\ntype = PiecewiseLinear\nx = '0. 0.5 1 '\ny = '0 0.3 0'\n[../]\n[./right_displacement_x]\ntype = ParsedFunction\nvalue = Exx\nvars = 'Exx'\nvals = 'Exx'\n[../]\n[]\n[BCs]\n[./left_x]\ntype = DirichletBC\nvariable = 'disp_x'\nboundary = left\nvalue = 0\n[../]\n[./left_y]\ntype = DirichletBC\nvariable = 'disp_y'\nboundary = left\nvalue = 0\n[../]\n[./right_x]\ntype = FunctionDirichletBC\nvariable = 'disp_x'\nboundary = right\nfunction = right_displacement_x\npreset   = false\n[../]\n[./right_y]\ntype = DirichletBC\nvariable = 'disp_y'\nboundary = right\nvalue = 0\n[../]\n[]\n[Modules/TensorMechanics/Master]\n[./all]\nadd_variables = true\nstrain = SMALL\nincremental = true\n# volumetric_locking_correction = true\ngenerate_output = 'stress_xx stress_yy strain_xx strain_yy vonmises_stress hydrostatic_stress'\n[../]\n[]\n[Materials]\n[./elasticity_tensor_matrix]\ntype = ComputeIsotropicElasticityTensor\nblock = 'matrix'\nyoungs_modulus = 1.0\npoissons_ratio = 0.3\n[../]\n[./stress_matrix]\ntype = ComputeMultipleInelasticStress\ninelastic_models = 'isoplas'\nblock = 'matrix'\n[../]\n[./isoplas]\ntype = IsotropicPlasticityStressUpdate\nyield_stress = 0.18\nhardening_constant = 0.1\nblock = 'matrix'\n[../]\n[./elasticity_tensor_fiber]\ntype = ComputeIsotropicElasticityTensor\nblock = 'fiber'\nyoungs_modulus = 1.0\npoissons_ratio = 0.1\n[../]\n[./stress_fiber]\ntype = ComputeFiniteStrainElasticStress\nblock = 'fiber'\n[../]\n[]\n[Executioner]\ntype = Transient\nsolve_type = NEWTON\npetsc_options_iname = '-pc_type'\npetsc_options_value = 'lu'\nstart_time = 0.0\ndtmin = 0.0001\nend_time = 1.0\nnl_abs_tol = 1e-10\nnl_rel_tol = 1e-20\nnl_max_its = 200\ndt = 0.01\n[]\n[Outputs]\nexecute_on = 'INITIAL TIMESTEP_END'\nexodus = true\nprint_linear_residuals = false\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-357166",
                          "updatedAt": "2022-06-20T08:43:11Z",
                          "publishedAt": "2021-02-10T16:31:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "@srinath-chakravarthy Thanks for your response. I tried your input file, but I observe the same convergence behavior as with my own file. The first 17 timesteps are fine since there is no plastic deformation yet. The plastic deformation starts at timestep 18.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-357885",
                          "updatedAt": "2022-07-12T15:03:22Z",
                          "publishedAt": "2021-02-10T20:56:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "@GiudGiud Thanks for the hint. I tried it with the command.\nFor elastic deformation, it is perfectly consistent with finite differences:\n---------- Testing Jacobian -------------\n||J - Jfd||_F/||J||_F = 1.6109e-16, ||J - Jfd||_F = 1.95199e-15\nHowever, when plastic deformation starts:\n---------- Testing Jacobian -------------\n||J - Jfd||_F/||J||_F = 0.039895, ||J - Jfd||_F = 0.483421.\nSo it looks like the jacobian is wrong... But I am directly using the code from TensorMechanics Module. Does that mean that the implementation of MOOSE is incorrect?",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-357906",
                          "updatedAt": "2022-07-12T15:03:22Z",
                          "publishedAt": "2021-02-10T21:04:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Try this input instead:\n[Mesh]\n  file = mat_fiber.msh\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n[]\n\n[Functions]\n  [Exx]\n    type = PiecewiseLinear\n    x = '0. 0.5 1 '\n    y = '0 0.3 0'\n  []\n  [right_displacement_x]\n    type = ParsedFunction\n    value = Exx\n    vars = 'Exx'\n    vals = 'Exx'\n  []\n[]\n\n[BCs]\n  [left_x]\n    type = DirichletBC\n    variable = 'disp_x'\n    boundary = left\n    value = 0\n  []\n  [left_y]\n    type = DirichletBC\n    variable = 'disp_y'\n    boundary = left\n    value = 0\n  []\n  [right_x]\n    type = FunctionDirichletBC\n    variable = 'disp_x'\n    boundary = right\n    function = right_displacement_x\n    preset = false\n  []\n  [right_y]\n    type = DirichletBC\n    variable = 'disp_y'\n    boundary = right\n    value = 0\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = SMALL\n    incremental = true\n    # volumetric_locking_correction = true\n    generate_output = 'stress_xx stress_yy strain_xx strain_yy vonmises_stress hydrostatic_stress'\n  []\n[]\n\n[Materials]\n  [elasticity_tensor_matrix]\n    type = ComputeIsotropicElasticityTensor\n    block = 'matrix'\n    youngs_modulus = 1.0\n    poissons_ratio = 0.3\n  []\n  [stress_matrix]\n    type = ComputeMultipleInelasticStress\n    inelastic_models = 'isoplas'\n    block = 'matrix'\n  []\n  [isoplas]\n    type = IsotropicPlasticityStressUpdate\n    yield_stress = 0.18\n    hardening_constant = 0.1\n    block = 'matrix'\n  []\n\n  [elasticity_tensor_fiber]\n    type = ComputeIsotropicElasticityTensor\n    block = 'fiber'\n    youngs_modulus = 1.0\n    poissons_ratio = 0.1\n  []\n  [stress_fiber]\n    type = ComputeFiniteStrainElasticStress\n    block = 'fiber'\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu superlu_dist'\n\n  start_time = 0.0\n  dtmin = 0.0001\n\n  end_time = 1.0\n  nl_abs_tol = 1e-10\n  nl_rel_tol = 1e-20\n  nl_max_its = 200\n  dt = 0.01\n[]\n\n[Outputs]\n  execute_on = 'INITIAL TIMESTEP_END'\n  exodus = true\n  print_linear_residuals = false\n[]\n\nThe finite deformation jacobian in tensor_mechanics isn't perfect (as of now, it will improve by a lot soon!). Using PJFNK for non-AD or using Newton for AD should improve the convergence.\nSome other options you could play with are the tangent_operator option in ComputeMultiInelasticStress and use_finite_deform_jacobian in the action.",
                  "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-357947",
                  "updatedAt": "2022-06-20T08:43:11Z",
                  "publishedAt": "2021-02-10T21:21:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "srinath-chakravarthy"
                          },
                          "bodyText": "Also,\nOne more thing, you are applying a displacement bc and so the amount of plastic strain per increment is increasing, which is why you are seeing an increase in the no. of iterations per increment. Try to get non constant time steps and also try to see if you can apply a velocity bc. I have had a considerable amount of success by choosing an analytical vel. bc in lieu of displacment bc.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-358322",
                          "updatedAt": "2022-06-20T08:44:00Z",
                          "publishedAt": "2021-02-11T00:07:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "Thanks @hugary1995. So the jacobian in tensor_mechanics is currently not computed correctly. Are you currently working on a correct and consistent jacobian implementation? Can I ask, when soon is going to be? Using PJFNK seems to work around it quite well, however each linear iteration seems to be much slower than Newton.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-359302",
                          "updatedAt": "2022-06-20T08:43:56Z",
                          "publishedAt": "2021-02-11T11:53:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "@srinath-chakravarthy I am sorry, I do not really understand what you mean. I am working with quasistatic conditions, so there should not be any velocity.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-359303",
                          "updatedAt": "2022-06-20T08:43:56Z",
                          "publishedAt": "2021-02-11T11:55:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'm not - but that's in our radar for a while. @bwspenc can probably comment on this.\nPJFNK uses our inaccurate hand-coded jacobian for preconditioning, so linear convergence might be slow, but each iteration is also supposed to be much cheaper. See https://mooseframework.inl.gov/source/systems/NonlinearSystem.html  for more details.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-359490",
                          "updatedAt": "2022-06-20T08:44:20Z",
                          "publishedAt": "2021-02-11T13:18:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "Okay, thank you so much for clarifying!",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-369928",
                          "updatedAt": "2022-06-20T08:44:20Z",
                          "publishedAt": "2021-02-15T09:44:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "@hugary1995 @bwspenc\nHi Gary ,\nDoes the problem in calculation of Jacobian in tensor_mechanics still persists ? Or has it been already fixed ? Do you have any info on that ?\nThank you very much for your time.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-5773346",
                          "updatedAt": "2023-05-01T16:45:01Z",
                          "publishedAt": "2023-05-01T16:45:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "There is a new system (we refer to it as \"lagrangian mechanics kernels/materials\" at several places). As far as I know, the current state of Jacobian accuracy is:\n\nsome non-AD simple plasticity models in the old system now have correct Jacobians;\nmost non-AD creep models in the old system have correct Jacobians;\nall AD inelastic models in the old system have correct Jacobians;\nall inelastic models in the new system have correct Jacobians, though we only added a few inelastic models so far -- migration in progress.",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-5774720",
                          "updatedAt": "2023-05-01T19:53:48Z",
                          "publishedAt": "2023-05-01T19:53:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ttw0626"
                          },
                          "bodyText": "sorry this borthing, I wanna ask how to imporve the convergenced speed of non-AD inelastic model (Lagragian) which I did not use build-in return-mapping ? it will take too much time (around 2 h in 3D tensile coarse mesh) compared with commercial one (5-10mins). maybe my jacobian has problem, but it will get good convergency in 2D problem.\nBest regards,\nTAN",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-5934601",
                          "updatedAt": "2023-05-18T03:54:36Z",
                          "publishedAt": "2023-05-18T03:54:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYou can check your Jacobian using these tools:\nhttps://mooseframework.inl.gov/help/development/analyze_jacobian.html\nIf your Jacobian has issues you ll see a higher number of nonlinear iterations.\nIf it's not that, you will want to work on the preconditioning to improve performance in most cases.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-5934849",
                          "updatedAt": "2023-05-18T04:06:06Z",
                          "publishedAt": "2023-05-18T04:06:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ttw0626"
                          },
                          "bodyText": "Thanks for reply, Guillaume.\n\n\n\nI am going to try.\n\n\n\nActually, I wonder what's the reason why my material jacobian [modification based on ComputeLagrangianPK2Stress()] will failure in moose but is fine in abaqus umat when the problem become a little bit complicated?\nI understood the difference of the material jacobian between TM new system and abaqus umat, however, the basic StressUpdate algorithm should be same I think.\n\n\n\nThis is first implementation in moose about inelastic material, if I wanna insert more nonlinear on this framework in the future, the converged problem is super-important for me, could you give me some advice or recommendations about this ?\nBest regards.\nTAN",
                          "url": "https://github.com/idaholab/moose/discussions/16905#discussioncomment-5935736",
                          "updatedAt": "2023-05-18T06:08:38Z",
                          "publishedAt": "2023-05-18T06:08:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Potential issue with mesh adaptivity and ExtraNodesetGenerator",
          "author": {
            "login": "starkekr"
          },
          "bodyText": "I am having convergence issues with a simple deformation input file (attached).\nm_file_error.txt\nIn this simulation I have a precipitate which I am translating to one of the corner nodes in the simulation domain (using a time dependent aux variable). The displacement of the  corner nodes are fixed to prevent rigid body translations. After 40 timesteps, the precipitate reaches the corner node and then the simulation stops converging. I am thinking that this is because of mesh adaptivity relabeling the corner node? I also get the same problem with allow_renumbering = false so maybe its something else.\nSo I am wondering what the default behavior is when an element is refined and that element contains part of a nodeset? Any comments or thought is greatly appreciated :)",
          "url": "https://github.com/idaholab/moose/discussions/24369",
          "updatedAt": "2023-05-17T23:36:41Z",
          "publishedAt": "2023-05-15T21:15:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "sideset information is associated with the level 0 elements. With respect to nodesets, when new nodes are added along a boundary during mesh refinement, I don't actually know whether they get incorporated into existing nodesets (@roystgnr ?). I would guess not as how could we know the conditions under which a node should be considered as part of a nodeset? If you build a nodeset from a sideset post-adaptivity, then that would be clear. Anyway, I don't think that particular information is relevant to you in this case.\nWhat is relevant: if you were relying on applying a specific condition to a specific DofObject ID (e.g. element or node ID), then you would indeed be in trouble if renumbering was enabled during adaptivity, but it looks like you are using the nodeset throughout the input file. That should be fine and robust irrespective of whether you allow renumbering or not.",
                  "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5909946",
                  "updatedAt": "2023-05-15T22:02:38Z",
                  "publishedAt": "2023-05-15T21:59:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "They don't get incorporated by libMesh.  Nodesets were originally meant to be for things like point sources, pins in elastoplasticity, etc.  \"Create a new nodeset for every sideset\" was a MOOSE innovation ... so maybe MOOSE updates them after AMR, too?  I'd kinda expect it to be a bug if not, based on how MOOSE codes rely on that.",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5909960",
                          "updatedAt": "2023-05-15T22:02:23Z",
                          "publishedAt": "2023-05-15T22:02:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Wow you responded before I could even update my post \ud83d\ude04",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5909965",
                          "updatedAt": "2023-05-15T22:03:09Z",
                          "publishedAt": "2023-05-15T22:03:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Yes we do indeed rely on build_node_list_from_side_list post mesh refinement (otherwise our Dirichlet BC classes would not work)",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5909984",
                          "updatedAt": "2023-05-15T22:07:18Z",
                          "publishedAt": "2023-05-15T22:07:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "I just realized that I didn't get rid of all of my personal code. The problem still persists if I run this new input file\nm_file_error.txt",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5910589",
                          "updatedAt": "2023-05-16T01:17:23Z",
                          "publishedAt": "2023-05-16T00:39:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "What does poor convergence mean? Poor linear convergence? Poor nonlinear convergence?",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5911617",
                          "updatedAt": "2023-05-16T03:38:43Z",
                          "publishedAt": "2023-05-16T03:38:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "Poor nonlinear convergence. Here is a screenshot of the residuals\n\nI also just noticed that the displacement field shows problems even earlier than timstep 42. If you compare the x component of the displacement field as shown here in timestep 20\n\nto the next timestep 21\n\nyou can see that there are some issues. Both plots are scaled to the same magnitude. I would expect the displacement field to continue to look more or less like the one in timestep 20 but something weird happens as the precipitate approaches the boundary",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5915726",
                          "updatedAt": "2023-05-16T12:04:06Z",
                          "publishedAt": "2023-05-16T12:04:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Yea I don't know this physics very well. I'm going to ask some of our community members to chime in here",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5918772",
                          "updatedAt": "2023-05-16T16:45:04Z",
                          "publishedAt": "2023-05-16T16:45:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "will you paste your input file into a comment",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5918808",
                          "updatedAt": "2023-05-16T16:49:03Z",
                          "publishedAt": "2023-05-16T16:49:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Very likely just bad Jacobian... Are you using AD?",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5919352",
                          "updatedAt": "2023-05-16T17:45:53Z",
                          "publishedAt": "2023-05-16T17:45:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "[GlobalParams]\ndisplacements = 'disp_x disp_y'\n[]\n[Mesh]\n[msh]\ntype = GeneratedMeshGenerator\ndim  = 2\nnx   = 16\nny   = 16\nnz   = 0\nxmin = 0\nxmax = 4.0\nymin = 0\nymax = 4.0\nzmin = 0\nzmax = 0.0\n[]\n[ns]\ntype         = ExtraNodesetGenerator\ninput        = msh\nnew_boundary = ns1\ncoord        = '0 0 0'\n#nodes        = 1\n[]\nuniform_refine    = 3\n[]\n[Variables]\n[disp_x]\nfamily = LAGRANGE\norder  = FIRST\n[]\n[disp_y]\nfamily = LAGRANGE\norder  = FIRST\n[]\n[]\n[AuxVariables]\n[eta0]\nfamily = LAGRANGE\norder  = FIRST\n[]\n[eta1]\nfamily = LAGRANGE\norder  = FIRST\n[]\n[bnds]\nfamily = LAGRANGE\norder  = FIRST\n[]\n[]\n[Kernels]\n[stress_x]\ntype              = StressDivergenceTensors\nvariable          = disp_x\ncomponent         = 0\neigenstrain_names = eigenstrain\n[]\n[stress_y]\ntype              = StressDivergenceTensors\nvariable          = disp_y\ncomponent         = 1\neigenstrain_names = eigenstrain\n[]\n[]\n[AuxKernels]\n[eta0]\ntype = FunctionAux\nvariable = eta0\nfunction = '1.0/(1+exp(-(sqrt((x-(1-t))^2+(y-(1-t))^2)-0.5^2)/0.03))\n+1.0/(1+exp(-(sqrt((x-(5-t))^2+(y-(5-t))^2)-0.5^2)/0.03))\n+1.0/(1+exp(-(sqrt((x-(1-t))^2+(y-(5-t))^2)-0.5^2)/0.03))\n+1.0/(1+exp(-(sqrt((x-(5-t))^2+(y-(1-t))^2)-0.5^2)/0.03))\n-3'\nexecute_on = 'initial timestep_begin'\n[]\n[eta1]\ntype = ParsedAux\nvariable = eta1\nargs = eta0\nfunction = '1-eta0'\nexecute_on = 'initial timestep_begin'\n[]\n[bnds]\ntype = ParsedAux\nvariable = bnds\nargs = 'eta0 eta1'\nfunction = 'eta0*(1-eta0)'\nexecute_on = 'initial timestep_begin'\n[]\n[]\n[Materials]\n[./elasticity_tensor_A]\ntype = ComputeElasticityTensor\nbase_name = A\nfill_method = symmetric9\nC_ijkl = '1e1 1e0 1e0 1e1 0 1e1 .4e1 .2e1 .5e1'\n[../]\n[./strain_A]\ntype = ComputeSmallStrain\nbase_name = A\neigenstrain_names = eigenstrain\n[../]\n[./stress_A]\ntype = ComputeLinearElasticStress\nbase_name = A\n[../]\n[./eigenstrain_A]\ntype = ComputeEigenstrain\nbase_name = A\neigen_base = '0.1 0.05 0 0 0 0.01'\nprefactor = -1\neigenstrain_name = eigenstrain\n[../]\n[./elasticity_tensor_B]\ntype = ComputeElasticityTensor\nbase_name = B\nfill_method = symmetric9\nC_ijkl = '1e1 0 0 1e1 0 1e1 .5e1 .5e1 .5e1'\n[../]\n[./strain_B]\ntype = ComputeSmallStrain\nbase_name = B\neigenstrain_names = 'B_eigenstrain'\n[../]\n[./stress_B]\ntype = ComputeLinearElasticStress\nbase_name = B\n[../]\n[./eigenstrain_B]\ntype = ComputeEigenstrain\nbase_name = B\neigen_base = '0.1 0.05 0 0 0 0.01'\nprefactor = -1\neigenstrain_name = 'B_eigenstrain'\n[../]\n[./switching]\ntype = SwitchingFunctionMaterial\neta = eta0\n[../]\n[./combined]\ntype = TwoPhaseStressMaterial\nbase_A = A\nbase_B = B\n[../]\n[]\n[BCs]\n[fixed_x]\ntype     = DirichletBC\nvariable = disp_x\nboundary = ns1\nvalue    = 0\n[]\n[fixed_y]\ntype     = DirichletBC\nvariable = disp_y\nboundary = ns1\nvalue    = 0\n[]\n[Periodic]\n[all]\nvariable       = 'disp_x disp_y'\nauto_direction = 'x y'\n[]\n[]\n[]\n[Adaptivity]\nmarker      = combo\nmax_h_level = 4\n[Markers]\n[combo]\ntype    = ComboMarker\nmarkers = interface\n[]\n[interface]\ntype     = ValueThresholdMarker\nvariable = bnds\nrefine   = 0.05\ncoarsen  = 0.05\n[]\n[]\n[]\n[Executioner]\ntype                = Transient\nscheme              = bdf2\nsolve_type          = NEWTON\npetsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart'\npetsc_options_value = 'hypre boomeramg 101'\nl_max_its           = 100\nl_tol               = 0.0001\nnl_max_its          = 40\nnl_rel_tol          = 1e-05\nnl_abs_tol          = 1e-07\ndt                  = 0.01\nstart_time          = 0.0\nnum_steps           = 100\n[]\n[Outputs]\nexodus                 = true\nexecute_on             = 'initial timestep_end'\nprint_linear_residuals = false\ncheckpoint             = true\ninterval               = 1\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5919445",
                          "updatedAt": "2023-05-16T17:57:09Z",
                          "publishedAt": "2023-05-16T17:57:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "starkekr"
                  },
                  "bodyText": "Ahh, yes you are absolutely right, my mistake. With my executioner block set as:\n[Executioner]\n  type                = Transient\n  scheme              = bdf2\n  solve_type          = NEWTON\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu '\n  automatic_scaling   = true\n  l_tol               = 1e-12\n  nl_max_its          = 40\n  nl_rel_tol          = 1e-13\n  nl_abs_tol          = 1e-15\n  start_time          = 0.0\n  dt                  = 0.01\n  num_steps           = 150\n[]\n\nthe AMR solution seems to be consistent with the non adaptive case. Just out of curiosity @hugary1995 what preconditioner would you use?",
                  "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5920382",
                  "updatedAt": "2023-05-17T16:14:59Z",
                  "publishedAt": "2023-05-16T19:55:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The hypre boomeramg preconditioner is supposed to be pretty good at solving mechanics problems. However, the default parameters are far less effective compared to a well-tuned set of parameters. This page has a gentle introduction to some of the common parameters: https://mooseframework.inl.gov/releases/moose/v1.0.0/application_development/hypre.html\nI've found the following parameters effective for many problems I have at hand:\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_truncfactor'\n  petsc_options_value = 'hypre boomeramg 301 0.25 ext+i PMIS 4 2 0.4'\nI am optimistic that the above preconditioner can get your problem to converge. However, it's NOT going to change the solution. The solution doesn't depend on the type of preconditioner you use, except some numerical corner cases...",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5920872",
                          "updatedAt": "2023-05-16T20:59:36Z",
                          "publishedAt": "2023-05-16T20:59:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "I think the problem may be related to pinning the corner node and simultaneously having a misfitting precipitate there - the misfit strain is going to make your displacement want to be non-zero. You are going to have an inconsistency between the physics of the problem and the boundary condition (zero displacement) you are putting on the corner node. Conventional wisdom in the finite element world says you need to pin at least node to prevent finite translations or rotations of the whole mesh, but in previous work on precipitation problems in the MOOSE phase-field module, I have seen that if you use natural (zero-traction) BCs for the mechanical equilibrium equation, you can solve successfully without needing to pin a node. So I would give that a try. If that doesn't work, try pinning a node that is nowhere near a precipitate.",
                  "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5929656",
                  "updatedAt": "2023-05-17T16:15:29Z",
                  "publishedAt": "2023-05-17T16:12:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You are right on the cause of the misfit. Strain periodicity will fix this \"problem\" without relying on a parallel preconditioner to workaround the null space. We have the entire homogenization system and the global strain system designed for this scenario.",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5930780",
                          "updatedAt": "2023-05-17T18:05:22Z",
                          "publishedAt": "2023-05-17T18:05:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "starkekr"
                          },
                          "bodyText": "Maybe I'm mistaken but the misfit strain should force the total strain to be nonzero rather than the displacement field. Anyway here is the final input file that seems to be working for those who are interested. It utilizes the global strain system to enforce all the components of the mean stress to 0. @hugary1995  I also tried the preconditioner that you gave and it had trouble converging when the global strain system was added (it worked great without it!) so I reverted back to ilu and it seemed to work for this problem\n[GlobalParams]\n  displacements = 'fluct_x fluct_y'\n[]\n[Mesh]\n  [msh]\n    type = GeneratedMeshGenerator\n    dim  = 2\n    nx   = 16\n    ny   = 16\n    nz   = 0\n    xmin = 0\n    xmax = 4.0\n    ymin = 0\n    ymax = 4.0\n    zmin = 0\n    zmax = 0.0\n  []\n  [ns]\n    type         = ExtraNodesetGenerator\n    input        = msh\n    new_boundary = ns1\n    coord        = '0 0 0'\n    #nodes        = 1\n  []\n  uniform_refine    = 3\n[]\n[UserObjects]\n  [global_strain_uo]\n    type                  = GlobalStrainUserObject\n    applied_stress_tensor = '0 0 0 0 0 0'\n    execute_on            = 'Initial Linear Nonlinear'\n  []\n[]\n[ScalarKernels]\n  [global_strain_kernel]\n    type             = GlobalStrain\n    variable         = global_strain\n    global_strain_uo = global_strain_uo\n  []\n[]\n[Variables]\n  [fluct_x]\n    family = LAGRANGE\n    order  = FIRST\n  []\n  [fluct_y]\n    family = LAGRANGE\n    order  = FIRST\n  []\n  [global_strain]\n    order  = THIRD\n    family = SCALAR\n  []\n[]\n\n[AuxVariables]\n  [disp_x]\n    order   = FIRST\n    family  = LAGRANGE\n    outputs = exodus\n  []\n  [disp_y]\n    order   = FIRST\n    family  = LAGRANGE\n    outputs = exodus\n  []\n  [eta0]\n    family = LAGRANGE\n    order  = FIRST\n  []\n  [eta1]\n    family = LAGRANGE\n    order  = FIRST\n  []\n  [bnds]\n    family = LAGRANGE\n    order  = FIRST\n  []\n[]\n[Kernels]\n  [stress_x]\n    type              = StressDivergenceTensors\n    variable          = fluct_x\n    component         = 0\n    eigenstrain_names = eigenstrain\n  []\n  [stress_y]\n    type              = StressDivergenceTensors\n    variable          = fluct_y\n    component         = 1\n    eigenstrain_names = eigenstrain\n  []\n[]\n[AuxKernels]\n  [disp_x]\n    type                 = GlobalDisplacementAux\n    variable             = disp_x\n    scalar_global_strain = global_strain\n    global_strain_uo     = global_strain_uo\n    component            = 0\n  []\n  [disp_y]\n    type                 = GlobalDisplacementAux\n    variable             = disp_y\n    scalar_global_strain = global_strain\n    global_strain_uo     = global_strain_uo\n    component            = 1\n  []\n    [eta0]\n\t\ttype = FunctionAux\n\t\tvariable = eta0\n\t\tfunction = '1.0/(1+exp(-(sqrt((x-(1-t))^2+(y-(1-t))^2)-0.5^2)/0.03))\n\t\t           +1.0/(1+exp(-(sqrt((x-(5-t))^2+(y-(5-t))^2)-0.5^2)/0.03))\n\t\t           +1.0/(1+exp(-(sqrt((x-(1-t))^2+(y-(5-t))^2)-0.5^2)/0.03))\n\t\t           +1.0/(1+exp(-(sqrt((x-(5-t))^2+(y-(1-t))^2)-0.5^2)/0.03))\n\t\t           -3'\n\t\texecute_on = 'initial timestep_begin'\n\t[]\n\t[eta1]\n\t\ttype = ParsedAux\n\t\tvariable = eta1\n\t\targs = eta0\n\t\tfunction = '1-eta0'\n\t\texecute_on = 'initial timestep_begin'\n\t[]\n  [bnds]\n  \ttype = ParsedAux\n\tvariable = bnds\n\targs = 'eta0 eta1'\n\tfunction = 'eta0*(1-eta0)'\n\texecute_on = 'initial timestep_begin'\n  []\n[]\n[Materials]\n  [heta0]\n    type              = SwitchingFunctionMultiPhaseMaterial\n    h_name            = heta0\n    all_etas          = 'eta0 eta1'\n    phase_etas        = eta0\n    outputs           = exodus\n    output_properties = heta0\n  []\n  [heta1]\n    type              = SwitchingFunctionMultiPhaseMaterial\n    h_name            = heta1\n    all_etas          = 'eta0 eta1'\n    phase_etas        = eta1\n    outputs           = exodus\n    output_properties = heta1\n  []\n  [C_eta0]\n    type            = ComputeElasticityTensor\n    fill_method     = symmetric9\n    C_ijkl          = '1.025 0.288 0.406 1.025 0.404 1.059 0.183 0.183 0.368'\n    base_name       = C_eta0\n    rotation_matrix = '-0.98726 0.15910 0.00000 -0.15910 -0.98726 0.00000 0.00000 0.00000 1.00000'\n  []\n  [e_eta1]\n    type            = RotatedGenericConstantRankTwoTensor\n    tensor_values   = '-0.138 0.0 0.0 0.0 0.493 0.0 0.0 0.0 -0.064'\n    tensor_name     = e_eta1\n    rotation_matrix = '-0.54917 -0.83571 0.00000 0.83571 -0.54917 0.00000 -0.00000 0.00000 1.00000'\n  []\n  [C_eta1]\n    type            = ComputeElasticityTensor\n    fill_method     = symmetric9\n    C_ijkl          = '1.011 0.643 0.680 1.011 0.643 1.036 0.433 0.417 0.417'\n    base_name       = C_eta1\n    rotation_matrix = '-0.54917 -0.83571 0.00000 0.83571 -0.54917 0.00000 -0.00000 0.00000 1.00000'\n  []\n  [elastic_tensor]\n    type    = CompositeElasticityTensor\n    args    = 'eta0 eta1'\n    tensors = 'C_eta0 C_eta1'\n    weights = 'heta0 heta1'\n  []\n  [eigenstrain]\n    type             = CompositeEigenstrain\n    tensors          = 'e_eta1'\n    weights          = 'heta1'\n    args             = 'eta0 eta1'\n    eigenstrain_name = eigenstrain\n  []\n  [strain]\n    type          = ComputeSmallStrain\n    eigenstrain_names = eigenstrain\n    global_strain = global_strain\n  []\n  [stress]\n    type              = ComputeLinearElasticStress\n    outputs           = exodus\n    output_properties = stress\n  []\n  [global_strain_material]\n    type                 = ComputeGlobalStrain\n    scalar_global_strain = global_strain\n    global_strain_uo     = global_strain_uo\n  []\n[]\n[BCs]\n  [fixed_x]\n    type     = DirichletBC\n    variable = fluct_x\n    boundary = ns1\n    value    = 0\n  []\n  [fixed_y]\n    type     = DirichletBC\n    variable = fluct_y\n    boundary = ns1\n    value    = 0\n  []\n  [Periodic]\n    [all]\n      variable       = 'fluct_x fluct_y'\n      auto_direction = 'x y'\n    []\n  []\n[]\n[Adaptivity]\n  marker      = combo\n  max_h_level = 4\n  [Markers]\n    [combo]\n      type    = ComboMarker\n      markers = interface\n    []\n    [interface]\n      type     = ValueThresholdMarker\n      variable = bnds\n      refine   = 0.05\n      coarsen  = 0.05\n    []\n  []\n[]\n[Executioner]\n  type                = Transient\n  scheme              = bdf2\n  solve_type          = NEWTON\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'ilu '\n  automatic_scaling   = true\n  l_tol               = 1e-12\n  nl_max_its          = 40\n  nl_rel_tol          = 1e-13\n  nl_abs_tol          = 1e-15\n  start_time          = 0.0\n  dt                  = 0.01\n  num_steps           = 150\n[]\n[Outputs]\n  exodus                 = true\n  execute_on             = 'initial timestep_end'\n  print_linear_residuals = false\n  checkpoint             = true\n  interval               = 1\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5931776",
                          "updatedAt": "2023-05-17T20:49:42Z",
                          "publishedAt": "2023-05-17T20:31:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Thanks for sharing this. You're right that the misfit strain affects the strain field, but strain is calculated as derivatives of displacements, and displacements are actually what are being solved for- you can't get non-zero strain without spatially varying displacements.",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5932017",
                          "updatedAt": "2023-05-17T21:07:11Z",
                          "publishedAt": "2023-05-17T21:07:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Right, the hypre boomeramg preconditioner doesn't handle saddle point problem well (which you get by using the global strain system). I think a field split approach should work, though I had no luck with it so far. I've heard @ttruster discovered a bug in the FSP and that could fix it potentially.",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5932405",
                          "updatedAt": "2023-05-17T22:20:57Z",
                          "publishedAt": "2023-05-17T22:20:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "There wasn't really a bug. It just wasn't allowed. But yes that is fixed in #24379",
                          "url": "https://github.com/idaholab/moose/discussions/24369#discussioncomment-5932794",
                          "updatedAt": "2023-05-17T23:36:41Z",
                          "publishedAt": "2023-05-17T23:36:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Apply a Loading Rate (Force) as a Boundary condition",
          "author": {
            "login": "Vandenbg"
          },
          "bodyText": "I am currently working on a spherical indentation model in MARMOT and until now I have been using displacement control. I would like to compare my results to different applied loads over time,  i.e. 20mn/s or 80mn/s. This should be set up the same as MOOSE. So far I have tried two different methods, Pressure BC and Neumann BC. I have been unsuccessful on both accounts in getting my indenter tip to budge at all.\nThis is what I have been using.\n  [push_down]\n    type = ParsedFunction\n    expression = 'if(t<2, -(t/0.005)*3.2e-6, -0.001280)'\n  []\n  ...\n  [topy]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = '202'\n    function = push_down\n  []\n\nThis is what I tried for Neumann BC. I attempted several functions, each in the same form but changing the 0.020 to higher numbers.\n[topy]\n  type = FunctionNeumannBC\n  variable = disp_y\n  boundary = '202'\n  function = t*0.020\n[]\n\nHere is what I attempted with Pressure BC. Again, I changed the 0.020 value to a range of values with not avail.\n[Pressure]\n  [topy]\n    boundary = '202'\n    function = t*0.020\n    displacements = 'disp_y'\n  []\n[]\n\nPlease let me know If I am doing this correctly, or how I should go about applying a specific loading rate to a boundary. Thank you!",
          "url": "https://github.com/idaholab/moose/discussions/24413",
          "updatedAt": "2023-05-17T22:38:48Z",
          "publishedAt": "2023-05-17T19:36:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "So you are applying both a dirichlet and a load on the same boundary?",
                  "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931560",
                  "updatedAt": "2023-05-17T20:04:19Z",
                  "publishedAt": "2023-05-17T20:04:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Vandenbg"
                          },
                          "bodyText": "Yes, for boundary 202, disp_x and disp_z I am applying dirichlet conditions of 0, and for disp_y I am using what I described above.",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931646",
                          "updatedAt": "2023-05-17T20:14:54Z",
                          "publishedAt": "2023-05-17T20:14:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For disp_y, you have a dirichlet above as well",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931664",
                          "updatedAt": "2023-05-17T20:16:47Z",
                          "publishedAt": "2023-05-17T20:16:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Vandenbg"
                          },
                          "bodyText": "That is correct, it is what I have been using up until this point. The three examples above were all used independently. All three were not used at the same time.",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931672",
                          "updatedAt": "2023-05-17T20:18:40Z",
                          "publishedAt": "2023-05-17T20:18:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "how many time steps did you take? what was the value of 't' in the end",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931905",
                          "updatedAt": "2023-05-17T20:51:01Z",
                          "publishedAt": "2023-05-17T20:51:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Vandenbg"
                          },
                          "bodyText": "In both cases, I let the simulation run with no displacement for roughly 0.5 seconds.",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5932163",
                          "updatedAt": "2023-05-17T21:33:47Z",
                          "publishedAt": "2023-05-17T21:33:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "@recuero and @jiangwen84 do either of you have any insights on modeling nanoindentation with a prescribed load (rather than displacement control)?",
                  "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5931566",
                  "updatedAt": "2023-05-17T20:04:51Z",
                  "publishedAt": "2023-05-17T20:04:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "The methodology I'd use would be something like:\n\nMake sure to remove any possible rigid body motion in the indenter\nUse displacement control to move the indenter down (Dirichlet BC)\nEstablish contact to some extent.\nSwitch to load control, i.e. remove the Dirichlet BC and use controls to impose a load/pressure gradually.\nMake sure the transition between displacement control and load control is smooth. You do that by computing a reaction force for the displacement control part and then applying a consistent initial pressure value.",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5932004",
                          "updatedAt": "2023-05-17T21:20:04Z",
                          "publishedAt": "2023-05-17T21:06:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Vandenbg"
                          },
                          "bodyText": "Thank you for this suggestion. I will attempt this method. Have I set up the Pressure boundary condition correctly, would the reaction force value be placed where 0.02 is in the function?\n[Pressure]\n  [topy]\n    boundary = '202'\n    function = t*0.020 #<-- here?\n    displacements = 'disp_y'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5932190",
                          "updatedAt": "2023-05-17T21:38:14Z",
                          "publishedAt": "2023-05-17T21:38:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Yes, but note that you'll have to sum all the reaction forces and then come up with an initial pressure value that'll have a similar overall loading effect. It doesn't have to be exact, but it has to: 1) Keep precluding rigid body motion and 2) Not deviate from equilibrium too much, i.e. the system needs to be able to converge.",
                          "url": "https://github.com/idaholab/moose/discussions/24413#discussioncomment-5932501",
                          "updatedAt": "2023-05-17T22:38:49Z",
                          "publishedAt": "2023-05-17T22:38:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stress assisted diffusion coupling for anisotropic system",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello MOOSE experts,\nI am trying to add the stress assisted coupling for the anisotropic case which includes the following term:\n\nIn the above equation, diffusion (D) and expansion tensor \\beta is 3 by 3 matrix.\nI already did this coupling for the isotropic case; but, struggling to add for the anisotropic system.\nCan you please point me in the right direction?\nThanks,\nAvtar",
          "url": "https://github.com/idaholab/moose/discussions/24366",
          "updatedAt": "2023-05-17T19:51:01Z",
          "publishedAt": "2023-05-15T16:16:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Compute stress double contracted with beta.\nCompute its gradient. I see that you are already aware of #22910\nD is also a second order tensor, so the result is the mass flux (a vector).",
                  "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5918178",
                  "updatedAt": "2023-05-16T15:47:42Z",
                  "publishedAt": "2023-05-16T15:47:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thanks @hugary1995\nI already calculated sigma_xx and sigma_yy and sigma_zz using RankTwoCartesianComponent in the material kernel and extracted them as material property using Auxkernel MaterialRealAux.\nI am looking for the module to multiply them with expansion values and then add them to consider it a single variable. Then I can use the MatDiffusion kernel for the coupling.\nMy another query is how to add prefactor in the MatDiffusion which can accommodate diffusivity as matrix.\nCan you please me point me towards the modules which I can use?\nBest,\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5929523",
                          "updatedAt": "2023-05-17T16:01:19Z",
                          "publishedAt": "2023-05-17T16:01:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nDoes the anisotropic diffusion work for you?\nhttps://mooseframework.inl.gov/source/kernels/ADMatAnisoDiffusion.html\nIf not changing the diffusion coefficient in the kernel should not be too difficult\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5929711",
                          "updatedAt": "2023-05-17T16:16:34Z",
                          "publishedAt": "2023-05-17T16:16:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Hello @GiudGiud\nI need to add diffusivity as prefactor because there are other terms which needs to be included.\nFor the isotropic case, I did it something like this:\n[./constants]\n    type = GenericConstantMaterial\n    prop_names  = 'factor                 Omega   \tD\tR\t           T'\n    prop_values = '${pressure_coupling}  ${expansion_coeff}  ${diff}  ${gas_constant}\t${temp}'\n  [../]\n\n  [./stress_coeff]\n    type = ParsedMaterial\n    function = 'factor*(D*Omega*c)/(R*T)'\n    args = 'c'\n    f_name = 'prefactor_pressure_coupling'\n    material_property_names = 'factor D Omega\tR\tT'\n  [../]\n\nand then added it in the kernel as\n [stress_grad]\n   type = MatDiffusion\n   variable = 'c'\n   v = 'pressure'\n   diffusivity = 'prefactor_pressure_coupling'\n []\n\nIs there a way to do same thing when diffusivity is matrix?\nThen I can use MatAnisoDiffusion kernel for the coupling.\nOther than that\nCan you also point me to the module which I can use to find the sum of sigma_xx*beta_xx + sigma_yy*beta_yy + sigma_zz*beta_zz  and then add it as material property for the coupling, the same way I did it for isotropic case?\nBest,\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5929879",
                          "updatedAt": "2023-05-17T16:35:02Z",
                          "publishedAt": "2023-05-17T16:33:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "See the object I pasted for a start on anisotropic diffusion",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5929895",
                          "updatedAt": "2023-05-17T16:35:05Z",
                          "publishedAt": "2023-05-17T16:35:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Though I m sure there's anisotropic stress models in the tensor mechanics module you could look at as well",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5930236",
                          "updatedAt": "2023-05-17T17:07:46Z",
                          "publishedAt": "2023-05-17T17:07:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "This will be quite a stretch without writing some C++.",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5930964",
                          "updatedAt": "2023-05-17T18:33:10Z",
                          "publishedAt": "2023-05-17T18:33:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "@hugary1995  Ok. Can you please point me to the closest kernel (.C subroutine) so that I can build on top of it? Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24366#discussioncomment-5931449",
                          "updatedAt": "2023-05-17T19:51:18Z",
                          "publishedAt": "2023-05-17T19:51:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiphase modelling without concentration parameter",
          "author": {
            "login": "MScKarl"
          },
          "bodyText": "Hi everyone!\nI have been using MOOSE for a while but there are still things I really can\u2019t grasp. This is the only place I can turn to for help and I am in desperate need of some.\nFor some time, I have tried to convert my single-phase parameter algorithm into a dual-phase parameter algorithm. The problem I seem to face is that multiple of the required modules (switching functions, barrier functions, and penalty functions), require me to define a concentration of the different phases. In my case, I do not want to use the concentration.\nThe mathematical equations that I am using (which are shown in the images below) use mechanical stress to drive the phase transformation. How can I in the best possible way define this in MOOSE? The equations are already combined into one in f_eta, but when I run my code, everything changes phase, which isn\u2019t right.\nI would very much appreciate any help, explanations, and code-changing suggestions.\nBest Regards\nKarl\n\n[Mesh]\n    type = GeneratedMesh\n    dim = 2\n    nx = 400\n    ny = 400\n    xmin = -3\n    xmax = 3\n    ymin = -3\n    ymax = 3\n    elem_type = QUAD4\n[]\n\n[AuxVariables]\n  [./local_energy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n  [./cross_energy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[Variables]\n  [./eta1]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  [./eta2]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n[]\n\n[ICs]\n  [./eta1]\n    variable = eta1\n    type = RandomIC\n    min = 1e-5\n    max = 1e-3\n  [../]\n\n  [./eta2]\n    variable = eta2\n    type = RandomIC\n    min = 1e-5\n    max = 1e-3\n  [../]\n[]\n\n[BCs]\n\n   [./left_1]\n    type = NeumannBC\n    variable = 'eta1'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n  [./left_2]\n    type = NeumannBC\n    variable = 'eta2'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n   [./right_1]\n    type = NeumannBC\n    variable = 'eta1'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n  [./right_2]\n    type = NeumannBC\n    variable = 'eta2'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n   [./top_1]\n    type = NeumannBC\n    variable = 'eta1'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n  [./top_2]\n    type = NeumannBC\n    variable = 'eta2'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n  [./bottom_1]\n    type = NeumannBC\n    variable = 'eta1'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n  [./bottom_2]\n    type = NeumannBC\n    variable = 'eta2'\n    boundary = 'bottom'\n    value = 0.0\n  [../]\n\n[]\n\n[AuxKernels]\n\n  [./cross_terms]\n    type = CrossTermGradientFreeEnergy\n    variable = cross_energy\n    interfacial_vars = 'eta1 eta2'\n\n    kappa_names = 'kappa11 kappa12 \n                   kappa21 kappa22' \n                   \n  [../]\n\n[]\n\n[Kernels]\n  #\n  # Order parameter eta1\n  #\n  # Time derivative 1 \n  [./deta1_dt]\n    type = TimeDerivative\n    variable = eta1\n  [../]\n\n  #Interface 1\n  [./ACIntF_1]\n    type = ACMultiInterface\n    variable = eta1\n    etas = 'eta1 eta2'\n    mob_name = L1\n    kappa_names = 'kappa11 kappa12' \n  [../]\n\n  #Bulk 1\n  [./ACbulk_eta1]\n    type = AllenCahn\n    variable = eta1\n    coupled_variables = 'eta2'\n    mob_name = L1\n    f_name = F\n  [../]\n\n  #\n  # Order parameter eta2\n  #\n  # Time derivative 2      \n  [./deta2_dt]\n    type = TimeDerivative\n    variable = eta2\n  [../]\n\n  #Interface 2\n  [./ACIntF_2]\n    type = ACMultiInterface\n    variable = eta2\n    etas = 'eta1 eta2'\n    mob_name = L2\n    kappa_names = 'kappa21 kappa22' \n  [../]\n\n  #Bulk 2\n  [./ACbulk_eta2]\n    type = AllenCahn\n    variable = eta2\n    coupled_variables = 'eta1'\n    mob_name = L2\n    f_name = F\n  [../]\n[]\n\n[Materials]\n\n  [./kappa]\n    type = GenericConstantMaterial\n    prop_names  = 'kappa11 kappa12 kappa21 kappa22'\n    prop_values = '0.0000000133\t\t0\t0.000000334\t0'\n  [../]\n\n   [./L1]\n    type = GenericConstantMaterial\n    prop_names = 'L1'\n    prop_values = '1.0'\n  [../]\n\n   [./L2]\n    type = GenericConstantMaterial\n    prop_names = 'L2'\n    prop_values = '1.0'\n  [../]\n\n  [./P0]\n    type = GenericConstantMaterial\n    prop_names = 'P0'\n    prop_values = '144000000'\n  [../]\n\n  [./s]\n    type = GenericConstantMaterial\n    prop_names = 's'\n    prop_values = '0.6'\n  [../]\n\n  [./f_eta]\n    type = DerivativeParsedMaterial\n    property_name = f_eta # Name of the function\n    coupled_variables = 'eta1 eta2' \n    constant_names = 'P0 s'\n    constant_expressions = '144*10^6 0.6'\n    expression = 'P0*(((eta1^2-1)^2)+((eta2^2-1)^2)*(s/4*(eta1*(eta1+2)*(eta1^2+2*eta1-6)-7)))'\n  [../]\n\n[]\n\n[Postprocessors]\n  \n  [./eta_1]\n    type = ElementIntegralVariablePostprocessor\n    variable = 'eta1'\n  [../]\n  [./eta_2]\n    type = ElementIntegralVariablePostprocessor\n    variable = 'eta2'\n  [../]\n\n[]\n\n\n[Preconditioning]\n\n    type = SMP\n    full = true\n  [../]\n\n[]\n\n[Executioner]\n  type = Transient\n  scheme = 'bdf2'\n\n  solve_type = 'NEWTON'\n\n  start_time = 0.0\n  end_time   = 500.0\n\n  [./TimeStepper]\n    type = SolutionTimeAdaptiveDT\n    dt = 0.1\n  [../]\n[]\n\n[Debug]\n  # show_var_residual_norms = true\n[]\n\n[Outputs]\n\n  [./exodus]\n    type = Exodus\n  [../]\n\n[]\n\n\nBest regards\nKarl",
          "url": "https://github.com/idaholab/moose/discussions/24321",
          "updatedAt": "2023-05-17T16:29:25Z",
          "publishedAt": "2023-05-10T16:18:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "MScKarl"
                  },
                  "bodyText": "Hi @dschwen @amjokisaari!\nIn your profile, which I got from the MOOSE discussion page, it said that you are working in computational material science, which is the same area in which I tried to apply MOOSE. I was wondering if you maybe could have a look at my question. Maybe you could give me some suggestions or input on how I should proceed. If anything is unclear or if there is something I need to specify please let me know.\nBest regards\nKarl",
                  "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5905680",
                  "updatedAt": "2023-05-15T13:56:33Z",
                  "publishedAt": "2023-05-15T13:56:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MScKarl"
                  },
                  "bodyText": "@GiudGiud Maybe you are able to help me? I am in urgent need of help.\nBest regards\nKarl",
                  "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5917774",
                  "updatedAt": "2023-05-16T15:10:56Z",
                  "publishedAt": "2023-05-16T15:10:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'm sorry this (phase field and mechanics) is not my area of expertise.\n@laagesen or @hugary1995 will know more than me.",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918259",
                          "updatedAt": "2023-05-16T15:54:42Z",
                          "publishedAt": "2023-05-16T15:54:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "Hi @GiudGiud!\nI understand, but thanks for your reply. Is there a quick way to contact these people, as I'm a bit pressed for time?",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918347",
                          "updatedAt": "2023-05-16T16:04:05Z",
                          "publishedAt": "2023-05-16T16:04:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Their emails are public you can try that.\nThey are both active on this forum they'll pitch in if they have time.",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918406",
                          "updatedAt": "2023-05-16T16:10:54Z",
                          "publishedAt": "2023-05-16T16:10:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I don't have expertise on this matter, sorry. But before others chime in, I have the following suggestions/questions for starters:\n\nremove the Neumann BCs, they are unnecessary unless you want to prescribe nonzero fluxes.\nYou said \"The mathematical equations that I am using (which are shown in the images below) use mechanical stress to drive the phase transformation.\" but I don't see any elastic energy contribution in your free energy.",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918479",
                          "updatedAt": "2023-05-16T16:18:16Z",
                          "publishedAt": "2023-05-16T16:18:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "To add to what @hugary1995 said, I'm not sure what the evolution equations of the model are. Do you have Allen-Cahn equations for eta1 and eta2 derived from this? There would need to be gradient energy terms defined, as well as elastic energy terms as @hugary1995 mentioned.",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918650",
                          "updatedAt": "2023-05-16T16:31:29Z",
                          "publishedAt": "2023-05-16T16:31:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "Hi!\nThank you for your answers. In the images below is the Allen-Cahn equation used and the Total free energy equation that is being used.\n\n\u0413ij is a diagonal matrix referred to as the mobility tensor and is multiplied by the functional derivative of the total free energy \ud835\udc39",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918807",
                          "updatedAt": "2023-05-16T16:53:10Z",
                          "publishedAt": "2023-05-16T16:48:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You can start from this example: modules/combined/examples/phase_field-mechanics/SimplePhaseTrans.i",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918854",
                          "updatedAt": "2023-05-16T16:54:01Z",
                          "publishedAt": "2023-05-16T16:54:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "Thank you. I will go through the example. I may ask some follow up questions later if I don't solve it. I hope that's okay?",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918890",
                          "updatedAt": "2023-05-16T16:57:33Z",
                          "publishedAt": "2023-05-16T16:57:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yes sure, just post it here. All of us try our best to offer free premium support within our bandwidth :)",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5918948",
                          "updatedAt": "2023-05-16T17:05:33Z",
                          "publishedAt": "2023-05-16T17:05:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MScKarl"
                  },
                  "bodyText": "Hi again!\nI apologize that I return so quickly, but I just realized that I made a small mistake in my equations regarding the total free energy.\nWhat I missed was that the elastic energy is included in the potential and should not be handled separately. In the first-mentioned equations, all energy contributions are mathematically included except the gradient term (i.e. the interface contribution). This means that the mechanical part comes implicitly through its (x,y)- dependency. This would in turn mean that the mechanical energy is only spatial dependent and should not evolve with the phase evolution. The problem for me is to try to solve the equations:",
                  "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5926507",
                  "updatedAt": "2023-05-17T11:21:22Z",
                  "publishedAt": "2023-05-17T11:21:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'm totally lost. Someone else please help...",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5927370",
                          "updatedAt": "2023-05-17T12:56:58Z",
                          "publishedAt": "2023-05-17T12:56:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Based on the equations you've posted here, you should be able to solve the problem using two Allen-Cahn equations, one for eta1 and another for eta2. For each one, you need 3 kernels: TimeDerivative, ACInterface, and AllenCahn. Based on the form of the gradient terms, you don't need to use ACMultiInterface. You can need to pass your free energy f_eta to each of the two Allen-Cahn equations. Please have a look at this documentation and study how each kernel implements the governing equation as I've described: https://mooseframework.inl.gov/modules/phase_field/Phase_Field_Equations.html",
                          "url": "https://github.com/idaholab/moose/discussions/24321#discussioncomment-5929834",
                          "updatedAt": "2023-05-17T16:29:26Z",
                          "publishedAt": "2023-05-17T16:29:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow: Problem in convergence",
          "author": {
            "login": "sinaomrani96"
          },
          "bodyText": "Dear all,\nHope you are doing well.\nI wanted to simulate a 2-phase 3-component (water + tracer + CO2) system. First, I simulated the water + tracer system with PorousFlowFullySaturated similar to an example in tutorial_06. The I used \"Restarting and recovering from previous simulations\" to inject CO2, as I want to have tracer transport as CO2 get injected in my system. However, I have problem regarding convergence. I don't know that this problem is highly nonlinear or there are simpler ways to do it. I appreciate your insight on this. Also, Here are the input files if you want to have a look. Thanks.\nhttps://github.com/sinaomrani96/Test\nBest regards,\nSina",
          "url": "https://github.com/idaholab/moose/discussions/24235",
          "updatedAt": "2023-05-17T15:55:19Z",
          "publishedAt": "2023-05-01T11:34:32Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Hey @sinaomrani96 ,\nThere is general advice here: https://mooseframework.inl.gov/modules/porous_flow/nonlinear_convergence_problems.html  Please read carefully, as almost every sentence there comes from people struggling with many convergence problems.\nYour model is the most difficult situation (multiphase and multicomponent).  It is very easy for PorousFlow to drive a model to a situation where:\n\nthe boundary conditions are trying to remove fluid components that don't exist at the boundary\nthe saturation or mass fraction is very close to zero or one\nthe Jacobian is almost singular\n\nYou could try running for a while, recording residuals into AuxVars and visualising them to determine what the problem is.  You could try a different initialisation, eg, instead of mass_fraction = 0 somewhere, make it 0.1, just to see what happens.  You could try using a PP (2 porepressures) rather than PS formulation.   You could try changing \"variable = \" the Kernels+BCs+Diracs , eg, swap \"variable = tracer\" for \"variable = sgas\".   You could try turning off various BCs, or adding others (such as removing other components from boundary=right) or using different use_* to handle strange cases of saturation=0, etc.",
                  "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5775325",
                  "updatedAt": "2023-05-01T21:36:07Z",
                  "publishedAt": "2023-05-01T21:36:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Dear @WilkAndy,\nThanks for your reply.\nI will follow your comment and instructions. Sorry to take more of your time but I tried to run the first simulation a bit shorter, and after that run the second simulation (2-phase 3-components) and it converges at least but to a wrong answer (the previous setup failed to converge from the beginning). I tried to record residuals into AuxVars as you suggested but I face Segmentation fault. I was wondering if I am doing it wrong or there is something else. I would appreciate it if you could help me why I cannot record the residuals. Also here is the saturation profile if I turn off the DebugResidualAux.\ninput files: https://github.com/sinaomrani96/Test/tree/main",
                          "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5779400",
                          "updatedAt": "2023-05-02T10:35:40Z",
                          "publishedAt": "2023-05-02T10:35:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Use the save_in feature of a Kernel to shove the residual into an AuxVariable.\nOh dear, the saturation is waaay wrong (negative saturation).   I suspect it's due to using PorousFlowCapillaryPressureConst instead of an experimentally-measured capillary curve.\nOne other thing to try - probably best to do this before the other items mentioned above - is to copy almost exactly porous_flow/examples/restart/gas_injection.i .  See https://mooseframework.inl.gov/modules/porous_flow/restart.html .    That does almost exactly what you want, but is only 2-component.  Then you can figure out whether it's the extra fluid component or the gas phase that is causing your problems.",
                          "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5785624",
                          "updatedAt": "2023-05-02T21:50:50Z",
                          "publishedAt": "2023-05-02T21:50:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Dear @WilkAndy,\nThanks for your help and time. I finally got it running to a more logical answer, but still it needs correction. As I was getting values other than 0 for mass fraction of my second component (which is gas in the gas phase and should not have any value in the 1st phase), I suspected that this is the issue. I do not know if this is a silly approach or actually smart but this is what I did:\nAs I initialise my second simulation based on a single-phase tracer+water system, I assigned a ParseMaterial to have the value of mass fraction for water in that system. Then I used this for my second run instead of initialising water mass fraction with the values calculated by PorousFlowPropertyAux. However, the problem of getting values (highly negative) for my second component in first phase still persists, and this makes error in calculating mass fractions. How I can prevent this? Here are my input files and results (gas saturation profile and its mass fraction in first phase) now:\nhttps://github.com/sinaomrani96/Test/tree/main\n\n\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5790544",
                          "updatedAt": "2023-05-03T12:05:39Z",
                          "publishedAt": "2023-05-03T12:05:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Hey @sinaomrani96 - i'm not going to have time to look at this for the next few days.   i'm giving some important lectures and organising a conference and they're taking all my time.",
                          "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5809847",
                          "updatedAt": "2023-05-04T21:06:57Z",
                          "publishedAt": "2023-05-04T21:06:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sinaomrani96"
                          },
                          "bodyText": "Hi,\nI just wanted to update the status of this problem that changing the order of numbering will solve this issue. Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24235#discussioncomment-5929465",
                          "updatedAt": "2023-05-17T15:55:19Z",
                          "publishedAt": "2023-05-17T15:55:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Recrystallization literature and open source code",
          "author": {
            "login": "KangChenRui"
          },
          "bodyText": "Hi\uff0cEveryone\uff01\nI would like to learn about the literature and open source code related to recrystallization.\nIs there any content on these aspects on MOOSE?\nThank you for your help\nChenrui",
          "url": "https://github.com/idaholab/moose/discussions/24409",
          "updatedAt": "2023-05-17T15:06:15Z",
          "publishedAt": "2023-05-17T08:02:55Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "We have done recrystallization simulations, where we keep track of a stored energy content in each grain and use the DiscreteNucleation system to nucleate new grains. @amjokisaari has worked on this.",
                  "url": "https://github.com/idaholab/moose/discussions/24409#discussioncomment-5928870",
                  "updatedAt": "2023-05-17T15:01:18Z",
                  "publishedAt": "2023-05-17T15:01:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "https://link.springer.com/article/10.1007/s11837-019-03830-z",
                  "url": "https://github.com/idaholab/moose/discussions/24409#discussioncomment-5928931",
                  "updatedAt": "2023-05-17T15:06:16Z",
                  "publishedAt": "2023-05-17T15:06:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow: Sink dirackernel of components with the whole mass_flux",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear all,\nI learn the Point and line sources/sinks page. I can set the source dirackernels with known separate mass_flux for all components by PorousFlowSquarePulsePointSource. For example,\n[DiracKernels]\n  [source1]\n    type = PorousFlowSquarePulsePointSource\n    start_time = 0\n    end_time = 100\n    point = '0.5 0.5 0'\n    mass_flux = 0.1\n    variable = pp\n  []\n  [source0]\n    type = PorousFlowSquarePulsePointSource\n    start_time = 0\n    end_time = 100\n    point = '0.5 0.5 0'\n    mass_flux = 0.02\n    variable = mf_0\n  []\n[]\n\nAnd I also want to set the sink dirackernel for all components. Only the sum of the mass flux of all components is known. I try the PorousFlowPeacemanBorehole but the produced mass flux is dynamic and it is the function of the pressure.\nBut I want to set the fixed overall mass flux of all components, equal to the overall mass flux in the source dirackernel.\nHow can I solve this problem?\nThanks for your help.\nJ",
          "url": "https://github.com/idaholab/moose/discussions/24375",
          "updatedAt": "2023-05-17T14:36:52Z",
          "publishedAt": "2023-05-15T23:14:37Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "You could use a PorousFlowPolyLineSink and specify mass_fraction_component in place of the PorousFlowPeacemanBorehole as your production well - see https://github.com/idaholab/moose/blob/next/modules/combined/examples/geochem-porous_flow/geotes_2D/porous_flow.i for an example",
                  "url": "https://github.com/idaholab/moose/discussions/24375#discussioncomment-5910460",
                  "updatedAt": "2023-05-16T00:09:04Z",
                  "publishedAt": "2023-05-16T00:09:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "You could use a PorousFlowPolyLineSink and specify mass_fraction_component in place of the PorousFlowPeacemanBorehole as your production well - see https://github.com/idaholab/moose/blob/next/modules/combined/examples/geochem-porous_flow/geotes_2D/porous_flow.i for an example\n\nHello Chris, thanks for your suggestions. It does work well.",
                          "url": "https://github.com/idaholab/moose/discussions/24375#discussioncomment-5928584",
                          "updatedAt": "2023-05-17T14:36:53Z",
                          "publishedAt": "2023-05-17T14:36:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}