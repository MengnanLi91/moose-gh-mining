{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNy0wOFQwMzo1MDowMC0wNTowMM4AP-C0"
    },
    "edges": [
      {
        "node": {
          "title": "[Terminator][Subapp]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Hi moose users,\nRecently, I am using a Terminator.C to finish my subapp in a multiapp.\nHowever, if I use the Terminator.C, my subapp does not calculate anything after the first timestep of my mainapp.\nIt seems like the Terminator.C turn off the subapp for whole timesteps for mainapp after the subapp reached the criteria.\nI checked this issue with put the following print line in the execute class of Terminator.C:\nstd::cout << \"Time Execute Terminator Test :\" << _t << std::endl;\nHere I attached the output results during the calculation:\n--------------------------------------------------------------------\nsub_app0: Time Step 41, time = 41, dt = 1\nsub_app0:\nsub_app0: Performing automatic scaling calculation\nsub_app0:\nsub_app0:  0 Nonlinear |R| = 0.000000e+00\nsub_app0:  Solve Converged!\ncurrents: 29.6614 Older currents:92.9853\nchanged potential difference: 1e-07\n**Time Execute Terminator Test :41**\nsub_app0:\nsub_app0: Postprocessor Values:\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0: | time           | EcorrPostCal   | Isum           | SideAverageO2  | SideAverageTTT |\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0: :                :                :                :                :                :\nsub_app0: |   2.700000e+01 |  -2.918000e-01 |  -2.135603e+04 |   2.500000e-01 |  -2.919000e-01 |\nsub_app0: |   2.800000e+01 |  -2.918100e-01 |   1.029218e+04 |   2.500000e-01 |  -2.918000e-01 |\nsub_app0: |   2.900000e+01 |  -2.918200e-01 |   7.123863e+03 |   2.500000e-01 |  -2.918100e-01 |\nsub_app0: |   3.000000e+01 |  -2.918300e-01 |   3.956327e+03 |   2.500000e-01 |  -2.918200e-01 |\nsub_app0: |   3.100000e+01 |  -2.918400e-01 |   7.895681e+02 |   2.500000e-01 |  -2.918300e-01 |\nsub_app0: |   3.200000e+01 |  -2.918300e-01 |  -2.376415e+03 |   2.500000e-01 |  -2.918400e-01 |\nsub_app0: |   3.300000e+01 |  -2.918310e-01 |   7.895681e+02 |   2.500000e-01 |  -2.918300e-01 |\nsub_app0: |   3.400000e+01 |  -2.918320e-01 |   4.729349e+02 |   2.500000e-01 |  -2.918310e-01 |\nsub_app0: |   3.500000e+01 |  -2.918330e-01 |   1.563094e+02 |   2.500000e-01 |  -2.918320e-01 |\nsub_app0: |   3.600000e+01 |  -2.918320e-01 |  -1.603082e+02 |   2.500000e-01 |  -2.918330e-01 |\nsub_app0: |   3.700000e+01 |  -2.918321e-01 |   1.563094e+02 |   2.500000e-01 |  -2.918320e-01 |\nsub_app0: |   3.800000e+01 |  -2.918322e-01 |   1.246473e+02 |   2.500000e-01 |  -2.918321e-01 |\nsub_app0: |   3.900000e+01 |  -2.918323e-01 |   9.298528e+01 |   2.500000e-01 |  -2.918322e-01 |\nsub_app0: |   4.000000e+01 |  -2.918324e-01 |   6.132331e+01 |   2.500000e-01 |  -2.918323e-01 |\nsub_app0: |   4.100000e+01 |  -2.918325e-01 |   2.966143e+01 |   2.500000e-01 |  -2.918324e-01 |\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0:\nsub_app0:\nsub_app0: Time Step 42, time = 42, dt = 1\nsub_app0:\nsub_app0: Performing automatic scaling calculation\nsub_app0:\nsub_app0:  0 Nonlinear |R| = 0.000000e+00\nsub_app0:  Solve Converged!\ncurrents: -2.00038 Older currents:61.3233\nchanged potential difference: 1e-07\n**Time Execute Terminator Test :42**\nTime :42\nsub_app0:\nsub_app0: Postprocessor Values:\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0: | time           | EcorrPostCal   | Isum           | SideAverageO2  | SideAverageTTT |\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0: :                :                :                :                :                :\nsub_app0: |   2.800000e+01 |  -2.918100e-01 |   1.029218e+04 |   2.500000e-01 |  -2.918000e-01 |\nsub_app0: |   2.900000e+01 |  -2.918200e-01 |   7.123863e+03 |   2.500000e-01 |  -2.918100e-01 |\nsub_app0: |   3.000000e+01 |  -2.918300e-01 |   3.956327e+03 |   2.500000e-01 |  -2.918200e-01 |\nsub_app0: |   3.100000e+01 |  -2.918400e-01 |   7.895681e+02 |   2.500000e-01 |  -2.918300e-01 |\nsub_app0: |   3.200000e+01 |  -2.918300e-01 |  -2.376415e+03 |   2.500000e-01 |  -2.918400e-01 |\nsub_app0: |   3.300000e+01 |  -2.918310e-01 |   7.895681e+02 |   2.500000e-01 |  -2.918300e-01 |\nsub_app0: |   3.400000e+01 |  -2.918320e-01 |   4.729349e+02 |   2.500000e-01 |  -2.918310e-01 |\nsub_app0: |   3.500000e+01 |  -2.918330e-01 |   1.563094e+02 |   2.500000e-01 |  -2.918320e-01 |\nsub_app0: |   3.600000e+01 |  -2.918320e-01 |  -1.603082e+02 |   2.500000e-01 |  -2.918330e-01 |\nsub_app0: |   3.700000e+01 |  -2.918321e-01 |   1.563094e+02 |   2.500000e-01 |  -2.918320e-01 |\nsub_app0: |   3.800000e+01 |  -2.918322e-01 |   1.246473e+02 |   2.500000e-01 |  -2.918321e-01 |\nsub_app0: |   3.900000e+01 |  -2.918323e-01 |   9.298528e+01 |   2.500000e-01 |  -2.918322e-01 |\nsub_app0: |   4.000000e+01 |  -2.918324e-01 |   6.132331e+01 |   2.500000e-01 |  -2.918323e-01 |\nsub_app0: |   4.100000e+01 |  -2.918325e-01 |   2.966143e+01 |   2.500000e-01 |  -2.918324e-01 |\nsub_app0: |   4.200000e+01 |  -2.918325e-01 |  -2.000378e+00 |   2.500000e-01 |  -2.918325e-01 |\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0:\nCopyTransfer: TTT\nCopyTransfer: TTT\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 8.472638e-02\n      0 Linear |R| = 3.680385e+00\n      1 Linear |R| = 1.804670e-15\n 1 Nonlinear |R| = 8.309315e-02\n      0 Linear |R| = 3.588376e+00\n      1 Linear |R| = 7.778159e-15\n 2 Nonlinear |R| = 2.241028e-03\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  HS-: 2.241028e-03\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | Ecorr          | FClm           | FCu2p          | FCuCl2m        | FHSm           | FO2            | IA             | IC             | ID             | IE             | IS             | O2             |\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-09 |  -2.918325e-01 |  -6.539886e+00 |   0.000000e+00 |   3.269943e+00 |  -2.214755e+09 |  -8.978969e-01 |   3.155004e+05 |  -3.465343e+05 |   0.000000e+00 |   2.961443e-07 |   2.136907e+14 |   2.499999e-01 |\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n\n\nTime Step 2, time = 2.1e-09, dt = 1.1e-09\nCopyTransfer: O2\nCopyTransfer: O2\nsub_app0:\nsub_app0: Time Step 0, time = 0\nsub_app0:\nsub_app0: Postprocessor Values:\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0: | time           | EcorrPostCal   | Isum           | SideAverageO2  | SideAverageTTT |\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0: |   0.000000e+00 |  -2.918325e-01 |  -2.000378e+00 |   2.500000e-01 |  -2.918325e-01 |\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0:\nCopyTransfer: TTT\nCopyTransfer: TTT\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 2.465074e-03\n\n      0 Linear |R| = 8.524832e-04\n      1 Linear |R| = 1.886083e-19\n 1 Nonlinear |R| = 6.162670e-04\n      0 Linear |R| = 3.013980e-04\n      1 Linear |R| = 3.515695e-19\n 2 Nonlinear |R| = 1.540669e-04\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  HS-: 1.540669e-04\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | Ecorr          | FClm           | FCu2p          | FCuCl2m        | FHSm           | FO2            | IA             | IC             | ID             | IE             | IS             | O2             |\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-09 |  -2.918325e-01 |  -6.539886e+00 |   0.000000e+00 |   3.269943e+00 |  -2.214755e+09 |  -8.978969e-01 |   3.155004e+05 |  -3.465343e+05 |   0.000000e+00 |   2.961443e-07 |   2.136907e+14 |   2.499999e-01 |\n|   2.100000e-09 |  -2.918325e-01 |  -6.535205e+00 |   0.000000e+00 |   3.267602e+00 |  -1.384216e+08 |  -8.978960e-01 |   3.152746e+05 |  -3.465340e+05 |   0.000000e+00 |   7.403611e-08 |   1.335560e+13 |   2.499998e-01 |\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n\n\nTime Step 3, time = 3.31e-09, dt = 1.21e-09\nCopyTransfer: O2\nCopyTransfer: O2\nsub_app0:\nsub_app0: Time Step 0, time = 0\nsub_app0:\nsub_app0: Postprocessor Values:\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0: | time           | EcorrPostCal   | Isum           | SideAverageO2  | SideAverageTTT |\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0: |   0.000000e+00 |  -2.918325e-01 |  -2.000378e+00 |   2.500000e-01 |  -2.918325e-01 |\nsub_app0: +----------------+----------------+----------------+----------------+----------------+\nsub_app0:\nCopyTransfer: TTT\nCopyTransfer: TTT\n\n------------------------------------------------------------------------------------------------\n\nSo, as you can see in the above results. The Terminator does not participate in the subapp calculation after the first timestep of mainapp.\nIs it a bug?\nKind regards,\nNakkyu",
          "url": "https://github.com/idaholab/moose/discussions/21546",
          "updatedAt": "2022-07-11T08:54:45Z",
          "publishedAt": "2022-07-10T05:39:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "coskrrb2002"
                  },
                  "bodyText": "I used postprocessorDT to overcome this issue.\nBut I am still wondering about this issue.",
                  "url": "https://github.com/idaholab/moose/discussions/21546#discussioncomment-3118251",
                  "updatedAt": "2022-07-11T04:03:58Z",
                  "publishedAt": "2022-07-11T04:03:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis isnt necessarily a bug. The Terminator was thought as a tool to end a simulation, and therefore to be used in the main app more likely. There isnt really anything in its documentation that lets you think it can be used in a subapp, reset and re-used on the next time step.\nI agree it would be a convenient feature.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21546#discussioncomment-3118331",
                  "updatedAt": "2022-07-11T04:27:10Z",
                  "publishedAt": "2022-07-11T04:27:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to realize fully coupled simulation through MultiApps system in MOOSE",
          "author": {
            "login": "sychang2021"
          },
          "bodyText": "I have a problem coupled by two systems which have twenty variables. When the number of mesh is large, solving the equations of the two systems simultaneously will face the limitation of solution speed and memory. So I think it is possible to solve the two problems separately (in two input files) and pass the information through the MultiApps system. But in doing so, is the solution method tightly coupled instead of fully coupled ? Can I achieve full coupling through the MultiApps system?",
          "url": "https://github.com/idaholab/moose/discussions/21545",
          "updatedAt": "2022-07-11T04:18:50Z",
          "publishedAt": "2022-07-09T17:25:10Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "We refer to full coupling as the single-matrix approach, where all variables are solved for in the same system.\nYou can only achieve tight or loose coupling using MultiApps. At convergence, the results from full and tight coupling should be the same",
                  "url": "https://github.com/idaholab/moose/discussions/21545#discussioncomment-3113911",
                  "updatedAt": "2022-07-09T23:04:20Z",
                  "publishedAt": "2022-07-09T23:04:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sychang2021"
                          },
                          "bodyText": "On my computer, I'm using Newton's method to solve a problem with 20 variables, 20,000 grids, which is a coupling of two different problems. Below is my setup in Executioner.\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n\n  #petsc_options_iname = '-pc_type -sub_pc_type -ksp_gmres_restart -pc_gasm_overlap -sub_pc_factor_shift_type -pc_gasm_blocks -sub_pc_factor_mat_solver_type'\n  #petsc_options_value = 'gasm     lu           200                1                NONZERO                   16             superlu_dist'\n\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n\nAt the beginning, it takes 1000s to solve each step. When the solution reaches more than 30 steps, it takes more than 1 hour to solve each step. But when I solve the two subproblems separately, the total time to solve one step is about 200 seconds. So I thought it would be more feasible to solve them separately. But I'm also worried about the accuracy of the solution. Do you think fully coupled and tightly coupled results are the same when converging?\nI would very much like to use the single-matrix approach to solving the problem, which looks wonderful and ideal. But limited by solving time and memory, maybe I have to take another approach.\nI have tried other petsc setups like the other petsc setup above. The solution time of each step is about 1/3 of the direct lu method. But still too slow for a large problem. Do you have any suggestions?",
                          "url": "https://github.com/idaholab/moose/discussions/21545#discussioncomment-3114183",
                          "updatedAt": "2022-07-10T02:57:25Z",
                          "publishedAt": "2022-07-10T02:52:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It takes 200s with fixed point iterations? Or did you just run one solve then the other (loose coupling).\nYes at convergence fully and tightly coupled match. I have yet to see a case where they dont.\nThe single matrix approach is simple but is not the most common method. Numerically, it's more often than not beneficial to separate solves to reduce the size of the system.",
                          "url": "https://github.com/idaholab/moose/discussions/21545#discussioncomment-3114225",
                          "updatedAt": "2022-07-10T03:26:57Z",
                          "publishedAt": "2022-07-10T03:26:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sychang2021"
                          },
                          "bodyText": "I have split a coupling problem into two separate problems. One of the problems took 130 seconds to solve in one step, and the other took 70 seconds to solve in one step. It looks like I need to use the MultiApps system for tight coupling. Thanks for your suggestion and reply.",
                          "url": "https://github.com/idaholab/moose/discussions/21545#discussioncomment-3114248",
                          "updatedAt": "2022-07-10T03:41:45Z",
                          "publishedAt": "2022-07-10T03:41:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you need to iterate the coupling though. Like both problems need to run several times for each time step, exchanging information using Transfers.\nSee the fixed point parameters in the dropdown here:\nhttps://mooseframework.inl.gov/source/multiapps/FullSolveMultiApp.html",
                          "url": "https://github.com/idaholab/moose/discussions/21545#discussioncomment-3118306",
                          "updatedAt": "2022-07-11T04:18:50Z",
                          "publishedAt": "2022-07-11T04:18:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Multiapp][Transfer]",
          "author": {
            "login": "coskrrb2002"
          },
          "bodyText": "Dear Users,\nI am trying to make the following multi-app:\n\nI am trying to use FullSolveMultiApp and MultiAppCopyTransfer, however, it doesn't work very well.\nWhen I was trying, Subapp doesn't update value B from the main app after timestep 1.\nThe following lines are the multiapps and transfer I used.\nDid I make any mistake here?\n\nCode\n[MultiApps]\n  [sub_app]\n    type = FullSolveMultiApp\n    app_type = corrosionApp\n    input_files = 'FakeTest2.i'\n    clone_master_mesh = true # Use mesh of master.i in sub.i file\n  []\n[]\n[Transfers]\n  [pull]\n    type = MultiAppCopyTransfer\n    from_multi_app = sub_app\n    variable = 'B'\n    source_variable = 'B'\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n  [push]\n    type = MultiAppCopyTransfer\n    to_multi_app = sub_app\n    source_variable = 'A'\n    variable = 'A'\n    execute_on = 'INITIAL TIMESTEP_END'\n  []\n[]\n\n\nBest regards,\nnakkyu",
          "url": "https://github.com/idaholab/moose/discussions/21536",
          "updatedAt": "2022-07-10T05:44:56Z",
          "publishedAt": "2022-07-08T08:32:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think you may want to execute all the transfers and the multiapp on timestep_end.\nThe ordering goes like this then:\nmain app executes\ntransfer to subapp of B\nsubapp executes\ntransfer to main app of A\nthen repeats if you have fixed point coupling iterations turned on",
                  "url": "https://github.com/idaholab/moose/discussions/21536#discussioncomment-3110117",
                  "updatedAt": "2022-07-08T20:02:54Z",
                  "publishedAt": "2022-07-08T20:02:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "coskrrb2002"
                          },
                          "bodyText": "Thank you for your advice!\nBut I found I have an issue with the Terminator object.",
                          "url": "https://github.com/idaholab/moose/discussions/21536#discussioncomment-3114429",
                          "updatedAt": "2022-07-10T05:44:55Z",
                          "publishedAt": "2022-07-10T05:44:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Nonlinear solve did not converge in phase filed simulation",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nRecently I used GrainTracker to simulate grain growth, but I found that the calculation did not converge directly to Time Step 195. The useful information was extracted by outputting the interrupted information is Couldn't find a matching grain while working on variable index: 7 and Nonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0. Its feature is that Nonlinear solve did not converge is displayed without calculation directly after creating a new grain ID. How should this problem be solved please?\nFinally, the contents of the executioner and the output terminal that I set in the .i file are as follows,\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold'\n  petsc_options_value = 'hypre boomeramg 31 0.7'\n\n  l_max_its = 20 # Max number of linear iterations\n  l_tol = 1e-4 # Relative tolerance for linear solves\n  nl_max_its = 12 # Max number of nonlinear iterations\n  nl_abs_tol = 1e-8 #1e-11 # Relative tolerance for nonlinear solves\n  nl_rel_tol = 1e-10 # Absolute tolerance for nonlinear solves\n  dtmim = 1e-15\n  start_time = 0.0\n  end_time = ${my_end_time}\n  # num_steps = 3\n\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1.0\n    growth_factor = 1.2\n    cutback_factor = 0.8\n    optimal_iterations = 8\n  [../]\n  [./Adaptivity]\n    # Block that turns on mesh adaptivity. Note that mesh will never coarsen beyond initial mesh (before uniform refinement)\n    initial_adaptivity = ${my_num_initial_adaptivity} # Number of times mesh is adapted to initial condition\n    refine_fraction = 0.7 # Fraction of high error that will be refined\n    coarsen_fraction = 0.2 # Fraction of low error that will coarsened\n    max_h_level = ${my_num_adaptivity} # Max number of refinements used, starting from initial mesh (before uniform refinement)\n  [../]\n[]\n...\nTime Step 194, time = 310.643, dt = 1.40896\n\nGrain Tracker Status:\nGrains active index 0: 50 -> 50\nGrains active index 1: 60 -> 60\nGrains active index 2: 44 -> 44\nGrains active index 3: 47 -> 46--\nGrains active index 4: 38 -> 38\nGrains active index 5: 33 -> 32--\nGrains active index 6: 22 -> 22\nGrains active index 7: 16 -> 15--\nGrains active index 8: 17 -> 17\nGrains active index 9: 13 -> 13\nGrains active index 10: 18 -> 18\nGrains active index 11: 9 -> 9\nGrains active index 12: 12 -> 12\nGrains active index 13: 9 -> 9\nGrains active index 14: 12 -> 12\nGrains active index 15: 10 -> 10\n\nMarking Grain 846 as INACTIVE (variable index: 7)\nMarking Grain 453 as INACTIVE (variable index: 3)\nMarking Grain 707 as INACTIVE (variable index: 5)\nFinished inside of GrainTracker\n\n 0 Nonlinear |R| = 4.989953e+04\n 1 Nonlinear |R| = 9.701443e+03\n 2 Nonlinear |R| = 2.306064e+03\n 3 Nonlinear |R| = 3.248389e+02\n 4 Nonlinear |R| = 1.227843e+01\n 5 Nonlinear |R| = 2.200736e-02\n 6 Nonlinear |R| = 1.479065e-06\n  Finished Solving                                                                       [218.64 s] [   41 MB]\n Solve Converged!\nOutlier Variable Residual Norms:\n  gr1: 6.540621e-07\n  gr3: 6.823711e-07\n  gr5: 5.629546e-07\n  gr7: 7.498556e-07\n\nPostprocessor Values:\n+----------------+-------------------+----------------+----------------+----------------+----------------+\n| time           | avg_grain_volumes | dofs           | dt             | ngrains        | run_time       |\n+----------------+-------------------+----------------+----------------+----------------+----------------+\n:                :                   :                :                :                :                :\n|   2.909175e+02 |      4.142835e+06 |   1.764217e+07 |   1.408964e+00 |   4.270000e+02 |   5.617250e+04 |\n|   2.923264e+02 |      4.171643e+06 |   2.244227e+07 |   1.408964e+00 |   4.260000e+02 |   5.643598e+04 |\n|   2.937354e+02 |      4.181437e+06 |   1.693335e+07 |   1.408964e+00 |   4.260000e+02 |   5.664712e+04 |\n|   2.951444e+02 |      4.181266e+06 |   2.459606e+07 |   1.408964e+00 |   4.240000e+02 |   5.695084e+04 |\n|   2.965533e+02 |      4.220649e+06 |   2.331995e+07 |   1.408964e+00 |   4.240000e+02 |   5.721412e+04 |\n|   2.979623e+02 |      4.230544e+06 |   2.818122e+07 |   1.408964e+00 |   4.220000e+02 |   5.752029e+04 |\n|   2.993713e+02 |      4.240552e+06 |   1.961283e+07 |   1.408964e+00 |   4.180000e+02 |   5.779650e+04 |\n|   3.007802e+02 |      4.240566e+06 |   2.103417e+07 |   1.408964e+00 |   4.150000e+02 |   5.802086e+04 |\n|   3.021892e+02 |      4.270750e+06 |   1.967925e+07 |   1.408964e+00 |   4.110000e+02 |   5.824107e+04 |\n|   3.035981e+02 |      4.301435e+06 |   1.990094e+07 |   1.408964e+00 |   4.110000e+02 |   5.844750e+04 |\n|   3.050071e+02 |      4.322091e+06 |   2.152884e+07 |   1.408964e+00 |   4.100000e+02 |   5.873865e+04 |\n|   3.064161e+02 |      4.364004e+06 |   2.330024e+07 |   1.408964e+00 |   4.090000e+02 |   5.905024e+04 |\n|   3.078250e+02 |      4.385324e+06 |   1.979170e+07 |   1.408964e+00 |   4.070000e+02 |   5.930594e+04 |\n|   3.092340e+02 |      4.385290e+06 |   2.462248e+07 |   1.408964e+00 |   4.060000e+02 |   5.958971e+04 |\n|   3.106430e+02 |      4.417731e+06 |   2.470678e+07 |   1.408964e+00 |   4.050000e+02 |   5.982335e+04 |\n+----------------+-------------------+----------------+----------------+----------------+----------------+\n\n  Finished Adapting Mesh                                                                 [  8.24 s] [  -45 MB]\n\nTime Step 195, time = 312.052, dt = 1.40896\n\nGrain Tracker Status:\nGrains active index 0: 50 -> 50\nGrains active index 1: 60 -> 60\nGrains active index 2: 44 -> 44\nGrains active index 3: 46 -> 46\nGrains active index 4: 38 -> 38\nGrains active index 5: 32 -> 32\nGrains active index 6: 22 -> 22\nGrains active index 7: 15 -> 16++\nGrains active index 8: 17 -> 15--\nGrains active index 9: 13 -> 13\nGrains active index 10: 18 -> 18\nGrains active index 11: 9 -> 9\nGrains active index 12: 12 -> 12\nGrains active index 13: 9 -> 9\nGrains active index 14: 12 -> 12\nGrains active index 15: 10 -> 10\n\nNucleating Grain Detected  (variable index: 7)\nMarking Grain 921 as INACTIVE (variable index: 8)\nMarking Grain 947 as INACTIVE (variable index: 8)\n*****************************************************************************\nCouldn't find a matching grain while working on variable index: 7\nCreating new unique grain: 1125\nGrain ID: 1125\nGhosted Entities: 718474 718490 718496 718497 718500 718821 720098 720115 720204 720479 720517 720851 721240 721241 722700 722\n701 722712 722713 722716 722717 722812 722813 722940 722941 722944 722945 723724 723725 723756 723757 723844 723845 723872 723\n873 1036082 1036094 1036095 1036100 1036101 1036216 1036217 1036353 1036923 1036924 1037019 1037020 1037027 1037028 1037207 10\n37208 1037211 1037212 1038525 1039116 1039117 1041963 1041964 1041967 1041968 1042067 1042068 1042283 1042284 1042287 1042288 \nLocal Entities: \nHalo Entities: 718648 718649 718650 718651 718652 718653 718667 718668 718669 718670 718671 718672 718700 718701 718781 718783\n 718848 718890 718891 718900 718943 718981 718982 718983 719079 719080 719081 719122 719123 719124 720014 720015 720017 720038\n 720070 720071 720073 720074 720075 720076 720077 720082 720083 720084 720085 720090 720092 720093 720100 720519 720520 720521\n 720522 720523 720524 722784 722785 722786 722787 722848 722849 722850 722851 722852 722853 722854 722855 722900 722901 722927\n 722928 722929 722930 722931 722947 722996 722997 722998 723700 723701 723703 723710 723716 723717 723718 723719 1036170 10361\n72 1036245 1036249 1036260 1036262 1036263 1036264 1036265 1036266 1036280 1036291 1036292 1036294 1036305 1036307 1036314 103\n6316 1036343 1036344 1036345 1036353 1036354 1036358 1036359 1036360 1036361 1036362 1036456 1036509 1036532 1036534 1036653 1\n036654 1036655 1036656 1036677 1036678 1036679 1036680 1036685 1036687 1036717 1036718 1036719 1036720 1036721 1036722 1036723\n 1036724 1036735 1036736 1036773 1036782 1036790 1036792 1036867 1036868 1036869 1036870 1036871 1036872 1036873 1036874 10368\n77 1036879 1036880 1036881 1036882 1036901 1036902 1036903 1036904 1036905 1036907 1036908 1036909 1036910 1036911 1036925 103\n6926 1036927 1037240 1037244 1037245 1037246 1037247 1037330 1037366 1037477 1037479 1037509 1037510 1037511 1037512 1037513 1\n037514 1037515 1037516 1037537 1037538 1037540 1037573 1037574 1037575 1037576 1037582 1037584 1038118 1038119 1038121 1038125\n 1038202 1038204 1038246 1038247 1038248 1038249 1038250 1038251 1038252 1038253 1038269 1038270 1038271 1038272 1038281 10382\n82 1038283 1038284 1038293 1038294 1038295 1038296 1038305 1038306 1038307 1038308 1038313 1038315 1038316 1038317 1038320 103\n8322 1038323 1038326 1038330 1038382 1038390 1038391 1038392 1038393 1038401 1038403 1038404 1038409 1038411 1038422 1038424 1\n038426 1038428 1038433 1038434 1038435 1038436 1038438 1038440 1038450 1038451 1038452 1038453 1038482 1038483 1038484 1038485\n 1038510 1038511 1038512 1038513 1038576 1038578 1038579 1038612 1038614 1038651 1038963 1038967 1038969 1039041 1039126 10391\n27 1042209 1042211 1042213 1042215 1042219 1042220 1042222 1042223 1042224 1042705 1042709 1042711 1042713 1042715 1042770 104\n2772 1042773 1042775 1042777 1042779 1042826 1042828 1042829 1042831 \nPeriodic Node IDs: \nBBoxes:\nMax: (x,y,z)=( 23535.2,  5859.38,        0) Min: (x,y,z)=( 22578.1,  4828.12,        0)\nStatus:  MARKED\nOrig IDs (rank, index): (107, 3) (74, 9) \nVar_index: 7\nMin Entity ID: 718458\n*****************************************************************************\nFinished inside of GrainTracker\n\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nSolve failed, cutting timestep.\n\nTime Step 195, time = 311.77, dt = 1.12717\n\nGrain Tracker Status:\nGrains active index 0: 50 -> 50\nGrains active index 1: 60 -> 60\nGrains active index 2: 44 -> 44\nGrains active index 3: 46 -> 46\nGrains active index 4: 38 -> 38\nGrains active index 5: 32 -> 32\nGrains active index 6: 22 -> 22\nGrains active index 7: 16 -> 16\nGrains active index 8: 15 -> 15\nGrains active index 9: 13 -> 13\nGrains active index 10: 18 -> 18\nGrains active index 11: 9 -> 9\nGrains active index 12: 12 -> 12\nGrains active index 13: 9 -> 9\nGrains active index 14: 12 -> 12\nGrains active index 15: 10 -> 10\n\nFinished inside of GrainTracker\n\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nSolve failed, cutting timestep.\n\nTime Step 195, time = 311.545, dt = 0.901737\n...\nAny suggestions or recommendations to fix the problem would be greatly appreciated.\nThank you\nWei",
          "url": "https://github.com/idaholab/moose/discussions/21516",
          "updatedAt": "2022-07-09T12:53:22Z",
          "publishedAt": "2022-07-06T15:53:57Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf there is truly a NAN you can use the --trap-fpe command line option to track it down.\nThere is also a breakpoint you can set in the debugger. I think it's break libmesh_handle_FPE\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21516#discussioncomment-3094442",
                  "updatedAt": "2022-07-06T18:15:29Z",
                  "publishedAt": "2022-07-06T18:15:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thanks for your reply. @GiudGiud\n\nThere is also a breakpoint you can set in the debugger. I think it's break libmesh_handle_FPE\n\nYeah, I also tried to use the debug mode to find my bug, but due to the large size of this example, the debug mode loading mesh is very slow, so I still use the *-opt file to try to modify my code.\nNow I also found my problem, but don't know how to solve it.\nSpecifically, I tried to use the grain size information obtained by GrainDataVectorPostprocessor to determine the GB energy in the grain growth model, so I added such a piece of code to the class GNGsGrainGrowth based on GBAnisotropy,\n  auto grainEnergy = getVectorPostprocessorValueByName(\"grain_volumes\", \"gb_energy\"); // _fe_problem vector<Real>\n  unsigned int size_grainEnergy = grainEnergy.size();\n\n  // calculate the GB energy and mobility based on grain size\n\n  // if (*max_element(grainID.begin(), grainID.end()) < size_grainEnergy)\n  //   std::cout << \"done\" << std::endl;\n\n  if (grainEnergy.size() != 0  && *max_element(grainID.begin(), grainID.end()) < size_grainEnergy ) // not initial step and the max grain ID is less than the size of grainEnergy vector by Postprocessorvector\n  {\n    if (grainID.size() == 1) // inside the grain \n    {\n      std::vector<std::vector<Real>> inter_GBenergy(_op_num, std::vector<Real>(_op_num, grainEnergy[grainID[0]]));\n      _sigma =  inter_GBenergy;\n    }\n    if (grainID.size() > 1) // at GB boundary\n    {\n      for (unsigned int i = 0; i < grainID.size()-1; ++i)\n        for(unsigned int j = i+1; j < grainID.size(); ++j)\n        { \n          _sigma[variableIndex[i]][variableIndex[j]] = (grainEnergy[grainID[i]] + grainEnergy[grainID[j]])/2;      \n          _sigma[variableIndex[j]][variableIndex[i]] = _sigma[variableIndex[i]][variableIndex[j]];\n        }\n    }\n  }\nIf I comment out this code in GNGsGrainGrowth, use recover to run normally. And if I add it, I will report the non-convergence error mentioned above.\nSo I think the non-convergence is caused by the fact that the GrainTracker creates a new grain ID, considering that the new grain ID does not have an old value _feature_volumes_old after it is created.\nIn general, my question is how to better initialize the volume value of each grain or feature, if the GrainTracker creates a new grain ID during the calculation process, and ensure that before calling the material class GNGsGrainGrowth .\nAny suggestions or recommendations to fix the problem would be greatly appreciated.\nThank you\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/21516#discussioncomment-3105017",
                          "updatedAt": "2022-07-08T05:33:43Z",
                          "publishedAt": "2022-07-08T05:33:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYou may want to try the devel version then, it's intermediate between opt and dbg. METHOD=devel make to make it.\nso looking at this code, what jumps to my mind is: is the vector of the vector postprocessor containing information for the new grain or are we accessing it out of bounds?\nIf not you may need to rework this workflow to either fix the VPP output or not use a VPP\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21516#discussioncomment-3109746",
                          "updatedAt": "2022-07-08T18:28:26Z",
                          "publishedAt": "2022-07-08T18:28:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Oh, thank you so mech.  You ara right, this problem has been resolved by modifying GrainDataVectorPostprocessor. Specifically, the problem is that the GrainDataVectorPostprocessor cannot get the old value, when the  GrainTracker creates a Grain ID during the calculation process.\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/21516#discussioncomment-3112459",
                          "updatedAt": "2022-07-09T12:54:04Z",
                          "publishedAt": "2022-07-09T12:53:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to implement time dependent velocity field",
          "author": {
            "login": "brandon-barclay"
          },
          "bodyText": "Hello, I am trying to implement a time dependent velocity field for an outdoor airflow simulation and I was looking for some advice regarding the best way to go about this. I found .csv data which contains wind velocity at given x,y,z locations and t.\nThe only object I was able to find which appears to allow interpolation of data like this was the \" PiecewiseMulticonstant \" object, however it was not clear to me how to implement different function values at the different times. If anyone has any advice regarding this object, or a better way to interpolate the velocity data, it would be greatly appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/21542",
          "updatedAt": "2022-07-21T23:52:31Z",
          "publishedAt": "2022-07-08T20:46:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIs the time dependence fully separable from the space dependence? (eg is it v(x,t) = f(t) g(x) ) ?\nThis would make it easy.\nIf not:\nIs there an analytical equation for the data?\nthen you could use a parsed expression instead of a tabulation\nand if not:\nPiecewiseMultiConstant and PiecewiseMultiLinear are what you want to use. It is tabulated along X Y Z and T axis. There are example files in:\nhttps://github.com/idaholab/moose/tree/next/test/tests/functions/piecewise_multilinear\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21542#discussioncomment-3110506",
                  "updatedAt": "2022-07-08T21:59:47Z",
                  "publishedAt": "2022-07-08T21:59:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get the volume of mesh?",
          "author": {
            "login": "hhy2022"
          },
          "bodyText": "Hi,\nI am trying to output the volume information about the mesh I used. I found some useful example in https://mooseframework.inl.gov/source/auxkernels/VolumeAux.html.\nI run the example and got the result below:\nThis was the mesh of the problem:\n\nThis was the volume output of the problem:\n\nI am a little confused since I thought the output volume didn't match the real situation.\nI went to the source code and found the volume was calculated using return _bnd ? _current_side_volume : _current_elem_volume;. I thought it should calculate the volume of the mesh. I might misunderstood something and perhaps there were some problems with my output method. I am wondering if anyone can get me some suggestions on getting the volume of the mesh. I should use this value as a parameter in developing my own application.\nThank you so much for your help.",
          "url": "https://github.com/idaholab/moose/discussions/21506",
          "updatedAt": "2022-07-08T17:41:46Z",
          "publishedAt": "2022-07-05T18:02:26Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo you want the volume of the mesh, not each cell in the mesh?\nif so, you may use this postprocessor\nhttps://mooseframework.inl.gov/source/postprocessors/VolumePostprocessor.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3087047",
                  "updatedAt": "2022-07-05T18:12:12Z",
                  "publishedAt": "2022-07-05T18:12:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hhy2022"
                          },
                          "bodyText": "I want each cell volume. Sorry about the mistake.\nHuihua",
                          "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3087074",
                          "updatedAt": "2022-07-05T18:19:16Z",
                          "publishedAt": "2022-07-05T18:19:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "then VolumeAux is the way. Is the result wrong? What is the problem?",
                          "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3087384",
                          "updatedAt": "2022-07-05T19:24:25Z",
                          "publishedAt": "2022-07-05T19:24:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hhy2022"
                          },
                          "bodyText": "I thought the result should provide 20 volume values since there were 20 cells. But the output only showed 6 different color bars and the values didn't match the manually calculated ones.\nFor example, the left down corner cell should have a volume around 0.4875 based on the mesh information calculation (1.5/2*1.3/2=0.4875). However, the light blue (left down corner cell) showed a value around 0.4125.",
                          "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3087431",
                          "updatedAt": "2022-07-05T19:33:35Z",
                          "publishedAt": "2022-07-05T19:33:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah yes that is weird indeed!\nCould you please paste your input file syntax for the VolumeAux ?",
                          "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3087591",
                          "updatedAt": "2022-07-05T20:08:34Z",
                          "publishedAt": "2022-07-05T20:08:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hhy2022"
                          },
                          "bodyText": "Sure. Actually it was an example shown in the link https://mooseframework.inl.gov/source/auxkernels/VolumeAux.html.\nBelow is the detail:\n[Mesh]\n  [cmg]\n    type = CartesianMeshGenerator\n    dim = 2\n    dx = '1.5 2.4 0.1'\n    dy = '1.3 0.9'\n    ix = '2 1 1'\n    iy = '2 3'\n  []\n[]\n\n[AuxVariables/volume]\n  order = CONSTANT\n  family = MONOMIAL\n[]\n\n[AuxKernels/volume_aux]\n  type = VolumeAux\n  variable = volume\n[]\n\n[Problem]\n  solve = false\n[]\n\n[Executioner]\n  type = Steady\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3087615",
                          "updatedAt": "2022-07-05T20:16:22Z",
                          "publishedAt": "2022-07-05T20:16:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hhy2022"
                          },
                          "bodyText": "The total output showed 5 different color bars and that were correct since there were 5 different volumes for this problem. Sorry about the misunderstood before.\nThe only porblem now was the exact value of the volume seemed didn't match the manually calculated ones.",
                          "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3087896",
                          "updatedAt": "2022-07-05T21:17:21Z",
                          "publishedAt": "2022-07-05T21:17:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It matches on my machine?\nFor some of the areas for example, I get\n0.4875 in the bottom left, 1.56 in the bottom middle/right and 0.03 for the top right.\nnow analytically we should have:\n1.5/2 * 1.3/2 = 0.4875\n2.4/1 * 1.3/2 = 1.56\n0.1/1 * 0.9/3 = 0.03",
                          "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3088352",
                          "updatedAt": "2022-07-05T23:28:25Z",
                          "publishedAt": "2022-07-05T23:28:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hhy2022"
                          },
                          "bodyText": "Yes. But the color bar value showing that the bottom left should be 0.4125 while the calculated one was 0.4875. The green one from color bar was 0.795 while the calculated one should be 0.72.\nWait, is there any different with the color? like light green and dark green? I thought the color bar with values on side should be the indicating values of the volume. Can I use another output method to print out the real value instead of the color bar figure?",
                          "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3092487",
                          "updatedAt": "2022-07-06T13:20:54Z",
                          "publishedAt": "2022-07-06T13:20:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in paraview you may hover over the cells and get the values\nI dont know about peacock",
                          "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3093169",
                          "updatedAt": "2022-07-06T14:57:55Z",
                          "publishedAt": "2022-07-06T14:57:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hhy2022"
                          },
                          "bodyText": "So this VolumeAux can get the cell volume well. Right?\nBesides, I can use paraview, but I couldn't see the values when I hover the cells. Could you please tell me which version you used?",
                          "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3095167",
                          "updatedAt": "2022-07-06T20:28:54Z",
                          "publishedAt": "2022-07-06T20:28:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "You can also run mesh only mode (--mesh-only on command line) to get some output like this:\n<cut>\n\n  Mesh Subdomains:\n   Subdomain 0: 16 elems (QUAD4, 16 active), 25 active nodes\n    Volume: 1\n    Bounding box minimum: (x,y,z)=(       0,        0,        0)\n    Bounding box maximum: (x,y,z)=(       1,        1,        0)\n    Bounding box delta: (x,y,z)=(       1,        1,        0)\n   Global mesh volume = 1\n\nwhere it will show the volume of each subdomain and the total volume.",
                  "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3108310",
                  "updatedAt": "2022-07-08T14:23:04Z",
                  "publishedAt": "2022-07-08T14:23:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hhy2022"
                          },
                          "bodyText": "OK. Thank you so much for that information. I will have a try.",
                          "url": "https://github.com/idaholab/moose/discussions/21506#discussioncomment-3109488",
                          "updatedAt": "2022-07-08T17:41:46Z",
                          "publishedAt": "2022-07-08T17:41:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Solve not converging when called through surrogate trainer.",
          "author": {
            "login": "j-bowhay"
          },
          "bodyText": "Hi,\nI am exploring the functionality built into MOOSE for building surrogate models. I am playing around with a very simple example of a heat sink conducting into air. When I run the input file on its own the solver converges fine however when I then go to train my nearest point surrogate I am getting lots of errors about the solve failing to converge. I think this maybe because my sample is not being parsed through correct?\n\n radiator_steady.i \n\n[Mesh]\n  [file]\n    type = FileMeshGenerator\n    file = 'radiator_smaller.msh'\n  []\n[]\n\n[Variables]\n    [T]\n    []\n[]\n\n[ICs]\n  [radiator_ic]\n    type = ConstantIC\n    variable = T\n    value = 373.15\n    block = 'inner_surface'\n  []\n  [air_ic]\n    type = ConstantIC\n    variable = T\n    value = 283.15\n    block = 'outer_surface'\n  []\n[]\n\n[Kernels]\n  [hc]\n    type = ADHeatConduction\n    variable = T\n  []\n[]\n\n[Materials]\n    [radiator]\n        type = ADHeatConductionMaterial\n        thermal_conductivity = 386\n        specific_heat = 389\n        block = 'inner_surface'\n    []\n    [radiator_density]\n        type = ADGenericConstantMaterial\n        prop_names = 'density'\n        prop_values = 8960\n        block = 'inner_surface'\n    []\n    [air]\n        type = ADHeatConductionMaterial\n        thermal_conductivity = 0.025\n        specific_heat = 1000\n        block = 'outer_surface'\n    []\n    [air_density]\n        type = ADGenericConstantMaterial\n        prop_names = 'density'\n        prop_values = 1.2754\n        block = 'outer_surface'\n    []\n[]\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = false\n  []\n[]\n\n[Executioner]\n    automatic_scaling = true\n    line_search = 'default'\n    type = Steady\n    solve_type = 'NEWTON'\n    petsc_options_iname='-pc_type'\n    petsc_options_value='lu'\n[]\n\n[Postprocessors]\n  [T_avg]\n    type = AverageNodalVariableValue\n    variable = T\n  []\n[]\n\n[Outputs]\n[]\n\n\n\n nearest_point_training.i \n\n[StochasticTools]\n[]\n\n[Distributions]\n    [rad_k]\n        type = Uniform\n        lower_bound = 300\n        upper_bound = 500\n    []\n    [rad_h]\n        type = Uniform\n        lower_bound = 300\n        upper_bound = 500\n    []\n[]\n\n[Samplers]\n    [sample]\n        type = LatinHypercube\n        distributions = 'rad_k rad_h'\n        num_rows = 100\n        execute_on = PRE_MULTIAPP_SETUP\n    []\n[]\n\n[MultiApps]\n    [sub]\n      type = SamplerFullSolveMultiApp\n      input_files = radiator_steady.i\n      sampler = sample\n    []\n  []\n  \n  [Controls]\n    [cmdline]\n      type = MultiAppSamplerControl\n      multi_app = sub\n      sampler = sample\n      param_names = 'Materials/radiator/thermal_conductivity Materials/radiator/specific_heat'\n    []\n  []\n\n  [Transfers]\n    [data]\n      type = SamplerReporterTransfer\n      from_multi_app = sub\n      sampler = sample\n      stochastic_reporter = results\n      from_reporter = 'T_avg/value'\n    []\n  []\n  \n  [Reporters]\n    [results]\n      type = StochasticReporter\n      outputs = none\n    []\n  []\n\n  [Trainers]\n    [nearest_point_avg]\n      type = NearestPointTrainer\n      execute_on = timestep_end\n      sampler = sample\n      response = results/data:T_avg:value\n    []\n  []\n\n  [Outputs]\n    [out]\n      type = SurrogateTrainerOutput\n      trainers = 'nearest_point_avg'\n      execute_on = FINAL\n    []\n  []\n\n\nThanks in advance!",
          "url": "https://github.com/idaholab/moose/discussions/21538",
          "updatedAt": "2022-07-11T09:13:56Z",
          "publishedAt": "2022-07-08T14:31:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "Hi,\nYour inputs look fine to me. What exactly is the error you are getting? Is the radiator_steady.i solve not converging? One thing to try is to check if the solve converges with the bounds of your distributions. For instance, setting Materials/radiator/thermal_conductivity=500. This will tell you if your physics is having a difficult time converging.\nI'd be happy to try it out myself, but I will need the mesh file you have.\nZach",
                  "url": "https://github.com/idaholab/moose/discussions/21538#discussioncomment-3108507",
                  "updatedAt": "2022-07-08T14:54:01Z",
                  "publishedAt": "2022-07-08T14:54:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "j-bowhay"
                          },
                          "bodyText": "The errors I am getting:\n\nOutput\n\nFramework Information:\nMOOSE Version:           git commit 6921d94afc on 2022-06-23\nLibMesh Version:         \nPETSc Version:           3.16.5\nSLEPc Version:           3.16.2\nCurrent Time:            Fri Jul  8 16:38:42 2022\nExecutable Timestamp:    Fri Jul  8 11:46:15 2022\n\nParallelism:\n  Num Processors:          4\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          1\n  Spatial Dimension:       1\n  Nodes:                   \n    Total:                 2\n    Local:                 2\n    Min/Max/Avg:           0/2/0\n  Elems:                   \n    Total:                 1\n    Local:                 1\n    Min/Max/Avg:           0/1/0\n  Num Subdomains:          1\n  Num Partitions:          1\n  Partitioner:             metis\n\nExecution Information:\n  Executioner:             Steady\n  Solver Mode:             Preconditioned JFNK\n\nLEGACY MODES ENABLED:\n This application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate diffs due to zero values being stored, and these tests should be re-golded.\n\n      Finished Instantiating Sub-Apps                                                    [  3.20 s] [  127 MB]\nsub00: Parallelism:\nsub00:   Num Processors:          1\nsub00:   Num Threads:             1\nsub00: \nsub00: Mesh: \nsub00:   Parallel Type:           replicated\nsub00:   Mesh Dimension:          2\nsub00:   Spatial Dimension:       2\nsub00:   Nodes:                   2237\nsub00:   Elems:                   4312\nsub00:   Num Subdomains:          2\nsub00: \nsub00: Nonlinear System:\nsub00:   Num DOFs:                2237\nsub00:   Num Local DOFs:          2237\nsub00:   Variables:               \"T\" \nsub00:   Finite Element Types:    \"LAGRANGE\" \nsub00:   Approximation Orders:    \"FIRST\" \nsub00: \nsub00: Execution Information:\nsub00:   Executioner:             Steady\nsub00:   Solver Mode:             NEWTON\nsub00:   MOOSE Preconditioner:    SMP\nsub00: \nsub00: LEGACY MODES ENABLED:\nsub00:  This application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate diffs due to zero values being stored, and these tests should be re-golded.\nsub00: \n    Finished Initializing MultiApps                                                      [  5.68 s] [  142 MB]\n  Finished Performing Initial Setup                                                      [  5.69 s] [  142 MB]\nsub00: \nsub00: Postprocessor Values:\nsub00: +----------------+----------------+\nsub00: | time           | T_avg          |\nsub00: +----------------+----------------+\nsub00: |   0.000000e+00 |   0.000000e+00 |\nsub00: +----------------+----------------+\nsub00: \nsub00: \nsub00: Performing automatic scaling calculation\nsub00: \nsub00:  0 Nonlinear |R| = 5.902855e+02\nsub00:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub00:  Solve Did NOT Converge!\nsub00: Aborting as solve did not converge\nsub01: \nsub01: Postprocessor Values:\nsub01: +----------------+----------------+\nsub01: | time           | T_avg          |\nsub01: +----------------+----------------+\nsub01: |   0.000000e+00 |   0.000000e+00 |\nsub01: +----------------+----------------+\nsub01: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub01: \nsub01: Performing automatic scaling calculation\nsub01: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub01:  0 Nonlinear |R| = 5.902855e+02\nsub01:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub01:  Solve Did NOT Converge!\nsub01: Aborting as solve did not converge\nsub02: \nsub02: Postprocessor Values:\nsub02: +----------------+----------------+\nsub02: | time           | T_avg          |\nsub02: +----------------+----------------+\nsub02: |   0.000000e+00 |   0.000000e+00 |\nsub02: +----------------+----------------+\nsub02: \nsub02: \nsub02: Performing automatic scaling calculation\nsub02: \nsub02:  0 Nonlinear |R| = 5.902855e+02\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nsub02:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub02:  Solve Did NOT Converge!\nsub02: Aborting as solve did not converge\nsub03: \nsub03: Postprocessor Values:\nsub03: +----------------+----------------+\nsub03: | time           | T_avg          |\nsub03: +----------------+----------------+\nsub03: |   0.000000e+00 |   0.000000e+00 |\nsub03: +----------------+----------------+\nsub03: \nsub03: \nsub03: Performing automatic scaling calculation\nsub03: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub03:  0 Nonlinear |R| = 5.902855e+02\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub03:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub03:  Solve Did NOT Converge!\nsub03: Aborting as solve did not converge\nsub04: \nsub04: Postprocessor Values:\nsub04: +----------------+----------------+\nsub04: | time           | T_avg          |\nsub04: +----------------+----------------+\nsub04: |   0.000000e+00 |   0.000000e+00 |\nsub04: +----------------+----------------+\nsub04: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub04: \nsub04: Performing automatic scaling calculation\nsub04: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub04:  0 Nonlinear |R| = 5.902855e+02\nsub04:       0 Linear |R| = 5.902855e+02\n    Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nLinear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub04:  Solve Did NOT Converge!\nsub04: Aborting as solve did not converge\nsub05: \nsub05: Postprocessor Values:\nsub05: +----------------+----------------+\nsub05: | time           | T_avg          |\nsub05: +----------------+----------------+\nsub05: |   0.000000e+00 |   0.000000e+00 |\nsub05: +----------------+----------------+\nsub05: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub05: \nsub05: Performing automatic scaling calculation\nsub05: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub05:  0 Nonlinear |R| = 5.902855e+02\nsub05:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub05:  Solve Did NOT Converge!\nsub05: Aborting as solve did not converge\nsub06: \nsub06: Postprocessor Values:\nsub06: +----------------+----------------+\nsub06: | time           | T_avg          |\nsub06: +----------------+----------------+\nsub06: |   0.000000e+00 |   0.000000e+00 |\nsub06: +----------------+----------------+\nsub06: \nsub06: \nsub06: Performing automatic scaling calculation\nsub06: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub06:  0 Nonlinear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nsub06:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub06:  Solve Did NOT Converge!\nsub06: Aborting as solve did not converge\nsub07: \nsub07: Postprocessor Values:\nsub07: +----------------+----------------+\nsub07: | time           | T_avg          |\nsub07: +----------------+----------------+\nsub07: |   0.000000e+00 |   0.000000e+00 |\nsub07: +----------------+----------------+\nsub07: \nsub07: \nsub07: Performing automatic scaling calculation\nsub07: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub07:  0 Nonlinear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nsub07:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub07:  Solve Did NOT Converge!\nsub07: Aborting as solve did not converge\nsub08: \nsub08: Postprocessor Values:\nsub08: +----------------+----------------+\nsub08: | time           | T_avg          |\nsub08: +----------------+----------------+\nsub08: |   0.000000e+00 |   0.000000e+00 |\nsub08: +----------------+----------------+\nsub08: \nsub08: \nsub08: Performing automatic scaling calculation\nsub08: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub08:  0 Nonlinear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nsub08:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub08:  Solve Did NOT Converge!\nsub08: Aborting as solve did not converge\nsub09: \nsub09: Postprocessor Values:\nsub09: +----------------+----------------+\nsub09: | time           | T_avg          |\nsub09: +----------------+----------------+\nsub09: |   0.000000e+00 |   0.000000e+00 |\nsub09: +----------------+----------------+\nsub09: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub09: \nsub09: Performing automatic scaling calculation\nsub09: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub09:  0 Nonlinear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nsub09:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub09:  Solve Did NOT Converge!\nsub09: Aborting as solve did not converge\nsub10: \nsub10: Postprocessor Values:\nsub10: +----------------+----------------+\nsub10: | time           | T_avg          |\nsub10: +----------------+----------------+\nsub10: |   0.000000e+00 |   0.000000e+00 |\nsub10: +----------------+----------------+\nsub10: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub10: \nsub10: Performing automatic scaling calculation\nsub10: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub10:  0 Nonlinear |R| = 5.902855e+02\nsub10:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub10:  Solve Did NOT Converge!\nsub10: Aborting as solve did not converge\nsub11: \nsub11: Postprocessor Values:\nsub11: +----------------+----------------+\nsub11: | time           | T_avg          |\nsub11: +----------------+----------------+\nsub11: |   0.000000e+00 |   0.000000e+00 |\nsub11: +----------------+----------------+\nsub11: \nsub11: \nsub11: Performing automatic scaling calculation\nsub11: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub11:  0 Nonlinear |R| = 5.902855e+02\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub11:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub11:  Solve Did NOT Converge!\nsub11: Aborting as solve did not converge\nsub12: \nsub12: Postprocessor Values:\nsub12: +----------------+----------------+\nsub12: | time           | T_avg          |\nsub12: +----------------+----------------+\nsub12: |   0.000000e+00 |   0.000000e+00 |\nsub12: +----------------+----------------+\nsub12: \nsub12: \nsub12: Performing automatic scaling calculation\nsub12: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub12:  0 Nonlinear |R| = 5.902855e+02\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub12:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub12:  Solve Did NOT Converge!\nsub12: Aborting as solve did not converge\nsub13: \nsub13: Postprocessor Values:\nsub13: +----------------+----------------+\nsub13: | time           | T_avg          |\nsub13: +----------------+----------------+\nsub13: |   0.000000e+00 |   0.000000e+00 |\nsub13: +----------------+----------------+\nsub13: \nsub13: \nsub13: Performing automatic scaling calculation\nsub13: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub13:  0 Nonlinear |R| = 5.902855e+02\nsub13:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n\n    Taking Step\n      Taking Step  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub13:  Solve Did NOT Converge!\nsub13: Aborting as solve did not converge\nsub14: \nsub14: Postprocessor Values:\nsub14: +----------------+----------------+\nsub14: | time           | T_avg          |\nsub14: +----------------+----------------+\nsub14: |   0.000000e+00 |   0.000000e+00 |\nsub14: +----------------+----------------+\nsub14: \nsub14: \nsub14: Performing automatic scaling calculation\nsub14: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub14:  0 Nonlinear |R| = 5.902855e+02\nsub14:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub14:  Solve Did NOT Converge!\nsub14: Aborting as solve did not converge\nsub15: \nsub15: Postprocessor Values:\nsub15: +----------------+----------------+\nsub15: | time           | T_avg          |\nsub15: +----------------+----------------+\nsub15: |   0.000000e+00 |   0.000000e+00 |\nsub15: +----------------+----------------+\nsub15: \nsub15: \nsub15: Performing automatic scaling calculation\nsub15: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub15:  0 Nonlinear |R| = 5.902855e+02\nsub15:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub15:  Solve Did NOT Converge!\nsub15: Aborting as solve did not converge\nsub16: \nsub16: Postprocessor Values:\nsub16: +----------------+----------------+\nsub16: | time           | T_avg          |\nsub16: +----------------+----------------+\nsub16: |   0.000000e+00 |   0.000000e+00 |\nsub16: +----------------+----------------+\nsub16: \nsub16: \nsub16: Performing automatic scaling calculation\nsub16: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub16:  0 Nonlinear |R| = 5.902855e+02\nsub16:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub16:  Solve Did NOT Converge!\nsub16: Aborting as solve did not converge\nsub17: \nsub17: Postprocessor Values:\nsub17: +----------------+----------------+\nsub17: | time           | T_avg          |\nsub17: +----------------+----------------+\nsub17: |   0.000000e+00 |   0.000000e+00 |\nsub17: +----------------+----------------+\nsub17: \nsub17: \nsub17: Performing automatic scaling calculation\nsub17: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub17:  0 Nonlinear |R| = 5.902855e+02\nsub17:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub17:  Solve Did NOT Converge!\nsub17: Aborting as solve did not converge\nsub18: \nsub18: Postprocessor Values:\nsub18: +----------------+----------------+\nsub18: | time           | T_avg          |\nsub18: +----------------+----------------+\nsub18: |   0.000000e+00 |   0.000000e+00 |\nsub18: +----------------+----------------+\nsub18: \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nsub18: \nsub18: Performing automatic scaling calculation\nsub18: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub18:  0 Nonlinear |R| = 5.902855e+02\nsub18:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub18:  Solve Did NOT Converge!\nsub18: Aborting as solve did not converge\nsub19: \nsub19: Postprocessor Values:\nsub19: +----------------+----------------+\nsub19: | time           | T_avg          |\nsub19: +----------------+----------------+\nsub19: |   0.000000e+00 |   0.000000e+00 |\nsub19: +----------------+----------------+\nsub19: \nsub19: \nsub19: Performing automatic scaling calculation\nsub19: \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub19:  0 Nonlinear |R| = 5.902855e+02\nsub19:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub19:  Solve Did NOT Converge!\nsub19: Aborting as solve did not converge\nsub20: \nsub20: Postprocessor Values:\nsub20: +----------------+----------------+\nsub20: | time           | T_avg          |\nsub20: +----------------+----------------+\nsub20: |   0.000000e+00 |   0.000000e+00 |\nsub20: +----------------+----------------+\nsub20: \nsub20: \nsub20: Performing automatic scaling calculation\nsub20: \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nsub20:  0 Nonlinear |R| = 5.902855e+02\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub20:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub20:  Solve Did NOT Converge!\nsub20: Aborting as solve did not converge\nsub21: \nsub21: Postprocessor Values:\nsub21: +----------------+----------------+\nsub21: | time           | T_avg          |\nsub21: +----------------+----------------+\nsub21: |   0.000000e+00 |   0.000000e+00 |\nsub21: +----------------+----------------+\nsub21: \nsub21: \nsub21: Performing automatic scaling calculation\nsub21: \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub21:  0 Nonlinear |R| = 5.902855e+02\nsub21:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n.Nonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub21:  Solve Did NOT Converge!\nsub21: Aborting as solve did not converge\nsub22: \nsub22: Postprocessor Values:\nsub22: +----------------+----------------+\nsub22: | time           | T_avg          |\nsub22: +----------------+----------------+\nsub22: |   0.000000e+00 |   0.000000e+00 |\nsub22: +----------------+----------------+\nsub22: \nsub22: \nsub22: Performing automatic scaling calculation\nsub22: \nsub22:  0 Nonlinear |R| = 5.902855e+02\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nsub22:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub22:  Solve Did NOT Converge!\nsub22: Aborting as solve did not converge\nsub23: \nsub23: Postprocessor Values:\nsub23: +----------------+----------------+\nsub23: | time           | T_avg          |\nsub23: +----------------+----------------+\nsub23: |   0.000000e+00 |   0.000000e+00 |\nsub23: +----------------+----------------+\nsub23: \nsub23: \nsub23: Performing automatic scaling calculation\nsub23: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub23:  0 Nonlinear |R| = 5.902855e+02\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nsub23:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub23:  Solve Did NOT Converge!\nsub23: Aborting as solve did not converge\nsub24: \nsub24: Postprocessor Values:\nsub24: +----------------+----------------+\nsub24: | time           | T_avg          |\nsub24: +----------------+----------------+\nsub24: |   0.000000e+00 |   0.000000e+00 |\nsub24: +----------------+----------------+\nsub24: \nsub24: \nsub24: Performing automatic scaling calculation\nsub24: \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub24:  0 Nonlinear |R| = 5.902855e+02\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nsub24:       0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nsub24:  Solve Did NOT Converge!\nsub24: Aborting as solve did not converge\n                                                                       [ 17.66 s] [   10 MB]\n    Finished Taking Step                                                                 [ 17.66 s] [   10 MB]\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nAborting as solve did not converge\n  Finished Executing MultiApps                                                           [ 18.25 s] [   10 MB]\nFinished Executing                                                                       [ 24.07 s] [  156 MB]\n\n\nIve set radiator_steady.i to the corners of the parameter space and it still solves fine so I dont think the physics is the problem. Github wont let me upload my mesh as a .msh so have renamed it to .txt. Thanks! radiator_smaller.txt",
                          "url": "https://github.com/idaholab/moose/discussions/21538#discussioncomment-3108827",
                          "updatedAt": "2022-07-08T15:47:24Z",
                          "publishedAt": "2022-07-08T15:47:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zachmprince"
                          },
                          "bodyText": "I'm getting the same error just running radiator_steady.i on its own\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   2237\n  Elems:                   4312\n  Num Subdomains:          2\n\nNonlinear System:\n  Num DOFs:                2237\n  Num Local DOFs:          2237\n  Variables:               \"T\" \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nExecution Information:\n  Executioner:             Steady\n  Solver Mode:             NEWTON\n  MOOSE Preconditioner:    SMP\n\n\nPostprocessor Values:\n+----------------+----------------+\n| time           | T_avg          |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+\n\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 5.902855e+02\n      0 Linear |R| = 5.902855e+02\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge",
                          "url": "https://github.com/idaholab/moose/discussions/21538#discussioncomment-3109036",
                          "updatedAt": "2022-07-08T16:19:51Z",
                          "publishedAt": "2022-07-08T16:19:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zachmprince"
                          },
                          "bodyText": "One thing I notices is that there isn't any BCs or source term. Which would give a trivial solution in a Steady solve.",
                          "url": "https://github.com/idaholab/moose/discussions/21538#discussioncomment-3109047",
                          "updatedAt": "2022-07-08T16:21:38Z",
                          "publishedAt": "2022-07-08T16:21:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Thermal Hydraulics: FlowChannel1Phase Oreintated at an angle?",
          "author": {
            "login": "TheBEllis"
          },
          "bodyText": "Hi MOOSE team, I am currently trying to use the thermal hydraulics module to simplify some fluids problems. I was wondering if there is any way to use 1D flow channels (specifically FlowChannel1Phase) that are at an angle or incline, as shown in the piece of art I have attached. If I try and change the orientation vector I get a reminder that these components should be aligned with one of the axes. It may be that there is no way round this currently. If so, is there any chance it will be added in future? Many thanks for any help.\n\n)",
          "url": "https://github.com/idaholab/moose/discussions/21519",
          "updatedAt": "2022-07-12T09:38:14Z",
          "publishedAt": "2022-07-06T18:42:41Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@licharlot",
                  "url": "https://github.com/idaholab/moose/discussions/21519#discussioncomment-3094679",
                  "updatedAt": "2022-07-06T19:01:15Z",
                  "publishedAt": "2022-07-06T19:01:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "licharlot"
                          },
                          "bodyText": "There is no general restriction on the flow channels orientation. How are you connecting your pipes together?Are they coupled to a heat structure? Are you using any user objects like LayeredAverage?",
                          "url": "https://github.com/idaholab/moose/discussions/21519#discussioncomment-3103258",
                          "updatedAt": "2022-07-07T21:04:03Z",
                          "publishedAt": "2022-07-07T21:04:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheBEllis"
                          },
                          "bodyText": "Ahhh thank you! They are coupled to a heat structure, I've been using HeatStructureFromFile3D and HeatTransferFromHeatStructure3D1Phase. I can see the restriction is on this side of things, as mentioned in the HeatTransferFromHeatStructure3D1Phase syntax documentation. I assume one way around this could be to manually set the gravity vector to change the frame of reference, is there a simpler way around this that I should be aware of?",
                          "url": "https://github.com/idaholab/moose/discussions/21519#discussioncomment-3107563",
                          "updatedAt": "2022-07-08T12:29:53Z",
                          "publishedAt": "2022-07-08T12:29:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "licharlot"
                          },
                          "bodyText": "Yes there is that restriction for the 3D heat structure. I think adjusting the gravity vector for each flow channel is the best way at this point. You won't have that restriction if you use 2D heat structures (cylindrical or plate).",
                          "url": "https://github.com/idaholab/moose/discussions/21519#discussioncomment-3108826",
                          "updatedAt": "2022-07-08T15:47:06Z",
                          "publishedAt": "2022-07-08T15:47:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Axisymmetric model creation in 3D",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Dear all,\nAs part of my recent work concerning radiation damage models, i am interested in creating a 3D cylindrical pipe model (see below) that mainly simulate elasticity effects. The damage resulting from irradiation induced swelling is then captured through the thermal strains calculated from ComputeThermalExpansionEigenstrain.\n\nI am currently looking at a suitable 3D axisymmetric model from the repository that will form the basis for my model. As far as i checked most of them were reduced 2D models with coord_type set to RZ. I wonder how would this command look like if i want to use a 3D model. I am aware a 2D model would suffice for most of the cases, unless if one want to address problems relating to stress effects in the vicinity of the circumference e.g., torsion. My intention here is to compare with analytical results for which a 3D FE model would result in a better comparision.\nKind regards,\nArun",
          "url": "https://github.com/idaholab/moose/discussions/21366",
          "updatedAt": "2022-07-21T23:52:21Z",
          "publishedAt": "2022-06-21T12:26:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe currently do not have a mesh generator that will extrude a 2D RZ geometry to a 3D model.\nIs your geometry extruded in the axial direction? I see to see a bend at the top and at the bottom of this picture.\nYou can use free meshing software gmsh or cubit-learn to generate this mesh it does not seem too complicated.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-2994789",
                  "updatedAt": "2022-06-21T14:47:43Z",
                  "publishedAt": "2022-06-21T14:47:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Well, the issue is not about meshing, but how do we make use of this 3D mesh and run an axi-symmetric model. Below here is my mesh done in cubit and ready to go in to simulation. My concern here is what should be set to this parameter coord_type when we want to run this simulation with a cylindrical coordinate system and problem dimensionality as 3. Will RZ work even for this case?",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-2994905",
                          "updatedAt": "2022-06-21T15:01:59Z",
                          "publishedAt": "2022-06-21T15:01:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you have a 3D mesh then you should run XYZ coordinates.\nWe do not have RthetaZ in MOOSE, only RZ",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-2994938",
                          "updatedAt": "2022-06-21T15:06:07Z",
                          "publishedAt": "2022-06-21T15:06:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Yes that's fine. I have gases flowing inside the pipe and so wanted to apply gas pressure in the inner walls. I am wondering how to intertpret radial direction working from within the cartesian system.",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-2995806",
                          "updatedAt": "2022-06-21T16:57:37Z",
                          "publishedAt": "2022-06-21T16:57:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The radial direction is not treated any particular way in the cartesian solve.\nAre your kernels or your material properties dependent on r ?",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-2996633",
                          "updatedAt": "2022-06-21T19:18:40Z",
                          "publishedAt": "2022-06-21T19:18:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "As said earlier, my boundary condition for gas pressure depends on the radial direction R. If i work in cartesian system and choose one of the axes for applying this pressure BC, i will be applying in the wrong direction. Either i would need to choose cylindrical system, which for this 3D case is not possible or i may need to revert to a 2D model.",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-2999722",
                          "updatedAt": "2022-06-22T07:18:16Z",
                          "publishedAt": "2022-06-22T07:18:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You will have to apply the BC on both X and Y axis, with a projection based on the local angle.",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3003221",
                          "updatedAt": "2022-06-22T15:12:26Z",
                          "publishedAt": "2022-06-22T15:12:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "This seems a quite different way. How do one can calculate the local angle and where this would be accounted in the boundary conditions?",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3008759",
                          "updatedAt": "2022-06-23T09:16:25Z",
                          "publishedAt": "2022-06-23T09:16:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you may want to look at Pressure.C in the tensor mechanics module src/bcs folder. It uses the normal to compute the contribution of the external pressure to the residual on the bc",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3013700",
                          "updatedAt": "2022-06-23T21:50:12Z",
                          "publishedAt": "2022-06-23T21:50:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "At least for small deformations, I suppose you can use the local normal\nvector to resolve the normal pressure into x and y components (requires a\nlittle bit of coordinate transformation). You might have to write code for\nit.\n\u2026\nOn Thu, Jun 23, 2022 at 5:16 AM abarun22 ***@***.***> wrote:\n This seems a quite different way. How do one can calculate the local angle\n and where this would be accounted in the boundary conditions?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21366 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ACYC6LNWECNNWN6MLMMMQJDVQQTPNANCNFSM5ZME7ZEQ>\n .\n You are receiving this because you are subscribed to this thread.Message\n ID: ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3009545",
                  "updatedAt": "2022-06-23T11:08:12Z",
                  "publishedAt": "2022-06-23T11:08:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Thanks Srinath for the suggestion. The tricky thing here is the calculation of the local angle. I wanted to clarify what this angle is and how this can be interpreted from the perspective of a FE domain. Any ideas/suggestions here would help me to solve this issue and focus next on integrating these transformed corrdinates in to the pressure BC application module swiftly.",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3010594",
                          "updatedAt": "2022-06-23T13:49:28Z",
                          "publishedAt": "2022-06-23T13:49:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "You should not need the local angle, moose. Boundary normals should be\naccessible easily _normals[_qp]\n\u2026\nOn Thu, Jun 23, 2022, 9:49 AM abarun22 ***@***.***> wrote:\n Thanks Srinath for the suggestion. The tricky thing here is the\n calculation of the local angle. I wanted to clarify what this angle is and\n how this can be interpreted from the perspective of a FE domain. Any\n ideas/suggestions here would help me to solve this issue and focus next on\n integrating these transformed corrdinates in to the pressure BC application\n module swiftly.\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21366 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ACYC6LOBMVZNLMOTFLJ4HYDVQRTPHANCNFSM5ZME7ZEQ>\n .\n You are receiving this because you commented.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3010661",
                  "updatedAt": "2022-06-23T13:58:04Z",
                  "publishedAt": "2022-06-23T13:58:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "With the normals, i am wondering how to calculate the angle theta needed for coordinate conversion as stated here.\n\nYou might probably thinking about a different way to solve this problem",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3011061",
                          "updatedAt": "2022-06-23T14:47:41Z",
                          "publishedAt": "2022-06-23T14:47:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "You can do it your way and calculating the angle should be trivial right ?\nn.x = mag(n)*max(x)* cos(theta), where n is the normal vector and x is the\nunit x vector. I think the normals in moose are unit magnitude and so is\nthe unit vector in x. So the angle to x axis would simply be cos-1(x\ncomponent of the normal vector).\nIn a more general sense, with this procedure, you should be able to apply\nan arbitrary normal pressure on any arbitrary plane. The only tricky part\nmight be to add residuals to the individual components in moose, but you\ncan use an action to do this i think.\n\u2026\nOn Thu, Jun 23, 2022 at 10:47 AM abarun22 ***@***.***> wrote:\n With the normals, i am wondering how to calculate the angle theta needed\n for coordinate conversion as stated here.\n [image: image]\n <https://user-images.githubusercontent.com/40111479/175326744-8d6692e4-5d64-4107-8fa6-091c96e14fb4.png>\n You might probably thinking about a different way to solve this problem\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21366 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ACYC6LPZAC2XQ5A6CCGES6LVQR2JRANCNFSM5ZME7ZEQ>\n .\n You are receiving this because you commented.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3011190",
                  "updatedAt": "2022-06-23T15:04:11Z",
                  "publishedAt": "2022-06-23T15:04:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Thanks Srinath for the inputs. With this conversion based approach, theta eventually can be calculated as a inverse cosine of x component of the normal vector. I am now looking for a suitable template to start my developments. I would like to ask if its more relevant to copy the class Pressure that applies pressure on boundaries?",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3012576",
                          "updatedAt": "2022-06-23T18:13:24Z",
                          "publishedAt": "2022-06-23T18:13:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "I think you should look at pressure action and just modify the scaling\nfactors to the correct values. Just saying if pressure was a scalar then\np*n is the vector so the components of the vector give you the relevant\nvalues in each direction.\n\u2026\nOn Thu, Jun 23, 2022, 2:13 PM abarun22 ***@***.***> wrote:\n Thanks Srinath for the inputs. With this conversion based approach, theta\n eventually can be calculated as a inverse cosine of x component of the\n normal vector. I am now looking for a suitable template to start my\n developments. I would like to ask if its more relevant to copy the class\n Pressure that applies pressure on boundaries?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#21366 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ACYC6LLMG7FWMAJPW5NHDXLVQSSM5ANCNFSM5ZME7ZEQ>\n .\n You are receiving this because you commented.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3012660",
                  "updatedAt": "2022-06-23T18:26:55Z",
                  "publishedAt": "2022-06-23T18:26:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "I guess this has already been implemented in Pressure.C. Here is the computeQpResidual function from this file that will tell you how the pressure value is resolved in to component directions. I do not know what _test does in this case, but this block would for sure apply the pressure in the normal direction on any given surface, which is what we need and this should work correctly without going for actual conversion to cylindrical coordinate systems.\nReal\nPressure::computeQpResidual()\n{\n  return computeFactor() * (_normals[_qp](_component) * _test[_i][_qp]);\n}\n\nProbably you might want to say something like this:\n[BCs]\n  [./Pressure]\n    [./pbc]\n      boundary = 'inner'\n      factor= 50\n      displacements = 'disp_x disp_y'\n    [../]\n  [../]\n[]\n\nHere the x & y displacements are given just to specify that the first two resolved components of pressure are meant to be applied on to this boundary 'inner'. This is what i thought based on our earlier discussions, probably you could pour in your suggestions.\nKind regards,\nArun",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3019289",
                          "updatedAt": "2022-06-24T17:57:01Z",
                          "publishedAt": "2022-06-24T17:57:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "srinath-chakravarthy"
                          },
                          "bodyText": "Yes this is all you need would be my guess. This is a relatively new addition, since in the previous avatar of Pressure BC, we needed to specify a component, see ADPressure.C for the AD version of the old Pressure.C. I can see now it is deprecated and also very recently (in the last 2 days). So all you need to specify\u00a0is the pressure value for each of your x and y directions\u00a0and this should do the rest. The _test is necessary from the weak form of the bc. You can easily verify that the correct pressure is being applied by validating with the axisymmetric 2d model and a cross-section in your 3d model.\u00a0",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3019483",
                          "updatedAt": "2022-06-24T18:32:05Z",
                          "publishedAt": "2022-06-24T18:32:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Hi Srinath, FYI, the new pressure BC works fine with the results comparing ok with the equivalent analytical results. Thanks for the suggestions.",
                          "url": "https://github.com/idaholab/moose/discussions/21366#discussioncomment-3106502",
                          "updatedAt": "2022-07-08T09:31:14Z",
                          "publishedAt": "2022-07-08T09:31:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Free format Fortran UMAT",
          "author": {
            "login": "Flolaffel"
          },
          "bodyText": "Hello,\nwhen running make to compile my UMAT I get\nCan't open included file 'xxx.f90'\nDoes that mean that MOOSE does not support free format UMATs?",
          "url": "https://github.com/idaholab/moose/discussions/21476",
          "updatedAt": "2022-07-21T23:51:40Z",
          "publishedAt": "2022-07-01T06:08:46Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "not sure if it does\n@dschwen @recuero @ngrilli will know.\nIf it does and the problem is local we ll want to see the output of make -n",
                  "url": "https://github.com/idaholab/moose/discussions/21476#discussioncomment-3064297",
                  "updatedAt": "2022-07-01T13:36:35Z",
                  "publishedAt": "2022-07-01T13:36:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "@Flolaffel have you tried passing the compiler flag -ffree-form?",
                          "url": "https://github.com/idaholab/moose/discussions/21476#discussioncomment-3064793",
                          "updatedAt": "2022-07-01T14:40:41Z",
                          "publishedAt": "2022-07-01T14:40:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "I'm not sure, what you mean by using -ffree-form. To me it seems like that's not an available option when using the make command. What are you refering to?",
                          "url": "https://github.com/idaholab/moose/discussions/21476#discussioncomment-3078497",
                          "updatedAt": "2022-07-04T14:01:25Z",
                          "publishedAt": "2022-07-04T14:01:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can add additional compiling and linking flags by modifying the environment variables.\nYou may also modify the Makefile used to compile the UMAT",
                          "url": "https://github.com/idaholab/moose/discussions/21476#discussioncomment-3080820",
                          "updatedAt": "2022-07-05T00:00:35Z",
                          "publishedAt": "2022-07-05T00:00:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "FWIW it looks like there's a Makefile variable PLUGIN_FLAGS that you can set to influence how your UMAT gets compiled. I set this in my app's Makefile to change the line length etc. You can see what else goes into building UMAT plugins here.",
                          "url": "https://github.com/idaholab/moose/discussions/21476#discussioncomment-3104494",
                          "updatedAt": "2022-07-08T02:59:07Z",
                          "publishedAt": "2022-07-08T02:59:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Flolaffel"
                  },
                  "bodyText": "Update: I have to admit I don't have enough knowledge about UMATs, Fortran and compiler flags to solve this problem on my own. The UMAT I'm working with is written (not by me) in a mix of F77 and F90. From @jessecarterMOOSE's comment I saw that MOOSE provides options to compile F90. However in my case make always exited with an error when it came to compile the F90 part of the UMAT. So I went and asked my master thesis supervisor for help.\nHere is how he solved it: He used @GiudGiud's recommended make -n  command to get get the flags MOOSE uses for compiling. Then, following those commands, he wrote a script that creates the .plugin file you need for MOOSE externally. You can then simply copy that file into the MOOSE plugins folder and it seems to work just fine.",
                  "url": "https://github.com/idaholab/moose/discussions/21476#discussioncomment-3106183",
                  "updatedAt": "2022-07-08T08:50:02Z",
                  "publishedAt": "2022-07-08T08:50:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}