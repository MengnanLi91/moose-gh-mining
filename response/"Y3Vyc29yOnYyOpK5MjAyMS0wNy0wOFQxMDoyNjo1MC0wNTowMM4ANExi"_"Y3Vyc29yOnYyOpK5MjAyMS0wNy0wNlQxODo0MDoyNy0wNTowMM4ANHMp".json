{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNy0wNlQxODo0MDoyNy0wNTowMM4ANHMp"
    },
    "edges": [
      {
        "node": {
          "title": "Help with Update",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "Dear MOOSE Group,\nI am trying to update and got an error message as:\n% conda activate moose\n% conda update --all\nCollecting package metadata (current_repodata.json): failed\nCondaHTTPError: HTTP 000 CONNECTION FAILED for url https://conda.anaconda.org/idaholab/osx-64/current_repodata.json\nElapsed: -\nAn HTTP error occurred when trying to retrieve this URL.\nHTTP errors are often intermittent, and a simple retry will get you on your way.\n'https://conda.anaconda.org/idaholab/osx-64'\nPlease help.\nThomas",
          "url": "https://github.com/idaholab/moose/discussions/17918",
          "updatedAt": "2023-08-29T18:37:46Z",
          "publishedAt": "2021-05-24T21:16:51Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "As the error message states, these errors are intermittent. I am positive if you try again, it will work. Normally, you can try again immediately after seeing an error like this, and it will work.",
                  "url": "https://github.com/idaholab/moose/discussions/17918#discussioncomment-780971",
                  "updatedAt": "2023-08-29T18:37:46Z",
                  "publishedAt": "2021-05-25T12:56:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "It is still not working. If it is not intermittent, what would you recommend me to do?\nPlease let me know.\nThomas",
                          "url": "https://github.com/idaholab/moose/discussions/17918#discussioncomment-783350",
                          "updatedAt": "2023-08-29T18:37:46Z",
                          "publishedAt": "2021-05-25T21:17:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I wonder if Anaconda broke our stuff? The following URL does not work:\nhttps://conda.anaconda.org/idaholab/osx-64/current_repodata.json\nbut all the packages are available:\nhttps://conda.anaconda.org/idaholab/osx-64\nWe don't really have access to build the current_repodata.json file. Anaconda does this for you when you upload a package. Very strange. I'll look into it.",
                          "url": "https://github.com/idaholab/moose/discussions/17918#discussioncomment-783481",
                          "updatedAt": "2023-08-29T18:37:46Z",
                          "publishedAt": "2021-05-25T21:51:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rks171"
                          },
                          "bodyText": "I had this same issue and what worked for me was to disable ssl verirification by typing the following and then trying again.\nconda config --set ssl_verify False",
                          "url": "https://github.com/idaholab/moose/discussions/17918#discussioncomment-979417",
                          "updatedAt": "2023-08-29T18:37:46Z",
                          "publishedAt": "2021-07-08T13:01:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get the variable value in the former and next nodes?",
          "author": {
            "login": "YuhangNIU"
          },
          "bodyText": "Hi all,\nAs we all know, the current variable value can be described as u(i) = _u[_qp]. Could anyone kindly tell me how to get the variable value in the former and next nodes? I want to calculate the formula, just like:\nAu(i-1) + Bu(i+1)\nThank you!\nYuhang",
          "url": "https://github.com/idaholab/moose/discussions/18274",
          "updatedAt": "2023-04-25T22:33:22Z",
          "publishedAt": "2021-07-07T02:40:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "You'll have to be more precise about what you mean by \"former and next nodes\".   Do you mean the next node in the list of nodes of the particular element.  Or nodes in a neighbouring element.  Or something else?",
                  "url": "https://github.com/idaholab/moose/discussions/18274#discussioncomment-972935",
                  "updatedAt": "2023-04-25T22:33:22Z",
                  "publishedAt": "2021-07-07T04:10:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "YuhangNIU"
                          },
                          "bodyText": "If we use the 1D GeneratedMesh setting nx=100, there are 100 nodes in this mesh.\nSupposing the current variable value in the fifth node is described as u(i) = _u[_qp], \"the former\" represents variable value in the fourth node, and \"the next\" represents variable value in the sixth node.",
                          "url": "https://github.com/idaholab/moose/discussions/18274#discussioncomment-973380",
                          "updatedAt": "2023-04-25T22:33:22Z",
                          "publishedAt": "2021-07-07T07:09:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "What are you actually trying to do?  Form a spatial derivative?  MOOSE has that sort of functionality inbuilt.  Or are you doing some numerical stabilization involving values at lots of nodes?  That's more complicated, but has been done in MOOSE too, so we can help you.\nThe chances are that MOOSE has an elegant way of doing what you want.  BUT, if you just want all raw nodal values, you can use a NodalValueSampler VectorPostprocessor to record all the nodal values.",
                          "url": "https://github.com/idaholab/moose/discussions/18274#discussioncomment-973994",
                          "updatedAt": "2023-04-25T22:33:22Z",
                          "publishedAt": "2021-07-07T09:42:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YuhangNIU"
                          },
                          "bodyText": "Thanks for the help. I'll try to use the NodalValueSampler! Much appreciated.",
                          "url": "https://github.com/idaholab/moose/discussions/18274#discussioncomment-977208",
                          "updatedAt": "2023-04-25T22:34:03Z",
                          "publishedAt": "2021-07-08T01:36:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @YuhangNIU\nInside a kernel, you can access the value of the variable at the nodes using:\n_u_nodal(_var.dofValues()),\nthis is a vector that contains the nodal values. You can see an example code here:\nhttps://github.com/idaholab/moose/blob/next/framework/src/kernels/ConservativeAdvection.C\nBest Regards,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18274#discussioncomment-978854",
                          "updatedAt": "2023-04-25T22:34:03Z",
                          "publishedAt": "2021-07-08T10:26:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "What is the water-phase pressure P_w in the capillary pressure",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "(This message was posted on behalf of samuel171228 who posted the original question on the defunct google-groups.)\nHello all MOOSE user\nI'm using a porous flow module to make single-phase, unsaturated flow in porous media.\nTo calculate saturation and relative permeability.\nBut I have some problem with the definition of the capillary pressure\nI think When we calculate capillary pressure(P_c), the P_c is the difference between water-phase pressure and gas-phase pressure\n-> P_c = - P_w\n(because of single-phase & unsaturated flow)\nIn here, what is the P_w?\nIs it pore-pressure or not?\n(In my input file, the pore-pressure can be calculated as hydrostatic pressure)",
          "url": "https://github.com/idaholab/moose/discussions/17519",
          "updatedAt": "2022-07-26T13:15:06Z",
          "publishedAt": "2021-04-06T09:40:53Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Hi Samuel,\nWelcome to MOOSE and PorousFlow.  You are correct that P_c = -P_w, and that P_w is porepressure (in your single-phase case).  Note that if P_w >= 0 then the system is fully saturated (S_w = 1) and so P_c has no physical meaning (in your single-phase case).  When P_w < 0 then the system is unsaturated (S_w < 1) and P_c > 0, and P_c has a physical meaning.\na",
                  "url": "https://github.com/idaholab/moose/discussions/17519#discussioncomment-574039",
                  "updatedAt": "2022-07-26T13:16:25Z",
                  "publishedAt": "2021-04-06T09:44:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Without further input from Samuel, i'm marking this as \"answered\".",
                          "url": "https://github.com/idaholab/moose/discussions/17519#discussioncomment-582892",
                          "updatedAt": "2022-07-26T13:16:26Z",
                          "publishedAt": "2021-04-08T05:07:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "samuel171748"
                          },
                          "bodyText": "Oh Andy, Thank you for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/17519#discussioncomment-978269",
                          "updatedAt": "2022-07-26T13:17:35Z",
                          "publishedAt": "2021-07-08T08:07:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "problem to define a parameter",
          "author": {
            "login": "sSajjad90"
          },
          "bodyText": "Hi,\nI am working on a numerical code to develop the material solution and have to define many variables that read and write data. I have got a problem defining this kind of parameter that did not provide the proper results. Would you please let me what is wrong in defining the code?\nA simple part of code and the results are in the following:\nfor example, a simple parameter like \"_count\"  is defined  in a part of the code which must be started from \"0\" and growth with \"1\" for each iteration, but it provides the wrong data\nI defined a public class of material in the *.h file\n#pragma once\n#include \"Material.h\"\nclass last : public Material\n{\npublic:\nstatic InputParameters validParams();\nlast(const InputParameters & parameters);\nprotected:\nvirtual void computeQpProperties() override;\nvirtual void initQpStatefulProperties() override;\nMaterialProperty & _C_star;\nReal _count;\nthe relevant parts of *.C file :\n_count++;\n_C_star[_qp] = _count;\n\nResult:\n----------------+----------------+\n| time           | C_star         |\n+----------------+----------------\n|   5.000000e-01 |    2.305000e+02 |\n|   1.000000e+00 |   4.905000e+02 |\n|   1.500000e+00 |   7.505000e+02 |\n|   2.000000e+00 |   1.010500e+03 |\n|   2.500000e+00 |   1.270500e+03 |\n|   3.000000e+00 |   1.530500e+03 |\n|   3.500000e+00 |   1.790500e+03 |\n|   4.000000e+00 |   2.050500e+03 |\n|   4.500000e+00 |   2.310500e+03 |\n|   5.000000e+00 |   2.570500e+03 |\n|   5.500000e+00 |   2.830500e+03 |\n|   6.000000e+00 |   3.090500e+03 |\n|   6.500000e+00 |   3.350500e+03 |\n|   7.000000e+00 |   3.610500e+03 |\n|   7.500000e+00 |   3.870500e+03 |\nI suppose I have to add a \"GenericConstantMaterial\" class to define these types of variables. Could you let me know how can I do it in *.h and *.C files?\nThanks in advance,\nSajjad",
          "url": "https://github.com/idaholab/moose/discussions/17858",
          "updatedAt": "2023-02-16T22:48:32Z",
          "publishedAt": "2021-05-17T18:07:36Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Sajjad\nI think one problem is that those lines are executed more than once per time step. The material properties are evaluated many times, at initialization, at every non-linear iteration, for residuals, for jacobians etc.\nYou could add a check based on the current time step and the last time step _count was incremented. This would limit the number of times _count is incremented\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17858#discussioncomment-750364",
                  "updatedAt": "2023-03-07T23:57:06Z",
                  "publishedAt": "2021-05-17T23:20:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sSajjad90"
                          },
                          "bodyText": "Hi,\nMany thanks,\nWould you please let me know how can add the check based on the current time step and the last time step _count?\nI used the \"ElementAverageValue\" posts processor that may cause the problem. I checked the different types of executes but they did not work properly.\nAny suggestion?",
                          "url": "https://github.com/idaholab/moose/discussions/17858#discussioncomment-753484",
                          "updatedAt": "2023-03-07T23:57:06Z",
                          "publishedAt": "2021-05-18T15:16:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You could add a parameter like _current_timestep and have an if condition :\nif (_t != _current_timestep)\n{\n  // do the increment\n  \n  _current_timestep = _t;\n}\n\nIs _C_star going to be constant across the domain?\nIf not you ll need _current_timestep to be a field not just a single value",
                          "url": "https://github.com/idaholab/moose/discussions/17858#discussioncomment-753523",
                          "updatedAt": "2023-03-08T18:42:11Z",
                          "publishedAt": "2021-05-18T15:22:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sSajjad90"
                          },
                          "bodyText": "Dear Guillaume,\nwould you please add the command you already told me to the below code? I have got stock to control the number of iteration. In the following, there is a very simple code test just to evaluate _count++ and you could see *.C, *.h and the *.i files.\ntest.h file:\n#pragma once\n\n#include \"Material.h\"\n\n/**\n *\n */\nclass test : public Material\n{\npublic:\n  static InputParameters validParams();\n\n  test(const InputParameters & parameters);\n\nprotected:\n  // virtual void initQpStatefulProperties() override;\n  void computeQpProperties();\n\n\n  int _count;\n  MaterialProperty<Real> & _C_star;\n\n};\n\n\ntest.C file:\n#include \"test.h\"\n\nregisterMooseObject(\"precipitationApp\", test);\n\nInputParameters\ntest::validParams()\n{\n  InputParameters params = Material::validParams();\n  params.addRequiredParam<std::string>(\"f_name_Cstar\", \"name of the ac function.\");\n\n  return params;\n}\n\ntest::test(const InputParameters & parameters)\n  : Material(parameters),\n  _C_star(declareProperty<Real>(getParam<std::string>(\"f_name_Cstar\"))),\n  _count(0)\n{\n}\n// void\n// test::initQpStatefulProperties()\n// {\n//\n// }\nvoid\ntest::computeQpProperties()\n{\n  _count++;\n  _C_star[_qp]= _count;\n}\n\n\ntest.i file:\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  xmin = 0\n  xmax = 1\n  nx = 10\n[]\n[Problem]\n  kernel_coverage_check = false\n  solve = false\n[]\n\n[AuxVariables]\n  [./prop1]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n[AuxKernels]\n  [./prop1_output]\n    type = MaterialRealAux\n    variable = prop1\n    property = C_star\n    execute_on = 'TIMESTEP_END'\n  [../]\n[]\n[Materials]\n  [./MixedModeFiniteSystem]\n    type = test\n    f_name_Cstar = 'C_star'\n    f_name_2Cstar = 'C_2star'\n  [../]\n[]\n[Postprocessors]\n  [./C_star]\n    type = ElementAverageValue\n    variable = prop1\n    execute_on = 'TIMESTEP_END'\n  [../]\n  [./C_star2]\n    type = ElementAverageMaterialProperty\n    mat_prop = 'C_star'\n    execute_on = 'TIMESTEP_END'\n  [../]\n\n\n[]\n[Executioner]\n  type = Transient\n  solve_type = PJFNK\n  start_time = 0\n  end_time = 5\n  dt = 1\n\n[]\n\n[Outputs]\nexodus = true\ncsv = true\n[]\n\n\ntest.zip",
                          "url": "https://github.com/idaholab/moose/discussions/17858#discussioncomment-755833",
                          "updatedAt": "2023-03-08T18:41:56Z",
                          "publishedAt": "2021-05-19T02:02:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Closing this. Hope you managed to implement the pseudo code yourself",
                          "url": "https://github.com/idaholab/moose/discussions/17858#discussioncomment-977127",
                          "updatedAt": "2023-03-08T18:42:03Z",
                          "publishedAt": "2021-07-08T00:45:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Apply boundary conditions to different parts of stitched mesh",
          "author": {
            "login": "pratyushpotu"
          },
          "bodyText": "Hi, I am trying to apply boundary conditions to certain boundaries on a mesh comprised of three boxes stitched together horizontally (left, middle, and right). In particular, I'm trying to assign an id to the top part of the left box for instance, but whenever I try applying a boundary condition it applies to the top of the whole mesh instead of just one component. Thus, I was wondering how to apply boundary conditions to different boundaries like the top part of the left box and the bottom part of the right box.",
          "url": "https://github.com/idaholab/moose/discussions/18282",
          "updatedAt": "2022-08-16T02:09:44Z",
          "publishedAt": "2021-07-07T21:09:49Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou could try to use\nhttps://mooseframework.inl.gov/source/meshgenerators/BreakBoundaryOnSubdomainGenerator.html\nOR\nhttps://mooseframework.inl.gov/source/meshgenerators/BoundingBoxNodeSetGenerator.html\nThe first will require the boxes to be different blocks. The last one will require you to be a little mindful of floating point evaluations for the node at the corner of two stitched boxes\nto split up the top sideset in multiple parts.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-976701",
                  "updatedAt": "2022-08-16T02:09:44Z",
                  "publishedAt": "2021-07-07T21:22:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "pratyushpotu"
                          },
                          "bodyText": "Hi,\nThanks for your help. I was able to produce the boundaries I wanted, but the meshgenerator system needs a single end point, so when trying to apply boundary conditions to the boundaries, I can only apply a boundary condition to one produced boundary. If I try to apply another boundary condition to a boundary that is not the final generator, I get that the node set id does not exist. How would I go about adding the node set id to a boundary without specifying it to be the final generator?\nThanks,\nPratyush",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-976961",
                          "updatedAt": "2022-08-16T02:09:45Z",
                          "publishedAt": "2021-07-07T23:08:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nI m not sure I understand the problem. Could you please paste the meshgenerators you are using here?\nYou should make a linear chain of mesh generators, if that helps\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-977010",
                          "updatedAt": "2022-08-16T02:10:15Z",
                          "publishedAt": "2021-07-07T23:38:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh you are saying the boundaries created by the middle mesh generators are overwritten by the final ones?\nSo if you add show_info = true to the last mesh generator or if you open the resulting mesh in paraview, you should be able to see the final names of the boundaries after all the generation. You can then use the final names in your boundary conditions",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-977013",
                          "updatedAt": "2022-08-16T02:10:16Z",
                          "publishedAt": "2021-07-07T23:40:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pratyushpotu"
                          },
                          "bodyText": "Here are the mesh generators I am using\n[Mesh]\n  [./generated_mesh]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    xmax = 10\n    ymin = 0\n    ymax = 1\n    nx = 100\n    ny = 10\n  [../]\n  [./nodes1]\n    type = BoundingBoxNodeSetGenerator\n    new_boundary = 'AB'\n    input = 'generated_mesh'\n    top_right = '2 1 0'\n    bottom_left = '2 0 0'\n  [../]\n  [./nodes2]\n    type = BoundingBoxNodeSetGenerator\n    new_boundary = 'BC'\n    input = 'generated_mesh'\n    top_right = '8 1 0'\n    bottom_left = '8 0 0'\n  [../]\n  final_generator = nodes1\n  show_info = true\n[]\n\nAnd here are the boundary conditions:\n[BCs]\n  [AB_temperature]\n    type = DirichletBC\n    boundary = 'AB'\n    variable = temperature\n    value = 500\n  []\n    [BC_temperature]\n    type = DirichletBC\n    boundary = 'BC'\n    variable = temperature\n    value = 500\n  []\n[]\n\nBox A is from x = 0 to x = 2, Box B is from x=2 to x=8, and Box C is from x=8 to x=10. Because I have my final_generator set to nodes1, the AB boundary condition works, but the BC boundary condition does not work. I want to have more boundaries later such as the top of box A and the bottom of box C, but for now I am testing with the interfaces between the three boxes. Therefore, I am wondering how to apply boundary conditions to multiple node sets that are not the default top, bottom etc... . Thanks for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-977044",
                          "updatedAt": "2022-08-16T02:10:31Z",
                          "publishedAt": "2021-07-07T23:54:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok the problem is that the input of nodes2 needs to be nodes1 not generated_mesh. Otherwise, there are two final meshes and the simulation does not know which one to use.\nor as you did, you selected one as the final generator, and the other one got ignored, so that does not work for you",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-977084",
                          "updatedAt": "2022-08-16T02:11:01Z",
                          "publishedAt": "2021-07-08T00:18:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "pratyushpotu"
                          },
                          "bodyText": "Oh I see, I thought the input was what part of the mesh the node set was a part of, but its actually just how the mesh generator chains from each generator. Changing the input got me exactly what I needed. Thanks so much for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/18282#discussioncomment-977096",
                          "updatedAt": "2022-08-16T02:11:01Z",
                          "publishedAt": "2021-07-08T00:25:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Setting ADVectorVariableValues from individual coupled variable components",
          "author": {
            "login": "rtaylo45"
          },
          "bodyText": "Hello,\nI have a coupled 1D  Thermal hydraulics MOOSE app that solves for, among other things, velocity. I would like to use this code in MultiApps to transfer its velocity to my MOOSE app and use this velocity to transport material. But this code returns velocity as a scalar and not a vector. I have written an advection kernel shown below with the header file:\nclass MoleAdvection : public ADKernelValue\n{\npublic:\n  static InputParameters validParams();\n  MoleAdvection(const InputParameters & parameters);\n  virtual ~MoleAdvection();\n\nprotected:\n  virtual ADReal precomputeQpResidual() override;\n\n  // x velocity\n  const ADVariableValue & _x_velocity;\n  // y velocity\n  const ADVariableValue & _y_velocity;\n  // z velocity\n  const ADVariableValue & _z_velocity;\n  // Velocity vector\n  const ADVectorVariableValue & _vector_velocity;\n};\n\nand the C file\n#include \"MoleAdvection.h\"\n\nregisterADMooseObject(\"moleApp\", MoleAdvection);\n\nInputParameters\nMoleAdvection::validParams()\n{\n  InputParameters params = ADKernelValue::validParams();\n  params.addClassDescription(\"Applies non-conservative advection\");\n  params.addCoupledVar(\"x_velocity\", 0., \"Coupled x velocity\");\n  params.addCoupledVar(\"y_velocity\", 0., \"Coupled y velocity\");\n  params.addCoupledVar(\"z_velocity\", 0., \"Coupled z velocity\");\n  params.addCoupledVar(\"vector_velocity\", {0., 0., 0.}, \"Coupled vector velocity\");\n  return params;\n}\n\nMoleAdvection::MoleAdvection(const InputParameters & parameters)\n  : ADKernelValue(parameters),\n  _x_velocity(adCoupledValue(\"x_velocity\")),\n  _y_velocity(adCoupledValue(\"y_velocity\")),\n  _z_velocity(adCoupledValue(\"z_velocity\")),\n  _vector_velocity(adCoupledVectorValue(\"vector_velocity\"))\n{\n}\n\nMoleAdvection::~MoleAdvection() {}\n\nADReal\nMoleAdvection::precomputeQpResidual()\n{\n  if (_vector_velocity[_qp].norm() < 1.e-8)\n  {\n    ADVectorVariableValue _velocity = {_x_velocity, _y_velocity, _z_velocity};\n    return _velocity[_qp] * _grad_u[_qp];\n  }\n  else\n  {\n    return _vector_velocity[_qp] * _grad_u[_qp];\n  }\n}\n\nWhich does not compile. I have looked at the Doxygen for MOOSE and libMesh to try to figure out how to create a way to create a velocity vector from x_velocity, y_velocity and z_velocity. But i have come up short with trying to figure out how to do it. I would like the kernel to be able to use either a coupled velocity already in vector form (see variable _vector_velocity ) or create a velocity vector from the individual components. I am having trouble coming up with a way to do this and could use some help.",
          "url": "https://github.com/idaholab/moose/discussions/18278",
          "updatedAt": "2022-10-18T18:36:29Z",
          "publishedAt": "2021-07-07T18:07:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nTo create a velocity vector from individual components, you can use:\nADRealVectorValue V = {_x_velocity[_qp], _y_velocity[_qp], _w_velocity[_qp]};\nI dont think you need to instantiate the destructor btw.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18278#discussioncomment-976171",
                  "updatedAt": "2022-10-18T18:36:30Z",
                  "publishedAt": "2021-07-07T18:24:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "I kept having <brace-enclosed initializer list> error but this worked:\nADRealVectorValue V;\nV =  {_x_velocity[_qp], _y_velocity[_qp], _w_velocity[_qp]};",
                          "url": "https://github.com/idaholab/moose/discussions/18278#discussioncomment-976196",
                          "updatedAt": "2022-10-18T18:36:30Z",
                          "publishedAt": "2021-07-07T18:33:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "Actually i need to do this for it to converge.\n    ADRealVectorValue _velocity(_x_velocity[_qp], _y_velocity[_qp], _z_velocity[_qp]);\n    return _velocity * _grad_u[_qp];",
                          "url": "https://github.com/idaholab/moose/discussions/18278#discussioncomment-976397",
                          "updatedAt": "2022-10-18T18:36:30Z",
                          "publishedAt": "2021-07-07T19:26:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Setting required coupled variables through actions.",
          "author": {
            "login": "leanderVS"
          },
          "bodyText": "Hi everyone\nAn issue/question concerning the KKSMultiACBulkF kernel.\nWithin this kernel, the variable that the kernel operates on has to be provided through the usual \u2018variable = \u2026\u2019. The kernel also requires the user to specify a coupled variable \u2018eta_i = \u2026\u2019 which defines the order parameter that derivatives are taken with respect to. However, within my (limited) experience, both of these variables are always the same, which makes the introduction of eta_i kind of redundant. Is there a reason the kernel does not simply use \"variable\" to define the derivatives?\nOf more importance to my own research is the actual definition of eta_i as a coupled variable. I modified the KKSMultiACBulkF kernel to generate a bulk free energy expression Sum_j[h(eta_j)F_j]. The F_j\u2019s are constant (but different) at the moment, while the h(eta_j) were defined through SwitchingFunctionMultiPhaseMaterial.\nI am modelling an electrolyte in contact with a polycrystalline metal sample, which requires multiple of these adapted kernels to be called (each grain was assigned a different order parameter). When introduced manually into the inputfile, these give the expected results. However, altering the number of grains also requires quite some adaptations to the inputfile to introduce the correct bulk free energy expression as discussed above. To simply this, I tried to write an action. Whereas \u201cvariable\u201d can easily be set through for example:\nparams.set(\"variable\") = var_name;\nThe issue here is that I have not found a way to add/set the InputParameter object of the coupledVariable eta_j within that action since the coupledVar eta_j does not have the same definition within MOOSE as a simple NonlinearVariableName. CoupledVariableName and quite some other constructions I tried did not work unfortunately.\nI guess there are two options:\nEither I have to rewrite KKSMultiACBulkF to avoid the use of eta_j entirely or I need a way to set eta_j through an action. Preferably the latter if anyone has a solution.\nHope I formulated this clearly, any help would be appreciated, thanks!\nKind regards\nLeander",
          "url": "https://github.com/idaholab/moose/discussions/18110",
          "updatedAt": "2022-06-29T07:38:12Z",
          "publishedAt": "2021-06-17T13:41:56Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dschwen @laagesen @amjokisaari if any of you could please answer this phase field question",
                  "url": "https://github.com/idaholab/moose/discussions/18110#discussioncomment-899038",
                  "updatedAt": "2022-10-13T17:04:37Z",
                  "publishedAt": "2021-06-21T16:37:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "The variables are not always the same. This Kernel appears on the equation for the lagrange multiplier that enforces the sum of all switching functions to be 1 in the case of many (>2) phases.",
                  "url": "https://github.com/idaholab/moose/discussions/18110#discussioncomment-940295",
                  "updatedAt": "2022-10-13T17:04:46Z",
                  "publishedAt": "2021-06-29T20:58:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "As for\n\nThe issue here is that I have not found a way to add/set the InputParameter object of the coupledVariable eta_j within that action since the coupledVar eta_j does not have the same definition within MOOSE as a simple NonlinearVariableName. CoupledVariableName and quite some other constructions I tried did not work unfortunately\n\ntry params.set<std::vector<VariableName>>(\"variable\") = {var_name};\nA coupled variable can be an AuxVariable or a non linear Variable (hence the general VariableName rather than NonlinearVariableName (which you forgot in your example) or AuxVariableName), and MOOSE allows you to couple an arbitrary number of variables for each parameter (hence the std::vector).",
                          "url": "https://github.com/idaholab/moose/discussions/18110#discussioncomment-940315",
                          "updatedAt": "2022-10-13T17:04:54Z",
                          "publishedAt": "2021-06-29T21:01:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "See here for an example of both uses:\n\n  \n    \n      moose/modules/phase_field/src/action/ConservedAction.C\n    \n    \n        Lines 173 to 174\n      in\n      06bc1f7\n    \n  \n  \n    \n\n        \n          \n           params.set<NonlinearVariableName>(\"variable\") = _chempot_name; \n        \n\n        \n          \n           params.set<std::vector<VariableName>>(\"v\") = {_var_name};",
                          "url": "https://github.com/idaholab/moose/discussions/18110#discussioncomment-940335",
                          "updatedAt": "2022-10-13T17:04:55Z",
                          "publishedAt": "2021-06-29T21:03:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "leanderVS"
                          },
                          "bodyText": "@dschwen , thank you for your reply!\nI already had a look at ConservedAction.C but must have missed that particular part, thanks for pointing this out. The code now perfectly compiles and the simulation even converges, but it appears that it somehow still ignores the extra kernel I tried to add.\nThis is now the addition I made to PolycrystalKernelAction (now called CorrosionPolycrystalKernelAction for my purposes) to implement the bulk free energy terms (using the kernel CorrosionFb_I) (since I believe that in my case both variable and eta_i should refer to the same variable that the kernel operates on.\n{\n  InputParameters params = _factory.getValidParams(\"CorrosionFb_I\");\n  params.set<NonlinearVariableName>(\"variable\") = var_name;\n  params.set<std::vector<VariableName>>(\"args\") = v;\n\n  params.set<std::vector<VariableName>>(\"eta_i\") = {var_name};\n\n  params.set<std::vector<MaterialPropertyName>>(\"Fj_names\") = _Fj_names;\n  params.set<std::vector<MaterialPropertyName>>(\"hj_names\") = _hj_names;\n  params.applyParameters(parameters());\n\n  std::string kernel_name = \"CorrosionFb_I_\" + var_name;\n  _problem->addKernel(\"CorrosionFb_I\", kernel_name, params);\n}\n\nIn addition, the typical\nparams.addParam<std::vector>(\"Fj_names\",\"...\")\nparams.addParam<std::vector>(\"hj_names\",\"...\")\nwere added to the validParams() function of the action. Otherwise I think nothing changed for this action (apart from the declaration of Fj_names and hj_names in the .h file).\nThe action is then called in the Inputfile using:\n[Kernels]\n[./CorrosionPolycrystalKernel]\n// All different grain orientations have the same constant bulk free energy, the electrolyte (eta9) has a lower bulk free energy\nop_num = 10  \nvar_name_base = eta \nFj_names = 'F_metal   F_metal   F_metal   F_metal   F_metal   F_metal   F_metal   F_metal   F_metal   F_elec'\nhj_names = 'h_metal_0 h_metal_1 h_metal_2 h_metal_3 h_metal_4 h_metal_5 h_metal_6 h_metal_7 h_metal_8 h_elec'\n\n[../]\n[]\nThis implementation, however, appears to ignore the addition of the extra kernel. It thus gives the same results as if I wouldn't have implemented the extra kernel (although I did not overlap the two simulations to compare them one-to-one).\nAs mentioned, the kernel does work on its own, when it is introduced as such:\n`\n[Kernels]\n[./PolycrystalKernel]\nop_num = 10  \nvar_name_base = eta  \n\n[../]\n//Kernels for bulk free energy introduction\n[./F_bulk_metal_0]\ntype = CorrosionFb_I\nFj_names = 'f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_elec'\neta_i = 'eta0'\nhj_names = 'h_metal_0 h_metal_1 h_metal_2 h_metal_3 h_metal_4 h_metal_5 h_metal_6 h_metal_7 h_metal_8 h_elec'\nvariable = eta0\nargs = 'eta1 eta2 eta3 eta4 eta5 eta6 eta7 eta8 eta9'\n\n[]\n[./F_bulk_metal_1]\n//Notice that all the metallic grain have the same constant free energy contribution.\ntype = CorrosionFb_I\nFj_names = 'f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_metal f_elec'\neta_i = 'eta1'\nhj_names = 'h_metal_0 h_metal_1 h_metal_2 h_metal_3 h_metal_4 h_metal_5 h_metal_6 h_metal_7 h_metal_8 h_elec'\nvariable = eta1\nargs = 'eta0 eta2 eta3 eta4 eta5 eta6 eta7 eta8 eta9'\n\n[]\n//and a lot more of the same stuff for all the other order parameters.\n[]\n`\nI suppose the issue still lies in the action, but since the eta_i seems to be fine thanks to your fix, I ran out of ideas of where the issue could be.\nBest regards\nLeander",
                          "url": "https://github.com/idaholab/moose/discussions/18110#discussioncomment-974394",
                          "updatedAt": "2022-10-13T17:04:56Z",
                          "publishedAt": "2021-07-07T11:23:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow sinks",
          "author": {
            "login": "MatiasAllay"
          },
          "bodyText": "I'm sorry for bringing another simple question...\nI'm modeling Theis problem but instead of PorousFlowSquarePulsePointSource I would like to use PorousFlowSink. However, for some reason nothing happens:\n[Mesh]\ntype = GeneratedMesh\ndim = 2\nnx = 20\nny = 1\nymax = 1\nxmax = 100\nbias_x = 1.05\n[]\n[Problem]\ncoord_type = RZ\n[]\n[GlobalParams]\nPorousFlowDictator = dictator\n[]\n[Variables]\n[pp]\ninitial_condition = 20E6\n[]\n[]\n[PorousFlowBasicTHM]\ndictator_name = dictator\nadd_darcy_aux = false\nfp = simple_fluid\ngravity = '0 0 0'\nmultiply_by_density = false\nporepressure = pp\n[]\n[Modules]\n[FluidProperties]\n[simple_fluid]\ntype = SimpleFluidProperties\nviscosity = 0.001\n[]\n[]\n[]\n[Materials]\n[porosity]\ntype = PorousFlowPorosityConst\nporosity = 0.05\n[]\n[biot_mod]\ntype = PorousFlowConstantBiotModulus\nfluid_bulk_modulus = 2E9\nbiot_coefficient = 1.0\n[]\n[permeability]\ntype = PorousFlowPermeabilityConst\npermeability = '1E-14 0 0 0 1E-14 0 0 0 1E-14'\n[]\n[]\n[BCs]\n[sink]\ntype = PorousFlowSink\nvariable = pp\nflux_function = 0.16E-3\nboundary = left\n[]\n[]\n[VectorPostprocessors]\n[pp]\ntype = LineValueSampler\nnum_points = 25\nstart_point = '0 0 0'\nend_point = '100 0 0'\nsort_by = x\nvariable = pp\n[]\n[]\n[Preconditioning]\n[smp]\ntype = SMP\nfull = true\n[]\n[]\n[Executioner]\ntype = Transient\nsolve_type = Newton\ndt = 200\nend_time = 1E3\nnl_abs_tol = 1e-10\n[]\n[Outputs]\n[csv]\ntype = CSV\nexecute_on = final\n[]\n[]\nAlso, how is the area of the sink defined in this case? Would it be 2 * pi * Radius * height?\nThanks MOOSE\nMatias",
          "url": "https://github.com/idaholab/moose/discussions/18259",
          "updatedAt": "2022-07-26T13:09:10Z",
          "publishedAt": "2021-07-05T12:36:56Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "Hi Matias,\nIt is most likely due to the zero surface area for the sink at r = 0. Shift the mesh slightly (eg xmin = 0.1 in the Mesh block) and it should work (injection is through the area of the cylinder like you had above). You can use an AreaPostProcessor to compute the surface area of the sink for you and compute the flux for your sink in a function.",
                  "url": "https://github.com/idaholab/moose/discussions/18259#discussioncomment-967732",
                  "updatedAt": "2022-07-26T13:09:27Z",
                  "publishedAt": "2021-07-05T23:20:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "There is an example of this in https://github.com/idaholab/moose/blob/06bc1f73f0d4dfb3d01ce9ba77d6bb97346e07eb/modules/porous_flow/examples/restart/gas_injection.i",
                          "url": "https://github.com/idaholab/moose/discussions/18259#discussioncomment-967735",
                          "updatedAt": "2022-07-26T13:09:27Z",
                          "publishedAt": "2021-07-05T23:22:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MatiasAllay"
                          },
                          "bodyText": "Thanks @cpgr! This solve my question.",
                          "url": "https://github.com/idaholab/moose/discussions/18259#discussioncomment-973585",
                          "updatedAt": "2022-07-26T13:09:45Z",
                          "publishedAt": "2021-07-07T08:07:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Newbie to MOOSE",
          "author": {
            "login": "karthigesut"
          },
          "bodyText": "Hi all,\nI am a newbie to moose. I have installed moose software on Ubuntu 20.04. Now I don't know how to use the software. Is there any written guidelines or user manual on how to use this software? My goal is to do a fracture/fail mechanism (crystal plasticity) on a metal (Ti64) microstructure.\nThank you\nKarthi",
          "url": "https://github.com/idaholab/moose/discussions/18256",
          "updatedAt": "2022-09-24T11:46:32Z",
          "publishedAt": "2021-07-05T04:08:39Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I suggest look at https://mooseframework.inl.gov/getting_started/examples_and_tutorials/index.html",
                  "url": "https://github.com/idaholab/moose/discussions/18256#discussioncomment-964130",
                  "updatedAt": "2022-09-24T11:46:38Z",
                  "publishedAt": "2021-07-05T04:20:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "karthigesut"
                          },
                          "bodyText": "Hi Andy,\nThanks so much.\nkarthi",
                          "url": "https://github.com/idaholab/moose/discussions/18256#discussioncomment-964158",
                          "updatedAt": "2022-09-24T11:46:40Z",
                          "publishedAt": "2021-07-05T04:39:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "alikhan-zada"
                  },
                  "bodyText": "Hello Karthi,\nI think this will help more than the documentation, but that's just my opinion.\nhttps://www.youtube.com/watch?v=V7azGBtIkQA&list=PLct8iNZXls-CqvXrFk68E5QwPwsnMmyYo\nCheers :)",
                  "url": "https://github.com/idaholab/moose/discussions/18256#discussioncomment-973118",
                  "updatedAt": "2022-09-24T11:46:42Z",
                  "publishedAt": "2021-07-07T05:45:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Discontinuous Galerkin Advection in 3D",
          "author": {
            "login": "ngrilli"
          },
          "bodyText": "Has anybody developed code and examples to use Discontinuous Galerkin in 3D, for instance to model advection?\nI was looking at the test case here:\nhttps://github.com/idaholab/moose/blob/next/modules/rdg/test/tests/advection_1d/1d_aefv_square_wave.i\nMy understanding is that if I need to implement the same model in 3D model,\nI will need to:\n\nExtend AEFVSlopeLimitingOneD to calculate gradients in 3D\nExtend AEFVUpwindInternalSideFlux to use a 3D velocity vector\n\nwhile the AEFVKernel seems to be already suitable for 3D,\nand same for AEFVMaterial.\nAm I right?\nCould you give me some hints about the implementation?\nThank you very much in advance for your suggestions,\nBest Regards,\nNicol\u00f2",
          "url": "https://github.com/idaholab/moose/discussions/18210",
          "updatedAt": "2022-06-14T22:39:44Z",
          "publishedAt": "2021-06-29T22:14:31Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jbadger95"
                  },
                  "bodyText": "Disclaimer, I'm fairly new to MOOSE and am still learning but I think the examples you're looking at are more about using DG to implement a Finite Volume method (more natural FV capabilities are in the works) and less about using DG to solve the problem. In the tests directory you'll find a lot more examples with DG (for example 3D DG examples). Checkout test/tests/dgkernels, I haven't looked at them in depth but just glancing I'm seeing 3d_diffusion, ad_dg_convection, advection_diffusion_mixed_bcs.",
                  "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-941171",
                  "updatedAt": "2022-06-14T22:39:47Z",
                  "publishedAt": "2021-06-30T03:43:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @jbadger95\nThank you very much for pointing me to those files.\nNow I see DGKernels are also implemented in the framework and not only in the rdg module.\nI will try them. Thank you again.\nBest Regards,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-941835",
                          "updatedAt": "2022-06-14T22:39:47Z",
                          "publishedAt": "2021-06-30T07:20:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear MOOSE users,\nfollowing up my initial question:\nnow I learned how to use the DG kernel for advection.\nNow I would like to do coupled advection, I mean I want to implement the equation:\n\nwhere u is my variable, rho is a coupled variable and v the velocity.\nThe question is: how should I modify the DGConvection kernel?\nThe main challenge is that I need to get the coupled variable in the neighbouring element,\nso, for instance in the residual calculation, I will have a variable _rho_coupled_neighbor\ninstead of the variable _u_neighbor\nwhile I think the variable _u[_qp] can be simply substituted by _rho_coupled[_qp] which is obtained by:\n_rho_coupled(coupledValue(\"rho_coupled\")), this is the easy part I think.\nI saw in the base class DGKernel that the variable in the neighbour element is obtained by:\n_u_neighbor(_is_implicit ? _var.slnNeighbor() : _var.slnOldNeighbor()),\nHowever: _var(*mooseVariable()) gets the variable on which the kernel is applied, so u.\nSo, the question is: is there a function similar to mooseVariable() which can provide me a coupled variable instead, given its name?\nAny other suggestion to reach my goal?",
                  "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-944556",
                  "updatedAt": "2022-06-14T22:39:57Z",
                  "publishedAt": "2021-06-30T17:17:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "DGCoupledDiffusion.C under moose/test/src/dgkernels shows us how to couple variables in DG kernels.",
                          "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-944867",
                          "updatedAt": "2022-06-14T22:40:00Z",
                          "publishedAt": "2021-06-30T18:40:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "It is not using more strait-forward functions provided in NeighborCoupleable. Maybe MOOSE developers can comment on this? I was expecting to see something like\n    _v(coupledValue(\"v\")),\n    _v_neighbor(coupledNeighborValue(\"v\")),\n\nYou can try this to see if it works or not.",
                          "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-944899",
                          "updatedAt": "2022-06-14T22:40:01Z",
                          "publishedAt": "2021-06-30T18:47:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear MOOSE users,\nfollowing up my initial question:\nnow I have implemented the DG kernel for coupled advection:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/dgkernels/DGAdvectionCoupledVConst.C\nThe equations I am trying to solve are:\n\n$\\rho_e$ and $\\rho_t$ are the two variables.\nv is a constant velocity (v = 1.0) along positive x axis.\nAn initial vertical strip contains the non-zero phase field and I want to see the advection towards the right.\nI think the implementation is correct because I see the correct solution at up to time t = 1.0 when the variable reaches at the boundary,\nsee image below:\n\nI think the advection s correct, but there are two things:\n\nPeriodic BC do not work, the field clearly does not transfer from right to left\nAfter a certain time, when the field is at the boundary, I see $\\rho_e$ and $\\rho_t$ get very large value and simulation diverge.\n\nPoint 2) I really don't understand because there is nothing in the equations themselves that can give this divergence.\nI tried with different shape functions (MONOMIAL, L2_LAGRANGE)\nand with/without periodic BC, Dirichlet BC also give the same effect.\nAny suggestion is very much appreciated.\nThe input file is copied in the following, and also available here:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/test/tests/DGKernels/DGtestVConst.i\nBest Regards,\nNicol\u00f2\n[Mesh]\n\n  [./gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 10\n    ny = 10\n    nz = 1\n    xmax = 2.0\n    ymax = 2.0\n    zmax = 0.2\n    elem_type = HEX8\n    displacements = 'disp_x disp_y disp_z'  \n  [../] \n\n[]\n\n[GlobalParams]\n\n[]\n\n[Variables]\n \n  [./rho_t]\n    order = CONSTANT\n    family = MONOMIAL\n    [./InitialCondition]\n      type = FunctionIC\n      function = init_rho_t\n    [../]\n  [../]\n  \n  [./rho_gnd_edge]\n    order = CONSTANT\n    family = MONOMIAL\n    [./InitialCondition]\n      type = FunctionIC\n      function = init_rho_gnd_edge\n    [../]\n  [../]\n  \n[]\n\n[AuxVariables]\n\n[]\n\n[Functions]\n\n  [./dts]\n    type = PiecewiseConstant\n    x = '0.0 10.0'\n    y = '0.1 0.1'\n  [../]\n  \n  [./init_rho_gnd_edge]\n    type = ParsedFunction\n\tvalue = 'if(3.0*(x-1.0),0.0,1.0)'\n  [../]\n  \n  [./init_rho_t]\n    type = ParsedFunction\n\tvalue = 'if(3.0*(x-1.0),0.0,1.0)'\n  [../]\n  \n[]\n\n[UserObjects]\n\n[]\n\n[Kernels]\n\n  [./drho_gnd_edge_dt]\n    type = TimeDerivative\n    variable = rho_gnd_edge\n  [../]\n\n  [./drho_t_dt]\n    type = TimeDerivative\n    variable = rho_t\n  [../]  \n    \n[]\n\n[DGKernels]\n\n  [./rho_t_advection_edge]\n    type = DGAdvectionCoupledVConst\n    variable = rho_gnd_edge\n\trho_coupled = rho_t\n    velocity = '1 0 0'\n  [../] \n  \n  [./rho_gnd_edge_advection]\n    type = DGAdvectionCoupledVConst\n    variable = rho_t\n\trho_coupled = rho_gnd_edge\n    velocity = '1 0 0'\n  [../]\n\n[]\n\n[AuxKernels]\n\n[]\n\n[BCs]\n  \n  [./Periodic]\n  \n    [./auto_rho_t_boundary_x]\n      variable = rho_t\n      primary = 'left'\n\t  secondary = 'right'\n\t  translation = '2.0 0.0 0.0'\n    [../]\n    [./auto_rho_gnd_edge_boundary_x]\n      variable = rho_gnd_edge\n      primary = 'left'\n\t  secondary = 'right'\n      translation = '2.0 0.0 0.0'  \n    [../]\n\t\n    [./auto_rho_t_boundary_y]\n      variable = rho_t\n      primary = 'bottom'\n\t  secondary = 'top'\n\t  translation = '0.0 2.0 0.0'\n    [../]\n    [./auto_rho_gnd_edge_boundary_y]\n      variable = rho_gnd_edge\n      primary = 'bottom'\n\t  secondary = 'top'\n      translation = '0.0 2.0 0.0'\t  \n    [../]\n\t\n    [./auto_rho_t_boundary_z]\n      variable = rho_t\n      primary = 'back'\n\t  secondary = 'front'\n\t  translation = '0.0 0.0 0.2'\n    [../]\n    [./auto_rho_gnd_edge_boundary_z]\n      variable = rho_gnd_edge\n      primary = 'back'\n\t  secondary = 'front'\n\t  translation = '0.0 0.0 0.2'\n    [../]\n\n  [../]  \n  \n[]\n \n[Postprocessors]\n\n[]\n\n[Materials]\n\n[]\n\n[Preconditioning]\n  \n  active = 'smp'\n  \n  [./smp]\n    type = SMP\n    full = true\n  [../]\n  \n[]\n\n[Executioner]\n\n  type = Transient\n  solve_type = 'PJFNK'\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu superlu_dist'\n  \n  line_search = 'none'\n  automatic_scaling = true\n  \n  l_max_its = 50\n  nl_max_its = 50\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-10\n  \n  [./TimeStepper]\n    type = FunctionDTGrowth\n    function = dts\n\tcutback_factor_at_failure = 0.1\n\tgrowth_factor = 1.2\n  [../]\n\n  start_time = 0.0\n  end_time = 10.0\n  \n  dtmin = 1.0e-10\n  timestep_tolerance = 1.0e-10\n[]\n\n[Outputs]\n\n  csv = false\n\n  [./out]\n    type = Exodus\n    interval = 1\n  [../]\n  \n[]",
                  "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-957735",
                  "updatedAt": "2022-06-14T22:40:05Z",
                  "publishedAt": "2021-07-02T16:54:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "@YaqiWang maybe you have a clue about this?\nThank you\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-957739",
                          "updatedAt": "2022-06-14T22:40:43Z",
                          "publishedAt": "2021-07-02T16:55:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "does it work with reflective?\nThere's definitely some gaps in the implementation of periodic BCs\n@gridley has looked at that recently, maybe he can help here",
                          "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-958120",
                          "updatedAt": "2022-06-14T22:40:45Z",
                          "publishedAt": "2021-07-02T18:46:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @GiudGiud\nApologies but I am not sure what you mean by reflective BC.\nCould you point me to an example in moose?\nI only tried removing all BC, so it should be zero flux and I get the same solution as with periodic.\nI also tried dirichlet and penalty dirichlet but I get the same problem of the high value of the variable and oscillations appearing\nat the boundary after some time.\nI don't specifically need periodic BC, but I was just trying to setup a simulation\nthat can work even if there are accumulation of the variable at the boundaries.\nOtherwise, is there any other way to make conservative advection with a coupled variable in moose?\nI made this code some time ago:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/kernels/ConservativeAdvectionCoupled.C\nbut it was not working well, I am not enough familiar with the framework to modify properly\nthe function fullUpwind(JacRes res_or_jac)\nin such a way that it can work with a coupled variable.\nThis code was taken from:\nhttps://github.com/idaholab/moose/blob/next/framework/src/kernels/ConservativeAdvection.C\nbut my modifications of fullUpwind(JacRes res_or_jac) were probably not correct.\nIf someone can help with this, it would be great.\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-958672",
                          "updatedAt": "2022-06-14T22:40:45Z",
                          "publishedAt": "2021-07-02T22:01:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Reflective should be the zero flux here.\nThe other way, and probably the best way, to do conservative advection is to use finite volume. You can have a look at the advection kernels for incompressible navier stokes. For advection with a constant velocity there's a simple one in the framework, FVAdvection.\nFor advection with a coupled variable velocity, INSFVMomentum/MassAdvection are more useful.\nNote that DG should work too, Im just less familiar with it so cant really help\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-958680",
                          "updatedAt": "2022-06-14T22:40:54Z",
                          "publishedAt": "2021-07-02T22:05:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Sorry, I did not notice this. You seem missing a kernel for the convection term. Check this moose/test/tests//dgkernels/1d_advection_dg/1d_advection_dg.i out. We apply integration by parts for the convection term multiplied with a test function resulting into a normal kernel and a dg kernel.",
                          "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-966718",
                          "updatedAt": "2022-06-14T22:40:56Z",
                          "publishedAt": "2021-07-05T16:20:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @YaqiWang\nThank you, really, your comment was illuminating for me.\nSo let me see if I understand well:\n\nThe DG kernels are taking care of the discontinuity of the shape functions at the elements boundaries.\nThe normal kernels are taking care of the bulk term, where shape functions can have a gradient, which must be considered for advection.\nTherefore, I need to use both at the same time.\nDoes this make sense?\n\nI have implemented both normal kernel for coupled advection and DG kernel for coupled advection and I am using them together.\nThe result is correct now, see the following picture compared to the one I posted above:\n\nI can see that the advection is definitely conservative and there is no more solution divergence when the\nfield remains blocked at the boundary like before.\nMain features:\n\nI am able to run these simulations with both first order monomial and constant monomial variables\nperiodic BC do not do anything in both cases, but that was the same as I found earlier, not very important for my project anyway\nthe key to avoid the divergence at the end is actually to add the line \"implicit = false\" in all the advection kernels,\nas it is done in the example in moose:\nhttps://github.com/idaholab/moose/tree/next/test/tests/dgkernels/1d_advection_dg\nIf I don't use \"implicit = false\", I have the divergence problem discussed above even with the combined DG + non-DG kernels.\n\nAnyway the solution looks much more correct now and I will pursue further this method for my problem.\nIf anyone is interested, my kernels for coupled advection and test cases are here:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/test/tests/DGKernels/DGtestConstMonomial.i\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/dgkernels/DGAdvectionCoupledVConst.C\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/kernels/AdvectionCoupledVConst.C\nThank you very much again,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-972299",
                          "updatedAt": "2022-06-14T22:41:02Z",
                          "publishedAt": "2021-07-06T22:29:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Glad it is working. I am not so sure about this implicit = false. This is making the kernel coupling the variable of the previous time step. I would think it should work without this implicit. You may want to double check.",
                          "url": "https://github.com/idaholab/moose/discussions/18210#discussioncomment-972420",
                          "updatedAt": "2022-06-14T22:41:27Z",
                          "publishedAt": "2021-07-06T23:40:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}