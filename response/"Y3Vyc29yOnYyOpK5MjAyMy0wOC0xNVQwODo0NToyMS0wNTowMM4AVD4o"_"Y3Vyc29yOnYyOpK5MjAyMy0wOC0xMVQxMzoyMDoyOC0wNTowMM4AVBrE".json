{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wOC0xMVQxMzoyMDoyOC0wNTowMM4AVBrE"
    },
    "edges": [
      {
        "node": {
          "title": "Large mesh best practices and memory management",
          "author": {
            "login": "Eilloo"
          },
          "bodyText": "Hi all,\nI have a few questions about how best to deal with large meshes, as I have been running into errors which I think are to do with processes running out of memory.\nFor an idea of size, my mesh is around 5 million elements, and I am attempting to run my simulations across multiple nodes on an HPC.\n1. Mesh splitting:\nAs I understand it, this pre-splits the mesh into a fixed number of chunks for later use with distributed mesh. The number of chunks must match the number of processors the simulation will then be run on, and the idea is that you only need to store a small part of the mesh for the process to run. Ideal when the mesh is too large to fit into the memory.\nHowever, it also seems that you need to fit the whole mesh into memory in order to perform the splitting operations in the first place? If the mesh doesn't fit, you can't split it to alleviate that problem?\nIs the idea that you can usually fit the whole mesh into memory when it is just the mesh (ie, when performing the splitting), but during a simulation you need to allocate some of that memory to the nonlinear and aux systems, for instance, so you now can't afford to store the whole mesh?\nA further question is whether the mesh splitting operation somehow assumes that you will have the same amount of memory when you run the simulation as you did during splitting?\nThis is a tricky question to phrase, but the scenario is that I can fit a mesh one HPC node with a large amount of memory, and perform splitting operations there. However, if I try and use the resulting .cpr files on different HPC nodes with less memory, I run into mpi errors even if the number of processors is correct.\nI wondered if this is related to how the mesh is split in the first place.\n2. What is the difference between pre-splitting the mesh and setting --distributed-mesh, and setting parallel_type = distributed in the input file?\nUp to now, I had thought that setting parallel_type = distributed would automatically distribute the mesh across the number of processors you are running on.\nIs this the case, and if so, is the process behind the scenes any different than doing the splitting as a separate step?\n3. What about storing the nonlinear and auxiliary system variables?\nThe last thing to ask is whether the mesh is usually the memory bottleneck? I have a fairly large number of variables, and an especially large number of aux variables since I am extracting all my vector variable components due to #24193.\nWill these be distributed, or could this also be a problem? I wondered if this was the reason why I could successfully split a mesh, but mpi errors suggesting memory issues occur when I try and run the actual simulation.\nIn case it's useful, I usually get exit code 7 (bus error) when things don't work, and occasionally exit code 9 (killed) from mpirun.\n5 million elements doesn't seem completely unreasonable, so any insight into where I might be going wrong is greatly appreciated.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/25053",
          "updatedAt": "2023-08-15T11:27:20Z",
          "publishedAt": "2023-07-28T14:08:33Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "For an idea of size, my mesh is around 5 million elements, and I am attempting to run my simulations across multiple nodes on an HPC.\n\nThis is a very reasonable size. How many degrees of freedom in nonlinear and aux systems (you can see this in the header printout)?\n\nAs I understand it, this pre-splits the mesh into a fixed number of chunks for later use with distributed mesh. The number of chunks must match the number of processors the simulation will then be run on, and the idea is that you only need to store a small part of the mesh for the process to run. Ideal when the mesh is too large to fit into the memory.\n\nThat's correct. You gain two things here by each processor only needing to load its small part of mesh (keep in mind that when loading from splits, you're forcing distributed mesh):\n\nEach processor loads a smaller file from disk, which is faster for startup than every process loading the same, huge, full mesh file\nYou save the memory of each process needing to know the full mesh at the beginning in order to do partitioning. If you don't use split mesh, each process will load the full mesh, do the same partitioning, and then delete elems that are not needed locally\n\n\nHowever, it also seems that you need to fit the whole mesh into memory in order to perform the splitting operations in the first place? If the mesh doesn't fit, you can't split it to alleviate that problem?\n\nYou should split the mesh only using a few processes. That is:\nmpiexec -n 4 /path/to/app.opt -i input.it --split-mesh 600\n\nEach process will still load the full mesh (so 4 copies of the mesh), and each will be responsible for saving 150 partitions in this case. As your mesh gets bigger, you can actually just run this in serial:\n/path/to/app.opt -i input.it --split-mesh 600\n\nand it'll take longer, but that's fine - it's only done once. As you get bigger and bigger meshes, most HPCs usually have high memory or visualization nodes. These are perfect for splitting meshes.\n\nIs the idea that you can usually fit the whole mesh into memory when it is just the mesh (ie, when performing the splitting), but during a simulation you need to allocate some of that memory to the nonlinear and aux systems, for instance, so you now can't afford to store the whole mesh?\n\nKind of. But, when you get into meshes that are millions of elements... in general we recommend pre splitting always so you don't have to even think about this problem.\n\nWhat is the difference between pre-splitting the mesh and setting --distributed-mesh, and setting parallel_type = distributed in the input file?\n\nLike I said above. When you don't pre split but use distributed mesh, the mesh is serialized (loaded fully) on all processes, partitioned on all processes, and then deleted. Thus, when you don't do pre split, at one point each process has the full mesh in memory. You can sometimes get away with this because this memory jump is done before adding systems/vectors/matrices/etc.\n\nThe last thing to ask is whether the mesh is usually the memory bottleneck? I have a fairly large number of variables, and an especially large number of aux variables since I am extracting all my vector variable components due to #24193. Will these be distributed, or could this also be a problem? I wondered if this was the reason why I could successfully split a mesh, but mpi errors suggesting memory issues occur when I try and run the actual simulation\n\nWhether or not you are replicated or distributed, vectors and matrices are always distributed. So - the overhead for this should not be different.\n\n5 million elements doesn't seem completely unreasonable, so any insight into where I might be going wrong is greatly appreciated.\n\nAs I asked above - can you share how many degrees of freedom you have in your problem? That would give us an idea on usage.",
                  "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6578013",
                  "updatedAt": "2023-07-28T16:50:00Z",
                  "publishedAt": "2023-07-28T16:49:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Eilloo"
                          },
                          "bodyText": "Thanks for the thorough explanation - that clears a lot up!\nI can indeed split the mesh on a high memory node in this case\nIn terms of dofs, we don't get as far as printing that header (this is using the split mesh in 1200 parts, although I have also tried using fewer splits in case too many boundaries is somehow a problem). The last reported step is 'Ghosting Ghosted Boundaries\".\nWe have 12 variables in the nonlinear system (counting vectors as 3), so around 60 million dofs(?). The auxiliary system is a similar order, 15 variables.",
                          "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6592297",
                          "updatedAt": "2023-07-31T09:14:37Z",
                          "publishedAt": "2023-07-31T08:11:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Eilloo"
                  },
                  "bodyText": "As a followup question to this, could someone confirm exactly what the reported memory use in the output file is telling us?\nI have been assuming that it is the memory used per process for each step, so we should multiply by the number of processors per node to get the total memory used per node (on a cluster). Is this correct?\nBelow is an example of the reporting I am referring to:\n  Initializing\n    Ghosting Ghosted Boundaries.                                                         [\ufffd[33m 18.59 s\ufffd[39m] [\ufffd[33m 2036 MB\ufffd[39m]\n    Updating Because Mesh Changed\n      Updating Mesh\n        Finished Building Boundary Elements List                                         [\ufffd[33m  2.67 s\ufffd[39m] [\ufffd[33m 2455 MB\ufffd[39m]\n      Finished Updating Mesh                                                             [\ufffd[33m 16.13 s\ufffd[39m] [\ufffd[33m 2490 MB\ufffd[39m]\n    Finished Updating Because Mesh Changed                                               [\ufffd[33m 16.37 s\ufffd[39m] [\ufffd[33m 2573 MB\ufffd[39m]\n    Updating Because Mesh Changed\n      Updating Mesh\n        Finished Building Boundary Elements List                                         [\ufffd[33m  2.59 s\ufffd[39m] [\ufffd[33m 2973 MB\ufffd[39m]\n      Finished Updating Mesh                                                             [\ufffd[33m 15.52 s\ufffd[39m] [\ufffd[33m 3008 MB\ufffd[39m]\n    Finished Updating Because Mesh Changed                                               [\ufffd[33m 15.74 s\ufffd[39m] [\ufffd[33m 3106 MB\ufffd[39m]\n    Initializing Equation Systems..                                                      [\ufffd[33m 21.55 s\ufffd[39m] [\ufffd[33m 3387 MB\ufffd[39m]\n    Initializing Displaced Equation System.                                              [\ufffd[33m 18.36 s\ufffd[39m] [\ufffd[33m 3622 MB\ufffd[39m]\n    Updating Because Mesh Changed\n      Updating Mesh                                                                      [\ufffd[33m 17.39 s\ufffd[39m] [\ufffd[33m 3664 MB\ufffd[39m]\n    Finished Updating Because Mesh Changed                                               [\ufffd[33m 17.60 s\ufffd[39m] [\ufffd[33m 3664 MB\ufffd[39m]\n  Finished Initializing                                                                  [\ufffd[33m108.22 s\ufffd[39m] [\ufffd[33m 3664 MB\ufffd[39m]\n\nAnd:\nCurrently Executing\n  Performing Initial Setup\n    Updating Geometric Search\n      Finding Nearest Nodes........                                                      [\ufffd[33m 49.86 s\ufffd[39m] [\ufffd[33m 3666 MB\ufffd[39m]\n      Updating Displaced GeometricSearch\n        Finding Nearest Nodes........                                                    [\ufffd[33m 48.65 s\ufffd[39m] [\ufffd[33m 3702 MB\ufffd[39m]\n      Finished Updating Displaced GeometricSearch                                        [\ufffd[33m 48.65 s\ufffd[39m] [\ufffd[33m 3702 MB\ufffd[39m]\n    Finished Updating Geometric Search                                                   [\ufffd[33m 98.51 s\ufffd[39m] [\ufffd[33m 3702 MB\ufffd[39m]\n    Reinitializing Because of Geometric Search Objects...............                    [\ufffd[33m 88.36 s\ufffd[39m] [\ufffd[33m 4368 MB\ufffd[39m]\n    Building SemiLocalElemMap.....                                                       [\ufffd[33m 36.10 s\ufffd[39m] [\ufffd[33m 4335 MB\ufffd[39m]\nlibMesh terminatinglibMesh terminating:",
                  "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6627981",
                  "updatedAt": "2023-08-03T13:29:43Z",
                  "publishedAt": "2023-08-03T13:29:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It's roughly correct. It s the instantaneous current use, not the specific \"step use\"\nIt s not the most accurate thing because it only reports process 0, not the average use over all processes",
                          "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6628140",
                          "updatedAt": "2023-08-03T13:41:56Z",
                          "publishedAt": "2023-08-03T13:41:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Eilloo"
                          },
                          "bodyText": "Ok, thanks for clarifying.\nI am suspicious that something is being replicated when it shouldn't be to be reaching such large memory usage numbers... using the approximation of a minimum from 20022 we get around 21Gb. I gather the actual requirements can still be much higher depending on preconditioner choice and materials, but this is many orders of magnitude below the total memory available in a parallel run (ie, summing the memory across all nodes).\nDo you know of any way in MOOSE to effectively debug this kind of thing? Since the simulation is being killed during setup, I'm not sure I can make use of the memory usage and performance post-processors?",
                          "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6678794",
                          "updatedAt": "2023-08-09T10:20:37Z",
                          "publishedAt": "2023-08-09T10:20:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you can use memory profiling to keep track of memory requirements\nlook at heap profiling here\nhttps://mooseframework.inl.gov/application_development/profiling.html\nThis will point you to the code that allocates large amounts of memory",
                          "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6682495",
                          "updatedAt": "2023-08-09T16:30:29Z",
                          "publishedAt": "2023-08-09T16:30:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Eilloo"
                          },
                          "bodyText": "Perfect, thanks - I'll look into this",
                          "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6688614",
                          "updatedAt": "2023-08-10T08:32:35Z",
                          "publishedAt": "2023-08-10T08:32:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Eilloo"
                          },
                          "bodyText": "Sorry to reopen an answered thread - I have one more question related to this:\n@loganharbour, when you say the vectors and matrices are always distributed, do you know what the process for splitting is?\nThrough some playing around, it seems as though the process is analogous to using distributed mesh without pre-splitting. In other words, is memory allocated on every processor for the whole system, and then parts which are not needed by each process are deleted?\nThe reason it seems this way is that I stop running into memory issues if I run across fewer processes, so that each one has more memory available to it. Apart from ghosting, if everything was pre-split, this wouldn't make a difference - for instance, halving the number of processors would double the memory available to each, but also double the amount stored on each.\nIt therefore seems like the matrices are all replicated at first, or perhaps something in between. If this is true, is there any pre-splitting type operation that can be done?",
                          "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6699983",
                          "updatedAt": "2023-08-11T09:44:53Z",
                          "publishedAt": "2023-08-11T09:44:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "@loganharbour, when you say the vectors and matrices are always distributed, do you know what the process for splitting is?\n\nThe way this is done is by partitioning, for which how this process done is equivalent for a given processor configuration (# procs), regardless of distributed or replicated mesh. This partitionining assigns nodal and elemental values in the mesh to a particular processor. Once this process is done, this denotes who owns what part of the vectors and matrices in the problem.\nWhen the vectors and matrices are allocated (regardless of distributed or replicated mesh), they are still distributed. If you do not need ghosting for a vector or matrix, each processor will only allocate the degrees of freedom that it owns. If you need some ghosting, you'll have a bit more allocation here in order to have space for the entries that you need that other processors own.\n\nThe reason it seems this way is that I stop running into memory issues if I run across fewer processes, so that each one has more memory available to it.\n\nThis is likely because you have more available memory on a compute node, no? This is a common process. Say you have a compute node that has 256GB of memory a piece and 48 procs. If you request this whole node, you get 256 / 48 = 5.3 GB / proc. If you request the whole node but only use half the procs, you get 256 / 24 = 10.6GB / proc. That is - when you have a memory constrained problem, we often request fewer processors but request a whole node so that we have more memory available.\nAre you sure that you're not just resolving your problems because you have more memory available?\n\nIt therefore seems like the matrices are all replicated at first, or perhaps something in between. If this is true, is there any pre-splitting type operation that can be done?\n\nThis isn't the case. The matricies and vectors (aside from ghosting) really are allocated in a distributed sense. With pre-split mesh, for a standard problem, there should be very little replicated data.\nHowever, there is a chance that you could be using an algorithm or some capability that doesn't support distribution and does some replication. Can you share what you're trying to run?",
                  "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6702977",
                  "updatedAt": "2023-08-11T15:26:50Z",
                  "publishedAt": "2023-08-11T15:26:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There's also some overhead to ghosting variables & the mesh (one layer on the edge of every domain by default) that does go down as the number of processes is reduced (and removed entirely in serial)",
                          "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6703636",
                          "updatedAt": "2023-08-11T16:44:41Z",
                          "publishedAt": "2023-08-11T16:44:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Eilloo"
                          },
                          "bodyText": "This is interesting - it does indeed sound like most of these issues are resolved due to having more memory available. However, I am not clear about why, say, half the number of processors with double the memory is any better overall from a memory point of view?\nTo use an over-simplified example, suppose the matrices in your problem take up 8Gb of memory; one compute node has 4Gb of memory in total, and each compute node has 2 processors. If you request two nodes with two processors per node, the matrices would be split into four 2Gb parts and each processor would allocate only values on its part.\nHowever, if we request two nodes but only one processor per node, the matrices are split into two 4Gb parts instead, so even though there is more memory per processor, the total is always the same.\nI am sure I am missing something key here - apologies if this is a silly question, but hopefully the example highlights where I am going wrong!",
                          "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6728135",
                          "updatedAt": "2023-08-15T07:56:53Z",
                          "publishedAt": "2023-08-15T07:56:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The total isn\u2019t quite the same exactly because of the cost of ghosting\n(And the distribution of the mesh)\nThere s also some marginal cost from creating all the objects in each process.\nthe key here is to measure. And probably make a table for the cost of each part of the simulation for 1,2,3\u2026 processes",
                          "url": "https://github.com/idaholab/moose/discussions/25053#discussioncomment-6729730",
                          "updatedAt": "2023-08-15T11:27:20Z",
                          "publishedAt": "2023-08-15T11:27:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "FV elemental vs qp evaluation",
          "author": {
            "login": "heinono1"
          },
          "bodyText": "Hi. I think I have my FV version of Ferret (module for ferroic systems) working. Some of the FV kernels are elemental, some are flux kernels. It seems to me that when evaluating the residuals for elemental kernels, I can either evaluate variables/functors on quadrature points and would as an example have the residual as\n    return prefactor * (_mag_y[_qp]* _nz[_qp] - _mag_z[_qp]* _ny[_qp]);\n\nwhere _mag_x, _nx etc are functors and prefactor is ADReal,\nor I can define elemental values like\n  ADReal _mag_x_elem = _mag_x(makeElemArg(_current_elem),determineState());\n  ADReal _mag_y_elem = _mag_y(makeElemArg(_current_elem),determineState());\n\nand similarly for _ny_elem and _ny_elem and evaluate the residual as\n return  prefactor * (_mag_z_elem * _nx_elem - _mag_x_elem * _nz_elem);\n\nAm I correct that either one works, and, if so, is there any particular advantage to one vs the other?",
          "url": "https://github.com/idaholab/moose/discussions/25199",
          "updatedAt": "2023-08-14T18:15:02Z",
          "publishedAt": "2023-08-14T14:36:01Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nBoth formulations are equivalent in terms of results for a finite volume variable.\nThe element argument on a constant monomial gets the cell-center value, which is also the only quadrature point in a FV simulation (_qp = 0).\nThe first formulation would be a tad faster (possibly not measurable), as it's a more lightweight interface\nThe second formulation (using the functor routines) will let you use functions, variables, functor material properties and soon postprocessors for mag_x and _y.\n@lindsayad\nAs you prefer basically!\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25199#discussioncomment-6722009",
                  "updatedAt": "2023-08-14T15:14:23Z",
                  "publishedAt": "2023-08-14T15:14:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "heinono1"
                          },
                          "bodyText": "Thanks, Guillaume. That is what I was guessing. Incidentally, I did write postprocessors for the FV code but had to use ADFunctorElementalAux and ADFunctorElementalGradientAux to define elemental variables and their gradients that I could use with the ElementIntegralPostprocessor, so postprocessors that can use the FV variables directly will be great!",
                          "url": "https://github.com/idaholab/moose/discussions/25199#discussioncomment-6722899",
                          "updatedAt": "2023-08-14T16:46:13Z",
                          "publishedAt": "2023-08-14T16:46:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It's coming real soon! Josh has fixed a legacy issues with postprocessors and now we are on the brink of having that",
                          "url": "https://github.com/idaholab/moose/discussions/25199#discussioncomment-6723127",
                          "updatedAt": "2023-08-14T17:16:30Z",
                          "publishedAt": "2023-08-14T17:16:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "heinono1"
                          },
                          "bodyText": "That will be great!",
                          "url": "https://github.com/idaholab/moose/discussions/25199#discussioncomment-6723135",
                          "updatedAt": "2023-08-14T17:18:03Z",
                          "publishedAt": "2023-08-14T17:18:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I will say that I think it's easier to support finite volume with the functor interfaces, e.g. makeElemArg. So we may develop FV features in the future that are only supported through the functor interfaces. But the _qp code that already exists will probably always be supported, as there is substantial user code that relies on it.",
                          "url": "https://github.com/idaholab/moose/discussions/25199#discussioncomment-6723617",
                          "updatedAt": "2023-08-14T18:15:02Z",
                          "publishedAt": "2023-08-14T18:15:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Building MOOSE in developer mode:",
          "author": {
            "login": "steam-simulator"
          },
          "bodyText": "Any web links to how I can build my moose app in developer mode? Do I have to re-install moose to do this?",
          "url": "https://github.com/idaholab/moose/discussions/25201",
          "updatedAt": "2023-08-14T19:25:21Z",
          "publishedAt": "2023-08-14T16:55:44Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou have to rebuild with the devel method\nMETHOD=devel make -j6\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25201#discussioncomment-6723118",
                  "updatedAt": "2023-08-14T17:15:26Z",
                  "publishedAt": "2023-08-14T17:15:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The requested AD material property 'stress' of type 'RankTwoTensorTempl<double>' is already retrieved or declared as a non-AD property of type 'RankTwoTensorTempl<double>'.",
          "author": null,
          "bodyText": "Hello All,\nI\u2019ve obtained stress as an AD Material property into my permeability model. But when I run my input file, I got the above error. What I\u2019m I doing wrong?\nThis is how I obtained the stress:\n   _stress(getADMaterialProperty<RankTwoTensor>(\"stress\")),\n   _strain(getADMaterialProperty<RankTwoTensor>(\"creep_strain\"))\n\nMy input file looks something like this:\n  [elasticity_tensor_fluid]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 1e11                  \n    poissons_ratio = 0.0     \n  []\n\n  [return_stress]\n    type = ADComputeMultipleInelasticStress\n    inelastic_models = \"new_creep\"\n    combined_inelastic_strain_weights = '1.0'\n  []\n\n  [new_creep]\n    type = ADNewCreep\n    smin = 1.21e8 \n    smax = 1.88e5    \n    smin_const = 0.87\n    smax_const = 1.21\n  []",
          "url": "https://github.com/idaholab/moose/discussions/25193",
          "updatedAt": "2023-08-14T15:15:59Z",
          "publishedAt": "2023-08-13T00:36:28Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhere is stress being declared?\nThere's a Debug option to show material properties , who is declaring and who is consuming\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25193#discussioncomment-6711542",
                  "updatedAt": "2023-08-13T02:29:04Z",
                  "publishedAt": "2023-08-13T02:29:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Hello, so I got a new error after I modified the constructor:\n*** ERROR ***\nThe following error occurred in the object \"stress_xx\", of type \"ADRankTwoScalarAux\".\n\nThe requested AD material property 'stress' of type 'RankTwoTensorTempl<double>'\nis already retrieved or declared as a non-AD property of type 'RankTwoTensorTempl<double>'.\n\nThe stress is being consumed by my new permeability model and I declared it in my header file as:\n  /// get the AD of total stress tensor\n\tconst ADMaterialProperty<RankTwoTensor>& _stress\n\nIn the source, it is:\n   _stress(getADMaterialProperty<RankTwoTensor>(\"RR_stress\")),\n   _strain(getADMaterialProperty<RankTwoTensor>(\"RR_total_strain\"))\n\nMy intention is to get the an ADstress from ADComputeMultipleInelasticStress into my permeability model.\nHere is what the debug option is showing:\n    domain: block 1 (52)\n      Material Name:       temperature_neighbor\n      Property Names:      \"PorousFlow_grad_temperature_qp\" \"PorousFlow_temperature_qp\" \"dPorousFlow_grad_temperature_qp_dgradvar\"\n                             \"dPorousFlow_grad_temperature_qp_dvar\" \"dPorousFlow_temperature_qp_dvar\"\n\n      Material Name:       saturation_neighbor\n      Property Names:      \"PorousFlow_grad_porepressure_qp\" \"PorousFlow_grad_saturation_qp\" \"PorousFlow_porepressure_qp\"\n                             \"PorousFlow_saturation_qp\" \"dPorousFlow_grad_porepressure_qp_dgradvar\" \"dPorousFlow_grad_porepressure_qp_dvar\"\n                             \"dPorousFlow_grad_saturation_qp_dgradvar\" \"dPorousFlow_grad_saturation_qp_dvar\"\n                             \"dPorousFlow_porepressure_qp_dvar\" \"dPorousFlow_saturation_qp_dvar\"\n      Material Name:       massfrac_neighbor\n      Property Names:      \"PorousFlow_grad_mass_frac_qp\" \"PorousFlow_mass_frac_qp\" \"dPorousFlow_mass_frac_qp_dvar\"\n\n      Material Name:       water_viscosity_density_neighbor\n      Property Names:      \"PorousFlow_fluid_phase_density_qp0\" \"PorousFlow_fluid_phase_enthalpy_qp0\"\n                             \"PorousFlow_fluid_phase_internal_energy_qp0\" \"PorousFlow_viscosity_qp0\"\n                             \"dPorousFlow_fluid_phase_density_qp0/dpressure_variable\" \"dPorousFlow_fluid_phase_density_qp0/dtemperature_variable\"\n                             \"dPorousFlow_fluid_phase_enthalpy_qp0/dpressure_variable\" \"dPorousFlow_fluid_phase_enthalpy_qp0/dtemperature_variable\"\n                             \"dPorousFlow_fluid_phase_internal_energy_qp0/dpressure_variable\" \"dPorousFlow_fluid_phase_internal_energy_qp0/dtemperature_variable\"\n                             \"dPorousFlow_viscosity_qp0/dpressure_variable\" \"dPorousFlow_viscosity_qp0/dtemperature_variable\"\n\n      Material Name:       relperm_water_neighbor\n      Property Names:      \"PorousFlow_relative_permeability_qp0\" \"dPorousFlow_relative_permeability_qp0/dsaturation_variable\"\n\n      Material Name:       porosity_block 1_neighbor\n      Property Names:      \"PorousFlow_porosity_qp\" \"dPorousFlow_porosity_qp_dgradvar\" \"dPorousFlow_porosity_qp_dvar\"\n\n      Material Name:       permeability_block 1_neighbor\n      Property Names:      \"PorousFlow_permeability_qp\" \"dPorousFlow_permeability_qp_dgradvar\" \"dPorousFlow_permeability_qp_dvar\"\n                             \"fracture_normal_strain_qp\" \"initial_fracture_aperture_qp\" \"random_xy_rotation_angle_for_each_element_qp\"\n                             \"random_yz_rotation_angle_for_each_element_qp\"\n      Material Name:       elasticity_tensor_block 1_neighbor\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\"\n      Material Name:       return_stress_neighbor\n      Property Names:      \"RR_combined_inelastic_strain\" \"RR_elastic_strain\" \"RR_material_timestep_limit\"\n                             \"RR_rotation_total\" \"RR_stress\"\n      Material Name:       new_creep_neighbor\n      Property Names:      \"creep_strain\" \"effective_creep_strain\" \"kelv_creep_strain\"\n      Material Name:       RR_stress_yy_all_neighbor\n      Property Names:      \"RR_stress_yy\"\n      Material Name:       RR_stress_xx_all_neighbor\n      Property Names:      \"RR_stress_xx\"\n      Material Name:       RR_stress_zz_all_neighbor\n      Property Names:      \"RR_stress_zz\"\n      Material Name:       RR_creep_strain_xx_all_neighbor\n      Property Names:      \"RR_creep_strain_xx\"\n      Material Name:       RR_creep_strain_yy_all_neighbor\n      Property Names:      \"RR_creep_strain_yy\"\n      Material Name:       RR_creep_strain_zz_all_neighbor\n      Property Names:      \"RR_creep_strain_zz\"\n      Material Name:       RR_elastic_strain_yy_all_neighbor\n      Property Names:      \"RR_elastic_strain_yy\"\n      Material Name:       massfrac_nodal_neighbor\n      Property Names:      \"PorousFlow_mass_frac_nodal\" \"dPorousFlow_mass_frac_nodal_dvar\"\n      Material Name:       porosity_block 1_nodal_neighbor\n      Property Names:      \"PorousFlow_porosity_nodal\" \"dPorousFlow_porosity_nodal_dgradvar\" \"dPorousFlow_porosity_nodal_dvar\"\n\n      Material Name:       relperm_water_phase0_nodal_neighbor\n      Property Names:      \"PorousFlow_relative_permeability_nodal0\" \"dPorousFlow_relative_permeability_nodal0/dsaturation_variable\"\n\n      Material Name:       saturation_nodal_neighbor\n      Property Names:      \"PorousFlow_porepressure_nodal\" \"PorousFlow_saturation_nodal\" \"dPorousFlow_porepressure_nodal_dvar\"\n                             \"dPorousFlow_saturation_nodal_dvar\"\n      Material Name:       temperature_nodal_neighbor\n      Property Names:      \"PorousFlow_temperature_nodal\" \"dPorousFlow_temperature_nodal_dvar\"\n      Material Name:       water_viscosity_density_phase0_nodal_neighbor\n      Property Names:      \"PorousFlow_fluid_phase_density_nodal0\" \"PorousFlow_fluid_phase_enthalpy_nodal0\"\n                             \"PorousFlow_fluid_phase_internal_energy_nodal0\" \"PorousFlow_viscosity_nodal0\"\n                             \"dPorousFlow_fluid_phase_density_nodal0/dpressure_variable\" \"dPorousFlow_fluid_phase_density_nodal0/dtemperature_variable\"\n                             \"dPorousFlow_fluid_phase_enthalpy_nodal0/dpressure_variable\" \"dPorousFlow_fluid_phase_enthalpy_nodal0/dtemperature_variable\"\n                             \"dPorousFlow_fluid_phase_internal_energy_nodal0/dpressure_variable\" \"dPorousFlow_fluid_phase_internal_energy_nodal0/dtemperature_variable\"\n                             \"dPorousFlow_viscosity_nodal0/dpressure_variable\" \"dPorousFlow_viscosity_nodal0/dtemperature_variable\"\n\n      Material Name:       PorousFlow_density_qp_all_neighbor\n      Property Names:      \"PorousFlow_fluid_phase_density_qp\" \"dPorousFlow_fluid_phase_density_qp_dvar\"\n\n      Material Name:       PorousFlow_viscosity_qp_all_neighbor\n      Property Names:      \"PorousFlow_viscosity_qp\" \"dPorousFlow_viscosity_qp_dvar\"\n      Material Name:       PorousFlow_enthalpy_qp_all_neighbor\n      Property Names:      \"PorousFlow_fluid_phase_enthalpy_qp\" \"dPorousFlow_fluid_phase_enthalpy_qp_dvar\"\n\n      Material Name:       PorousFlow_internal_energy_qp_all_neighbor\n      Property Names:      \"PorousFlow_fluid_phase_internal_energy_qp\" \"dPorousFlow_fluid_phase_internal_energy_qp_dvar\"\n\n      Material Name:       PorousFlow_relative_permeability_qp_all_neighbor\n      Property Names:      \"PorousFlow_relative_permeability_qp\" \"dPorousFlow_relative_permeability_qp_dvar\"\n\n      Material Name:       PorousFlow_relative_permeability_nodal_all_neighbor\n      Property Names:      \"PorousFlow_relative_permeability_nodal\" \"dPorousFlow_relative_permeability_nodal_dvar\"\n\n      Material Name:       PorousFlow_density_nodal_all_neighbor\n      Property Names:      \"PorousFlow_fluid_phase_density_nodal\" \"dPorousFlow_fluid_phase_density_nodal_dvar\"\n\n      Material Name:       PorousFlow_viscosity_nodal_all_neighbor\n      Property Names:      \"PorousFlow_viscosity_nodal\" \"dPorousFlow_viscosity_nodal_dvar\"\n      Material Name:       PorousFlow_enthalpy_nodal_all_neighbor\n      Property Names:      \"PorousFlow_fluid_phase_enthalpy_nodal\" \"dPorousFlow_fluid_phase_enthalpy_nodal_dvar\"\n\n      Material Name:       PorousFlow_internal_energy_nodal_all_neighbor\n      Property Names:      \"PorousFlow_fluid_phase_internal_energy_nodal\" \"dPorousFlow_fluid_phase_internal_energy_nodal_dvar\"\n\n      Material Name:       all_strain_neighbor\n      Property Names:      \"RR_mechanical_strain\" \"RR_rotation_increment\" \"RR_strain_increment\" \"RR_strain_rate\"\n                             \"RR_total_strain\"\n\nAnd here is part of my input file where the problem might be:\n[AuxVariables]\n  [stress_xx]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [stress_yy]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [stress_zz]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n  [porosity]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n    [permeability]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n[]\n\n\n[AuxKernels]\n  [stress_xx]\n    type = RankTwoScalarAux\n    variable = stress_xx\n    rank_two_tensor = stress\n    scalar_type = MinPrincipal\n    point1 = '0 0 0'\n    point2 = '0 0 1'\n    execute_on = timestep_end\n  []\n  [stress_yy]\n    type = RankTwoScalarAux\n    variable = stress_yy\n    rank_two_tensor = stress\n    scalar_type = MidPrincipal\n    point1 = '0 0 0'\n    point2 = '0 0 1'\n    execute_on = timestep_end\n  []\n  [porosity]\n    type = PorousFlowPropertyAux\n    variable = porosity\n    property = porosity\n    execute_on = timestep_end\n  []\n    [permeability]\n    type = PorousFlowPropertyAux\n    variable = permeability\n    property = permeability\n    execute_on = timestep_end\n  []\n[]\n\n\n [Modules/TensorMechanics/Master]\n   [all]\n    strain = SMALL\n    incremental = true\n    add_variables = true\n    generate_output = 'stress_yy creep_strain_xx creep_strain_yy creep_strain_zz elastic_strain_yy'  \n    use_automatic_differentiation = true\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/25193#discussioncomment-6711822",
                          "updatedAt": "2023-08-13T04:10:17Z",
                          "publishedAt": "2023-08-13T04:10:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This looks like you have two stress models, one from the tensor mechanics action and one from one of your materials most probably\nbut I don\u2019t see any called stress_xx\nthe auxvariable and auxkernels for output are not a problem",
                          "url": "https://github.com/idaholab/moose/discussions/25193#discussioncomment-6713232",
                          "updatedAt": "2023-08-13T11:51:04Z",
                          "publishedAt": "2023-08-13T11:50:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Hi. You\u2019re right. It seems my StressDivergenceTensor Kernels are conflicting with my Tensor Mechanics Action. I fixed this by removing and replacing all stress divergence kernels, associated auxk and auxv by:\n[Modules/TensorMechanics/Master]\n  [Modules/TensorMechanics/Master]\n    [Modules/TensorMechanics/Master]\n    strain = SMALL\n    incremental = true\n    add_variables = true\n    generate_output = 'stress_yy stress_xx stress_zz creep_strain_xx'  \n    use_automatic_differentiation = true\n    base_name = RR\n  [block1]\n  block = 'block1'\n  []\n  [block2]\n   block = 'block2'\n  []\n  [block3]\n   block = 'block3'\n  []\n    []\n  []\n[]\n\nNow I\u2019m getting this new error:\nsection '[Modules/TensorMechanics/Master/Modules/TensorMechanics]' does not have an associated \"Action\".\n Common causes:\n- you misspelled the Action/section name\n- the app you are running does not support this Action/syntax",
                          "url": "https://github.com/idaholab/moose/discussions/25193#discussioncomment-6714230",
                          "updatedAt": "2023-08-13T15:52:03Z",
                          "publishedAt": "2023-08-13T15:49:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This syntax is not valid. You're nesting plenty of things,\n[Modules/TensorMechanics/Master]\n  [Modules/TensorMechanics/Master]\n    [Modules/TensorMechanics/Master]\n\nit should be simpler than that",
                          "url": "https://github.com/idaholab/moose/discussions/25193#discussioncomment-6714243",
                          "updatedAt": "2023-08-13T15:53:33Z",
                          "publishedAt": "2023-08-13T15:53:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Yeah, I fixed that a while ago, it works but now I have an old error:\n*** ERROR ***\nThe following error occurred in the object \"RR_stress_yy_block1\", of type \"RankTwoCartesianComponent\".\n\nThe requested non-AD material property 'RR_stress' of type 'RankTwoTensorTempl<double>'\nis already retrieved or declared as a AD property of type 'RankTwoTensorTempl<double>'.\n\nIt seems I\u2019m requesting a non-AD stress from TensorMechanicsAction but I\u2019ve declared and retrieved the stress as an AD property in my perm model. Is there a way around it?",
                          "url": "https://github.com/idaholab/moose/discussions/25193#discussioncomment-6714327",
                          "updatedAt": "2023-08-13T16:15:50Z",
                          "publishedAt": "2023-08-13T16:15:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "So, I went around it by passing use_automatic_differentiation = true to each block of the tensor mechanics action. But I\u2019m getting a new error:\n*** ERROR ***\nThe following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\n\nMaterial property 'stress', requested by 'permeability_block2' is not defined on block block2\nMaterial property 'total_strain', requested by 'permeability_block2' is not defined on block block2\nMaterial property 'stress', requested by 'permeability_block2_face' is not defined on block block2\nMaterial property 'total_strain', requested by 'permeability_block2_face' is not defined on block block2\nMaterial property 'stress', requested by 'permeability_block2_neighbor' is not defined on block block2\nMaterial property 'total_strain', requested by 'permeability_block2_neighbor' is not defined on block block2\nMaterial property 'stress', requested by 'permeability_block3' is not defined on block block3\nMaterial property 'total_strain', requested by 'permeability_block3' is not defined on block block3\nMaterial property 'stress', requested by 'permeability_block3_face' is not defined on block block3\nMaterial property 'total_strain', requested by 'permeability_block3_face' is not defined on block block3\nMaterial property 'stress', requested by 'permeability_block3_neighbor' is not defined on block block3\nMaterial property 'total_strain', requested by 'permeability_block3_neighbor' is not defined on block block3\nMaterial property 'stress', requested by 'permeability_block1' is not defined on block block1\nMaterial property 'total_strain', requested by 'permeability_block1' is not defined on block block1\nMaterial property 'stress', requested by 'permeability_block1_face' is not defined on block block1\nMaterial property 'total_strain', requested by 'permeability_block1_face' is not defined on block block1\nMaterial property 'stress', requested by 'permeability_block1_neighbor' is not defined on block block1\nMaterial property 'total_strain', requested by 'permeability_block1_neighbor' is not defined on block block1\n\nPart of my input file looks like:\n[UserObjects]\n [dictator]\n  type = PorousFlowDictator\n  porous_flow_vars = 'ppressure disp_x disp_y disp_z'\n  number_fluid_phases = 1\n  number_fluid_components = 1\n []\n [pc]\n  type = PorousFlowCapillaryPressureVG\n  alpha = 1E-6\n  m = 0.6\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  gravity = '0 0 0'\n  PorousFlowDictator = dictator\n[]\n\n  [FluidProperties]\n    [water]\n      type = SimpleFluidProperties\n      bulk_modulus = 2e9\n      density0 = 900\n      viscosity = 7e-3\n      thermal_expansion = 0\n    []\n  []\n\n[Variables]\n  [ppressure]       \n    block = ' block1 block2' \n  []\n[]\n\n[AuxVariables]\n    [darcy_vel_x]\n    family = MONOMIAL\n    order = CONSTANT\n    block = ' block1 block2' \n  []\n  [darcy_vel_y]\n    family = MONOMIAL\n    order = CONSTANT\n    block = ' block1 block2' \n  []\n  [darcy_vel_z]\n    family = MONOMIAL\n    order = CONSTANT\n    block = ' block1 block2' \n  []\n  [swater]\n    family = MONOMIAL\n    order = CONSTANT\n    block = ' block1 block2' \n  []\n  [porosity]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n    [permeability]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n[]\n\n[AuxKernels]\n    [darcy_vel_x]\n    type = PorousFlowDarcyVelocityComponent\n    component = x\n    variable = darcy_vel_x\n    fluid_phase = 0                            \n    execute_on = TIMESTEP_END \n    block = ' block1 block2' \n  []\n  [darcy_vel_y]\n    type = PorousFlowDarcyVelocityComponent\n    component = y\n    variable = darcy_vel_y\n    fluid_phase = 0                            \n    execute_on = TIMESTEP_END\n    block = ' block1 block2' \n  []\n    [darcy_vel_z]\n    type = PorousFlowDarcyVelocityComponent\n    component = z\n    variable = darcy_vel_z\n    fluid_phase = 0                            \n    execute_on = TIMESTEP_END\n    block = ' block1 block2' \n  []\n  [swater]\n    type = PorousFlowPropertyAux\n    variable = swater\n    property = saturation\n    phase = 0\n    execute_on = timestep_end\n    block = ' block1 block2' \n  []\n  [porosity]\n    type = PorousFlowPropertyAux\n    variable = porosity\n    property = porosity\n    execute_on = timestep_end\n  []\n    [permeability]\n    type = PorousFlowPropertyAux\n    variable = permeability\n    property = permeability\n    execute_on = timestep_end\n  []\n[]\n\n[ICs]\n  [fluid_pressure]\n    type = ConstantIC\n    variable = ppressure\n    value = 101\n    block = block1\n  []\n []\n\n[Kernels]\n  [time_derivative_water]\n    type = PorousFlowMassTimeDerivative\n    variable = 'ppressure'\n  []\n  [flux_water]\n    type = PorousFlowAdvectiveFlux\n    fluid_component = 0\n    use_displaced_mesh = false\n    variable = 'ppressure'\n  []\n[]\n\n[Materials]\n  [temperature]\n    type = PorousFlowTemperature\n    temperature = 293.15\n    use_displaced_mesh = false\n  []\n  [saturation]\n    type = PorousFlow1PhaseP\n    porepressure = 'ppressure'\n    capillary_pressure = pc\n    block = ' block1 block2' \n  []\n  [massfrac]\n    type = PorousFlowMassFraction\n    block = ' block1 block2' \n  []\n  [water_viscosity_density]\n    type = PorousFlowSingleComponentFluid\n    fp = water\n    phase = 0\n    block = ' block1 block2' \n  []\n  [relperm_water]\n    type = PorousFlowRelativePermeabilityCorey\n    n = 0.0\n    s_res = 0.1\n    sum_s_res = 0.5\n    phase = 0\n    block = ' block1 block2' \n  []\n    [porosity_block1]\n    type = PorousFlowPorosityConst\n    porosity = 0.08\n    block = block1\n  []\n    [porosity_block2]\n    type = PorousFlowPorosityConst\n    porosity = 1.0\n    block = 'block2'\n  []\n    [porosity_block3]\n    type = PorousFlowPorosityConst\n    porosity =  0.0                     \n    block = 'block3'\n  []\n    [permeability_block1]\n     type = newPerm\n     Raw = true\n     flow = rotxy_aux\n    block = block1\n  []\n    [permeability_block2]\n     type = newPerm\n     Raw = true\n     flow = rotxy_aux\n     block = 'block2'\n  []\n    [permeability_block3]\n     type = newPerm\n     Raw = true\n     flow = rotxy_aux  \n     block = 'block3'\n    []\n\n  [elasticity_tensor_block1]\n    type = ADComputeIsotropicElasticityTensor                \n    youngs_modulus = 2.5e1                  \n    poissons_ratio = 0.1\n    block = 'block1'\n    base_name = RR\n []\n  [elasticity_tensor_block2]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 1e11                  \n    poissons_ratio = 0.0 \n    block = 'block2'\n    base_name = RR    \n  []\n  [elasticity_tensor_block3]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 2.1e19                   \n    poissons_ratio =  0.30 \n    block = 'block3'\n    base_name = RR\n  []\n\n  [return_stress]\n    type = ADComputeMultipleInelasticStress\n    inelastic_models = \"new_creep\"\n    combined_inelastic_strain_weights = '1.0'\n  []\n  [new_creep]\n    type = ADNewCreep\n    smin = 1.21e8 \n    smax = 1.88e5    \n    smin_const = 0.87\n    smax_const = 1.21\n    block = 'block1 block3 block2'\n  []\n\n[Modules/TensorMechanics/Master]\n    strain = SMALL\n    incremental = true\n    add_variables = true\n    additional_generate_output = 'stress_yy stress_xx stress_zz creep_strain_xx creep_strain_yy creep_strain_zz elastic_strain_yy'  \n    use_automatic_differentiation = true\n    base_name = RR\n  [block1]\n  block = 'block1'\n    use_automatic_differentiation = true\n  []\n  [block2]\n   block = 'block2'\n   use_automatic_differentiation = true\n  []\n  [block3]\n   block = 'block3'\n   use_automatic_differentiation = true\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/25193#discussioncomment-6714727",
                          "updatedAt": "2023-08-13T17:50:17Z",
                          "publishedAt": "2023-08-13T17:50:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "@hugary1995 @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/25193#discussioncomment-6715463",
                          "updatedAt": "2023-08-13T21:42:07Z",
                          "publishedAt": "2023-08-13T21:42:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Whatever object is in charge of defining permeability is declaring it with the wrong name.\nSo that s why you gets tons of \u201cmissing property\u201d message. You should use the debug show_materials option to get the names in sync",
                          "url": "https://github.com/idaholab/moose/discussions/25193#discussioncomment-6716716",
                          "updatedAt": "2023-08-14T03:14:06Z",
                          "publishedAt": "2023-08-14T03:14:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Yeah, I declared it with the correct name, and I\u2019m back to square one with this error:\n*** ERROR ***\nThe following error occurred in the object \"permeability_block1\", of type \"newPerm\".\n\nThe requested AD material property 'stress' of type 'RankTwoTensorTempl<double>'\nis already retrieved or declared as a non-AD property of type 'RankTwoTensorTempl<double>'.\n\nProbably, the problem is with ADComputeMultipleInelasticStress. I checked the source code and It seems it is not declaring stress as an ADMaterial. I'm certain it is a bug.",
                          "url": "https://github.com/idaholab/moose/discussions/25193#discussioncomment-6717074",
                          "updatedAt": "2023-08-14T04:33:42Z",
                          "publishedAt": "2023-08-14T04:32:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@dschwen wrote this object. Could you please comment on the AD-status and needs here?",
                          "url": "https://github.com/idaholab/moose/discussions/25193#discussioncomment-6722034",
                          "updatedAt": "2023-08-14T15:16:00Z",
                          "publishedAt": "2023-08-14T15:15:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Could you guys help me to set a side (boundary)?",
          "author": {
            "login": "bosxered"
          },
          "bodyText": "Hello, Moose experts.\nI have difficulty setting a 'top' boundary due to its randomness (or anisotropic surface).\nI imported the exodus file from an external meshing utility for the surface roughness.\nBut I found the boundary condition wasn't applied correctly, due to a not-well-defined boundary.\nSo, I tried to set a boundary well and tested various options but all failed.\nHere is my system.\n\nThe green line is the top boundary that I want to set.\nI tested by applying voltage (DirichletBC) and the results are below.\n\nThe green circles say the boundary has problems.\nHere is my input file.\n[Mesh]\n  construct_side_list_from_node_list = true\n  [./fmg]\n    type = FileMeshGenerator\n    file = './S-roughness-1_in.e'\n  []\n  [./subdomain]\n    type = SubdomainBoundingBoxGenerator\n    input = fmg\n    bottom_left = '0.01 14.5 0.0'\n    top_right = '79.99 25.0 0.0'\n    block_id = 1\n  []\n  [./tt]\n    type = SideSetsAroundSubdomainGenerator\n    input = subdomain\n    normal = '0 1 0'\n    new_boundary = 'tt'\n    block = 1\n#    external_only = true\n  []\n  [./tl]\n    type = SideSetsAroundSubdomainGenerator\n    input = tt\n    normal = '-1 0 0'\n    new_boundary = 'tl'\n    block = 1\n#    external_only = true\n  []\n  [./tr]\n    type = SideSetsAroundSubdomainGenerator\n    input = tl\n    normal = '1 0 0'\n    new_boundary = 'tr'\n    block = 1\n#    external_only = true\n  []\n  [./blk_top]\n    type = RenameBoundaryGenerator\n    input = tr\n    old_boundary = 'tt tl tr'\n    new_boundary = 'blk_top blk_top blk_top'\n  []\n\n#  [./blk_top]\n#    type = BoundingBoxNodeSetGenerator\n#    input = fmg\n#    new_boundary = 'blk_top'\n#    top_right = '80.0 25.0 0.0'\n#    bottom_left = '0.0 14.5 0.0'\n#  []\n  [./blk_bot]\n    type = BoundingBoxNodeSetGenerator\n    input = blk_top\n    new_boundary = 'blk_bot'\n    top_right = '80.0 0.01 0.0'\n    bottom_left = '0.0 0.0 0.0'\n  []\n  [./blk_left]\n    type = BoundingBoxNodeSetGenerator\n    input = blk_bot\n    new_boundary = 'blk_left'\n    top_right = '0.01 25.0 0.0'\n    bottom_left = '-0.01 0.0 0.0'\n  []\n  [./blk_right]\n    type = BoundingBoxNodeSetGenerator\n    input = blk_left\n    new_boundary = 'blk_right'\n    top_right = '80.01 25.0 0.0'\n    bottom_left = '79.99 0.0 0.0'\n  []\n#  [./blk_bot]\n#    type = SideSetsAroundSubdomainGenerator\n#    block = 5\n#    new_boundary = 'blk_bot'\n#    normal = '0 -1 0'\n#    input = fmg\n#  [../]\n#  [./blk_top]\n#    type = SideSetsAroundSubdomainGenerator\n#    block = 5\n#    new_boundary = 'blk_top'\n#    normal = '0 1 0'\n#    input = blk_bot\n#  [../]\n#\n#  [./blk_left]\n#    type = SideSetsAroundSubdomainGenerator\n#    block = 5\n#    new_boundary = 'blk_left'\n#    normal = '-1 0 0'\n#    input = blk_top\n#  [../]\n#  [./blk_right]\n#    type = SideSetsAroundSubdomainGenerator\n#    block = 5\n#    new_boundary = 'blk_right'\n#    normal = '1 0 0'\n#    input = blk_left\n#  [../]\n[]\n\n\n[Functions]\n  [./bc_func]\n    type = PiecewiseLinear\n    data_file = './vsweep.csv'\n    format = columns\n    scale_factor = 1.0\n  [../]\n[]\n\n[Variables]\n\n  [./V]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n\n[]\n\n\n[BCs]\n  [V_top]\n    type = FunctionDirichletBC\n    variable = V\n    function = bc_func # GND\n    boundary = blk_top\n  []\n\n  [V_bot]\n    type = DirichletBC\n    variable = V\n    value = 0.0\n    boundary = blk_bot\n  []\n\n#  [V_left]\n#    type = DirichletBC\n#    variable = V\n#    value = 0.01 # GND\n#    boundary = blk_left\n#  []\n#\n#  [V_right]\n#    type = DirichletBC\n#    variable = V\n#    value = 0.0\n#    boundary = blk_right\n#  []\n\n[]\n\n[Kernels]\n\n\n  ########## Electrical ###############\n\n  [./Matdiff_sig_del2_V]\n    type = MatDiffusion\n    variable = V\n    diffusivity = 'electrical_conductivity'\n  [../]\n\n  ########## Electrical END ###########\n\n[]\n\n\n\n\n\n[Materials]\n\n\n  [./electrical_conductivity_TE]\n    type = ParsedMaterial\n    property_name = 'electrical_conductivity'\n    expression = '0.5e-2'\n    outputs = exodus\n  [../]\n\n\n[]\n\n[AuxVariables]\n\n\n  ########### Electric ###########\n  [Ex]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [Ey]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n#  [J]\n#    family = NEDELEC_ONE\n#    order = FIRST\n#  []\n#\n#  [Jy]\n#    order = CONSTANT\n#    family = MONOMIAL\n#  []\n\n  [E_AC_elec]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n#  [Jy_times_x]\n#    order = CONSTANT\n#    family = MONOMIAL\n#  []\n\n  ######### Electric END #########\n\n[]\n\n\n[AuxKernels]\n\n#  [dummy]\n#    type = ParsedAux\n#    variable = dum_x\n#    use_xyzt = true\n#    expression = 'x'\n#  []\n\n  ########## Electric ##########\n  [Ex_aux]\n    type = PotentialToFieldAux\n    variable = Ex\n    gradient_variable = V\n    sign = negative\n    component = x\n  []\n\n  [Ey_aux]\n    type = PotentialToFieldAux\n    variable = Ey\n    gradient_variable = V\n    sign = negative\n    component = y\n  []\n\n#  [current_density]\n#    type = CurrentDensity\n#    variable = J\n#    potential = V\n#  []\n#\n#  [Jy]\n#    type = VectorVariableComponentAux\n#    variable = Jy\n#    vector_variable = J\n#    component = y\n#  []\n\n[]\n\n[Postprocessors]\n\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = 'PJFNK'\n\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre      boomeramg'\n\n  l_max_its = 50\n  nl_max_its = 50\n\n  l_tol = 1.0e-4\n  nl_rel_tol = 1.0e-8\n  nl_abs_tol = 1e-8\n\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    growth_factor = 1.5\n    cutback_factor = 0.5\n    optimal_iterations = 5\n    dt = 1e-4\n  [../]\n  \n#  [./Adaptivity]\n#    interval = 2\n#    refine_fraction = 0.2\n#    coarsen_fraction = 0.3\n#    max_h_level = 3\n#  [../]\n\n\n  dtmin = 1e-13\n  dtmax = 2.5e-2\n\n#  start_time = 0.0\n#  end_time = 27.7\n\n########## For TEST ##########\n  num_steps = 2\n##############################\n\n\n  automatic_scaling = true\n#  compute_scaling_once = false\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  file_base = output\n\n  [myexo]\n    type = Exodus\n    file_base = half\n    interval = 2\n#    start_step = 4340 \n  []\n\n  [mymycp]\n    type = Checkpoint\n    num_files = 10\n    interval = 50\n    file_base = mycp\n  []\n[]\n\nCould you guys help me to set a side (top boundary)?\nThank you\nBest Wishes,\nJeonghwan",
          "url": "https://github.com/idaholab/moose/discussions/25127",
          "updatedAt": "2023-08-16T12:36:55Z",
          "publishedAt": "2023-08-07T18:25:27Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Can you use sidesetsaroundsubdomain with external_only = true?\nThis can pick up jagged edges.\nThere's also ParsedGenerateSideset that can do this, once my PR is merged (so it will take a few more days)",
                  "url": "https://github.com/idaholab/moose/discussions/25127#discussioncomment-6661998",
                  "updatedAt": "2023-08-07T19:07:10Z",
                  "publishedAt": "2023-08-07T19:07:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Thank you. I will try your suggestion and let you know.\nBy the way, is it possible to surf the Moose homepage and read some syntax, now?\nIt was possible about 6 hours ago, but I found it isn't now.\nIs it only my problem?",
                          "url": "https://github.com/idaholab/moose/discussions/25127#discussioncomment-6663815",
                          "updatedAt": "2023-08-08T00:44:28Z",
                          "publishedAt": "2023-08-08T00:44:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "I tried external_only = true and error messages came out.\n\n  [./tt]\n    type = SideSetsAroundSubdomainGenerator\n    input = subdomain\n    normal = '0 1 0'\n    new_boundary = 'tt'\n    block = 1\n    external_only = true\n  []\n  [./tl]\n    type = SideSetsAroundSubdomainGenerator\n    input = tt\n    normal = '-1 0 0'\n    new_boundary = 'tl'\n    block = 1\n    external_only = true\n  []\n  [./tr]\n    type = SideSetsAroundSubdomainGenerator\n    input = tl\n    normal = '1 0 0'\n    new_boundary = 'tr'\n    block = 1\n    external_only = true\n  []\n  [./blk_top]\n    type = RenameBoundaryGenerator\n    input = tr\n    old_boundary = 'tt tl tr'\n    new_boundary = 'blk_top blk_top blk_top'\n  []\n\n*** ERROR ***\n/home2/users/jjh2021/lib/Moose/005_surface_roughness/002_Single/002_RESET/001_roughness1/boundary_test/only_V.i:39: unused parameter 'Mesh/tt/external_only'\n/home2/users/jjh2021/lib/Moose/005_surface_roughness/002_Single/002_RESET/001_roughness1/boundary_test/only_V.i:47: unused parameter 'Mesh/tl/external_only'\n/home2/users/jjh2021/lib/Moose/005_surface_roughness/002_Single/002_RESET/001_roughness1/boundary_test/only_V.i:55: unused parameter 'Mesh/tr/external_only'\n\n\n\n\n\nThere's also ParsedGenerateSideset that can do this, once my PR is merged (so it will take a few more days)\n\nI read about ParsedGenerateSideset and example files. But I don't think it is a really good solution because It seems like I have to define some analytic function that can be expressed by x,y, and z, and distinguish or separate the region. As you can see, my rough surface is really hard to be expressed by x,y, and z and be separated exactly.",
                          "url": "https://github.com/idaholab/moose/discussions/25127#discussioncomment-6665390",
                          "updatedAt": "2023-08-08T05:41:24Z",
                          "publishedAt": "2023-08-08T05:41:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "How old is your moose? when did you last update?\n\n\nYou can use a parsed expression that everything verifies, like x > -10000000 and then use the \"include_only_external\" (once my PR is merged) to just get the external sides",
                          "url": "https://github.com/idaholab/moose/discussions/25127#discussioncomment-6665506",
                          "updatedAt": "2023-08-08T06:01:58Z",
                          "publishedAt": "2023-08-08T06:01:57Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Oh, maybe the version issue. I downloaded the Moose this Feb. Could you tell me how can I update the hpc version Moose? Do I have to download and compile the new version (start from the beginning and PETSc and libMesh building)?\n\n\nI am sorry but I didn't understand your suggestion. What is PR? I could not find the \"include_only_external\" option in the ParsedGenerateSideset.",
                          "url": "https://github.com/idaholab/moose/discussions/25127#discussioncomment-6676617",
                          "updatedAt": "2023-08-09T06:37:26Z",
                          "publishedAt": "2023-08-09T06:33:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes that is too old\nplease follow these instructions for staying up to date\nhttps://mooseframework.inl.gov/moose/getting_started/new_users.html#44fe78f2-40d2-4cda-ad14-4cb3598a2180\nIf you are using PETSc and libmesh built manually (using the moose/scripts), then do NOT use these instructions.\nInstead:\ngit fetch origin\ngit rebase origin/master\ncd scripts\n./update_and_rebuild_libmesh.sh\n\npetsc has not been updated since then",
                          "url": "https://github.com/idaholab/moose/discussions/25127#discussioncomment-6681479",
                          "updatedAt": "2023-08-09T16:00:59Z",
                          "publishedAt": "2023-08-09T15:03:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "I found these messages.\n(base) ~/Moose/moose$ git fetch origin\nremote: Enumerating objects: 40470, done.\nremote: Counting objects: 100% (20139/20139), done.\nremote: Compressing objects: 100% (943/943), done.\nremote: Total 40470 (delta 19266), reused 19876 (delta 19163), pack-reused 20331\nReceiving objects: 100% (40470/40470), 22.62 MiB | 14.81 MiB/s, done.\nResolving deltas: 100% (31815/31815), completed with 3208 local objects.\nFrom https://github.com/idaholab/moose\n   b7007a5..aefe64e  master     -> origin/master\n   ec30cd9..e51cec8  devel      -> origin/devel\n   2246d87..160a3c5  next       -> origin/next\n * [new branch]      scheduled  -> origin/scheduled\nFetching submodule libmesh\nremote: Enumerating objects: 4049, done.\nremote: Counting objects: 100% (3925/3925), done.\nremote: Compressing objects: 100% (803/803), done.\nremote: Total 4049 (delta 3194), reused 3717 (delta 3122), pack-reused 124\nReceiving objects: 100% (4049/4049), 2.52 MiB | 866.00 KiB/s, done.\nResolving deltas: 100% (3210/3210), completed with 1037 local objects.\nFrom https://github.com/libMesh/libmesh\n   9f6a1fa..1a492a9  devel      -> origin/devel\n   18406c8..fffcdd1  master     -> origin/master\nFetching submodule libmesh/contrib/metaphysicl\nremote: Enumerating objects: 97, done.\nremote: Counting objects: 100% (97/97), done.\nremote: Compressing objects: 100% (33/33), done.\nremote: Total 97 (delta 57), reused 90 (delta 53), pack-reused 0\nUnpacking objects: 100% (97/97), done.\nFrom https://github.com/libMesh/MetaPhysicL\n   60042ea..fdba85c  bootstrapped -> origin/bootstrapped\n   4ee1952..5ae7bea  master     -> origin/master\nFetching submodule libmesh/contrib/timpi\nremote: Enumerating objects: 359, done.\nremote: Counting objects: 100% (142/142), done.\nremote: Compressing objects: 100% (26/26), done.\nremote: Total 359 (delta 112), reused 136 (delta 110), pack-reused 217\nReceiving objects: 100% (359/359), 123.26 KiB | 0 bytes/s, done.\nResolving deltas: 100% (181/181), completed with 23 local objects.\nFrom https://github.com/libMesh/TIMPI\n   c02c341..768effc  bootstrapped -> origin/bootstrapped\n   07e64be..4c8be49  master     -> origin/master\n\n(base) ~/Moose/moose$ git rebase origin/master\nCannot rebase: You have unstaged changes.\nPlease commit or stash them.\n\n\nMaybe git fetch origin worked. But I am not sure git rebase origin/master worked well.\nIs it okay to doing next step,\ncd scripts\n./update_and_rebuild_libmesh.sh\n\n?",
                          "url": "https://github.com/idaholab/moose/discussions/25127#discussioncomment-6686178",
                          "updatedAt": "2023-08-10T01:26:36Z",
                          "publishedAt": "2023-08-10T01:26:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No you need to commit your changes before rebasing",
                          "url": "https://github.com/idaholab/moose/discussions/25127#discussioncomment-6686244",
                          "updatedAt": "2023-08-10T01:43:14Z",
                          "publishedAt": "2023-08-10T01:43:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Use git commit -a",
                          "url": "https://github.com/idaholab/moose/discussions/25127#discussioncomment-6686245",
                          "updatedAt": "2023-08-10T01:43:26Z",
                          "publishedAt": "2023-08-10T01:43:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "I followed your suggestion git commit -a and committed all.\nAfter that I rebased it.\nThis is the message of it.\n(base) ~/Moose/moose$ git rebase origin/master\nFirst, rewinding head to replay your work on top of it...\nApplying:       modified:   modules/electromagnetics/test/tests/auxkernels/current_density/current_density.i\nUsing index info to reconstruct a base tree...\nM       modules/phase_field/examples/multiphase/DerivativeMultiPhaseMaterial.i\nM       modules/phase_field/test/tests/KKS_system/kks_xevac.i\nM       scripts/configure_petsc.sh\nM       test/tests/scaling/off-diag-scaling/tests\nM       test/tests/scaling/resid-and-jac-together/tests\nM       test/tests/scaling/scalar-field-grouping/tests\n<stdin>:2682: trailing whitespace.\n\nwarning: 1 line adds whitespace errors.\nFalling back to patching base and 3-way merge...\nRemoving test/tests/scaling/up-to-date-scale-factors/up-to-date-scale-factors.i\nRemoving test/tests/scaling/up-to-date-scale-factors/tests\nRemoving test/tests/scaling/up-to-date-scale-factors/gold/up-to-date-scale-factors_out.e\nCONFLICT (modify/delete): test/tests/scaling/scalar-field-grouping/tests deleted in     modified:   modules/electromagnetics/test/tests/auxkernels/current_density/current_density.i and modified in HEAD. Version HEAD of test/tests/scaling/scalar-field-grouping/tests left in tree.\nRemoving test/tests/scaling/scalar-field-grouping/test.i\nRemoving test/tests/scaling/scalar-field-grouping/gold/test_out.e\nRemoving test/tests/scaling/residual-based/tests\nRemoving test/tests/scaling/residual-based/residual-based.i\nRemoving test/tests/scaling/residual-based/residual-based-two-var.i\nRemoving test/tests/scaling/residual-based/gold/two-var-jacobian.e\nRemoving test/tests/scaling/residual-based/gold/residual-based_out.e\nRemoving test/tests/scaling/residual-based/gold/residual-based-two-var_out.e\nRemoving test/tests/scaling/residual-based/gold/jacobian.e\nCONFLICT (modify/delete): test/tests/scaling/resid-and-jac-together/tests deleted in    modified:   modules/electromagnetics/test/tests/auxkernels/current_density/current_density.i and modified in HEAD. Version HEAD of test/tests/scaling/resid-and-jac-together/tests left in tree.\nRemoving test/tests/scaling/resid-and-jac-together/test.i\nRemoving test/tests/scaling/resid-and-jac-together/gold/together.e\nRemoving test/tests/scaling/resid-and-jac-together/gold/test_out.e\nRemoving test/tests/scaling/remove-singularity/tests\nRemoving test/tests/scaling/remove-singularity/test.i\nRemoving test/tests/scaling/remove-singularity/gold/test_out.e\nRemoving test/tests/scaling/remove-singularity/gold/manual.e\nCONFLICT (modify/delete): test/tests/scaling/off-diag-scaling/tests deleted in  modified:   modules/electromagnetics/test/tests/auxkernels/current_density/current_density.i and modified in HEAD. Version HEAD of test/tests/scaling/off-diag-scaling/tests left in tree.\nRemoving test/tests/scaling/off-diag-scaling/test.i\nRemoving test/tests/scaling/off-diag-scaling/gold/unscaled.e\nRemoving test/tests/scaling/off-diag-scaling/gold/test_out.e\nRemoving test/tests/scaling/off-diag-scaling/gold/off_diag.e\nRemoving test/tests/scaling/ignore-variables/tests\nRemoving test/tests/scaling/ignore-variables/ignore.i\nAuto-merging scripts/configure_petsc.sh\nAuto-merging modules/phase_field/test/tests/KKS_system/kks_xevac.i\nRemoving modules/phase_field/test/tests/KKS_system/kks_example_split.i\nRemoving modules/phase_field/test/tests/KKS_system/kks_example_offset.i\nRemoving modules/phase_field/test/tests/KKS_system/kks_example.i\nAuto-merging modules/phase_field/examples/multiphase/DerivativeMultiPhaseMaterial.i\nRemoving modules/phase_field/examples/kim-kim-suzuki/kks_example_noflux.i\nRemoving modules/phase_field/examples/kim-kim-suzuki/kks_example_dirichlet.i\nRemoving modules/phase_field/examples/anisotropic_interfaces/snow.i\nRemoving modules/phase_field/examples/anisotropic_interfaces/ad_snow.i\nRemoving modules/phase_field/examples/anisotropic_interfaces/GrandPotentialTwophaseAnisotropy.i\nRemoving modules/phase_field/examples/anisotropic_interfaces/GrandPotentialSolidification.i\nRemoving modules/phase_field/examples/anisotropic_interfaces/GrandPotentialPlanarGrowth.i\nFailed to merge in the changes.\nPatch failed at 0001    modified:   modules/electromagnetics/test/tests/auxkernels/current_density/current_density.i\nThe copy of the patch that failed is found in:\n   /home2/users/jjh2021/lib/Moose/moose/.git/rebase-apply/patch\n\nWhen you have resolved this problem, run \"git rebase --continue\".\nIf you prefer to skip this patch, run \"git rebase --skip\" instead.\nTo check out the original branch and stop rebasing, run \"git rebase --abort\".\n\nWhat do I have to do next?",
                          "url": "https://github.com/idaholab/moose/discussions/25127#discussioncomment-6686474",
                          "updatedAt": "2023-08-10T02:15:42Z",
                          "publishedAt": "2023-08-10T02:15:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Just remove the last file indicated then git rebase \u2014continue",
                          "url": "https://github.com/idaholab/moose/discussions/25127#discussioncomment-6686506",
                          "updatedAt": "2023-08-10T02:20:10Z",
                          "publishedAt": "2023-08-10T02:20:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Integral along the boundary",
          "author": {
            "login": "jin0123456"
          },
          "bodyText": "Hello,\n\nI have an integral that looks like this. Some of the variables in the integral term vary with time and position. I want to store the result of this integral as a material property[_qp] because it's location related. Or I want to store such integral values at each integral point of the boundary. How can I do to achieve the results I want in MOOSE?\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/25150",
          "updatedAt": "2023-08-14T03:03:12Z",
          "publishedAt": "2023-08-09T12:54:22Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can create a material property to do this.\nIs your mesh 1D?\nIs this integral from the bottom of the mesh to the current location in the element?\nAre q2, GP, D, F all variables or material properties or functions?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25150#discussioncomment-6681383",
                  "updatedAt": "2023-08-09T14:56:08Z",
                  "publishedAt": "2023-08-09T14:56:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "My mesh is 2D(RZ).\nThe integral is from the bottom to the current location in the element and I need to store this integral value in every locations(every elem) on boundary.\nq2 is material property, GP, D are constant values, F is a function or it can also be a material property.\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/25150#discussioncomment-6686228",
                          "updatedAt": "2023-08-10T01:39:11Z",
                          "publishedAt": "2023-08-10T01:39:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "\u00e9dit: first you will need to form the int\u00e9grand using a ParsedAux\nActually you could try with an auxiliary variable and with a LayeredIntegrzal user object and a SpatialUserOvjectAux to use the user object to fill the variable\nthen in the LayeredIntegrzl you turn on the cumulative option\nthis could work for now. You can work with the order of the variable and the number of layers to get a high resolution",
                          "url": "https://github.com/idaholab/moose/discussions/25150#discussioncomment-6686526",
                          "updatedAt": "2023-08-10T02:48:59Z",
                          "publishedAt": "2023-08-10T02:22:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jin0123456"
                          },
                          "bodyText": "Thanks for your answer,  I have solved the problem in this way.",
                          "url": "https://github.com/idaholab/moose/discussions/25150#discussioncomment-6716643",
                          "updatedAt": "2023-08-14T03:03:13Z",
                          "publishedAt": "2023-08-14T03:03:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A 'Density' is not a registered object",
          "author": {
            "login": "tctheodosiou"
          },
          "bodyText": "Hello,\nI am trying to run the Thermal Mortar Contact problem (https://mooseframework.inl.gov/modules/combined/tutorials/introduction/step01.html)\nI get the following error message:\n*** ERROR ***\nA 'Density' is not a registered object.\nI included TensorMechanics and HeatConduction modules. After searching the documentation, I noticed that Density in mentioned a lot in the \"Combined module\", so I included it as well. Recompiled with make clobberall, and then make. Still Density is not working.\nShould I assume that I should include some other module too? Which? (And how do I determine which modules are needed for each App? e.g. Re. Density, it is not that obvious where to find it).\n(I even reinstall everything dev & prebuilt to make sure that everything is compiled correctly!!!)\nBy the way, the make file didn't have any reference to the Combined module, so I added \"Combined := yes\" by hand. Shouldnt it be in the list when the Makefile was created by stork?\nThank you for your time!",
          "url": "https://github.com/idaholab/moose/discussions/25191",
          "updatedAt": "2023-08-12T16:38:05Z",
          "publishedAt": "2023-08-12T13:24:43Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDensity is part of the miscellaneous module\nTo find where an object comes from, you can do this in moose/:\nfind . | grep \"Density.C\"\n\nor you can use various search features. Or just use the combined module.\nThere is a \"ALL_MODULES\" boolean in the Makefile you could have used\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25191#discussioncomment-6709074",
                  "updatedAt": "2023-08-12T14:39:42Z",
                  "publishedAt": "2023-08-12T14:29:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tctheodosiou"
                          },
                          "bodyText": "Hi Guillaume,\nThank you again for your quick support! Your solution worked (as expected).\nRe. ALL_MODULES, I am aware of that, but in the documentation, it says to avoid all modules to include only what's necessary. (In a worst case scenario, I would enable all modules. But for the moment, I 's like to \"follow the rules\" :) ) In the next case of \"missing object\", I will search for it with find, as you suggested. (Enabling the Combined module, did not solve the problem).\nSorry for my ignorant questions. MOOSE is a huge framework, and I am trying to adapt.",
                          "url": "https://github.com/idaholab/moose/discussions/25191#discussioncomment-6709607",
                          "updatedAt": "2023-08-12T16:24:45Z",
                          "publishedAt": "2023-08-12T16:24:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah yes I would not recommend all_modules, slows down building quite a bit\nno worries",
                          "url": "https://github.com/idaholab/moose/discussions/25191#discussioncomment-6709668",
                          "updatedAt": "2023-08-12T16:36:26Z",
                          "publishedAt": "2023-08-12T16:36:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[PorousFlow] permeability as a function of depth",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi all,\nbelow is my perm object ,it read perm + damage from .csv files so we can assign properties on element basis (not important here).\nI now want to make it a function of depth too, for example\nif z less then 500m, perm_z = perm_z *1.5 something like this\nI think this should be very simple, but I don't know how to bring depth into my class\nKind regards,\nTraiwit\nInputParameters\nPorousFlowPermeabilityConstCSV::validParams()\n{\n  InputParameters params = PorousFlowPermeabilityBase::validParams();\n  params.addParam<RealTensorValue>(\n      \"permeability\",\n      \"The permeability tensor (usually in m^2), which is assumed constant for this material\");\n  params.addParam<UserObjectName>(\"read_prop_user_object\",\n                                      \"The ElementReadPropertyFile \"\n                                      \"GeneralUserObject to read element \"\n                                      \"specific property values from file\");\n  params.addClassDescription(\n      \"This Material calculates the permeability tensor assuming it is constant\");\n  params.addParam<MaterialPropertyName>(\"damage\",0,\"damage\");\n  params.addParam<MaterialPropertyName>(\"flag\", 0 ,\"flag\");\n  return params;\n}\n\nPorousFlowPermeabilityConstCSV::PorousFlowPermeabilityConstCSV(const InputParameters & parameters)\n  : PorousFlowPermeabilityBase(parameters), _damage(getMaterialProperty<Real>(\"damage\")),\n  _read_prop_user_object(isParamValid(\"read_prop_user_object\")\n                             ? &getUserObject<ElementPropertyReadFile>(\"read_prop_user_object\")\n                             : nullptr),\n  _mat_prop(declareProperty<RealVectorValue>(\"Euler_angles\")),\n  _aw(declareProperty<RealVectorValue>(\"aw\")),\n  _kmax(declareProperty<RealVectorValue>(\"kmax\")),\n  _RMD_max(declareProperty<RealVectorValue>(\"RMD_MAX\")),\n  _perm(declareProperty<RealVectorValue>(\"perm_tensor\")),\n  _flag(getMaterialProperty<Real>(\"flag\"))\n{\n}\n\nvoid\nPorousFlowPermeabilityConstCSV::computeQpProperties()\n{\n\n  ////// Aw is given\n  //  read values from .CSV file\n    _mat_prop[_qp](0) = _read_prop_user_object->getData(_current_elem, 0);\n    _mat_prop[_qp](1) = _read_prop_user_object->getData(_current_elem, 1);\n    _mat_prop[_qp](2) = _read_prop_user_object->getData(_current_elem, 2);\n    //_mat_prop[_qp](3) = _read_prop_user_object->getData(_current_elem, 3);\n    //_mat_prop[_qp](4) = _read_prop_user_object->getData(_current_elem, 4);\n    //_mat_prop[_qp](5) = _read_prop_user_object->getData(_current_elem, 5);\n    _aw[_qp](0) = _read_prop_user_object->getData(_current_elem, 6);\n    _kmax[_qp](0)    = _read_prop_user_object->getData(_current_elem, 7);\n    // // calculate perm tensor\n\n    if (_flag[_qp] == 1){\n      _perm[_qp](0) =  1e-18; // pow(10,_damage[_qp]+98)*1e-7;\n      _perm[_qp](1) =  1e-18; // pow(10,_damage[_qp]+98)*1e-7;\n      _perm[_qp](2) =  1e-18; // pow(10,_damage[_qp]+98)*1e-7;\n    }\n    else if (_flag[_qp] == 2) {\n        _perm[_qp](0) =  1e-14; // pow(10,_damage[_qp]+98)*1e-7;\n        _perm[_qp](1) =  1e-14; // pow(10,_damage[_qp]+98)*1e-7;\n        _perm[_qp](2) =  1e-14; // pow(10,_damage[_qp]+98)*1e-7;\n       }\n\n************************************** I want to apply depth to equations below ***************************************\n************************************** I want to apply depth to equations below ***********************************************\n************************************** I want to apply depth to equations below ***********************************************\n\n    else {\n    _perm[_qp](0) = std::min(exp(_damage[_qp]*_aw[_qp](0))*_mat_prop[_qp](0)*1e-7,_kmax[_qp](0)*1e-7); // _kmax[_qp](0)*1e-7\n    _perm[_qp](1) = std::min(exp(_damage[_qp]*_aw[_qp](0))*_mat_prop[_qp](1)*1e-7,_kmax[_qp](0)*1e-7);\n    _perm[_qp](2) = std::min(exp(_damage[_qp]*_aw[_qp](0))*_mat_prop[_qp](2)*1e-7,_kmax[_qp](0)*1e-7);\n       }\n\n\n\nRealTensorValue permeability(  _perm[_qp](0),\n                               0,\n                               0,\n                               0,\n                               _perm[_qp](1),\n                               0,\n                               0,\n                               0,\n                               _perm[_qp](2));\n\n_permeability_qp[_qp]  = permeability;\n\n(*_dpermeability_qp_dvar)[_qp].assign(_num_var, RealTensorValue());\n(*_dpermeability_qp_dgradvar)[_qp].resize(LIBMESH_DIM);\n    for (unsigned i = 0; i < LIBMESH_DIM; ++i)\n(*_dpermeability_qp_dgradvar)[_qp][i].assign(_num_var, RealTensorValue());",
          "url": "https://github.com/idaholab/moose/discussions/25185",
          "updatedAt": "2023-08-12T00:22:23Z",
          "publishedAt": "2023-08-11T08:24:14Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo you are trying to replace the \"file loading\" with a function of depth?\nOr are you trying to have both dependencies?\nFor the former, if the dependency is simple, then a ParsedFunction will do it and you can pull in functions in materials.\nFor the latter, you have the z coordinate in your CSV file right? Could you use that to modify the loaded value by loading the z column and performing the desired operations or is that too coarse?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25185#discussioncomment-6703783",
                  "updatedAt": "2023-08-11T17:01:39Z",
                  "publishedAt": "2023-08-11T17:01:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud it will be the later case, no I do not have z-centroid of the element in the csv, it's assigned based on element ID.\nis  there a way to extract z-centroid for each element via MOOSE?\nRegards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/25185#discussioncomment-6706245",
                          "updatedAt": "2023-08-11T23:43:01Z",
                          "publishedAt": "2023-08-11T23:43:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you want this during a material property computation right?\nthere's a _q_point[_qp] attribute usually available when computing or using material properties that is a Point and can be accessed at index 2 to get the z\nsee the GenericFunctionMaterial code for an example of using coordinates in a material",
                          "url": "https://github.com/idaholab/moose/discussions/25185#discussioncomment-6706382",
                          "updatedAt": "2023-08-12T14:37:32Z",
                          "publishedAt": "2023-08-12T00:22:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error in running a phase field file",
          "author": {
            "login": "mdh23rct"
          },
          "bodyText": "Dear all,\nHope you are doing great! I am a new user of MOOSE. Currently, I am coding to simulate phase field. But, while want to run the file, it is showing the following error:\nA 'SwitchingFunctionMaterial' is not a registered object.\n\nIf you are trying to find this object in a dynamically loaded library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable. \n\nWould you be kind to let me know what is the problem, and how I can solve the problem!!\nI appreciate your help.\nBest regards,\nZahid",
          "url": "https://github.com/idaholab/moose/discussions/25189",
          "updatedAt": "2023-08-11T20:00:52Z",
          "publishedAt": "2023-08-11T16:09:56Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhich executable are you using?\nYou need to be using the phase field module executable, or the executable from an application that includes this module\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25189#discussioncomment-6703626",
                  "updatedAt": "2023-08-11T16:43:06Z",
                  "publishedAt": "2023-08-11T16:43:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "Dear Dr. Guillaume,\nI appreciate your reply. What I am seeing, in the application folder (\\wsl.localhost\\Ubuntu\\home\\user\\projects\\irradiation), there are no modules, though the modules are in the moose folder (\\wsl.localhost\\Ubuntu\\home\\user\\projects\\moose). Unfortunately, the Makefile in the application folder cannot link to the modules of the moose folder. What to do then?\nThe make file in the application folder look like this:\n##############################################################################\n################### MOOSE Application Standard Makefile #######################\n###############################################################################\n#\n# Optional Environment variables\n# MOOSE_DIR        - Root directory of the MOOSE project\n#\n###############################################################################\n# Use the MOOSE submodule if it exists and MOOSE_DIR is not set\nMOOSE_SUBMODULE    := $(CURDIR)/moose\nifneq ($(wildcard $(MOOSE_SUBMODULE)/framework/Makefile),)\n  MOOSE_DIR        ?= $(MOOSE_SUBMODULE)\nelse\n  MOOSE_DIR        ?= $(shell dirname `pwd`)/moose\nendif\n\n# framework\nFRAMEWORK_DIR      := $(MOOSE_DIR)/framework\ninclude $(FRAMEWORK_DIR)/build.mk\ninclude $(FRAMEWORK_DIR)/moose.mk\n\n################################## MODULES ####################################\n# To use certain physics included with MOOSE, set variables below to\n# yes as needed.  Or set ALL_MODULES to yes to turn on everything (overrides\n# other set variables).\n\nALL_MODULES                 := yes\n\nCHEMICAL_REACTIONS          := no\nCONTACT                     := no\nELECTROMAGNETICS            := no\nEXTERNAL_PETSC_SOLVER       := no\nFLUID_PROPERTIES            := no\nFSI                         := no\nFUNCTIONAL_EXPANSION_TOOLS  := no\nGEOCHEMISTRY                := no\nHEAT_CONDUCTION             := no\nLEVEL_SET                   := no\nMISC                        := no\nNAVIER_STOKES               := no\nOPTIMIZATION                := no\nPERIDYNAMICS                := no\nPHASE_FIELD                 := no\nPOROUS_FLOW                 := no\nRAY_TRACING                 := no\nREACTOR                     := no\nRDG                         := no\nRICHARDS                    := no\nSTOCHASTIC_TOOLS            := no\nTHERMAL_HYDRAULICS          := no\nTENSOR_MECHANICS            := no\nXFEM                        := no\n\ninclude $(MOOSE_DIR)/modules/modules.mk\n###############################################################################\n\n# dep apps\nAPPLICATION_DIR    := $(CURDIR)\nAPPLICATION_NAME   := irradiation\nBUILD_EXEC         := yes\nGEN_REVISION       := no\ninclude            $(FRAMEWORK_DIR)/app.mk\n\n###############################################################################\n# Additional special case targets should be added here\n\nI am using the command: ./irradiation-opt -i irradiation.i   to run the file. So irradiation-opt should be the executable. Am I right!\nThanks,\nZahid",
                          "url": "https://github.com/idaholab/moose/discussions/25189#discussioncomment-6703932",
                          "updatedAt": "2023-08-11T17:26:54Z",
                          "publishedAt": "2023-08-11T17:23:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "I think you need to change PHASE FIELD from no to yes in the Makefile in your application, and then recompile. It should be able to find it after that.",
                          "url": "https://github.com/idaholab/moose/discussions/25189#discussioncomment-6703950",
                          "updatedAt": "2023-08-11T17:25:44Z",
                          "publishedAt": "2023-08-11T17:25:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Exactly that. You may need to make clobberall before re-make-ing.",
                          "url": "https://github.com/idaholab/moose/discussions/25189#discussioncomment-6703980",
                          "updatedAt": "2023-08-11T17:27:25Z",
                          "publishedAt": "2023-08-11T17:27:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "Thank you guys for helping me out. Last time, I have given ALL_MODULES := yes. It should turn on all the modules as instructed in the MOOSE help. In addition, this time also made PHASE_FIELD := yes. What I found the same file runs on the first try, but may not run on the second try. I am using WSL shell command. I am not exactly sure what is happening. I am thinking of bugs in the compiler!!\nDo you have any comments on that!",
                          "url": "https://github.com/idaholab/moose/discussions/25189#discussioncomment-6705306",
                          "updatedAt": "2023-08-11T20:00:52Z",
                          "publishedAt": "2023-08-11T20:00:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Quick question on redefining blocks/nodesets/sidesets with MOOSE",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "I use gmsh primarily for meshing but discovered that with local refinement some \"physical groups\" aka block names disappear because they are not tied to the locations in space. So I'm looking for a fix for that.\nI saw someone defining a boundary with MOOSE on another question and was wondering if that would be useful for my case. For example, if I have an existing mesh with no blocks defined (or \"wrong\" blocks defined), can I use some inbuilt MOOSE functions to redefine them?\nFor example, I found \"SubdomainBoundingBoxGenerator\" which, if I understand correctly, takes the lower left and upper right coordinates and assigns all elements within the cubic/3d rectaungular \"box\" defined by those points to a new subdomain ID you can define?\nCan you also do the same for more complex geometries? Say, 3D triangles?\nWhat about for surfaces? In one of the input file examples, I saw \"ParsedGenerateSideset\" where it seems like the area was defined with a parsed mathematical function. So, for example, would a plane rectangular surface on the top be \"(z=0) & (x>0) & (x<x_len) & (y>0) & (y<ylen)\"?\nAlso, I found \"ParsedGenerateSideSet\" accidentally while looking through an example input file. I can't seem to find a list of all available options here, I tried using the url and went to \"https://mooseframework.inl.gov/source/meshgenerators/\" to find a list of them but got a 403 Forbidden error.\nAnother related question is on mesh refinement. Can you use the parsed generate sideset (or something else) to define a \"block\", and then use the mesh refinement option to refine that block alone?",
          "url": "https://github.com/idaholab/moose/discussions/25190",
          "updatedAt": "2023-08-11T19:17:27Z",
          "publishedAt": "2023-08-11T17:13:00Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nBlocks / physical groups should not disappear in the first place. Especially not with mesh refinement.\nYou can use MOOSE redefine blocks in a number of ways. Please have a look at the subdomain generating mesh generators:\nhttps://mooseframework.inl.gov/syntax/Mesh/index.html\nYou can use parsed expressions for more complex geometries. You can also just create your own mesh generator to do it.\nA rectangular plane on top could be:\n\"(z=${top}) & (x>0) & (x<x_len) & (y>0) & (y<ylen)\"?\n\nbut be careful with the equality of floating point numbers. Use this instead:\n\"(z>${top}-1e-8) & (z<${top}+1e-8) & (x>0) & (x<x_len) & (y>0) & (y<ylen)\"?\n\nYou can use the RefineBlockGenerator to refine a single block\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25190#discussioncomment-6703967",
                  "updatedAt": "2023-08-11T17:26:16Z",
                  "publishedAt": "2023-08-11T17:26:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Awesome, thanks! And yeah the problem with blocks disappearing is an issue with gmsh, not MOOSE. (https://gitlab.onelab.info/gmsh/gmsh/-/issues/1786)\nAlso, another question: If existing blocks are already defined, and there is partial overlap with newly created blocks in MOOSE, will the MOOSE blocks override the former? Say, an existing block from an external meshing software is a sphere partially cutting into a rectangular box, and the sphere is defined as a block. If you assign an ID in MOOSE to all elements within the rectangular box (thus, including parts of the sphere), how does it handle that? Can you tell it to ignore original block IDs?\nAlso, will you also be required to assign an ID to the part of the sphere that isn't within the rectangular block or will it just be assumed that any block not explicitly defined belongs to the whole mesh? (i.e, any kernels and materials that don't have the block specified will act on that part)?",
                          "url": "https://github.com/idaholab/moose/discussions/25190#discussioncomment-6704143",
                          "updatedAt": "2023-08-11T17:54:51Z",
                          "publishedAt": "2023-08-11T17:54:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes the later generators take precedence for renaming blocks unless there is a specific parameter to override that (like exclude_subdomain_id)",
                          "url": "https://github.com/idaholab/moose/discussions/25190#discussioncomment-6704353",
                          "updatedAt": "2023-08-11T18:20:28Z",
                          "publishedAt": "2023-08-11T18:20:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}