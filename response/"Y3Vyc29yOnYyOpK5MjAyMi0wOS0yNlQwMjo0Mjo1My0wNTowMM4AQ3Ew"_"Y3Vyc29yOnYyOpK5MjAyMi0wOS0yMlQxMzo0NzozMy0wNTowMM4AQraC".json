{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wOS0yMlQxMzo0NzozMy0wNTowMM4AQraC"
    },
    "edges": [
      {
        "node": {
          "title": "CoupledVarThesholdNodalBCModifier type system exists?",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "I have a mesh with values at the nodes of 0 or 1. If the indicator value is 1, I want to apply a DirichletBC to that node and for the rest of the nodes, I just want to solve some other physics. The indicator field will change every timestep, and can't be determined beforehand. Can someone point me to some code that shows the changing of node sets based on a value or something that could perform the action above? Thank you!",
          "url": "https://github.com/idaholab/moose/discussions/22172",
          "updatedAt": "2022-09-25T07:21:39Z",
          "publishedAt": "2022-09-22T17:11:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can follow the element subdomain modifier code. IIRC modifying the nodeset was actually the easy part of all. You'd modify the boundary info and call meshChanged to reinit the equation system.",
                  "url": "https://github.com/idaholab/moose/discussions/22172#discussioncomment-3713729",
                  "updatedAt": "2022-09-23T02:27:37Z",
                  "publishedAt": "2022-09-23T02:27:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I thought there was some nodeset modifying code in a PR somewhere. I\u2019ll check when I get back",
                          "url": "https://github.com/idaholab/moose/discussions/22172#discussioncomment-3724046",
                          "updatedAt": "2022-09-24T16:32:11Z",
                          "publishedAt": "2022-09-24T16:32:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Let me know if you find it. I created my own that works for my application but will probably need some changes to be general purpose enough to add into MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/22172#discussioncomment-3724092",
                          "updatedAt": "2022-09-24T16:44:22Z",
                          "publishedAt": "2022-09-24T16:44:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Looking at recent activity on this, #21579, seems we do not have this\nWe're definitely interested if you have something working",
                          "url": "https://github.com/idaholab/moose/discussions/22172#discussioncomment-3726305",
                          "updatedAt": "2022-09-25T07:21:39Z",
                          "publishedAt": "2022-09-25T07:21:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Linear iteration residual",
          "author": {
            "login": "xueyang94"
          },
          "bodyText": "Hello, I am wondering what the residual function of the linear iteration is at each nonlinear iteration. Is it dx*J+R, where dx is the solution update, J is the Jacobian, and R is the nonlinear residual? Also, when using Newton as the solver_type, usually only one linear iteration is needed, but sometimes there are more than one linear iterations. Is that an indication of a wrong Jacobian in the kernels?",
          "url": "https://github.com/idaholab/moose/discussions/22188",
          "updatedAt": "2022-09-25T03:02:31Z",
          "publishedAt": "2022-09-24T18:16:01Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "For your first question, almost -- it is preconditioned.\nFor your second question,  if you use a direct solver, usually only one linear iteration is needed, unless the matrix isn't well conditioned. If you use an iterative solver, then you need more than one linear iteration in general.\nIn short, if you use Newton + a direct solver + a full preconditioning matrix, more than one linear iteration is indeed an indication of either\n\ninaccurate Jacobian\na poorly conditioned system",
                  "url": "https://github.com/idaholab/moose/discussions/22188#discussioncomment-3725458",
                  "updatedAt": "2022-09-25T00:48:47Z",
                  "publishedAt": "2022-09-25T00:48:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Note there s a Python utility in moose (jacobian_analyzer) you may use to check your jacobian if you suspect it has issues",
                          "url": "https://github.com/idaholab/moose/discussions/22188#discussioncomment-3725599",
                          "updatedAt": "2022-09-25T01:39:06Z",
                          "publishedAt": "2022-09-25T01:39:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Also residual is scaled if you use manual or automatic scaling",
                          "url": "https://github.com/idaholab/moose/discussions/22188#discussioncomment-3725636",
                          "updatedAt": "2022-09-25T01:57:23Z",
                          "publishedAt": "2022-09-25T01:57:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "Yes I have used the Jacobian debugger before, thanks for pointing it out!",
                          "url": "https://github.com/idaholab/moose/discussions/22188#discussioncomment-3725757",
                          "updatedAt": "2022-09-25T03:02:32Z",
                          "publishedAt": "2022-09-25T03:02:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The difference between _array_grad_test and _grad_test",
          "author": {
            "login": "dingqiushi"
          },
          "bodyText": "Hello,\nIn ArrayDiffusion.C, the residual function uses _array_grad_test , and _grad_test is used in the jacobian function. What's the difference between _array_grad_test and _grad_test, under what circumstances should I use _array_grad_test?\nRealEigenVector\nArrayDiffusion::computeQpResidual()\n{\n  if (_d)\n    return _grad_u[_qp] * _array_grad_test[_i][_qp] * (*_d)[_qp];\n\n  else if (_d_array)\n  {\n    mooseAssert((*_d_array)[_qp].size() == _var.count(),\n                \"diffusion_coefficient size is inconsistent with the number of components of array \"\n                \"variable\");\n    return (*_d_array)[_qp].cwiseProduct(_grad_u[_qp] * _array_grad_test[_i][_qp]);\n  }\n\n  else\n  {\n    mooseAssert((*_d_2d_array)[_qp].cols() == _var.count(),\n                \"diffusion_coefficient size is inconsistent with the number of components of array \"\n                \"variable\");\n    mooseAssert((*_d_2d_array)[_qp].rows() == _var.count(),\n                \"diffusion_coefficient size is inconsistent with the number of components of array \"\n                \"variable\");\n    return (*_d_2d_array)[_qp] * (_grad_u[_qp] * _array_grad_test[_i][_qp]);\n  }\n}\n\nRealEigenVector\nArrayDiffusion::computeQpJacobian()\n{\n  if (_d)\n    return RealEigenVector::Constant(_var.count(),\n                                     _grad_phi[_j][_qp] * _grad_test[_i][_qp] * (*_d)[_qp]);\n  else if (_d_array)\n    return _grad_phi[_j][_qp] * _grad_test[_i][_qp] * (*_d_array)[_qp];\n  else\n    return _grad_phi[_j][_qp] * _grad_test[_i][_qp] * (*_d_2d_array)[_qp].diagonal();\n}",
          "url": "https://github.com/idaholab/moose/discussions/22176",
          "updatedAt": "2022-09-29T17:18:14Z",
          "publishedAt": "2022-09-23T02:30:54Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "_array_grad_test is only for array variables.\n_grad_test is for regular field variables.",
                  "url": "https://github.com/idaholab/moose/discussions/22176#discussioncomment-3721730",
                  "updatedAt": "2022-09-24T04:50:53Z",
                  "publishedAt": "2022-09-24T04:50:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Working of older version of moose",
          "author": {
            "login": "K-Komal-98"
          },
          "bodyText": "I am running a code of 2018 but that is not converging now. So, I want to run an older version of moose of april 2018 to reproduce the results. I followed these steps in order to install the older version:\nconda create -n test moose-mpich\nconda activate test\ncd projects\ncd moose\ngit checkout e1abc87f1b8ca4a7b8ba0b2fd9f803fb2ee31c8     #moose version\nI checked the moose folder and saw that the update_and_rebuild_petsc.sh and many other files are missing. Where can I have gone wrong?\nOn reading the documentation and the forum, 2 more commands has to be run\n./scripts/update_and_rebuild_petsc.sh\n./scripts/update_and_rebuild_libmesh.sh\nbut this cannot be run unless I have the update_and_rebuild_petsc.sh file.",
          "url": "https://github.com/idaholab/moose/discussions/22179",
          "updatedAt": "2022-09-29T17:18:07Z",
          "publishedAt": "2022-09-23T06:16:05Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIn 2018 we probably did not have these scripts. That was 4 years ago. In fact the petsc script is from December 2018\nYou ll have to take these steps manually\nOR\nyou can pull newer versions of the scripts. libmesh and petsc should be fairly backwards compatible\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22179#discussioncomment-3721724",
                  "updatedAt": "2022-09-24T04:45:42Z",
                  "publishedAt": "2022-09-24T04:45:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Adding interpolation from file to PiecewiseLinearInterpolationMaterial",
          "author": {
            "login": "AndrewFalkowski"
          },
          "bodyText": "How difficult would it be to add support for pulling x,y values from a file to the PiecewiseLinearInterpolationMaterial object? This seems like a fairly simple and worthwhile addition given how common pulling materials data from files is. From my understanding the only way to currently replicate this is to use a PiecewiseLinear function and then pull that with a CoupledValueFunctionMaterial, which is somewhat cumbersome.",
          "url": "https://github.com/idaholab/moose/discussions/22181",
          "updatedAt": "2022-09-29T17:18:00Z",
          "publishedAt": "2022-09-23T18:00:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Should be GenericFunctionMaterial for the current way to do this*\nThis would not be too hard. It's just x,y values, no time dependence?\nYou could do it through the PropertyReadFile user object or you could duplicate the machinery in the function",
                  "url": "https://github.com/idaholab/moose/discussions/22181#discussioncomment-3721711",
                  "updatedAt": "2022-09-24T04:40:03Z",
                  "publishedAt": "2022-09-24T04:40:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Heterogeneous permeability data file",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear MOOSE developers and users,\nI mesh a vertical 3D block (x:200m;y:5km; z: 5km ) by tetrahedrons using Gmsh. So I don't have regular structured grids.\nI want to create a heterogeneous permeability data file for my model. I learn the Heterogeneous models . It is helpful for me. But I also need the .data file for my model.\nCould you please tell me which open source software/tool can creat such .data file?\nThank you in advance.\nCheer,\nJoseph",
          "url": "https://github.com/idaholab/moose/discussions/22164",
          "updatedAt": "2022-09-23T15:02:15Z",
          "publishedAt": "2022-09-22T12:59:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "The fundamentals of this file usually come from other modelling, eg, statistical modelling of the subsurface, that is based on field experiments and/or lab data.  This gives you some knowledge of the statistics of the permeability distribution (eg mean, standard deviation).   Alternatively, the information could come from field measurements that you want to interpolate, for instance, you know the permeability close to some well-screens, and you need to interpolate that data to other places in the model.\nIn any case, assuming you have some notion of the permeability field that you want to create, you must create the .data file yourself.  I imagine that usually people use python, because it is open-source and pretty universally used (you can publish your software code to generate the permeability field).  Alternatively, there are probably proprietary packages like Leapfrog, Geomodeller, GoCAD, etc, that can output this information.\na",
                  "url": "https://github.com/idaholab/moose/discussions/22164#discussioncomment-3712735",
                  "updatedAt": "2022-09-22T21:10:29Z",
                  "publishedAt": "2022-09-22T21:10:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "Thanks for your guidance. Andy. I am trying to create this data using Python.\nJoseph",
                          "url": "https://github.com/idaholab/moose/discussions/22164#discussioncomment-3718043",
                          "updatedAt": "2022-09-23T15:02:05Z",
                          "publishedAt": "2022-09-23T15:02:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem about compiling the application",
          "author": {
            "login": "K-Komal-98"
          },
          "bodyText": "Earlier, my application got compiled then I updated the conda and moose according to this link \"https://mooseframework.inl.gov/getting_started/installation/update_moose.html\". Now, I am getting error. I repeated the process but the error continues to exist. Kindly help me with this issue. I have attached the screenshots of the error.",
          "url": "https://github.com/idaholab/moose/discussions/22047",
          "updatedAt": "2022-09-29T17:16:13Z",
          "publishedAt": "2022-09-08T05:09:03Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSee this post\n#21936\nYou need to update the packages using mamba.\nMore information on updating (everything, but you dont need to update moose necessarily) there:\nhttps://mooseframework.inl.gov/getting_started/installation/update_moose.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3591118",
                  "updatedAt": "2022-09-08T05:11:50Z",
                  "publishedAt": "2022-09-08T05:11:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "K-Komal-98"
                          },
                          "bodyText": "I updated the packages using mamba but the error is still there. I followed exactly the same instructions given in the link.",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3591270",
                          "updatedAt": "2022-09-08T05:46:00Z",
                          "publishedAt": "2022-09-08T05:46:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I've seen this on Ubuntu (22.04)... Can you provide a mamba list? And also the version of Ubuntu you are using.\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3594190",
                          "updatedAt": "2022-09-08T12:36:37Z",
                          "publishedAt": "2022-09-08T12:36:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Also, if you can refrain from posting pictures of text to these discussions it will help others down the road when performing 'searches' of possibly the same issue you are experiencing.",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3594244",
                          "updatedAt": "2022-09-08T12:43:43Z",
                          "publishedAt": "2022-09-08T12:43:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "K-Komal-98"
                          },
                          "bodyText": "I am working on Ubuntu (22.04). I reinstalled MOOSE and now I am not getting this error but a different one. The error is as follows:\nLinking Executable /home/komal/projects/nucleation_bm/nucleation_bm-opt...\n/home/komal/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.4.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/komal/projects/nucleation_bm/lib/libnucleation_bm-opt.so: undefined reference to `InputParameters validParams()'\ncollect2: error: ld returned 1 exit status\nmake: *** [/home/komal/projects/moose/framework/app.mk:416: /home/komal/projects/nucleation_bm/nucleation_bm-opt] Error 1",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3624765",
                          "updatedAt": "2022-09-12T10:47:17Z",
                          "publishedAt": "2022-09-12T10:47:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "K-Komal-98"
                          },
                          "bodyText": "Can you please help me with this error?",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3624846",
                          "updatedAt": "2022-09-12T10:58:15Z",
                          "publishedAt": "2022-09-12T10:58:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ats5662"
                          },
                          "bodyText": "This worked for me\nmamba activate moose\nmamba update --all\nsudo apt-get install lsb-core\ncd ~/projects/moose\nunset LIBMESH_DIR\n./scripts/update_and_rebuild_libmesh.sh",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3626562",
                          "updatedAt": "2022-09-12T14:21:18Z",
                          "publishedAt": "2022-09-12T14:18:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is a conda-based install, you should not run the scripts\nthis error on validParams is likely due to the deprecation of the validParams template. See this post\nhttps://mooseframework.inl.gov/newsletter/2020_04.html#!\nis your app (nuclearion_bm?) open source? So I could try to build it locally\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3627205",
                          "updatedAt": "2022-09-12T15:25:56Z",
                          "publishedAt": "2022-09-12T15:25:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "K-Komal-98"
                  },
                  "bodyText": "I reinstalled many times and now finally the problem is solved. Thankyou!",
                  "url": "https://github.com/idaholab/moose/discussions/22047#discussioncomment-3714369",
                  "updatedAt": "2022-09-23T05:55:06Z",
                  "publishedAt": "2022-09-23T05:55:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about the Function block.",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "I use the method getFunction in Kernel.And I wrote  std::cout<<_ufun.value(_t,_q_point[_qp])<<std::endl; in the precomputeQpResidual() of a ADDiffusion case. _ufun is from _ufun(getFunction(\"function\")).\nThe Function block in input file is like this:\n[Functions]\n[./UFUN]\ntype = PiecewiseLinear\nx = '0 1'\ny = '0 1'\n[../]\n[]\nIt only output 0 in the terminal. It should output the variable's values at quadrature points right? I don't know what went wrong.By the way, the mesh is 1D and xmin = 0 xmax = 1.",
          "url": "https://github.com/idaholab/moose/discussions/22167",
          "updatedAt": "2022-09-23T02:40:08Z",
          "publishedAt": "2022-09-22T13:45:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Ethan-xj"
                  },
                  "bodyText": "It seems like it only output the y value at the first point of x",
                  "url": "https://github.com/idaholab/moose/discussions/22167#discussioncomment-3709690",
                  "updatedAt": "2022-09-22T13:51:35Z",
                  "publishedAt": "2022-09-22T13:51:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Ethan-xj"
                  },
                  "bodyText": "OK. I missed the axis should be x.",
                  "url": "https://github.com/idaholab/moose/discussions/22167#discussioncomment-3713761",
                  "updatedAt": "2022-09-23T02:40:06Z",
                  "publishedAt": "2022-09-23T02:40:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Assembling to Scalar Variable Residual from Mortar Constraint",
          "author": {
            "login": "ttruster"
          },
          "bodyText": "I find myself needing to implement coupling between a scalar variable into a mortar constraint residual and Jacobian and vice versa. I have looked closely over the ScalarLagrangeMultiplier Kernel and the AverageValueConstraint Scalar Kernel for diffusion as well as Homogenization files (Constraint user object, scalar kernel, and off-diagonal Jacobian kernel) for the Tensor Mechanics system. It seems that the \"MOOSE way\" to do this would require a:\n\nMortar Constraint for the off-diagonal Jacobian (I have implemented)\nScalar Kernel to handle the residual and Jacobian of the scalar variable (I have made a hard-coded version)\nA User Object that performs integration over a Mortar lower dimensional boundary object to compute the terms needed in the Scalar Kernel (non-existent in the MOOSE framework or modules; would require some framework expansion)\n\nAs a temporary work-around, I have tried adding direct assembly calls within the Mortar Constraint object for vector-residual and matrix-Jacobian blocks associated with the scalar variable. I'm using calls similar to those in ScalarLagrangeMultiplier and HomogenizedTotalLagrangianStressDivergence, which assembly to the upper and lower blocks of the Jacobian at the same time. They are happening through additional calls (quadrature loops and functions) that I embedded within the ComputeResidual and ComputeOffDiagonalJacobianScalar method calls of the MortarConstraint and MortarConstraintBase files. I have attached a sample of the source code with the loops.\nsrc.txt\nI can confirm from debug-mode that computations are occurring in the Residual Scalar calculation during the time when the Mortar Constraint ComputeResidual method is called. However, it doesn't seem like those values are getting into the global system residual, since the analysis finishes with a zero Nonlinear Residual norm.\nSo, question:  am wondering if it is not possible to assemble residual contributions into other/coupled variables (i.e. the test function rows) different from the primary variable of the object, without modifying the tagging/caching/low-level assembly calls within MOOSE framework that are looping over the objects? The symmetric-block access for the Jacobian within ScalarLagrangeMultiplier gave me hope that would be possible. Of course it is not \"appropriate\" according to MOOSE design, but didn't know if it is technically not feasible.\nThe long term resolution is to make a user-object that has reference to the mortar subdomain mesh and system, to perform the quadrature. I might be able to get that to happen through either a SideUserObject.execute or a DomainUserObject.executeOnBoundary call, if I can get the Two Material System coupled into those. The MortarFrictionalPressureVectorAux AuxKernel gives me hope for doing that, since it also references the mortar mesh and data structure but outside of a Mortar Constraint object. Any clues for going down this route?\nThanks for reading, and suggestions welcome!\nTim",
          "url": "https://github.com/idaholab/moose/discussions/22020",
          "updatedAt": "2022-10-14T03:24:56Z",
          "publishedAt": "2022-09-06T19:34:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "reverendbedford"
                  },
                  "bodyText": "This is exactly analogous to the homogenization constraint stuff in the Lagrangian kernels, right?  So I take it you can't use a ElementUserObject to loop over the lower-dimension mortar blocks?  Shouldn't they just be standard 2D domains (in a 3D problem)?",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3585443",
                  "updatedAt": "2022-09-07T13:56:07Z",
                  "publishedAt": "2022-09-07T13:56:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "The problem is that the \"local\" scalar residual information is not getting incorporated into global data. Here are revised code snippets that should work\nvoid\nVMNTPeriodicBase::::computeResidual()\n{\n  setNormals();\n\n  precalculateResidual();\n\n  if (_compute_primal_residuals)\n  {\n    // Compute the residual for the secondary interior primal dofs\n    computeResidual(Moose::MortarType::Secondary);\n\n    // Compute the residual for the primary interior primal dofs.\n    computeResidual(Moose::MortarType::Primary);\n  }\n\n  if (_compute_lm_residuals)\n    // Compute the residual for the lower dimensional LM dofs (if we even have an LM variable)\n    computeResidual(Moose::MortarType::Lower);\n\n  if (_compute_scalar_residuals)\n    // Compute the residual for the scalar dofs\n    computeResidualScalar();\n}\n\n\n\nvoid\nVMNTPeriodicBase::computeResidualScalar()\n{\n  prepareVectorTag(_assembly, _kappa_var);\n  for (_qp = 0; _qp < _qrule_msm->n_points(); _qp++)\n  {\n    precalculateMaterial();\n    for (_h = 0; _h < _k_order; _h++)\n      _local_re(_h) += _JxW_msm[_qp] * _coord[_qp] * computeQpResidualScalar();\n  }\n\n  accumulateTaggedLocalResidual();\n\n  for (const auto tag_id : _vector_tags)\n  {\n    const auto & vector_tag = _subproblem.getVectorTag(tag_id);\n    _assembly.addResidualScalar(vector_tag);\n  }\n}\nThe call to _assembly.addResidualScalar is the important new piece that takes the local residual and adds it into global residual information",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3585750",
                  "updatedAt": "2022-09-07T14:28:35Z",
                  "publishedAt": "2022-09-07T14:28:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "Thanks for suggestions. I've got a summary at the bottom, about the topic of add-Jacobian needs and about user objects.\nI switched the residual assembly to use the tagging system. The compiler complained that\nAssembly::addResidualScalar(const VectorTag&)\u2019 is protected within this context\nAnd so instead I made a call to\n_fe_problem.addResidualScalar();\nThat is in the attached file, with all the other assemblies I am trying to run.\nVMNTPeriodicBase.txt\nI was able to run a test case for heat conduction with mortar periodic conditions and a macro heat flux (analogous to macro stress) imposed, and the analysis solves for the macro thermal gradient as a scalar variable and the temperature field as a Lagrange variable. The analysis converges with the PJFNK solver and gives the correct result for both solution fields.\nHowever, now this issue is that the off-diagonal mortar constraint Jacobian (coupling secondary variable and scalar variable) seem not to be accumulating/adding. When I use the NEWTON solve type, then the residual diverges. When I comment out or otherwise change around the code in the \"computeOffDiagJacobianScalar\" function, the residual normal are identical, which suggests to me that this code isn't getting added to the global Jacobian.\nI've been self-studying on the Problem, System, Loops, and Assembly source files through doxygen to try and learn the ways that local residual/Jacobian blocks get assembled to the global arrays. It seems that each object type (kernel, dgkernel, scalarkernel, ...) get handled at different places; some of them involve caching while the \"ComputeMortarFunctor\" file seems to have less provisions for scalar and off-diagonal variable couplings.\nI've made a couple attempts at getting the local data into the global; those are in the comments of the attached .txt (a .C) file.\nOne thing that mystifies me: the \"ScalarLagrangeMultiplier\" object only contains two lines that give an allocation to a DenseMatrix; there are no calls to an accumulate or an add-Jacobian function below that. My gut says that probably those values need to go into the specially named ken and kne arrays, and that they are swept up by the caching that happens in \"ComputeFullJacobianThread\" and \"NonlinearSystemBase\". But without knowing where to look, I'm not sure what code to copy in order to handle the Secondary-scalar, Primary-Scalar, and Lower-Scalar (and the transposes) assemblies that I need to accumulate.\nIn short, I've been gathering a list of needed assembly and pre-calculate Residual etc. functions that are available for Kernels and are missing in some of the object systems. If it helps, I could be working on the framework to add those and then do a pull request; this would be my first time, so some guidance would help (i.e. I probably need to read this https://mooseframework.inl.gov/framework/contributing.html)\nAbout User Objects: yeah I've been thinking about the minimal integrals needed and I may be able to get by with two single-side integrals rather than having to do a coupled Mortar integral, if I can somehow grab material properties from the opposite element face across the mortar segment pair. It's yet to be seen whether I should try that with an Element user object on 2d blocks (can they be called on the mortar sub-problem?) or if instead needs to happen on the 3d problem Side sets user object.",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3600488",
                  "updatedAt": "2022-09-08T20:52:14Z",
                  "publishedAt": "2022-09-08T20:52:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The problem with\n\n_fe_problem.addResidualScalar();\n\nis that it's not going to honor the vector tags requested by the user for their constraint object. It's going to add to all vectors that are of residual type. A better solution is to make the individual vector tag API that is currently protected public.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3602465",
                          "updatedAt": "2022-09-09T00:22:43Z",
                          "publishedAt": "2022-09-09T00:22:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "About User Objects: yeah I've been thinking about the minimal integrals needed and I may be able to get by with two single-side integrals rather than having to do a coupled Mortar integral, if I can somehow grab material properties from the opposite element face across the mortar segment pair. It's yet to be seen whether I should try that with an Element user object on 2d blocks (can they be called on the mortar sub-problem?) or if instead needs to happen on the 3d problem Side sets user object.\n\nFor fundamental assembly operations I would be hesitant about a design that includes user objects. If user objects are being included, to me that indicates that we don't have friendly enough APIs on our _sys, _assembly, or _subproblem to get your job done, when we really should.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3602478",
                          "updatedAt": "2022-09-09T00:26:22Z",
                          "publishedAt": "2022-09-09T00:26:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "There is definitely some help we need to give you here and at least some framework development that will need to happen. I need to think about this a bit more in order to give you good help (hopefully tomorrow). In the mean time, if you are motivated to do some moose development, please do! We love contributions!",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3602558",
                          "updatedAt": "2022-09-09T00:45:56Z",
                          "publishedAt": "2022-09-09T00:45:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Regarding framework support, I wonder if we can't add an \"integrated\" scalar kernel which loops over the elements to assemble the residual, Jacobian, and off-diagonal Jacobians for a scalar variable. The objects Tim mentioned, e.g. ScalarLagrangeMultiplier, AverageValueConstraint, and HomogenizationConstraintIntegral, will all benefit from having such loop in the framework.\nThe main reason that the Homogenization system in tensor mechanics need to use an ElementUserObject is to retrieve material properties. If we embrace that integrated scalar kernel idea, then we will no longer need such a user object, since we can bring the MaterialInterface into the integrated scalar kernel.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3602881",
                          "updatedAt": "2022-09-09T02:03:11Z",
                          "publishedAt": "2022-09-09T02:03:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "Having \"integrated\" scalar kernels to allow coupling of regular variables and scalar variables would definitely be one way to solve the problems above. They originate from needing to evaluate weak form terms (integrals) have products of variables, scalars, and materials.\nThe \"issue\" is that those integrals would be needed (in the long term) over all the different types of integrals. For my current project goals, I will end up needing integrals for kernels, interfacekernels, and mortar constraint objects to couple with scalar variables. DG-kernels and integrated BCs would be later in the future if cohesive-zone-like damage would be included.\nSo the current approach with the ScalarLagrangeMultiplier, AverageValueConstraint, and HomogenizationConstraintIntegral objects has been instead to use the integration methods that are present within user objects to handle the regular variable and material couplings, and then multiply the integral result onto scalar variable within the kernel; and just make sure the user object gets called on each linear execute.\nSo that seems as a design philosophy question, as to whether enough folks see the utility to have the full coupling ability and put all the scalar integrals as derivatives off of the scalar kernel. Or to just finish expanding the coverage of user objects to handle mortar constraint objects or any other \"missing\" cases.\nThat's where my hiccups have been so far, is needing to figure out which assembly accumulation is missing for various coupling, as well as how to get the integrals done.\nI figured my hack for calling the _fe_problem.addResidualScalar(); might not be great, but I figure that the tagging API is probably protected so that most normal users/developers don't \"mess up\" or call in the tag additions where they shouldn't be.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3602954",
                          "updatedAt": "2022-09-09T02:22:00Z",
                          "publishedAt": "2022-09-09T02:21:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "Well, I spent a few hours on Friday night and then did some thinking over the last few days related to the topic of mortar user objects and assembly of scalar variable contributions. I'm going to break the assembly off into another thread to raise an issue there.\nFor the Mortar User Object, I'm pretty sure what needs to happen is to add this object class into computeUserObjectsInternal as well as the initialization locations for user objects, so that this is on the same level as element, side, interface, or domain user objects. Thus, a loop over all mortar user objects would be needed, and so I should emulate what computeMortarFunctor does for looping over MortarConstraintBase objects to collect the residual and/or Jacobian contributions.\nAdding this new type of user object is necessary because:\n\nOnly specialized mortar objects are able to generate the container of material properties and other data needed for the mortar segment calculations, namely loopOverMortarSegments()\nEven for conforming primary/secondary meshes in 3d, for history-dependent or complex material models, the use of quadrature points from a full element side integral are different than the segments, so the accuracy of the computations would degrade compared to using the same quadrature points for both user object and constraint residual integrals\n\nI would like to open an issue with the objective of programming a \"MortarUserObjectBase\" class and the necessary initialization/loops to fit within the user object system. The while the base class would not contain integrals (so you could make other types of mortar objects from it), a derived class with the integration would also be developed.\nThe target application of these developments are:\nProblems involving scalar variables coupled to standard variables along mortar surfaces. An example of this class of problems is: imposition of periodic boundary conditions through surface integration and either penalty, Nitsche, or Lagrange multiplier field methods.\nI've been spending time looking through the framework code, and I have some ideas to get started with, I'll need some discussion/help in the process. This will be my first time working on an issue; I've already forked the main repository and am starting to make commits on the side.",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3645431",
                  "updatedAt": "2022-09-14T14:39:15Z",
                  "publishedAt": "2022-09-14T14:39:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Is there more to this problem than just missing Jacobian accumulations for the scalar variable? That seems like just one missing API call. We are going down what seems like too large a development path if that is the only problem. The missing Jacobian accumulation call is likely very akin to what was the missing residual accumulation call. If that is the only problem, then if you create a branch with a MNWE (minimal non-working example), then I think we could get this solved pretty quickly. (I generally prefer branches over shared text files because then it is much easier to document improvements via commits)",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3648443",
                          "updatedAt": "2022-09-14T21:16:23Z",
                          "publishedAt": "2022-09-14T21:16:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "We can avoid the user object route if we do 3 of the 4 needed Jacobian (scalar to variable, variable to scalar, and scalar to scalar) and 2 of the 2 needed residual (variable and scalar) computations all within one Mortar Constraint. This was the \"hacky\" way I proposed at the top, since it seems to violate the MOOSE goal of 'each object compute and assemble contributions only to the variable it owns', i.e. to one row of the Jacobian and residual (variable to variable handled in another constraint file, and scalar to variable). I'm also wondering if there is potential value to open up user objects and post processors that do loops over mortar segments for some other purposes.\nI terms of a MNWE, I have my forked repo here: https://github.com/Truster-Research-Group/moose-clmi_lab\nAgain, first timer: should I put the test input file in the /test/test directory somewhere, the needed .C and .h files for the code I've created which needs the accumulate commands within /test/src and /test/include respectively, and make a commit saying what file to run, push that commit to my repo, and let you know about it by posting on the forum here? Or can you paste a link to a forum post that has the process I should emulate?",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3649231",
                  "updatedAt": "2022-09-15T00:32:02Z",
                  "publishedAt": "2022-09-15T00:32:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "What is this scalar variable? What does it represent physically? Does it have other residual objects that contribute to its residual/Jacobian? I would say that the MOOSE philosophy is to (loosely) have an object per physics/PDE-term. Mortar constraints themselves can already contribute residuals/Jacobians to three different variables (secondary variable, primary variable, LM variable).\n\nAgain, first timer: should I put the test input file in the /test/test directory somewhere, the needed .C and .h files for the code I've created which needs the accumulate commands within /test/src and /test/include respectively, and make a commit saying what file to run, push that commit to my repo, and let you know about it by posting on the forum here?\n\nI would just keep your code in whatever directories you already have them in. You can also put your input wherever you want. I can see where all your files are located just by running commands like git show --name-only HEAD. Before committing and pushing you might want to checkout a new branch (something like git checkout -b non-working-scalar-in-mortar)",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3649667",
                          "updatedAt": "2022-09-15T02:13:03Z",
                          "publishedAt": "2022-09-15T02:13:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "Hit the enter key...\nThere are two scalar variables for this problem: the macro flux-gradient prescribed through an aux-variable, and the macro actual gradient solved for alongside the concentration field. For solid mechanics, these are analogous to macro-stress and macro-strain, respectively, applied to an RVE. Theory for Nitsche method version is described here https://www.sciencedirect.com/science/article/pii/S0045782519305481 and the mortar version is described here https://www.sciencedirect.com/science/article/pii/S0045782514000528.\nThe scalar variable is coupled/integrated along each RVE boundary pair, which likely are doing to be different mortar surfaces. Yet they are pretty much going to involve the same variables each time.\nAs seen in the example, the residual/Jacobian terms of the primary to secondary variable can be handled in a different object than the terms involving products of the primary/secondary with the scalar variable. Or you could put those terms within the same object with the scalar; I split them up here to illustrate the point.\nIn short, the term from the paper above that I've implemented is { [w1-w2] - dxkappa } * tau * { [u1-u2] - dxepsilon } where 1=primary, 2=secondary, epsilon is the scalar unknown (macro gradient [u,x u,y]), u is the variable unknown, dx = [x1-x2, y1-y2] in 2d, and w/kappa are the weighting functions. So if you call this \"one term\", then yes it can all go into one object.\nAbout the performance: right now, the PJFNK method is used so that it will converge. Using Newton doesn't converge because the off diagonal Jacobian Scalar terms aren't getting assembled. I have also left the residual assembly with the _fe_problem object instead of _assembly.addResidualScalar for the time being. But I'm going to be adding some other examples in the next couple days that try that after changing it to a public method.\nLet me know your thoughts, thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3670837",
                  "updatedAt": "2022-09-17T19:35:00Z",
                  "publishedAt": "2022-09-17T19:35:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Is the branch name non-working-scalar-in-mortar?",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3676504",
                          "updatedAt": "2022-09-18T23:38:07Z",
                          "publishedAt": "2022-09-18T23:38:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@jbadger95, Nitsche method (but for periodic boundary constraints as opposed to mechanical contact constraints)",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3676507",
                          "updatedAt": "2022-09-18T23:45:18Z",
                          "publishedAt": "2022-09-18T23:38:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "Yes, that's the branch; others are for other in progress work.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3677257",
                          "updatedAt": "2022-09-19T03:19:19Z",
                          "publishedAt": "2022-09-19T03:19:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ttruster"
                  },
                  "bodyText": "I added another test case of scalar variables using the Kernel this time, into the non-working-scalar-in-mortar. There is a base class KernelScalarBase which expands the Kernel computations to act on a second coupled variable (a scalar). I created it using LowerDIntegratedBC as a model for how to add the contributions from the 2nd variable and reuse the quadrature loops and methods of the underlying class.\nAs a test case, I copied over the ScalarLagrangeMultiplier and AverageValueConstraint contributions to be in the single derived class ScalarLMKernel. I also copied the test case scalar_constraint_kernel.i and modified it to have syntax for this new object.\nThere are some comments in the file about 'temporary' fixes to make it execute. The good news is, the solution converges to the same analytical result that the existing 3 object system (with a post processor integral) does, which means the residual is being assembled; the bad news is that the convergence is slow, so something is off with the Jacobian. I literally copied the Dense Matrix calls from the existing objects, and this is deriving from the same Kernel class; although I am using the Kernel's off diagonal Scalar method for computing one of the contributions.\nThoughts? Again, some Jacobian accumulation/adding seems to be missing.",
                  "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3686129",
                  "updatedAt": "2022-09-20T02:43:14Z",
                  "publishedAt": "2022-09-20T02:43:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "I spoke too soon and didn't look closely at the iteration type: in fact, it is doing linear/matrix solver iterations, not Newton iterations.\nI confirmed after adding an off diagonal scalar method using dense matrix assembly, identical to ScalarLagrangeMultiplier, that the linear iterations are identical for the new and old systems. Also, with a new input file scalar_constraint_kernel_LU.i which uses an LU solver and Newton method, that indeed there is just one iteration.\nSo the Dense Matrix approach seems to work for the Kernel objects, but does not work for the Constraint or Interface-Kernel objects (yet). Thoughts on why that is?\nAlso, I've been wondering how either the Dense Matrix or the tagged scalar vectors/matrices will work in parallel (threaded/OpenMP or distributed/MPI) cases? I've been running it with one thread so far. The adding of the residual from multiple threads to the same scalar variable rows probably creates a race condition.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3690121",
                          "updatedAt": "2022-09-20T12:50:14Z",
                          "publishedAt": "2022-09-20T12:50:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "we have mutex locks to ensure no race conditions when attempting to add or insert into the global vector or matrix",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3701863",
                          "updatedAt": "2022-09-21T15:51:48Z",
                          "publishedAt": "2022-09-21T15:51:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "So the Dense Matrix approach seems to work for the Kernel objects, but does not work for the Constraint or Interface-Kernel objects (yet). Thoughts on why that is?\n\nDifferent calls to different assembly methods after the residual object jacobian routines. I hope to run your code soon to verify. Fixing this should just be a couple line addition in framework code",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3701869",
                          "updatedAt": "2022-09-21T15:53:44Z",
                          "publishedAt": "2022-09-21T15:53:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ttruster"
                          },
                          "bodyText": "Thanks. I also made a couple more commits related to the kernel plus scalar coupling. Now that class can act as a pseudo-intermediate class to add coupling to scalars but not require the scalar to be used in the derived classes. This would help for the tensor mechanics homogenization case, where that class derives 3 levels down from the Kernel class. The example test shows the Diffusion Kernel can derive from it instead and not use a scalar.\nMaybe these can point out some things about assembly too.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3711273",
                          "updatedAt": "2022-09-22T17:00:51Z",
                          "publishedAt": "2022-09-22T17:00:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "There are so many routines in TestPeriodicBase it's hard for me to wrap my head around what is adding to what. Can you tell me exactly what routines do these couplings?\n\nfield-scalar\nscalar-field\n\nI assume field-scalar is done solely by computeOffDiagJacobianScalar, but I want to be sure.\nPlease respond within this thread (via 'Reply') while we're on this topic. It's hard for me to keep track of the thread of conversation when there are multiple Answers addressing the same thread of conversation.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3712234",
                          "updatedAt": "2022-09-22T19:31:20Z",
                          "publishedAt": "2022-09-22T19:30:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Actually I've created issue #22174, so let's continue this over there.",
                          "url": "https://github.com/idaholab/moose/discussions/22020#discussioncomment-3712326",
                          "updatedAt": "2022-09-22T19:45:11Z",
                          "publishedAt": "2022-09-22T19:45:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MetaPhysicL error in ThreadedElementLoopBase",
          "author": {
            "login": "czadeh"
          },
          "bodyText": "Hello,\nI added a new material property to an application I have been working on and now I get an error when I run an input file with the new MP.\nI have 2 AD variables and now 4 MPs. My input file without the new MP runs fine, but now I am getting this error:\n*** ERROR ***\nWe caught a MetaPhysicL error in ThreadedElementLoopBase. This is very likely due to AD not having a sufficiently large derivative container size. Please run MOOSE configure with the '--with-derivative-size=' option\nIs this normal? Should I change the derivative size? If so, how?\nThanks,\nCameron",
          "url": "https://github.com/idaholab/moose/discussions/22033",
          "updatedAt": "2022-09-29T17:15:56Z",
          "publishedAt": "2022-09-07T17:35:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat do you mean by MP?  material property right?\nThis error can happen with AD. You should do what the prompt says. The default is 53 for the container size, you may try like 100 at first.\nIn the moose/ folder, run ./configure --with-derivative-size=100\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3588507",
                  "updatedAt": "2022-09-07T19:53:20Z",
                  "publishedAt": "2022-09-07T19:40:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "Sorry, I meant material property. I will try that and let you know.",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3588650",
                          "updatedAt": "2022-09-07T20:03:54Z",
                          "publishedAt": "2022-09-07T20:03:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "Still getting that error even when I keep increasing the derivative size up to 2000. Perhaps it is an issue with the new files I added?",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3598827",
                          "updatedAt": "2022-09-08T18:50:18Z",
                          "publishedAt": "2022-09-08T18:50:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "weird. Are you recompiling after the configure?",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3599422",
                          "updatedAt": "2022-09-08T19:43:49Z",
                          "publishedAt": "2022-09-08T19:43:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "I recompiled my project I was working on before I tried again.",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3600418",
                          "updatedAt": "2022-09-08T20:39:52Z",
                          "publishedAt": "2022-09-08T20:39:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok good.\nThe error in Metaphysicl is not the error the prompt mentions then.\nPlease follow these instructions here to get us a backtrace\nhttps://mooseframework.inl.gov/application_development/debugging.html\nalso let s consider any floating point operation you have on AD numbers. Do you have exotic tanh2 etc functions?",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3601447",
                          "updatedAt": "2022-09-08T22:04:49Z",
                          "publishedAt": "2022-09-08T22:04:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "Funny you mention that, I use the tanh function on AD Reals in my calculation.",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3601655",
                          "updatedAt": "2022-09-08T22:39:35Z",
                          "publishedAt": "2022-09-08T22:39:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you drop it for testing?\nIt could be that",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3601804",
                          "updatedAt": "2022-09-08T22:44:56Z",
                          "publishedAt": "2022-09-08T22:44:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "I dropped the tanh but still had the issue... but then I broke down my function line by line and I found out this:\n\nwhen log and tanh functions are removed it works fine\nif there are either log or tanh functions it gives that error",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3609445",
                          "updatedAt": "2022-09-09T15:06:43Z",
                          "publishedAt": "2022-09-09T15:06:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you add checks that you are within the range of validity of these functions?\nand the range where the derivative is well defined as well. if the derivative is no longer defined then that could be trouble\nlog is only trouble near 0 I think?",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3610869",
                          "updatedAt": "2022-09-09T18:03:07Z",
                          "publishedAt": "2022-09-09T18:03:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "What METHOD are you compiling with? (Default is opt)",
                          "url": "https://github.com/idaholab/moose/discussions/22033#discussioncomment-3613091",
                          "updatedAt": "2022-09-10T05:01:33Z",
                          "publishedAt": "2022-09-10T05:01:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}