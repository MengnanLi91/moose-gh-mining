{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNi0wMVQwNzoxNjo1Ni0wNTowMM4AM2tq"
    },
    "edges": [
      {
        "node": {
          "title": "Constrain concentration variable",
          "author": {
            "login": "souzanha"
          },
          "bodyText": "Hi all,\nI get large fluctuations in my system with a regular Cahn-Hilliard + NeumannBC, and cannot uphold 0<= c <= 1 which gives me convergence problems, especially as I'm using a thermodynamic model with logarithmic terms. I've tried using polynomials, which allows me larger time-steps and faster convergence but then these fluctuations keeps happening until I reach c~10^2 and then it crashes. I use adaptivity (mesh is quite refined in the problematic areas).\nNow, I think I would like to try to constrain the concentration, i.e:\nif (_c[qp] > 1) {\n_c[qp] = 1\n}\nWhich I think I could include in any kernel, as long as I call for and initialize the concentration variable. However I'm quite new still with Moose, so I would value any suggestions.\nThanks in advance,\nSouzan",
          "url": "https://github.com/idaholab/moose/discussions/17937",
          "updatedAt": "2022-06-23T15:02:55Z",
          "publishedAt": "2021-05-26T17:25:43Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "First thing I would check is your free energy. Looks like the system tries to find the solution/minimum outside 0-1 range. If that is the case, adding any constraint would not help you from getting a correct solution.\nIf you think your free energy is correct, then you can try to use a variational inequality solver (snes_type = vinewtonrsls) to set the bounds for your variable. One example can be found in test/tests/auxkernels/bounds/constant_bounds.i\nI am pinging @laagesen to provide you more suggestions.",
                  "url": "https://github.com/idaholab/moose/discussions/17937#discussioncomment-787902",
                  "updatedAt": "2022-06-23T15:02:57Z",
                  "publishedAt": "2021-05-26T18:53:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Hi Souzan,\nI would start out by comparing your input file to one of the many Cahn-Hilliard examples in the MOOSE repository. For example this is a good one:\nmoose/modules/phase_field/examples/cahn-hilliard/Parsed_SplitCH.i\nThat can help you figure out if the problem lies with the governing equations in your input file. I would then try modifying the free energy in the example file to the polynomial form you want to use, then try the logarithmic form, to see if you can isolate whether the free energy is causing troubles. I would also try simulations without the NeumannBC at first, that may be causing solute to be added into the simulation domain and driving it away from two-phase coexistence. You mentioned that c~100 at the end, if it is that large everywhere in the domain that may be caused by the NeumannBC.",
                          "url": "https://github.com/idaholab/moose/discussions/17937#discussioncomment-787964",
                          "updatedAt": "2022-06-23T15:03:01Z",
                          "publishedAt": "2021-05-26T19:07:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Thank you @jiangwen84 and @laagesen for your suggestions. I will start again from the beginning to see if I can isolate the problem.\nI started off with using the same defined energy expression, and changed it into mine. The polynomial function I use seem to work nicely, as does the logarithmic term. However, it is when I introduce the flux when it slows down and I start getting issues. Previously I had not included any periodic boundary condition, only the Neumann at one boundary. Now when I kept the periodic boundary block from\nmoose/modules/phase_field/examples/cahn-hilliard/Parsed_SplitCH.i\n... I can use larger time steps and the solution runs more smoothly. Is there a reason for that?",
                          "url": "https://github.com/idaholab/moose/discussions/17937#discussioncomment-793364",
                          "updatedAt": "2022-06-23T15:03:02Z",
                          "publishedAt": "2021-05-27T14:37:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "If you are using a large value for the NeumannBC you may be adding a lot of solute to the system. This could be acting like a large source term and driving it far away from the concentration you start from. In such cases of a large effective source, it can make the problem more difficult to converge at each time step. In addition to the periodic BCs, I would also try running with no boundary conditions block, this will give you the natural BC in the finite element method, which in this case is a no-flux BC.\nWhat is the physical system you are trying to simulate? We can probably help troubleshoot the NeumannBC but it would help understand the physics of your system and why you are wanting to add flux at a boundary.",
                          "url": "https://github.com/idaholab/moose/discussions/17937#discussioncomment-793476",
                          "updatedAt": "2022-06-23T15:03:01Z",
                          "publishedAt": "2021-05-27T14:47:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "I see, I was also quite worried that this was the case. I've been using a NeumannBC, but for my real application I'd made my own boundary kernel that adds a flux depending on the chemical potential value at the boundary.\nI'm essentially following: https://pubs.rsc.org/en/content/articlehtml/2020/ta/c9ta11697d\nI may have defined my kernel incorrectly. The idea is to call for the value of the chemical potential at the boundary, use it in the Butler-Volmer equation and define an outgoing flux.\nThis is how it looks like:\n#include \"ADButlerVolmerBC.h\"\nregisterMooseObject(\"intercalationApp\", ADButlerVolmerBC);\ndefineLegacyParams(ADButlerVolmerBC);\nInputParameters\nADButlerVolmerBC::validParams()\n{\nInputParameters params = ADIntegratedBC::validParams();\nparams.addRequiredCoupledVar(\"w\", \"Coupled variable setting the gradient on the boundary.\");\nparams.addParam(\"Temperature\", 298, \"Value of temperature to use\");\nparams.addParam(\"current_density\",1.0, \"Applied Current Density\");\nparams.addParam(\"deltaPhi\",100e-3, \"Potential 100mV\");\nparams.addParam(\"V\",43.8e-6, \"Molar volume\");\nparams.addParam(\"F\",96485, \"Faradays constant\");\nparams.addParam(\"mueq\",-3e5, \"Chemical potential at phase equilibrium\"); // J/m^3\nparams.addParam(\"R\",8.315,\"Gas constant\");\nparams.addParam(\"l_0\",1e-9,\"Length unit\");\nparams.addParam(\"e_0\",1e-18,\"Energy unit\");\nparams.addParam(\"D\",1e-15,\"Diffusion coefficient\");\nreturn params;\n}\nADButlerVolmerBC::ADButlerVolmerBC(const InputParameters & parameters)\n: ADIntegratedBC(parameters),\n_w(coupledValue(\"w\")),\n_temp(getParam(\"Temperature\")),\n_deltaPhi(getParam(\"deltaPhi\")),\n_j0(getParam(\"current_density\")),\n_V(getParam(\"V\")),\n_F(getParam(\"F\")),\n_mueq(getParam(\"mueq\")),\n_R(getParam(\"R\")),\n_lo(getParam(\"l_0\")),\n_eo(getParam(\"e_0\")),\n_D(getParam(\"D\"))\n{\n}\nADReal\nADButlerVolmerBC::computeQpResidual()\n{\nauto constant = (_mueq-(_F * _deltaPhi)) * ((_lo * _lo * _lo)/_eo); //scale dimension by m^3/J\nauto div = ((2 * _R * _temp)/_V) * ((_lo * _lo * _lo)/_eo); //scale the denominator in the exponent term\nauto exponent = (constant-_w[_qp])/div;\nauto flux = (((_lo * _lo * _lo * _lo)/_eo) * ((_R  * _temp)/(_F * _D)) * _j0  * (std::exp(exponent) - std::exp(-exponent)));\nreturn -_test[_i][_qp] * flux;\n\n}",
                          "url": "https://github.com/idaholab/moose/discussions/17937#discussioncomment-794537",
                          "updatedAt": "2022-08-21T11:31:35Z",
                          "publishedAt": "2021-05-27T18:12:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "What variable are you applying that BC to?",
                          "url": "https://github.com/idaholab/moose/discussions/17937#discussioncomment-795109",
                          "updatedAt": "2022-08-21T11:32:12Z",
                          "publishedAt": "2021-05-27T20:53:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Our default split formulation is a reverse split, which leads to counterintuitive variable/equation assignments. I think because of the coupledtimederivative you need to assign the kernel to the w variable and have c be the coupled variable.",
                          "url": "https://github.com/idaholab/moose/discussions/17937#discussioncomment-795114",
                          "updatedAt": "2022-08-21T11:32:13Z",
                          "publishedAt": "2021-05-27T20:55:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "I use the kernels: CoupledTimeDerivative, SplitCHWRes and SplitCHParsed and have applied by BC to the chemical potential.\nHowever, I have also coupled to the chemical potential:\n[BCs]\n[./right]\ntype = ADButlerVolmerBC\nvariable = w\nw = w\nboundary = right\n[../]\n[]\nNow, I think I may not have fully understood the coupling correctly. What I know is that I need to call for the chemical potential at the nodes of the boundary, which is why I coupled to w.\nRunning the model with the above kernels, it runs smoothly for awhile (total c keeps decreasing). But I get c_max ~  2.5 , c_min ~-1e-5, before it crashes.",
                          "url": "https://github.com/idaholab/moose/discussions/17937#discussioncomment-797212",
                          "updatedAt": "2022-08-21T11:32:13Z",
                          "publishedAt": "2021-05-28T10:03:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Can you be more specific about what you mean by \"it crashes\"? What is the error you are getting? You already mentioned that you don't have problems when you use periodic BCs. Do you get the same behavior if you use NeumannBC with a constant value?",
                          "url": "https://github.com/idaholab/moose/discussions/17937#discussioncomment-799286",
                          "updatedAt": "2022-08-21T11:32:15Z",
                          "publishedAt": "2021-05-28T18:49:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "souzanha"
                          },
                          "bodyText": "Thank you for the troubleshooting! I'm very glad to have some people to discuss this with. This is the error that I get:\nTime Step 284, time = 0.0900684, dt = 2e-14\n0 Nonlinear |R| = 2.759644e+11\n0 Linear |R| = 2.759644e+11\n1 Linear |R| = 1.169056e+01\n1 Nonlinear |R| = 8.527509e+08\n0 Linear |R| = 8.527509e+08\n1 Linear |R| = 2.677094e+00\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 1\nSolve Did NOT Converge!\nAborting as solve did not converge\n*** ERROR ***\nThe following error occurred in the object \"TimeStepper\", of type \"ConstantDT\".\nSolve failed and timestep already at or below dtmin, cannot continue!\nI'm outputting the maximum and minimum concentrations and this happens when large fluctuations start occurring.\nc_max = 2.514514e+00\nc_,min = -5.985228e-01\nRegarding the periodic BCs, I tested it with moose/modules/phase_field/examples/cahn-hilliard/Parsed_SplitCH.i\nwhen including a NeumannBC it converged easier and with a lower timestep. In the end, having a periodic BC is not an issue at the moment. But I would not want to apply it anywhere if I could. So I tried my model with the Butler-Volmer BC and added the Periodic BC, and I get much more far into the solution. I just let it run and I'm already much further ahead just by looking at the outputted time steps. Note that this is just by adding the Period BC. Could this have to do with any symmetry issues in FEM? I have not heard about periodic BC helping with convergence.",
                          "url": "https://github.com/idaholab/moose/discussions/17937#discussioncomment-807881",
                          "updatedAt": "2022-08-21T11:32:18Z",
                          "publishedAt": "2021-05-31T16:57:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "From what you have said, the model runs fine with the standard periodic and standard Neumann BCs, but not when the Butler-Volmer BC that you created is included. So it seems the problem is most likely with the Butler-Volmer BC. So, I suggest focusing your troubleshooting efforts there. Can you create a simpler test case to debug the Butler-Volmer BC? It is always good to compare to an analytical solution if there is one available. If there is a 1D problem that has an analytical solution, that would be a great way to test and debug.",
                          "url": "https://github.com/idaholab/moose/discussions/17937#discussioncomment-810948",
                          "updatedAt": "2022-08-21T11:32:31Z",
                          "publishedAt": "2021-06-01T13:16:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "adaptive converging criteria",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi MOOSE team,\nI just wonder if MOOSE has adaptive converaging criteria\nfor example, increase the value of nl_rel_tol of the current timestep by 10% after 10 nonlinear iterations?\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/17969",
          "updatedAt": "2021-06-21T17:32:39Z",
          "publishedAt": "2021-05-31T04:12:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "This is not supported. It might be possible to add support, but I am not sure how. This parameter is used to set items in libMesh objects, so it is not something easily adapted using MOOSE systems.  Perhaps @roystgnr has some comments?\n\n  \n    \n      moose/framework/src/executioners/FEProblemSolve.C\n    \n    \n         Line 164\n      in\n      a3b504b\n    \n  \n  \n    \n\n        \n          \n           es.parameters.set<Real>(\"nonlinear solver relative residual tolerance\") =",
                  "url": "https://github.com/idaholab/moose/discussions/17969#discussioncomment-811352",
                  "updatedAt": "2021-06-01T14:38:15Z",
                  "publishedAt": "2021-06-01T14:37:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "It's not?  I've never used this code path, but it looks like we're setting defaults at\nhttps://github.com/libMesh/libmesh/blob/master/src/systems/nonlinear_implicit_system.C#L51\nand then respecting the value at\nhttps://github.com/libMesh/libmesh/blob/master/src/systems/nonlinear_implicit_system.C#L104",
                          "url": "https://github.com/idaholab/moose/discussions/17969#discussioncomment-811479",
                          "updatedAt": "2021-06-01T15:01:02Z",
                          "publishedAt": "2021-06-01T15:01:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "I am sure it could be changed by something, but I was hoping that we could just update via the Control system and the parameter that exists in FEProblemSolve. To do that we would need the value set in libMesh to reference the value in the FEProblemSolve parameters. This might be feasible, but not as simple as I would hope.",
                          "url": "https://github.com/idaholab/moose/discussions/17969#discussioncomment-816150",
                          "updatedAt": "2021-06-02T14:21:34Z",
                          "publishedAt": "2021-06-02T14:21:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Oh, I think I get it - libMesh checks ES parameter \"nonlinear solver relative residual tolerance\" at every nonlinear solve, but FEProblemSolve only sets that parameter from \"nl_rel_tol\" at construction time, so any later changes to \"nl_rel_tol\" won't get propagated?",
                          "url": "https://github.com/idaholab/moose/discussions/17969#discussioncomment-816618",
                          "updatedAt": "2021-06-02T15:47:19Z",
                          "publishedAt": "2021-06-02T15:47:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "No Fluid Structure Interaction Module in Moose install",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I would like to use the Fluid Structure Interaction module in MOOSE. When I attempted to run an example fsi model in Peacock I received an error that my install did not have the appropriate files to run an fsi model. My install of MOOSE does not have the Fluid Structure Interaction Module installed in the Modules directory. What do I need to do in order to install this application?\nThanks for any help solving this problem.",
          "url": "https://github.com/idaholab/moose/discussions/17987",
          "updatedAt": "2022-08-22T02:35:19Z",
          "publishedAt": "2021-06-02T01:24:36Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Fluid structure interaction is under the modules/fsi folder. If it's not there then you need to update moose",
                  "url": "https://github.com/idaholab/moose/discussions/17987#discussioncomment-814245",
                  "updatedAt": "2022-08-22T02:35:19Z",
                  "publishedAt": "2021-06-02T06:24:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Complete. I had to perform a \"git pull\" update of MOOSE. Thank you for the advice.",
                          "url": "https://github.com/idaholab/moose/discussions/17987#discussioncomment-816302",
                          "updatedAt": "2022-08-22T02:35:19Z",
                          "publishedAt": "2021-06-02T14:45:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Solving enviroments indefinitely",
          "author": {
            "login": "kyleluma"
          },
          "bodyText": "I have just began installing Moose. I've done all of the steps correctly I am assuming since everything has worked out fine prior to this.\nI run:\nconda create --name moose moose-libmesh moose-tools\nto which it succesfully collects package metadata, attempts to solve enviroment but fails:\nSolving environment: failed with repodata from current_repodata.json, will retry with next repodata source.\nCollecting package metadata (repodata.json): done\nand then:\nSolving enviroment: (with the spinning line)\nI've quit and restarted from the installation of minconda and it says everything is where it should be, not sure what the problem would be.\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/17981",
          "updatedAt": "2021-06-02T13:31:06Z",
          "publishedAt": "2021-06-01T17:22:01Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "Strange issue more and more folks are experiencing from Anaconda cloud servers (conda/conda#9554).\nCan you perform the following, and then try to install packages?\nconda config --set ssl_verify False\nconda create --name moose -q -y\nconda activate moose\nconda install moose-tools\nconda install moose-libmesh\nNote about the additional steps; We are also finding Conda Solves to be much quicker when asking Conda to install individual packages. Start with moose-tools, as that package contains the most non-version specific amount of dependencies. Once complete (if --set ssl_verify worked), then install moose-libmesh.",
                  "url": "https://github.com/idaholab/moose/discussions/17981#discussioncomment-812256",
                  "updatedAt": "2021-06-01T17:47:35Z",
                  "publishedAt": "2021-06-01T17:47:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "kyleluma"
                          },
                          "bodyText": "thanks a lot for this!! God bless.",
                          "url": "https://github.com/idaholab/moose/discussions/17981#discussioncomment-812532",
                          "updatedAt": "2021-06-01T19:03:58Z",
                          "publishedAt": "2021-06-01T19:03:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I forgot to mention: We are in the process of making the above instructions the norm (optimize install times): #17934",
                          "url": "https://github.com/idaholab/moose/discussions/17981#discussioncomment-815924",
                          "updatedAt": "2021-06-02T13:30:50Z",
                          "publishedAt": "2021-06-02T13:30:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Questions about XFEM Module input file and crack propagation criterion",
          "author": {
            "login": "emdcstanford"
          },
          "bodyText": "Hi,\nI am fairly new to using the XFEM module in MOOSE, and I've been running some of the test simulations as well as some of my own. However, I'm a little confused about some of the parameters in the example input files, especially in relation to the  crack propagation and initiation theory presented in the paper Jiang et al. 2020 in Eng. Frac. Mech.\nWith regards to the 'crack_growth_increment parameter', is this the amount of distance the crack is prescribed to grow each time the crack propagation criterion is satisfied? However I notice I can also propagate the crack without this parameter.\nThen in XFEMRankTwoTensorMarkerUserObject, I am a little confused about the 'threshold'. Is this a scalar quantity equivalent to the fracture strength described in the paper mentioned above for crack initiation (section 5.2) which we use when there are no prescribed cracks apriori, or is this part of the crack propagation criterion? I was under the impression that the propagation criterion is that of maximum hoop stress and don't immediately see how this is related to a threshold value.\nThank you very much for the help,\nEnrique",
          "url": "https://github.com/idaholab/moose/discussions/17970",
          "updatedAt": "2022-07-26T13:05:40Z",
          "publishedAt": "2021-05-31T06:29:04Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@emdcstanford Some of the crack propagation criterions mentioned in that paper has not been fully merged into the MOOSE repository. It definitely reminds us to get those codes merged as soon as we can.\nYou are correct that the crack propagation criterion was based on maximum hoop stress in that paper. And the maximum hoop stress is obtained by evaluating the stress intensity factors. In MOOSE, XFEMRankTwoTensorMarkerUserObject uses a different simple criterion where the crack propagates if the crack tip element stress exceeds a threshold and the direction is determined as the maximum principal direction.\nRegarding the crack_growth_increment, this parameter specifies the amount of distance the crack will grow when crack propagation criterion is met. Without providing this parameter, crack will only propagate one element per time.\nLet us know if you have more questions.",
                  "url": "https://github.com/idaholab/moose/discussions/17970#discussioncomment-813260",
                  "updatedAt": "2022-07-26T13:05:44Z",
                  "publishedAt": "2021-06-01T22:57:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Apparent issues with MOOSE Docker Container",
          "author": {
            "login": "andrewritzmann"
          },
          "bodyText": "Hi,\nI was using the MOOSE docker container on both Windows 10 and Linux (Ubuntu 18.04.5 LTS) with fairly good success. Recently, I changed laptops, and I tried using the latest container of ubuntu-moose (I've tried several since, but I can confirm as of this morning that the following issue exists for tag 62256f8 [current latest image as of 9:09 AM PDT on 5/12/2021]).\nFollowing the instructions on the MOOSE Getting Started --> Docker page (https://mooseframework.inl.gov/getting_started/installation/docker.html). I ran, per the instructions, the following command:\ndocker run -ti herter4171/ubuntu-moose:latest /bin/bash -c 'cd test; ./run_tests'\nThe result was a failure due to the pyhit module.\nMessage: \"failed to import pyhit - try running \"make hit\" in the $MOOSE_DIR/test directory.\"\nI have tried to troubleshoot this with making the hit target in both the $MOOSE_DIR/test directory and the $MOOSE_DIR/framework/contrib/hit directory.\nThis has been a persistent problem of late with running the image on Windows 10. I am reluctant to try the newer container on my Linux host system for fear of messing with an older, working version. The problem appears to have occurred between March 10, 2021 and today.\nSince the Docker approach is supposed to be a plug-and-play solution, fixing this issue would be quite helpful.\nBest,\nAndrew",
          "url": "https://github.com/idaholab/moose/discussions/17812",
          "updatedAt": "2022-07-01T08:59:45Z",
          "publishedAt": "2021-05-12T16:25:07Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Andrew\nUsing WSL is the preferred way to use MOOSE on windows 10.\nFor the pyhit error, you just need to download moosetools i think. repo\nFor more info on pyhit\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17812#discussioncomment-805230",
                  "updatedAt": "2022-07-01T08:59:49Z",
                  "publishedAt": "2021-05-31T04:52:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "You do not need moosetools repo, something is going wrong with compiling hit python bindings. Typically, when this happens it is because of hit was compiled with one version of python and you are using a different version with run_tests.",
                          "url": "https://github.com/idaholab/moose/discussions/17812#discussioncomment-811316",
                          "updatedAt": "2022-07-01T08:59:50Z",
                          "publishedAt": "2021-06-01T14:31:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "activate_distance in ActivateElementsByPath does not seem to work.",
          "author": {
            "login": "zx1987"
          },
          "bodyText": "All\nI am playing around the user object ActivateElementsByPath following the example https://mooseframework.inl.gov/source/userobject/ActivateElementsByPath.html\nI adapt it and make a example to activate elements within a given distance  along a path. It appears to me activate_distance is not working as expected. While I used different value for activate-distance, it is only activating one layer of elements on top and below the path.  I am attaching a copy of the input file and could anybody advise what might be wrong? Thank you.\n[Problem]\n  kernel_coverage_check = false\n[]\n\n[Mesh]\n  [./gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin =0\n    ymin=0\n    xmax =0.01\n    ymax =0.004\n    nx=100\n    ny= 40\n    nz=1\n  [../]\n  [./bottom_domain]\n    input = gen\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0 0 0'\n    top_right = ' 0.01  0.001 0'\n    block_id = 1\n  [../]\n  [./top_domain]\n    input = bottom_domain\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0 0.001 0'\n    top_right = '0.01  0.004 00'\n    block_id = 2\n  [../]\n  [./sidesets]\n    input = top_domain\n    type = SideSetsAroundSubdomainGenerator\n    normal = '1 0 0'\n    block = 1\n    new_boundary = 'moving_interface'\n  []\n[]\n\n[Variables]\n  [./temp]\n    block = '1'\n  [../]\n[]\n\n[Functions]\n  [./fy]\n    type = ParsedFunction\n    value= 'if(t<12.5,0.0015,0.0025)'\n  [../]\n  [./fx]\n    type = ParsedFunction\n    value= 'if(t<12.5,0.0008*t, 0.01-0.0008*(t-12.5))'\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Executioner]\n  type = Transient\n\n  automatic_scaling = true\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  line_search = 'none'\n\n  l_max_its = 10\n  nl_max_its = 20\n  nl_rel_tol = 1e-4\n\n  start_time = 0.0\n  end_time = 25.0\n  dt = 1e-1\n  dtmin = 1e-4\n[]\n\n[UserObjects]\n  [./activated_elem_uo]\n    type = ActivateElementsByPath\n    execute_on = timestep_begin\n    activate_distance = 0.0005\n    function_x= fx\n    function_y= fy\n    active_subdomain_id = 1\n    expand_boundary_name = 'moving_interface'\n  [../]\n[]\n[Outputs]\n  exodus = true\n[]\n\n\nBest,\nXiang",
          "url": "https://github.com/idaholab/moose/discussions/17947",
          "updatedAt": "2023-01-18T10:29:14Z",
          "publishedAt": "2021-05-27T14:55:57Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dewenyushu"
                  },
                  "bodyText": "Hi @zx1987 , thanks for finding this issue.\nI tested this out and realized that this is a bug related to the usage of close_to_point function. I created a PR (#17954) which should fix this issue.\nAlso, I'd like you to be aware of the CoupledVarThresholdElementSubdomainModifier  user object, which is a more generalized version of adding/deleting/removing the elements. We also have a plan to combine these capabilities\nhttps://mooseframework.inl.gov/source/userobject/CoupledVarThresholdElementSubdomainModifier.html",
                  "url": "https://github.com/idaholab/moose/discussions/17947#discussioncomment-794885",
                  "updatedAt": "2023-01-18T10:29:24Z",
                  "publishedAt": "2021-05-27T19:50:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Hi @dewenyushu , thanks for the bug fix and pointing me to the CoupledVarThresholdElementSubdomainModifier. Will check it out.\nBest,\nXiang",
                          "url": "https://github.com/idaholab/moose/discussions/17947#discussioncomment-795213",
                          "updatedAt": "2023-01-18T10:29:29Z",
                          "publishedAt": "2021-05-27T21:30:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Hi @dewenyushu\nI just checked the new code, and have some further questions here:\nI added the activate_distance=9 into the example check_element_addition.i input file, as below\n`[Problem]\nkernel_coverage_check = false\n[]\n[Mesh]\n[./gen]\ntype = GeneratedMeshGenerator\ndim = 3\nxmin =0\nxmax =10\nymin =0\nymax =10\nzmin =0\nzmax =0.5The width of the newly activated elements do not seem to be correct, as I am expecting any elements within a distance of 9 to the\nnx=100\nny=100\nnz=1\n[../]\n[./left_domain]\ninput = gen\ntype = SubdomainBoundingBoxGenerator\nbottom_left = '0 0 0'\ntop_right = '5 10 0.5'\nblock_id = 1\n[../]\n[./right_domain]\ninput = left_domain\ntype = SubdomainBoundingBoxGenerator\nbottom_left = '5 0 0'\ntop_right = '10 10 0.5'\nblock_id = 2\n[../]\n[./sidesets]\ninput = right_domain\ntype = SideSetsAroundSubdomainGenerator\nnormal = '1 0 0'\nblock = 1\nnew_boundary = 'moving_interface'\n[]\n[]\n[Variables]\n[./temp]\nblock = '1'\n[../]\n[]\n[Functions]\n[./fx]\ntype = ParsedFunction\nvalue= '7.5'\n[../]\n[./fy]\ntype = ParsedFunction\nvalue= '2.5*t'\n[../]\n[./fz]\ntype = ParsedFunction\nvalue= '0.25'\n[../]\n[]\n[Preconditioning]\n[./smp]\ntype = SMP\nfull = true\n[../]\n[]\n[Executioner]\ntype = Transient\nautomatic_scaling = true\nsolve_type = 'NEWTON'\npetsc_options_iname = '-pc_type'\npetsc_options_value = 'lu'\nline_search = 'none'\nl_max_its = 10\nnl_max_its = 20\nnl_rel_tol = 1e-4\nstart_time = 0.0\nend_time = 1.0\ndt = 1e-1\ndtmin = 1e-4\n[]\n[UserObjects]\n[./activated_elem_uo]\ntype = ActivateElementsByPath\nexecute_on = timestep_begin\nfunction_x= fx\nfunction_y= fy\nfunction_z= fz\nactivate_distance=9\nactive_subdomain_id = 1\nexpand_boundary_name = 'moving_interface'\n[../]\n[]\n[Outputs]\nexodus = true\n[]`\nI got a snapshot rendered with block ID as below at t=0.3s. The width of the newly activated elements do not seem to be correct, as I am expecting any elements within a distance of 9 to the line of x=7.5 will be activated (white color), and also there is one element in the top row of the newly activated element is shown in red. Did me misunderstand anything here?\nThank you.\nBest,\nxiang",
                          "url": "https://github.com/idaholab/moose/discussions/17947#discussioncomment-799843",
                          "updatedAt": "2023-01-18T10:29:29Z",
                          "publishedAt": "2021-05-28T21:58:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Hi @zx1987\nI think you are understanding the usage of this pretty well. I suppose the issue may because you did not manage to grab the recent fix. Since it is merged this morning, the fix only appears on the next branch now. I would suggest trying rebase your branch on next, re-compile, and run your problem again\nI just tried running with your above input, and I got something that looks okay. Following is a snapshot at t=0.3s:",
                          "url": "https://github.com/idaholab/moose/discussions/17947#discussioncomment-799943",
                          "updatedAt": "2023-01-18T10:29:42Z",
                          "publishedAt": "2021-05-28T23:00:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Hi @dewenyushu\nYes your are right. Wen mentioned this to me earlier, but at that time I already messed up with my previous installation and I had a new install, thinking that the update is already in in. After grabbing the update it worked as expected. Thank you.\nBest,\nXiang",
                          "url": "https://github.com/idaholab/moose/discussions/17947#discussioncomment-801660",
                          "updatedAt": "2023-01-18T10:29:43Z",
                          "publishedAt": "2021-05-29T16:01:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Sounds great! Glad it worked :)",
                          "url": "https://github.com/idaholab/moose/discussions/17947#discussioncomment-811187",
                          "updatedAt": "2023-01-18T10:29:44Z",
                          "publishedAt": "2021-06-01T14:05:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "System won't solve unless I have very high nl_rel_tol",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nMy model won't solve unless I set nl_rel_tol to something like 0.9, I tried to increase nl_abs_tol and  l_abs_tol instead, but they don't help.\n\nerror message:\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nSolve Did NOT Converge!\n\nI'm running a quasi-static mining simulation with E of 20e9, rapid strain softening (DP model) with the domain size of like 3000^3m, hence the max stress is around 8e7 Pa.\nis there any way to work around nl_rel_tol value? I see the coal mining example coverts everything to MPa instead of Pa, will this help? @WilkAndy\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/17809",
          "updatedAt": "2022-07-26T02:13:04Z",
          "publishedAt": "2021-05-12T06:29:37Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Working in MPa won't help - it simply scales all the residuals and makes your input file (perhaps) easier to read.\nAre you using Newton or PJFNK or something else?",
                  "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-727569",
                  "updatedAt": "2022-07-26T02:13:07Z",
                  "publishedAt": "2021-05-12T08:12:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "I'm using Newton now, will give PJFNK a go though it is much slower (imo) compared to Newton",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-731603",
                          "updatedAt": "2022-07-27T13:17:14Z",
                          "publishedAt": "2021-05-12T23:45:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Newton is better, i agree.  I think PJFNK will likely bomb out really early, as the model will go into some strange configuration where the plasticity goes nuts.",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-731773",
                          "updatedAt": "2022-07-27T13:17:14Z",
                          "publishedAt": "2021-05-13T01:03:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Yes, I tried PJFNK, didn't work so well + very slow.\nall the simulation works fine if I have nl_rel_tol>0.9 with max_disp of like 2-3 cm (after stopes excavation) for a huge mine model.\nI just feel like nl_rel_tol>0.9 is bad, since most of the example has this value around 1e-3, but if nothing is too wrong about the results, I might have to live with it.\nThanks @WilkAndy",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-731783",
                          "updatedAt": "2022-07-27T13:17:14Z",
                          "publishedAt": "2021-05-13T01:08:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You should not accept a nl_rel_tol of 0.9. The simulation has not converged.\nTry to output the results at two different unconverged step and see if you can see any pattern.\nAlso use the show_residual_norms option to see which variable is lagging behind in convergence.",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-732077",
                          "updatedAt": "2022-07-27T13:17:35Z",
                          "publishedAt": "2021-05-13T04:06:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thanks @GiudGiud, basically the simulation moves to the next step without having to solve the next non-linear iteration when I use nl_rel_tol of 0.9. I turn off plasticity and see the disp_ and stress results are pretty much 30% different.\nwhere do I use 'show_residual_norms'? i couldn't find it in any example.\nalso is there anywhere else that I can relax simulation so I can reduce nl_rel_tol a little bit more?\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-732378",
                          "updatedAt": "2022-07-27T13:17:35Z",
                          "publishedAt": "2021-05-13T06:37:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "With a tolerance of 0.9 your solution could be 90% different and the solver would not care.\nIt's a debug output and I mispelled it\n[Debug]\n  show_var_residual_norms = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-734197",
                          "updatedAt": "2022-07-27T13:17:59Z",
                          "publishedAt": "2021-05-13T14:47:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any updates on this?\nWith regards to relaxing the simulation, you could a fixed point iteration process, and use a relaxation factor there.",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-805262",
                          "updatedAt": "2022-07-27T13:18:05Z",
                          "publishedAt": "2021-05-31T05:12:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @GiudGiud and @WilkAndy\nso this error\n\nerror message:\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\nSolve Did NOT Converge!\n\nis solved by adding use_displaced_mesh = true into every object under the [Kernels] and [UserObject] blocks\nNow simulation solves fine with rapid plastic softening (1/10 coh within 1% damage), but just take much much longer for simulation to converge for nl_rel_tol of less than 0.9 (0.3-0.5).\nnow i'm looking for the way to make the simulation convereg fasting, hence i create a new thread about adaptive convergence criteria.\nAnyway, thanks a lot guys,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-805340",
                          "updatedAt": "2022-07-27T13:18:08Z",
                          "publishedAt": "2021-05-31T05:48:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "0.3 / 0.5 still seems pretty high.\nWhat is the absolute residual?\nDo you have the output of 'show_var_residual_norms' ?",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-808319",
                          "updatedAt": "2022-07-27T13:18:11Z",
                          "publishedAt": "2021-05-31T19:16:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "I agree with @GiudGiud : 0.3 is still really high.\n\nyou might be almost converged anyway, and that's why @GiudGiud suggested the absolute residual.  If it's really tiny then MOOSE won't converge any more due to precision loss.  Compared with most MOOSE users, I'm a real fan of setting nl_abs_tol , because many PorousFlow simulations suffer from the problem of being almost converged.  You can see a small essay i wrote at https://mooseframework.inl.gov/modules/porous_flow/convergence.html\n@GiudGiud suggested show_var_residual_norms in a [Debug] block because you can see how different Variables might need scaling.   Incorrect scaling can also lead to nonconvergence, and is also mentioned in the above link.\n\nIt is difficult to conclusively say what's wrong.  In mining scenarios with difficult plasticity, i have sometimes had to add damped dynamics to get good convergence.   Have you tried that?",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-808624",
                          "updatedAt": "2022-07-27T13:18:13Z",
                          "publishedAt": "2021-05-31T21:06:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "what does 'nl_rel_tol' really mean? i see the definition says 'Description:Nonlinear Relative Tolerance', but relative to what?",
                  "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-731599",
                  "updatedAt": "2022-07-27T13:18:48Z",
                  "publishedAt": "2021-05-12T23:44:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Relative to the initial nonlinear residual (0'th nonlinear |R|) for that step.",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-731768",
                          "updatedAt": "2022-07-27T13:18:48Z",
                          "publishedAt": "2021-05-13T01:00:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "If the convergence issue only occurs after the softening stage, you can lag the internal softening variable to get good convergence.",
                  "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-809212",
                  "updatedAt": "2022-07-27T13:18:50Z",
                  "publishedAt": "2021-06-01T03:13:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @hugary1995,\nwhat do you mean by 'lag the internal softening variable', do you mean increase internal_limit?\nIf so that will defeat what I want to achieve, we want to do rapid softening where cohesion goes down by 1/10 with 0.5% damage.\n  [./mc_coh]\n    type = TensorMechanicsHardeningCubic\n    value_0 = 5e6\n    value_residual = 5e5\n    internal_limit = 0.005\n    use_displaced_mesh = true\n  [../]\n\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-809221",
                          "updatedAt": "2022-07-27T13:18:54Z",
                          "publishedAt": "2021-06-01T03:20:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "try using execute_on = timestep_end or execute_on = timestep_begin in the above",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-809237",
                          "updatedAt": "2022-07-27T13:18:58Z",
                          "publishedAt": "2021-06-01T03:30:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'm a little confused. Maybe I missed some of your earlier discussion. Are you trying to use this hardening model as a softening model? I thought you were using some sort of damage plasticity model. Are you referring to your effective plastic strain as \"damage\"?",
                          "url": "https://github.com/idaholab/moose/discussions/17809#discussioncomment-811077",
                          "updatedAt": "2022-07-27T13:18:57Z",
                          "publishedAt": "2021-06-01T13:43:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Dream3d exported file can NOT be read by EBSD_reconstruction module",
          "author": {
            "login": "zengfy-hust"
          },
          "bodyText": "Hello Moose workers:\nI use dream3d to covert EBSD file to INL file .then used it as an initia condition for EBSD_reconstruction module in phase_field module .however ,when I chanege the innput file .Error message was shown as followed\n*** ERROR ***\nThe following error occurred in the object \"ebsd_reader\", of type \"EBSDReader\".\nEBSD Data ouside of the domain declared in the header ([-850:-730], [-0.5:119.5], [0:0]) dim=2\nStack frames: 16\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >)\n2: callMooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >&, MooseApp*)\n3: EBSDReader::readFile()\n4: EBSDReader::EBSDReader(InputParameters const&)\n5: std::shared_ptr moose::internal::buildObj(InputParameters const&)\n6: Factory::create(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, InputParameters&, unsigned int, bool)\n7: FEProblemBase::addUserObject(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, InputParameters&)\n8: Action::timedAct()\n9: ActionWarehouse::executeActionsWithAction(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&)\n10: ActionWarehouse::executeAllActions()\n11: MooseApp::runInputFile()\n12: MooseApp::run()\n13: /home/zengfanyi/projects/moose/modules/phase_field/phase_field-opt(+0x527e) [0x55d01cade27e]\n14: __libc_start_main\n15: /home/zengfanyi/projects/moose/modules/phase_field/phase_field-opt(+0x550d) [0x55d01cade50d]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\nEBSD_reconstruction.zip",
          "url": "https://github.com/idaholab/moose/discussions/17851",
          "updatedAt": "2022-06-27T12:03:31Z",
          "publishedAt": "2021-05-15T13:39:04Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "The error message indicates that one of the data points has coordinates outside the slab defined in the file's header. I'll take a look at the file. Maybe we can just discard such points and not fuss about it. I'm surprised this has not come up before, though.",
                  "url": "https://github.com/idaholab/moose/discussions/17851#discussioncomment-744516",
                  "updatedAt": "2022-06-27T12:03:40Z",
                  "publishedAt": "2021-05-15T15:57:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Looks to me like the header is not well formed. For one, the x_dim, y_dim, z_dim values should all be integers. Also x_dim * x_step + x_min should give you x_max. Please double check your export options or try changing the file manually. E.g. x_dim should be (1.5+850.5)/1.5 = 568.0.",
                  "url": "https://github.com/idaholab/moose/discussions/17851#discussioncomment-744517",
                  "updatedAt": "2022-06-27T12:03:51Z",
                  "publishedAt": "2021-05-15T16:05:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zengfy-hust"
                  },
                  "bodyText": "thank you ,I will follow your instruction this evening ,and I will let you know if it works well .",
                  "url": "https://github.com/idaholab/moose/discussions/17851#discussioncomment-744518",
                  "updatedAt": "2022-06-27T12:03:47Z",
                  "publishedAt": "2021-05-16T08:28:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zengfy-hust"
                  },
                  "bodyText": "Hello Moose workers \ud83d\udc4d\nA new error message occured when I change the input file and the EBSD_reconstruction file .I attached both files in this reply just for your better understand for my pronblem.The error meaasge was shown as following :\n*** ERROR ***\nA 'EBDSMeshGenerator' is not a registered object.\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\nStack frames: 21\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >)\n2: void mooseError<std::__cxx11::basic_string<char, std::char_traits, std::allocator > >(std::__cxx11::basic_string<char, std::char_traits, std::allocator >&&)\n3: Factory::reportUnregisteredError(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&) const\n4: Factory::getValidParams(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&)\n5: MooseObjectAction::MooseObjectAction(InputParameters)\n6: AddMeshGeneratorAction::AddMeshGeneratorAction(InputParameters)\n7: /home/zengfanyi/projects/moose/framework/libmoose-opt.so.0(+0xf3a968) [0x7f80565dc968]\n8: std::shared_ptr moose::internal::buildAct(InputParameters const&)\n9: ActionFactory::create(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, InputParameters&)\n10: Parser::walkRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >, hit::Node*)\n11: Parser::walk(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, hit::Node*)\n12: hit::Node::walk(hit::Walker*, hit::NodeType)\n13: hit::Node::walk(hit::Walker*, hit::NodeType)\n14: hit::Node::walk(hit::Walker*, hit::NodeType)\n15: Parser::parse(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&)\n16: MooseApp::setupOptions()\n17: MooseApp::run()\n18: /home/zengfanyi/projects/moose/modules/phase_field/phase_field-opt(+0x527e) [0x564a0ef9527e]\n19: __libc_start_main\n20: /home/zengfanyi/projects/moose/modules/phase_field/phase_field-opt(+0x550d) [0x564a0ef9550d]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\nUploading EBSD_reconstruction.zip\u2026",
                  "url": "https://github.com/idaholab/moose/discussions/17851#discussioncomment-744519",
                  "updatedAt": "2022-06-27T12:04:11Z",
                  "publishedAt": "2021-05-16T09:14:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Did you include phase field in the list of modules to compile for your application?",
                          "url": "https://github.com/idaholab/moose/discussions/17851#discussioncomment-805292",
                          "updatedAt": "2022-06-27T12:04:08Z",
                          "publishedAt": "2021-05-31T05:26:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zengfy-hust"
                          },
                          "bodyText": "sure I did",
                          "url": "https://github.com/idaholab/moose/discussions/17851#discussioncomment-805555",
                          "updatedAt": "2022-06-27T12:04:11Z",
                          "publishedAt": "2021-05-31T07:04:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "This is not related to the EBSD data file. You are running the input with an executable that does not have support for EBSD built in. I'm turning this into a discussion now. As this does not seem to be a MOOSE issue.",
                  "url": "https://github.com/idaholab/moose/discussions/17851#discussioncomment-744520",
                  "updatedAt": "2022-06-27T12:04:12Z",
                  "publishedAt": "2021-05-16T14:03:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Check the spelling. I think it's EBSD  MeshGenerator not EBDS",
                  "url": "https://github.com/idaholab/moose/discussions/17851#discussioncomment-808304",
                  "updatedAt": "2022-06-27T12:04:09Z",
                  "publishedAt": "2021-05-31T19:14:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zengfy-hust"
                          },
                          "bodyText": "sorry  for the fault ,after I correct that ,another error occurred .\n*** ERROR ***\nThe following error occurred in the object \"ebsd_mesh\", of type \"EBSDMeshGenerator\".\nEBSDMeshGenerator error. Requested uniform_refine levels not possible.\nI wonder what uniform_refine level should it be since I already set it to 1 .for your convenience ,I just upload the file I used for your better understanding of my question .FYI ,the coordination in EBSD_reconstruction.txt had been moved 0.5 just in case the coordination  overlapped.\nEBSD_reconstruction.zip\nhope to hear from you soon .",
                          "url": "https://github.com/idaholab/moose/discussions/17851#discussioncomment-809214",
                          "updatedAt": "2022-06-27T12:04:09Z",
                          "publishedAt": "2021-06-01T03:15:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Please check the documentation for more explanation on this object and the uniform refine parameter\nhttps://mooseframework.inl.gov/source/meshgenerators/EBSDMeshGenerator.html",
                          "url": "https://github.com/idaholab/moose/discussions/17851#discussioncomment-809228",
                          "updatedAt": "2022-06-27T12:04:10Z",
                          "publishedAt": "2021-06-01T03:23:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zengfy-hust"
                          },
                          "bodyText": "Another error occurred ,Do you know why this happen ?\n*** ERROR ***\nThe following error occurred in the object \"ebsd_reader\", of type \"EBSDReader\".\nAn EBSD feature needs to have a uniform phase.",
                          "url": "https://github.com/idaholab/moose/discussions/17851#discussioncomment-810831",
                          "updatedAt": "2022-06-27T12:04:12Z",
                          "publishedAt": "2021-06-01T12:47:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Attempting to read a bool vector from input",
          "author": {
            "login": "rks171"
          },
          "bodyText": "I'm attempting to use the InputParameters class to read a bool type vector from the input file as follows:\n       pars.set<std::vector<bool>>(\"param_name\") = getParam<std::vector<bool>>(\"param_name\");\n\nWhen I try to run the code, I get the following error:\n*** ERROR ***\nunsupported type 'std::__1::vector<bool, std::__1::allocator<bool> >' for input parameter 'GlobalParams/PBModelParams/param_name'\n\nWhich makes me think a vector of bools is not supported in the class?\nIf I change to using an int vector, it works.",
          "url": "https://github.com/idaholab/moose/discussions/17859",
          "updatedAt": "2022-09-07T07:26:54Z",
          "publishedAt": "2021-05-17T18:40:04Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "I think you are correct that this is not supported. I am not sure if this is intentional, but I imagine we don't support it because a std::vector is handled a bit differently than other types that has caused us problems in the past.\n@roystgnr Do you have any other info on this.",
                  "url": "https://github.com/idaholab/moose/discussions/17859#discussioncomment-753680",
                  "updatedAt": "2022-09-07T07:26:56Z",
                  "publishedAt": "2021-05-18T15:48:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "This one's not my fault!  Check out framework/src/parser/Parser.C - there's nothing in the Parameters or InputParameters class that would complain about a vector<bool>, but there's no option in the parser for instantiating one, and that Parser::extractParams() code looks to be the source of the error message above.\nThat might not be an intentional omission.  A lot of people do hate vector<bool> for not following the same sort of API as the other vector instantiations, but a vector<unsigned char> is a pretty popular substitute, and I don't see that in the Parser.C list either.",
                          "url": "https://github.com/idaholab/moose/discussions/17859#discussioncomment-758673",
                          "updatedAt": "2022-09-07T07:26:56Z",
                          "publishedAt": "2021-05-19T14:23:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "@rks171, You might follow Roy's suggestion and see if you can add the appropriate specialization in Parser.C. We would accept a tested contribution.\nThere are several macros in there to do this. Vector of bools may cause issues since they are fundamentally different, but as Roy suggested, I would start with 'unsigned char' and see if that meets your needs. Honestly, you might just use unsigned short and move on. It's unlikely that you have enough Booleans in an input parameter that would have any effect on memory usage.",
                          "url": "https://github.com/idaholab/moose/discussions/17859#discussioncomment-763664",
                          "updatedAt": "2023-03-21T12:57:31Z",
                          "publishedAt": "2021-05-20T14:32:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rks171"
                          },
                          "bodyText": "Thanks for the suggestions for this issue.  When you suggest to use unsigned char, does that mean the user would be inputting t or f for \"true\"  or \"false\" and then I would be checking to make sure that is what is entered in the parser side?  And I'm not sure if I understood @roystgnr correctly, but it sounds like unsigned char might not be supported either?  My current workaround is to just use unsigned int and have the user input 0/1.  It works, but it's just a little less straightforward than entering true/false or on/off.",
                          "url": "https://github.com/idaholab/moose/discussions/17859#discussioncomment-763873",
                          "updatedAt": "2023-03-21T12:57:32Z",
                          "publishedAt": "2021-05-20T15:12:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@rks171 did you go with unsigned int? Is it working for you\nLet's have an issue about this. Any volunteer to post it",
                          "url": "https://github.com/idaholab/moose/discussions/17859#discussioncomment-805267",
                          "updatedAt": "2023-03-21T12:57:56Z",
                          "publishedAt": "2021-05-31T05:16:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rks171"
                          },
                          "bodyText": "Yes I have been using unsigned int and it works fine as a workaround.",
                          "url": "https://github.com/idaholab/moose/discussions/17859#discussioncomment-810726",
                          "updatedAt": "2023-03-21T12:57:56Z",
                          "publishedAt": "2021-06-01T12:16:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}