{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wMy0xN1QxMTozNjo1OS0wNTowMM4AMWSJ"
    },
    "edges": [
      {
        "node": {
          "title": "Mortar interface flux match",
          "author": {
            "login": "srinath-chakravarthy"
          },
          "bodyText": "A question for all the mortar experts. I am trying to mimic the interfacefluxmatch with mortar. For some reason i am encountering convergence issues with this. I am using ADMortar. Please see below my implementation. Any help will be appreciated.\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/* \n * File:   EqualNormalFluxConstraint.C\n * Author: srinath\n * \n * Created on January 28, 2021, 1:21 PM\n */\n\n#include \"EqualNormalFluxConstraint.h\"\n\n#include \"SubProblem.h\"\n#include \"FEProblem.h\"\n\nregisterMooseObject(\"electro_chemo_mechApp\", EqualNormalFluxConstraint);\n\nInputParameters\nEqualNormalFluxConstraint::validParams()\n{\n  InputParameters params = ADMortarConstraint::validParams();\n  params.addClassDescription(\n      \"EqualNormalFluxConstraint enforces continuity of a gradient component between secondary and \"\n      \"primary sides of a mortar interface using lagrange multipliers\");\n  params.addParam<MaterialPropertyName>(\n      \"primary_mat_prop\",\n      \"diffusivity\",\n      \"The material property name providing the quantity to equilibrate on the primary side\");\n  params.addParam<MaterialPropertyName>(\n      \"secondary_mat_prop\",\n      \"diffusivity\",\n      \"The material property name providing the quantity to equilibrate on the secondary side\");\n  params.addParam<bool>(\"primary_tensor\", false, \"Is the material property tensor_valued\");\n  params.addParam<bool>(\"secondary_tensor\", false, \"Is the material property tensor_valued\");\n  \n  return params;\n}\n\nEqualNormalFluxConstraint::EqualNormalFluxConstraint(const InputParameters & parameters)\n  : ADMortarConstraint(parameters),\n  _primary_tensor(getParam<bool>(\"primary_tensor\")),\n  _secondary_tensor(getParam<bool>(\"secondary_tensor\")),\n  _primary_mat_prop_real(!_primary_tensor ? &getNeighborADMaterialProperty<Real>(\"primary_mat_prop\"):nullptr),\n  _secondary_mat_prop_real(!_secondary_tensor ? &getADMaterialProperty<Real>(\"secondary_mat_prop\"):nullptr),\n  _primary_mat_prop_tensor(_primary_tensor ? &getNeighborADMaterialProperty<RealTensorValue>(\"primary_mat_prop\"):nullptr),\n  _secondary_mat_prop_tensor(_secondary_tensor ? &getADMaterialProperty<RealTensorValue>(\"secondary_mat_prop\"):nullptr)\n\n{\n}\n\nADReal\nEqualNormalFluxConstraint::computeQpResidual(Moose::MortarType mortar_type)\n{\n       \n  switch (mortar_type)\n  {\n    case Moose::MortarType::Secondary:\n      return _lambda[_qp] * _test_secondary[_i][_qp]; \n    case Moose::MortarType::Primary:\n      return _lambda[_qp] * _test_primary[_i][_qp];\n    case Moose::MortarType::Lower:\n    {\n        ADRealVectorValue gradup; \n        ADRealVectorValue gradus;\n        auto residual = _lambda[_qp] * _test[_i][_qp];\n        if (_has_primary)\n        {\n            if (!_primary_tensor)\n                gradup = (*_primary_mat_prop_real)[_qp] * _grad_u_primary[_qp];\n            else\n                gradup = (*_primary_mat_prop_tensor)[_qp] * _grad_u_primary[_qp];\n            if (!_secondary_tensor)\n                gradus = (*_secondary_mat_prop_real)[_qp] * _grad_u_secondary[_qp];\n            else\n                gradus = (*_secondary_mat_prop_tensor)[_qp] * _grad_u_secondary[_qp];\n                \n            residual = ((gradup - gradus) * _normals[_qp]  + _lambda[_qp]) * _test[_i][_qp];\n        }\n                    \n        return residual;\n    }\n    default:\n      return 0;\n  }\n}",
          "url": "https://github.com/idaholab/moose/discussions/16880",
          "updatedAt": "2022-06-02T06:20:00Z",
          "publishedAt": "2021-02-03T21:47:01Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc who can I tag on mortar problems?\nThanks",
                  "url": "https://github.com/idaholab/moose/discussions/16880#discussioncomment-494354",
                  "updatedAt": "2022-06-02T06:26:57Z",
                  "publishedAt": "2021-03-17T15:48:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "@lindsayad",
                          "url": "https://github.com/idaholab/moose/discussions/16880#discussioncomment-495580",
                          "updatedAt": "2022-06-02T06:26:58Z",
                          "publishedAt": "2021-03-17T20:25:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@srinath-chakravarthy I believe you need a difference in sign between your Secondary and Primary residual. Right now you are applying the same sign. For something like heat transport for example that would mean that you are applying a heat sink on both sides of the interface (if lambda is positive) or a heat source on both sides of the interface (if lambda is negative).",
                  "url": "https://github.com/idaholab/moose/discussions/16880#discussioncomment-495936",
                  "updatedAt": "2022-06-02T06:27:05Z",
                  "publishedAt": "2021-03-17T22:07:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The GapConductanceConstraint class in the heat_conduction module applies continuity of heat flux across a mortar interface. You can see the difference in signs between primary and secondary residuals",
                          "url": "https://github.com/idaholab/moose/discussions/16880#discussioncomment-495940",
                          "updatedAt": "2022-06-02T06:27:10Z",
                          "publishedAt": "2021-03-17T22:09:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Well I shouldn't really say \"continuity of heat flux\". I should say that the heat flux is the same on either side of the interface and we are setting that flux equal to \"k * (T_primary - T_secondary) / gap\" through the use of the Lagrange Multiplier",
                          "url": "https://github.com/idaholab/moose/discussions/16880#discussioncomment-495979",
                          "updatedAt": "2022-06-02T06:27:11Z",
                          "publishedAt": "2021-03-17T22:12:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Buckling?",
          "author": {
            "login": "jmhospers"
          },
          "bodyText": "Hello everyone,\nI am looking at MOOSE for structural engineering applications, where we now use commercial applications. For many use cases, the high cost is not warranted and I want an alternative. MOOSE appears very capable for linear/plastic applications. However, I cannot find a capability for (linear bifurcation) buckling calculations? It must be possible, anyone here ever done this?",
          "url": "https://github.com/idaholab/moose/discussions/17328",
          "updatedAt": "2022-08-10T14:11:49Z",
          "publishedAt": "2021-03-16T12:49:11Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "MOOSE currently doesn't have an arc-length solver. Contributions are always welcome.",
                  "url": "https://github.com/idaholab/moose/discussions/17328#discussioncomment-488840",
                  "updatedAt": "2022-08-10T14:11:49Z",
                  "publishedAt": "2021-03-16T14:01:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jmhospers"
                          },
                          "bodyText": "I was hoping there was some obscure way to call the eigensolvers. I don't feel like my math/coding would be up to scrap at the moment.",
                          "url": "https://github.com/idaholab/moose/discussions/17328#discussioncomment-488912",
                          "updatedAt": "2022-08-10T14:11:49Z",
                          "publishedAt": "2021-03-16T14:14:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Oh sorry! I misunderstood your question. MOOSE can definitely solve eigenvalue problems. Maybe use this page https://mooseframework.inl.gov/source/executioners/NonlinearEigen.html as a starting point.",
                          "url": "https://github.com/idaholab/moose/discussions/17328#discussioncomment-488965",
                          "updatedAt": "2022-08-10T14:12:23Z",
                          "publishedAt": "2021-03-16T14:25:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@sapitts Do you have any information you could add about tensor mechanics?",
                  "url": "https://github.com/idaholab/moose/discussions/17328#discussioncomment-495670",
                  "updatedAt": "2022-08-10T14:12:23Z",
                  "publishedAt": "2021-03-17T20:43:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "I don't have anything to add beyond what @hugary1995 has already posted about eigensolvers. @bwspenc would be a better bet for column buckling model recommendations",
                          "url": "https://github.com/idaholab/moose/discussions/17328#discussioncomment-495870",
                          "updatedAt": "2022-08-10T14:12:23Z",
                          "publishedAt": "2021-03-17T21:40:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "unable to run tests on the combined module and simulations input files do not run!",
          "author": {
            "login": "Ali-toghraee"
          },
          "bodyText": "Hello all,\nI am trying to install the new version of MOOSE with conda. The tests did not run at first but I did the following and the moose tests passed.\nconda deactivate\nmodule purge\nconda activate moose\ncd /path to my moose folder/\ngit clean -xfd # warning... this will delete any unsaved commits if you have any\ncd test\nmake -j #my cpu core numbers\n./run_tests\nNow, to run my simulations, I made the executable in combined module folder(combined-opt). However the tests for that did not run leaving errors as below:\n(base) atoghraee@ME-DESKTOP102: ~/ projects02/moose/modules/combined$ conda activate moose\n(moose) atoghraee@ME-DESKTOP102: / projects02 / moose/ modules/ combined$ ./ run_tests -j 90\nBuilding and linking hit...\nfailed to import pyhit - try running \"make hit\" in the $MOOSE_DIR/test directory.\n(moose) atoghraee@ME-DESKTOP102:/ projects02/ moose/modules / combined$\nI should mention that I already have a moose from 2019 in the projects folder, So to install the new moose I just created another folder under projects02",
          "url": "https://github.com/idaholab/moose/discussions/17292",
          "updatedAt": "2022-07-20T15:26:22Z",
          "publishedAt": "2021-03-11T21:23:20Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt looks like you are missing pyhit. Could you please install it with conda install moose-pyhit\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17292#discussioncomment-491038",
                  "updatedAt": "2022-07-20T15:26:26Z",
                  "publishedAt": "2021-03-16T21:32:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "I don't think we have a moose-pyhit package in conda.",
                          "url": "https://github.com/idaholab/moose/discussions/17292#discussioncomment-495634",
                          "updatedAt": "2022-07-20T15:26:27Z",
                          "publishedAt": "2021-03-17T20:40:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "You might be running into a PYTHONPATH problem, make sure you don't have it set to something that points it to the projects/moose location. Also, make sure you don't have $MOOSE_DIR set incorrectly for where you are working.",
                  "url": "https://github.com/idaholab/moose/discussions/17292#discussioncomment-495651",
                  "updatedAt": "2022-07-20T15:26:27Z",
                  "publishedAt": "2021-03-17T20:42:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "Also make sure you have the conda environment loaded.",
                          "url": "https://github.com/idaholab/moose/discussions/17292#discussioncomment-495655",
                          "updatedAt": "2022-07-20T15:26:28Z",
                          "publishedAt": "2021-03-17T20:42:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "'Compute Strain Increment Based Stress' for Steady-State problem",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi MOOSE users,\nI have question regarding 'Compute Strain Increment Based Stress' for steady-state simulation\n\nultimately, I want my appliccation to work as follow, where I can change the value of C and strain at any particular block\n\nSo, the question is how do I define stress_old, strain_mech, strain_mech_old from an output file from the previous steady-state step?\nHere in I attached the previous step output file generator (grav_redo.i)\nand currect step .i file with Compute Strain Increment Based Stress (grav_redo_later.i)\ntensor mech elastic equli.zip\nThank you for your time.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/17326",
          "updatedAt": "2022-09-09T13:25:06Z",
          "publishedAt": "2021-03-16T04:38:12Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @Traiwit\nIn general, every MaterialProperty defined in the code can be initialised from a previous file.\nFor instance we add the following in the [AuxVariables] block of the restart input file to initialise a stress component:\n[./stress_xx]\norder = CONSTANT\nfamily = MONOMIAL\ninitial_from_file_var = stress_xx\ninitial_from_file_timestep = 620\n[../]\nWe have to do this for all the components.\nIf the above block is used, the standard initialisation in the material object is skipped.\nYou will need to do that for your: stress_old, strain_mech, strain_mech_old\nSo in general, if you want to restart a material model, you need to define in the initial input file\nall the material properties that must keep the memory of the previous simulation (both in AuxVariables and AuxKernels),\nthen in the restart file, you define them again, both in AuxVariables and AuxKernels,\nand you have to initialise them as in the example above. You need to do this for all components\nof all MaterialProperty that must keep memory in your simulation.\nSome MaterialProperty are like history variables and need to be initialised, others may not be history variables.\nThis you need to determine yourself.\nDon't forget to check parent classes of your material objects, as they may contain some of the MaterialProperty\nthat must be initialised.\nTrust this helps.\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-487848",
                  "updatedAt": "2022-09-09T13:25:42Z",
                  "publishedAt": "2021-03-16T10:04:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @ngrilli,\nFirst of all, thank you for always helping me out, I really appreciate your help!\nI will give it a go and keep you updated.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-488281",
                          "updatedAt": "2022-09-09T13:26:42Z",
                          "publishedAt": "2021-03-16T12:02:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Sidenote: I wish there are more examples of the steady-state problem, as transient doesn't suit my objective.\nIt can be easily done using for-loop in python/matlab, but solving tensor-mechanical problems there is also difficult",
                  "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-488283",
                  "updatedAt": "2022-09-09T13:27:18Z",
                  "publishedAt": "2021-03-16T12:03:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "You might also consider looking into the restart and recovery capability for MOOSE simulations. More information here. I've used the restart capability successfully in quasi-static / transient simulations, although I have never tried it in a steady state tensor mechanics simulation, and the option may be of use here too",
                  "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-491224",
                  "updatedAt": "2022-09-09T13:27:18Z",
                  "publishedAt": "2021-03-16T22:34:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @sapitts, yes I am using the 'restart' for the Variable (disp_x,y,z) but it cannot call the higher-order Auxvariable for some reason, Auxvariable constant/monomial can be imported with no issue using initial_from_file_var.",
                          "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-492087",
                          "updatedAt": "2022-10-20T13:28:19Z",
                          "publishedAt": "2021-03-17T05:24:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "@aeslaughter is there a MOOSE developer that could help with this question about restart with higher order monomial variables?",
                          "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-494426",
                          "updatedAt": "2022-10-20T13:28:19Z",
                          "publishedAt": "2021-03-17T16:03:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "@loganharbour @friedmud Do either of you know how to help?",
                          "url": "https://github.com/idaholab/moose/discussions/17326#discussioncomment-495569",
                          "updatedAt": "2022-10-20T13:28:19Z",
                          "publishedAt": "2021-03-17T20:22:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Runtime Error \"ERROR: no system number 0 found!\"",
          "author": {
            "login": "AngeloCass"
          },
          "bodyText": "I have developed a C++ routine that makes use of a MOOSE application to execute a model with varying parameter sets. This routine uses MPI to iterate through different parameter sets in parallel. The routine works as expected on my local machine, but when trying to test on the HPC cluster that I am using, I get the error shown in the subject line. I will attach a text file containing the output with errors.\nError.txt",
          "url": "https://github.com/idaholab/moose/discussions/17350",
          "updatedAt": "2021-05-06T17:20:09Z",
          "publishedAt": "2021-03-17T16:07:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "AngeloCass"
                  },
                  "bodyText": "I forgot to ask this directly, but if anyone has suggestions or solutions for this please let me know! Thanks!",
                  "url": "https://github.com/idaholab/moose/discussions/17350#discussioncomment-494448",
                  "updatedAt": "2021-03-17T16:11:36Z",
                  "publishedAt": "2021-03-17T16:11:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "Can you share the problem (input) you're running?",
                  "url": "https://github.com/idaholab/moose/discussions/17350#discussioncomment-494488",
                  "updatedAt": "2021-03-17T16:20:19Z",
                  "publishedAt": "2021-03-17T16:19:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AngeloCass"
                          },
                          "bodyText": "I will attach the input file to this reply. Some of the values in the GlobalParams block are overwritten with command line inputs by the C++ routine at runtime. Also, the Outputs block file base is defined unique to each execution through a command line input.\nInput.txt",
                          "url": "https://github.com/idaholab/moose/discussions/17350#discussioncomment-494547",
                          "updatedAt": "2021-03-17T16:35:02Z",
                          "publishedAt": "2021-03-17T16:35:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "Hopefully you are aware that we have native capability for doing this: https://mooseframework.inl.gov/modules/stochastic_tools/index.html",
                  "url": "https://github.com/idaholab/moose/discussions/17350#discussioncomment-495556",
                  "updatedAt": "2021-03-17T20:18:10Z",
                  "publishedAt": "2021-03-17T20:17:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Load nemesis output files into SolutionUserObject",
          "author": {
            "login": "zhang-rite"
          },
          "bodyText": "Hi,\nNow another problem related to distributed mesh is how to read the series of nemesis output files (e.g., e..) into a SolutionUserObject for the initial condition in next run? Is there a function for this available? Or for converting nemesis output to an exodus file.\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/17226",
          "updatedAt": "2023-03-15T15:25:48Z",
          "publishedAt": "2021-03-04T08:26:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@loganharbour can you please answer this or tag someone knowledgeable about nemesis",
                  "url": "https://github.com/idaholab/moose/discussions/17226#discussioncomment-495156",
                  "updatedAt": "2023-03-15T15:25:48Z",
                  "publishedAt": "2021-03-17T18:39:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "SolutionUserObject doesn't support Nemesis, so to do this correctly that would need to be added. You can use Paraview to convert the Nemesis files to a single Exodus. You can even limit the output to a certain variable. Of course, if the mesh is very large that will probably give you memory problems.",
                  "url": "https://github.com/idaholab/moose/discussions/17226#discussioncomment-495535",
                  "updatedAt": "2023-03-15T15:25:59Z",
                  "publishedAt": "2021-03-17T20:15:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Plotting Yield locus",
          "author": {
            "login": "Aayush-T"
          },
          "bodyText": "Hi everyone,\nI am new to Moose, I wanted to make a Yield surface for a biaxial loading case. I have calculated stress and strain but can not find a way for finding equivalent plastic strain. I tried using the value of stresses at t=10 sec and then calculate principal stresses from them to plot the graph for different displacement values, but the graph is not right. Can anyone help with it? The code and graph\n\nis attached below.\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  elem_type = QUAD4\n  displacements = 'disp_x disp_y'\n  nx = 1\n  ny = 1\n[]\n\n[Variables]\n  [./disp_x]\n  [../]\n  [./disp_y]\n  [../]\n[]\n\n[GlobalParams]\n  volumetric_locking_correction = true\n[]\n\n[AuxVariables]\n  [./stress_yy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./stress_xx]\n  order = CONSTANT\n  family = MONOMIAL\n  [../]\n  [./stress_xy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e_yy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e_xx]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./e_xy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./fp_yy]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./gss]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./euler1]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./euler2]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./euler3]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[Functions]\n  [./tdisp]\n    type = ParsedFunction\n    value = 0.001*t\n  [../]\n  [./rdisp]\n  type = ParsedFunction\n  value = 0.001*t\n[../]\n[]\n\n[UserObjects]\n  [./prop_read]\n    type = ElementPropertyReadFile\n    prop_file_name = 'euler_ang_file.txt'\n    # Enter file data as prop#1, prop#2, .., prop#nprop\n    nprop = 3\n    read_type = element\n  [../]\n[]\n\n[AuxKernels]\n  [./stress_yy]\n    type = RankTwoAux\n    variable = stress_yy\n    rank_two_tensor = stress\n    index_j = 1\n    index_i = 1\n    execute_on = timestep_end\n  [../]\n  [./e_yy]\n    type = RankTwoAux\n    variable = e_yy\n    rank_two_tensor = lage\n    index_j = 1\n    index_i = 1\n    execute_on = timestep_end\n  [../]\n  [./stress_xx]\n    type = RankTwoAux\n    variable = stress_xx\n    rank_two_tensor = stress\n    index_j = 0\n    index_i = 0\n    execute_on = timestep_end\n  [../]\n  [./e_xx]\n    type = RankTwoAux\n    variable = e_xx\n    rank_two_tensor = lage\n    index_j = 0\n    index_i = 0\n    execute_on = timestep_end\n  [../]\n  [./e_xy]\n    type = RankTwoAux\n    variable = e_xy\n    rank_two_tensor = lage\n    index_j = 1\n    index_i = 0\n    execute_on = timestep_end\n  [../]\n  [./stress_xy]\n    type = RankTwoAux\n    variable = stress_xy\n    rank_two_tensor = stress\n    index_j = 1\n    index_i = 0\n    execute_on = timestep_end\n  [../]\n  [./fp_yy]\n    type = RankTwoAux\n    variable = fp_yy\n    rank_two_tensor = fp\n    index_j = 1\n    index_i = 1\n    execute_on = timestep_end\n  [../]\n  [./gss]\n    type = MaterialStdVectorAux\n    variable = gss\n    property = state_var_gss\n    index = 0\n    execute_on = timestep_end\n  [../]\n  [./euler1]\n    type = MaterialRealVectorValueAux\n    variable = euler1\n    property = Euler_angles\n    component = 0\n    execute_on = timestep_end\n  [../]\n  [./euler2]\n    type = MaterialRealVectorValueAux\n    variable = euler2\n    property = Euler_angles\n    component = 1\n    execute_on = timestep_end\n  [../]\n  [./euler3]\n    type = MaterialRealVectorValueAux\n    variable = euler3\n    property = Euler_angles\n    component = 2\n    execute_on = timestep_end\n  [../]\n[]\n\n[BCs]\n  [./fix_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom'\n    value = 0\n  [../]\n  [./fix_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0\n  [../]\n  [./tdisp]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = top\n    function = tdisp\n  [../]\n#  [./rdisp]\n#    type = FunctionDirichletBC\n#    variable = disp_x\n#    boundary = right\n#    function = rdisp\n#  [../]\n[]\n\n[UserObjects]\n  [./slip_rate_gss]\n    type = CrystalPlasticitySlipRateGSS\n    variable_size = 12\n    slip_sys_file_name = input_slip_sys.txt\n    num_slip_sys_flowrate_props = 2\n    flowprops = '1 4 0.001 0.1 5 8 0.001 0.1 9 12 0.001 0.1'\n    uo_state_var_name = state_var_gss\n  [../]\n  [./slip_resistance_gss]\n    type = CrystalPlasticitySlipResistanceGSS\n    variable_size = 12\n    uo_state_var_name = state_var_gss\n  [../]\n  [./state_var_gss]\n    type = CrystalPlasticityStateVariable\n    variable_size = 12\n    groups = '0 4 8 12'\n    group_values = '60.8 60.8 60.8'\n    uo_state_var_evol_rate_comp_name = state_var_evol_rate_comp_gss\n    scale_factor = 1.0\n  [../]\n  [./state_var_evol_rate_comp_gss]\n    type = CrystalPlasticityStateVarRateComponentGSS\n    variable_size = 12\n    hprops = '1.0 541.5 109.8 2.5'\n    uo_slip_rate_name = slip_rate_gss\n    uo_state_var_name = state_var_gss\n  [../]\n[]\n\n[Materials]\n  [./crysp]\n    type = FiniteStrainUObasedCP\n    stol = 1e-2\n    tan_mod_type = exact\n    uo_slip_rates = 'slip_rate_gss'\n    uo_slip_resistances = 'slip_resistance_gss'\n    uo_state_vars = 'state_var_gss'\n    uo_state_var_evol_rate_comps = 'state_var_evol_rate_comp_gss'\n  [../]\n  [./strain]\n    type = ComputeFiniteStrain\n    displacements = 'disp_x disp_y'\n  [../]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '1.684e5 1.214e5 1.214e5 1.684e5 1.214e5 1.684e5 0.754e5 0.754e5 0.754e5'\n    fill_method = symmetric9\n    read_prop_user_object = prop_read\n  [../]\n[]\n\n[Postprocessors]\n  [./stress_yy]\n    type = ElementAverageValue\n    variable = stress_yy\n  [../]\n  [./stress_xx]\n    type = ElementAverageValue\n    variable = stress_xx\n  [../]\n  [./e_xy]\n    type = ElementAverageValue\n    variable = e_xy\n  [../]\n  [./e_yy]\n    type = ElementAverageValue\n    variable = e_yy\n  [../]\n  [./e_xx]\n    type = ElementAverageValue\n    variable = e_xx\n  [../]\n  [./stress_xy]\n    type = ElementAverageValue\n    variable = stress_xy\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  dt = 0.01\n  solve_type = 'PJFNK'\n\n  petsc_options_iname = -pc_hypre_type\n  petsc_options_value = boomerang\n  nl_abs_tol = 1e-10\n  nl_rel_step_tol = 1e-10\n  dtmax = 10.0\n  nl_rel_tol = 1e-10\n  dtmin = 0.01\n  num_steps = 1000\n  nl_abs_step_tol = 1e-10\n[]\n\n[Outputs]\n  exodus = true\n   csv = true\n[]\n\n[Kernels]\n  [./TensorMechanics]\n    displacements = 'disp_x disp_y'\n    use_displaced_mesh = true\n  [../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/16839",
          "updatedAt": "2022-06-10T14:44:28Z",
          "publishedAt": "2021-01-30T07:05:19Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Aayush-T"
                  },
                  "bodyText": "The block letter part is not part of the code and was commented by me, I forgot to remove it while pasting the code here!",
                  "url": "https://github.com/idaholab/moose/discussions/16839#discussioncomment-322881",
                  "updatedAt": "2022-06-24T09:22:36Z",
                  "publishedAt": "2021-01-30T07:07:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @Aayush-T\nIf you use the crystal plasticity model,\nthe scalar cumulative plastic strain is calculated and the variable is called \"_acc_slip\" in the code.\nTherefore, you can add an auxiliary variable like:\n[./acc_slip]\norder = CONSTANT\nfamily = MONOMIAL\n[../]\nand corresponding AuxKernel:\n[./acc_slip]\ntype = MaterialRealAux\nvariable = acc_slip\nproperty = acc_slip\nexecute_on = timestep_end\n[../]\nNot sure which quantity you are looking for exactly.\nIf you want something like Mises plastic strain, then you can output the components\nof the plastic deformation gradients using for instance:\n[./fp_xy]\norder = CONSTANT\nfamily = MONOMIAL\n[../]\nand\n[./fp_xy]\ntype = RankTwoAux\nvariable = fp_xy\nrank_two_tensor = fp\nindex_j = 1\nindex_i = 0\nexecute_on = timestep_end\n[../]\nThen you can calculate equivalent plastic strain with the expression you like using the paraview \"calculator\" filter.\nHope this helps\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/16839#discussioncomment-324607",
                  "updatedAt": "2022-06-24T09:22:36Z",
                  "publishedAt": "2021-01-31T07:42:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Aayush-T"
                          },
                          "bodyText": "Yes, actually I was looking for ways to get the equivalent plastic strain values from the moose itself and output in the csv file as I could not find any direct function in moose that does it. Thanks for such a prompt response.\nRegards,\nAayush Trivedi\nIIT Bombay",
                          "url": "https://github.com/idaholab/moose/discussions/16839#discussioncomment-372507",
                          "updatedAt": "2022-06-24T09:22:36Z",
                          "publishedAt": "2021-02-16T06:03:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "This should really be possible by setting the appropriate scalar_type in the RankTwoScalarAux .  If it isn't currently possible, you (or someone), should add that functionality for future users.",
                          "url": "https://github.com/idaholab/moose/discussions/16839#discussioncomment-375087",
                          "updatedAt": "2022-06-24T09:22:36Z",
                          "publishedAt": "2021-02-16T21:01:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Aayush-T"
                          },
                          "bodyText": "I am trying to add this. Also, the _acc_slip is not working in the dual-phase crysp case that I am using. If anyone else is able to do that, please do post or I will update it.",
                          "url": "https://github.com/idaholab/moose/discussions/16839#discussioncomment-427113",
                          "updatedAt": "2022-06-24T09:22:36Z",
                          "publishedAt": "2021-03-03T20:20:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "AD Neumann BC for a vector variable",
          "author": {
            "login": "ABallisat"
          },
          "bodyText": "Hello all,\nI have a need to set a Neumann BC for a vector variable, specifically setting a component of the gradient of a component of a vector to be a value (probably zero), for example something along the lines of\npartial v_x / partial y = 0\n\nfor vector v with components x and y (and naturally extend to 3D). I am using AD so would prefer it to be within that system. I have been looking at the ADIntegratedBC.C as a basis for this but cannot figure out how to get it to work with vector variables. Could someone point me in the right direction?\nI have looked at VectorNeumannBC.C but cannot figure out how it iterates over a vector variable, my understanding in this area is lacking. My guess is that the\nfor (_i = 0; _i < _test.size(); _i++)\nline iterates over the components as _test.size() returns the number of components of the vector, is this understanding correct? If so, then i could be passed through to work out what component you are on.\nThanks for the help!\nAlex",
          "url": "https://github.com/idaholab/moose/discussions/17018",
          "updatedAt": "2023-04-07T16:49:01Z",
          "publishedAt": "2021-02-16T16:09:57Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Alex\nVectorNeumannBC are definitely a good start to create an AD version of that BC.\n_i will indeed be the component the BC is currently considering.\nYou may want to look at ADVectorDirichletBC as well btw.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17018#discussioncomment-495143",
                  "updatedAt": "2023-03-02T13:40:01Z",
                  "publishedAt": "2021-03-17T18:36:39Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Grain Growth - grain_growth_2D_random.i",
          "author": {
            "login": "EtienneSwerim"
          },
          "bodyText": "Hi,\nCould I get a little help with the appended example file: grain_growth_2D_random.i?\nAs I understand from the Grain Growth Model section of the Moose Manual, order parameters and kernels are automatically created by the Action system called GrainGrowthAction. I even found the files GrainGrowthAction.h and GrainGrowthAction.C and read them.\nWhat I do not understand is:\n\n\nWhere, in the grain_growth_2D_random.i, are the GrainGrowthAction files called? The name GrainGrowthAction is not present in the file! I guess these files are called implicitly but how?\n\n\nWhen it comes to variables, only the name PolycrystalVariables is defined but neither a type nor an action, see below.\n\n\n[Variables]\n  # Variable block, where all variables in the simulation are declared\n  [./PolycrystalVariables]\n    # Custom action that created all of the grain variables and sets their initial condition\n  [../]\n[]\n\nI noticed that Moose crashes if the name PolycrystalVariables is changed and I noticed that there is a folder called PolycrystalVariables\n(moose/module/phase_field/doc/content/syntax/Variables/PolycrystalVariables)\nThis folder contains a single file called index.md which contain the following single line:\n!template load file=stubs/moose_system.md.template name=PolycrystalVariables syntax=/Variables/PolycrystalVariables\na) Is this index.md file called by the variable name PolycrystalVariables in the grain_growth_2D_random.i file?\nb) What does this index.md file do? I noticed there were a lot of theses files in the moose folder for example one below PolycrystalKernel and one below PolycrystalRandomIC and I do not understand what these two do either.\nVery grateful for help!\nBest Regards\nEtienne\ngrain_growth_2D_random.txt",
          "url": "https://github.com/idaholab/moose/discussions/16966",
          "updatedAt": "2022-08-22T16:39:44Z",
          "publishedAt": "2021-02-11T20:54:37Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "SudiptaBiswas"
                  },
                  "bodyText": "The input file you are referring to doesn't use GrainGrowthAction. Instead, it separately uses the PolycrystalVariableAction and PolycrystalkernelAction.  Variables/PolycrystalVariables calls for the action that sets up the variables based on variable_base_name and op_num. You can find out how the actions are registered in the PhaseFieldApp.C file.\n*.md files are the documentation files. You will find more documentation on this on the mooseframework website.",
                  "url": "https://github.com/idaholab/moose/discussions/16966#discussioncomment-361168",
                  "updatedAt": "2022-08-22T16:39:44Z",
                  "publishedAt": "2021-02-11T22:48:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "EtienneSwerim"
                          },
                          "bodyText": "Hi Sudipta,\nThanks a lot for your answer!\nVery useful to know about the PhaseFieldApp.C file.\nAs I understand from your answer, when the input file contains:\n[Variables]\n[./PolycrystalVariables]\n[../]\n[]\nMoose calls the files: PolycrystalVariablesAction.h and PolycrystalVariablesAction.C.\nAnd good to know that all the .md files are for documentation and not calculation.\nAgain, thanks a lot! I am new to Moose so help is greatly appreciated.\nBest Regards\nEtienne",
                          "url": "https://github.com/idaholab/moose/discussions/16966#discussioncomment-362733",
                          "updatedAt": "2022-08-22T16:39:44Z",
                          "publishedAt": "2021-02-12T13:37:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MPI had an error",
          "author": {
            "login": "Leni-Yeo"
          },
          "bodyText": "Good afternoon,\nI am trying to do a simulation for polycrystal grain growth. I saw the example that applies the polycrystalvariables and polycrystalkernel actions. I modified the polycrystalkernel action to include the following kernels: ADAllenCahn, ADTimeDerivative, and ADACInterfaceKobayashi2 for a basic simulation. The problem is that I get a \"MPI had an error\" when running the simulation. I cannot find the exact problem. I assumed it is in the action kernel but still could not solve it.  Please help.\nI attached my input file and the kernel action I am using to set up the kernels.\n##################### I COPIED THE ERROR BELOW ##########################\nGeneric Warning: In ../Parallel/MPI/vtkMPICommunicator.cxx, line 69\nMPI had an error\nInvalid communicator, error stack:\nMPI_Comm_test_inter(112): MPI_Comm_test_inter(comm=0xf2e8f3e0, flag=0x7ffcce88cfc0) failed\nMPI_Comm_test_inter(70).: Invalid communicator\napplication called MPI_Abort(MPI_COMM_WORLD, 612613) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=612613\n:\nsystem msg for write_line failure : Bad file descriptor\nPrimary job  terminated normally, but 1 process returned\na non-zero exit code. Per user-direction, the job has been aborted.\nGeneric Warning: In ../Parallel/MPI/vtkMPICommunicator.cxx, line 69\nMPI had an error\nInvalid communicator, error stack:\nMPI_Comm_test_inter(112): MPI_Comm_test_inter(comm=0x4ce493e0, flag=0x7ffd8f4d8be0) failed\nMPI_Comm_test_inter(70).: Invalid communicator\napplication called MPI_Abort(MPI_COMM_WORLD, 612613) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=612613\n:\nsystem msg for write_line failure : Bad file descriptor\nAssertion failed in file src/mpi/comm/comm_test_inter.c at line 77: ((comm)&(0x03ffffff)) < MPIR_COMM_N_BUILTIN\n/home/user/miniconda3/envs/moose/lib/libmpi.so.12(+0x1c7d93) [0x7fa949f80d93]\n/home/user/miniconda3/envs/moose/lib/libmpi.so.12(MPL_backtrace_show+0x18) [0x7fa949f80e73]\n/home/user/miniconda3/envs/moose/lib/libmpi.so.12(+0x15bb94) [0x7fa949f14b94]\n/home/user/miniconda3/envs/moose/lib/libmpi.so.12(MPI_Comm_test_inter+0x2f0) [0x7fa949e27840]\n/lib/x86_64-linux-gnu/libmpi_cxx.so.40(_ZN3MPI9IntracommC1EP19ompi_communicator_t+0x8b) [0x7fa9443623db]\n/lib/x86_64-linux-gnu/libmpi_cxx.so.40(+0x1125a) [0x7fa94435e25a]\n/lib64/ld-linux-x86-64.so.2(+0x11b8a) [0x7fa94e9abb8a]\n/lib64/ld-linux-x86-64.so.2(+0x11c91) [0x7fa94e9abc91]\n/lib/x86_64-linux-gnu/libc.so.6(_dl_catch_exception+0xe5) [0x7fa94abed915]\n/lib64/ld-linux-x86-64.so.2(+0x160bf) [0x7fa94e9b00bf]\n/lib/x86_64-linux-gnu/libc.so.6(_dl_catch_exception+0x88) [0x7fa94abed8b8]\n/lib64/ld-linux-x86-64.so.2(+0x155fa) [0x7fa94e9af5fa]\n/lib/x86_64-linux-gnu/libdl.so.2(+0x134c) [0x7fa94717734c]\n/lib/x86_64-linux-gnu/libc.so.6(_dl_catch_exception+0x88) [0x7fa94abed8b8]\n/lib/\ninternal ABORT - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\nGeneric Warning: In ../Parallel/MPI/vtkMPICommunicator.cxx, line 69\nMPI had an error\nInvalid communicator, error stack:\nMPI_Comm_test_inter(112): MPI_Comm_test_inter(comm=0xa292c3e0, flag=0x7ffe75b7b580) failed\nMPI_Comm_test_inter(70).: Invalid communicator\napplication called MPI_Abort(MPI_COMM_WORLD, 537483525) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=537483525\n:\nsystem msg for write_line failure : Bad file descriptor\nGeneric Warning: In ../Parallel/MPI/vtkMPICommunicator.cxx, line 69\nMPI had an error\nInvalid communicator, error stack:\nMPI_Comm_test_inter(112): MPI_Comm_test_inter(comm=0x62a903e0, flag=0x7ffcd7088450) failed\nMPI_Comm_test_inter(70).: Invalid communicator\nfiles.zip",
          "url": "https://github.com/idaholab/moose/discussions/17109",
          "updatedAt": "2022-07-04T07:26:24Z",
          "publishedAt": "2021-02-23T20:07:44Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi\nDo you have a working version without this new action?\nI dont see the new kernels or the new action in the input file you provided.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17109#discussioncomment-491225",
                  "updatedAt": "2022-07-04T07:26:26Z",
                  "publishedAt": "2021-03-16T22:34:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Leni-Yeo"
                          },
                          "bodyText": "Hi\nThank you for answering back.\nThe problem was fortunately solved. We had set up a wrong kernel apparently which messed up the IC and boundary conditions.\nTo answer your question, it was a modified version of the \"grain_growth_2D_voronoi_newadapt.i\" file, with the first kernel replaced by the \"ACInterfaceKobayashi1\".",
                          "url": "https://github.com/idaholab/moose/discussions/17109#discussioncomment-494536",
                          "updatedAt": "2022-07-04T07:26:26Z",
                          "publishedAt": "2021-03-17T16:32:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Great! Thanks for letting us know.",
                          "url": "https://github.com/idaholab/moose/discussions/17109#discussioncomment-494554",
                          "updatedAt": "2022-07-04T07:26:26Z",
                          "publishedAt": "2021-03-17T16:36:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}