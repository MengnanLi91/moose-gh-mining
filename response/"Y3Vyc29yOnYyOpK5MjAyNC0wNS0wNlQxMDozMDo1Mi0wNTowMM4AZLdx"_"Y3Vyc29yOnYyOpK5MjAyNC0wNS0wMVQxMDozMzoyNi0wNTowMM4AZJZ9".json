{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wNS0wMVQxMDozMzoyNi0wNTowMM4AZJZ9"
    },
    "edges": [
      {
        "node": {
          "title": "Problem of using MatchedValueBC",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nI would like to know if each variable must have one kernel at least. Can I just use the MatchedValueBC of this variable, but do not use kernel of this variable (that's to say the value of this variable equal to v  in MatchedValueBC in each linear and nonlinear iteration)?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/27552",
          "updatedAt": "2024-05-06T15:28:40Z",
          "publishedAt": "2024-05-06T14:20:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes that's pretty much an obligation because having no kernels means huge rows of 0s in the Jacobian.\nJust add a time derivative kernel on that variable, that does not change much\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27552#discussioncomment-9330089",
                  "updatedAt": "2024-05-06T14:26:45Z",
                  "publishedAt": "2024-05-06T14:26:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "I have tried to add a ADTimeDerivative kernel, but the value equals to initial value and doesn't change. Is there any other kernel I can use?",
                          "url": "https://github.com/idaholab/moose/discussions/27552#discussioncomment-9330146",
                          "updatedAt": "2024-05-06T14:31:55Z",
                          "publishedAt": "2024-05-06T14:31:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "why would it change? From the BC? The volume would stay constant for sure with just this kernel",
                          "url": "https://github.com/idaholab/moose/discussions/27552#discussioncomment-9330215",
                          "updatedAt": "2024-05-06T14:37:26Z",
                          "publishedAt": "2024-05-06T14:37:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Yes, the v in MatchedValueBC will change over the time.",
                          "url": "https://github.com/idaholab/moose/discussions/27552#discussioncomment-9330243",
                          "updatedAt": "2024-05-06T14:40:03Z",
                          "publishedAt": "2024-05-06T14:40:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "and you want u to be equal to v everywhere in the domain?\nor just on the boundary?",
                          "url": "https://github.com/idaholab/moose/discussions/27552#discussioncomment-9330620",
                          "updatedAt": "2024-05-06T15:13:18Z",
                          "publishedAt": "2024-05-06T15:13:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Just on the boundary.",
                          "url": "https://github.com/idaholab/moose/discussions/27552#discussioncomment-9330640",
                          "updatedAt": "2024-05-06T15:15:43Z",
                          "publishedAt": "2024-05-06T15:15:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "and you are not seeing that happen? as if the BC is not being applied?\nyou could try this boundary condition too. v is a Functor (since it s a variable)\nhttps://mooseframework.inl.gov/source/bcs/FunctorDirichletBC.html",
                          "url": "https://github.com/idaholab/moose/discussions/27552#discussioncomment-9330686",
                          "updatedAt": "2024-05-06T15:19:21Z",
                          "publishedAt": "2024-05-06T15:19:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "OK, thanks a lot!",
                          "url": "https://github.com/idaholab/moose/discussions/27552#discussioncomment-9330794",
                          "updatedAt": "2024-05-06T15:28:41Z",
                          "publishedAt": "2024-05-06T15:28:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Auxkernels and AD",
          "author": {
            "login": "joe61vette"
          },
          "bodyText": "I have a compound auxvariable (mdot) that is the product of density, velocity and area. I use an aux instead of a material property due to a \"product of averages is not equal to the average of the products\" type of problem when variables are interpolated to QPs. I would like to use the AD system but it seems like auxkernels only return Real values. Is it possible for an auxvariable to be of type ADReal? I haven't found an example yet, so I am guessing not.\nThanks,\nJoe Kelly",
          "url": "https://github.com/idaholab/moose/discussions/27544",
          "updatedAt": "2024-05-06T04:33:59Z",
          "publishedAt": "2024-05-03T17:49:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Joe\nNo it's not possible for aux variables to be AD.\nSo you want to avoid evaluating the material property on the face by evaluating each component? You want to make sure face values are computed from the average of the values of that material property on the elements?\nWith Functor material properties we can define how the property gets evaluated for each argument (element, face, point, etc)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27544#discussioncomment-9308429",
                  "updatedAt": "2024-05-03T18:02:24Z",
                  "publishedAt": "2024-05-03T18:02:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Thanks Guillaume. I'll take a look at functor properties.  I have only used them in an FVM context and this is FEM (1D).  After I read up on it, I'll either mark this as answered or have a better defined question. Below is an excerpt that explains the problem a bit better.\n\"To simplify the discussion, we\u2019ll first consider a constant density case. It is essential to note that in this implementation the values of the flow area and the velocity variables only exist for the nodal points. Within a kernel, the values for the quadrature points are interpolated from the actual nodal values according to the type of quadrature being used. Again, to keep this simple, we\u2019ll consider the most elementary type of quadrature: first-order Gauss. Thus, there is only one quadrature point located at the midpoint of the element and linear interpolation is used. Therefore,\nA[0] = (1/2)(A0 + A1)\nU[0] = (1/2) (U0 + U1)\nLet\u2019s consider the case where the flow area of an element doubles over its length and the velocity and area at the bottom of the element both have a value of unity. The corresponding volumetric flux would then have a value of 1 \ufffdm3/s\ufffd. For a constant density case, the volumetric flux at the top of the element would also have the same value. However, using the quadrature point values we would have\nA[0] = (1/2)* (1+2) = 1.5\nU[0]= (1/2)* (1+0.5)=0.75\nso that the product U \u00b7 A is equal to 1.125 rather than unity. Consequently, using the product of the quadrature values for velocity and flow area within the convective term can result in large mass errors rendering the calculation meaningless.\"",
                          "url": "https://github.com/idaholab/moose/discussions/27544#discussioncomment-9308595",
                          "updatedAt": "2024-05-03T18:25:09Z",
                          "publishedAt": "2024-05-03T18:25:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "After looking at the functor material description, I don't believe that it solves the problem described above. Namely, for a 1D problem, only the velocity calculated at the nodal points is guaranteed to conserve the mass flow rate. If you interpolate each quantity (rho, velocity and area) to the QPs in forming a residual, that product does not equal the mass flow rate.",
                          "url": "https://github.com/idaholab/moose/discussions/27544#discussioncomment-9308724",
                          "updatedAt": "2024-05-03T18:37:31Z",
                          "publishedAt": "2024-05-03T18:37:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Well you're right that functor material properties were initially meant for facilitating on-the-fly evaluations and therefore meant it would be easy to combine functors / call them anywhere. So if mdot = rho v A then they allow to compute mdot(anywhere = x) as rho(x) * v(x) * A(x)\nbut it does not have to be that way. If I define a functor mdot that is equal to rho v A only on the nodes (definition of the functor for the NodalArg spatial argument), and equal to an interpolation of mdot between nodes elsewhere (definition of the functor for other spatial arguments, for example ElemQpArg, a Qp inside an element), then it does what you want.\nYou can look at ConstantFunctor in MooseFunctor.h for one of the simplest functor definitions.\nThen PiecewiseByBlockLambdaFunctor in its own header for a more complex one.\nMy idea would be to create the one you need.\n@lindsayad is the most knowledgeable on functors\nThen for the user to create them, that will have to be done through a FunctorMaterial, which will create the functor as a functor material property.",
                          "url": "https://github.com/idaholab/moose/discussions/27544#discussioncomment-9308786",
                          "updatedAt": "2024-05-03T18:46:06Z",
                          "publishedAt": "2024-05-03T18:46:06Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Thanks Guillaume.  I think I understand and will give it a try.",
                          "url": "https://github.com/idaholab/moose/discussions/27544#discussioncomment-9308856",
                          "updatedAt": "2024-05-03T18:57:40Z",
                          "publishedAt": "2024-05-03T18:57:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "sounds good. There is also a functor that leverages a map by faces. that can be an inspiration too. It's in Navier Stokes module\nsrc/utils/FaceCenteredMapFunctor.C",
                          "url": "https://github.com/idaholab/moose/discussions/27544#discussioncomment-9309021",
                          "updatedAt": "2024-05-03T19:22:05Z",
                          "publishedAt": "2024-05-03T19:22:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "There's a flaw in the thought process here. There is no interpolation in finite elements, just evaluation of the approximate solution. There is nothing special about the solution evaluation at the nodes vs. the interior of the elements. The evaluation of U at an interior element quadrature point is just as correct or incorrect as its evaluation at a node. Same with A. So you should not regard the product of U and A and rho at nodes as something special upon which you should base all other evaluations. If you have an issue with evaluation of mdot because of its composite nature, the fix would be to cast it as a degree of freedom in your system of equations, not try to project an auxiliary mdot into a finite element space",
                          "url": "https://github.com/idaholab/moose/discussions/27544#discussioncomment-9324110",
                          "updatedAt": "2024-05-06T04:33:59Z",
                          "publishedAt": "2024-05-06T04:33:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "In Porous flow, can we use kernels instead of action to 'save_component_rate_in'?",
          "author": {
            "login": "robo-boluo"
          },
          "bodyText": "Dear Moose community,\nI followed the coupled flow example under the folder of '(modules/combined/examples/geochem-porous_flow/geotes_weber_tensleep/porous_flow.i). The example uses '[PorousFlowFullySaturated]' action to save the mass fraction rate.\n\nConsidering the extension of multiple phases and unsaturated flow, my question is that can we use kernels such as, [PorousFlowMassTimeDerivative] to save the mass fraction rate?\nThanks for your time and help.\nRobo",
          "url": "https://github.com/idaholab/moose/discussions/27550",
          "updatedAt": "2024-05-06T00:42:45Z",
          "publishedAt": "2024-05-05T18:25:42Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can look at PorousFlowFullySaturated.C to see what this parameter is doing.\n      kernel_name = \"PorousFlowFullySaturated_MassTimeDerivative\" + Moose::stringify(i);\n      params.set<unsigned int>(\"fluid_component\") = i;\n      params.set<NonlinearVariableName>(\"variable\") = _mass_fraction_vars[i];\n      if (_save_component_rate_in.size() != 0)\n        params.set<std::vector<AuxVariableName>>(\"save_in\") = {_save_component_rate_in[i]};\n      _problem->addKernel(kernel_type, kernel_name, params);\n\nit is just using the \"save_in\" parameter on the kernels. You can do that too with an input file that uses the kernels instead of the action\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27550#discussioncomment-9322333",
                  "updatedAt": "2024-05-05T21:30:50Z",
                  "publishedAt": "2024-05-05T21:30:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "robo-boluo"
                  },
                  "bodyText": "many thanks for the prompt reply.",
                  "url": "https://github.com/idaholab/moose/discussions/27550#discussioncomment-9323025",
                  "updatedAt": "2024-05-06T00:42:17Z",
                  "publishedAt": "2024-05-06T00:42:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unexpected Negative Temperatures in Cement Heat Transfer Simulation",
          "author": {
            "login": "DanielChou0916"
          },
          "bodyText": "Hello MOOSE Community,\nI'm conducting a heat transfer simulation in cement and encountering an issue where the middle nodes of my domain exhibit negative temperatures. Below are the details of my setup:\nThermal Properties:\nThermal Conductivity: 2.6 W/m\u00b0C\nSpecific Heat: 790 J/kg\u00b0C\nDensity: 2500 kg/m\u00b3\nSimulation Domain:\nThe domain consists of eight 2D triangular elements in a square configuration.\nBoundary and Initial Conditions:\nInitial Temperature: 0\u00b0C throughout the domain.\nBottom Boundary: Constant at 0\u00b0C.\nTop Boundary: Linear increase from 0\u00b0C to 25\u00b0C over 10 seconds (0.25*t).\nDespite these settings, I observed that the temperature at node 3 (located at x,y = (1,1)) drops to -8.92\u00b0C, which is unexpected. This issue does not occur when I run a similar simulation in ABAQUS.\nAdditionally, I attempted to use parameters from an official example, modifying them for my cement material:\nThermal Conductivity: Changed from 45.0 to 2.6 W/m\u00b0C\nSpecific Heat: Unsure if the original 0.5 is in kJ/kg\u00b0C.\nI would appreciate any insights or suggestions on why these negative temperatures might be occurring and how to resolve this issue. Attached are the mesh file (I_mesh_example_square.e) and the input file (II_2_heat_conduction.i) for reference.\nThank you for your assistance!\nMy simple simulation:\nheattests.zip\nThe MOOSE official example:\nhttps://mooseframework.inl.gov/modules/combined/tutorials/introduction/thermomech_step01.html",
          "url": "https://github.com/idaholab/moose/discussions/27509",
          "updatedAt": "2024-05-03T20:19:09Z",
          "publishedAt": "2024-04-30T12:14:22Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou are very far from a steady state (the linear slope between the two boundaries one will expect) at this point.\nThe CFEM discretization in use can present oscillation in the presence of large perturbations, which imposing a dirichlet next to a volume far from that temperature is.\nDo you know what discretization Abaqus uses?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27509#discussioncomment-9285027",
                  "updatedAt": "2024-05-01T13:05:26Z",
                  "publishedAt": "2024-05-01T13:05:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "DanielChou0916"
                          },
                          "bodyText": "Thank you very much for pointing me out!\nI try to add temp from 0~25, and retain 25C to continue the simulation for an extra period\nFurthermore, I use finer mesh than my example.\nThe results make sense to me now!!\nAnd I do not really know what discretization Abaqus uses...\nWill pay more attention on these aspects when doing the formal simulation by MOOSE.\nBut thanks again :)",
                          "url": "https://github.com/idaholab/moose/discussions/27509#discussioncomment-9309415",
                          "updatedAt": "2024-05-03T20:19:08Z",
                          "publishedAt": "2024-05-03T20:19:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Recommended Ubuntu version",
          "author": {
            "login": "Khaksarkn"
          },
          "bodyText": "Hi,\nIs there any version of Ubuntu Desktop (20.04, 22.04, or the latest 24.04), that you recommend using for MOOSE applications?\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/27534",
          "updatedAt": "2024-05-02T18:36:28Z",
          "publishedAt": "2024-05-02T18:00:19Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "KamalnathOSU"
                  },
                  "bodyText": "I have used MOOSE with Ubuntu 20.04 in WSL (Windows Subsystem for Linux). So far, there is no issue.",
                  "url": "https://github.com/idaholab/moose/discussions/27534#discussioncomment-9298625",
                  "updatedAt": "2024-05-02T18:04:54Z",
                  "publishedAt": "2024-05-02T18:04:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Khaksarkn"
                          },
                          "bodyText": "Thanks for the info. I have used that as well.\nI meant for desktop versions of Ubuntu. There has been a new 24.04 release. I was wondering what people recommend for desktop versions.",
                          "url": "https://github.com/idaholab/moose/discussions/27534#discussioncomment-9298642",
                          "updatedAt": "2024-05-02T18:06:46Z",
                          "publishedAt": "2024-05-02T18:06:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I imagine building MOOSE and running MOOSE based applications will work just fine.\nThe complication we run into usually involves the graphical front end; Peacock.",
                          "url": "https://github.com/idaholab/moose/discussions/27534#discussioncomment-9298904",
                          "updatedAt": "2024-05-02T18:36:28Z",
                          "publishedAt": "2024-05-02T18:36:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "April 2024 Newsletter",
          "author": {
            "login": "cticenhour"
          },
          "bodyText": "The April 2024 MOOSE Newsletter has been released! A summary of the content is below:\n\nMOOSE Improvements\n\nAdded convection functor material\nWebServerControl added\nNew time stepper based on target number of fixed point iterations\nNew initial residual evaluation behavior\n\n\nlibMesh-level Changes\n\n2024.04.23 Update\n\n\nBug Fixes and Minor Enhancements",
          "url": "https://github.com/idaholab/moose/discussions/27531",
          "updatedAt": "2024-05-02T14:45:42Z",
          "publishedAt": "2024-05-02T14:45:41Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Error in Finite Volume Incompressible Porous media Navier Stokes Test",
          "author": {
            "login": "m1russell"
          },
          "bodyText": "I am trying to implement a NS analysis of the flow of an incompressible fluid through a body composed of two domains with differing porosities. I tried following the example given in 2d-rc-epsjump.i @ (modules/navier_stokes/test/tests/finite_volume/pins/channel-flow/porosity_jump/2d-rc-epsjump.i) and @( https://mooseframework.inl.gov/modules/navier_stokes/pinsfv.html) but run into the following error.\n*** ERROR ***\nThe following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\n\nAttempted to get a functor with the name 'porosity' but multiple functors match. Make sure that you do not have functor material properties, functions, postprocessors or variables with the same names\n\nThe error seems to originate from the use of the name \"porosity\" as both an AuxVariable and FunctorMaterials. I am just learning how to use the NS module so any help would be much appreciated.\nI have added the full input deck below:\nmu=1.1\nrho=1.1\nadvected_interp_method='upwind'\nvelocity_interp_method='rc'\n\n[Mesh]\n  [mesh]\n    type = CartesianMeshGenerator\n    dim = 2\n    dx = '1 1'\n    dy = '0.5'\n    ix = '30 30'\n    iy = '20'\n    subdomain_id = '1 2'\n  []\n[]\n\n[GlobalParams]\n  rhie_chow_user_object = 'rc'\n  porosity = porosity\n[]\n\n[UserObjects]\n  [rc]\n    type = PINSFVRhieChowInterpolator\n    u = u\n    v = v\n    porosity = porosity\n    pressure = pressure\n  []\n[]\n\n[Variables]\n  [u]\n    type = PINSFVSuperficialVelocityVariable\n    initial_condition = 1\n  []\n  [v]\n    type = PINSFVSuperficialVelocityVariable\n    initial_condition = 1e-6\n  []\n  [pressure]\n    type = INSFVPressureVariable\n  []\n[]\n\n[AuxVariables]\n  [porosity]\n    type = MooseVariableFVReal\n  []\n[]\n\n[ICs]\n  inactive = 'porosity_continuous'\n  [porosity_1]\n    type = ConstantIC\n    variable = porosity\n    block = 1\n    value = 1\n  []\n  [porosity_2]\n    type = ConstantIC\n    variable = porosity\n    block = 2\n    value = 0.5\n  []\n  [porosity_continuous]\n    type = FunctionIC\n    variable = porosity\n    block = '1 2'\n    function = smooth_jump\n  []\n[]\n\n[Functions]\n  [smooth_jump]\n    type = ParsedFunction\n    expression = '1 - 0.5 * 1 / (1 + exp(-30*(x-1)))'\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = PINSFVMassAdvection\n    variable = pressure\n    advected_interp_method = ${advected_interp_method}\n    velocity_interp_method = ${velocity_interp_method}\n    rho = ${rho}\n  []\n\n  [u_advection]\n    type = PINSFVMomentumAdvection\n    variable = u\n    advected_interp_method = ${advected_interp_method}\n    velocity_interp_method = ${velocity_interp_method}\n    rho = ${rho}\n    momentum_component = 'x'\n  []\n  [u_viscosity]\n    type = PINSFVMomentumDiffusion\n    variable = u\n    mu = ${mu}\n    momentum_component = 'x'\n  []\n  [u_pressure]\n    type = PINSFVMomentumPressure\n    variable = u\n    pressure = pressure\n    momentum_component = 'x'\n  []\n\n  [v_advection]\n    type = PINSFVMomentumAdvection\n    variable = v\n    advected_interp_method = ${advected_interp_method}\n    velocity_interp_method = ${velocity_interp_method}\n    rho = ${rho}\n    momentum_component = 'y'\n  []\n  [v_viscosity]\n    type = PINSFVMomentumDiffusion\n    variable = v\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = PINSFVMomentumPressure\n    variable = v\n    pressure = pressure\n    momentum_component = 'y'\n  []\n[]\n\n[FVBCs]\n  [inlet-u]\n    type = INSFVInletVelocityBC\n    boundary = 'left'\n    variable = u\n    function = '1'\n  []\n  [inlet-v]\n    type = INSFVInletVelocityBC\n    boundary = 'left'\n    variable = v\n    function = 0\n  []\n\n  [walls-u]\n    type = INSFVNaturalFreeSlipBC\n    boundary = 'top bottom'\n    variable = u\n    momentum_component = 'x'\n  []\n  [walls-v]\n    type = INSFVNaturalFreeSlipBC\n    boundary = 'top bottom'\n    variable = v\n    momentum_component = 'y'\n  []\n\n  [outlet_p]\n    type = INSFVOutletPressureBC\n    boundary = 'right'\n    variable = pressure\n    function = 0.4\n  []\n[]\n\n[FunctorMaterials]\n  inactive = 'smooth'\n  [jump]\n    type = ADPiecewiseByBlockFunctorMaterial\n    prop_name = 'porosity'\n    subdomain_to_prop_value = '1 1\n                               2 0.5'\n  []\n  [smooth]\n    type = ADGenericFunctionFunctorMaterial\n    prop_names = 'porosity'\n    prop_values = 'smooth_jump'\n  []\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n  line_search = 'none'\n  nl_rel_tol = 1e-10\n[]\n\n[Postprocessors]\n  [inlet_p]\n    type = SideAverageValue\n    variable = 'pressure'\n    boundary = 'left'\n  []\n  [outlet-u]\n    type = SideIntegralVariablePostprocessor\n    variable = u\n    boundary = 'right'\n  []\n[]\n\n[Outputs]\n  exodus = true\n  csv = false\n[]",
          "url": "https://github.com/idaholab/moose/discussions/27530",
          "updatedAt": "2024-05-07T22:03:12Z",
          "publishedAt": "2024-05-01T22:55:44Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou have too many objects called porosity. Rename one of them?\nMaybe the auxiliary variable first?\nNote that we have 3 different treatments implemented for porosity jump. Please try them and let us know your thoughts\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27530#discussioncomment-9289759",
                  "updatedAt": "2024-05-01T23:34:36Z",
                  "publishedAt": "2024-05-01T23:34:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "m1russell"
                  },
                  "bodyText": "Sounds good, is the issue that the example test was meant to show you can declare porosity either as an auxillary variable whose value is set by the IC or as a functor material? I am not sure why it had both to begin with.",
                  "url": "https://github.com/idaholab/moose/discussions/27530#discussioncomment-9289900",
                  "updatedAt": "2024-05-02T00:08:18Z",
                  "publishedAt": "2024-05-02T00:08:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Oh yeah sometimes tests are just doing whatever to get some lines of code tested",
                          "url": "https://github.com/idaholab/moose/discussions/27530#discussioncomment-9290026",
                          "updatedAt": "2024-05-02T00:36:40Z",
                          "publishedAt": "2024-05-02T00:36:40Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error in adding DerivativeMaterialInterface kernel",
          "author": {
            "login": "tqcthai"
          },
          "bodyText": "",
          "url": "https://github.com/idaholab/moose/discussions/27528",
          "updatedAt": "2024-05-01T23:41:23Z",
          "publishedAt": "2024-05-01T22:43:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Time_scale in HPC Vs. Local system",
          "author": {
            "login": "ashishdhole"
          },
          "bodyText": "Hello,\nIf I am running same input script on my local PC the 1st time step converges well at 1 sec, but if I am running the same script on HPC, my 1st time step converges at 6.25e-05. is there anything I need to add in the script that will show same time steps on HPC as on my local system?\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/27519",
          "updatedAt": "2024-05-01T19:07:39Z",
          "publishedAt": "2024-05-01T06:54:30Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nAre you using the same number of cores on both systems?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27519#discussioncomment-9284684",
                  "updatedAt": "2024-05-01T12:19:15Z",
                  "publishedAt": "2024-05-01T12:19:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "no. On my local system I am using 4 cores on HPC I am using 400.",
                          "url": "https://github.com/idaholab/moose/discussions/27519#discussioncomment-9287789",
                          "updatedAt": "2024-05-01T18:20:43Z",
                          "publishedAt": "2024-05-01T18:20:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the preconditioning depends on the number of cores used.\nWe recommend 20k dofs per core as a guideline. 400 processes for an input that runs with 4 is likely overkill and detrimental to the runtime",
                          "url": "https://github.com/idaholab/moose/discussions/27519#discussioncomment-9287947",
                          "updatedAt": "2024-05-01T18:42:29Z",
                          "publishedAt": "2024-05-01T18:42:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "In case of adaptivity how will we know the exact dof?",
                          "url": "https://github.com/idaholab/moose/discussions/27519#discussioncomment-9287968",
                          "updatedAt": "2024-05-01T18:44:28Z",
                          "publishedAt": "2024-05-01T18:44:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you can use a postprocessor to count the number of dofs\nhttps://mooseframework.inl.gov/source/postprocessors/NumDOFs.html\nuniform refinement generates 4x (in 2D) and 8x (in 3D) as many cells for the refined cells",
                          "url": "https://github.com/idaholab/moose/discussions/27519#discussioncomment-9288155",
                          "updatedAt": "2024-05-01T19:07:56Z",
                          "publishedAt": "2024-05-01T19:07:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Getting non-nodal values to output with nodal values in same .csv or vice versa",
          "author": {
            "login": "jackeggemeyer"
          },
          "bodyText": "I currently use VectorPostprocessors to output some of my nodal variables to a .csv file. I want my output to have a variable per each node and timestep. However, I also want to output an elemental variable for each node.\nMy elemental variable must stay elemental as it is part of the discrete nucleation kernel and has to be an elemental auxiliary variable. Is there a way to get nucl_map to output with the vectorpostprocessors? Like an average of the elemental values per node? I looked at the DiscreteNucleatoinData post-processor. I provided some code below. Thank you so much for your help! Let me know if you need more information.\n[AuxVariables]\n  [./nucl_map]\n     order = first\n     family = MONOMIAL\n     outputs = exodus\n  [../]\n[]\n\n[AuxKernels]\n  [./nucl_map_aux]\n    type = DiscreteNucleationAux\n    map = map\n    variable = nucl_map\n    no_nucleus_value = 0\n    nucleus_value = 1\n  [../]\n[]\n\n[VectorPostprocessors]\n    [./etarad]\n    type = NodalValueSampler\n    variable = 'etab0 etam0'\n    sort_by = 'id'\n  [../] \n[] \n\nI also wouldn't mind the nodal variables being ouputed per element either I just wanted the data synced.",
          "url": "https://github.com/idaholab/moose/discussions/27524",
          "updatedAt": "2024-05-03T15:28:55Z",
          "publishedAt": "2024-05-01T14:57:09Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "You could project the elemental variable on a nodal one with the ProjectionAux, then output that one\nhttps://mooseframework.inl.gov/source/auxkernels/ProjectionAux.html",
                  "url": "https://github.com/idaholab/moose/discussions/27524#discussioncomment-9286364",
                  "updatedAt": "2024-05-01T15:33:43Z",
                  "publishedAt": "2024-05-01T15:33:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}