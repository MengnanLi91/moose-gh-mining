{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0xMi0xMVQwMDo0MToyNy0wNjowMM4AWgF_"
    },
    "edges": [
      {
        "node": {
          "title": "Training a Gaussian Process model in MOOSE",
          "author": {
            "login": "charlieowen3065"
          },
          "bodyText": "Hello!\nI am currently trying to use the stochastic tools module to train a gaussian process model, but am having issues with the hyperparameters.\nMy basic setup is this: I load in my training data from CSV files (using CSVSampler for X and VectorPostprocessor for Y) and specify the \"Signal Variance\", \"Noise Variance\", and \"Length Factor\" for a Matern covariance function with p = 1 (nu = 3/2). I also run the same model (same inputs, hyperparameters, and covariance function) in python using sklearn just to have a reference point. I am able to get a good, general model working on python, but when I use those same hyperparameters in MOOSE, when I go to evaluate the model using my testing data, it only predicts a vector of ~0's (the given values are ~4*10^-301, which is zero). I have gone into both codes and found the actual used hyperparameters for these evaluations, and they do match.\nI believe the issue has to do with how I am training the algorithm, but I am not sure where. An issue that may be wrong is in the length factor HP. For this one, MOOSE requires an input for each feature, but since I have 102 features, I added in a few lines that takes in the input length factor and copies this into a 1x102 vector, then uses that vector for the input. I am not sure if this is maybe causing an unforeseen consequence somewhere, so I thought I'd mention it.\nI have also tried using the 'adam' tuning algorithm, but this also does not give any better results. (I have tired with batch sizes from 1-50, itterations from 10-1000, and with learning rates from 0.001 - 10).\nHere is the training input file:\n# =+=+=+=+=+=+=+=+=+ USER INPUTS =+=+=+=+=+=+=+=+=+=+=+=+=\n\nX_filename = \"X_train.csv\"\n\n# Hyperparameters\nsignal_variance = 0.01\nnoise_variance = 0.01\nlength_factor = 0.01\np = 1\n\n# =+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n\n[StochasticTools]\n[]\n\n[Samplers]\n  [X_train]\n    type = CSVSampler\n    samples_file = ${X_filename}\n    execute_on = 'initial'\n  []\n[]\n\n[VectorPostprocessors]\n  [Y_train]\n    type = CSVReader\n    csv_file = 'Y_train.csv'\n  []\n[]\n\n[Covariance]\n  [Matern_32]\n    type = MaternHalfIntCovariance\n\tconstant_length_factor = True\n    signal_variance = ${signal_variance}\n    noise_variance = ${noise_variance}\n    length_factor = \"${length_factor}\"\n\tp = ${p}\n  []\n[]\n\n[Trainers]\n  [train]\n    type = GaussianProcessTrainer\n    execute_on = timestep_end\n    covariance_function = 'Matern_32'\n    standardize_params = 'false' #Center and scale the training params\n    standardize_data = 'false' #Center and scale the training data\n    sampler = X_train\n    response = Y_train/${column_name}\n\t# Tuning\n\ttuning_algorithm = 'adam'\n\ttune_parameters = 'signal_variance length_factor'\n\t# tune_parameters = 'signal_variance'\n\titer_adam = 100\n\tbatch_size = 20\n\tlearning_rate_adam = 10\n\t\n  []\n[]\n\n[Outputs]\n  [out]\n    type = SurrogateTrainerOutput\n    trainers = 'train'\n\tfile_base = \"Trained_Model\"\n    execute_on = FINAL\n  []\n[]\n\nTo make my life simpler, I already standardized my X, so that is why those options are false. I also run this through a shell script where I input my hyperparameters there, so you can ignore the values on the top of the file. Those are just there to initialize the variables.\nAny advise on this? I have tried a large range of hyperparameters for the MOOSE GP model, but nothing has given results better than a vector of zeros (my actual Y's are in the ~2000 range).\nI am pretty stuck, so I am willing to try just about anything.\nThanks!\nCharlie",
          "url": "https://github.com/idaholab/moose/discussions/26267",
          "updatedAt": "2023-12-12T21:54:40Z",
          "publishedAt": "2023-12-06T18:28:41Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@zachmprince @somu15",
                  "url": "https://github.com/idaholab/moose/discussions/26267#discussioncomment-7781060",
                  "updatedAt": "2023-12-06T20:25:42Z",
                  "publishedAt": "2023-12-06T20:25:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "somu15"
                          },
                          "bodyText": "Hi. Did you modify the source code to take in 102 length factors? If so, what did you change in the code?\nAlso, a GP performs poorly in such a high dimensional space. Even if the training is successful, it'd require a lot of training data. I recommend two things:\n\nFor your verification, benchmark MOOSE and Python on lower dimensional problem, maybe 10.\nUse dimensionality reduction to reduce the number of length factors. A simple PCA should help you.\n\nReach out for any further questions.\nSom",
                          "url": "https://github.com/idaholab/moose/discussions/26267#discussioncomment-7791185",
                          "updatedAt": "2023-12-07T16:52:59Z",
                          "publishedAt": "2023-12-07T16:52:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "charlieowen3065"
                  },
                  "bodyText": "Hi Som!\nTo alter the length factor, I appended the code in MaternHalfIntCovariance.C to be:\nvoid\nMaternHalfIntCovariance::computeCovarianceMatrix(RealEigenMatrix & K,\n                                                 const RealEigenMatrix & x,\n                                                 const RealEigenMatrix & xp,\n                                                 const bool is_self_covariance) const\n{\n  \n  if ((unsigned)x.cols() != _length_factor.size()){\n    \n\tif (_constant_length_factor == false){\n\t  mooseError(\"length_factor size does not match dimension of trainer input.\");\n\t} else{\n\t  std::vector<Real> _new_length_factor;\n\t  _new_length_factor.resize(x.cols());\n\t  for (int i=0; i<x.cols(); i++){\n\t\t  _new_length_factor[i] = _length_factor[0];\n\t  }\t  \n\t  \n\t  std::cout << \"WARNING: length_factor size (\" << _length_factor.size() << \") does not match dimension of trainer input (\" << x.cols() << \"). \\n The input value has been copied (\" << x.cols() << \") times. (MaternHalfIntCovariance)\" << std::endl;\n\t  \n\t  // casting away const\n\t  std::vector<Real> *ptr;\n\t  ptr = (std::vector<Real>*)( &_length_factor );\n\t  *ptr = _new_length_factor;\n\t  //_length_factor = _new_length_factor;\n\t  \n\t  std::cout << \"_length_factor.size(): \" << _length_factor.size() << std::endl;\n\t  \n\t}\n  \n  }\n\n(Before, it just took _length_factor to be the input value). Is this done correctly? In the evaluation stage, I print all the HPs that are loaded in, and this one seems to be correctly loaded in as a vector of 102 of the same points.\nMy feature size is high, but we do plan on keeping it at this scale. However, we do have a large number of training points (~2000).\nI also used a much smaller dataset (8 features, ~1000 points), and it was still predicting zeros, so the error persists.\nThe output of both is in the form\ngp_surroagte, gp_surrogate_std\n1.39e-313, 1.39e-313\n4.66e-313, 1.39e-313\n4.66e-313, 1.39e-313\n4.66e-313, 1.39e-313\n..., ...\nand really just repeats like that for all points.\nSo for some reason, it is only predicting zeros with 0-std. I assume it has to be with the code I added in (as this is the only difference between my code and the original), but I am not sure where the error would arise?\nThanks!\nCharlie",
                  "url": "https://github.com/idaholab/moose/discussions/26267#discussioncomment-7794102",
                  "updatedAt": "2023-12-07T21:49:49Z",
                  "publishedAt": "2023-12-07T21:49:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "charlieowen3065"
                          },
                          "bodyText": "I no longer think that my added code here is the issue, as I ran the case with only 8 features again, but deleted my code and placed it into the input properly, and I am still seeing no predictions (all 0's).\nThe only other code I have added was in\nvoid\nLoadCovarianceDataAction::load(GaussianProcess & model)\n{\n  const std::string & covar_type = model.getGPHandler().getCovarType();\n  const std::unordered_map<std::string, Real> & map = model.getGPHandler().getHyperParamMap();\n  const std::unordered_map<std::string, std::vector<Real>> & vec_map =\n      model.getGPHandler().getHyperParamVectorMap();\n  const UserObjectName & covar_name = model.name() + \"_covar_func\";\n\n  InputParameters covar_params = _factory.getValidParams(covar_type);\n\n  for (auto & p : map){\n\t\n\tstd::cout << p.first << \": \" << p.second << std::endl;\n\t\n\t// Added functionality -- was trying to assign \"p\" (an int) to a double ----------------------------------------------------------------- (Charlie Owen, 11/30/2023)\n\tif (covar_params.type(p.first) == \"unsigned int\"){\n\t\tstd::cout << \"WARNING: Parameter [\" << p.first << \"] is an 'unsigned int', and could therefore not be moved into \\n a double. Functionality added to account for this. ~CO, 11/30/2023. (LoadCovarianceDataAction)\" << std::endl;\n\t\tcovar_params.set<unsigned int>(p.first) = p.second;\n\t}\n\telse {\n      covar_params.set<Real>(p.first) = p.second;\n\t}\n  }\n  for (auto & p : vec_map){\n\tstd::cout << \"Here 2\" << std::endl;\n\t// std::cout << p.first << \": \" << p.second << std::endl;\n    std::cout << p.first << \":\" << std::endl;\n\tfor (int i = 0; i < p.second.size(); i++){\n\t\tstd::cout << i << \": \" << p.second[i] << std::endl;\n\t}\n\t\n\tcovar_params.set<std::vector<Real>>(p.first) = p.second;\n  }\n  _problem->addObject<CovarianceFunctionBase>(\n      covar_type, covar_name, covar_params, /* threaded = */ false);\n\n  model.setupCovariance(covar_name);\n}\n\n\nWhere I added a line as it was trying to read \"p\" as a double, while it was declared an 'unsigned int' before. This was a wired bug, so maybe I am misinterpreting something here? What is the proper way to load in a Matern covariance function?\nWithout the piece I added, I was unable to do so, so maybe it is training fine, but I am loading it in wrong? The p should just be an int and represents nu=p+0.5 in the matern equation (or just p  depending on the equation).",
                          "url": "https://github.com/idaholab/moose/discussions/26267#discussioncomment-7834320",
                          "updatedAt": "2023-12-12T18:54:25Z",
                          "publishedAt": "2023-12-12T18:54:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "somu15"
                          },
                          "bodyText": "I was on personal leave and hence my responses have been delayed so far.\nFor the Matern Half Int covariance, p should be a positive integer. See the documentation here: https://mooseframework.inl.gov/source/surrogates/MaternHalfIntCovariance.html\nAs far as the zero predictions go, this typically relates to problem with your training data. Some problems could be:\n\nNot standardizing the training data inputs and outputs. This is very important for GPs. You can standardize by simply setting standardize_params = 'true' and standardize_data = 'true'\nThe training data doesn't make physical sense.\nOr some other issue.\n\nStandardize the data and params and see how it goes. Also, when doing predictions, focus on both the mean and the std of the GP.\nWhy are you using the Matern Half Int kernel and not the Squared Exponential?",
                          "url": "https://github.com/idaholab/moose/discussions/26267#discussioncomment-7835241",
                          "updatedAt": "2023-12-12T20:50:08Z",
                          "publishedAt": "2023-12-12T20:50:07Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "charlieowen3065"
                          },
                          "bodyText": "Hi Som!\nAll fine - I appreciate the help!\nI think I have it working now - looks like without standardize_data = 'true', the model doesn't make very good predictions? Why is that? I've done ML before, but I've never had to standardize my Y before, so I suppose that I hadn't though about doing it. Just seems like it shouldn't be necessary?\nEither way, thanks for the help!\nCharlie",
                          "url": "https://github.com/idaholab/moose/discussions/26267#discussioncomment-7835487",
                          "updatedAt": "2023-12-12T21:18:39Z",
                          "publishedAt": "2023-12-12T21:18:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "somu15"
                          },
                          "bodyText": "This is a zero mean GP implementation we are dealing. Therefore, the Y's should also be standardized. See https://cs229.stanford.edu/section/cs229-gaussian_processes.pdf for the basics of a GP.\nAnd, do you know why you're using the Matern kernel?",
                          "url": "https://github.com/idaholab/moose/discussions/26267#discussioncomment-7835513",
                          "updatedAt": "2023-12-12T21:22:17Z",
                          "publishedAt": "2023-12-12T21:22:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "charlieowen3065"
                          },
                          "bodyText": "Som,\nGreat, thanks!\nFor the Matern kernel, we are still in a preliminary stage in the process, so I don't have a better reason for picking it other than it seems to work better than other kernels for our specific data.\nIs there a good method I should use to determine the best kernel for a dataset? My plan was to do offline hyperparameter tuning using various kernels and use the best model for our project.\nDoes this seem like a bad method?",
                          "url": "https://github.com/idaholab/moose/discussions/26267#discussioncomment-7835615",
                          "updatedAt": "2023-12-12T21:35:14Z",
                          "publishedAt": "2023-12-12T21:35:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "somu15"
                          },
                          "bodyText": "Yes, you can start with manually determining the best kernel for a given training data set. See this link on kernel selection: https://www.cs.toronto.edu/~duvenaud/cookbook/\nA Matern kernel work better than squared exponential if the training data is discontinuous. Squared exponential assumes smoothness and Matern kernel does not. But you have to train an additional parameter for the Matern. See this: https://andrewcharlesjones.github.io/journal/matern-kernels.html\nBut I'm glad the STM implementation is working now. Reach out if you have further questions.",
                          "url": "https://github.com/idaholab/moose/discussions/26267#discussioncomment-7835646",
                          "updatedAt": "2023-12-12T21:38:57Z",
                          "publishedAt": "2023-12-12T21:38:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "charlieowen3065"
                          },
                          "bodyText": "Will do! And thank you for all the advise!",
                          "url": "https://github.com/idaholab/moose/discussions/26267#discussioncomment-7835652",
                          "updatedAt": "2023-12-12T21:39:40Z",
                          "publishedAt": "2023-12-12T21:39:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can I set a time-varying inlet flow in THM\uff1f",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "@joshuahansel Hello josh, I'm excited that THM finally has its own Q&A module.\nTo get back on track, I want to calculate a case which has a time-varying inlet mass flow. Is there any way to achieve this\uff1f\nEthan",
          "url": "https://github.com/idaholab/moose/discussions/26153",
          "updatedAt": "2023-12-12T16:15:03Z",
          "publishedAt": "2023-11-27T06:38:34Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "Hi Ethan,\nYes, you would use some ControlLogic with InletMassFlowRateTemperature1Phase. See modules/thermal_hydraulics/test/tests/components/inlet_mass_flow_rate_1phase/clg.ctrl_m_dot_3eqn_rdg.i. Let me know if you have any questions.",
                  "url": "https://github.com/idaholab/moose/discussions/26153#discussioncomment-7680705",
                  "updatedAt": "2023-11-27T13:07:30Z",
                  "publishedAt": "2023-11-27T13:07:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Thanks a lot, it works. And I have another issue now. I can calculate a area-variation case using FlowChannel1Phase in THM. But in the subcahnnel model I created, even if I only change the area in one element of one channel, the calculation is non-convergent, like:\nTime Step 1, time = 0.25, dt = 0.25\n 0 Nonlinear |R| = 2.557412e+00\n      0 Linear |R| = 2.557412e+00\n      1 Linear |R| = 1.664515e-04\n      2 Linear |R| = 9.914895e-11\n 1 Nonlinear |R| = 1.451551e+11\nNonlinear solve did not converge due to DIVERGED_DTOL iterations 1\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nI am confused. Theoretically, I only added the lateral momentum equation and the lateral term. Do you have any ideas regarding the reasons for non-convergence?",
                          "url": "https://github.com/idaholab/moose/discussions/26153#discussioncomment-7830751",
                          "updatedAt": "2023-12-12T13:08:56Z",
                          "publishedAt": "2023-12-12T13:08:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "Do you know that it's related to your terms? Are you able to test a corresponding case without your terms?",
                          "url": "https://github.com/idaholab/moose/discussions/26153#discussioncomment-7830803",
                          "updatedAt": "2023-12-12T13:15:13Z",
                          "publishedAt": "2023-12-12T13:15:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "I think I found the problem. I still use UO to transfer the variables of adjacent channels(like rho = rhouA/rhoA). And I use AREA_LINEAR. When I change AREA_LINEAR into AREA, the area-variation case can be converged. Btw, if the area doesn't change, there's no difference between AREA_LINEAR and AREA right?",
                          "url": "https://github.com/idaholab/moose/discussions/26153#discussioncomment-7832071",
                          "updatedAt": "2023-12-12T15:17:56Z",
                          "publishedAt": "2023-12-12T15:17:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joshuahansel"
                          },
                          "bodyText": "if the area doesn't change, there's no difference between AREA_LINEAR and AREA right?\n\nCorrect. And in most cases, you want to use AREA, the cell-average cross-sectional area corresponding to the solution variables themselves.",
                          "url": "https://github.com/idaholab/moose/discussions/26153#discussioncomment-7832697",
                          "updatedAt": "2023-12-12T16:15:04Z",
                          "publishedAt": "2023-12-12T16:15:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "simulating runoff",
          "author": {
            "login": "nlosacco"
          },
          "bodyText": "Hi all,\nI am trying to simulate runoff on a slope, i.e. the condition at which rainfall stops infiltrating due to saturation of the soil at the surface and flows as a thin water film downslope. This condition can be assumed to be represented by u=0 with u the porewater pressure at the soil surface.\nSo, using the PorousFlowSink to simulate prescribed variable rainfall infiltration in an initially unsaturated slope, so with initial u<0, when u=0 is reachedI'd like to be able to automatically switch to a flow which enforces the condition u=0 at the slope surface.\nDoes a feature like that exist?",
          "url": "https://github.com/idaholab/moose/discussions/25591",
          "updatedAt": "2023-12-12T07:44:02Z",
          "publishedAt": "2023-09-26T18:43:20Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cpgr",
                  "url": "https://github.com/idaholab/moose/discussions/25591#discussioncomment-7117115",
                  "updatedAt": "2023-09-26T21:24:13Z",
                  "publishedAt": "2023-09-26T21:24:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "I think that you can use PorousFlowPiecewiseLinearSink to do this - see https://mooseframework.inl.gov/modules/porous_flow/boundaries.html",
                          "url": "https://github.com/idaholab/moose/discussions/25591#discussioncomment-7117347",
                          "updatedAt": "2023-09-26T22:07:31Z",
                          "publishedAt": "2023-09-26T22:07:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nlosacco"
                          },
                          "bodyText": "Hi,\nthanks for your reply. I already went through that page but I don\u2019t think it is relevant to my case. I want to apply a flux independently of the pressure u value. But I want to make sure that u > 0 is never reached! So if during the calculations a value of u > 0 is predicted as a consequence of the prescribed flux, the latter should be automatically changed so that u=0 is achieved.",
                          "url": "https://github.com/idaholab/moose/discussions/25591#discussioncomment-7117509",
                          "updatedAt": "2023-09-26T22:41:50Z",
                          "publishedAt": "2023-09-26T22:41:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nlosacco"
                          },
                          "bodyText": "As a mechanical analogy you can think of a horizontal (nonlinear) cantilever beam with vertical point load prescribed at the tip and a unilateral contact constraint limiting the maximum deflection. Regardless of the applied load value, when the max deflection is reached no further vertical displacement of the tip is allowed, until the load is duly reduced",
                          "url": "https://github.com/idaholab/moose/discussions/25591#discussioncomment-7117547",
                          "updatedAt": "2023-09-26T22:49:08Z",
                          "publishedAt": "2023-09-26T22:49:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Hmm, could you use a parsed flux_function in the sink to make the flux 0 when u > 0? Otherwise you might have to look at the conditional controls system to see if there is something that you can use there. @WilkAndy would probably know this, but is on leave until next week.",
                          "url": "https://github.com/idaholab/moose/discussions/25591#discussioncomment-7117945",
                          "updatedAt": "2023-09-27T00:27:33Z",
                          "publishedAt": "2023-09-27T00:27:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nlosacco"
                          },
                          "bodyText": "Thanks @cpgr , I\u2019ll give a try. I am just afraid that those solution, parsed flux function and conditional controls, work in an explicit way, i.e. the check u>0 is done at the beginning of a step and nothing prevents significant overshooting to occur in the previous step if the flux is large enough\u2026 I\u2019ll try and also wait for @WilkAndy suggestions",
                          "url": "https://github.com/idaholab/moose/discussions/25591#discussioncomment-7119547",
                          "updatedAt": "2023-09-27T06:06:11Z",
                          "publishedAt": "2023-09-27T06:06:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nlosacco"
                          },
                          "bodyText": "Hi all,\n@cpgr , @WilkAndy , I had to put this aside for a while but now I'm on it again. Wondering if you have any suggestions on how to simulate the runoff. I think the way to go is imposing a time-varying flux through a PorousFlowSink, using a ConditionalFunctionEnable to check wether the porewaterpressure u is close to zero, then switching to a PenaltyDirichletBC to impose u=0 through a purposely calculated flow, if the latter condition is met.\nAbout this I have a more general question which I am posing in #26203",
                          "url": "https://github.com/idaholab/moose/discussions/25591#discussioncomment-7715702",
                          "updatedAt": "2023-11-30T10:13:50Z",
                          "publishedAt": "2023-11-30T10:13:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arndflatten"
                          },
                          "bodyText": "I think you don't need to switch the boundary condition from a fluxBC-type like PorousFlowSink (that you use for the unsaturated case where rain can still infiltrate into the model) to a dirichletBC (in case the pressure exceeds u>0). You may still want to use the fluxBC in the case of u>0 to prescribe a flux that automatically enforces the fluid pressure to be u=0. Try the PorousFlowPiecewiseLinearSink with your rainfall condition for u<0 and the sink condition with gradient being 1/L for u>0, see section Numerical Implementation in https://mooseframework.inl.gov/modules/porous_flow/boundaries.html.",
                          "url": "https://github.com/idaholab/moose/discussions/25591#discussioncomment-7827725",
                          "updatedAt": "2023-12-12T07:44:03Z",
                          "publishedAt": "2023-12-12T07:44:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Simulation was successful but got an error message at the end",
          "author": {
            "login": "steam-simulator"
          },
          "bodyText": "Hello,\nMy simulation was successful, but I got the following error at the end of the simulation run. If I increase the time step to 1, the error disappears, but I\u2019m unsure why I get this error with a smaller time step. Could anyone help? Thanks.\nTime Step 5001, time = 100, dt = 2.75691e-12\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nTime Step 5001, time = 100, dt = 1.37845e-12\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nTime Step 5001, time = 100, dt = 1e-12\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge\n\n\n*** ERROR ***\nThe following error occurred in the object \"ConstantDT\", of type \"ConstantDT\".\n\nSolve failed and timestep already at or below dtmin, cannot continue!\n\nStack frames: 12\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)\n2: callMooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&, MooseApp*)\n3: /home/hue/MOOSE/projects/moose/framework/libmoose-opt.so.0(+0xdd7dc1) [0x7f1e4b020dc1]\n4: /home/hue/MOOSE/projects/moose/framework/libmoose-opt.so.0(+0x1093e37) [0x7f1e4b2dce37]\n5: TimeStepper::computeStep()\n6: Transient::execute()\n7: MooseApp::executeExecutioner()\n8: MooseApp::run()\n9: main\n10: __libc_start_main\n11: ../../../hue-opt(+0x33ef) [0x5654c2a3e3ef]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor",
          "url": "https://github.com/idaholab/moose/discussions/26301",
          "updatedAt": "2023-12-12T01:37:31Z",
          "publishedAt": "2023-12-12T00:39:04Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nThis looks like a rounding error. It s probably the sum of the sizes of the steps that does not quite equal max_time.\nIncrease the timestep_tol parameter to 5e-12 in the executioner\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26301#discussioncomment-7825677",
                  "updatedAt": "2023-12-12T01:07:10Z",
                  "publishedAt": "2023-12-12T01:07:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "steam-simulator"
                          },
                          "bodyText": "worked like a charm! Thx",
                          "url": "https://github.com/idaholab/moose/discussions/26301#discussioncomment-7825803",
                          "updatedAt": "2023-12-12T01:37:27Z",
                          "publishedAt": "2023-12-12T01:37:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "INSVF with adaptive mesh",
          "author": {
            "login": "doquang"
          },
          "bodyText": "I am trying to include an adaptive mesh for the existing example (gallium_melting.i), but it's not working for me.\nI wonder, does ValueRangeMarker marker work with FV?\nPlease find more Information from the input file.\n##########################################################\n# Simulation of Galium Melting Experiment\n# Ref: Gau, C., & Viskanta, R. (1986). Melting and solidification of a pure metal on a vertical wall.\n# Key physics: melting/solidification, convective heat transfer, natural convection\n##########################################################\n\nmu = 1.81e-3\nrho_solid = 6093\nrho_liquid = 6093\nk_solid = 32\nk_liquid = 32\ncp_solid = 381.5\ncp_liquid = 381.5\nL = 80160\nalpha_b = 1.2e-4\nT_solidus = 302.93\nT_liquidus = '${fparse T_solidus + 0.1}'\nadvected_interp_method = 'upwind'\nvelocity_interp_method = 'rc'\nT_cold = 301.15\nT_hot = 311.15\nNx = 20\nNy = 12\n\n[GlobalParams]\n  rhie_chow_user_object = 'rc'\n[]\n\n[UserObjects]\n  [rc]\n    type = INSFVRhieChowInterpolator\n    u = vel_x\n    v = vel_y\n    pressure = pressure\n  []\n[]\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    xmax = 88.9e-3\n    ymin = 0\n    ymax = 63.5e-3\n    nx = ${Nx}\n    ny = ${Ny}\n  []\n[]\n\n[AuxVariables]\n  [U]\n    type = MooseVariableFVReal\n  []\n  [fl]\n    type = MooseVariableFVReal\n    initial_condition = 0.0\n  []\n  [density]\n    type = MooseVariableFVReal\n  []\n  [th_cond]\n    type = MooseVariableFVReal\n  []\n  [cp_var]\n    type = MooseVariableFVReal\n  []\n  [darcy_coef]\n    type = MooseVariableFVReal\n  []\n  [fch_coef]\n    type = MooseVariableFVReal\n  []\n[]\n\n[AuxKernels]\n  [mag]\n    type = VectorMagnitudeAux\n    variable = U\n    x = vel_x\n    y = vel_y\n  []\n  [compute_fl]\n    type = NSLiquidFractionAux\n    variable = fl\n    temperature = T\n    T_liquidus = '${T_liquidus}'\n    T_solidus = '${T_solidus}'\n    execute_on = 'TIMESTEP_END'\n  []\n  [rho_out]\n    type = ADFunctorElementalAux\n    functor = 'rho_mixture'\n    variable = 'density'\n  []\n  [th_cond_out]\n    type = ADFunctorElementalAux\n    functor = 'k_mixture'\n    variable = 'th_cond'\n  []\n  [cp_out]\n    type = ADFunctorElementalAux\n    functor = 'cp_mixture'\n    variable = 'cp_var'\n  []\n  [darcy_out]\n    type = ADFunctorElementalAux\n    functor = 'Darcy_coefficient'\n    variable = 'darcy_coef'\n  []\n  [fch_out]\n    type = ADFunctorElementalAux\n    functor = 'Forchheimer_coefficient'\n    variable = 'fch_coef'\n  []\n[]\n\n[Variables]\n  [vel_x]\n    type = INSFVVelocityVariable\n    initial_condition = 0.0\n  []\n  [vel_y]\n    type = INSFVVelocityVariable\n    initial_condition = 0.0\n  []\n  [pressure]\n    type = INSFVPressureVariable\n  []\n  [lambda]\n    family = SCALAR\n    order = FIRST\n  []\n  [T]\n    type = INSFVEnergyVariable\n    initial_condition = '${T_cold}'\n    scaling = 1.0\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    advected_interp_method = ${advected_interp_method}\n    velocity_interp_method = ${velocity_interp_method}\n    rho = rho_mixture\n  []\n  [mean_zero_pressure]\n    type = FVIntegralValueConstraint\n    variable = pressure\n    lambda = lambda\n    phi0 = 0.0\n  []\n\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_x\n    rho = rho_mixture\n    momentum_component = 'x'\n  []\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_x\n    advected_interp_method = ${advected_interp_method}\n    velocity_interp_method = ${velocity_interp_method}\n    rho = rho_mixture\n    momentum_component = 'x'\n  []\n  [u_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_x\n    mu = ${mu}\n    momentum_component = 'x'\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_x\n    momentum_component = 'x'\n    pressure = pressure\n  []\n  [u_friction]\n    type = INSFVMomentumFriction\n    variable = vel_x\n    momentum_component = 'x'\n    linear_coef_name = 'Darcy_coefficient'\n    quadratic_coef_name = 'Forchheimer_coefficient'\n  []\n  [u_buoyancy]\n    type = INSFVMomentumBoussinesq\n    variable = vel_x\n    T_fluid = T\n    gravity = '0 -9.81 0'\n    rho = '${rho_liquid}'\n    ref_temperature = ${T_cold}\n    momentum_component = 'x'\n  []\n  [u_gravity]\n    type = INSFVMomentumGravity\n    variable = vel_x\n    gravity = '0 -9.81 0'\n    rho = '${rho_liquid}'\n    momentum_component = 'x'\n  []\n\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_y\n    rho = rho_mixture\n    momentum_component = 'y'\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_y\n    advected_interp_method = ${advected_interp_method}\n    velocity_interp_method = ${velocity_interp_method}\n    rho = rho_mixture\n    momentum_component = 'y'\n  []\n  [v_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_y\n    momentum_component = 'y'\n    pressure = pressure\n  []\n  [v_friction]\n    type = INSFVMomentumFriction\n    variable = vel_y\n    momentum_component = 'y'\n    linear_coef_name = 'Darcy_coefficient'\n    quadratic_coef_name = 'Forchheimer_coefficient'\n  []\n  [v_buoyancy]\n    type = INSFVMomentumBoussinesq\n    variable = vel_y\n    T_fluid = T\n    gravity = '0 -9.81 0'\n    rho = '${rho_liquid}'\n    ref_temperature = ${T_cold}\n    momentum_component = 'y'\n  []\n  [v_gravity]\n    type = INSFVMomentumGravity\n    variable = vel_y\n    gravity = '0 -9.81 0'\n    rho = '${rho_liquid}'\n    momentum_component = 'y'\n  []\n\n  [T_time]\n    type = INSFVEnergyTimeDerivative\n    variable = T\n    cp = cp_mixture\n    rho = rho_mixture\n  []\n  [energy_advection]\n    type = INSFVEnergyAdvection\n    variable = T\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n  []\n  [energy_diffusion]\n    type = FVDiffusion\n    coeff = k_mixture\n    variable = T\n  []\n  [energy_source]\n    type = NSFVPhaseChangeSource\n    variable = T\n    L = ${L}\n    liquid_fraction = fl\n    T_liquidus = ${T_liquidus}\n    T_solidus = ${T_solidus}\n    rho = 'rho_mixture'\n  []\n\n[]\n\n[FVBCs]\n  [walls-u]\n    type = INSFVNoSlipWallBC\n    boundary = 'left right top bottom'\n    variable = vel_x\n    function = 0\n  []\n  [walls-v]\n    type = INSFVNoSlipWallBC\n    boundary = 'left right top bottom'\n    variable = vel_y\n    function = 0\n  []\n  [hot_wall]\n    type = FVDirichletBC\n    variable = T\n    value = '${T_hot}'\n    boundary = 'left'\n  []\n  [cold_wall]\n    type = FVDirichletBC\n    variable = T\n    value = '${T_cold}'\n    boundary = 'right'\n  []\n[]\n\n[Materials]\n  [ins_fv]\n    type = INSFVEnthalpyMaterial\n    rho = rho_mixture\n    cp = cp_mixture\n    temperature = 'T'\n  []\n  [eff_cp]\n    type = NSFVMixtureMaterial\n    phase_2_names = '${cp_solid} ${k_solid} ${rho_solid}'\n    phase_1_names = '${cp_liquid} ${k_liquid} ${rho_liquid}'\n    prop_names = 'cp_mixture k_mixture rho_mixture'\n    phase_1_fraction = fl\n  []\n  [mushy_zone_resistance]\n    type = INSFVMushyPorousFrictionMaterial\n    liquid_fraction = 'fl'\n    mu = '${mu}'\n    rho_l = '${rho_liquid}'\n    dendrite_spacing_scaling = 1e-1\n  []\n  [const_functor]\n    type = ADGenericFunctorMaterial\n    prop_names = 'alpha_b'\n    prop_values = '${alpha_b}'\n  []\n[]\n\n[Adaptivity]\n   max_h_level = 3\n\n  [Markers]\n    [temp_maker]\n      type = ValueRangeMarker\n      lower_bound = ${T_solidus}\n      upper_bound = 10000\n      variable = T\n    []\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  # Time-stepping parameters\n  start_time = 0.0\n  end_time = 200.0\n\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    optimal_iterations = 10\n    dt = 0.1\n  []\n\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu NONZERO'\n  nl_rel_tol = 1e-2\n  nl_abs_tol = 1e-4\n  nl_max_its = 30\n[]\n\n[Outputs]\n  exodus = true\n  csv = false\n[]",
          "url": "https://github.com/idaholab/moose/discussions/26228",
          "updatedAt": "2023-12-11T22:29:50Z",
          "publishedAt": "2023-12-02T11:50:49Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "makeclean"
                  },
                  "bodyText": "I think AMR only works with nodal variables, you could likely map the thing your interested in from being elemental to nodal, using something like\n[t_nodal]\n    order = FIRST\n    family = MONOMIAL\n  []\n\nWith a AuxKernel\n  [v_elem]\n    type = ProjectionAux\n    v = t_nodal\n    variable = T \n []\n[]\n\nThen change your AMR target variable to t_nodal",
                  "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7738987",
                  "updatedAt": "2023-12-02T16:58:23Z",
                  "publishedAt": "2023-12-02T16:58:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "grmnptr"
                  },
                  "bodyText": "AMR should work for FV variables. There is a test in the framework for it (grap in moose/test folder). Let me know if you can't find it, I can try to look it up once I am at my computer.",
                  "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7739006",
                  "updatedAt": "2023-12-02T17:03:04Z",
                  "publishedAt": "2023-12-02T17:03:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Seems you need to specify the marker\n[Adaptivity]\n  max_h_level = 3\n  marker = temp_maker\n  [Markers]\n    [temp_maker]\n\nI wonder why.. seems like a bad design to ignore by default",
                  "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7741461",
                  "updatedAt": "2023-12-03T01:53:02Z",
                  "publishedAt": "2023-12-03T01:53:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "doquang"
                  },
                  "bodyText": "@grmnptr - I found the tests in folder test/tests/fvkernels/fv_adapt. Those tests are using BoxMarker, and it works fine. But it doesn't work for me if I switch to use ValueRangeMarker as below:\n[Adaptivity]\n  max_h_level = 3\n  marker = u_maker\n  [Markers]\n    [u_maker]\n      type = ValueRangeMarker\n      lower_bound = 0.5\n      upper_bound = 10000\n      variable = u\n    []\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7744113",
                  "updatedAt": "2023-12-03T15:05:24Z",
                  "publishedAt": "2023-12-03T15:05:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "doquang"
                  },
                  "bodyText": "@GiudGiud - by adding parameter marker = ... does not solve my issue.",
                  "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7744119",
                  "updatedAt": "2023-12-03T15:06:12Z",
                  "publishedAt": "2023-12-03T15:06:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "interesting. It did trigger adaptivity on your input when I ran it.\nCan you paste the log?",
                          "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7744497",
                          "updatedAt": "2023-12-03T16:44:49Z",
                          "publishedAt": "2023-12-03T16:44:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "doquang"
                          },
                          "bodyText": "Here is some of them\nTime Step 0, time = 0\n\nScalar Variable Values:\n+----------------+----------------+\n| time           | lambda         |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+\n\n\nTime Step 1, time = 0.1, dt = 0.1\n 0 Nonlinear |R| = 2.639405e+03\n      0 Linear |R| = 2.639405e+03\n      1 Linear |R| = 1.544556e-12\n 1 Nonlinear |R| = 4.123644e-08\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  T: 4.123644e-08\n\nScalar Variable Values:\n+----------------+----------------+\n| time           | lambda         |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-01 |   3.743556e-18 |\n+----------------+----------------+\n\nMesh unchanged, skipping remaining steps...\n\nTime Step 2, time = 0.3, dt = 0.2\n 0 Nonlinear |R| = 2.194897e+03\n      0 Linear |R| = 2.194897e+03\n      1 Linear |R| = 2.848781e-12\n 1 Nonlinear |R| = 7.219062e-08\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  T: 7.219062e-08\n\nScalar Variable Values:\n+----------------+----------------+\n| time           | lambda         |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-01 |   3.743556e-18 |\n|   3.000000e-01 |  -3.613605e-23 |\n+----------------+----------------+\n\nMesh unchanged, skipping remaining steps...\n\nTime Step 3, time = 0.7, dt = 0.4\n 0 Nonlinear |R| = 1.697521e+03\n      0 Linear |R| = 1.697521e+03\n      1 Linear |R| = 4.392041e-08\n 1 Nonlinear |R| = 4.512988e+02\n      0 Linear |R| = 4.512988e+02\n      1 Linear |R| = 2.993721e-09\n 2 Nonlinear |R| = 8.569323e+00\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  T: 8.569323e+00\n\nScalar Variable Values:\n+----------------+----------------+\n| time           | lambda         |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-01 |   3.743556e-18 |\n|   3.000000e-01 |  -3.613605e-23 |\n|   7.000000e-01 |  -7.409458e-17 |\n+----------------+----------------+\n\nMesh unchanged, skipping remaining steps...\n\nTime Step 4, time = 1.5, dt = 0.8\n 0 Nonlinear |R| = 7.855620e+03\n      0 Linear |R| = 7.855620e+03\n      1 Linear |R| = 9.132753e-08\n 1 Nonlinear |R| = 5.957224e+02\n      0 Linear |R| = 5.957224e+02\n      1 Linear |R| = 3.789441e-09\n 2 Nonlinear |R| = 3.150666e+01\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  T: 3.150666e+01",
                          "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7744512",
                          "updatedAt": "2023-12-03T16:49:27Z",
                          "publishedAt": "2023-12-03T16:49:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you set the third_state parameter to refine?",
                          "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7744624",
                          "updatedAt": "2023-12-03T16:57:32Z",
                          "publishedAt": "2023-12-03T16:57:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "doquang"
                  },
                  "bodyText": "can you set the third_state parameter to refine?\n\nBy adding third_state = REFINE do not change the results. I always get messages:\nMesh unchanged, skipping remaining steps...",
                  "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7744994",
                  "updatedAt": "2023-12-03T17:37:16Z",
                  "publishedAt": "2023-12-03T17:37:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I played with the parameters a bit.\ninvert = true is the key here to see something immediately, you re trying to refine at low temperatures right?\nor in the liquid region? (third_state)\nAdaptivity does trigger with:\n[Adaptivity]\n  max_h_level = 3\n  marker = temp_maker\n  [Markers]\n    [temp_maker]\n      type = ValueRangeMarker\n      lower_bound = '${fparse T_solidus}'\n      upper_bound = 10000\n      variable = T\n      invert = true\n      # third_state = REFINE\n    []\n  []\n[]\n\nthe log does not include this Mesh unchanged because adaptivity is on\nTime Step 0, time = 0\n\nScalar Variable Values:\n+----------------+----------------+\n| time           | lambda         |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+\n\n\nTime Step 1, time = 0.1, dt = 0.1\n 0 Nonlinear |R| = 2.639405e+03\n      0 Linear |R| = 2.639405e+03\n      1 Linear |R| = 1.509562e-12\n 1 Nonlinear |R| = 4.127113e-08\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  T: 4.127113e-08\n\nScalar Variable Values:\n+----------------+----------------+\n| time           | lambda         |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-01 |   4.235227e-18 |\n+----------------+----------------+\n\n\nTime Step 2, time = 0.3, dt = 0.2\n 0 Nonlinear |R| = 3.313282e+03\n      0 Linear |R| = 3.313282e+03\n      1 Linear |R| = 3.820352e-12\n 1 Nonlinear |R| = 6.313553e-03\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  T: 6.313553e-03\n\nScalar Variable Values:\n+----------------+----------------+\n| time           | lambda         |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-01 |   4.235227e-18 |\n|   3.000000e-01 |   4.442778e-18 |\n+----------------+----------------+\n\n\nTime Step 3, time = 0.7, dt = 0.4",
                          "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7747669",
                          "updatedAt": "2023-12-04T00:04:09Z",
                          "publishedAt": "2023-12-04T00:04:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "doquang"
                  },
                  "bodyText": "@GiudGiud - It still do not fully work for me. The invert of nothing is everything. So the mesh do not refine at high (or low) temperatures as what I want.",
                  "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7750072",
                  "updatedAt": "2023-12-04T07:53:03Z",
                  "publishedAt": "2023-12-04T07:53:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so you want (refine, nothing, refine)  at (low T, solidus-10000, > 10000) right?",
                          "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7753067",
                          "updatedAt": "2023-12-04T13:19:13Z",
                          "publishedAt": "2023-12-04T13:19:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "doquang"
                          },
                          "bodyText": "From ValueRangeMarker, if I understood correctly, I would like:\n(coarsening, refine, coarsening) at (< T_solidus, T_solidus, > 10000)\nMarker::MarkerValue\nValueRangeMarker::computeQpMarker()\n{\n  // Is the variable value inside the range?\n  if (_u[_qp] >= _lower_bound && _u[_qp] <= _upper_bound)\n    return _inside;\n\n  // How about the buffer zone?\n  if (_u[_qp] >= _lower_bound - _buffer_size && _u[_qp] <= _upper_bound + _buffer_size)\n    return _third_state;\n\n  // Must be outside the range\n  return _outside;\n}",
                          "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7753165",
                          "updatedAt": "2023-12-04T13:30:11Z",
                          "publishedAt": "2023-12-04T13:29:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "doquang"
                          },
                          "bodyText": "@GiudGiud - By debugging, I got the value _u[_qp] always = T_init",
                          "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7753209",
                          "updatedAt": "2023-12-04T13:34:14Z",
                          "publishedAt": "2023-12-04T13:34:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok so invert = false is correct.\nI m looking into it.",
                          "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7754075",
                          "updatedAt": "2023-12-04T14:57:29Z",
                          "publishedAt": "2023-12-04T14:57:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok so INSFVEnergyVariable (the type of T) does not compute values on Qps (but it should have, there's even an API for it. I ll keep looking)\nSo that s why it cannot be used with this marker.\nI ll put up a patch.\nIn the mean time, use a ProjectionAux to copy this variable on a constant monomial. Then use this constant monomial for adaptivity. This will give the exact same result as you would have gotten if INSFVEnergyVariable worked with Qps",
                          "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7755232",
                          "updatedAt": "2023-12-04T16:38:10Z",
                          "publishedAt": "2023-12-04T16:34:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I am getting decent results now with adaptivty on T\nI had to restart from the galium melting input. I dont know what I did (or did not do) to your input file in the process of finding the bug but the results were awful. I started coarser than that galium meling input has the mesh",
                  "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7755792",
                  "updatedAt": "2023-12-04T17:27:01Z",
                  "publishedAt": "2023-12-04T17:27:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "note that convergence isnt really pushed too hard, which could likely explain the lack of symmetry / uniformity of the results. You ll have to investigate",
                          "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7755798",
                          "updatedAt": "2023-12-04T17:27:50Z",
                          "publishedAt": "2023-12-04T17:27:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is now fixed in the latest MOOSE version (in next branch)",
                          "url": "https://github.com/idaholab/moose/discussions/26228#discussioncomment-7824905",
                          "updatedAt": "2023-12-11T22:29:51Z",
                          "publishedAt": "2023-12-11T22:29:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error \"Sorry, you cannot currently specify multiple subdomain or boundary ids for a given geometric entity\" when defining Bcs on Gmsh generated surface",
          "author": {
            "login": "Lezgo11"
          },
          "bodyText": "Hello! I'm tying to set up BCs on a 3D model I did myself. However, I keep running into this error:\nSorry, you cannot currently specify multiple subdomain or boundary ids for a given geometric entity\n\nStack frames: 15\n0: 0   libmesh_opt.0.dylib                 0x000000010f59362c libMesh::print_trace(std::__1::basic_ostream<char, std::__1::char_traits<char>>&) + 1148\n1: 1   libmesh_opt.0.dylib                 0x000000010f590af3 libMesh::MacroFunctions::report_error(char const*, int, char const*, char const*, std::__1::basic_ostream<char, std::__1::char_traits<char>>&) + 179\n2: 2   libmesh_opt.0.dylib                 0x000000010f9c8718 libMesh::GmshIO::read_mesh(std::__1::basic_istream<char, std::__1::char_traits<char>>&) + 14712\n3: 3   libmesh_opt.0.dylib                 0x000000010f9ccfed libMesh::GmshIO::read(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&) + 269\n4: 4   libmesh_opt.0.dylib                 0x000000010fb7d4c5 libMesh::NameBasedIO::read(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&) + 7589\n5: 5   libmesh_opt.0.dylib                 0x000000010fbd1fa8 libMesh::UnstructuredMesh::read(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, void*, bool, bool) + 216\n6: 6   libmoose-opt.0.dylib                0x000000010acda39b FileMesh::buildMesh() + 1195\n7: 7   libmoose-opt.0.dylib                0x000000010acd485f MooseMesh::init() + 271\n8: 8   libmoose-opt.0.dylib                0x000000010ba17c77 SetupMeshAction::act() + 1463\n9: 9   libmoose-opt.0.dylib                0x000000010b9e28de ActionWarehouse::executeActionsWithAction(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&) + 1342\n10: 10  libmoose-opt.0.dylib                0x000000010ba23988 ActionWarehouse::executeAllActions() + 264\n11: 11  libmoose-opt.0.dylib                0x000000010bd9644d MooseApp::runInputFile() + 141\n12: 12  libmoose-opt.0.dylib                0x000000010bd92095 MooseApp::run() + 1045\n13: 13  ex04-opt                            0x0000000100110bd3 main + 131\n14: 14  dyld                                0x00000002003a73a6 start + 1942\n[0] ../src/mesh/gmsh_io.C, line 300, compiled Nov 16 2023 at 15:58:37\n\n\nStack frames: 6\n0: 0   libmesh_opt.0.dylib                 0x000000010f59362c libMesh::print_trace(std::__1::basic_ostream<char, std::__1::char_traits<char>>&) + 1148\n1: 1   libmoose-opt.0.dylib                0x000000010bd83380 moose::internal::mooseErrorRaw(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>) + 784\n2: 2   libmoose-opt.0.dylib                0x000000010b5ba297 void mooseError<char const*>(char const*&&) + 247\n3: 3   libmoose-opt.0.dylib                0x000000010bd924da MooseApp::run() + 2138\n4: 4   ex04-opt                            0x0000000100110bd3 main + 131\n5: 5   dyld                                0x00000002003a73a6 start + 1942\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\n\nHere's the 3D object in question:\n\nI'm very new at Moose and have no idea if I did things right to begin with with the gmsh file. I would appreciate any input!",
          "url": "https://github.com/idaholab/moose/discussions/26290",
          "updatedAt": "2023-12-11T22:17:43Z",
          "publishedAt": "2023-12-10T17:56:43Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is a problem reading your GMSH file.\nIn moose, every element only has a single subdomain. Whatever we are using in the gmsh file to create the subdomains in the moose (really libmesh) mesh, it must have a single value on each element\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26290#discussioncomment-7815129",
                  "updatedAt": "2023-12-11T03:06:03Z",
                  "publishedAt": "2023-12-11T03:06:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "\"subdomain_id\" is a member variable of an element in type of subdomain_id_type in libMesh, which is the mesh framework used by MOOSE. I am not sure about Gmsh but one element having one single subdomain or block id is a common practice. A side can have multiple boundary ids on the other hand. If this mesh is a valid Gmsh mesh, something possibly will need to be fixed in libMesh. @roystgnr may have more comments.",
                          "url": "https://github.com/idaholab/moose/discussions/26290#discussioncomment-7824530",
                          "updatedAt": "2023-12-11T21:32:06Z",
                          "publishedAt": "2023-12-11T21:32:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "1runer"
                          },
                          "bodyText": "From the screenshot the mesh looks fine to me.\nCan you share the .geo file?",
                          "url": "https://github.com/idaholab/moose/discussions/26290#discussioncomment-7824846",
                          "updatedAt": "2023-12-11T22:17:53Z",
                          "publishedAt": "2023-12-11T22:17:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "pressure out of range",
          "author": {
            "login": "lvdbrand"
          },
          "bodyText": "Hello,\nI'm trying to make a 2D terrain stability study by coupling the \"TensorMechanics\" module and the \"PorousFlow\" module.\nI'd like to simulate a static water table in the ground. To do this, I've used an initial condition to give the \"porepressure\" variable a value using the \"PieceWiseMultilinear\" function.  My mesh is divided into two blocks: only the lower block contains water. At the interface between these two blocks (\"aquifers\" boundary), the porepressure variable is set to 0.\nMy problem is that Moose returns this error :\n\nWhy the pressure is out of range? Is there a lower limit below which Moose will not take a pressure into account? If so, how can this problem be solved?\nThanks!\nLucas\nHere is my code with my mesh and the file with the values of the \"porepressure\" variable:\npressure_out_of_range.zip",
          "url": "https://github.com/idaholab/moose/discussions/26297",
          "updatedAt": "2023-12-11T18:13:15Z",
          "publishedAt": "2023-12-11T16:41:37Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe lower limit on pressure is from the water fluid properties object, which requires physical pressures\nThe final Moose error messages is simply from enough time steps failing. It's not the one to look at. You want to address the problem with the pressures\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26297#discussioncomment-7822365",
                  "updatedAt": "2023-12-11T17:09:29Z",
                  "publishedAt": "2023-12-11T17:09:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lvdbrand"
                          },
                          "bodyText": "The problem is with \"Water97FluidProperties\"? Should I use something else like \"SimpleFluidProperties\" in fluidproperties object?",
                          "url": "https://github.com/idaholab/moose/discussions/26297#discussioncomment-7822603",
                          "updatedAt": "2023-12-11T17:31:10Z",
                          "publishedAt": "2023-12-11T17:31:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Feel free to use that one to get a result, but if you want to use water properties it would be better to find out why these properties are being evaluated at such a terribly small pressure",
                          "url": "https://github.com/idaholab/moose/discussions/26297#discussioncomment-7822646",
                          "updatedAt": "2023-12-11T17:34:54Z",
                          "publishedAt": "2023-12-11T17:34:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lvdbrand"
                          },
                          "bodyText": "To mimic an aquifer, I create a hydrostatic pressure whose value starts at 0 at the \"aquifers\" boundary and increases towards the \"bottom\" boundary. That's why the pressure is so small. Is there an easier way of doing this?\nThanks",
                          "url": "https://github.com/idaholab/moose/discussions/26297#discussioncomment-7822759",
                          "updatedAt": "2023-12-11T17:44:47Z",
                          "publishedAt": "2023-12-11T17:44:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you offset pressure to have realistic values? I reckon 0 atm does not exist in the real physical system",
                          "url": "https://github.com/idaholab/moose/discussions/26297#discussioncomment-7822797",
                          "updatedAt": "2023-12-11T17:48:22Z",
                          "publishedAt": "2023-12-11T17:48:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "1runer"
                          },
                          "bodyText": "Hydrostatic pressure is not \"0\". You always have the atmospheric pressure acting on the fluid and rock body which is in the order of 1e5 Pa.",
                          "url": "https://github.com/idaholab/moose/discussions/26297#discussioncomment-7823001",
                          "updatedAt": "2023-12-11T18:15:09Z",
                          "publishedAt": "2023-12-11T18:13:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlowPolyLineSink - specify injection temperature",
          "author": {
            "login": "anupkgeos"
          },
          "bodyText": "Hi all,\nHow can I inject fluid at a certain temperature using PorousFlowPolyLineSink?\n[./injection_T]\n    type = PorousFlowPolyLineSink\n    fluid_phase = 0\n    variable = temperature\n    SumQuantityUO = heat_enthalpy_in_inc\n    line_base = '1 0.01 0.1 0.0'\n    line_length = ${well_length}\n    line_direction = '0 0 1'\n    use_internal_energy = true\n    p_or_t_vals = '-1e9 1e9'\n    fluxes = '-${inj_ext_flux} -${inj_ext_flux}'\n  [../]\n\nOr is there any DiracKernel for a line source where injection temperature can be specified?\nThank you,\nAnup",
          "url": "https://github.com/idaholab/moose/discussions/26272",
          "updatedAt": "2023-12-11T17:36:28Z",
          "publishedAt": "2023-12-07T16:20:52Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lynnmunday"
                  },
                  "bodyText": "These are documented on this page:\nhttps://mooseframework.inl.gov/modules/porous_flow/sinks.html",
                  "url": "https://github.com/idaholab/moose/discussions/26272#discussioncomment-7792517",
                  "updatedAt": "2023-12-07T18:28:09Z",
                  "publishedAt": "2023-12-07T18:28:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "anupkgeos"
                          },
                          "bodyText": "with all line sinks, there is use option to use_enthalpy but no option to specify the injection temperature",
                          "url": "https://github.com/idaholab/moose/discussions/26272#discussioncomment-7794362",
                          "updatedAt": "2023-12-07T22:26:44Z",
                          "publishedAt": "2023-12-07T22:26:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "1runer"
                  },
                  "bodyText": "I don't think you can set a specific temperature for any kind of line object. Their value is always determined for a specific area/volume. Therefore a flux (e.g. energy) is needed to normalize the value over the area.\nI also doubt that this assumption is realistic. Let's start with a borehole. We know the temperature of the fluid at the top of the open borehole. This temperature then rises to the bottom of the borehole (or to reservoir temperature)depending on the rock properties. In modeling, a temperature at a point (open top hole) is often specified as Dirichlet-BC assuming a certain fluid flow.\nIf you want to have a certain temperature a long a line, I would use the PorousFlowPolyLineSink for fluid flux only. For temperature I would define the line of interested as Nodeset (e.g. using BoundingBoxNodeSetGenerator) and add a Dirichlet-BC for temperature.",
                  "url": "https://github.com/idaholab/moose/discussions/26272#discussioncomment-7822655",
                  "updatedAt": "2023-12-11T17:54:59Z",
                  "publishedAt": "2023-12-11T17:36:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem with Outputs System",
          "author": {
            "login": "lvdbrand"
          },
          "bodyText": "Hello, I'm new with Moose and i have a problem with the 'Outputs System' in my files.\nI'm trying to do a 3D terrain stability study with the TensorMechanics module. First I wrote a code for a 2D case study (which worked), then I adapted it for 3D and that's when it stopped working.\nI have a problem when adding the 'Outputs System'. The code runs in the console only when I comment out this part. I'd like to have the exodus file for visualization purposes. I don't see where I made a mistake, can you help me?\nThanks!\nLucas\nHere's the error I get:\nlibMesh terminating:\nError writing sidesets\nStack frames: 21\n0: libMesh::print_trace(std::ostream&)\n1: libMesh::MacroFunctions::report_error(char const*, int, char const*, char const*, std::ostream&)\n2: libMesh::ExodusII_IO_Helper::write_sidesets(libMesh::MeshBase const&)\n3: libMesh::ExodusII_IO::write_nodal_data_common(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&, bool)\n4: libMesh::ExodusII_IO::write_nodal_data(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::vector<double, std::allocator<double> > const&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const&)\n5: libMesh::MeshOutput<libMesh::MeshBase>::write_equation_systems(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, libMesh::EquationSystems const&, std::set<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const*)\n6: libMesh::ExodusII_IO::write_timestep(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, libMesh::EquationSystems const&, int, double, std::set<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > > > const*)\n7: Exodus::outputNodalVariables()\n8: AdvancedOutput::output(MooseEnumItem const&)\n9: Exodus::output(MooseEnumItem const&)\n10: OversampleOutput::outputStep(MooseEnumItem const&)\n11: OutputWarehouse::outputStep(MooseEnumItem)\n12: FEProblemBase::outputStep(MooseEnumItem)\n13: Transient::preExecute()\n14: Transient::execute()\n15: MooseApp::executeExecutioner()\n16: MooseApp::run()\n17: main\n18: /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7faf7d6abd90]\n19: __libc_start_main\n20: ./tensor_mechanics-opt(+0x33ff) [0x5648725333ff]\n[0] ../src/mesh/exodusII_io_helper.C, line 3231, compiled Jun 23 2023 at 20:09:25\n\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n\nHere's my code :\n[Mesh]\n    type = FileMesh\n    file = maillage_3D_zone_r\u00e9duite_V6.msh\n    coord_block = '0 1'\n[]\n\n[GlobalParams]\n    displacements = 'disp_x disp_y disp_z'\n[]\n  \n[Modules]\n    [TensorMechanics]\n        [Master]\n        [all]\n            strain = SMALL\n            incremental = true\n            add_variables = true\n            generate_output = 'stress_xx stress_xy stress_xz stress_yy stress_yx stress_yz stress_zz stress_zx stress_zy strain_xx strain_xy strain_xz strain_yy strain_yx strain_yz strain_zz strain_zx strain_zy plastic_strain_xx plastic_strain_xy plastic_strain_xz plastic_strain_yy plastic_strain_yx plastic_strain_yz plastic_strain_zz plastic_strain_zx plastic_strain_zy secondinv_strain'\n        []\n        []\n    []\n[]\n\n[Kernels]\n    [gravity_z]\n        type = Gravity\n        variable = disp_z\n        value = -9.81\n    []\n[]\n  \n  \n[BCs]\n    [confine_x]\n        type = DirichletBC\n        variable = disp_x\n        boundary = 'north_side east_side south_side west_side bottom'\n        value = 0\n    []\n    [confine_y]\n        type = DirichletBC\n        variable = disp_y\n        boundary = 'north_side east_side south_side west_side bottom'\n        value = 0\n    []\n    [confine_z]\n        type = DirichletBC\n        variable = disp_z\n        boundary = bottom\n        value = 0\n    []\n[]\n\n[AuxVariables]\n    [./mc_int]\n        order = CONSTANT\n        family = MONOMIAL\n    [../]\n    [./yield_fcn]\n        order = CONSTANT\n        family = MONOMIAL\n    [../]\n    [./cohesion]\n        order = CONSTANT\n        family = MONOMIAL\n    [../]\n    [./friction]\n        order = CONSTANT\n        family = MONOMIAL\n    [../]\n[]\n  \n[AuxKernels]\n    [./mc_int_auxk]\n        type = MaterialStdVectorAux\n        index = 0\n        property = plastic_internal_parameter\n        variable = mc_int\n    [../]\n    [./yield_fcn_auxk]\n        type = MaterialStdVectorAux\n        index = 0\n        property = plastic_yield_function\n        variable = yield_fcn\n    [../]\n[]\n  \n[Postprocessors]\n    [./dt]\n        type = TimestepSize\n    [../]\n[]\n    \n[UserObjects]\n    [./mc_coh_0]\n        type = TensorMechanicsHardeningTime\n        value = 20e3\n    [../]\n    [./mc_phi_0]\n        type = TensorMechanicsHardeningTime\n        value = 0.5236\n    [../]\n    [./mc_psi_0]\n        type = TensorMechanicsHardeningTime\n        value = 0.5236\n    [../]\n    [./mc_0]\n        type = TensorMechanicsPlasticMohrCoulomb\n        cohesion = mc_coh_0\n        friction_angle = mc_phi_0\n        dilation_angle = mc_psi_0\n        mc_tip_smoother = 0\n        mc_edge_smoother = 25\n        yield_function_tolerance = 1E-3\n        internal_constraint_tolerance = 1E-8\n    [../]\n    [./mc_coh_1]\n        type = TensorMechanicsHardeningTime\n        value = 20e3\n    [../]\n    [./mc_phi_1]\n        type = TensorMechanicsHardeningTime\n        value = 0.6108\n    [../]\n    [./mc_psi_1]\n        type = TensorMechanicsHardeningTime\n        value = 0.6108\n    [../]\n    [./mc_1]\n        type = TensorMechanicsPlasticMohrCoulomb\n        cohesion = mc_coh_1\n        friction_angle = mc_phi_1\n        dilation_angle = mc_psi_1\n        mc_tip_smoother = 0\n        mc_edge_smoother = 25\n        yield_function_tolerance = 1E-3\n        internal_constraint_tolerance = 1E-8\n    [../]\n[]\n    \n[Materials]\n    [./elasticity_tensor_0]\n        type = ComputeIsotropicElasticityTensor\n        block = 0\n        youngs_modulus = 20e6\n        poissons_ratio = 0.3\n    [../]\n    [./mc_0]\n        type = ComputeMultiPlasticityStress\n        ep_plastic_tolerance = 1E-7\n        plastic_models = mc_0\n        perform_finite_strain_rotations = false\n        min_stepsize = 0.01\n        ignore_failures = true\n        block = 0\n    [../]\n    [density_0]\n        type = GenericConstantMaterial\n        block = 0\n        prop_names = density\n        prop_values = 1937\n    [../]\n    [./elasticity_tensor_1]\n        type = ComputeIsotropicElasticityTensor\n        block = 1\n        youngs_modulus = 20e6\n        poissons_ratio = 0.3\n    [../]\n    [./mc_1]\n        type = ComputeMultiPlasticityStress\n        ep_plastic_tolerance = 1E-7\n        plastic_models = mc_1\n        perform_finite_strain_rotations = false\n        min_stepsize = 0.01\n        ignore_failures = true\n        block = 1\n    [../]\n    [density_1]\n        type = GenericConstantMaterial\n        block = 1\n        prop_names = density\n        prop_values = 1937\n    [../]\n[]\n    \n[Preconditioning]\n    [./andy]\n        type = SMP\n        full = true\n    [../]\n[]\n\n    \n[Executioner]\n    end_time = 3\n    dt = 0.05\n    #num_steps = 35\n    solve_type = NEWTON\n    type = Transient\n\n    line_search = 'basic'\n    nl_abs_tol = 1e-3\n    nl_rel_tol = 1e-5\n\n    l_max_its = 50\n    nl_max_its = 30\n\n    dtmin = 1e-8\n\n    petsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -ksp_type -ksp_gmres_restart'\n    petsc_options_value = ' asm      2              lu            gmres     200'\n  \n    automatic_scaling = true\n    scaling_group_variables = 'disp_x disp_y disp_z'\n[]\n\n[Outputs]\n    file_base = test_terrils_3D_transient\n    exodus = true\n    #perf_graph = true\n[]\n\nHere are the files I've added to UserObjects 'TensorMechanicsHardeningTime', as well as my mesh if necessary.\nOutputs_problem.zip",
          "url": "https://github.com/idaholab/moose/discussions/25582",
          "updatedAt": "2023-12-11T15:56:37Z",
          "publishedAt": "2023-09-26T14:15:08Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou have sidesets with negative ids.\ni m not sure why that is.\nyou can rename them in the .msh file\ndo they contain accents like the mesh name?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25582#discussioncomment-7114109",
                  "updatedAt": "2023-09-26T15:11:41Z",
                  "publishedAt": "2023-09-26T15:11:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lvdbrand"
                  },
                  "bodyText": "Hello,\nIndeed, that was the cause of my problem.\nPS: sorry for the late reply.",
                  "url": "https://github.com/idaholab/moose/discussions/25582#discussioncomment-7821537",
                  "updatedAt": "2023-12-11T15:51:04Z",
                  "publishedAt": "2023-12-11T15:51:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no worries. Thank you for letting us know!",
                          "url": "https://github.com/idaholab/moose/discussions/25582#discussioncomment-7821595",
                          "updatedAt": "2023-12-11T15:56:38Z",
                          "publishedAt": "2023-12-11T15:56:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "want to define a new boundary three layers above the boundary exists",
          "author": {
            "login": "ziyiwang141319"
          },
          "bodyText": "I want to define a new boundary several layers (2-5 as i define) above the boundary exists. I am thinking of use NearestNodeLocator and BoundingBoxNodeSystem, but I am kind of unclear how to reach the goal. or is there a better way? And for NearestNodeLocator and BoundingBoxNodeSystem, can I use the mesh from a file? (It did not work when I tried it). I am not very familar with generate mesh using Moose, I read a disscussion mentioned scratch in moose. Where can I activate it? Thanks!!",
          "url": "https://github.com/idaholab/moose/discussions/26167",
          "updatedAt": "2023-12-11T06:41:27Z",
          "publishedAt": "2023-11-28T01:35:34Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe have not done much on boundary layers afaik\nTo do this, I would create a BoundaryLayerExtraIDGenerator that sets an extra element integer equal to the boundary layer index.\nthis new mesh generator, that only sets an extra element id, could then act on moose-generated meshes or external meshes loaded using a FileMeshGenerator the same way\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26167#discussioncomment-7687016",
                  "updatedAt": "2023-11-28T01:44:26Z",
                  "publishedAt": "2023-11-28T01:44:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ziyiwang141319"
                          },
                          "bodyText": "Thanks a lot. I will try.",
                          "url": "https://github.com/idaholab/moose/discussions/26167#discussioncomment-7816194",
                          "updatedAt": "2023-12-11T06:41:27Z",
                          "publishedAt": "2023-12-11T06:41:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}