{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0xMi0xNFQwODowMDoxMS0wNjowMM4AOQVi"
    },
    "edges": [
      {
        "node": {
          "title": "Multiapps user object based transfer - Seg fault with UserObjectInterface",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Dear all,\nI am trying to develop an user object based multi-apps transfer mechanism along the lines of MultiAppUserObjectTransfer.  The issue being that i could not get the basic framework to execute for the simplest of cases. There seems to be an seg-fault problem with the inclusion of UserObjectInterface which is a direct base class of the new transfer class that i am currently developing. Execution is OK without UserObjectInterface, however with the cost of undefined reference to getUserObjectByName and therefore i continued inheriting this class and moved on to debug the seg-fault. I tried to check this issue in the debug mode and obtained the following trace back.\n\n#1  0x00007ffff7bc881a in std::_Rb_tree<std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::pair<std::__cxx11::basic_string<char, std::char_traits, std::allocator > const, libMesh::Parameters::Value*>, std::_Select1st<std::pair<std::__cxx11::basic_string<char, std::char_traits, std::allocator > const, libMesh::Parameters::Value*> >, std::less<std::__cxx11::basic_string<char, std::char_traits, std::allocator > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits, std::allocator > const, libMesh::Parameters::Value*> > >::find (this=0x311, __k=...) at /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/stl_tree.h:2536\n#2  0x00007ffff7bc725b in std::__cxx1998::map<std::__cxx11::basic_string<char, std::char_traits, std::allocator >, libMesh::Parameters::Value*, std::less<std::__cxx11::basic_string<char, std::char_traits, std::allocator > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits, std::allocator > const, libMesh::Parameters::Value*> > >::find (this=0x311, __x=...) at /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/stl_map.h:1189\n#3  0x00007ffff7bc54f0 in std::__debug::map<std::__cxx11::basic_string<char, std::char_traits, std::allocator >, libMesh::Parameters::Value*, std::less<std::__cxx11::basic_string<char, std::char_traits, std::allocator > >, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits, std::allocator > const, libMesh::Parameters::Value*> > >::find (this=0x2f9, __x=...) at /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/debug/map.h:574\n#4  0x00007ffff6a95306 in libMesh::Parameters::have_parameter<FEProblemBase*> (this=0x2f1, name=...)\nat /home/abalasub/Working/Projects/moose/scripts/../libmesh/installed/include/libmesh/parameters.h:407\n#5  0x00007ffff6a95a95 in libMesh::Parameters::get<FEProblemBase*> (this=0x2f1, name=...)\nat /home/abalasub/Working/Projects/moose/scripts/../libmesh/installed/include/libmesh/parameters.h:426\n#6  0x00007ffff6a9415f in InputParameters::getCheckedPointerParam<FEProblemBase*> (this=0x2f1, name=..., error_string=...)\nat /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/InputParameters.h:1211\n#7  0x00007ffff2454c90 in UserObjectInterface::UserObjectInterface (this=0xf6df18, moose_object=0xf6d800)\nat /home/abalasub/Working/Projects/moose/framework/src/userobject/UserObjectInterface.C:25\n#8  0x00007ffff1cd51f3 in MultiAppTransferQuantity_UO::MultiAppTransferQuantity_UO (this=0xf6d800, parameters=...,\n__in_chrg=, __vtt_parm=)\nat /home/abalasub/Working/Projects/moose/framework/src/transfers/MultiAppTransferQuantity_UO.C:33\n#9  0x00007ffff1d5782d in __gnu_cxx::new_allocator<MultiAppTransferQuantity_UO>::construct<MultiAppTransferQuantity_UO, InputParameters const&> (this=0x7fffffffbc27, __p=0xf6d800, __args#0=...)\n#10 0x00007ffff1d54e84 in std::allocator_traits<std::allocator<MultiAppTransferQuantity_UO> >::construct<MultiAppTransferQuantity_UO, InputParameters const&> (__a=..., __p=0xf6d800, __args#0=...)\nat /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/alloc_traits.h:475\n#11 0x00007ffff1d50cff in std::_Sp_counted_ptr_inplace<MultiAppTransferQuantity_UO, std::allocator<MultiAppTransferQuantity_UO>, (__gnu_cxx::_Lock_policy)2>::_Sp_counted_ptr_inplace<InputParameters const&> (this=0xf6d7f0, __a=...)\nat /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr_base.h:526\n#12 0x00007ffff1d4befb in std::__shared_count<(__gnu_cxx::_Lock_policy)2>::__shared_count<MultiAppTransferQuantity_UO, std::al---Type  to continue, or q  to quit---\nlocator<MultiAppTransferQuantity_UO>, InputParameters const&> (this=0x7fffffffbdb8, __a=...)\nat /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr_base.h:637\n#13 0x00007ffff1d46686 in std::__shared_ptr<MultiAppTransferQuantity_UO, (__gnu_cxx::_Lock_policy)2>::__shared_ptr<std::allocator<MultiAppTransferQuantity_UO>, InputParameters const&> (this=0x7fffffffbdb0, __tag=..., __a=...)\nat /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr_base.h:1295\n#14 0x00007ffff1d3efd7 in std::shared_ptr<MultiAppTransferQuantity_UO>::shared_ptr<std::allocator<MultiAppTransferQuantity_UO>, InputParameters const&> (this=0x7fffffffbdb0, __tag=..., __a=...)\nat /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr.h:344\n#15 0x00007ffff1d33fc7 in std::allocate_shared<MultiAppTransferQuantity_UO, std::allocator<MultiAppTransferQuantity_UO>, InputParameters const&> (__a=..., __args#0=...) at /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr.h:691\n#16 0x00007ffff1d2251f in std::make_shared<MultiAppTransferQuantity_UO, InputParameters const&> (__args#0=...)\nat /usr/local/depot/gcc-7.3.0/include/c++/7.3.0/bits/shared_ptr.h:707\n#17 0x00007ffff1d0d8d0 in moose::internal::buildObj<MultiAppTransferQuantity_UO> (parameters=...)\nat /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/Registry.h:146\n#18 0x00007ffff2bc6187 in Factory::create (this=0x7ffff7ebb8f0, obj_name=..., name=..., parameters=..., tid=0,\nprint_deprecated=false) at /home/abalasub/Working/Projects/moose/framework/src/base/Factory.C:131\n#19 0x00007ffff1912324 in Factory::create (this=0x7ffff7ebb8f0, obj_name=..., name=..., parameters=..., tid=0)\nat /home/abalasub/Working/Projects/moose/framework/build/header_symlinks/Factory.h:303\n#20 0x00007ffff18b901b in FEProblemBase::addTransfer (this=0xd97660, transfer_name=..., name=..., parameters=...)\nat /home/abalasub/Working/Projects/moose/framework/src/problems/FEProblemBase.C:4482\n#21 0x00007ffff2340c8f in AddTransferAction::act (this=0xa9cfc0)\nat /home/abalasub/Working/Projects/moose/framework/src/actions/AddTransferAction.C:30\n#22 0x00007ffff232f5ad in Action::timedAct (this=0xa9cfc0)\nat /home/abalasub/Working/Projects/moose/framework/src/actions/Action.C:93\n#23 0x00007ffff2334023 in ActionWarehouse::executeActionsWithAction (this=0x7ffff7ebb510, task=...)\nat /home/abalasub/Working/Projects/moose/framework/src/actions/ActionWarehouse.C:392\n#24 0x00007ffff2333acd in ActionWarehouse::executeAllActions (this=0x7ffff7ebb510)\nat /home/abalasub/Working/Projects/moose/framework/src/actions/ActionWarehouse.C:352\n#25 0x00007ffff2b1abd5 in MooseApp::runInputFile (this=0x7ffff7e6c020)\nat /home/abalasub/Working/Projects/moose/framework/src/base/MooseApp.C:1017\n#26 0x00007ffff2b1d600 in MooseApp::run (this=0x7ffff7e6c020)\nat /home/abalasub/Working/Projects/moose/framework/src/base/MooseApp.C:1281\n#27 0x0000000000412c91 in main (argc=3, argv=0x7fffffffda98) at /home/abalasub/Working/Projects/submodel_repo/src/main.C:33\n\nA detailed analysis of traceback reveals the problem runs very deep in to the libmesh functionalities and that it is harder to find the exact cause of this issue. I wonder if there is any we could do here to find the right fix for this issue. Attached here are the modified sources and the input files used for this simulation, which might possibly throw some hints as to check where things are going wrong. Any suggestions here are highly appreciated.\nKind regards,\nArun\n08112021.zip",
          "url": "https://github.com/idaholab/moose/discussions/19322",
          "updatedAt": "2022-07-08T08:03:21Z",
          "publishedAt": "2021-11-08T19:00:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt seems the issue you are getting is because of this InputParameters::getCheckedPointerParam<FEProblemBase*>\nThis is used by the UO interface to get access to the FEProblem. i would put some print statements there to understand when this is being run, maybe it s being ran too early and the problem has not been created yet. I doubt it s that though, Transfers should be created fairly late.\nI think you have moved forward on this, based on this other discussion #19485\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19322#discussioncomment-1828607",
                  "updatedAt": "2022-07-08T08:03:19Z",
                  "publishedAt": "2021-12-16T21:51:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A question in SmearedCracking",
          "author": {
            "login": "xuxiaobei1995"
          },
          "bodyText": "Hi all,\n Recently I'm doing some work about cracking based on SmearedCracking. I want to realize two things:\n (1) Adjust the Young's modulus and Poisson's ratio depending on the number of cracks (For example, E_crack = E_intatct * (0.6)^N, N means the number of cracks).\n (2) When the cracked region is under compressive stresses and the temperature is above a given value, the cracks \"heal\" so that everything turn back to the original status.\n Because I knows little about the theory of the tensor mechanics, The code is difficult for me to understand. Does anyone know how to realize these two things? Any suggestion is appreciated.\n\nBest Regards,\nXiaobei",
          "url": "https://github.com/idaholab/moose/discussions/19445",
          "updatedAt": "2022-07-06T21:43:59Z",
          "publishedAt": "2021-11-21T10:55:44Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere s pretty good docs around smeared cracking models\nhttps://mooseframework.inl.gov/source/materials/ComputeSmearedCrackingStress.html#!\nand softening models dependent on the number of cracks\nhttps://mooseframework.inl.gov/source/materials/PowerLawSoftening.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19445#discussioncomment-1828464",
                  "updatedAt": "2022-07-06T21:44:56Z",
                  "publishedAt": "2021-12-16T21:45:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "creating a function that returns random value between min and max",
          "author": {
            "login": "vermaprk"
          },
          "bodyText": "Hi\nI am trying to make a function which returns a random value between min and max. But when i run these files it returns always '0'.\nI checked my input file with a parsedfunction but it works well in that case.\ncan somebody please help me find the bug in my code. (I am beginner in C++)\n <Codes>\n------------------------------------------------------------------------------------------------------------------------------------------------\n<Source FIle>\n------------------------------------------------------------------------------------------------------------------------------------------------\n\n#include \"RndConstantFunction.h\"\n#include \"MooseRandom.h\"\n\nregisterMooseObject(\"vsubraApp\", RndConstantFunction);\n\nInputParameters\nRndConstantFunction::validParams()\n{\n   InputParameters params = Function::validParams();\n   params.addClassDescription(\n     \"A function that returns random number between min and max\");\n     params.addParam<Real>(\"min\", 0.0, \"The constant value\");\n     params.addParam<Real>(\"max\", 1.0, \"The constant value\");\n     return params;\n }\n RndConstantFunction::RndConstantFunction(const InputParameters & parameters)\n   : Function(parameters),\n   _min(parameters.get<Real>(\"min\")),\n   _max(parameters.get<Real>(\"max\"))\n {\n }\n\nReal\n RndConstantFunction::value(const Point & p)\n {\n   // Random number between min and max\n   Real rand_num = MooseRandom::rand(0);\n\n   return rand_num * (_max - _min) + _min;\n }\n\n------------------------------------------------------------------------------------------------------------------------------------------------\n<Header FIle>\n------------------------------------------------------------------------------------------------------------------------------------------------\n\n#pragma once\n\n#include \"Function.h\"\n\nclass RndConstantFunction : public Function\n{\npublic:\n  static InputParameters validParams();\n\n  RndConstantFunction(const InputParameters & parameters);\n\n  virtual Real value(const Point & p);\n\nprotected:\n  const Real & _min;\n  const Real & _max;\n\n};\n---------------------------------------------------------------------------------------------------------------------------------------------------\n<input file>\n---------------------------------------------------------------------------------------------------------------------------------------------------\n\n[StochasticTools]\n[]\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n[]\n\n[Postprocessors]\n  [function_val]\n    type = FunctionValuePostprocessor\n    function = fun\n  []\n[]\n\n[Functions/fun]\n  type = RndConstantFunction\n  min  = '4'\n  max  = '10'\n[]\n\n[Controls/receiver]\n  type = SamplerReceiver\n[]",
          "url": "https://github.com/idaholab/moose/discussions/19595",
          "updatedAt": "2022-11-25T12:56:00Z",
          "publishedAt": "2021-12-10T07:11:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPlease use triple quotes to format code when posting on discussions.\nThe way you are setting _min and _max is odd. Maybe that was the old way\nCan you do this instead:\n_min(getParam<Real>(\"min\")),\nWhen you can MooseRandom::rand(0) you are asking for a particular state (index 0) for that random number generator.\nCan you use ::rand() instead?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19595#discussioncomment-1787345",
                  "updatedAt": "2023-06-23T15:14:52Z",
                  "publishedAt": "2021-12-10T18:11:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "I already tried with ::rand(). Still it is returning 0",
                          "url": "https://github.com/idaholab/moose/discussions/19595#discussioncomment-1787908",
                          "updatedAt": "2023-06-23T15:14:52Z",
                          "publishedAt": "2021-12-10T19:33:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "The 0 is an index to a map of RNG states, not a specific state per se (i.e. it should not always return the same value, but a separate independent stream of values than for example ::rand(1)).\nNote that this way of generating random numbers will not be parallel consistent and is generally discouraged.",
                          "url": "https://github.com/idaholab/moose/discussions/19595#discussioncomment-1788207",
                          "updatedAt": "2023-06-23T15:14:52Z",
                          "publishedAt": "2021-12-10T20:33:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "but in this case it is returning zero always irrespective of\n\n::rand()\n\n\n::rand(0)\n\n\nrand(1)",
                          "url": "https://github.com/idaholab/moose/discussions/19595#discussioncomment-1812040",
                          "updatedAt": "2023-06-23T15:14:54Z",
                          "publishedAt": "2021-12-15T11:24:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "rand() works fine for me. I just checked.\nare _min and _max set properly?\nIf you add\n_console << _min << \" \" << _max << \" \" << MooseRandom::rand() << std::endl;\nin your function what does it print?",
                          "url": "https://github.com/idaholab/moose/discussions/19595#discussioncomment-1828321",
                          "updatedAt": "2023-06-23T15:14:55Z",
                          "publishedAt": "2021-12-16T21:38:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Print the variable value",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "I am quite new to MOOSE and C++. So just wondering how can I  make sure the value given in input file is properly passed to the kernel file or material file.\nI mean is there any method to print the value or matrix in the kernel file?\nThanks in advance.",
          "url": "https://github.com/idaholab/moose/discussions/19642",
          "updatedAt": "2022-06-02T14:32:13Z",
          "publishedAt": "2021-12-15T17:15:10Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "Just for your own purposes of feeling comfortable that MOOSE is doing the right thing you can always add a quick std::cout << _my_param_value << std::endl; in computeQpResidual to make sure the value is coming through.  Obviously, this is not something you want to have in there for a long time (it will cause millions of print outs!) - but it will give you the confidence that you're doing things correctly in the beginning :-)\nYou can also see what MOOSE is reading from your input file by using --show-input on the command-line.  This will cause MOOSE to echo out what it thinks it read from your input file (and show you all of the default values for all parameters you didn't specify).",
                  "url": "https://github.com/idaholab/moose/discussions/19642#discussioncomment-1815271",
                  "updatedAt": "2022-06-02T14:32:37Z",
                  "publishedAt": "2021-12-15T18:01:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thanks.\nwhen I am using\n\n\n--show-input\n\n\nit says command not found.",
                          "url": "https://github.com/idaholab/moose/discussions/19642#discussioncomment-1815422",
                          "updatedAt": "2022-06-02T14:32:38Z",
                          "publishedAt": "2021-12-15T18:11:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "That is a command-line option for your executable... so do:\n./my_moose_program -i my_input  --show-input",
                          "url": "https://github.com/idaholab/moose/discussions/19642#discussioncomment-1815540",
                          "updatedAt": "2022-06-02T14:33:34Z",
                          "publishedAt": "2021-12-15T18:25:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thank you very much. It helps a lot.",
                          "url": "https://github.com/idaholab/moose/discussions/19642#discussioncomment-1827303",
                          "updatedAt": "2022-06-02T14:33:38Z",
                          "publishedAt": "2021-12-16T19:39:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "The .pvtu extension should be used when writing VTK files in libMesh",
          "author": {
            "login": "rcontinuum"
          },
          "bodyText": "Hello,\nI just want to share the following observation:\nIf I set in [Outputs] vtk = true [] and execute an input file in serial mode I get a group of vtk and vtu files like\ntest_out_000.vtk\ntest_out_001.vtk\ntest_out_000_0.vtu\ntest_out_001_0.vtu\n\nNow, if I open the groups of vtk-files in paraview then I get a paraview error \"A reader for \".../test_out_000.vtk\" could not be found\".\nI tried paraview versions 5.9.1 and 5.5.2 (from the paraview download page).\nIf I rename the *.vtk-files to *.pvtu-files then paraview loads the renamed files with no error.\nIn the case I run a moose app in parallel *.pvtu-files are written and the problem does not occur.\nThe moose app gives in serial mode a hint \"The .pvtu extension should be used when writing VTK files in libMesh.\"\nIn https://mooseframework.inl.gov/docs/doxygen/libmesh/vtk__io_8C_source.html   around line 256\none finds a comment that vtk-files would work too, but maybe that is not correct anymore.\nEdit: typo",
          "url": "https://github.com/idaholab/moose/discussions/19553",
          "updatedAt": "2022-06-17T03:36:19Z",
          "publishedAt": "2021-12-06T15:55:43Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI just tried on a sample input file with paraview 5.9.1 on mac and was able to open the .vtu file generated by MOOSE.\nI think you need to open the .vtu file with paraview, not the .vtk file.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1762639",
                  "updatedAt": "2022-06-17T03:36:22Z",
                  "publishedAt": "2021-12-07T05:10:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rcontinuum"
                          },
                          "bodyText": "Thank you for looking into this.\nYes, I can open the vtu-files too. But only single ones, i.e. one at a time. paraview (on linux) does not identify the vtu-files as a group.\nSee my screenshot\n\nIt could be due to the numbering of the vtu-files. Both end with _0, which may mean \"Piece\" number 0? Whereas the generated vtk-files have consecutive numbers at the end, _000.vtk and _001.vtk. The vtk-files are just files which basically \"point\" to the corresponding vtu-file (which contain the \"real\" simulation data).\nLike in test_out_000.vtk\n...\n<Piece Source=\"test_out_000_0.vtu\"/>\n...\n\n\nIf I do in a bash terminal:  mmv \"*.vtk\" \"#1.pvtu\"  (rename all *.vtk to *.pvtu; multiple move) then these renamed files get identified as a pvtu-group too and can be opened as a group of files with no error message. And I can play the fields as a \"movie/animation\". Basically I assume, paraview \"runs\" through the group of pvtu-files and loads the corresponding \"real\" simulation data from the corresponding vtu-files.\nDo you see the same behavior on Mac?\nI mean, if yes it should be a simple modification in the source code. Basically, always write files with pvtu-ending (in serial and parallel) \"pointing\" to the vtu-files which contains the \"real\" data. Just use always the ending .pvtu instead of .vtk (in searial mode).\nRalf\nPS: Sure, I can always perform a mmv \"*.vtk\" \"#1.pvtu\"after the run. So, it's nothing essential.",
                          "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1763414",
                          "updatedAt": "2022-06-17T03:36:23Z",
                          "publishedAt": "2021-12-07T08:42:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Paraview will let you load more files from the GUI I think.\nI dont know why we have the _0, suffix on the .vtu. I think it makes sense for the .pvtu.\n@roystgnr any ideas on this?",
                          "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1766136",
                          "updatedAt": "2022-06-17T03:36:28Z",
                          "publishedAt": "2021-12-07T15:43:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Looks like we're writing out pvtu format even in serial right now (or at least we're handing an MPI communicator to VTK and that's what it's deciding to do in that case), with a comment in the libMesh source saying this is fine since Paraview understands that special case.  So you ask VTKIO to write \"foo.pvtu\", and it writes the header data to that, and then it writes a \"foo_#.vtu\" file for each processor rank #.  The catch is that, if you ask for an extension other than pvtu, we yell at you but then we do as you say, and Paraview etc. don't understand that.  So unless we want to add special-case code to an already undermaintained code path, the fix might be to just have Moose VTKOutput.C always ask for a .pvtu extension?\nBut I must still not be understanding this, because: how is this a problem cropping up now?  The patch enabling parallel writes and warning about non-pvtu extensions went into libMesh nearly 9 years ago, and it looks like John was editing the Moose output to match years later than that.",
                          "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1768497",
                          "updatedAt": "2022-06-24T01:04:47Z",
                          "publishedAt": "2021-12-07T20:00:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "people were probably loading up the vtu instead of the vtk file.\nSo sounds like we just need to write pvtu instead of vtk to be good here",
                          "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1769642",
                          "updatedAt": "2022-06-24T01:25:09Z",
                          "publishedAt": "2021-12-08T01:00:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rcontinuum"
                          },
                          "bodyText": "Background: I was playing around with vtk = true and thought the MOOSE VTK-output files are not fully behaving like I would expect in serial mode. But in parallel mode it behave like I expected (from a user point of view using paraview). I (intent to) use vtk-files for development/debugging, typically meshes with one or a few elements, as they are in ASCII. And an exodus-file needs ncdump to make them readable for a human.\nI just wanted to report my observation. I mean, it's no a big deal for me, I can always rename with mmv.\n\nthe fix might be to just have Moose VTKOutput.C always ask for a .pvtu extension?\n\nThat was at least my first thought and even if I'm not familiar with your code I thought that should by like modifying \"one\" line of code (which is a \"dangerous\" assumption from my side). I don't know the precise VTK definition of \"parallel\" files, but in principle they should work for \"n=1\", i.e. serial, too.\n\nhow is this a problem cropping up now?\n\nI started with looking into MOOSE recently, so I cannot tell you.\nMaybe paraview (or VTK-lib) a few years ago was not that \"picky\" concerning *.vtk and *.pvtu extensions and their content. But this is a speculation from my side.",
                          "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1772259",
                          "updatedAt": "2022-06-24T01:25:16Z",
                          "publishedAt": "2021-12-08T12:20:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "rcontinuum"
                  },
                  "bodyText": "Shall I open an issue on this topic?",
                  "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1811213",
                  "updatedAt": "2022-06-24T01:04:48Z",
                  "publishedAt": "2021-12-15T08:32:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Sure but its a libmesh issue i think",
                          "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1813201",
                          "updatedAt": "2022-06-24T01:04:48Z",
                          "publishedAt": "2021-12-15T14:33:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Please make sure to document the workaround there btw",
                          "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1813208",
                          "updatedAt": "2022-06-24T01:04:49Z",
                          "publishedAt": "2021-12-15T14:33:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "It's a Moose issue, and at least in theory it was noted in #19581 and fixed by #19582 last week.  Looks like Github doesn't automatically generate backlinks to referenced discussions the way it does to issues and PRs?  That's annoying.  Sorry, I'd have mentioned it here manually if I'd known that was necessary.",
                          "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1817197",
                          "updatedAt": "2022-06-24T01:04:52Z",
                          "publishedAt": "2021-12-15T21:17:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rcontinuum"
                          },
                          "bodyText": "Thank you for fixing this so fast!",
                          "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1821319",
                          "updatedAt": "2022-06-24T01:26:29Z",
                          "publishedAt": "2021-12-16T07:45:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rcontinuum"
                          },
                          "bodyText": "Sorry, I'd have mentioned it here manually if I'd known that was necessary.\n\nWell, at least now I see in the right most column of this page after scrolling up \"Events\".",
                          "url": "https://github.com/idaholab/moose/discussions/19553#discussioncomment-1821379",
                          "updatedAt": "2022-06-24T01:26:29Z",
                          "publishedAt": "2021-12-16T07:55:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Finite Volume \"Interior\" Boundary Condition",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "Is there an \"interior\" boundary condition in Moose? I am trying to simulate flow through a 2D channel. In the middle of the channel, there is a side set. I want Moose to run for some time with the side set not as a boundary condition, and then at some point, I will turn it into a wall or some other boundary condition. I am getting the error that \"The INSFVMomentumAdvection object mass is not completely bounded by INSFVBCs\" if I don't include any boundary condition for that specific side set. The side set completely blocks the channel when it is turned on.",
          "url": "https://github.com/idaholab/moose/discussions/19636",
          "updatedAt": "2022-10-14T12:36:40Z",
          "publishedAt": "2021-12-15T13:07:53Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can have an interior sideset but we currently dont allow interior boundary conditions in finite volume. It's not something that cant be done it's just that most of the time that will be an error in the input rather than something desirable.\nThere's multiple options for doing what you want to do.\n\nrestart the simulation at the point where you want to block the channel, loading up the previous velocity and pressure fields, with the mesh as you intend with a blockage\nhave a volumetric blockage instead of a sideset. If you set a very high friction coefficient you should be able to essentially cut the flow. Note that if the flow has nowhere else to go it ll still go through, but with a very high pressure drop\ncreate an interface kernel that will penalize (with a lagrange multiplier) flow going through that sideset. Just a constraint on v_normal should do.\n\nWorking with a boundary condition \"that turns on\" at some point seems difficult. The advection kernel examines at the beginning of the simulation all boundaries and determines which one it would execute on and with which behavior for Rhie Chow interpolation. This one would first be a normal region then become a wall, so the RC interpolation differs between those two cases.\n@lindsayad might have a different opinion\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19636#discussioncomment-1813501",
                  "updatedAt": "2022-07-15T14:22:24Z",
                  "publishedAt": "2021-12-15T15:06:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Yea I think the easiest thing at this point would be to do the restart option that @GiudGiud recommended. After #18563 things would get a little simpler for this, but we still need to know what the flow boundaries are so that we can implicitly run advection kernels on outflow boundaries. Maybe in the future we can make that a Controllable parameter but that's not in the cards at the moment.",
                          "url": "https://github.com/idaholab/moose/discussions/19636#discussioncomment-1817261",
                          "updatedAt": "2022-07-15T14:22:24Z",
                          "publishedAt": "2021-12-15T21:22:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error using MaterialRealVectorValueAux",
          "author": {
            "login": "crb3874"
          },
          "bodyText": "At a bit of a loss with this -\nI have a custom Material class InterpolatedMGXSMaterial which produces material property values using interpolation tables read in from a csv file. I'm getting incorrect results from simulations using it, when compared with identical simulations with directly provided material properties. The only difference between these simulations is how the material properties are being calculated, so I'm trying to debug my InterpolatedMGXSMaterial using MaterialRealVectorValueAux.\n**The issue: When using MaterialRealVectorValueAux, I get the error \"Material has no property named: diffusivity\" **\nMy material properties are declared in InterpolatedMGXSMaterial.h as\nMaterialProperty<RealEigenVector> & _diffusivity;\n\nand in InterpolatedMGXSMaterial.C I have\nInterpolatedMGXSMaterial::InterpolatedMGXSMaterial(const InputParameters & parameters), \n... , \n_diffusivity(declareProperty<RealEigenVector>(\"diffusivity\")),\n ... {...}\n\nFor debugging, I'm attempting to fill an AuxVariable with the element-wise values of diffusivity at the zeroth index.\nWithin my input file, I have\n[AuxVariables]\n...\n  [diff_fast]\n    family = MONOMIAL\n    order = CONSTANT\n  []\n...\n[]\n[AuxKernels]\n...\n  [copy_diff]\n    type = MaterialRealVectorValueAux\n    property = diffusivity\n    variable = diff_fast\n    component = 0\n    execute_on = final\n  []\n...\n[]\n\nWhen I run the simulation with these extra options, I get the error \"Material has no property named: diffusivity\". The strange thing is that I'm using custom Kernels as well for my simulation the directly reference the material property as \"diffusivity\" with no issue.\nThis seems like something with a really simple fix, but as far as I can tell I've properly defined the material property, so I'm not sure what the issue is. Any thoughts?\nThanks,\nColin",
          "url": "https://github.com/idaholab/moose/discussions/19638",
          "updatedAt": "2022-08-24T12:03:53Z",
          "publishedAt": "2021-12-15T13:38:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "MaterialRealVectorValueAux is for vector materials. You need one for array materials. I can write one up real quick.",
                  "url": "https://github.com/idaholab/moose/discussions/19638#discussioncomment-1813308",
                  "updatedAt": "2022-08-24T12:04:00Z",
                  "publishedAt": "2021-12-15T14:44:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "crb3874"
                          },
                          "bodyText": "Thank you for the reply, Logan. It seems obvious now that you've said it. I may be able to write up a MaterialRealArrayValueAux on my own - I'll follow up with whether that fixes the issue.",
                          "url": "https://github.com/idaholab/moose/discussions/19638#discussioncomment-1813629",
                          "updatedAt": "2022-08-24T12:04:14Z",
                          "publishedAt": "2021-12-15T15:15:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "crb3874"
                          },
                          "bodyText": "This seems to have fixed my issue - I wrote up a quick MaterialRealArrayValueAux and I seem to be able to copy my material properties to an AuxVariable. Thanks for the help!",
                          "url": "https://github.com/idaholab/moose/discussions/19638#discussioncomment-1814223",
                          "updatedAt": "2022-08-24T12:04:14Z",
                          "publishedAt": "2021-12-15T15:56:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nWould you mind making a PR to the framework to add this?\nThis involves adding a test and a basic documentation page if you havent done this before\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/19638#discussioncomment-1814244",
                          "updatedAt": "2022-08-24T12:04:15Z",
                          "publishedAt": "2021-12-15T15:58:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "This ended up being a little more complicated than expected - I'm almost done with it. Refs #19639",
                          "url": "https://github.com/idaholab/moose/discussions/19638#discussioncomment-1814258",
                          "updatedAt": "2022-08-24T12:04:29Z",
                          "publishedAt": "2021-12-15T16:01:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "crb3874"
                          },
                          "bodyText": "One issue that came up is that attempting to check for the provided index being out of bounds for the array material property (from this->_prop[this->_qp].size()) in the constructor results in a segfault, but doing the same error checking in getRealValue() works fine. Is this because the call hierarchy in MOOSE sets up the AuxKernels before Materials, so the MaterialProperty isn't initialized until after the constructor is called for MaterialRealArrayValueAux?",
                          "url": "https://github.com/idaholab/moose/discussions/19638#discussioncomment-1814280",
                          "updatedAt": "2022-08-24T12:04:29Z",
                          "publishedAt": "2021-12-15T16:04:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "Take a look at #19640. This adds MaterialRealEigenVectorAux (for a single value to a regular aux variable) and VectorMaterialRealEigenVectorAux (for all values to an array aux variable)\nSpecifically, https://github.com/idaholab/moose/blob/e5cdca1326fe035686bd96a09b4c3fc63bbd146e/framework/src/auxkernels/MaterialRealEigenVectorAux.C. You can't check upon construction because you're right, the materials aren't initialized yet. The check has to be done when getting the value.",
                          "url": "https://github.com/idaholab/moose/discussions/19638#discussioncomment-1814458",
                          "updatedAt": "2022-08-24T12:04:29Z",
                          "publishedAt": "2021-12-15T16:25:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "crb3874"
                          },
                          "bodyText": "Makes sense. Thank you for adding this functionality!",
                          "url": "https://github.com/idaholab/moose/discussions/19638#discussioncomment-1814506",
                          "updatedAt": "2022-08-24T12:05:00Z",
                          "publishedAt": "2021-12-15T16:33:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ADKernelValue class and ADKernelGrad class",
          "author": {
            "login": "rtaylo45"
          },
          "bodyText": "Hello,\nI have a situation where i am applying a SUPG stabilization method to a kernel in my moose app. I have my normal kernel class which returns an ADReal for its precomputeQpResidual function. The header file is shown below:\n#pragma once\n\n#include \"ADKernelValue.h\"\n#include \"Function.h\"\n\n/**\n * This class implements the kernel for the gas species part for liquid-gas\n * mass transfer.\n */\nclass LiquidGasMassTransfer : public ADKernelValue\n{\npublic:\n\tstatic InputParameters validParams();\n\tLiquidGasMassTransfer(const InputParameters & parameters);\n\tvirtual ~LiquidGasMassTransfer();\n\nprotected:\n\t// residual for the mass transfer coefficient term\n\tvirtual ADReal precomputeQpResidual() override;\n\n\t// Molar mass of gas species\n\tconst Real _gas_molar_mass;\n\t// Henry's Law Coefficient [kg/Pa/m^3]\n\tconst Function & _henrys_coefficient;\n\t// Interfacial area concentration 1/m\n\tconst ADVariableValue & _interfacial_area_concentration;\n\t// Mass transfer coefficient 1/s\n\tconst Function & _mass_transfer_coefficient;\n\t// Pressure Pa\n\tconst ADVariableValue & _pressure;\n\t// Gas volume fraction\n\tconst ADVariableValue & _gas_volume_fraction;\n\t// Liquid species variable\n\tconst ADVariableValue & _liquid_species;\n\t// Gas species variable\n\tconst ADVariableValue & _gas_species;\n\t// List of all gas species variables\n\tstd::vector<const ADVariableValue *> _gas_species_list;\n\t// List of all gas species molar masses\n\tconst std::vector<Real> _gas_species_molar_mass_list;\n\nprivate:\n\t// Liquid species variable name\n\tVariableName _liquid_species_name;\n\t// Gas species variable name\n\tVariableName _gas_species_name;\n\t// Computes the mole fraction of the gas species\n\tADReal computeGasMoleFraction();\n\n};\n\n\nThe SUPG version looks the exact same but the precomputeQpResidual version returns an ADRealVectorValue. This header file is shown below:\n#pragma once\n\n#include \"ADKernelGrad.h\"\n\n/**\n * This class applied the SUPG stabilization to the liquid gass mass transfer\n * kernel\n */\nclass LiquidGasMassTransferSUPG : public ADKernelGrad\n{\npublic:\n\tstatic InputParameters validParams();\n\tLiquidGasMassTransferSUPG(const InputParameters & parameters);\n\tvirtual ~LiquidGasMassTransferSUPG();\n\nprotected:\n\tvirtual ADRealVectorValue precomputeQpResidual();\n\n\t// Velocity vector variable m/s\n\tconst ADVectorVariableValue & _velocity;\n\t// Molar mass of gas species\n\tconst Real _gas_molar_mass;\n\t// Henry's Law Coefficient [kg/Pa/m^3]\n\tconst Function & _henrys_coefficient;\n\t// Interfacial area concentration 1/m\n\tconst ADVariableValue & _interfacial_area_concentration;\n\t// Mass transfer coefficient 1/s\n\tconst Function & _mass_transfer_coefficient;\n\t// Pressure Pa\n\tconst ADVariableValue & _pressure;\n\t// Gas volume fraction\n\tconst ADVariableValue & _gas_volume_fraction;\n\t// Liquid species variable\n\tconst ADVariableValue & _liquid_species;\n\t// Gas species variable\n\tconst ADVariableValue & _gas_species;\n\t// List of all gas species variables\n\tstd::vector<const ADVariableValue *> _gas_species_list;\n\t// List of all gas species molar masses\n\tconst std::vector<Real> _gas_species_molar_mass_list;\n\nprivate:\n\t// Liquid species variable name\n\tVariableName _liquid_species_name;\n\t// Gas species variable name\n\tVariableName _gas_species_name;\n\t// Computes the mole fraction of the gas species\n\tADReal computeGasMoleFraction();\n\n};\n\nAs you can see the class definitions are nearly identical, except for the velocity variable that needs to be passed. My question is, how can/should i design this class structure so that i don't have redundant code? Should i write a base class for this with the kernel system? If so, what is the base class? Or is there no way around this?\nthanks,\nZack",
          "url": "https://github.com/idaholab/moose/discussions/19632",
          "updatedAt": "2022-06-06T07:31:15Z",
          "publishedAt": "2021-12-15T04:03:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI would template this based on either:\n\nthe return type (so ADReal and ADRealVectorValue) and have some template logic to inherit the right class\nthe base class (ADkernelGrad or ADKernelValue) and define the return type inside the class definition\n\nThen every function can pretty much be written the same. There should be some existing templating of operations (+, *, outer_product). Some might be missing and you ll have to define them locally.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19632#discussioncomment-1813199",
                  "updatedAt": "2022-06-06T07:31:43Z",
                  "publishedAt": "2021-12-15T14:32:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rtaylo45"
                          },
                          "bodyText": "The way i got around this was super simple, i feel dumb that i didn't do this before. I just inherit from ADKernel, use logic to add SUPG stabilization if the user ask for it.",
                          "url": "https://github.com/idaholab/moose/discussions/19632#discussioncomment-1814200",
                          "updatedAt": "2022-06-06T07:31:49Z",
                          "publishedAt": "2021-12-15T15:53:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Geometric stiffness (Jacobian) for Pressure BC",
          "author": {
            "login": "matthiasneuner"
          },
          "bodyText": "Hi, it seems to me that for the Pressure BC in the TensorMechanics module the Jacobian wrt the displacement variables is missing, despite the fact that this BC acts on the deformed mesh.\nI am simulating materials with very large deformations, and accordingly, this Jacobian is essential for me.\nA quick&dirty implementation by implementing the derivative of the boundary _normals wrt the displacement variables in computeQpJacobian() in Pressure got me the desired behavior.\nNow for cleaning up that workaround and pushing that to the MOOSE main repo, I was wondering if Pressure is actually the right place to implement the derivative of the _normals wrt the displacement vector, or if this should be performed at some higher level, since essentially all types of follower loads may use that for computing the exact Jacobian.\nIf so, what would be the ideal place to compute that derivative?",
          "url": "https://github.com/idaholab/moose/discussions/19566",
          "updatedAt": "2022-06-16T19:07:30Z",
          "publishedAt": "2021-12-07T05:07:23Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@matthiasneuner You are correct that the Jacobian in Pressure BC is not exact. normal and area changes with respect to displacements are not considered. Have you checked your hand-coded Jacobian against finite difference approximation? Are they exact?\nLet me tag @jasondhales since he recently worked on it. He might give you some suggestion on where the derivatives calculation should go.",
                  "url": "https://github.com/idaholab/moose/discussions/19566#discussioncomment-1762698",
                  "updatedAt": "2022-06-16T19:07:44Z",
                  "publishedAt": "2021-12-07T05:30:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "matthiasneuner"
                          },
                          "bodyText": "My Jacobian is exact yes. You can find my implementation in my app (https://github.com/matthiasneuner/chamois/blob/master/src/bcs/FiniteStrainPressure.C), making use of an auxiliary material (https://github.com/matthiasneuner/chamois/blob/master/src/materials/ComputeDeformedBoundaryNormalVector.C).\nSince I use Fastor for tensor contractions instead of MOOSE tensors, this implementation is not yetcompatible with the main repo. Maybe I can rewrite that using MOOSE tensors during the holidays, and create a PR.",
                          "url": "https://github.com/idaholab/moose/discussions/19566#discussioncomment-1786989",
                          "updatedAt": "2022-06-16T19:07:46Z",
                          "publishedAt": "2021-12-10T17:11:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "I took a quick look at your implementation of pressure BC. You set use_displaced_mesh = false which means the pressure term is integrated over the undeformed configuration. Shouldn't we account for the area change due to deformation?",
                          "url": "https://github.com/idaholab/moose/discussions/19566#discussioncomment-1795930",
                          "updatedAt": "2022-06-16T19:07:46Z",
                          "publishedAt": "2021-12-13T05:26:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "matthiasneuner"
                          },
                          "bodyText": "You are right; This is actually happening; Nanson's formula is applied in ComputeDeformedBoundaryNormalVector (https://github.com/matthiasneuner/chamois/blob/6066b7dfc4d9456dd971f2a91b470899fe98fe78/src/materials/ComputeDeformedBoundaryNormalVector.C#L79), but I just recognized that the name is misleading since the vector is not a normalized vector anymore. I will improve that.",
                          "url": "https://github.com/idaholab/moose/discussions/19566#discussioncomment-1796274",
                          "updatedAt": "2022-06-16T19:07:49Z",
                          "publishedAt": "2021-12-13T07:24:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think this ought to be handled in \"Assembly\". For example, now in ADIntegratedBC we have\n_normals(_assembly.adNormals()),\nand in IntegratedBC we have\n_normals(_assembly.normals()),\nI think we should add a method to compute the derivative of normal w.r.t to displacements in assembly, and manually request it when needed (for example in the case of pressure BC):\n_d_normals_d_displacements(_assembly.dNormalsDDisplacements()),\nIn the case of AD, these derivatives should come from AD libMesh.\n@lindsayad is this a use case of AD libMesh?",
                          "url": "https://github.com/idaholab/moose/discussions/19566#discussioncomment-1804554",
                          "updatedAt": "2022-07-30T03:12:14Z",
                          "publishedAt": "2021-12-14T11:36:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "You mean the AD libmesh that doesn't exist? \ud83d\ude04 Yes as @hugary1995 pointed out we do currently have \"manual\" code in Assembly that reproduces mapping calculations from libMesh with displacement information included in order to create an adNormals() that has the correct derivatives with respect to displacements. Someday when we do have AD libMesh, then we can remove that near-duplicate code in Assembly\nBut as far as creating derivatives with respect to displacements for our manual Jacobian objects, I will leave that to you all \ud83d\ude04",
                          "url": "https://github.com/idaholab/moose/discussions/19566#discussioncomment-1807234",
                          "updatedAt": "2022-07-30T03:12:28Z",
                          "publishedAt": "2021-12-14T17:37:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jasondhales"
                  },
                  "bodyText": "My take is that the derivative code ought to go into Pressure.C.  Getting the derivative of the normal would be a good contribution.",
                  "url": "https://github.com/idaholab/moose/discussions/19566#discussioncomment-1768654",
                  "updatedAt": "2022-06-16T19:08:01Z",
                  "publishedAt": "2021-12-07T20:30:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Transient Simulation with Peridynamics Module",
          "author": {
            "login": "ppandit95"
          },
          "bodyText": "Dear MOOSE Community,\nI wish to run a transient simulation using peridynamics module wherein density needs to be provided to create the mass matrix but I couldn't find any test for that and the simulations carried out are quasi static in nature with varying BCs with time.So in this context I wish to know whether it is possible as of now to run the transient simulations with Peridynamics Module .\nMany Thanks\nPushkar",
          "url": "https://github.com/idaholab/moose/discussions/19608",
          "updatedAt": "2022-07-14T21:04:15Z",
          "publishedAt": "2021-12-12T04:26:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Hi @ppandit95, I was having the same problem as well, I don't think MOOSE does have a true quasi-static (reached the steady-state and move on to the next step)\nSo I follow this 'Load step' method: https://mooseframework.inl.gov/source/executioners/Transient.html\nthen pre-define all the BCs, and use [Controls] to activate each BC at each particular time-step (arbitrary)\n... BCs block ...\n     [./stope1]\n       type = PorousFlowPiecewiseLinearSinkTC\n     variable = porepressure\n     boundary = 'stope1'\n     pt_vals = '0 1e9' # x coordinates defining g\n     multipliers = '0 1e9' # y coordinates defining g\n     flux_function =  1e5 #1e5 # Variable C\n     v = min\n     use_mobility = true\n     fluid_phase = 0\n     save_in = flux\n     use_relperm = true\n     [../]\n\n     [./stope2]\n       type = PorousFlowPiecewiseLinearSinkTC\n     variable = porepressure\n     boundary = 'stope2'\n     pt_vals = '0 1e9' # x coordinates defining g\n     multipliers = '0 1e9' # y coordinates defining g\n     flux_function =  1e5 #1e5 # Variable C\n     v = min\n     use_mobility = true\n     fluid_phase = 0\n     use_relperm = true\n     save_in = flux\n     [../]\n\n\n\n...Controls block...\n  [stope1_control]\n    type = ConditionalFunctionEnableControl\n    enable_objects = 'BCs::stope1'\n    conditional_function = 'if(t>=2 ,1,0)'\n    execute_on = 'initial timestep_begin'\n  []\n\n  [stope2_control]\n    type = ConditionalFunctionEnableControl\n    enable_objects = 'BCs::stope2'\n    conditional_function = 'if(t>=3  ,1,0)'\n    execute_on = 'initial timestep_begin'\n  []\n\n[]\n\n\n@GiudGiud I still would like to have a multi-steps steady-state solver (true quasi-SS), not sure if you can suggest it to the MOOSE team?",
                  "url": "https://github.com/idaholab/moose/discussions/19608#discussioncomment-1795032",
                  "updatedAt": "2022-07-14T21:04:33Z",
                  "publishedAt": "2021-12-12T23:25:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ppandit95"
                          },
                          "bodyText": "ohh,thats great I have been using time varying BCs but this also seems a alternative way to solve the problem,thanks @Traiwit",
                          "url": "https://github.com/idaholab/moose/discussions/19608#discussioncomment-1795680",
                          "updatedAt": "2022-07-14T21:04:37Z",
                          "publishedAt": "2021-12-13T03:54:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So you're talking about nested relaxation transient solves inside a global transient?\nOr nested direct steady solves inside a global transient?",
                          "url": "https://github.com/idaholab/moose/discussions/19608#discussioncomment-1798842",
                          "updatedAt": "2022-07-14T21:04:36Z",
                          "publishedAt": "2021-12-13T15:03:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Either way, I think our rework of the Executioner system (currently ongoing) will help us nest solves like this.\nWe ll keep you posted",
                          "url": "https://github.com/idaholab/moose/discussions/19608#discussioncomment-1798846",
                          "updatedAt": "2022-07-14T21:04:37Z",
                          "publishedAt": "2021-12-13T15:04:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@GiudGiud more like the 2nd case, but yes awesome, thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/19608#discussioncomment-1801946",
                          "updatedAt": "2022-09-24T06:50:15Z",
                          "publishedAt": "2021-12-13T23:06:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Adding the InertialForce kernel is equivalent to creating the mass matrix you are talking about. In the Executioner, you can specify\n[TimeIntegrator]\n  type = NewmarkBeta\n[]\nto use the Newmark-beta time integrator. Generalized-alpha methods are also available if you search the regression tests.",
                  "url": "https://github.com/idaholab/moose/discussions/19608#discussioncomment-1804459",
                  "updatedAt": "2022-07-14T21:04:40Z",
                  "publishedAt": "2021-12-14T11:18:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ppandit95"
                          },
                          "bodyText": "Thanks @hugary1995 for elaborating on the implementation of mass matrix and the relevant executioner.I will look into it...",
                          "url": "https://github.com/idaholab/moose/discussions/19608#discussioncomment-1805477",
                          "updatedAt": "2022-07-14T21:04:40Z",
                          "publishedAt": "2021-12-14T14:00:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}