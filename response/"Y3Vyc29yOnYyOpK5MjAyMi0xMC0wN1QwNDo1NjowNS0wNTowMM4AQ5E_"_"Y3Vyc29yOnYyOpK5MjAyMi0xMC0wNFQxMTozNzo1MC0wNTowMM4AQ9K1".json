{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMC0wNFQxMTozNzo1MC0wNTowMM4AQ9K1"
    },
    "edges": [
      {
        "node": {
          "title": "error in installing Libmesh On HPC",
          "author": {
            "login": "gmaurya20"
          },
          "bodyText": "I have successfully installed PETSc using the offline installation method, but I am getting errors in the LIBMESH installation. The error is attached in the .txt file. please help me to solve this.\ntext.txt",
          "url": "https://github.com/idaholab/moose/discussions/22289",
          "updatedAt": "2022-10-07T08:26:18Z",
          "publishedAt": "2022-10-04T08:52:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "gmaurya20"
                  },
                  "bodyText": "To install PETSc, I have used :\npython3.7.9\nGCC-8.1.0\nMpich-4.0.2\ncmake-3.23.1\nMake-4.3",
                  "url": "https://github.com/idaholab/moose/discussions/22289#discussioncomment-3794219",
                  "updatedAt": "2022-10-04T09:00:28Z",
                  "publishedAt": "2022-10-04T09:00:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "While I haven't read all the way through the text.txt attachment yet, I see you ran ./update_and_rebuild_libmesh.sh. When running this script, it produces a libmesh_diagnostic.log file in the same location. Can you post that log as well? Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/22289#discussioncomment-3795708",
                          "updatedAt": "2022-10-04T12:42:04Z",
                          "publishedAt": "2022-10-04T12:42:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gmaurya20"
                          },
                          "bodyText": "libmesh_diagnostic.log file\nlibmesh_diagnostic.log",
                          "url": "https://github.com/idaholab/moose/discussions/22289#discussioncomment-3795926",
                          "updatedAt": "2022-10-04T13:15:06Z",
                          "publishedAt": "2022-10-04T13:15:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "I see something strange in the fact that the build immediately tried to use something outside of your name space:\n/usr/bin/grep: /home/jsoni/GCC-8.1.0/lib/../lib64/libatomic.la: Permission denied\n/usr/bin/sed: can't read /home/jsoni/GCC-8.1.0/lib/../lib64/libatomic.la: Permission denied\nlibtool:   error: '/home/jsoni/GCC-8.1.0/lib/../lib64/libatomic.la' is not a valid libtool archive\nmake[2]: *** [Makefile:744: libdbg.la] Error 1\nThere is a reference to jsoni's home. Did this person perhaps give you their finished build of GCC? If so, I'm afraid it doesn't work this way for compilers. But I am also curious as to how PETSc was able to build and libMesh.\nEdit: how PETSc was able to build and not libMesh.",
                  "url": "https://github.com/idaholab/moose/discussions/22289#discussioncomment-3795780",
                  "updatedAt": "2022-10-04T13:59:32Z",
                  "publishedAt": "2022-10-04T12:53:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "gmaurya20"
                          },
                          "bodyText": "configure and make log file for PETSc\nmake.log.txt\nconfigure.log.txt",
                          "url": "https://github.com/idaholab/moose/discussions/22289#discussioncomment-3796044",
                          "updatedAt": "2022-10-04T13:30:10Z",
                          "publishedAt": "2022-10-04T13:30:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@gmaurya20 did you install the whole stack of compilers yourself?",
                          "url": "https://github.com/idaholab/moose/discussions/22289#discussioncomment-3798063",
                          "updatedAt": "2022-10-04T17:13:50Z",
                          "publishedAt": "2022-10-04T17:13:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gmaurya20"
                          },
                          "bodyText": "yes. I installed.",
                          "url": "https://github.com/idaholab/moose/discussions/22289#discussioncomment-3798209",
                          "updatedAt": "2022-10-04T17:31:49Z",
                          "publishedAt": "2022-10-04T17:31:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I don't think anyone here is going to know how to prevent the compiler from accessing this location:\n/home/jsoni\n\nThis is a hard coded home directory path that no one but jsoni has access to. Your environment variables are clean. I know of no way to change GCC's behavior to not do this. I think you will need to rebuild GCC over again (and everything else you built with this compiler).",
                          "url": "https://github.com/idaholab/moose/discussions/22289#discussioncomment-3798681",
                          "updatedAt": "2022-10-04T18:29:12Z",
                          "publishedAt": "2022-10-04T18:29:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gmaurya20"
                          },
                          "bodyText": "Ok,\nI am installing GCC and MPICH again.",
                          "url": "https://github.com/idaholab/moose/discussions/22289#discussioncomment-3798707",
                          "updatedAt": "2022-10-04T18:33:13Z",
                          "publishedAt": "2022-10-04T18:33:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "libatomic is not something we ever ask for explicitly, it's an internal library of GCC ... though it looks like it should be linked implicitly any time C11 or C++11 or higher standards are requested, which should be the default for gcc and g++ 8.1, so if you're using a hand-built gcc binary without having access to all its install directories then you could see an error like this.  It's also possible to have it linked implicitly because some dependency libtool file asked for it ... contrib/gzstream gives -lz to the linker, so if there's a libz.la somewhere around that is pointing to /some/wrong/directory/libatomic.la then that could also result in an error like this.\nIt's interesting that the failure only happens when trying to link a libtool library for gzstream, after there's already been a successful link of one for gmv.  Could be that the C compiler is working but the C++ compiler isn't - that would explain why gmv (which is pure C) and PETSc (which has C++ options but IIRC the C++ is usually turned off) could link when gzstream (which is pure C++) couldn't.\nSpeculations aside, no software hardcodes /home/jsoni anywhere.  There's got to be a hand-built gcc or a hand-built libz or something of that sort pointing to it.",
                  "url": "https://github.com/idaholab/moose/discussions/22289#discussioncomment-3796459",
                  "updatedAt": "2022-10-04T14:12:16Z",
                  "publishedAt": "2022-10-04T14:12:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "gmaurya20"
                          },
                          "bodyText": "Thank you all,\nInstalling GCC and MPICH again---- It worked.",
                          "url": "https://github.com/idaholab/moose/discussions/22289#discussioncomment-3820828",
                          "updatedAt": "2022-10-07T08:25:52Z",
                          "publishedAt": "2022-10-07T08:25:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Errors with three subdomains mesh with interface transfer",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hi all,\nI am trying to have three subdomains for a simple BVP. My two-domain works just fine, but I have errors with three subdomains.\nMy input file and error message are attached.\nThanks\nKindly help.",
          "url": "https://github.com/idaholab/moose/discussions/22323",
          "updatedAt": "2022-10-06T22:07:05Z",
          "publishedAt": "2022-10-06T21:31:26Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou made a tree of mesh generators that has multiple outputs.\nTry chaining all the mesh generators, making each MG the input = of the one below it\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22323#discussioncomment-3818088",
                  "updatedAt": "2022-10-06T21:43:53Z",
                  "publishedAt": "2022-10-06T21:43:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "Wow!\nThat worked..\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/22323#discussioncomment-3818176",
                          "updatedAt": "2022-10-06T22:07:06Z",
                          "publishedAt": "2022-10-06T22:07:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Better Initial Guess for Newton Solve",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "I looked at the predictor system and I see that for implicit solves it can give a better initial guess for the first Newton Iteration. Say I know that for a specific dof, there is a better initial guess. Is there a way for me to supply that dof that guess but keep the rest the same?",
          "url": "https://github.com/idaholab/moose/discussions/22319",
          "updatedAt": "2022-10-06T20:09:17Z",
          "publishedAt": "2022-10-06T11:48:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "We don\u2019t usually modify initial guesses of each time step solves, except the first one, because the initial guess is the solution from the previous step. and the time derivative term will also depend on it. So if you modify the \u201cinitial guess\u201d you modify the solution of the transient\nYou ll have to write a custom user object to do that.\nSee below for custom predictor",
                  "url": "https://github.com/idaholab/moose/discussions/22319#discussioncomment-3814408",
                  "updatedAt": "2022-10-06T13:58:04Z",
                  "publishedAt": "2022-10-06T13:14:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "When using the predictor block for an implicit solve, I thought that it didn't change the final solution just the first guess? I am bascially trying to implement that but with a single dof. Would that still modify the final solution?",
                          "url": "https://github.com/idaholab/moose/discussions/22319#discussioncomment-3814463",
                          "updatedAt": "2022-10-06T13:18:50Z",
                          "publishedAt": "2022-10-06T13:18:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It must be doing something else to get the time derivative right.\nI m familiar with using a predictor in a predictor corrector scheme, not on its own.",
                          "url": "https://github.com/idaholab/moose/discussions/22319#discussioncomment-3814619",
                          "updatedAt": "2022-10-06T13:38:09Z",
                          "publishedAt": "2022-10-06T13:38:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "So if you modify the \u201cinitial guess\u201d you modify the solution of the transient\n\nThe predictor modifies the current solution, not the _solution_old. So you don't need to do anything special to get the time derivative right.",
                          "url": "https://github.com/idaholab/moose/discussions/22319#discussioncomment-3814659",
                          "updatedAt": "2022-10-06T13:41:05Z",
                          "publishedAt": "2022-10-06T13:41:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@maxnezdyur, you can derive from SimplePredictor, and if you know the dof you want to modify, modify it in MyCustomPredictor::apply(NumericVector<Number> & sln). E.g.\nvoid\nMyCustomPredictor::apply(NumericVector<Number> & sln)\n{\n  SimplePredictor::apply(sln);\n\n  // whatever it takes for you to figure out that dof and the modified guess.\n  ......\n\n  sln.set(dof, value);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/22319#discussioncomment-3814709",
                          "updatedAt": "2022-10-06T13:45:52Z",
                          "publishedAt": "2022-10-06T13:45:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "... or just derive from Predictor if SimplePredictor isn't what you want.",
                          "url": "https://github.com/idaholab/moose/discussions/22319#discussioncomment-3814721",
                          "updatedAt": "2022-10-06T13:47:33Z",
                          "publishedAt": "2022-10-06T13:47:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "The final question today (thanks for all the help everyone). Is there a way to get the nodal neighbors of a node? I am currently using a nodal user object, and have access to the node and mesh, but I can't find a way to find the nodes connected to the current node.",
                          "url": "https://github.com/idaholab/moose/discussions/22319#discussioncomment-3817381",
                          "updatedAt": "2022-10-06T19:26:04Z",
                          "publishedAt": "2022-10-06T19:26:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You can request a node-to-elem-map. I assume by \"nodes connected to the current node\" you mean nodes of the elements that are connected to the current node.",
                          "url": "https://github.com/idaholab/moose/discussions/22319#discussioncomment-3817618",
                          "updatedAt": "2022-10-06T20:09:18Z",
                          "publishedAt": "2022-10-06T20:09:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "If you are doing a Steady solve... then the initial guess is just the initial condition... so you can use that system to set an initial guess.\n@hugary1995 has the right idea for Transient solves.\nAlso, for BCs, note that the DirichletBC object is always doing this (modifying the initial guess to match the value) by default (you can turn it off by setting preset = false).",
                  "url": "https://github.com/idaholab/moose/discussions/22319#discussioncomment-3815185",
                  "updatedAt": "2022-10-06T14:41:55Z",
                  "publishedAt": "2022-10-06T14:41:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "ADRealVectorValue vs ADReal for the residual",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear all,\nI am going to write the mass equation and momentum equation.\nWhen I define the residual for the momentum equation, it is easy to understand that the type of the residual should be defined as ADRealVectorValue. However, the residual for the mass equation contains vector velocity. But the mass equation is a scalar equation.  So I am a little bit confused what is the type for the residual for the mass equation since it contains a vector velocity. And I also I am confused about  ADRealVectorValue in line 36 of the ADHeatConduction.C file.\nThanks a lot.\nJ",
          "url": "https://github.com/idaholab/moose/discussions/22264",
          "updatedAt": "2022-10-06T19:32:00Z",
          "publishedAt": "2022-09-29T15:34:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is a precomputeQpResidual routine you are looking at. Its output is then multiplied by a vector of the test functions, then you do get an ADReal.\nThis is why there are no test function term is this routine, even though you would expect one!\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22264#discussioncomment-3764253",
                  "updatedAt": "2022-09-29T16:11:09Z",
                  "publishedAt": "2022-09-29T16:11:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "Hello Guillaume, thanks for your answer. I still have three questions:\n\n\nprecomputeQpResidual means the output is multiplied by a vector of the test functions. How about computeQpResidual?\n\n\nSpecially, if I want to use 'precomputeQpResidual' and define the types of the terms in mass equation m_t + (mv)_x = 0 and momentum equation: v = lambda * P_x. What will be the types (ADRealVectorValue orADReal) of m_t, (mv)_x,  v, and P_x?\n\n\nAa you mentioned, the precomputeQpResidual means the output is multiplied by a vector of the test functions.   For the momentum equation, which is a vector equation. Now the output is already a vector.  If it is multiplied by a vector of the test functions, it will be a scalar. Is it right?\n\n\nThanks a lot!\nJ",
                          "url": "https://github.com/idaholab/moose/discussions/22264#discussioncomment-3764359",
                          "updatedAt": "2022-09-29T16:38:15Z",
                          "publishedAt": "2022-09-29T16:21:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "computeQpResidual gets you the residual directly. So in computeQpResidual you must have the test functions\n\n\n\nYou will need to make sure to inherit the right types for each kernel btw. It wont compile if you pick the wrong one for the return type of precomputeQpResidual\nFor mass, you only have a single equation so:\nm_t ADReal\ndiv(rho v) ADReal\nFor momentum you have 2-3 equations depending on the dimension,\nso both ADRealVectorValue\n\nyes see in ADKernelGrad, you end up with a dotproduct\n\n    for (_qp = 0; _qp < _qrule->n_points(); _qp++)\n    {\n      const auto value = precomputeQpResidual() * _ad_JxW[_qp] * _ad_coord[_qp];\n      for (_i = 0; _i < n_test; _i++) // target for auto vectorization\n        residuals[_i] += raw_value(MathUtils::dotProduct(value, _grad_test[_i][_qp]));",
                          "url": "https://github.com/idaholab/moose/discussions/22264#discussioncomment-3764664",
                          "updatedAt": "2022-09-29T16:50:12Z",
                          "publishedAt": "2022-09-29T16:50:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "In the moose workshop, when your colleague defines the type of residual for the LaplaceYang equation, which is essentially a mass equation, he uses ADvectorvalue. But based on your above-mentioned 'using ADReal in div(rho v)'. Please refer to the attached figures.",
                          "url": "https://github.com/idaholab/moose/discussions/22264#discussioncomment-3764789",
                          "updatedAt": "2022-09-29T17:05:55Z",
                          "publishedAt": "2022-09-29T17:05:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "LaplaceYoung is more of a diffusion equation\nmass equation is an advection equation.\nIf you have a gradient, then yes it should be a RealVectorValue\nI reckon you actually have a divergence operator in this equation",
                          "url": "https://github.com/idaholab/moose/discussions/22264#discussioncomment-3765039",
                          "updatedAt": "2022-09-29T17:26:14Z",
                          "publishedAt": "2022-09-29T17:26:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "LaplaceYoung is more of a diffusion equation mass equation is an advection equation.\nIf you have a gradient, then yes it should be a RealVectorValue I reckon you actually have a divergence operator in this equation\n\nHi Guillaume,\nwell, if the variable u in the attached figure is pressure, then gradient of u should be equivalent to the velocity, therefore it is essentially mass transport equation, no?",
                          "url": "https://github.com/idaholab/moose/discussions/22264#discussioncomment-3765149",
                          "updatedAt": "2022-09-29T17:39:08Z",
                          "publishedAt": "2022-09-29T17:39:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "LaplaceYoung is more of a diffusion equation mass equation is an advection equation.\nIf you have a gradient, then yes it should be a RealVectorValue I reckon you actually have a divergence operator in this equation\n\nAgain, if u in the attached figure is temperature, then gradient of u is heat flux which is also something similar to velocity",
                          "url": "https://github.com/idaholab/moose/discussions/22264#discussioncomment-3765170",
                          "updatedAt": "2022-09-29T17:41:07Z",
                          "publishedAt": "2022-09-29T17:41:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It depends how you write the mass equation.\nI usually write it from a conservation of mass standpoint, with mass advection.\nYou could also take the divergence of the momentum equation, use the conservation of mass, and end up with a diffusion problem on pressure instead.\nA heat flux is not similar to a velocity and neither is a gradient of pressure. They are all vectors sure, but that's it.",
                          "url": "https://github.com/idaholab/moose/discussions/22264#discussioncomment-3765415",
                          "updatedAt": "2022-09-29T18:11:15Z",
                          "publishedAt": "2022-09-29T18:11:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "It depends on how you write the mass equation. I usually write it from conservation of mass standpoint, with mass advection. You could also take the divergence of the momentum equation, use the conservation of mass, and end up with a diffusion problem on pressure instead.\nA heat flux is not similar to a velocity and neither is a gradient of pressure. They are all vectors sure, but that's it.\n\nYes. That is also what I am confused with since grad_u n in the diffusion equation and velocity in the mass equation are both vectors.\nwhy there is a difference in types for these two?",
                          "url": "https://github.com/idaholab/moose/discussions/22264#discussioncomment-3771005",
                          "updatedAt": "2022-09-30T11:20:12Z",
                          "publishedAt": "2022-09-30T10:02:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "It depends how you write the mass equation. I usually write it from a conservation of mass standpoint, with mass advection. You could also take the divergence of the momentum equation, use the conservation of mass, and end up with a diffusion problem on pressure instead.\nA heat flux is not similar to a velocity and neither is a gradient of pressure. They are all vectors sure, but that's it.\n\nFor example, in your workshop, I find two 'diffusion equations. But the types of their residuals are different. One is ADReal and another one is ADRealVectorValue.",
                          "url": "https://github.com/idaholab/moose/discussions/22264#discussioncomment-3772807",
                          "updatedAt": "2022-09-30T14:10:26Z",
                          "publishedAt": "2022-09-30T14:10:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The type for the computeQpresidual is ADReal\nThe type for the precomputeQpReal is ADRealVectorValue, which then enters a dotproduct to make an ADReal",
                          "url": "https://github.com/idaholab/moose/discussions/22264#discussioncomment-3772934",
                          "updatedAt": "2022-09-30T14:26:54Z",
                          "publishedAt": "2022-09-30T14:26:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PorousFlow multyphase - not converge due to DIVERGED_PC_FAILED",
          "author": {
            "login": "wangshengwa"
          },
          "bodyText": "Hi all,\nI have a system of two layers; and aquitard that confines and aquifer. A well extract water from the aquitard. I would like, in a first step, to desaturate the aquitard and after that, in a second step,  inject a gas fluid. However, the input file with two phases does not converge, even though the model is only extracting water in the first step.\nLooks like the problem comes from the Preconditioning system. I get\n Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0 PC failed due to SUBPC_ERROR  Nonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0 Solve Did NOT Converge! Aborting as solve did not converge\nLooks like activating hypre boomeramg converges, but to a wrong result and diverges after a while.\nA previous issue suggest that this happens because a variable is declare but not used https://github.com/idaholab/moose/issues/18893 . In my case the gas pressure is not used in the first step.\nHas anyone seen something similar before?\nYou can find my codes here: https://github.com/wangshengwa/PorousFlow-stuff/tree/main/2pf\nCheers and thanks in advance\nWang",
          "url": "https://github.com/idaholab/moose/discussions/22251",
          "updatedAt": "2022-10-13T13:39:05Z",
          "publishedAt": "2022-09-28T14:50:38Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "You might benefit from using the s_scale parameter in the capillary pressure function to avoid the derivative blowing up in the fully-saturated initial step - see https://mooseframework.inl.gov/modules/porous_flow/nonlinear_convergence_problems.html and https://mooseframework.inl.gov/modules/porous_flow/capillary_pressure.html\nAlso, you probably want to include some PorousFlowMassTimeDerivative kernels to make sure that the fluid masses balance.",
                  "url": "https://github.com/idaholab/moose/discussions/22251#discussioncomment-3757896",
                  "updatedAt": "2022-09-29T00:52:53Z",
                  "publishedAt": "2022-09-29T00:52:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangshengwa"
                          },
                          "bodyText": "Hi @cpgr . Thanks for your help is really nice. I forgot to add PorousFlowMassTimeDerivative, I was doing steady state tests. Now I fix that. Thanks.\nI also studied the s_scale factor. However, for me is unclear what value should it take. Looks like different values of s_scale take the model to converge to different results. However, non of them seems correct.\nHere, you will find a comparison of the \"first stage\" of my 2 phase model with a model that uses one phase and actions If you run them, you will see that the extraction rate in both models is different.\ncodes: https://github.com/wangshengwa/PorousFlow-stuff/tree/main/2pf\nCan you advise how to proceed?\nCheers and thanks!\nWang",
                          "url": "https://github.com/idaholab/moose/discussions/22251#discussioncomment-3798805",
                          "updatedAt": "2022-10-04T18:53:37Z",
                          "publishedAt": "2022-10-04T18:53:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Oh, I think I see the difference. Your single-phase unsaturated case (action.i) withdraws mass from the aquifer, but doesn't replace it with anything - so water saturation drops below 1, but the remaining pore space is empty (there is no gas phase).\nYour two-phase case (kernels2p.i) withdraws mass from phase 0, so that the saturation decreases below 1. In this case, however, there is another phase (phase 1) which fills the empty pore space  automatically (phase 1). This is different from the unsaturated case above. This case isn't unsaturated!\nSo I guess it depends on what you want to achieve here.\nYou could make your two-phase case be identical to the unsaturated case by setting the density of the phase 1 fluid equal to zero (this is a bit of a hack)\n    [the_simple_fluid2]\n      type = SimpleFluidProperties\n      density0 = 0\n    []\n\nand you should now get the same results as action.i (note: you should make the nl tolerances identical to those in action.i).",
                          "url": "https://github.com/idaholab/moose/discussions/22251#discussioncomment-3800903",
                          "updatedAt": "2022-10-05T02:07:48Z",
                          "publishedAt": "2022-10-05T02:07:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "And the following is what action.i really is doing (with the kernels explicitly included)\n[Mesh]\n  [the_mesh]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 5\n    ny = 100\n    xmin = 0\n    xmax = 5\n    ymin = 0\n    ymax = 100\n  []\n  [aquitard]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 1\n    bottom_left = '0 50 0'\n    top_right = '5 100 0'\n    input = the_mesh\n  []\n  [aquifer]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 2\n    bottom_left = '0 0 0'\n    top_right = '5 50 0'\n    input = aquitard\n  []\n[]\n\n[GlobalParams]\n  PorousFlowDictator = dictator\n  biot_coefficient = 1.0\n[]\n\n[Variables]\n  [ppwater]\n  []\n[]\n\n[ICs]\n  [ppwater]\n    type = FunctionIC\n    variable = ppwater\n    function = '10000*(100-y)'\n  []\n[]\n\n\n[BCs]\n  [ppwater_top]\n    type = FunctionDirichletBC\n    variable = ppwater\n    function = 0\n    boundary = top\n  []\n[]\n\n[Modules]\n  [FluidProperties]\n    [the_simple_fluid]\n      type = SimpleFluidProperties\n    []\n  []\n[]\n\n[AuxVariables]\n  [swater]\n    family = MONOMIAL\n    order = FIRST\n  []\n[]\n\n[UserObjects]\n  [dictator]\n    type = PorousFlowDictator\n    porous_flow_vars = 'ppwater'\n    number_fluid_phases = 1\n    number_fluid_components = 1\n  []\n  [pc]\n    type = PorousFlowCapillaryPressureVG\n    m = 0.6\n    alpha = 1e-5\n    sat_lr = 0.0\n  []\n  [produced_mass]\n    type = PorousFlowSumQuantity\n  []\n[]\n\n[Kernels]\n  [mass0]\n    type = PorousFlowMassTimeDerivative\n    fluid_component = 0\n    variable = ppwater\n  []\n  [flux0]\n    type = PorousFlowAdvectiveFlux\n    fluid_component = 0\n    variable = ppwater\n    gravity = '0 -10 0'\n  []\n[]\n\n[AuxKernels]\n  [swater]\n    type = PorousFlowPropertyAux\n    property = saturation\n    phase = 0\n    variable = swater\n  []\n[]\n\n[Materials]\n  [temperature]\n    type = PorousFlowTemperature\n  []\n  [simple_fluid0]\n    type = PorousFlowSingleComponentFluid\n    fp = the_simple_fluid\n    phase = 0\n  []\n  [ppss]\n    type = PorousFlow1PhaseP\n    porepressure = ppwater\n    capillary_pressure = pc\n  []\n  [massfrac]\n    type = PorousFlowMassFraction\n  []\n\n  [porosity_clay]\n    type = PorousFlowPorosity\n    porosity_zero = 0.3\n    block = 1\n  []\n  [permeability_clay]\n    type = PorousFlowPermeabilityConst\n    permeability = '1E-20 0 0   0 1E-20 0   0 0 1E-20'\n    block = 1\n  []\n  [porosity_rock]\n    type = PorousFlowPorosity\n    porosity_zero = 0.05\n    block = 2\n  []\n  [permeability_rock]\n    type = PorousFlowPermeabilityConst\n    permeability = '1E-13 0 0   0 1E-13 0   0 0 1E-14'\n    block = 2\n  []\n  [relperm_water]\n    type = PorousFlowRelativePermeabilityCorey\n    n = 3\n    phase = 0\n  []\n[]\n\n[DiracKernels]\n   [produce]\n     type = PorousFlowPeacemanBorehole\n     variable = ppwater\n     SumQuantityUO = produced_mass\n     mass_fraction_component = 0\n     point_file = action.bh\n     bottom_p_or_t = 1E-8\n     unit_weight = '0 0 0'\n     use_mobility = true\n     character = 1\n   []\n[]\n\n[Postprocessors]\n  [bh_report]\n    type = PorousFlowPlotQuantity\n    uo = produced_mass\n    execute_on = 'initial timestep_end'\n  []\n  [fluid_mass]\n    type = PorousFlowFluidMass\n    execute_on = 'initial timestep_end'\n  []\n[]\n\n\n[Preconditioning]\n  active = basic\n  [basic]\n    type = SMP\n    full = true\n    petsc_options = '-ksp_diagonal_scale -ksp_diagonal_scale_fix'\n    petsc_options_iname = '-pc_type -sub_pc_type -sub_pc_factor_shift_type -pc_asm_overlap'\n    petsc_options_value = ' asm      lu           NONZERO                   2'\n  []\n  [lu]\n    type = SMP\n    full = true\n    petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n    petsc_options_value = ' lu       mumps'\n  []\n  [moose]\n    type = SMP\n    full = true\n    petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart'\n    petsc_options_value = 'hypre boomeramg 500'\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = Newton\n  start_time = -3600\n  dt = 3600\n  end_time = 172800\n  nl_abs_tol = 1E-12\n  nl_rel_tol = 1e-08\n[]\n\n[Outputs]\n  print_linear_residuals = false\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/22251#discussioncomment-3800906",
                          "updatedAt": "2022-10-05T02:08:53Z",
                          "publishedAt": "2022-10-05T02:08:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangshengwa"
                          },
                          "bodyText": "Thanks! Setting density of the phase 1 to zero works! However, I would like to in a first stage desaturate the medium of the phase 0 (leave it empty) and in a second stage inject the phase 1.\nIf I understood correctly, by setting density0 = 0 we are still replacing the empty space with the phase 1 is just that this phase has no mass. But in the second stage I would like to inject fluid with mass, how can I solve this?\nCheers!\nWang",
                          "url": "https://github.com/idaholab/moose/discussions/22251#discussioncomment-3802362",
                          "updatedAt": "2022-10-05T07:28:22Z",
                          "publishedAt": "2022-10-05T07:28:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "This is just an opinion, not necessarily fact.... i think that your concept of withdrawing water and then replacing the vacuum with air is flawed.  It will be difficult to run PorousFlow like this because it is unphysical (an aquifer never contains a vacuum - always air or some other gas).  If i were you, i'd attempt to reproduce the physical situation with your model.  Having said this, PorousFlow was used to simulate water+vacuum in a carbon-fibre composite, where there truly was a vacuum, so it's not impossible, but care had to be taken with the capillary curve.  Almost definitely you are getting problems from the end-points of the capillary pressure curve, and probably the boundary conditions in your present setup (eg, you are extracting a fluid component from a region where it doesn't exist).",
                          "url": "https://github.com/idaholab/moose/discussions/22251#discussioncomment-3808483",
                          "updatedAt": "2022-10-05T19:37:49Z",
                          "publishedAt": "2022-10-05T19:37:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangshengwa"
                          },
                          "bodyText": "Hi and thanks for your reply. Indeed my approach seems wrong. Thanks for your comment.\nIn other words, only makes physical sense to keep the aquifer saturated at all times.\nAfter some testing, I noticed that as soon as the aquifer desaturates MOOSE has problems converging.\nThanks!",
                          "url": "https://github.com/idaholab/moose/discussions/22251#discussioncomment-3816015",
                          "updatedAt": "2022-10-06T16:16:13Z",
                          "publishedAt": "2022-10-06T16:16:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "My suggestion would be to either use the MultiApp system plus the FullSolveMultiApp to do the initial phase... or to do this as a restart problem.\nhttps://mooseframework.inl.gov/source/multiapps/FullSolveMultiApp.html\nhttps://mooseframework.inl.gov/application_usage/restart_recover.html",
                  "url": "https://github.com/idaholab/moose/discussions/22251#discussioncomment-3790929",
                  "updatedAt": "2022-10-03T21:15:16Z",
                  "publishedAt": "2022-10-03T21:15:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangshengwa"
                          },
                          "bodyText": "Hi @friedmud I will try this tomorrow and come back to you. Thanks!\nWang",
                          "url": "https://github.com/idaholab/moose/discussions/22251#discussioncomment-3798814",
                          "updatedAt": "2022-10-04T18:54:14Z",
                          "publishedAt": "2022-10-04T18:54:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Postprocessor for verifying mass flow rate conservation",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, experts.\nI have a model of fluid-solid conjugate heat transfer. Now I want to verify that the mass flow rate is conserved within the fluid region. That is, whether the mass flow rate at the inlet is equal to the mass flow rate at the outlet. Is there any way in MOOSE to do this?\nI know that VolumetricFlowRate might be able to do it. But the advised_mat_prop parameter in VolumetricFlowRate requires that the material property be Functor, but my material type is ADParsedMaterial, so VolumetricFlowRate is not suitable.\nActually I've used the following syntax to do a simple calculation:\n[AuxKernels]\n  [./speed_auxk]\n    type = VectorVariableMagnitudeAux\n    variable = speed\n    vector_variable = velocity\n    block = 'fluid'\n  [../]\n[]\n\n[Materials]\n  [./rho_fluid-nonAD]\n    type = ParsedMaterial\n    f_name = rho_fluid_noAD\n    function = '(11096 - 1.3236 * Tf) * 1e-6'\n    args = 'Tf'\n    block = 'fluid'\n  [../]\n  [./mass_flow_rate_density_mat]\n    type = ParsedMaterial\n    block = 'fluid'\n    f_name = mass_flow_rate_density\n    args = speed\n    material_property_names = rho_fluid_noAD\n    function = 'rho_fluid_noAD * speed'\n  [../]\n[]\n\n[Postprocessors]\n  [./outlet_mass_flow_rate]\n    type = SideIntegralMaterialProperty\n    boundary = 'fluid_top'\n    property = mass_flow_rate_density\n  [../]\n  [./inlet_mass_flow_rate]\n    type = SideIntegralMaterialProperty\n    boundary = 'fluid_bottom'\n    property = mass_flow_rate_density\n  [../]\n[]\n\nHowever, the relative error of outlet_mass_flow_rate and inlet_mass_flow_rate is around one thousandth, which is obviously not a satisfactory accuracy. So I want to ask if there is any Postprocessor that can calculate mass flow rate directly?",
          "url": "https://github.com/idaholab/moose/discussions/22307",
          "updatedAt": "2022-10-06T06:22:57Z",
          "publishedAt": "2022-10-05T15:27:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is the same issue as in the previous discussion around energy conservation\n#22074\nSide integrals are not appropriate to look at conservation with FE. You will need to make a mass conservation version of the INSElementIntegralEnergyAdvection.C\nBut really if energy is conserved you can trust that mass is conserved as well\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22307#discussioncomment-3806719",
                  "updatedAt": "2022-10-05T15:48:42Z",
                  "publishedAt": "2022-10-05T15:48:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "I'm doing thermomechanical coupling, and the expansion of the solid will cause the outlet channel to narrow and the outlet velocity to increase. So I need to verify that the outlet mass flow rate is the same as the inlet mass flow rate.\n\nBut really if energy is conserved you can trust that mass is conserved as well\n\nIf I use INSElementIntegralEnergyAdvvection to verify the energy conservation of thermomechanical coupling, does it mean that mass is naturally conserved\uff1f Then the mass flow rate is also conserved.",
                          "url": "https://github.com/idaholab/moose/discussions/22307#discussioncomment-3806826",
                          "updatedAt": "2022-10-05T15:58:00Z",
                          "publishedAt": "2022-10-05T15:57:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It would be hard to conserve energy if mass was not conserved.\nIf energy is not conserved, then I would investigate if mass is conserved",
                          "url": "https://github.com/idaholab/moose/discussions/22307#discussioncomment-3806876",
                          "updatedAt": "2022-10-05T16:04:00Z",
                          "publishedAt": "2022-10-05T16:04:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You probably want to review thermodynamics. For incompressible flow the mass balance reduces to div(u) = 0, where u is the fluid velocity.",
                          "url": "https://github.com/idaholab/moose/discussions/22307#discussioncomment-3810274",
                          "updatedAt": "2022-10-06T02:10:48Z",
                          "publishedAt": "2022-10-06T02:10:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thanks for your advice @hugary1995 @GiudGiud . I've used [INSElementIntegralEnergyAdvection] to verifiy energy conservation, which relative error is 3e-10. Does it  mean that mass is naturally conserved?\n\nFor incompressible flow the mass balance reduces to div(u) = 0, where u is the fluid velocity.\n\nAnd how can I verify whether div(u) equals to 0?",
                          "url": "https://github.com/idaholab/moose/discussions/22307#discussioncomment-3810807",
                          "updatedAt": "2022-10-06T04:42:12Z",
                          "publishedAt": "2022-10-06T04:36:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It means energy is conserved. As I mentioned it would be hard not conserving mass, while conserving energy. However, I'm sure you could engineer a solution which does one without the other.\nIf you care to check, then you need to create the object I mentioned\nThere is a divergence auxkernel you can use, though it wont account for stabilization terms.",
                          "url": "https://github.com/idaholab/moose/discussions/22307#discussioncomment-3810850",
                          "updatedAt": "2022-10-06T04:45:09Z",
                          "publishedAt": "2022-10-06T04:45:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "So if say it without jargon: You don't check mass conservation for INS... You are not solving for density.",
                          "url": "https://github.com/idaholab/moose/discussions/22307#discussioncomment-3810880",
                          "updatedAt": "2022-10-06T04:50:45Z",
                          "publishedAt": "2022-10-06T04:50:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "It looks like creating the object is necessary to solve this problem. I will give it a try.\ud83d\udc40",
                          "url": "https://github.com/idaholab/moose/discussions/22307#discussioncomment-3810891",
                          "updatedAt": "2022-10-06T04:53:29Z",
                          "publishedAt": "2022-10-06T04:53:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": ":-/\nAgain, feel free to go over the derivation of navier stokes equations yourself. Mass balance is an assumption not a consequence.",
                          "url": "https://github.com/idaholab/moose/discussions/22307#discussioncomment-3810932",
                          "updatedAt": "2022-10-06T05:03:09Z",
                          "publishedAt": "2022-10-06T05:03:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You are solving that equation for conservation of mass. If you dont converge it much, you can see mass not being converged because velocities entering the cell are larger than exiting the cell (for finite volume, for FE it s more a volumetric problem). Mass balance is the residual of mass equation pretty much\nWith the time-dependent modification of the meshes, I can understand their desire to check mass conservation.",
                          "url": "https://github.com/idaholab/moose/discussions/22307#discussioncomment-3810977",
                          "updatedAt": "2022-10-06T05:20:52Z",
                          "publishedAt": "2022-10-06T05:19:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "I'm a little confused and dizzy now... What I can understand now is that if I want to verify that the mass flow rate is conserved, in another words, the inlet mass flow rate and the outlet mass flow rate are equal, I need to create an object like INSElementIntegralEnergyAdvection . And this object needs to take density and speed into consideration. The product of density and velocity is then integrated over the boundary. If the integral at the inlet boundary is equal to the integral at the outlet boundary, then it is proved that the mass flow rate is conserved. Is there something wrong with my understanding?",
                          "url": "https://github.com/idaholab/moose/discussions/22307#discussioncomment-3811046",
                          "updatedAt": "2022-10-06T05:34:15Z",
                          "publishedAt": "2022-10-06T05:34:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "error when i make",
          "author": {
            "login": "CGH20171006"
          },
          "bodyText": "This error occurs after I use  make -j4, especially for apps in the modules folder (I don't get this error for apps I create myself),I guess it's because I changed some files in the modules/phase_field folder,\nwhat should  i do right now, is there any easy way to overwrite the moose files in GitHub to my computer again.\nthe error is:\n(moose) cgh@LAPTOP-8KAA4L1I:~/projects/moose/modules/phase_field$ make -j4\nLinking Executable /home/cgh/projects/moose/modules/phase_field/phase_field-opt...\n/home/cgh/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/cgh/projects/moose/modules/tensor_mechanics/lib/libtensor_mechanics-opt.so: undefined reference to non-virtual thunk to SideIntegralPostprocessor::getValue()' /home/cgh/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/cgh/projects/moose/modules/tensor_mechanics/lib/libtensor_mechanics-opt.so: undefined reference to MooseVariableData::vectorTagValue(unsigned int) const'\n/home/cgh/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/cgh/projects/moose/modules/tensor_mechanics/lib/libtensor_mechanics-opt.so: undefined reference to non-virtual thunk to ElementIntegralPostprocessor::getValue()' /home/cgh/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/cgh/projects/moose/modules/tensor_mechanics/lib/libtensor_mechanics-opt.so: undefined reference to MooseVariableData::vectorTagDofValue(unsigned int) const'\n/home/cgh/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.3.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/cgh/projects/moose/modules/tensor_mechanics/lib/libtensor_mechanics-opt.so: undefined reference to `non-virtual thunk to Material::resolveOptionalProperties()'\ncollect2: error: ld returned 1 exit status\nmake: *** [/home/cgh/projects/moose/framework/app.mk:416: /home/cgh/projects/moose/modules/phase_field/phase_field-opt] Error 1\n(ps:I am a Chinese undergraduate student and my English is very poor, I am sorry!)",
          "url": "https://github.com/idaholab/moose/discussions/21675",
          "updatedAt": "2022-10-05T13:38:37Z",
          "publishedAt": "2022-07-24T15:31:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "CGH20171006"
                  },
                  "bodyText": "i have been overwrite the moose file,and the error has gone.",
                  "url": "https://github.com/idaholab/moose/discussions/21675#discussioncomment-3216763",
                  "updatedAt": "2022-07-24T17:05:41Z",
                  "publishedAt": "2022-07-24T17:05:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tangweinuaa"
                          },
                          "bodyText": "the same error i meat, can you find the dir /home/cgh/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.3.0/.\nAnd, how do you overwrite the moose file",
                          "url": "https://github.com/idaholab/moose/discussions/21675#discussioncomment-3793156",
                          "updatedAt": "2022-10-04T06:20:27Z",
                          "publishedAt": "2022-10-04T06:20:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "By overwrite the moose files they mean they deleted the whole folder and cloned it again.\nI dont think this is the same error. Could you please make your own post regardless?",
                          "url": "https://github.com/idaholab/moose/discussions/21675#discussioncomment-3799244",
                          "updatedAt": "2022-10-04T20:02:56Z",
                          "publishedAt": "2022-10-04T20:02:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "tangweinuaa"
                          },
                          "bodyText": "ok, i did it by running update conda --all\nFurther, there are some conflicts or differences between the updated and old moose, which may lead to the same error.",
                          "url": "https://github.com/idaholab/moose/discussions/21675#discussioncomment-3800964",
                          "updatedAt": "2022-10-05T02:27:25Z",
                          "publishedAt": "2022-10-05T02:27:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Once you have updated packages and an updated moose, please let us know if you get errors make-ing moose and your application",
                          "url": "https://github.com/idaholab/moose/discussions/21675#discussioncomment-3805330",
                          "updatedAt": "2022-10-05T13:38:38Z",
                          "publishedAt": "2022-10-05T13:38:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Difficulty Solving FEA Problem with Higher Numerical Values",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I am using MOOSE to solve a numerical problem that involves solving a steady state pressure driven flow problem. I have had success in getting a numerical solutions for pressures in the range of 1e-4 Pa.For My actual problem I require the solutions for much higher pressure on the order of 1e7 Pa. For the expected flow velocities the relative pressure drop for each case is expected to be the same. I have come to realized the issue that I am experiencing is related to the residual errors of each variable being calculated. At the1e-4 pressure my initial residuals are as follows: T_fluid:  13.5975, velocity: 1.60189e-08, p_fluid:  6.19058e-06. At the 1e-4 pressure my initial residuals are: T_fluid:  13.5975, velocity: 448.259,  p_fluid:  56047.1. Since the problem is being solved as a steady state problem I do not have the ability to gradually increase the pressure. How can I resolve this solution issue without having to use a transient method using lots of computational resources?",
          "url": "https://github.com/idaholab/moose/discussions/22180",
          "updatedAt": "2022-10-04T20:45:37Z",
          "publishedAt": "2022-09-23T17:34:41Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you dont want to use a relaxation to steady state transient, then your options are to:\n\ninitialize close to the steady solution\nuse more robust solver methods\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22180#discussioncomment-3721683",
                  "updatedAt": "2022-09-24T04:26:44Z",
                  "publishedAt": "2022-09-24T04:26:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Would a potential resolution to the problem be a steady state solution at a lower pressure, then the use of that solution scaled for all previously solved variables (velocity and pressure) as the initial guess to the higher pressure solve?",
                          "url": "https://github.com/idaholab/moose/discussions/22180#discussioncomment-3792606",
                          "updatedAt": "2022-10-04T04:25:14Z",
                          "publishedAt": "2022-10-04T04:25:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It could work.",
                          "url": "https://github.com/idaholab/moose/discussions/22180#discussioncomment-3799524",
                          "updatedAt": "2022-10-04T20:44:56Z",
                          "publishedAt": "2022-10-04T20:44:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There is NO guarantee though. Another common technique is to ramp down viscosity through a pseudo transient",
                          "url": "https://github.com/idaholab/moose/discussions/22180#discussioncomment-3799528",
                          "updatedAt": "2022-10-04T21:42:21Z",
                          "publishedAt": "2022-10-04T20:45:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "Firstly, using a \"Transient\" solve where you slowly step to steady state can actually be faster...\nBut setting that aside you should try to use some of our scaling options to get the residual / jacobian entries around the same size for all physics.\nThe first option is \"manual\" scaling.  This will scale the residual for a variable using syntax like:\n[Variables]\n  [myvar]\n    order = FIRST\n    family = LAGRANGE\n    scaling = 1e-7\n  []\n[]\n\nSee the documentation here: https://mooseframework.inl.gov/syntax/Variables/index.html\nThe other option is automatic scaling.  You turn it on by setting automatic_scaling = true in your Executioner block.  You can see all of the options for automatic scaling at the bottom of the page under \"Solver Variable Scaling Parameters\" here: https://mooseframework.inl.gov/source/executioners/Steady.html",
                  "url": "https://github.com/idaholab/moose/discussions/22180#discussioncomment-3796574",
                  "updatedAt": "2022-10-04T14:26:38Z",
                  "publishedAt": "2022-10-04T14:26:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you. I have had some success using automatic scaling. Manual scaling resulted either in no solution due to convergence prior to the start of the iteration process due to very small initial residual error, or iteration divergence due to subsequent iteration not being scaled. I also changed the units so that the pressure (Pa to GPa) variable does not dominate the others, the result of this method is similar to the manual scaling, where there is no iterations due to low initial residual error.\nMy automatic scaling use has been with the transient version of my problem. I will try it on the steady state to see the result.",
                          "url": "https://github.com/idaholab/moose/discussions/22180#discussioncomment-3796767",
                          "updatedAt": "2022-10-04T14:47:51Z",
                          "publishedAt": "2022-10-04T14:47:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to define a cyclic loading in BC block",
          "author": {
            "login": "xchengood"
          },
          "bodyText": "Dear Moose experts or users,\nHow to define a cyclic loading in BC block? Any developed examples? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/22302",
          "updatedAt": "2022-10-14T03:29:13Z",
          "publishedAt": "2022-10-04T20:41:55Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can use a function to specify a known time-varying displacement.\nhttps://mooseframework.inl.gov/source/bcs/FunctionDirichletBC.html\nNot sure about examples, you should search the repository for tensor mechanics inputs doing this.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22302#discussioncomment-3799518",
                  "updatedAt": "2022-10-04T20:44:14Z",
                  "publishedAt": "2022-10-04T20:44:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MooseRevision.h is missing",
          "author": {
            "login": "yangbai90"
          },
          "bodyText": "In the moose/modules folder, when executing make all, it will fail due to the missing header file, where the header file MooseRevision.h can not be found.\nIn the moose/moose.mk config file, at line 302, it still requires this header file:\nmoose_revision_header := $(FRAMEWORK_DIR)/include/base/MooseRevision.h\n\nCopy the MooseRevision.h file from previous version into that folder can solve this issue.\nShould we either remove the line-302 of moose/moose.mk or recovery the MooseRevision.h?\nBest,\nYang",
          "url": "https://github.com/idaholab/moose/discussions/22294",
          "updatedAt": "2022-10-14T03:20:16Z",
          "publishedAt": "2022-09-14T10:09:45Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSorry we missed this, we dont use issues for user support.\nYour python installation is missing some packages. See similar posts in the discussions forum\n#22035\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22294#discussioncomment-3797747",
                  "updatedAt": "2022-10-04T16:37:51Z",
                  "publishedAt": "2022-10-04T16:37:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}