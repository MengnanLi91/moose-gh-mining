{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wMy0wMVQwMDoxMzoyNS0wNjowMM4AO5pK"
    },
    "edges": [
      {
        "node": {
          "title": "No module named 'hit'",
          "author": {
            "login": "my-hawary"
          },
          "bodyText": "Hi,\nI am trying to install MOOSE on my Macbook with M1 following the steps https://mooseframework.inl.gov/getting_started/installation/conda.html.\nFor Mambaforge3, i installed MacOSX-arm64.\nWhen I was trying to do the last step (Compile and test), I got the following error:\nModuleNotFoundError: No module named 'hit'",
          "url": "https://github.com/idaholab/moose/discussions/20437",
          "updatedAt": "2022-06-13T16:45:26Z",
          "publishedAt": "2022-03-01T05:48:11Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "Thank you for your message! As this is a question regarding conda installation, I am moving this to the Discussions forum. You might get some email notifications about this.",
                  "url": "https://github.com/idaholab/moose/discussions/20437#discussioncomment-2274163",
                  "updatedAt": "2022-06-13T16:45:33Z",
                  "publishedAt": "2022-03-01T15:39:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "To get started in troubleshooting your issue, could you load up your moose conda environment and post the output of the command conda list? This is just to confirm that everything we expect to have installed is there.\nEDIT: To summarize the thread below, conda was unable to install the moose packages due to a conda channel that did not exist. Removing the channel allowed proper syncing of the package metadata, which allowed download of the moose packages. See below for more details.",
                  "url": "https://github.com/idaholab/moose/discussions/20437#discussioncomment-2274173",
                  "updatedAt": "2022-06-13T16:45:33Z",
                  "publishedAt": "2022-03-01T15:40:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "my-hawary"
                          },
                          "bodyText": "It seems that the issue is with the packages. There is no packages installed in mambaforge3/envs/moose\nWhen I tried to reinstall the packages using mamba install moose-tools moose-libmesh, I got the following:\nRuntimeError: Multi-download failed\npublic/osx-arm64                                              No change\npkgs/r/osx-arm64                                   279.0 B @ 286.0 B/s 404 failed  0.1s\nconda/moose/osx-arm64                              199.0 B @ 203.0 B/s 404 failed  1.0s\nconda/moose/noarch                                 195.0 B @ 199.0 B/s 404 failed  1.0s",
                          "url": "https://github.com/idaholab/moose/discussions/20437#discussioncomment-2284768",
                          "updatedAt": "2022-06-13T16:45:37Z",
                          "publishedAt": "2022-03-03T02:58:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "Given that these are 404 errors, it appears as though there's an issue either with your internet connection/firewall or the configuration of the conda channels. Could you show the output of the following command?\nconda config --show channels",
                          "url": "https://github.com/idaholab/moose/discussions/20437#discussioncomment-2284849",
                          "updatedAt": "2022-06-13T16:45:33Z",
                          "publishedAt": "2022-03-03T03:21:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "my-hawary"
                          },
                          "bodyText": "I run the command on the base env. The o/p is:\nchannels:\n\nhttps://conda.software.inl.gov/public\nhttps://mooseframework.org/conda/moose\nconda-forge\ndefaults",
                          "url": "https://github.com/idaholab/moose/discussions/20437#discussioncomment-2284864",
                          "updatedAt": "2022-06-13T16:45:37Z",
                          "publishedAt": "2022-03-03T03:24:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "For comparison, the channel configuration for a newly configured M1 Mac Mini is as follows:\n% conda config --show channels\n% channels:\n    - https://conda.software.inl.gov/public\n    - conda-forge\n\nthe presence of conda/moose in your output is odd to me, as I only see public or conda-forge in the channel sync and download process output.",
                          "url": "https://github.com/idaholab/moose/discussions/20437#discussioncomment-2284865",
                          "updatedAt": "2022-07-06T16:40:10Z",
                          "publishedAt": "2022-03-03T03:24:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "The second channel you have listed does not exist, which explains the 404 errors. Please remove it by performing the following command:\nconda config --remove channels https://mooseframework.org/conda/moose\n\nAnd then try installing the packages again in the activated moose environment.",
                          "url": "https://github.com/idaholab/moose/discussions/20437#discussioncomment-2284875",
                          "updatedAt": "2022-07-06T16:40:12Z",
                          "publishedAt": "2022-03-03T03:26:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "my-hawary"
                          },
                          "bodyText": "It seemed to be working fine so far. I am running a test right now. I will let you now if I got any issues.\nThank you so much.",
                          "url": "https://github.com/idaholab/moose/discussions/20437#discussioncomment-2284937",
                          "updatedAt": "2022-07-06T16:40:20Z",
                          "publishedAt": "2022-03-03T03:41:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "February 2022 News",
          "author": {
            "login": "cticenhour"
          },
          "bodyText": "The February 2022 MOOSE Newsletter has been released!\nA content summary is below:\n\nLegacy Input Parameter Removal (Effective 1 March 2022)\nMOOSE Improvements\n\nThermal Hydraulics Module is now open source\nNew Lagrangian solid mechanics kernels now available in the tensor mechanics module\nAutomatic differentiation support in MOOSE functions\nBrayton cycle model demonstrated using the Thermal Hydraulics Module\nFinite volume Navier Stokes incompressible and weakly compressible implementations reworked to handle face interpolations of velocity\n\n\nMOOSE Bug Fixes and Minor Enhancements",
          "url": "https://github.com/idaholab/moose/discussions/20438",
          "updatedAt": "2022-06-14T15:25:19Z",
          "publishedAt": "2022-03-01T15:50:53Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Field Split Preconditioner or Physics Based Preconditioner",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "I'm doing a comparison against another FE package, and getting some wickedly quick runtimes from it, I think its down to the way it solves one field and then another, rather than solving both. What I can solve in 12 hours, it can solve in 2, for the exact same physics setup. Both use PETSc, so I'm currently assuming its down to the pre-conditioing. It has some interesting PC settings which I've ported across;\n[Preconditioning]\n  [FSP]\n    type = FSP\n    topsplit = 'temp_disp'\n    [temp_disp]\n      splitting = 'temp disp'\n      splitting_type = additive\n    []\n    [temp]\n      vars = 'temp'\n      petsc_options_iname = '-pc_type -pc_hypre_type -ksp_rtol\n                             -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_coarsen_type \n                             -pc_hypre_boomeramg_interp_type -ksp_type\n                             -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths'\n      petsc_options_value = ' hypre      boomeramg   1.0e-8            \n                              0.75       HMIS                       \n                              ext+i cg\n                              4  2'\n\n    []\n    [disp]\n      vars = 'disp_x disp_y disp_z'\n      petsc_options_iname = '-pc_type -ksp_type -ksp_rtol \n                             -pc_gamg_type -pc_gamg_agg_nsmooths\n                             -pc_gamg_threshold  -pc_gamg_coarse_eq_limit\n                             -pc_gamg_square_graph -pc_gamg_reuse_interpolation\n                             -mg_levels_esteig_ksp_type -mg_levels_ksp_type\n                             -mg_levels_pc_type -mg_levels_ksp_chebyshev_esteig_steps\n                             -mg_levels_esteig_ksp_max_it\n                             -pc_gamg_sym_graph'\n      petsc_options_value = ' gamg     cg         1e-12 \n                              agg     1     \n                              0.015   1000\n                              2       1\n                              cg     chebyshev\n                              jacobi   20\n                              20\n                              true'\n    []\n  []\n[]\n\nThis is my first attempt, but I get the following error\n[0]PETSC ERROR: --------------------- Error Message --------------------------------------------------------------\n[0]PETSC ERROR: No support for this operation for this object type\n[0]PETSC ERROR: DM type moose does not implement DMCreateGlobalVector\n[0]PETSC ERROR: See https://www.mcs.anl.gov/petsc/documentation/faq.html for trouble shooting.\n[0]PETSC ERROR: Petsc Release Version 3.15.1, unknown \n[0]PETSC ERROR: /home/dc-davi4/rds/rds-ukaea-ap001/moose_dev/moose//modules/combined/combined-opt on a  named cpu-p-60 by dc-davi4 Thu Feb 10 13:29:05 2022\n[0]PETSC ERROR: Configure options --download-hypre=1 --with-shared-libraries=1 --with-debugging=no --download-fblaslapack=1 --download-metis=1 --download-ptscotch=1 --download-parmetis=1 --download-superlu_dist=1 --download-mumps=1 --download-strumpack=1 --download-scalapack=1 --download-slepc=1 --with-mpi=1 --with-openmp=1 --with-cxx-dialect=C++11 --with-fortran-bindings=0 --with-sowing=0 --with-64-bit-indices --prefix=/home/dc-davi4/rds/rds-ukaea-ap001/moose_dev/petsc --with-make-np=24 --prefix=/home/dc-davi4/rds/rds-ukaea-ap001/moose_dev/petsc\n[0]PETSC ERROR: #1 DMCreateGlobalVector() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/dm/interface/dm.c:961\n[0]PETSC ERROR: #2 DMGetGlobalVector() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/dm/interface/dmget.c:165\n[0]PETSC ERROR: #3 KSPCreateVecs() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/ksp/interface/iterativ.c:1564\n[0]PETSC ERROR: #4 PCSetUp_MG() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/pc/impls/mg/mg.c:1179\n[0]PETSC ERROR: #5 PCSetUp_GAMG() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/pc/impls/gamg/gamg.c:803\n[0]PETSC ERROR: #6 PCSetUp() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/pc/interface/precon.c:1015\n[0]PETSC ERROR: #7 KSPSetUp() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/ksp/interface/itfunc.c:406\n[0]PETSC ERROR: #8 KSPSolve_Private() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/ksp/interface/itfunc.c:850\n[0]PETSC ERROR: #9 KSPSolve() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/ksp/interface/itfunc.c:1085\n[0]PETSC ERROR: #10 PCApply_FieldSplit() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/pc/impls/fieldsplit/fieldsplit.c:1252\n[0]PETSC ERROR: #11 PCApply() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/pc/interface/precon.c:444\n[0]PETSC ERROR: #12 PCApplyBAorAB() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/pc/interface/precon.c:725\n[0]PETSC ERROR: #13 KSP_PCApplyBAorAB() at /home/dc-davi4/rds/rds-ukaea-ap001/moose_dev/moose/petsc/include/petsc/private/kspimpl.h:393\n[0]PETSC ERROR: #14 KSPGMRESCycle() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/ksp/impls/gmres/gmres.c:163\n[0]PETSC ERROR: #15 KSPSolve_GMRES() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/ksp/impls/gmres/gmres.c:249\n[0]PETSC ERROR: #16 KSPSolve_Private() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/ksp/interface/itfunc.c:912\n[0]PETSC ERROR: #17 KSPSolve() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/ksp/ksp/interface/itfunc.c:1085\n[0]PETSC ERROR: #18 SNESSolve_NEWTONLS() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/snes/impls/ls/ls.c:225\n[0]PETSC ERROR: #19 SNESSolve() at /rds/project/iris_vol2/rds-ukaea-ap001/moose_dev/moose/petsc/src/snes/interface/snes.c:4653\n------------------------------------------------------\n\nI had a quick look at Physics Based Precondition (PBP) but the documentation is a bit scarce, https://mooseframework.inl.gov/source/preconditioners/PhysicsBasedPreconditioner.html. Would I be better off doing a thermal solve, then pass that thermal solution to a subapp to solve the mechanical part of the problem? Or can someone hint at the right way to set this up as a PBP?",
          "url": "https://github.com/idaholab/moose/discussions/20274",
          "updatedAt": "2022-06-17T18:05:17Z",
          "publishedAt": "2022-02-10T14:25:08Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI added more docs to the PBP in this PR: https://github.com/idaholab/moose/pull/19985/files\nIt's not merged yet.\n@fdkong have you seen this petsc error?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2151077",
                  "updatedAt": "2022-06-17T18:06:17Z",
                  "publishedAt": "2022-02-10T16:33:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "It is a weird error. GAMG is algebraic and it should not care about DM.\n@makeclean\nDo you mind sharing a simple input file with us on this? I will track it down to reproduce the issue. Regarding the performance, there are many options that can effect performance.   If the other FE code is using PETSc solvers, could you share the results of \"-snes_view\" if the other FE code uses nonlinear solvers, otherwise \"-ksp_view\".\nWith that results, we could setup the same thing for you at the MOSOE side.",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2151964",
                          "updatedAt": "2022-06-17T18:06:17Z",
                          "publishedAt": "2022-02-10T18:29:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "The thermal KSP\nKSP Object: (nls_solve_) 32 MPI processes\n  type: cg\n  maximum iterations=10000, initial guess is zero\n  tolerances:  relative=1e-08, absolute=1e-50, divergence=10000.\n  left preconditioning\n  using DEFAULT norm type for convergence test\nPC Object: (nls_solve_) 32 MPI processes\n  type: hypre\n  PC has not been set up so information may be incomplete\n    HYPRE BoomerAMG preconditioning\n      Cycle type V\n      Maximum number of levels 25\n      Maximum number of iterations PER hypre call 1\n      Convergence tolerance PER hypre call 0.\n      Threshold for strong coupling 0.75\n      Interpolation truncation factor 0.\n      Interpolation: max elements per row 0\n      Number of levels of aggressive coarsening 4\n      Number of paths for aggressive coarsening 2\n      Maximum row sums 0.9\n      Sweeps down         1\n      Sweeps up           1\n      Sweeps on coarse    1\n      Relax down          symmetric-SOR/Jacobi\n      Relax up            symmetric-SOR/Jacobi\n      Relax on coarse     Gaussian-elimination\n      Relax weight  (all)      1.\n      Outer relax weight (all) 1.\n      Using CF-relaxation\n      Not using more complex smoothers.\n      Measure type        local\n      Coarsen type        Falgout\n      Interpolation type  classical\n\nThe mechanical\nKSP Object: (ksp_u_) 32 MPI processes\n  type: cg\n  maximum iterations=10000, initial guess is zero\n  tolerances:  relative=1e-08, absolute=1e-50, divergence=10000.\n  left preconditioning\n  using DEFAULT norm type for convergence test\nPC Object: (ksp_u_) 32 MPI processes\n  type: gamg\n  PC has not been set up so information may be incomplete\n    type is MULTIPLICATIVE, levels=0 cycles=unknown\n      Cycles per PCApply=0\n      Using externally compute Galerkin coarse grid matrices\n      GAMG specific options\n        Threshold for dropping small values in graph on each level =  \n        Threshold scaling factor for each level not specified = 1.\n        AGG specific options\n          Symmetric graph false\n          Number of levels to square graph 2\n          Number smoothing steps 1\n        Complexity:    grid = 0.\n  linear system matrix = precond matrix:\n  Mat Object: 32 MPI processes\n    type: mpiaij\n    rows=14739, cols=14739, bs=3\n    total: nonzeros=602649, allocated nonzeros=602649\n    total number of mallocs used during MatSetValues calls=0\n      has attached near null space\n      using I-node (on process 0) routines: found 158 nodes, limit used is 5\n\nI'll try and make a MWE",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2156540",
                          "updatedAt": "2022-06-17T18:06:17Z",
                          "publishedAt": "2022-02-11T11:09:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "sample.zip\nHere is the minimum working example",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2203750",
                          "updatedAt": "2022-06-17T18:06:17Z",
                          "publishedAt": "2022-02-18T10:33:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "Thanks for example. I will look into it",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2206783",
                          "updatedAt": "2022-06-17T18:19:18Z",
                          "publishedAt": "2022-02-18T18:39:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "OK, I looked into this a bit. The issue was that GAMG would use DM to create global vectors when DM is detected since GMAG is built on the top of PCMG. Right now, our DM interface in MOOSE is incomplete. In the current use case, we have to involve DM since FSP is set up via DM.\nThe short-term solution is to use HYPRE instead of GAMG. I believe you will have a similar performance by replacing GAMG with hypre in FSP.\nThe long-term solution is to enhance the DM interface in MOOSE #20420. This will take a while since the team is busy ...",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2268771",
                          "updatedAt": "2022-06-17T18:19:18Z",
                          "publishedAt": "2022-02-28T21:20:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Thanks for taking a look into it @fdkong - is could I use PBP instead would that make a difference? Effectively what I'm trying to head towards is a system where I can solve the thermal system with one preconditioner and the (coupled) structural one with another. I could of course do a thermal solve and have my mechanical solve as a subapp, but is there a neater way to do it all in one input?",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2269005",
                          "updatedAt": "2022-06-17T18:19:19Z",
                          "publishedAt": "2022-02-28T22:09:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "Effectively what I'm trying to head towards is a system where I can solve the thermal system with one preconditioner and the (coupled) structural one with another.\n\nI meant: you could just replace the GAMG block with HYPRE, and then FSP will work",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2269053",
                          "updatedAt": "2022-06-17T18:19:20Z",
                          "publishedAt": "2022-02-28T22:18:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "Do something like this:\n[Preconditioning]\n  [FSP]\n    type = FSP\n    topsplit = 'temp_disp'\n    [temp_disp]\n      splitting = 'temp disp'\n      splitting_type = additive\n    []\n    [temp]\n      vars = 'temp'\n      petsc_options_iname = '-pc_type -pc_hypre_type -ksp_rtol\n                             -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_coarsen_type \n                             -pc_hypre_boomeramg_interp_type -ksp_type\n                             -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths'\n      petsc_options_value = ' hypre      boomeramg   1.0e-8            \n                              0.75       HMIS                       \n                              ext+i cg\n                              4  2'\n\n    []\n    [disp]\n      vars = 'disp_x disp_y disp_z'\n        petsc_options_iname = '-pc_type -pc_hypre_type -ksp_rtol\n                             -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_coarsen_type \n                             -pc_hypre_boomeramg_interp_type\n                             -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths'\n      petsc_options_value = ' hypre      boomeramg   1.0e-8            \n                              0.75       HMIS                       \n                              ext+i\n                              4  2'\n    []\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2269075",
                  "updatedAt": "2022-06-17T18:06:17Z",
                  "publishedAt": "2022-02-28T22:21:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "Sure, I'll give that a go, but if I wanted to specifically test GAMG then subapp is the way to go? even with a transient problem?",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2269129",
                          "updatedAt": "2022-06-17T18:17:17Z",
                          "publishedAt": "2022-02-28T22:31:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "You might have more details about what is your motivation here?  So I understand why you want to do this? If you want to do comparison with other codes,  you might use the same coupling approach as other codes do.",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2269231",
                          "updatedAt": "2022-06-17T18:17:17Z",
                          "publishedAt": "2022-02-28T22:55:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "I had a student code up an equivalent physics modules in Fenics/X (https://fenicsproject.org/) and relative to my MOOSE version of the problem, it ran 5x faster. I'm trying to isolate where and why, my initial guess was that it was due to a lot of PC choices I hadn't seen, which was my first go here - to try with the FSP to achieve the same thing. The next nearest thing I can do is a thermal solve, pass that data do the mechanical subapp using the temp as an aux field. I'm trying to achieve similar scaling to his problem, for example, with my full of the problem I can solve 300 timesteps in 12 hours, which I was pretty happy with, but to get that performance I used 360 MPI tasks, 6 tasks per socket which equates to a total of 3360 CPUS reserved (360 being used) across 60 nodes. He was able to do the same with 5 nodes using fully utilised machine, doing all timesteps in 2.5 hours.\nThis works out to be 23 seconds per fully converged NL cycle in FENICS and over 375 seconds with MOOSE, using my original PC settings. Fenics doesnt update the mesh, this incurs a cost in time. Maybe I should try the initial precondition only. So thats the motivation here, to figure out what the source of this performance gulf is.",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2269354",
                          "updatedAt": "2022-06-17T18:17:19Z",
                          "publishedAt": "2022-02-28T23:32:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "Sorry for late reply again.\n\nI'm trying to isolate where and why, my initial guess was that it was due to a lot of PC choices I hadn't seen, which was my first go here - to try with the FSP to achieve the same thing.\n\nFENICS uses PETSc as well. So the first step would be that:\nRun the \"FENICS\" code with the petsc log option \"-log_view\".\nRun the MOOSE code possibly with FSP (HYPRE for both heat conduction and solid mechanics) with the petsc log option \"-log_view\" and also moose pperfgraph .\nWith these data, we should be able to have a big picture of where differences come from.\nThe first step of debugging performance is \"profiling\". Once you have the results of \"-log_view\", we will have a better idea.\nPut \"-log_view\" as part of your command line.",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2283248",
                          "updatedAt": "2022-09-04T00:51:06Z",
                          "publishedAt": "2022-03-02T20:48:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@makeclean  My understanding is that your student is solving the two systems separately, without even using fixed point iteration to get a truly converged solution. Please correct me if I'm wrong.\nIf my understanding is correct, then in order to make an apples-to-apples comparison, you have to use the MultiApp system in MOOSE to setup the two systems individually (without fixed point iteration). I don't think playing with the FSP will give you a completely decoupled system in the sense that you assemble and solve two matrices separately. Again, @makeclean and @fdkong correct me if I'm wrong.",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2283558",
                          "updatedAt": "2022-10-11T13:47:13Z",
                          "publishedAt": "2022-03-02T21:41:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I guess another quick way to check is comparing your MOOSE solution to the FENICS solution.",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2283603",
                          "updatedAt": "2022-10-11T13:47:14Z",
                          "publishedAt": "2022-03-02T21:49:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "It is a good point. I am not sure how the physics components are coupled at FENICS.  There could be many things there. @makeclean  Do you have PJFNK at FENICS as well? If it is a pure Newton with an exact matrix, we definitely will see huge performance differences.\nIt was why I am interested in the results of \"-log_view\" that will give us a lot of information",
                          "url": "https://github.com/idaholab/moose/discussions/20274#discussioncomment-2283622",
                          "updatedAt": "2022-10-11T13:47:15Z",
                          "publishedAt": "2022-03-02T21:53:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Help with crystal plasticity modeling",
          "author": {
            "login": "xchengood"
          },
          "bodyText": "Hi Moose experts or users,\nHappy new year.\nRecently, I am working on the crystal plasticity model and thinking about how to write specific code for this model (Wen, Wei, Laurent Capolungo, Anirban Patra, and C. N. Tom\u00e9. \"A physics-based crystallographic modeling framework for describing the thermal creep behavior of Fe-Cr alloys.\" Metallurgical and Materials Transactions A 48, no. 5 (2017): 2603-2617.) The PDF is available at https://link.springer.com/content/pdf/10.1007/s11661-017-4011-3.pdf.\nTwo questions:\n\nShould I start from equation [1] or equation [4] when writing code?\nIf starting from equation [1], I have no idea about how to express the equations [1] and [2] in Moose. In equation [1], how to express \u03b5_ij and n_i, n_j, b_i and b_j for m_ij. Are there any codes developed for reference?\n\n\n\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/19959",
          "updatedAt": "2022-06-06T14:54:47Z",
          "publishedAt": "2022-01-05T16:11:42Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "Hi @xchengood,\nI would recommend starting with equation 4 from the cited paper. Look at the method calculateSlipRate in the classes CrystalPlasticityTwinningKalidindiUpdate and CrystalPlasticityKalidindiUpdate for examples.\nA variation of Equation 1 is implemented in CrystalPlasticityStressUpdateBase in the method calculateEquivalentSlipIncrement,line 459. In this base class we solve for the plastic velocity gradient, rather than the plastic strain rate as in the Wen et al. paper; see Equation 8 on the ComputeMultipleCrystalPlasticityStress documentation page the mathematical details.\nHope this helps,\nStephanie",
                  "url": "https://github.com/idaholab/moose/discussions/19959#discussioncomment-1915446",
                  "updatedAt": "2022-06-06T14:54:47Z",
                  "publishedAt": "2022-01-05T22:26:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @xchengood\nAn example of the implementation we are doing for Orowan's law (your equation [4]) in the CP model in MOOSE is here:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainCrystalPlasticityDislo.C\nThis is still based on the monolithic CP code,\nbut if you want to collaborate with us to port it to the UserObject based,\nfeel free to contact me.\nAs Stephanie mentioned, equation [1] is already implemented and normally you would not change it,\nunless you need to introduce additional mechanisms other than slip.\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/19959#discussioncomment-1915828",
                  "updatedAt": "2022-06-06T14:54:48Z",
                  "publishedAt": "2022-01-06T00:39:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Hi @ngrilli and @xchengood\nIf/when you collaborate to port the monolithic crystal plasticity code, would you refactor the code to the StressUpdate based version (base class here ), and not the User Object version, please? The StressUpdate version has several robustness and speed advantages, which @dewenyushu has shown elsewhere. Additionally, it will be more straightforward to refactor the monothlithic-based code to the StressUpdate version since both versions are solely Material classes.\nThanks!\nStephanie",
                          "url": "https://github.com/idaholab/moose/discussions/19959#discussioncomment-1915864",
                          "updatedAt": "2022-06-06T14:55:03Z",
                          "publishedAt": "2022-01-06T00:50:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @sapitts\nThank you very much for the information, I was not aware of that.\nI will definitely use the StressUpdate class.\nBest Regards,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/19959#discussioncomment-1918700",
                          "updatedAt": "2022-06-24T09:21:03Z",
                          "publishedAt": "2022-01-06T14:01:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "@sapitts and @ngrilli Thank you very much for your information. It is much helpful for me to achieve this model in Moose. Since I have less experience in the development of Moose, I am still struggling with Moose study. Here, could you help me look at the following equation (10) that I do have no idea how to express it in Moose?\n\nThe referenced paper is \"Crystal plasticity-based creep model for solution-strengthened nickel-based alloys\" (available at Chakraborty P, Jiang W. Crystal plasticity-based creep model for solution-strengthened nickel-based alloys. International Journal of Materials and Structural Integrity. 2019;13(1-3):144-59.)",
                          "url": "https://github.com/idaholab/moose/discussions/19959#discussioncomment-1991368",
                          "updatedAt": "2022-06-24T09:21:03Z",
                          "publishedAt": "2022-01-18T15:41:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "@xchengood sorry for the late reply, particularly since at this point you may have already solved this issue.\nI'd recommend reusing calculateSchmidTensor in the CrystalPlasticityStressUpdateBase class and passing in the array for the m^a_o vector for both the the plane_normal_vector and direction_vector arguments. Make sure to define a new tensor, too, to hold that dyadic product.",
                          "url": "https://github.com/idaholab/moose/discussions/19959#discussioncomment-2283537",
                          "updatedAt": "2022-08-03T11:59:36Z",
                          "publishedAt": "2022-03-02T21:37:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "@sapitts. Thank you for your suggestions very much. Appreciate.",
                          "url": "https://github.com/idaholab/moose/discussions/19959#discussioncomment-2283585",
                          "updatedAt": "2022-08-03T11:59:36Z",
                          "publishedAt": "2022-03-02T21:46:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "get node ids from a sideset and paired nodes in an Action",
          "author": {
            "login": "KhaledNabilSharafeldin"
          },
          "bodyText": "Hello,\nI have a list of sideset names BoundaryName and looking to get the node ids for all the nodes on these sidesets.\nalso, if there is a way to get the \"PairedBoundaryMapping\" for that node easily within action or constraint systems.\nUltimately, I am trying to get a list of primary and secondary node ids.\nthanks in advance!",
          "url": "https://github.com/idaholab/moose/discussions/20379",
          "updatedAt": "2022-12-02T10:30:37Z",
          "publishedAt": "2022-02-23T06:06:36Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUse the NodalValueSampler and restrict it to those sidesets with the boundary parameter\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/NodalValueSampler.html\nThe CSV output will have the list of node ids\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20379#discussioncomment-2233968",
                  "updatedAt": "2023-05-15T03:27:03Z",
                  "publishedAt": "2022-02-23T06:42:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "is there a cleaner way to code it in the action instead?",
                          "url": "https://github.com/idaholab/moose/discussions/20379#discussioncomment-2234042",
                          "updatedAt": "2023-05-15T04:19:03Z",
                          "publishedAt": "2022-02-23T07:01:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Oh yes for sure if you are willing to code.\nYou can loop over all boundaries and select the nodes from there.\nStart from  mesh->get_boundary_info(); and build the node list\nhttps://libmesh.github.io/doxygen/classlibMesh_1_1BoundaryInfo.html",
                          "url": "https://github.com/idaholab/moose/discussions/20379#discussioncomment-2234076",
                          "updatedAt": "2023-05-15T04:19:03Z",
                          "publishedAt": "2022-02-23T07:07:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "It looks like what I need is being done in MeshBase::get_info(), there's SidesetInfo struct that store node_ids\nis there an easy way to get to that info? any suggestions would be appreciated.\nthanks again!",
                          "url": "https://github.com/idaholab/moose/discussions/20379#discussioncomment-2237213",
                          "updatedAt": "2023-05-15T04:19:04Z",
                          "publishedAt": "2022-02-23T15:14:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "I believe you're looking for https://mooseframework.inl.gov/docs/doxygen/libmesh/classlibMesh_1_1BoundaryInfo.html#a4ab2a9be3fe7eaa1d6f9f5bdc7a9856e",
                          "url": "https://github.com/idaholab/moose/discussions/20379#discussioncomment-2237246",
                          "updatedAt": "2023-05-15T04:19:10Z",
                          "publishedAt": "2022-02-23T15:20:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "@loganharbour i can see how I can use the suggested function to return each boundary node paired to the sideset id, and then forming the sidesets from that.\nbut does this support distributed mesh?\nI would rather get the info from this, it seems to be more direct, I am just not sure how to get to that info in an Action, and the function doesnt return these info.\n\nIt looks like what I need is being done in MeshBase::get_info(), there's SidesetInfo struct that store node_ids\nis there an easy way to get to that info? any suggestions would be appreciated.\nthanks again!",
                          "url": "https://github.com/idaholab/moose/discussions/20379#discussioncomment-2237371",
                          "updatedAt": "2023-05-15T04:19:10Z",
                          "publishedAt": "2022-02-23T15:37:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "Oh heh, I'm the one that wrote that in MeshBase.\n\nbut does this support distributed mesh?\n\nNo, building the side list just builds information pertaining to the local entities (it may also include ghosted entities, but don't quote me on that).  Why do you need to know the global information? In the case of distributed mesh, you should really only want to act on local entities.",
                          "url": "https://github.com/idaholab/moose/discussions/20379#discussioncomment-2237399",
                          "updatedAt": "2023-05-15T04:19:30Z",
                          "publishedAt": "2022-02-23T15:42:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "Why do you need to know the global information?\n\nI'm trying to get nodal ids to apply a constraint to these nodes. I still will need to find the node pairs for those, but I haven't looked into that yet. ('getPairedBoundaryMapping' seems to be the method used)",
                          "url": "https://github.com/idaholab/moose/discussions/20379#discussioncomment-2237552",
                          "updatedAt": "2023-05-15T03:27:08Z",
                          "publishedAt": "2022-02-23T16:01:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "ok, so i found a way to get the node ids by creating sidesetsfromnormals, then getting the list of nodelist, with the dof_id_type i can get a pointer that holds the position vector and check for the corresponding sides.\nbut I still have a problem with creating the 8 edge corners as nodesets, since all of this is inaccessible at append_mesh flag , any idea if there's already this functionality implemented? (a nodeset generator for corner nodes)\nstd::vector<BoundaryName> boundary_names{\"xp\", \"xn\",\"yp\", \"yn\",\"zp\", \"zn\"};\n\nstd::vector<std::vector<dof_id_type>> allLists_from_boundaryNames;\n   \nfor (auto &&name : boundary_names)\n    allLists_from_boundaryNames.push_back(_mesh->getNodeList(_mesh->getBoundaryID(name)));\n\nand  auto nptr = *_mesh->nodePtr(n); were the functions i needed to build this up, if anyone's interested",
                          "url": "https://github.com/idaholab/moose/discussions/20379#discussioncomment-2282880",
                          "updatedAt": "2023-05-15T03:27:08Z",
                          "publishedAt": "2022-03-02T19:40:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can specify the points manually with this:\nhttps://mooseframework.inl.gov/docs/site/source/meshgenerators/ExtraNodesetGenerator.html",
                          "url": "https://github.com/idaholab/moose/discussions/20379#discussioncomment-2282979",
                          "updatedAt": "2023-05-15T03:27:15Z",
                          "publishedAt": "2022-03-02T20:01:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "unfortunately, the _mesh->dimensionWidth(dim) is not accessible at this section as well, i can do it manually, but is there a way to get it otherwise?\nso basically I neither have the total dimension of the cube or the corner node ids at that point of the code.\nthanks again",
                          "url": "https://github.com/idaholab/moose/discussions/20379#discussioncomment-2283037",
                          "updatedAt": "2023-05-15T03:27:41Z",
                          "publishedAt": "2022-03-02T20:12:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A 'Migration' is not a registered object\uff1f",
          "author": {
            "login": "biaogxb"
          },
          "bodyText": "when I run the input.i I receive the error\uff1aA 'Migration' is not a registered object\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\nanyone can help me\nCode.zip\n\uff1f",
          "url": "https://github.com/idaholab/moose/discussions/20436",
          "updatedAt": "2022-06-13T14:43:20Z",
          "publishedAt": "2022-03-01T14:54:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou forgot to register these objects. See this source file for example, right under the header:\nregisterMooseObject(\"MooseApp\", Diffusion);\n\nhttps://github.com/idaholab/moose/blob/next/framework/src/kernels/Diffusion.C\nYou ll want to register it to your application\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20436#discussioncomment-2274544",
                  "updatedAt": "2022-06-13T14:43:20Z",
                  "publishedAt": "2022-03-01T16:12:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "thank you so much!!!",
                          "url": "https://github.com/idaholab/moose/discussions/20436#discussioncomment-2279342",
                          "updatedAt": "2022-06-13T14:43:21Z",
                          "publishedAt": "2022-03-02T09:41:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to compile and run my source code\uff1f",
          "author": {
            "login": "biaogxb"
          },
          "bodyText": "I just started learning to use moose, and my source code: .c documents and .h and .i file, how to calculate on my moose and get the result\uff1fDo I need to write the makefile by myself?",
          "url": "https://github.com/idaholab/moose/discussions/20431",
          "updatedAt": "2022-08-27T10:28:00Z",
          "publishedAt": "2022-03-01T07:17:42Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "Follow the instructions here to create an application: https://mooseframework.inl.gov/getting_started/new_users.html\nAfter the application is made, you can place your source in src and include and the pre-generated makefile will compile appropriately.",
                  "url": "https://github.com/idaholab/moose/discussions/20431#discussioncomment-2273853",
                  "updatedAt": "2022-08-27T10:28:00Z",
                  "publishedAt": "2022-03-01T15:00:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "Thank you for your answer. I tried this, After compiling, I tried to run input.i file in my registered application, but this error occurred. Do you know how to overcome this problem.\nthe following errors were reported\uff1a\nA 'Migration' is not a registered object.\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\nCode.zip",
                          "url": "https://github.com/idaholab/moose/discussions/20431#discussioncomment-2274284",
                          "updatedAt": "2022-08-27T10:28:01Z",
                          "publishedAt": "2022-03-01T15:53:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "See #20436",
                          "url": "https://github.com/idaholab/moose/discussions/20431#discussioncomment-2274555",
                          "updatedAt": "2022-08-27T10:28:05Z",
                          "publishedAt": "2022-03-01T16:13:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "biaogxb"
                          },
                          "bodyText": "thank you so much\uff01\uff01!",
                          "url": "https://github.com/idaholab/moose/discussions/20431#discussioncomment-2279339",
                          "updatedAt": "2022-08-27T10:28:05Z",
                          "publishedAt": "2022-03-02T09:40:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Data output of grain growth model",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE Experts,\nI've started studying the example poly_grain_growth_2D_eldrforce.i.\nBut I don\u2019t know how to output the evolution of the number of grain boundaries of each grain over time, or the distribution of the number of grain boundaries at each time step.\nAny suggestions or recommendations to fix these problems would be greatly appreciated.\nThanks\nwei peng",
          "url": "https://github.com/idaholab/moose/discussions/16190",
          "updatedAt": "2022-08-25T03:34:26Z",
          "publishedAt": "2020-11-15T03:04:59Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@SudiptaBiswas Can you help with this?",
                  "url": "https://github.com/idaholab/moose/discussions/16190#discussioncomment-132843",
                  "updatedAt": "2022-08-25T03:34:29Z",
                  "publishedAt": "2020-11-18T16:49:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "I'm not sure I understand why you mean by \"number of grain boundaries of each grain\". Are you wanting the number of grains each grain is adjacent to? If we are on a grain boundary are you interested in the number of grains each boundary is adjacent to? We have a few existing AuxKernels that can visualize this information. There is also the FeataureVolumeVectorPostprocessor that can output several \"per grain\" quantities. If we don't have exactly what you need available now, it shouldn't be difficult to get that information.",
                  "url": "https://github.com/idaholab/moose/discussions/16190#discussioncomment-146166",
                  "updatedAt": "2022-08-25T03:34:29Z",
                  "publishedAt": "2020-12-03T15:42:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Yes, I want to output the number of neighboring grains for each grain during the time evolution. So what AuxKernel or Postprocessor can achieve this function?",
                          "url": "https://github.com/idaholab/moose/discussions/16190#discussioncomment-147700",
                          "updatedAt": "2022-08-25T03:34:29Z",
                          "publishedAt": "2020-12-05T04:00:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Currently this information is not stored. It is saved in the initial condition system (to build the graph coloring matrix), but it's only used in that one instance. However, it is indirectly available during the discovery phase each time the FeatureFloodCount object executes, so it could potentially be saved. I don't have time or scope to work on this for you, but I would be willing to advise you on how to modify the source to accomplish this. You could contribute your changes back to MOOSE too. Are you interested in working on this?",
                          "url": "https://github.com/idaholab/moose/discussions/16190#discussioncomment-158437",
                          "updatedAt": "2022-08-25T03:34:29Z",
                          "publishedAt": "2020-12-07T18:22:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Yeah, I am very honored to contribute to MOOSE. My job is to couple tensor mechanics and phase field to study the process of grain growth, so the grain boundary output is very important to me.",
                          "url": "https://github.com/idaholab/moose/discussions/16190#discussioncomment-162743",
                          "updatedAt": "2023-02-07T13:49:05Z",
                          "publishedAt": "2020-12-08T01:05:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Great! So this should be relatively straight forward, but you are going to have to look through the FeatureFloodCount object a bit and understand what's there. That object does the bulk of identifying and managing the \"feature\" or \"grain\" datastructure. In fact, you'll find the Feature data structure defined in that class.\nThe code you need for getting a list of all neighbors already exists here: \n  \n    \n      moose/modules/phase_field/src/userobjects/PolycrystalUserObjectBase.C\n    \n    \n        Lines 388 to 408\n      in\n      b51a7aa\n    \n  \n  \n    \n\n        \n          \n           void \n        \n\n        \n          \n           PolycrystalUserObjectBase::buildGrainAdjacencyMatrix() \n        \n\n        \n          \n           { \n        \n\n        \n          \n             mooseAssert(_is_primary, \"This routine should only be called on the primary rank\"); \n        \n\n        \n          \n            \n        \n\n        \n          \n             _adjacency_matrix = libmesh_make_unique<DenseMatrix<Real>>(_feature_count, _feature_count); \n        \n\n        \n          \n             for (auto & grain1 : _feature_sets) \n        \n\n        \n          \n             { \n        \n\n        \n          \n               for (auto & grain2 : _feature_sets) \n        \n\n        \n          \n               { \n        \n\n        \n          \n                 if (&grain1 == &grain2) \n        \n\n        \n          \n                   continue; \n        \n\n        \n          \n            \n        \n\n        \n          \n                 if (grain1.boundingBoxesIntersect(grain2) && grain1.halosIntersect(grain2)) \n        \n\n        \n          \n                 { \n        \n\n        \n          \n                   (*_adjacency_matrix)(grain1._id, grain2._id) = 1.; \n        \n\n        \n          \n                   (*_adjacency_matrix)(grain1._id, grain2._id) = 1.; \n        \n\n        \n          \n                 } \n        \n\n        \n          \n               } \n        \n\n        \n          \n             } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nAs you may expect, it's a double loop over all the grains to detect \"intersecting\" grains. In the object above we are doing this so that we can get PETSc to do the \"hard\" work of generating a coloring map, so I never bothered to store this data in the data structure as this data isn't needed beyond the local scope of where it's used.\nSo I would proceed like this:\n\nAllow the FeatureFloodCount object to run it's normal stages like normal (i.e. initialize, execute, finalize). This will populate your data structure with all of the rich information about each feature, it's Halo, and make many of the methods that you'll need to use for your data.\nIn finalize I created a new interface that updates data structures as necessary for queries like this one called updateFieldinfo. There are already several in there for showing the halos, unique grain maps, etc.  I would recommend that you start by just putting your new logic in that method to perform that double loop and populate a new data structure with a list (or vector) of neighbors for each feature.\nCopy and paste the code from the PolycrystalUserObject base to populate your new data structure. For debugging, I would recommend that you just print your data right to the terminal. Something like this:\n\ngrain_id, neighbor_ids\n1: 4,5,9\n2: 1,3,5\n3: 1,2,7,8\n...\n\n\nCreate a new interface in FeatureVolumeVectorPostprocessor to get your data back out. I wouldn't recommend that you try to do your own I/O. You are better off using existing MOOSE interfaces. So if you can populate new vectors in this object, you'll get all your data out in the normal MOOSE way: CSV files, Exodus files, etc.",
                          "url": "https://github.com/idaholab/moose/discussions/16190#discussioncomment-163733",
                          "updatedAt": "2022-09-05T04:17:32Z",
                          "publishedAt": "2020-12-08T16:15:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "BTW - Shameless plug: I have a new publication that should have a preprint available shortly that goes into a lot of the detail of how these algorithms all tie together. Maybe by mid to late December. I'll try to remember to post the link here when I have it available.",
                          "url": "https://github.com/idaholab/moose/discussions/16190#discussioncomment-163738",
                          "updatedAt": "2022-09-05T04:18:17Z",
                          "publishedAt": "2020-12-08T16:17:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you for your enthusiastic help, and I am very sorry to reply to you now. I will read your suggestions carefully, and hope to achieve what I need. Thank you again for your guidance.",
                          "url": "https://github.com/idaholab/moose/discussions/16190#discussioncomment-326391",
                          "updatedAt": "2022-09-05T04:18:17Z",
                          "publishedAt": "2021-02-01T05:46:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "hi permcody, @permcody\nI want to clarify the information I need to output again in the phase field grain growth simulation.\nIn the simulation of grain growth, the information that needs to be captured is two major aspects.\n\n\nThe first is grain-growth kinetics, which is mainly the grain size distribution at each time point.\nThe second is topology of grain-growth-induced microstructures, which needs to be able to output a series of csv files similar to the first one, and each csv file represents the topology of grains at different time nodes.\n\nThe content of the topology includes:\n\nthe number of faces (sides) per grain, in other words, the number of adjacent grains of a certain grain. I think this is the purpose of writing this object.\nthe number of edges per grain.\nthe number of vertices (corners) per grain.\n\nAccording to your suggestion,you are going to have to look through the FeatureFloodCount object a bit and understand what's there. I just tried to read the code to understand FeatureFloodCount, but I found this is difficult for beginners like me. So, could you share some basic documents with me, such as the program framework of FeatureFloodCount.C, the entry-level information of this algorithm, etc., so that I can better understand the FeatureFloodCount object.\nFinally, I am very sorry to reply you after such a long time. I hope that I could complete the editing of this object with your help and make some contributions to moose, which will also give me a deeper understanding of moose.\nThanks\nwei peng",
                          "url": "https://github.com/idaholab/moose/discussions/16190#discussioncomment-326770",
                          "updatedAt": "2022-09-05T04:18:18Z",
                          "publishedAt": "2021-02-01T09:43:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Hi @permcody, I think I'm done with outputting the number of adjacent grains by adding some code in FeatureFloodCount and FeatureFloodCount. And I also have made a pull request. Looking forward to your comments.\nWei",
                          "url": "https://github.com/idaholab/moose/discussions/16190#discussioncomment-2277339",
                          "updatedAt": "2022-09-05T04:18:19Z",
                          "publishedAt": "2022-03-02T01:42:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Persistent response following steady state restart",
          "author": {
            "login": "AdrienWehrle"
          },
          "bodyText": "Hi,\nI am a new MOOSE user trying to simulate some basic elastic deformation. At the moment, I have a solid with a given density initially responding to the gravity loading, with some pressure boundary at its front. I have a first input file detecting the gravity equilibrium with a given tolerance. Then I use the resulting exodus file for the initial mesh and conditions in my second input file where I want to apply different time-dependent forcings.\nThe steady state detection runs as expected, however once I run the second input file with the exodus file in steady state (with the same boundary conditions), I still get a relatively high initial response before a new steady state is reached. While I would have expected a smooth start without very minor variations in displacement as the system should already be in steady state.\nBelow are the input files for gravity equilibrium and transient evolution. In an attempt to narrow down my problem, the input file for transient evolution doesn't include any additional forcings.\nTwo notes:\n\nTrials at the default steady state tolerance did not solve the problem.\nTransient evolution is properly starting with the mesh and system of the steady state at the last time step.\n\nI built those two input files based on MOOSE examples (especially MASTODON) but I probably missed some conditions/objects or set some parameters with values that are preventing my system from staying in steady state at the restart... I tried to find the solution by myself, but I am now stuck without explanation.\nAny help would be much appreciated! Thank you a lot in advance!\ngravity_equilibrium.i\n# input file initially based on MASTODON Soil_Response.i ex09\n\n# ------------------------ \n\n# slope of the bottom boundary (in degrees)\nbed_slope = 15 \n\n# change coordinate system to add a slope\ngravity_x = ${fparse\n  \t      cos((90 - bed_slope) / 180 * pi) * 9.81\n              } \ngravity_z = ${fparse\n\t      cos(bed_slope / 180 * pi) * 9.81\n              } \n\n# account for slope in BC on displacement  \n# bed_factor_x = ${fparse\n#              \t cos(bed_slope / 180 * pi)\n#                 }\n# bed_factor_z = ${fparse\n# \t         sin(bed_slope / 180 * pi)\n#                 }\n\n# ------------------------\n\n[Mesh]\n  displacements = 'disp_x disp_y disp_z' \n\n  [channel]\n    type = FileMeshGenerator\n    file = channel.e\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  mass_damping_coefficient = 0.2\n  stiffness_damping_coefficient = 0.2\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n[]\n\n[AuxVariables]\n  [vel_x]\n  []\n  [accel_x]\n  []\n  [vel_y]\n  []\n  [accel_y]\n  []\n  [vel_z]\n  []\n  [accel_z]\n  []\n[]\n\n[Kernels]\n  [gravity_x]\n    type = Gravity\n    variable = disp_x\n    value= ${gravity_x}\n    use_displaced_mesh = true\n  []\n  [gravity_y]\n    type = Gravity\n    variable = disp_y\n    value = 0.\n    use_displaced_mesh = true\n  []\n  [gravity_z]\n    type = Gravity\n    variable = disp_z\n    value = -${gravity_z}\n    use_displaced_mesh = true\n  []\n  [DynamicTensorMechanics]\n    displacements = 'disp_x disp_y disp_z'\n    static_initialization = true\n    use_displaced_mesh = true\n  []\n  [inertia_x]\n    type = InertialForce\n    variable = disp_x\n    velocity = vel_x\n    acceleration = accel_x\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n  [inertia_y]\n    type = InertialForce\n    variable = disp_y\n    velocity = vel_y\n    acceleration = accel_y\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n  [inertia_z]\n    type = InertialForce\n    variable = disp_z\n    velocity = vel_z\n    acceleration = accel_z\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n[]\n\n[AuxKernels]\n  [accel_x]\n    type = NewmarkAccelAux\n    variable = accel_x\n    displacement = disp_x\n    velocity = vel_x\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_x]\n    type = NewmarkVelAux\n    variable = vel_x\n    acceleration = accel_x\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_y]\n    type = NewmarkAccelAux\n    variable = accel_y\n    displacement = disp_y\n    velocity = vel_y\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_y]\n    type = NewmarkVelAux\n    variable = vel_y\n    acceleration = accel_y\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_z]\n    type = NewmarkAccelAux\n    variable = accel_z\n    displacement = disp_z\n    velocity = vel_z\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_z]\n    type = NewmarkVelAux\n    variable = vel_z\n    acceleration = accel_z\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n[]\n\n[BCs]\n\n  [front_pressure]\n    type = Pressure\n    boundary = 'downstream'\n    variable = disp_x\n    factor = 2\n  []\n  \n  [anchor_bottom_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom'\n    value = 0.0\n  []  \n  [anchor_botom_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0.0\n  []\n  [anchor_bottom_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom'\n    value = 0.0\n  []\n\n  [anchor_sides_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left right'\n    value = 0.0\n  []\n  [anchor_sides_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'left right'\n    value = 0.\n  []\n  [anchor_sides_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'left right'\n    value = 0.0\n  []\n     \n[]\n  \n[Materials]\n  [elastic_material]\n    # has been designed to simplify multilayer materials\n    type = ComputeIsotropicElasticityTensorSoil\n    layer_variable = '1'\n    layer_ids = '1'\n    poissons_ratio = '0.31'\n    density = '0.9'\n    shear_modulus = '3.8e6'\n  []\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n  []\n  [strain]\n    type = ComputeFiniteStrain\n    displacements = 'disp_x disp_y disp_z'\n  []\n[]\n\n[Preconditioning]\n  [andy]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = '201                hypre    boomeramg      4'\n  start_time = 0.0\n  end_time = 10000.0 # 4.0\n  dt = 0.01 # 0.001\n  dtmin = 0.0001\n  nl_abs_tol = 1e-4\n  nl_rel_tol = 1e-5\n  l_tol = 1e-5\n  l_max_its = 25\n  timestep_tolerance = 1e-8\n\n  steady_state_detection = true\n  steady_state_tolerance = 1e-5 # 1e-8 default\n[]\n\n[Outputs]\n  exodus = true\n  perf_graph = true\n  print_linear_residuals = true\n[]\n\ntransient_state.i\n# input file initially based on MASTODON Soil_Response.i ex09\n\n# ------------------------ \n\n# slope of the bottom boundary (in degrees)\nbed_slope = 15 \n\n# change coordinate system to add a slope\ngravity_x = ${fparse\n  \t      cos((90 - bed_slope) / 180 * pi) * 9.81\n              } \ngravity_z = ${fparse\n\t      cos(bed_slope / 180 * pi) * 9.81\n              } \n\n# account for slope in BC on displacement  \n# bed_factor_x = ${fparse\n#              \t cos(bed_slope / 180 * pi)\n#                 }\n# bed_factor_z = ${fparse\n# \t         sin(bed_slope / 180 * pi)\n#                 }\n\n# ------------------------\n\n[Mesh]\n  displacements = 'disp_x disp_y disp_z' \n\n  [channel]\n    type = FileMeshGenerator\n    file = gravity_equilibrium_out.e\n    use_for_exodus_restart = true\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  mass_damping_coefficient = 0.2\n  stiffness_damping_coefficient = 0.2\n[]\n\n\n[Variables]\n  [disp_x]\n    initial_from_file_var = disp_x\n  []\n  [disp_y]\n    initial_from_file_var = disp_y\n  []\n  [disp_z]\n    initial_from_file_var = disp_z\n  []\n[]\n\n[AuxVariables]\n  [vel_x]\n    initial_from_file_var = vel_x\n  []\n  [accel_x]\n    initial_from_file_var = accel_x\n  []\n  [vel_y]\n    initial_from_file_var = vel_y\n  []\n  [accel_y]\n    initial_from_file_var = accel_y\n  []\n  [vel_z]\n    initial_from_file_var = vel_z\n  []\n  [accel_z]\n    initial_from_file_var = accel_z\n  []\n[]\n\n[Kernels]\n  [gravity_x]\n    type = Gravity\n    variable = disp_x\n    value= ${gravity_x}\n    use_displaced_mesh = true\n  []\n  [gravity_y]\n    type = Gravity\n    variable = disp_y\n    value = 0.\n    use_displaced_mesh = true\n  []\n  [gravity_z]\n    type = Gravity\n    variable = disp_z\n    value = -${gravity_z}\n    use_displaced_mesh = true\n  []\n  [DynamicTensorMechanics]\n    displacements = 'disp_x disp_y disp_z'\n    static_initialization = true\n    use_displaced_mesh = true\n  []\n  [inertia_x]\n    type = InertialForce\n    variable = disp_x\n    velocity = vel_x\n    acceleration = accel_x\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n  [inertia_y]\n    type = InertialForce\n    variable = disp_y\n    velocity = vel_y\n    acceleration = accel_y\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n  [inertia_z]\n    type = InertialForce\n    variable = disp_z\n    velocity = vel_z\n    acceleration = accel_z\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n[]\n\n[AuxKernels]\n  [accel_x]\n    type = NewmarkAccelAux\n    variable = accel_x\n    displacement = disp_x\n    velocity = vel_x\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_x]\n    type = NewmarkVelAux\n    variable = vel_x\n    acceleration = accel_x\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_y]\n    type = NewmarkAccelAux\n    variable = accel_y\n    displacement = disp_y\n    velocity = vel_y\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_y]\n    type = NewmarkVelAux\n    variable = vel_y\n    acceleration = accel_y\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_z]\n    type = NewmarkAccelAux\n    variable = accel_z\n    displacement = disp_z\n    velocity = vel_z\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_z]\n    type = NewmarkVelAux\n    variable = vel_z\n    acceleration = accel_z\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n[]\n\n[BCs]\n\n  [front_pressure]\n    type = Pressure\n    boundary = 'downstream'\n    variable = disp_x\n    factor = 2\n  []\n  \n  [anchor_bottom_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom'\n    value = 0.0\n  []  \n  [anchor_botom_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0.0\n  []\n  [anchor_bottom_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom'\n    value = 0.0\n  []\n\n  [anchor_sides_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left right'\n    value = 0.0\n  []\n  [anchor_sides_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'left right'\n    value = 0.\n  []\n  [anchor_sides_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'left right'\n    value = 0.0\n  []\n     \n[]\n\n[Materials]\n  [elastic_material]\n    # has been designed to simplify multilayer materials\n    type = ComputeIsotropicElasticityTensorSoil\n    layer_variable = '1'\n    layer_ids = '1'\n    poissons_ratio = '0.31'\n    density = '0.9'\n    shear_modulus = '3.8e6'\n  []\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n  []\n  [strain]\n    type = ComputeFiniteStrain\n    displacements = 'disp_x disp_y disp_z'\n  []\n[]\n\n[Preconditioning]\n  [andy]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = '201                hypre    boomeramg      4'\n  start_time = 0.0\n  end_time = 10000.0 # 4.0\n  dt = 0.01 # 0.001\n  dtmin = 0.0001\n  nl_abs_tol = 1e-4\n  nl_rel_tol = 1e-5\n  l_tol = 1e-5\n  l_max_its = 25\n  timestep_tolerance = 1e-8\n[]\n\n[Outputs]\n  exodus = true\n  perf_graph = true\n  print_linear_residuals = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/20399",
          "updatedAt": "2022-07-08T00:11:59Z",
          "publishedAt": "2022-02-24T17:40:52Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCould you please try checkpoint restart and see if you get an initial steady start from the transient?\nSee https://mooseframework.inl.gov/application_usage/restart_recover.html\nRestart from exodus is much harder to achieve, because you run the risk of having forgotten an auxiliary variable (seems fine here), of solving the equations with a different scaling factor (not here) etc.\nAnd checkpoints are much easier to use overall.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2247082",
                  "updatedAt": "2022-07-09T08:29:57Z",
                  "publishedAt": "2022-02-24T21:37:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AdrienWehrle"
                          },
                          "bodyText": "Hi Guillaume,\nthank you a lot for your answer! I modified my input files for checkpoint restart, but unfortunately the same issue remains... Mesh + variables are correctly initialized on restart, but the system moves directly away from the steady state that has been detected in the first simulation...\nPlease find below the updated input files.\nI am new to checkpoints, maybe I didn't set it up properly?\nThank you a lot for your help!\ngravity_equilibrium.i\n# input file initially based on MASTODON Soil_Response.i ex09\n\n# ------------------------ \n\n# slope of the bottom boundary (in degrees)\nbed_slope = 15 \n\n# change coordinate system to add a slope\ngravity_x = ${fparse\n  \t      cos((90 - bed_slope) / 180 * pi) * 9.81\n              } \ngravity_z = ${fparse\n\t      cos(bed_slope / 180 * pi) * 9.81\n              } \n\n# account for slope in BC on displacement  \n# bed_factor_x = ${fparse\n#              \t cos(bed_slope / 180 * pi)\n#                 }\n# bed_factor_z = ${fparse\n# \t         sin(bed_slope / 180 * pi)\n#                 }\n\n# ------------------------\n\n[Mesh]\n  displacements = 'disp_x disp_y disp_z' \n\n  [channel]\n    type = FileMeshGenerator\n    file = channel.e\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  mass_damping_coefficient = 0.2\n  stiffness_damping_coefficient = 0.2\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n[]\n\n[AuxVariables]\n  [vel_x]\n  []\n  [accel_x]\n  []\n  [vel_y]\n  []\n  [accel_y]\n  []\n  [vel_z]\n  []\n  [accel_z]\n  []\n[]\n\n[Kernels]\n  [gravity_x]\n    type = Gravity\n    variable = disp_x\n    value= ${gravity_x}\n    use_displaced_mesh = true\n  []\n  [gravity_y]\n    type = Gravity\n    variable = disp_y\n    value = 0.\n    use_displaced_mesh = true\n  []\n  [gravity_z]\n    type = Gravity\n    variable = disp_z\n    value = -${gravity_z}\n    use_displaced_mesh = true\n  []\n  [DynamicTensorMechanics]\n    displacements = 'disp_x disp_y disp_z'\n    static_initialization = true\n    use_displaced_mesh = true\n  []\n  [inertia_x]\n    type = InertialForce\n    variable = disp_x\n    velocity = vel_x\n    acceleration = accel_x\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n  [inertia_y]\n    type = InertialForce\n    variable = disp_y\n    velocity = vel_y\n    acceleration = accel_y\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n  [inertia_z]\n    type = InertialForce\n    variable = disp_z\n    velocity = vel_z\n    acceleration = accel_z\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n[]\n\n[AuxKernels]\n  [accel_x]\n    type = NewmarkAccelAux\n    variable = accel_x\n    displacement = disp_x\n    velocity = vel_x\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_x]\n    type = NewmarkVelAux\n    variable = vel_x\n    acceleration = accel_x\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_y]\n    type = NewmarkAccelAux\n    variable = accel_y\n    displacement = disp_y\n    velocity = vel_y\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_y]\n    type = NewmarkVelAux\n    variable = vel_y\n    acceleration = accel_y\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_z]\n    type = NewmarkAccelAux\n    variable = accel_z\n    displacement = disp_z\n    velocity = vel_z\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_z]\n    type = NewmarkVelAux\n    variable = vel_z\n    acceleration = accel_z\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n[]\n\n[BCs]\n\n  [front_pressure]\n    type = Pressure\n    boundary = 'downstream'\n    variable = disp_x\n    factor = 2\n  []\n  \n  [anchor_bottom_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom'\n    value = 0.0\n  []  \n  [anchor_botom_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0.0\n  []\n  [anchor_bottom_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom'\n    value = 0.0\n  []\n\n  [anchor_sides_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left right'\n    value = 0.0\n  []\n  [anchor_sides_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'left right'\n    value = 0.\n  []\n  [anchor_sides_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'left right'\n    value = 0.0\n  []\n     \n[]\n  \n[Materials]\n  [elastic_material]\n    # has been designed to simplify multilayer materials\n    type = ComputeIsotropicElasticityTensorSoil\n    layer_variable = '1'\n    layer_ids = '1'\n    poissons_ratio = '0.31'\n    density = '0.9'\n    shear_modulus = '3.8e6'\n  []\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n  []\n  [strain]\n    type = ComputeFiniteStrain\n    displacements = 'disp_x disp_y disp_z'\n  []\n[]\n\n[Preconditioning]\n  [andy]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = '201                hypre    boomeramg      4'\n  start_time = 0.0\n  end_time = 10000.0 # 4.0\n  dt = 0.05 # 0.001\n  dtmin = 0.0001\n  nl_abs_tol = 1e-4\n  nl_rel_tol = 1e-5\n  l_tol = 1e-5\n  l_max_its = 25\n  timestep_tolerance = 1e-8\n\n  steady_state_detection = true\n  steady_state_tolerance = 1e-5 # 1e-8 default\n[]\n\n[Outputs]\n  [checkpoint]\n    type = Checkpoint\n    use_displaced = true\n  []\n  exodus = true\n  perf_graph = true\n  print_linear_residuals = true\n[]\n\n\ntransient_state.i\n# input file initially based on MASTODON Soil_Response.i ex09\n\n# ------------------------ \n\n# slope of the bottom boundary (in degrees)\nbed_slope = 15 \n\n# change coordinate system to add a slope\ngravity_x = ${fparse\n  \t      cos((90 - bed_slope) / 180 * pi) * 9.81\n              } \ngravity_z = ${fparse\n\t      cos(bed_slope / 180 * pi) * 9.81\n              } \n\n# account for slope in BC on displacement  \n# bed_factor_x = ${fparse\n#              \t cos(bed_slope / 180 * pi)\n#                 }\n# bed_factor_z = ${fparse\n# \t         sin(bed_slope / 180 * pi)\n#                 }\n\n# ------------------------\n\n[Mesh]\n  displacements = 'disp_x disp_y disp_z' \n  file = gravity_equilibrium_out.e\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  mass_damping_coefficient = 0.2\n  stiffness_damping_coefficient = 0.2\n[]\n\n\n[Variables]\n  [disp_x]\n    initial_from_file_var =  disp_x\n  []\n  [disp_y]\n      initial_from_file_var =  disp_y\n  []\n  [disp_z]\n      initial_from_file_var =  disp_z\n  []\n[]\n\n[AuxVariables]\n  [vel_x]\n    initial_from_file_var =  vel_x\n  []\n  [accel_x]\n    initial_from_file_var =  accel_x\n  []\n  [vel_y]\n    initial_from_file_var =  vel_y\n  []\n  [accel_y]\n    initial_from_file_var =  accel_y\n  []\n  [vel_z]\n    initial_from_file_var =  vel_z\n  []\n  [accel_z]\n    initial_from_file_var =  accel_z\n  []\n[]\n\n[Kernels]\n  [gravity_x]\n    type = Gravity\n    variable = disp_x\n    value= ${gravity_x}\n    use_displaced_mesh = true\n  []\n  [gravity_y]\n    type = Gravity\n    variable = disp_y\n    value = 0.\n    use_displaced_mesh = true\n  []\n  [gravity_z]\n    type = Gravity\n    variable = disp_z\n    value = -${gravity_z}\n    use_displaced_mesh = true\n  []\n  [DynamicTensorMechanics]\n    displacements = 'disp_x disp_y disp_z'\n    static_initialization = true\n    use_displaced_mesh = true\n  []\n  [inertia_x]\n    type = InertialForce\n    variable = disp_x\n    velocity = vel_x\n    acceleration = accel_x\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n  [inertia_y]\n    type = InertialForce\n    variable = disp_y\n    velocity = vel_y\n    acceleration = accel_y\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n  [inertia_z]\n    type = InertialForce\n    variable = disp_z\n    velocity = vel_z\n    acceleration = accel_z\n    beta = 0.25\n    gamma = 0.5\n    use_displaced_mesh = true\n  []\n[]\n\n[AuxKernels]\n  [accel_x]\n    type = NewmarkAccelAux\n    variable = accel_x\n    displacement = disp_x\n    velocity = vel_x\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_x]\n    type = NewmarkVelAux\n    variable = vel_x\n    acceleration = accel_x\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_y]\n    type = NewmarkAccelAux\n    variable = accel_y\n    displacement = disp_y\n    velocity = vel_y\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_y]\n    type = NewmarkVelAux\n    variable = vel_y\n    acceleration = accel_y\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n  [accel_z]\n    type = NewmarkAccelAux\n    variable = accel_z\n    displacement = disp_z\n    velocity = vel_z\n    beta = 0.25\n    execute_on = timestep_end\n  []\n  [vel_z]\n    type = NewmarkVelAux\n    variable = vel_z\n    acceleration = accel_z\n    gamma = 0.5\n    execute_on = timestep_end\n  []\n[]\n\n[BCs]\n\n  [front_pressure]\n    type = Pressure\n    boundary = 'downstream'\n    variable = disp_x\n    factor = 2\n  []\n  \n  [anchor_bottom_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'bottom'\n    value = 0.0\n  []  \n  [anchor_botom_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0.0\n  []\n  [anchor_bottom_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'bottom'\n    value = 0.0\n  []\n\n  [anchor_sides_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left right'\n    value = 0.0\n  []\n  [anchor_sides_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'left right'\n    value = 0.\n  []\n  [anchor_sides_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'left right'\n    value = 0.0\n  []\n     \n[]\n\n[Materials]\n  [elastic_material]\n    # has been designed to simplify multilayer materials\n    type = ComputeIsotropicElasticityTensorSoil\n    layer_variable = '1'\n    layer_ids = '1'\n    poissons_ratio = '0.31'\n    density = '0.9'\n    shear_modulus = '3.8e6'\n  []\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n  []\n  [strain]\n    type = ComputeFiniteStrain\n    displacements = 'disp_x disp_y disp_z'\n  []\n[]\n\n[Preconditioning]\n  [andy]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = '201                hypre    boomeramg      4'\n  start_time = 0.0\n  end_time = 10000.0 # 4.0\n  dt = 0.01 # 0.001\n  dtmin = 0.0001\n  nl_abs_tol = 1e-4\n  nl_rel_tol = 1e-5\n  l_tol = 1e-5\n  l_max_its = 25\n  timestep_tolerance = 1e-8\n[]\n\n[Outputs]\n  exodus = true\n  perf_graph = true\n  print_linear_residuals = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2249948",
                          "updatedAt": "2022-07-09T08:29:58Z",
                          "publishedAt": "2022-02-25T08:45:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AdrienWehrle"
                          },
                          "bodyText": "I just did some more tests with very tight tolerances and other execution parameters. It unfortunately did not solve the problem so far...",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2251745",
                          "updatedAt": "2022-07-09T08:30:07Z",
                          "publishedAt": "2022-02-25T14:07:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hi Adrien\nThis doesnt seem normal. I would run your inputs files but I dont have your mesh and do not have this ComputeIsotropicElasticityTensorSoil material object either in the tensor mechanics module. I imagine you created it.\nThe only thing I noticed is that the NewmarkVelAux and NewmarkAccelAux do not use the displaced mesh. I'm not sufficiently familiar with the Newmark time integration method, could that be the issue?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2263722",
                          "updatedAt": "2022-07-09T08:30:07Z",
                          "publishedAt": "2022-02-28T07:18:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "AdrienWehrle"
                  },
                  "bodyText": "Hi Guillaume,\nI wanted to attach my mesh but GIthub doesn't support exodus files for attachments.. I will think of a way to share it with you! ComputeIsotropicElasticityTensorSoil is from MASTODON, see here.\n\nThe only thing I noticed is that the NewmarkVelAux and NewmarkAccelAux do not use the displaced mesh. I'm not sufficiently familiar with the Newmark time integration method, could that be the issue?\n\nOh thank you, I will check and let you know!\nThank you a lot!",
                  "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2263741",
                  "updatedAt": "2022-07-09T08:30:09Z",
                  "publishedAt": "2022-02-28T07:22:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AdrienWehrle"
                          },
                          "bodyText": "So I just added my mesh in my fork of MOOSE, here. (channel.e)",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2263797",
                          "updatedAt": "2022-07-09T08:30:10Z",
                          "publishedAt": "2022-02-28T07:33:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Thanks I ll try it out tomorrow!",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2263832",
                          "updatedAt": "2022-07-09T08:30:10Z",
                          "publishedAt": "2022-02-28T07:46:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "nl_abs_tol = 1e-4\n  nl_rel_tol = 1e-5\n\nthe second one seems really coarse. I m getting timesteps accepted with a 100 residual for the steady case. Even if it does end up stabilizing and meeting the steady-state criterion, the transient should also converge each step if we want to see steadiness. I ll look at that in more details",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2263849",
                          "updatedAt": "2022-07-09T08:30:10Z",
                          "publishedAt": "2022-02-28T07:50:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AdrienWehrle"
                          },
                          "bodyText": "I did some tests with nl_abs_tol = 1e-12 nd nl_rel_tol = 1e-7 and could  get rid of large residuals (and no more warning) but still a similar response on restart...",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2263892",
                          "updatedAt": "2022-07-11T08:26:46Z",
                          "publishedAt": "2022-02-28T07:58:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AdrienWehrle"
                          },
                          "bodyText": "The only thing I noticed is that the NewmarkVelAux and NewmarkAccelAux do not use the displaced mesh. I'm not sufficiently familiar with the Newmark time integration method, could that be the issue?\n\nInteresting, when I use the displaced mesh on NewmarkVelAux and NewmarkAccelAux, the system is simply blowing up...! So there is definitely something here.",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2264079",
                          "updatedAt": "2022-07-11T08:26:44Z",
                          "publishedAt": "2022-02-28T08:37:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AdrienWehrle"
                          },
                          "bodyText": "Another interesting note: on restart it's responding but then reaching another steady state, different to the one reached in the steady state detection. As if there were different local minima reached during the solve....",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2265476",
                          "updatedAt": "2022-07-11T08:26:46Z",
                          "publishedAt": "2022-02-28T12:55:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you paste your convergence history (the output log)?\nMy opinion is that the steady state has not been reached at the end of the steady.i run. I'm trying to see if I can converge it now\nEDIT: ok I see the jump now. Seems larger than what this hypothesis would allow",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2266388",
                          "updatedAt": "2022-07-11T08:26:46Z",
                          "publishedAt": "2022-02-28T15:05:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "In the MASTODON examples ( 6 & 13 ), NewmarkVel and AccelAux arent used with use_displaced_mesh = true so I think this isnt likely to be the problem.\nI ll tag @cbolisetti for awareness of what we're trying",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2266425",
                          "updatedAt": "2022-07-11T08:26:46Z",
                          "publishedAt": "2022-02-28T15:10:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "Can either of you share the input file? We have had some problems with steady state analysis and I tried to fix some of the issues in the past. Let me see if I can help.",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2266607",
                          "updatedAt": "2022-07-11T08:26:47Z",
                          "publishedAt": "2022-02-28T15:37:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The input for steady and transients are in the first post above, and the mesh is in the first comment of this reply\nI m running a more converged simulation rn (steady state at 1e-8), with automatic scaling which seems to help as well",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2266612",
                          "updatedAt": "2022-07-11T08:26:48Z",
                          "publishedAt": "2022-02-28T15:38:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "cbolisetti"
                  },
                  "bodyText": "@AdrienWehrle and @GiudGiud, I was using my iPad app earlier and I didn't notice the earlier part of the thread with the input files. I now see that you are trying to run a gravity analysis using restart. We don't usually use restart analysis for the gravity step. We use the controls block to switch off the inertia kernel and other time-derivative-dependent terms (damping, for instance) in the first 2 time steps. This makes sure that a static analysis is performed at these time steps and the inertia kernels are switched on when needed. I think this is a much simpler way to perform gravity analysis. We have an example that shows this: https://mooseframework.inl.gov/mastodon/examples/example14.html\nThere is a note that specifically talks about gravity. Please let me know if this method works for you. If not, I can try to help.",
                  "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2268570",
                  "updatedAt": "2022-07-09T08:30:11Z",
                  "publishedAt": "2022-02-28T20:46:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AdrienWehrle"
                          },
                          "bodyText": "Woh, thank you a lot @cbolisetti! It works like a charm and is way more efficient than a steady state detection in that case! Thank you a lot also @GiudGiud for your precious help!",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2272518",
                          "updatedAt": "2022-07-09T08:30:12Z",
                          "publishedAt": "2022-03-01T11:24:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "Excellent! Please let us know if you need anything else.",
                          "url": "https://github.com/idaholab/moose/discussions/20399#discussioncomment-2273824",
                          "updatedAt": "2022-07-09T08:30:13Z",
                          "publishedAt": "2022-03-01T14:57:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error with making project",
          "author": {
            "login": "Salma-Mao"
          },
          "bodyText": "Dear everyone,\nI am new to MOOSE. When I am trying to compile the project IN100-111grn.i , I am  getting:\n\nHowever, I can make the other project  successfully before this. I do not what is the matter. What can I do to resolve this problem.",
          "url": "https://github.com/idaholab/moose/discussions/20417",
          "updatedAt": "2022-06-15T20:08:45Z",
          "publishedAt": "2022-02-28T14:21:50Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "In the future, please do not post screenshots of text. Please copy and paste the text into a code block. This makes it possible for future users to search for your error (cannot parse images).\nLooks like your application \"ebsd\" does not have the phase field module (which contains those missing headers) enabled. You should have something like:\n################################## MODULES ####################################\nPHASE_FIELD             := yes\n\nin your application Makefile.",
                  "url": "https://github.com/idaholab/moose/discussions/20417#discussioncomment-2266419",
                  "updatedAt": "2022-06-15T20:08:46Z",
                  "publishedAt": "2022-02-28T15:09:38Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Salma-Mao"
                          },
                          "bodyText": "Thanks for your help. I accept your advice and do it  in the future. My application \"ebsd\" have enabled  the phase field module. However, I get the other problem.\nCreating Unity /usr/local/workspace/ebsd/build/unity_src/auxkernels_Unity.C\nLinking Library /opt/moose/modules/chemical_reactions/lib/libchemical_reactions-opt.la...\nLinking Library /opt/moose/modules/external_petsc_solver/lib/libexternal_petsc_solver-opt.la...\nLinking Library /opt/moose/modules/fluid_properties/lib/libfluid_properties-opt.la...\nLinking Library /opt/moose/modules/functional_expansion_tools/lib/libfunctional_expansion_tools-opt.la...\nLinking Library /opt/moose/modules/geochemistry/lib/libgeochemistry-opt.la...\nLinking Library /opt/moose/modules/level_set/lib/liblevel_set-opt.la...\nLinking Library /opt/moose/modules/ray_tracing/lib/libray_tracing-opt.la...\nLinking Library /opt/moose/modules/rdg/lib/librdg-opt.la...\nLinking Library /opt/moose/modules/reactor/lib/libreactor-opt.la...\nLinking Library /opt/moose/modules/richards/lib/librichards-opt.la...\nLinking Library /opt/moose/modules/stochastic_tools/lib/libstochastic_tools-opt.la...\nLinking Library /opt/moose/modules/heat_conduction/lib/libheat_conduction-opt.la...\nLinking Library /opt/moose/modules/tensor_mechanics/lib/libtensor_mechanics-opt.la...\nLinking Library /opt/moose/modules/navier_stokes/lib/libnavier_stokes-opt.la...\nLinking Library /opt/moose/modules/contact/lib/libcontact-opt.la...\nLinking Library /opt/moose/modules/fsi/lib/libfsi-opt.la...\nLinking Library /opt/moose/modules/misc/lib/libmisc-opt.la...\nLinking Library /opt/moose/modules/peridynamics/lib/libperidynamics-opt.la...\nLinking Library /opt/moose/modules/phase_field/lib/libphase_field-opt.la...\nLinking Library /opt/moose/modules/porous_flow/lib/libporous_flow-opt.la...\nLinking Library /opt/moose/modules/thermal_hydraulics/lib/libthermal_hydraulics-opt.la...\nCompiling C++ (in opt mode) /usr/local/workspace/ebsd/build/unity_src/auxkernels_Unity.C...\nLinking Library /opt/moose/modules/xfem/lib/libxfem-opt.la...\nLinking Library /opt/moose/modules/combined/lib/libcombined-opt.la...\nLinking Library /opt/moose/modules/module_loader/lib/libmodule_loader_with_cr_eps_fp_fet_gc_ls_ray_rdg_rct_rich_st_hc_tm_ns_con_fsi_misc_pd_pf_pflow_th_xfem_comb-opt.la...\nLinking Library /usr/local/workspace/ebsd/test/lib/libebsd_test-opt.la...\nLinking Library /usr/local/workspace/ebsd/lib/libebsd-opt.la...\nLinking Executable /usr/local/workspace/ebsd/ebsd-opt...\n/usr/bin/ld: /usr/local/workspace/ebsd/test/lib/libebsd_test-opt.so: undefined reference to `MooseApp::checkRegistryLabels()'\ncollect2: error: ld returned 1 exit status\nmake: *** [/opt/moose/framework/app.mk:407: /usr/local/workspace/ebsd/ebsd-opt] Error 1\n\nMooseApp::checkRegistryLabels() is not found in the files. What can I do to resolve this problem.\nThanks\nMS",
                          "url": "https://github.com/idaholab/moose/discussions/20417#discussioncomment-2269920",
                          "updatedAt": "2022-06-15T20:08:50Z",
                          "publishedAt": "2022-03-01T02:19:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you try to make clobberall then try to compile again?",
                          "url": "https://github.com/idaholab/moose/discussions/20417#discussioncomment-2269969",
                          "updatedAt": "2022-07-14T03:07:30Z",
                          "publishedAt": "2022-03-01T02:28:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Salma-Mao"
                          },
                          "bodyText": "I have tried  this approach. But, I get\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/src_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/executors_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/postprocessors_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/timeintegrators_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/predictors_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/fvbcs_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/preconditioners_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/samplers_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/fvkernels_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/systems_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/geomsearch_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/mesh_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/auxkernels_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/kernels_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/variables_Unity.C...\nCompiling C++ (in opt mode) /opt/moose/framework/build/unity_src/partitioner_Unity.C...\ng++: fatal error: Killed signal terminated program cc1plus\ncompilation terminated.\nmake: *** [/opt/moose/framework/build.mk:144: /opt/moose/framework/build/unity_src/systems_Unity.x86_64-pc-linux-gnu.opt.lo] Error 1\nmake: *** Waiting for unfinished jobs....",
                          "url": "https://github.com/idaholab/moose/discussions/20417#discussioncomment-2270162",
                          "updatedAt": "2022-07-14T03:07:30Z",
                          "publishedAt": "2022-03-01T03:03:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok see below",
                          "url": "https://github.com/idaholab/moose/discussions/20417#discussioncomment-2270247",
                          "updatedAt": "2022-08-29T20:59:07Z",
                          "publishedAt": "2022-03-01T03:24:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "After looking at your response below, I think Guillaume may be on to something.  Your compile failed this time most likely because you ran out of memory. Try compiling again with a fewer number of jobs. If it passes - woo! If it fails, hopefully it's the same error.",
                          "url": "https://github.com/idaholab/moose/discussions/20417#discussioncomment-2270278",
                          "updatedAt": "2022-08-29T20:59:39Z",
                          "publishedAt": "2022-03-01T03:32:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Salma-Mao"
                          },
                          "bodyText": "Thanks for your advice. I compile the project on the other computer with more memory. It passes. Thanks again.",
                          "url": "https://github.com/idaholab/moose/discussions/20417#discussioncomment-2270790",
                          "updatedAt": "2022-08-29T20:59:42Z",
                          "publishedAt": "2022-03-01T06:13:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "How long ago have did you stork your application? Can you show the contents of EBSDApp.C and EBSDTestApp.C? MooseApp::checkRegistryLabels() is no longer used.",
                  "url": "https://github.com/idaholab/moose/discussions/20417#discussioncomment-2269981",
                  "updatedAt": "2022-07-14T03:07:36Z",
                  "publishedAt": "2022-03-01T02:30:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Salma-Mao"
                          },
                          "bodyText": "The EBSDApp.C\n#include \"EBSDApp.h\"\n#include \"Moose.h\"\n#include \"AppFactory.h\"\n#include \"ModulesApp.h\"\n#include \"MooseSyntax.h\"\n\nInputParameters\nEBSDApp::validParams()\n{\nInputParameters params = MooseApp::validParams();\n\n// Do not use legacy material output, i.e., output properties on INITIAL as well as TIMESTEP_END\nparams.set<bool>(\"use_legacy_material_output\") = false;\n\nreturn params;\n}\n\nEBSDApp::EBSDApp(InputParameters parameters) : MooseApp(parameters)\n{\nEBSDApp::registerAll(_factory, _action_factory, _syntax);\n}\n\nEBSDApp::~EBSDApp() {}\n\nvoid\nEBSDApp::registerAll(Factory & f, ActionFactory & af, Syntax & syntax)\n{\nModulesApp::registerAll(f, af, syntax);\nRegistry::registerObjectsTo(f, {\"EBSDApp\"});\nRegistry::registerActionsTo(af, {\"EBSDApp\"});\n\n/* register custom execute flags, action syntax, etc. here */\n}\n\nvoid\nEBSDApp::registerApps()\n{\nregisterApp(EBSDApp);\n}\n\n/***************************************************************************************************\n*********************** Dynamic Library Entry Points - DO NOT MODIFY ******************************\n**************************************************************************************************/\nextern \"C\" void\nEBSDApp__registerAll(Factory & f, ActionFactory & af, Syntax & s)\n{\nEBSDApp::registerAll(f, af, s);\n}\nextern \"C\" void\nEBSDApp__registerApps()\n{\nEBSDApp::registerApps();\n}\n\nThe EBSDTestApp.C\n#include \"EBSDTestApp.h\"\n#include \"EBSDApp.h\"\n#include \"Moose.h\"\n#include \"AppFactory.h\"\n#include \"MooseSyntax.h\"\n#include \"ModulesApp.h\"\n\nInputParameters\nEBSDTestApp::validParams()\n{\n  InputParameters params = EBSDApp::validParams();\n  return params;\n}\n\nEBSDTestApp::EBSDTestApp(InputParameters parameters) : MooseApp(parameters)\n{\n  EBSDTestApp::registerAll(\n      _factory, _action_factory, _syntax, getParam<bool>(\"allow_test_objects\"));\n}\n\nEBSDTestApp::~EBSDTestApp() {}\n\nvoid\nEBSDTestApp::registerAll(Factory & f, ActionFactory & af, Syntax & s, bool use_test_objs)\n{\n  EBSDApp::registerAll(f, af, s);\n  if (use_test_objs)\n  {\n    Registry::registerObjectsTo(f, {\"EBSDTestApp\"});\n    Registry::registerActionsTo(af, {\"EBSDTestApp\"});\n  }\n}\n\nvoid\nEBSDTestApp::registerApps()\n{\n  registerApp(EBSDApp);\n  registerApp(EBSDTestApp);\n}\n\n/***************************************************************************************************\n *********************** Dynamic Library Entry Points - DO NOT MODIFY ******************************\n **************************************************************************************************/\n// External entry point for dynamic application loading\nextern \"C\" void\nEBSDTestApp__registerAll(Factory & f, ActionFactory & af, Syntax & s)\n{\n  EBSDTestApp::registerAll(f, af, s);\n}\nextern \"C\" void\nEBSDTestApp__registerApps()\n{\n  EBSDTestApp::registerApps();\n}",
                          "url": "https://github.com/idaholab/moose/discussions/20417#discussioncomment-2270157",
                          "updatedAt": "2022-07-14T03:07:38Z",
                          "publishedAt": "2022-03-01T03:01:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}