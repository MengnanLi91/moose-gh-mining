{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wMy0yM1QxNDo1ODowNy0wNTowMM4AS98j"
    },
    "edges": [
      {
        "node": {
          "title": "F-norm",
          "author": {
            "login": "nanguaxiaofendui"
          },
          "bodyText": "Hello all\uff0c\nI have two questions:\n1.Can the user provide the preprocessor pmat?\n2.How to output matrix norm?\nthanks",
          "url": "https://github.com/idaholab/moose/discussions/23851",
          "updatedAt": "2023-04-29T03:06:23Z",
          "publishedAt": "2023-03-27T06:24:32Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPlease don't post twice the same question. I'm deleting the other one.\nThese answers are likely in the petsc manual, you can pass arguments to petsc\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23851#discussioncomment-5440468",
                  "updatedAt": "2023-03-27T12:38:39Z",
                  "publishedAt": "2023-03-27T12:38:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "nanguaxiaofendui"
                          },
                          "bodyText": "thank you",
                          "url": "https://github.com/idaholab/moose/discussions/23851#discussioncomment-5440488",
                          "updatedAt": "2023-03-27T12:40:32Z",
                          "publishedAt": "2023-03-27T12:40:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Interface kernel advice needed",
          "author": {
            "login": "joe61vette"
          },
          "bodyText": "Hello:\nIn one block I have a temperature variable that is \"constant monomial\".  In an adjacent block, a different temperature variable is \"first Lagrange\".  Both are FEM, so I am not mixing FEM and FVM.\nI would like to place something like an interface kernel between the two blocks to allow conduction heat transfer across the boundary.  Is there an existing interface kernel for such a case?  Is there an example somewhere for something like this?\nThanks,\nJoe Kelly",
          "url": "https://github.com/idaholab/moose/discussions/23842",
          "updatedAt": "2023-04-29T03:06:38Z",
          "publishedAt": "2023-03-25T21:09:09Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Hello:\nIn one block I have a temperature variable that is \"constant monomial\".  In an adjacent block, a different temperature variable is \"first Lagrange\".  Both are FEM, so I am not mixing FEM and FVM.\nI would like to place something like an interface kernel between the two blocks to allow conduction heat transfer across the boundary.  Is there an existing interface kernel for such a case?  Is there an example somewhere for something like this?\nThanks,\nJoe Kelly\n\nDepends on your problems, you can use either thermal contact https://mooseframework.inl.gov/modules/combined/tutorials/introduction/step01.html or thin layer heat transfer https://mooseframework.inl.gov/moose/source/interfacekernels/ThinLayerHeatTransfer.html",
                  "url": "https://github.com/idaholab/moose/discussions/23842#discussioncomment-5428928",
                  "updatedAt": "2023-03-25T21:33:57Z",
                  "publishedAt": "2023-03-25T21:33:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Thanks Wen.  Do you know if either of these work when the variables are of different types?  I basically have DG on one side and CFEM on the other side.  I am about to quit for today and will give this a try tomorrow.",
                          "url": "https://github.com/idaholab/moose/discussions/23842#discussioncomment-5428962",
                          "updatedAt": "2023-03-25T21:44:19Z",
                          "publishedAt": "2023-03-25T21:44:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Thanks Wen.  Do you know if either of these work when the variables are of different types?  I basically have DG on one side and CFEM on the other side.  I am about to quit for today and will give this a try tomorrow.\n\nTheroetically, I do not see any issues with coupling different types of elements.  However, I believe this has not been tested before,  so you might have some troubles there.  Let us know what you find out.",
                          "url": "https://github.com/idaholab/moose/discussions/23842#discussioncomment-5429000",
                          "updatedAt": "2023-03-25T21:54:11Z",
                          "publishedAt": "2023-03-25T21:54:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joe61vette"
                  },
                  "bodyText": "I have tried three approaches without success.  The input files are attached.\ninterface.zip\nInterfaceTester.i : uses an internal sideset between the 2 blocks. Mesh is not split.  SideSetHeatTransferKernel is used. Result is non-convergence due to a ZEROPIVOT.\nInterfaceTester_2.i :  Mesh is split.  ThinLayerHeatTransfer is used. Result is a segfault.\nInterfaceTester_3.i : uses an internal sideset between the 2 blocks. Mesh is not split.  InterfaceDiffusion is used. Result is non-convergence due to a ZEROPIVOT.\nAny ideas?\nThanks.",
                  "url": "https://github.com/idaholab/moose/discussions/23842#discussioncomment-5432279",
                  "updatedAt": "2023-03-26T15:12:33Z",
                  "publishedAt": "2023-03-26T15:12:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Tying this to the other thread: #23846\nSeg fault in test case 2 is definitely a problem. We'll fix it\nFor 1 and 3, please see the other thread.",
                          "url": "https://github.com/idaholab/moose/discussions/23842#discussioncomment-5435015",
                          "updatedAt": "2023-03-27T01:13:21Z",
                          "publishedAt": "2023-03-27T01:05:22Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Shape Functions and Node",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "Within an element, are the order of the nodes and the order of the shape functions the same? If I know that a node is the third node of the element, does the third \"phi\" correspond to that node?",
          "url": "https://github.com/idaholab/moose/discussions/23841",
          "updatedAt": "2023-03-25T21:05:55Z",
          "publishedAt": "2023-03-25T20:21:24Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "Within an element, are the order of the nodes and the order of the shape functions the same? If I know that a node is the third node of the element, does the third \"phi\" correspond to that node?\n\nThat should be the case.\n@maxnezdyur btw, are you a hurricane fan?",
                  "url": "https://github.com/idaholab/moose/discussions/23841#discussioncomment-5428837",
                  "updatedAt": "2023-03-25T21:03:54Z",
                  "publishedAt": "2023-03-25T21:03:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Perfect, that's what I was hoping for. Of course, always supporting my Canes.",
                          "url": "https://github.com/idaholab/moose/discussions/23841#discussioncomment-5428842",
                          "updatedAt": "2023-03-25T21:05:52Z",
                          "publishedAt": "2023-03-25T21:05:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "BAD TERMINATION",
          "author": {
            "login": "Richard-happy"
          },
          "bodyText": "Hello,when I ran my input file, it was OK using 202020 mesh. However, it seemed someting went wrong when using 505050 mesh.Here is the report.\n===================================================================================\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   PID 13193 RUNNING AT ml64\n=   EXIT CODE: 9\n=   CLEANING UP REMAINING PROCESSES\n=   YOU CAN IGNORE THE BELOW CLEANUP MESSAGES\n===================================================================================\nYOUR APPLICATION TERMINATED WITH THE EXIT STRING: Killed (signal 9)\nThis typically refers to a problem with your application.\nPlease see the FAQ page for debugging suggestions\n\nAnd my input file is appended.\nnonlinear_TE.txt",
          "url": "https://github.com/idaholab/moose/discussions/23836",
          "updatedAt": "2023-03-25T10:46:02Z",
          "publishedAt": "2023-03-24T13:49:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cticenhour"
                  },
                  "bodyText": "Using your input, a simulation with a 50x50x50 mesh contains quite a large number of nonlinear DoFs (530,000+) and over 1.5 million auxiliary DoFs. My first guess would be that you ran out of memory on your machine.  I ran this input over 10 cores on a laptop with 64GB of RAM, and it was quickly filled up.\nMy suggestion is to coarsen the mesh to something less than 50x50x50. For a simple input like you've shown here, you should be able to get by with something much less fine. If you end up deciding that refinement is necessary as your input file becomes more complex, look into mesh adaptivity or running this on a higher memory machine (like a cluster or HPC system).",
                  "url": "https://github.com/idaholab/moose/discussions/23836#discussioncomment-5420716",
                  "updatedAt": "2023-03-24T16:41:30Z",
                  "publishedAt": "2023-03-24T16:41:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Richard-happy"
                          },
                          "bodyText": "OK, thank you for your suggestion, cticenhour",
                          "url": "https://github.com/idaholab/moose/discussions/23836#discussioncomment-5425905",
                          "updatedAt": "2023-03-25T10:45:56Z",
                          "publishedAt": "2023-03-25T10:45:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Solve Did NOT Converge when the BC for simple diffusion problem is large",
          "author": {
            "login": "lipxisi"
          },
          "bodyText": "Hello\nI create a simple diffusion problem like example02 where the diffusion coefficient and absorption coefficient are 0.008 and 0.085. At runtime, it is found that when the bottom boundary is very large for example, the bottom is 1e10 and no top BC, the calculation does not converge but it converges when it's less than a certain value like 1e6. Supposedly, the value at the bottom only magnifies or diminishes the calculated result, and will not affect the convergence. So  why it doesn't converge when the boundary conditions are large, and how to solve these problems. In addition, I want to ask what the terminal output 17 Linear |R| = 6.686767e+03 and 200 Nonlinear |R| = 4.442370e+08 represent.\nThanks very much",
          "url": "https://github.com/idaholab/moose/discussions/23827",
          "updatedAt": "2023-03-24T22:43:20Z",
          "publishedAt": "2023-03-23T09:05:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\ncan you turn on automatic scaling in the executioner block?\nthere are other threads that explain what the residual is, I ll try to paste one later today\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23827#discussioncomment-5406833",
                  "updatedAt": "2023-03-23T14:20:20Z",
                  "publishedAt": "2023-03-23T14:20:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lipxisi"
                  },
                  "bodyText": "Thanks Guillaume\nI used automatic_scaling = true, nl_rel_tol=1e-04 and nl_abs_tol=1e-04, then the problem converging.\n2363 Nonlinear |R| = 5.338276e+07\n0 Linear |R| = 5.338276e+07\n1 Linear |R| = 2.127353e+06\n2 Linear |R| = 4.831955e+05\n3 Linear |R| = 1.575160e+05\n4 Linear |R| = 5.433509e+04\n5 Linear |R| = 2.601507e+04\n6 Linear |R| = 1.455736e+04\n7 Linear |R| = 8.501569e+03\n8 Linear |R| = 5.372774e+03\n9 Linear |R| = 3.722465e+03\n10 Linear |R| = 3.015211e+03\n11 Linear |R| = 2.499467e+03\n12 Linear |R| = 1.227849e+03\n13 Linear |R| = 2.657926e+02\n2364 Nonlinear |R| = 2.766357e+06\nSolve Converged!\nSo what is the mean of  2364 Nonlinear |R| = 2.766357e+06, whether the converging is valid or not.",
                  "url": "https://github.com/idaholab/moose/discussions/23827#discussioncomment-5417641",
                  "updatedAt": "2023-03-24T12:53:47Z",
                  "publishedAt": "2023-03-24T12:53:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The petsc manual is the best reference for the meaning of the non linear residual\nhttps://petsc.org/release/docs/manual/snes/",
                          "url": "https://github.com/idaholab/moose/discussions/23827#discussioncomment-5423455",
                          "updatedAt": "2023-03-24T22:43:21Z",
                          "publishedAt": "2023-03-24T22:43:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Forcing function using an Aux Variable",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "for a transient heat transfer problem can I update the value of my variable in my problem domain prior to the next time step, with the value of an aux variable value at the nearest neighboring mesh and then solve the next time step with the imposed value?",
          "url": "https://github.com/idaholab/moose/discussions/23835",
          "updatedAt": "2023-04-29T03:07:21Z",
          "publishedAt": "2023-03-24T05:51:36Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe typically do not allow modifying nonlinear variable values but you can do it using a MultiApp. You send the value you want to impose then send them back using a transfer.\nThe cannon way to do this would be to write a UserObject that modifies the nonlinear variables. We dont have one that can do what you want afaik\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23835#discussioncomment-5417109",
                  "updatedAt": "2023-03-24T11:52:52Z",
                  "publishedAt": "2023-03-24T11:52:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "I was able to use the MultiApp to transfer between APPs. I noticed that the transferred value smears the solutions and seems to override the contribution of the original solutions.",
                          "url": "https://github.com/idaholab/moose/discussions/23835#discussioncomment-5420034",
                          "updatedAt": "2023-03-24T15:42:43Z",
                          "publishedAt": "2023-03-24T15:42:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Here is a snapshot of what the solutions look like.",
                          "url": "https://github.com/idaholab/moose/discussions/23835#discussioncomment-5420522",
                          "updatedAt": "2023-03-24T16:22:33Z",
                          "publishedAt": "2023-03-24T16:22:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Well whether it smears or not depends on the algorithm in the transfer\nIf you use the exact same mesh and the exact same variable type (finitelement family and order) the copy transfer will not smear",
                          "url": "https://github.com/idaholab/moose/discussions/23835#discussioncomment-5423036",
                          "updatedAt": "2023-03-24T21:26:17Z",
                          "publishedAt": "2023-03-24T21:26:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Coding dirichletbc from material property",
          "author": {
            "login": "vermaprk"
          },
          "bodyText": "I have written the include and src files for executing Dirichlet boundary condition taking values from material property. This runs well on simple problems. However, this is leading to convergence issues for complex problems. I have used IntegratedBC as the parent class. Please look into my code (attached)\nheader file\n#pragma once\n\n#include \"IntegratedBC.h\"\n\nclass EgMatDirichlet : public IntegratedBC\n{\npublic:\n  EgMatDirichlet(const InputParameters & parameters);\n\n  static InputParameters validParams();\n\nprotected:\n  virtual Real computeQpResidual() override;\n\nprivate:\n  const MaterialProperty<Real> & _boundary_prop;\n};\n\nsrc file\n#include \"EgMatDirichlet.h\"\n\nregisterMooseObject(\"goldfishApp\", EgMatDirichlet);\n\nInputParameters\nEgMatDirichlet::validParams()\n{\n  InputParameters params = IntegratedBC::validParams();\n\n  // Specify input parameters that we want users to be able to set:\n  params.addRequiredParam<MaterialPropertyName>(\"boundary_material\", \"Value on the boundary\");\n  return params;\n}\n\nEgMatDirichlet::EgMatDirichlet(const InputParameters & parameters)\n  : IntegratedBC(parameters),\n    // store the user-specified parameters from the input file...\n    _boundary_prop(getMaterialProperty<Real>(\"boundary_material\"))\n    \n{\n}\n\nReal\nEgMatDirichlet::computeQpResidual()\n{\n  \n  return _boundary_prop[_qp] - _u[_qp];\n}",
          "url": "https://github.com/idaholab/moose/discussions/23797",
          "updatedAt": "2023-03-27T04:11:50Z",
          "publishedAt": "2023-03-21T06:47:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nYou are missing the contribution to the Jacobian. Does it converge with PJFNK for the solve_type?\nYou should just use AD to make this boundary condition and it will handle that part if you want to make it work with Newton\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5382970",
                  "updatedAt": "2023-03-21T15:51:10Z",
                  "publishedAt": "2023-03-21T15:51:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Yes, it converges with PJFNK for a simple diffusion problem. However, when i have two coupled equations is fails to converge.\nAs per your suggestion I have used AD with PJFNK solver. It converges now, however computation time is too long.",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5389402",
                          "updatedAt": "2023-03-22T07:02:01Z",
                          "publishedAt": "2023-03-22T07:02:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "It looks like you are using an integrated BC class to set a Dirichlet BC. I think you need a penalty parameter to have the values match closer. You will also need to multiply by the test function.  Try the below:\nreturn _penalty * _test[_i][_qp] * (_u[_qp] - _boundary_prop[_qp]); where _penalty is a large number like 1e7 (problem dependent).",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5391786",
                          "updatedAt": "2023-03-22T11:10:59Z",
                          "publishedAt": "2023-03-22T11:10:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Yes, I am using ADIntegratedBC class as for ADNodalBC I couldn't find the getADMaterialProperty<Real> as a Public Member Function.\nIs there a way to do this for ADNodalBC ? (I have a limited knowledge of C++)\nI tried your method, but this also leads to non-convergence for the simple diffusion problem\nADReal\nADEgMatDirichlet::computeQpResidual()\n{\n  Real penalty = 1e7;\n  return penalty * _test[_i][_qp] * (_u[_qp] - _boundary_prop[_qp]);\n}\n\nmy input file for simple diffusion:\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    xmin = 0\n    xmax = 200e-6\n    nx = 200\n[]\n  \n[Variables]\n    [c]\n    []\n[]\n\n# Initial conditions.\n[ICs]\n    [conc]\n        variable = c\n        type = FunctionIC\n        function = ic_func_c\n    []\n[]\n\n[BCs]\n    [left_c]\n        type = DirichletBC\n        variable = c\n        boundary = 'left'\n        value = 1000\n    []\n    [right_c]\n        type = ADEgMatDirichlet\n        variable = c\n        boundary = 'right'\n        boundary_material=bndconst\n    []\n[]\n  \n[Functions]\n    [ic_func_c]\n        type = ParsedFunction\n        expression = 1000\n    []\n[]\n  \n[Kernels]\n    [cdot]\n        type = TimeDerivative\n        variable = c\n    []\n    [c_diff]\n        type=MatDiffusion\n        diffusivity= 7.5e-11\n        variable = c\n    []\n[]\n\n\n[Materials]\n    [matconstant]\n        type = ADGenericConstantMaterial\n        prop_names = 'bndconst'\n        prop_values = '300'\n    []\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'PJFNK'\n    dt=2\n    end_time = 200\n[]\n\n[Postprocessors]\n    [left_c]\n      type = PointValue\n      point = '0 0 0'\n      variable = c\n    []\n    [right_phi]\n      type = PointValue\n      point = '200e-6 0 0'\n      variable = c\n    []\n  \n  []\n[Outputs]\n    exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5393414",
                          "updatedAt": "2023-03-22T13:55:25Z",
                          "publishedAt": "2023-03-22T13:55:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Material properties aren\u2019t well defined on nodes because nodes can be shared between subdomains and we wouldn\u2019t know which subdomain to pick to evaluate the property (their expression can vary by subdomain)\nhence why there is not getMatProp on nodal classes\nnow that you are using AD, does Newton converge with the old integrated BC?",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5393539",
                          "updatedAt": "2023-03-22T14:06:26Z",
                          "publishedAt": "2023-03-22T14:06:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Thanks for the help.\nNewton converges for the diffusion problem. However the constant material property value 300 is showing in postprocessor as 2.999999e+02 :\ntime           | left_c         | right_c        |\n+----------------+----------------+----------------+\n:                :                :                :\n|   1.905000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.907500e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.912500e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.915000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.920000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.925000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.935000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.945000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.950000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.960000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.980000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.990000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.992500e+02 |   1.000000e+03 |   2.999999e+02 |\n|   1.995000e+02 |   1.000000e+03 |   2.999999e+02 |\n|   2.000000e+02 |   1.000000e+03 |   2.999999e+02 |\n\nHowever, in case of my original problem newton doesn't converges at all.\nPJFNK works well with DirichletBC and the computation time is almost double for ADEgMatDirichlet",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5400386",
                          "updatedAt": "2023-03-23T04:50:41Z",
                          "publishedAt": "2023-03-23T04:27:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in ADEgMatDirichlet, how do you retrieve the material property?\nIs this an AD material property? If not you re still missing terms in the Jacobian",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5400427",
                          "updatedAt": "2023-03-23T04:35:55Z",
                          "publishedAt": "2023-03-23T04:35:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "vermaprk"
                  },
                  "bodyText": "ADEgMatDirichlet.C\n#include \"ADEgMatDirichlet.h\"\n\nregisterMooseObject(\"goldfishApp\", ADEgMatDirichlet);\n\nInputParameters\nADEgMatDirichlet::validParams()\n{\n  InputParameters params = ADIntegratedBC::validParams();\n\n  // Specify input parameters that we want users to be able to set:\n  params.addRequiredParam<MaterialPropertyName>(\"boundary_material\", \"Value on the boundary\");\n  return params;\n}\n\nADEgMatDirichlet::ADEgMatDirichlet(const InputParameters & parameters)\n  : ADIntegratedBC(parameters),\n    // store the user-specified parameters from the input file...\n    _boundary_prop(getADMaterialProperty<Real>(\"boundary_material\"))\n    \n{\n}\n\nADReal\nADEgMatDirichlet::computeQpResidual()\n{\n  \n  return _boundary_prop[_qp] - _u[_qp];\n}\n\nAnd the input file material block is:\n[Materials]\n    [matconstant]\n        type = ADGenericConstantMaterial\n        prop_names = 'bndconst'\n        prop_values = '300'\n    []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5400548",
                  "updatedAt": "2023-03-23T05:06:54Z",
                  "publishedAt": "2023-03-23T05:06:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "shouldn't it be\n_u[_qp] - _boundary_prop[_qp];",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5400606",
                          "updatedAt": "2023-03-23T05:19:12Z",
                          "publishedAt": "2023-03-23T05:19:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "vermaprk"
                  },
                  "bodyText": "Aren't both same, as the residue has to be near to zero.\nI tried the following change on simplediffusion.i.\nADReal\nADEgMatDirichlet::computeQpResidual()\n{\n  \n  return _u[_qp] - _boundary_prop[_qp];\n}\n\nThe postprocessor gives:\nPostprocessor Values:\n+----------------+----------------+----------------+\n| time           | left_c         | right_c        |\n+----------------+----------------+----------------+\n:                :                :                :\n|   1.785000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.795000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.815000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.835000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.855000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.875000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.895000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.915000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.925000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.945000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.965000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.975000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.985000e+02 |   1.000000e+03 |   3.000001e+02 |\n|   1.992500e+02 |   1.000000e+03 |   3.000001e+02 |\n|   2.000000e+02 |   1.000000e+03 |   3.000001e+02 |\n+----------------+----------------+----------------+\n\nInterestingly, this change made in ADEgMatDirichlet leads to convergence issue on the original problem at the end time steps for PJFNK. Before, this change the code was running completely with PJFNK.\nSolve Did NOT Converge!\nAborting as solve did not converge\n\nTime Step 177, time = 199.999, dt = 1e-13\n 0 Nonlinear |R| = 4.105825e-06\n      0 Linear |R| = 4.105825e-06\n      1 Linear |R| = 8.327757e-13\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n Solve Did NOT Converge!\nAborting as solve did not converge\n\n\n*** ERROR ***\nThe following error occurred in the object \"TimeStepper\", of type \"ConstantDT\".\n\nSolve failed and timestep already at or below dtmin, cannot continue!",
                  "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5402688",
                  "updatedAt": "2023-03-23T08:57:36Z",
                  "publishedAt": "2023-03-23T08:57:35Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is not a real divergence.\nTime Step 177, time = 199.999, dt = 1e-13\n0 Nonlinear |R| = 4.105825e-06\n0 Linear |R| = 4.105825e-06\n1 Linear |R| = 8.327757e-13\nyou're converged, but the solver tries to take a 1e-13 timestep and it throws everything off\nif you increase the timestep_tol to 1e-12 this will be fixed\nCould you please paste the log for the Newton solve_type?",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5407535",
                          "updatedAt": "2023-03-23T15:12:05Z",
                          "publishedAt": "2023-03-23T15:12:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Please find the log file for newton attached.\nnohup.txt\ninput file:\nalpha = 0.5\ncinit = 1000\ncmax = 3920\nDLi = 7.5e-11\nR_const = 8.314\nF_const = 96487\nka = 1e-10\nt0 = 0.36\nI_app = -10\nT = 300\n\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    xmin = 0\n    xmax = 200e-6\n    nx = 200\n[]\n\n[Variables]\n    [c]\n    []\n    [phi]\n    []\n[]\n\n# Initial conditions.\n[ICs]\n    [conc]\n        variable = c\n        type = FunctionIC\n        function = ic_func_c\n    []\n[]\n\n[BCs]\n    [left_c]\n        type = ADMatNeumannBC\n        variable = c\n        boundary = 'left'\n        value = 1\n        boundary_material = Nflux\n    []\n    # [right_c]\n    #     type = ADMatNeumannBC\n    #     variable = c\n    #     boundary = 'right'\n    #     value = -1\n    #     boundary_material = Nflux\n    # []\n    [right_c]\n        type = ADEgMatDirichlet\n        variable = c\n        boundary = 'right'\n        boundary_material=bndconst\n    []\n    # [right_c]\n    #         type = ADDirichletBC\n    #         variable = c\n    #         boundary = 'right'\n    #         value = 300\n    #     []\n    [left_phi]\n        boundary = 'left'\n        type = MatDirichletBC\n        variable = phi\n        alpha = '${alpha}'\n        Iapp = '${I_app}'\n        cmax = '${cmax}'\n        temp = '${T}'\n        ka = '${ka}'\n        some_var = c\n    []\n[]\n\n[AuxVariables]\n    [velocity]\n        family = LAGRANGE_VEC\n    []\n[]\n\n[AuxKernels]\n    [vec]\n        type = VectorFunctionAux\n        variable = velocity\n        function = velocity_func\n        execute_on = 'INITIAL TIMESTEP_END'\n    []\n[]\n\n[Functions]\n    [velocity_func]\n        type = ParsedVectorFunction\n        expression_x = '1'\n    []\n\n    [ic_func_c]\n        type = ParsedFunction\n        expression = '${cinit}'\n    []\n[]\n\n[Kernels]\n    [cdot]\n        type = TimeDerivative\n        variable = c\n    []\n    [c_diff]\n        type=ADMatDiffusion\n        diffusivity='${DLi}'\n        variable = c\n    []\n    [c_mig]\n        type=ExampleMigration\n        variable = phi\n        velocity = velocity\n        reaction_rate = coeff_mig\n        v=c\n    []\n    [advection]\n        type = LevelSetAdvection\n        velocity = velocity\n        variable = phi\n    []\n\n    [rhs]\n        type = ADMaterialPropertyValue\n        variable = phi\n        prop_name = IbyK\n    []\n[]\n\n[Materials]\n    [matconstant]\n        type = ADGenericConstantMaterial\n        prop_names = 'bndconst'\n        prop_values = '1000'\n    []\n    [Boundaryflux]\n        type = ADParsedMaterial\n        property_name = Nflux\n        expression = '${I_app}/${F_const}'\n    []\n    [migrationcoeff]\n        type = ADParsedMaterial\n        property_name = coeff_mig\n        expression = '(2*${R_const}*${T}*(1-${t0}))/(${F_const})'\n    []\n    [ionicconductivity]\n        type = ADParsedMaterial\n        coupled_variables = 'c'\n        property_name = kappa\n        expression = '0.1147*exp(520/${R_const}*(1/298-1/${T}))*(c/1000)^3\n                        -2.238*exp(1010/${R_const}*(1/298-1/${T}))*(c/1000)^1.5\n                        +2.915*exp(1270/${R_const}*(1/298-1/${T}))*(c/1000)'\n        outputs = exodus\n    []\n    [IbyK]\n        type = ADParsedMaterial\n        property_name = IbyK\n        material_property_names = 'kappa'\n        expression = '${I_app}/kappa'\n        outputs = exodus\n    []\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'Newton'\n    # solve_type = 'PJFNK'\n    dt = 0.2\n    end_time = 200\n[]\n\n[Postprocessors]\n    [left_phi]\n      type = PointValue\n      point = '0 0 0'\n      variable = phi\n    []\n    [right_phi]\n      type = PointValue\n      point = '200e-6 0 0'\n      variable = phi\n    []\n    [right_c]\n        type = PointValue\n        point = '200e-6 0 0'\n        variable = c\n    []\n    [I0]\n        type = ParsedPostprocessor\n        function = '${F_const}*${ka}*pow((${cmax}-right_c),${alpha})*pow(right_c,${alpha})'\n        pp_names = 'right_c'\n    []\n    [voltage]\n        type = ParsedPostprocessor\n        function = 'right_phi + (${R_const}*${T})/(${alpha}*${F_const})*(asinh(${I_app}/I0))'\n        pp_names = 'right_phi I0'\n    []\n[]\n\n\n[Outputs]\n    exodus = true\n    [./csv]\n        type = CSV\n    [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5413579",
                          "updatedAt": "2023-03-24T05:13:45Z",
                          "publishedAt": "2023-03-24T04:45:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Try the code and input file below.\n\nI think you need to scale your problem. I think there are some conditioning problems.\nI think that for an integrateBC to model a DirichletBC like you want it needs to be in the form written below\nIn my previous post, I said the penalty term is problem dependent. Using 1e2 as the penalty parameter, the solution converges and is accurate (post processor attached below).\nI think the reason your problem worked somewhat for _u[_qp] - _boundary_prop[_qp] as the BC is because of the parameters you had, but as I increased the diffusivity, the BC below would still be accurate but the _u[_qp] - _boundary_prop[_qp] method would get progressively worse results.\n\n#include \"EgMatDirichlet.h\"\n\nregisterMooseObject(\"goldfishApp\", EgMatDirichlet);\n\nInputParameters\nEgMatDirichlet::validParams()\n{\n  InputParameters params = ADIntegratedBC::validParams();\n\n  // Specify input parameters that we want users to be able to set:\n  params.addRequiredParam<MaterialPropertyName>(\"boundary_material\", \"Value on the boundary\");\n  params.addRequiredParam<Real>(\"penalty\", \"Penalty to enforce the boundary condition.\");\n  return params;\n}\n\nEgMatDirichlet::EgMatDirichlet(const InputParameters & parameters)\n  : ADIntegratedBC(parameters),\n    // store the user-specified parameters from the input file...\n    _boundary_prop(getADMaterialProperty<Real>(\"boundary_material\")),\n    _penalty(getParam<Real>(\"penalty\"))\n{\n}\n\nADReal\nEgMatDirichlet::computeQpResidual()\n{\n  return _penalty * _test[_i][_qp] * (_u[_qp] - _boundary_prop[_qp]);\n}\n\n\n#pragma once\n\n#include \"ADIntegratedBC.h\"\n\nclass EgMatDirichlet : public ADIntegratedBC\n{\npublic:\n  EgMatDirichlet(const InputParameters & parameters);\n\n  static InputParameters validParams();\n\nprotected:\n  virtual ADReal computeQpResidual() override;\n\nprivate:\n  const ADMaterialProperty<Real> & _boundary_prop;\n  Real _penalty;\n};\n\n[Mesh]\n    type = GeneratedMesh\n    dim = 1\n    xmin = 0\n    xmax = 200e-6\n    nx = 200\n[]\n\n[Variables]\n    [c]\n    []\n[]\n\n# Initial conditions.\n[ICs]\n    [conc]\n        variable = c\n        type = FunctionIC\n        function = ic_func_c\n    []\n[]\n\n[BCs]\n    [left_c]\n        type = DirichletBC\n        variable = c\n        boundary = 'left'\n        value = 1000\n    []\n    [right_c]\n        type = EgMatDirichlet\n        variable = c\n        boundary = 'right'\n        boundary_material=bndconst\n        penalty = 1e2\n    []\n[]\n\n[Functions]\n    [ic_func_c]\n        type = ParsedFunction\n        expression = 1000\n    []\n[]\n\n[Kernels]\n    [cdot]\n        type = TimeDerivative\n        variable = c\n    []\n    [c_diff]\n        type=MatDiffusion\n        diffusivity= 7.5e-11\n        variable = c\n    []\n[]\n\n\n[Materials]\n    [matconstant]\n        type = ADGenericConstantMaterial\n        prop_names = 'bndconst'\n        prop_values = '300'\n    []\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    dt=2\n    end_time = 200\n    nl_abs_tol = 1e-10\n[]\n\n[Postprocessors]\n    [left_c]\n      type = PointValue\n      point = '0 0 0'\n      variable = c\n    []\n    [right_phi]\n      type = PointValue\n      point = '200e-6 0 0'\n      variable = c\n    []\n\n  []\n[Outputs]\n    exodus = true\n[]\n\nTime Step 100, time = 200, dt = 2\n 0 Nonlinear |R| = 2.257844e-06\n      0 Linear |R| = 2.257844e-06\n      1 Linear |R| = 5.617709e-20\n 1 Nonlinear |R| = 1.234283e-12\n Solve Converged!\n\nPostprocessor Values:\n+----------------+----------------+----------------+\n| time           | left_c         | right_phi      |\n+----------------+----------------+----------------+\n:                :                :                :\n|   1.720000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.740000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.760000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.780000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.800000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.820000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.840000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.860000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.880000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.900000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.920000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.940000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.960000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   1.980000e+02 |   1.000000e+03 |   3.000000e+02 |\n|   2.000000e+02 |   1.000000e+03 |   3.000000e+02 |\n+----------------+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/23797#discussioncomment-5416919",
                          "updatedAt": "2023-03-24T11:30:51Z",
                          "publishedAt": "2023-03-24T11:30:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Strange Stress Concentrations on Periodic RVE",
          "author": {
            "login": "Zoophish"
          },
          "bodyText": "Hi,\nI'm running a small strain model of an RVE using the homogenisation system in the new tensor mechanics system. I've noticed I get these unphyiscal looking stress concentrations on the boundaries. I'm following the test case given in this paper and it is clear that their model does not give these stress concentrations. I am using TET4 elements instead of HEX8 as I cannot mesh hex elements.\nThe artifact (this example is with the xx homogenisation stress constraint):\n\nRescaling the colour bar reveals the stresses (around the corners) which roughly match the paper I am following:\n\nFor clarity, it should look something like this:\n\nMy input file and mesh file is here:\ninput_file_mesh.zip\nIf this looks familiar, any help or pointers on what could be causing this would be greatly appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/23830",
          "updatedAt": "2023-03-24T11:26:16Z",
          "publishedAt": "2023-03-23T17:24:46Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "The paper's mesh looks finer and more regular.\nCould you please refine your mesh to see if the issue disappears?\nThere's a uniform refinement option in MOOSE if you dont want to go back to your meshing software",
                  "url": "https://github.com/idaholab/moose/discussions/23830#discussioncomment-5409437",
                  "updatedAt": "2023-03-23T17:28:38Z",
                  "publishedAt": "2023-03-23T17:28:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Zoophish"
                          },
                          "bodyText": "I reduced the element size in gmsh and it seems have fixed the artefact on my validation case.\n\nThanks for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/23830#discussioncomment-5416880",
                          "updatedAt": "2023-03-24T11:26:14Z",
                          "publishedAt": "2023-03-24T11:26:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "TET4 is a bad choice for solid mechanics...",
                  "url": "https://github.com/idaholab/moose/discussions/23830#discussioncomment-5410588",
                  "updatedAt": "2023-03-23T19:45:56Z",
                  "publishedAt": "2023-03-23T19:45:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to apply a pressure load on the surface of a shell element \uff1f",
          "author": {
            "login": "tttsss-01"
          },
          "bodyText": "I want to use shell elements to simulate the pressure load inside a cylinder, how to do it?\nPressure in BCs doesn't seem to be able to handle this.",
          "url": "https://github.com/idaholab/moose/discussions/23711",
          "updatedAt": "2023-04-21T16:32:36Z",
          "publishedAt": "2023-03-14T06:31:23Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@neuphris @recuero on shell elements",
                  "url": "https://github.com/idaholab/moose/discussions/23711#discussioncomment-5307174",
                  "updatedAt": "2023-03-14T14:37:08Z",
                  "publishedAt": "2023-03-14T14:37:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You need to implement a custom body force kernel for this. PR welcome.",
                  "url": "https://github.com/idaholab/moose/discussions/23711#discussioncomment-5410739",
                  "updatedAt": "2023-03-23T20:03:16Z",
                  "publishedAt": "2023-03-23T20:03:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "'EffectiveStrain' in 'RankTwoScalarTools'",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Hi MOOSEer,\nI try to calculate/use the equivalent plastic strain as shows https://mooseframework.inl.gov/source/utils/RankTwoScalarTools.html\nand discussed here #20979 and the input as\n\n[Auxvariables]\n[./equivalent_plastic_strain]\norder = CONSTANT\nfamily = MONOMIAL\n[../]\n[]\n[Auxkernels]\n[./equivalent_plastic_strain]\ntype =  RankTwoScalarTools #RankTwoScalarAux\nrank_two_tensor =  plastic_strain\nvariable = equivalent_plastic_strain\nscalar_type = effectiveStrain\n[../]\n[]\n\nBut the error throw out as\n\n*** ERROR ***\nA 'RankTwoScalarTools' is not a registered object.\n\nMaybe I misunderstood it, any suggestions are highly appreciated. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/23766",
          "updatedAt": "2023-04-29T03:07:28Z",
          "publishedAt": "2023-03-16T23:16:45Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUtils are meant to be called from the code, not from the input file.\nI think having an auxkernel was more appropriate there, to fill an auxvariable\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5339655",
                  "updatedAt": "2023-03-16T23:22:16Z",
                  "publishedAt": "2023-03-16T23:22:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thanks. I don't quite get it, could you explain more in detail? or are there related examples?",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5339669",
                          "updatedAt": "2023-03-16T23:25:39Z",
                          "publishedAt": "2023-03-16T23:25:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You\u2019re trying to use a utility.\nutilities are not objects you create in input files. It s code you can use when you are developing",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5339825",
                          "updatedAt": "2023-03-16T23:55:37Z",
                          "publishedAt": "2023-03-16T23:55:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Yes. I'm not sure where should I call for utility. Do you mean a new Auxkernel code containing RankTwoScalarTools and using utility needs to be developed?",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5339917",
                          "updatedAt": "2023-03-17T00:07:08Z",
                          "publishedAt": "2023-03-17T00:07:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yeah you could develop a new auxkernel that uses the utility you want to use.\nWhat are you trying to do?\nI think you just want to use the RankTwoScalarAux auxkernel here",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5339976",
                          "updatedAt": "2023-03-17T00:21:43Z",
                          "publishedAt": "2023-03-17T00:21:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "I want to call for the equivalent/effective plastic strain for other material modulus.\nso to put it this way, how can I obtain the \\epsilon_p^eq here? Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5343904",
                          "updatedAt": "2023-03-17T10:16:28Z",
                          "publishedAt": "2023-03-17T10:16:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you add\n[Debug]\n  show_material_props= true\n[]\n\nto the simulation do you see that property declared?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5347684",
                          "updatedAt": "2023-03-17T16:21:03Z",
                          "publishedAt": "2023-03-17T16:21:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Hi,\n\nI add it and it shows as\n\n\nConsumed Material Properties:\nObject: AuxKernel::isotropic_plasticityeffective_plastic_strain\nProperties: effective_plastic_strain\nObject: AuxKernel::isotropic_plasticityhardening_variable\nProperties: hardening_variable\n\nso it means it's calculated, right?\n\nPreviously, I used the [Compute Multiple Inelastic Stress] and [Isotropic Plasticity Stress Update] and input as follows to retrieve  \\epsilon_p^eq, but is this  \\epsilon_p^eq here the same as the one I showed in the figure? If yes, then what's the difference of [ effectiveStrain method] in https://mooseframework.inl.gov/source/utils/RankTwoScalarTools.html, as discussed as #20979. If no, then what's the definition of the \\epsilon_p^eq in the two modules.\n\n\n[./effective_plastic_strain]\ntype = MaterialRealAux\nproperty =  effective_plastic_strain\nvariable =  effective_plastic_strain\n[../]\n\n\nthe type of \\epsilon_p^eq should be  MaterialRealAux or RankTwoScalarAux or RankTwoScalarTools? All My questions come down to how can I calculate and call for \\epsilon_p^eq. Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5348088",
                          "updatedAt": "2023-03-17T16:57:16Z",
                          "publishedAt": "2023-03-17T16:57:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@hugary1995 @jiangwen84",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5350122",
                          "updatedAt": "2023-03-17T21:33:41Z",
                          "publishedAt": "2023-03-17T21:33:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Additionally, I'm trying to run the original input file from 'modules/combined/test/tests/j2_plasticity_vs_LSH/j2_hard1_mod_small_strain.i', which use the auxkernel to get eq_pl_strain as\n\n[./eq_pl_strain]\ntype = RankTwoScalarAux\nrank_two_tensor = plastic_strain\nscalar_type = EffectiveStrain\nvariable = eq_pl_strain\n[../]\n\nbut the error is still there.\n\n*** ERROR ***\nTo compute an effective inelastic strain use RankTwoScalarTools::effectiveStrain()",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5354397",
                          "updatedAt": "2023-03-18T17:03:47Z",
                          "publishedAt": "2023-03-18T17:03:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "[AuxVariables]\n  [ep]\n    order = CONSTANT\n    family = MONOMIAL\n    [AuxKernel]\n      type = MaterialRealAux\n      property = effective_plastic_strain\n      execute_on = 'TIMESTEP_END'\n    []\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/23766#discussioncomment-5410700",
                          "updatedAt": "2023-03-23T19:58:07Z",
                          "publishedAt": "2023-03-23T19:58:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}