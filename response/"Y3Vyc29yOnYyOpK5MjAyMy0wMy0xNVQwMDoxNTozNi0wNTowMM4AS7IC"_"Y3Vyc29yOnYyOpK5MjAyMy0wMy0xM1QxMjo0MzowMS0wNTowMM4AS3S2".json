{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wMy0xM1QxMjo0MzowMS0wNTowMM4AS3S2"
    },
    "edges": [
      {
        "node": {
          "title": "Problem when update moose/conda",
          "author": {
            "login": "aaelmeli"
          },
          "bodyText": "Hi\nI have updated moose repo and conda but when I rebuild moose, i get this error\nIn file included from /home/aaelmeli/projects/moose/framework/build/unity_src/meshgenerators_Unity.C:65:\n/home/aaelmeli/projects/moose/framework/src/meshgenerators/SymmetryTransformGenerator.C: In member function 'virtual std::unique_ptr<libMesh::MeshBase> SymmetryTransformGenerator::generate()':\n/home/aaelmeli/projects/moose/framework/src/meshgenerators/SymmetryTransformGenerator.C:90:28: error: 'orient_elements' is not a member of 'libMesh::MeshTools::Modification'\n   90 |   MeshTools::Modification::orient_elements(*mesh);\n      |                            ^~~~~~~~~~~~~~~\n\nDo I have to remove the entire moose and conda and installed it again from scratch? any other way?\nIf yes, is there any other way to solve this for next updates? I experienced this couple of times and it is somewhat frustrating to reinstall moose and conda at every moose update.\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/23727",
          "updatedAt": "2023-03-15T07:18:24Z",
          "publishedAt": "2023-03-15T00:14:44Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis means you need to update libmesh.\nThe conda update must have failed if you did that.\nYou may remove the conda environment and install it again\nYou do not need to remove moose, you ll just need to install it again after updating libmesh\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23727#discussioncomment-5315992",
                  "updatedAt": "2023-03-15T00:58:47Z",
                  "publishedAt": "2023-03-15T00:58:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aaelmeli"
                          },
                          "bodyText": "So, do I only need to perform these commands?\nmamba activate base\nmamba env remove -n moose\n\nthen reinstall it again by using\nmamba create -n moose moose-tools moose-libmesh\n?",
                          "url": "https://github.com/idaholab/moose/discussions/23727#discussioncomment-5316071",
                          "updatedAt": "2023-03-15T01:14:45Z",
                          "publishedAt": "2023-03-15T01:14:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes this should work",
                          "url": "https://github.com/idaholab/moose/discussions/23727#discussioncomment-5316082",
                          "updatedAt": "2023-03-15T01:15:40Z",
                          "publishedAt": "2023-03-15T01:15:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Hydrostatic stress coupled with concentration",
          "author": {
            "login": "sidharthsarmah"
          },
          "bodyText": "Hi @hugary1995 ,\nI want to implement this PDE term of the diffusion equation in a kernel, the CL is the variable to be computed which is coupled and dependent on the hydrostatic stress gradient.\nCould you suggest a similar example of how I proceed, the CL is the variable and \\sigma_h is the aux variable.",
          "url": "https://github.com/idaholab/moose/discussions/22910",
          "updatedAt": "2023-03-14T18:46:24Z",
          "publishedAt": "2022-12-07T20:20:55Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Yeah sure. Are you using AD?",
                  "url": "https://github.com/idaholab/moose/discussions/22910#discussioncomment-4337019",
                  "updatedAt": "2022-12-07T20:37:21Z",
                  "publishedAt": "2022-12-07T20:37:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You'll have to tell me how to compute sigma_h in your third term. Be it prescribed, or related to another nonlinear variable, please write down the equation.",
                          "url": "https://github.com/idaholab/moose/discussions/22910#discussioncomment-4337107",
                          "updatedAt": "2022-12-07T20:52:07Z",
                          "publishedAt": "2022-12-07T20:52:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay, that was my guess. So unfortunately this is not a good approach. Let me explain.\nThe whole purpose of using AD is to get the exact algorithmic tangent, so that you get quadratic convergence using a Newton solver. MOOSE uses forward mode automatic differentiation to get the algorithmic tangent (a.k.a. Jacobian). All you need to know as a user is that all the operations carries derivatives with them, so that the derivative information can be \"propagated\" down to the final residual. For this to work, all the operations you use during the calculation of residual have to support AD.\nHowever, that is not the case here since you use an AuxVariable to compute the hydrostatic stress (or the gradient of hydrostatic stress). An AuxVariable does not carry derivative information with it. As a result, although your final residual will still be correct (if implemented correctly), the algorithmic tangent will be inexact. Then it essentially loses the entire point of using AD.\nThere are multiple ways of dealing with this. For a new user, the easiest approach is probably to reparameterize the equation by projecting the hydrostatic stress onto an additional nonlinear variable, let's call it p_h. You need to solve for an additional equation for p_h:\nw * (p_h - sigma_h) = 0\nwhere w is the test function, p_h is the nonlinear variable to be solved, and sigma_h is the hydrostatic stress computed at quadrature points (as an AD material property).\nThe next step is to replace sigma_h in the third term of your original equation by this new variable p_h.",
                          "url": "https://github.com/idaholab/moose/discussions/22910#discussioncomment-4337307",
                          "updatedAt": "2022-12-07T21:14:00Z",
                          "publishedAt": "2022-12-07T21:13:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I suggest you first figure out how to compute a scalar-valued hydrostatic stress from a tensor-valued stress as an AD material property. There should a material object in the tensor_mechanics module that allows you to do that. If you don't find it, I can track that down for you when I get off work.",
                          "url": "https://github.com/idaholab/moose/discussions/22910#discussioncomment-4343841",
                          "updatedAt": "2022-12-08T14:23:03Z",
                          "publishedAt": "2022-12-08T14:23:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @hugary1995,\nI am a bit confused on this part.\nThe hydrostatic stress can directly be declared this way below since its defined as a RankTwoScalar parameter already (https://mooseframework.inl.gov/source/utils/RankTwoScalarTools.html).\nDo I have to use this auxvariable and convert it to a ADMaterialProperty and then relate it to p_h\n[AuxVariables]\n\n  [./hydrostatic]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n[AuxKernels]\n\n\nOR\n\nI have to defined another ADMaterialProperty named hydrostatic_stress = sum of normal stresses and then relate it to p_h?",
                          "url": "https://github.com/idaholab/moose/discussions/22910#discussioncomment-4347722",
                          "updatedAt": "2023-03-14T18:46:37Z",
                          "publishedAt": "2022-12-08T23:58:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "No, let me reiterate, don't use aux variable to bridge nonlinear equations in AD.\nYou need to create an AD material property for hydrostatic stress using https://mooseframework.inl.gov/source/materials/RankTwoInvariant.html",
                          "url": "https://github.com/idaholab/moose/discussions/22910#discussioncomment-4347901",
                          "updatedAt": "2022-12-09T00:33:18Z",
                          "publishedAt": "2022-12-09T00:33:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @hugary1995, thanks!\nPlease suggest:\nI am a bit confused on how to relate pressure with hydrostatic_stress as you mentioned.\nBased on the notes, \"This Material model is set up by [TensorMechanics/Master] automatically when stress components are requested in the generate_output parameter, but can also be set up directly by the user.\"\nI have declared a variable named pressure and hydrostatic_stress directly by calling generate_output:\n[Variables]\n\n  [./conc_lattice]\n  initial_condition = 1.0e3\n  [../]\n\n  [./pressure]\n  [../]\n\n[]\n\n[Modules/TensorMechanics/Master]\n\n  [./all]\n    strain = SMALL\n    incremental = true\n    add_variables = true\n    generate_output = 'stress_xx stress_yy stress_zz hydrostatic_stress'\n  use_automatic_differentiation = true\n  [../]\n\n[]\n\nNow since conc_lattice (C_L) is the primary kernel to be solved in this equation. Can we convert this convert this equation as follows with grad of hydrostatic stress in the coefficient?\nCan you suggest on how to:\n\nRelate the variable pressure to the property hydrostatic_stress?\nHow do I extract the grad of hydrostatic_stress in a Kernel?\n\n[Kernels]\n\n  [./stress_grad]\n    type = ADMatDiffusion\n    variable = 'conc_lattice'\n    diffusivity = 'func2'\n  [../]\n\n[]\n\n[Materials]\n\n  [./constants]\n    type = ADGenericConstantMaterial\n    prop_names  = 'DL\t\tNT\t\tNL\t\tWB\tVH\tR\tT'\n    prop_values = '0.01271\t8.464e13\t8.464e17\t11.5e6\t2000.0\t8314.5\t300'\n  [../]\n\n\n  [./elasticity_tensor]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 201880\n    poissons_ratio = 0.3\n  [../]\n\n  [./stress]\n    type = ADComputeLinearElasticStress\n  [../]\n\n[]\n\n\nKernel which can be used?",
                          "url": "https://github.com/idaholab/moose/discussions/22910#discussioncomment-4354266",
                          "updatedAt": "2023-03-14T18:47:10Z",
                          "publishedAt": "2022-12-09T17:19:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "We should tackle this problem step by step, and please try to follow my suggestions -- I am trying to help.\nFirst, please use the object I referenced above to obtain the hydrostatic stress sigma_h as an AD material property. Please convince yourself it is working as expected.\nNext, as I said earlier, to relate p_h and sigma_h, you need to a projection by solving the following equation:\nw (p_h - sigma_h) = 0\nFinally, with  nonlinear variable p_h, it will be trivial to obtain he pressure gradient.",
                          "url": "https://github.com/idaholab/moose/discussions/22910#discussioncomment-4358569",
                          "updatedAt": "2022-12-09T23:59:22Z",
                          "publishedAt": "2022-12-09T23:59:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @hugary1995, please suggest if I am correct.\nStep 1:\n\"First, please use the object I referenced above to obtain the hydrostatic stress sigma_h as an AD material property.\"\nBased on the object, \"This Material model is set up by [TensorMechanics/Master] automatically when stress components are requested in the generate_output parameter, but can also be set up directly by the user.\"\nThe hydrostatic_stress is set up as an ADProperty by either of the two ways:\n\nDirectly by calling generate_output(https://mooseframework.inl.gov/source/materials/RankTwoInvariant.html), is it correct?\n\n[Modules/TensorMechanics/Master]\n  [./all]\n          strain = SMALL\n          incremental = true\n          add_variables = true\n          generate_output = 'hydrostatic_stress'\n          use_automatic_differentiation = true\n  [../]\n[]\n\n\nInvoked as a material property on calling the material object, 'ADComputeLinearElasticStress':\n\n[Materials]\n\n***Elastic case***\n  [./elas_stress]\n    type = ADComputeLinearElasticStress\n  [../]\n\n[]\n\nStep 2:\n\"Next, as I said earlier, to relate p_h and sigma_h, you need to a projection by solving the following equation:\nw (p_h - sigma_h) = 0\"\nNow the 'hydrostatic_stress' property is assigned to a non-linear variable 'pressure' by using the kernel, \"ADMaterialPropertyValue\"(https://mooseframework.inl.gov/source/kernels/MaterialPropertyValue.html):\nStep 3:\nPlease let me know if the above steps are correct, I can then work on to find the final term, thanks!\n'Finally, with nonlinear variable p_h, it will be trivial to obtain he pressure gradient.'",
                          "url": "https://github.com/idaholab/moose/discussions/22910#discussioncomment-4366995",
                          "updatedAt": "2023-03-14T18:41:12Z",
                          "publishedAt": "2022-12-10T18:27:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The action only outputs hydrostatic stress as an AuxVariable. Again, you need to use the object I referenced above, which is called RankTwoInvariant. In your case you need to use its AD version called ADRankTwoInvariant. First, set up this object, run the model, output the material property, and verify that the value is correct.",
                          "url": "https://github.com/idaholab/moose/discussions/22910#discussioncomment-4373951",
                          "updatedAt": "2022-12-11T23:58:18Z",
                          "publishedAt": "2022-12-11T23:58:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @hugary1995, thanks\nI faced an issue implementing it as as no examples were available, my bad!\nI tried implementing the object now, but found an error, please suggest!\n*** ERROR ***\nThe following error occurred in the object \"stress_pressure\", of type \"ADRankTwoInvariant\".\n\nNot a recognized invariant for RankTwoInvariant\n\nObject:\n[Materials]\n\n\n  [./elasticity_tensor]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 201880\n    poissons_ratio = 0.3\n  [../]\n\n  [./elas_stress]\n    type = ADComputeLinearElasticStress\n  [../]\n\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/22910#discussioncomment-4380736",
                          "updatedAt": "2023-03-14T18:41:27Z",
                          "publishedAt": "2022-12-12T16:33:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Stress intensity boundary conditions",
          "author": {
            "login": "sidharthsarmah"
          },
          "bodyText": "Hi,\nI am trying to implement a stress intensity BC on the Outer nodes in a Boundary layer Problem (Green line) and a symmetry condition on bottom (Red line), which looks something like this.\nIt is a coupled problem with concentration BC on the H surface(Blue line)\n#****************BCs********************\n\n[BCs]\n\n   [./surface]\n    type = ADDirichletBC\n    variable = conc_lattice\n\n\n  [./x_bot]\n    type = ADDirichletBC\n    variable = disp_x\n    boundary = 'Symmetry'\n    value = 0  \n  [../]\n\n  [./y_bot]\n    type = ADDirichletBC\n    variable = disp_y\n    boundary = 'Symmetry'\n    value = 0  \n  [../]\n\n[]\n\nI have defined the Outer nodes in the input files.\n\n\nCould you please suggest if there is any mistake as I am encountering a  convergence issue)",
          "url": "https://github.com/idaholab/moose/discussions/23120",
          "updatedAt": "2023-03-14T18:44:44Z",
          "publishedAt": "2023-01-09T20:42:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I think the issue was found on another thread.\nUnits are MPa for stress instead of Pa",
                  "url": "https://github.com/idaholab/moose/discussions/23120#discussioncomment-4870069",
                  "updatedAt": "2023-02-04T15:47:27Z",
                  "publishedAt": "2023-02-04T15:47:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A 2D mesh with circular region, and applying a constant force on the circle",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hello,\nI am trying to analyze the problem in the image attached. Please how do I get a rectangular mesh with a circular region? And how do I apply a constant forcing term on the circular part? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/23477",
          "updatedAt": "2023-03-14T15:55:42Z",
          "publishedAt": "2023-02-18T16:39:50Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFor the constant forcing term, I think you will want to have a look at using a boundary condition if the variables only outside the circle in the rectangular regions.\nTo obtain a rectangular mesh with a circular hole, I think we have an example here:\nhttps://github.com/idaholab/moose/blob/next/modules/navier_stokes/examples/flow-over-circle/mesh.i\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23477#discussioncomment-5025435",
                  "updatedAt": "2023-02-19T15:07:56Z",
                  "publishedAt": "2023-02-19T15:07:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/23477#discussioncomment-5128277",
                          "updatedAt": "2023-02-27T21:22:00Z",
                          "publishedAt": "2023-02-27T21:21:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Rahim-Habibi"
                  },
                  "bodyText": "Hi,\nI can recommed to use Gmsh for meshing the domian.\nyou can create rectangular mesh with a circular region in.\nIf you want to apply boundary condition on the circle,  you can define the circle as a physical property then you will have access to that in MOOSE input file.",
                  "url": "https://github.com/idaholab/moose/discussions/23477#discussioncomment-5075264",
                  "updatedAt": "2023-02-22T10:02:42Z",
                  "publishedAt": "2023-02-22T10:02:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/23477#discussioncomment-5128280",
                          "updatedAt": "2023-02-27T21:22:06Z",
                          "publishedAt": "2023-02-27T21:22:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "salaudeen-ya"
                  },
                  "bodyText": "Using a circular body force specified over the region of interest also works",
                  "url": "https://github.com/idaholab/moose/discussions/23477#discussioncomment-5311596",
                  "updatedAt": "2023-03-14T15:55:33Z",
                  "publishedAt": "2023-03-14T15:55:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "VectorPostprocessor output as a boundary condition",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hello,\nPlease how can I use a Vectorpostprocessor such as the LineValueSampler and SideValueSampler as a Boundary condition without having to output in a csv file. This is because the values in the vectorpostprocessor change at every iteration and I need to update the changed values as new BC at each time step.\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/23582",
          "updatedAt": "2023-03-14T15:52:08Z",
          "publishedAt": "2023-03-02T16:07:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you using a MultiApp?\nOr is the coupling between the two equations (one that computes the VPP, and one that uses) within in the same input file?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23582#discussioncomment-5180600",
                  "updatedAt": "2023-03-02T16:13:44Z",
                  "publishedAt": "2023-03-02T16:13:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "I am using MultiApp with two input files.\nThe two files compute the VPP separately, and each of them uses the scaled VPP values coming from the other as BC.",
                          "url": "https://github.com/idaholab/moose/discussions/23582#discussioncomment-5180645",
                          "updatedAt": "2023-03-02T16:16:16Z",
                          "publishedAt": "2023-03-02T16:16:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok you can transfer the VPP directly between the two applications using this\nhttps://mooseframework.inl.gov/source/transfers/MultiAppVectorPostprocessorTransfer.html",
                          "url": "https://github.com/idaholab/moose/discussions/23582#discussioncomment-5180686",
                          "updatedAt": "2023-03-02T16:17:44Z",
                          "publishedAt": "2023-03-02T16:17:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "Alright. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/23582#discussioncomment-5180741",
                          "updatedAt": "2023-03-02T16:20:41Z",
                          "publishedAt": "2023-03-02T16:20:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "I got this error:\n\nThis is quite understandable since I only have one subdomain.\nTo be more clear in my problem:\n\nI want to transfer across the interface using two different input meshes. The VectorPostprocessor only allows me to transfer a scalar value to multiple subdomains at the same time. But, I want to transfer vector of values at the boundary to the other domain. MatchedNode did not quite give me the expected values too.",
                          "url": "https://github.com/idaholab/moose/discussions/23582#discussioncomment-5181067",
                          "updatedAt": "2023-03-02T16:45:42Z",
                          "publishedAt": "2023-03-02T16:44:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nmy bad I got this wrong\nYou have to use this\nhttps://mooseframework.inl.gov/source/transfers/MultiAppReporterTransfer.html#vector_transfer\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/23582#discussioncomment-5181218",
                          "updatedAt": "2023-03-02T16:58:56Z",
                          "publishedAt": "2023-03-02T16:58:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "salaudeen-ya"
                  },
                  "bodyText": "Thank you\nI was able to effectively transfer using NearestNode and coupled BC",
                  "url": "https://github.com/idaholab/moose/discussions/23582#discussioncomment-5311561",
                  "updatedAt": "2023-03-14T15:52:07Z",
                  "publishedAt": "2023-03-14T15:52:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unable to run phase-field fracture simulations using spectral decomposition of strain energy",
          "author": {
            "login": "MartimSalgado"
          },
          "bodyText": "Hi,\nI've created a model for a single edge notched tension test loaded in displacement control in moose using phase-field coupled with tensor mechanics and a volumetric deviatoric decomposition of strain energy. However, when I try to change the decomposition type to \"spectral\", the solver always fails to converge at the early steps of the simulation. I've already tried to use different petsc options, mesh, displacement increment, nothing works. I'm also running 2 versions: monolithic and staggered schemes (one single app and using multiapp). I'm sending attached the monolithic version that works with volumetric deviatoric.\nDoes anyone have any tips on how to get this to work with spectral decomposition? Thank you!\nsent.zip",
          "url": "https://github.com/idaholab/moose/discussions/18265",
          "updatedAt": "2023-03-14T14:44:56Z",
          "publishedAt": "2021-07-06T08:49:09Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Hi, thanks for reporting this. Could you convert this into an issue? I will look into this.",
                  "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-969807",
                  "updatedAt": "2022-09-12T17:43:19Z",
                  "publishedAt": "2021-07-06T12:15:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@MartimSalgado  Couple of things:\n\nI have to comment out some blocks that use your own staff.\nSince you use VI solver, you should set use_snes_vi_solver = true\nYou used 8 levels of refinement which seems to be too many. I suggest starting with a uniform mesh to identify the convergence issue.\nYou have two identical BC blocks, top_x and bottom_x\n@hugary1995 and I found an error of jacobian calculation in ComputeLinearElasticPFFractureStress::computeStrainSpectral It should not affect the convergence much because of using PJFNK, but we still need to fix it as soon as we can.",
                  "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-970706",
                  "updatedAt": "2022-09-12T17:43:20Z",
                  "publishedAt": "2021-07-06T15:24:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Hello moose developers,\nI am new moose user and interested in developing models for phase field fracture in polycrystals. I have been trying to reproduce\npure shear tests published in many articles using spectral decomposition. First I considered newton method and figured out that there was an issue because of the jacobian so I implemented a new jacobian based on the projector of the strain_old  (or stress_old) which is normally stable. However even with this I could not have convergence. Could anyone help us in solving this ?\nThank you in advance.",
                          "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-5085982",
                          "updatedAt": "2023-02-23T09:02:35Z",
                          "publishedAt": "2023-02-23T09:02:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Hello moose developers,\nI am new moose user and interested in developing models for phase field fracture in polycrystals. I have been trying to reproduce\npure shear tests published in many articles using spectral decomposition. First I considered newton method and figured out that there was an issue because of the jacobian so I implemented a new jacobian based on the projector of the strain_old  (or stress_old) which is normally stable. However even with this I could not have convergence. Could anyone help us in solving this ?\nThank you in advance.\n\nWhat was the issue with the oringal code?  The Jabobian should be correct.",
                          "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-5088502",
                          "updatedAt": "2023-02-23T13:35:31Z",
                          "publishedAt": "2023-02-23T13:35:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Thanks for your reply.\nThe jacobian is correct, but we think that the spectral method would not converge with a  vacillating Jacobian due to a null eigen value in a pure shear test.  That is why we have considered the \"old\" Projector instead of the current when computing the Jacobian, and even with this, we could not have convergence.\nregards,",
                          "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-5088990",
                          "updatedAt": "2023-02-23T14:20:00Z",
                          "publishedAt": "2023-02-23T14:20:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYou should test the jacobian using our automatic tools to determine that\nSee this page:\nhttps://mooseframework.inl.gov/help/development/analyze_jacobian.html\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-5089705",
                          "updatedAt": "2023-02-23T15:17:49Z",
                          "publishedAt": "2023-02-23T15:17:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Thanks for your reply.\nThe jacobian is correct, but we think that the spectral method would not converge with a vacillating Jacobian due to a null eigen value in a pure shear test. That is why we have considered the \"old\" Projector instead of the current when computing the Jacobian, and even with this, we could not have convergence.\nregards,\n\nI do not remember we have much convergence trouble with the pure shear test. Does it converge badly on linear or nonlinear iterations?\nCould you paste your \"executioner\" block here?",
                          "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-5089990",
                          "updatedAt": "2023-02-23T15:41:45Z",
                          "publishedAt": "2023-02-23T15:41:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "We have tried many execution scenarios, the last one is :\n[Executioner]\n[./TimeStepper]\ntype = IterationAdaptiveDT\ndt =1.0e-8  # Initial time step.  In this simulation it changes.\noptimal_iterations = 8 # Time step will adapt to maintain this number of nonlinear iterations\ngrowth_factor = 1.5\n[../]\ntype = Transient\n#solve_type =newton #PJFNK\npetsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\npetsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\nautomatic_scaling = true\nline_search = 'none'\nnl_rel_tol = 1e-3\nl_tol = 1.0e-4\nl_max_its = 200\nnl_max_its = 14\ndtmax = 3.0e-2\ndtmin = 1e-11\nend_time = 20.0\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-5090159",
                          "updatedAt": "2023-02-23T15:57:09Z",
                          "publishedAt": "2023-02-23T15:57:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "See this app as an example: https://github.com/hugary1995/raccoon/tree/devel/tutorials/mode2_brittle_fracture\n\nThe jacobian is correct, but we think that the spectral method would not converge with a vacillating Jacobian due to a null eigen value in a pure shear test.\n\nI also don't quite understand this statement.",
                          "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-5090214",
                          "updatedAt": "2023-02-23T16:02:46Z",
                          "publishedAt": "2023-02-23T16:02:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Of course I did not face problems with non pre-cracked meshs. However with a pre-cracked one, like in many articles, it never converged. The pre-crack could be either d=1 or a real mesh cut.\nregards",
                          "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-5090286",
                          "updatedAt": "2023-02-23T16:09:38Z",
                          "publishedAt": "2023-02-23T16:09:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "However with a pre-cracked one, like in many articles, it never converged.\n\nBut many articles show results generated with MOOSE...",
                          "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-5090330",
                          "updatedAt": "2023-02-23T16:13:55Z",
                          "publishedAt": "2023-02-23T16:13:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": null,
                          "bodyText": "That is why we are asking how these results have been obtained",
                          "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-5090351",
                          "updatedAt": "2023-02-23T16:16:22Z",
                          "publishedAt": "2023-02-23T16:16:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "selarem"
                  },
                  "bodyText": "disp_y = 0 everywhere on the external boundaries: left,right, top and\nbottom.\n\nLe jeu. 23 f\u00e9vr. 2023 \u00e0 19:37, Gary (Tianchen) Hu ***@***.***>\na \u00e9crit :\n\u2026\n Great, we are getting somewhere :)\n\n So I may have totally misunderstood your \"pure shear\" test. By \"disp_y has\n to be zero everywhere\", do you mean you also want to set disp_y on the left\n and right boundaries, or do you mean you literally want to set disp_y\n *everywhere* on the domain, i.e., on all the nodes?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#18265 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AFBUGDHJJADCRB2SWUE7UULWY6U5JANCNFSM474DOUKA>\n .\n You are receiving this because you commented.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/18265#discussioncomment-5092014",
                  "updatedAt": "2023-02-23T18:41:24Z",
                  "publishedAt": "2023-02-23T18:41:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unrealistic results in 3D simulation",
          "author": {
            "login": "RWTHLHK"
          },
          "bodyText": "I got a weird result in a 3D simulation. The sample is a common notched round bar. The displacement at the top is 0.3*t and the bottom is fixed as shown in the attached figures. But weirdly the maximum von Mises stress is at the top not at the bottom as expected.\n\n\n\nMy input file is as follwing:\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh]\n    [base]\n        type = FileMeshGenerator\n        file = NRB_R2_complete.inp\n    []\n[]\n\n[Modules/TensorMechanics/Master]\n  [./all]\n    strain = FINITE\n    add_variables = true\n    generate_output = 'max_principal_stress triaxiality_stress vonmises_stress plastic_strain_xx plastic_strain_yy plastic_strain_zz'\n  [../]\n[]\n\n[Functions]\n  [./hf]\n    type = PiecewiseLinear\n    data_file = stress_data.csv\n    format = columns\n  [../]\n[]\n\n[BCs]\n  [./y_pull_function]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = top\n    function = 0.3*t\n  [../]\n  [./y_bot]\n    type = DirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0.0\n  [../]\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 2e5#MPa\n    poissons_ratio = 0.29\n  [../]\n  [./isotropic_plasticity]\n    type = IsotropicPlasticityStressUpdate\n    yield_stress = 431.46 #MPa\n    hardening_function = hf\n  [../]\n  [./radial_return_stress]\n    type = ComputeMultipleInelasticStress\n    tangent_operator = elastic\n    inelastic_models = 'isotropic_plasticity'\n  [../]\n  [lode_angle]\n    type = ComputeLodeAngle\n    outputs = exodus\n  []\n  [critical_crack_strain]\n    type = ComputeCriticalCrackStrain\n    outputs = exodus\n  []\n  [peeq]\n    type = ComputePEEQ\n    outputs = exodus\n  []\n  [d]\n    type = ComputeDamage\n    alpha = 1.0\n    beta = 1.0\n    critical_fracture_stress = 1204\n    outputs = exodus\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-ksp_gmres_restart'\n  petsc_options_value = '101'\n\n  line_search = 'none'\n\n  l_max_its = 50\n  nl_max_its = 50\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-6\n  l_tol = 1e-9\n\n  start_time = 0.0\n  end_time = 0.5\n  dt = 0.005\n[]\n\n[Outputs]\n  exodus = true\n  console = true\n  print_perf_log = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23676",
          "updatedAt": "2023-04-29T03:12:38Z",
          "publishedAt": "2023-03-09T13:23:20Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "nl_abs_tol = 1e-6\nthis is pretty coarse. Let's tighten it and/or add automatic_scaling  to make sure we're looking at converged results\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23676#discussioncomment-5255879",
                  "updatedAt": "2023-03-09T15:32:06Z",
                  "publishedAt": "2023-03-09T15:32:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "RWTHLHK"
                          },
                          "bodyText": "Ok, thanks. I will try it.",
                          "url": "https://github.com/idaholab/moose/discussions/23676#discussioncomment-5256017",
                          "updatedAt": "2023-03-09T15:42:33Z",
                          "publishedAt": "2023-03-09T15:42:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RWTHLHK"
                          },
                          "bodyText": "I change  nl_rel_tol = 1e-10, nl_abs_tol = 1e-12. The maximum von mises stress is still at the top...",
                          "url": "https://github.com/idaholab/moose/discussions/23676#discussioncomment-5256069",
                          "updatedAt": "2023-03-09T15:46:31Z",
                          "publishedAt": "2023-03-09T15:46:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "2e5#MPa how did you change the units here?\nI think this should be in Pa",
                          "url": "https://github.com/idaholab/moose/discussions/23676#discussioncomment-5256242",
                          "updatedAt": "2023-03-09T16:00:11Z",
                          "publishedAt": "2023-03-09T16:00:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RWTHLHK"
                          },
                          "bodyText": "I didn't pay attention to the units yet. I want to see how can I incorporate the hardening law into the simulation. So I used the same data as that in an Abaqus simulation, the young modulus is 200GPa=2e5MPa.",
                          "url": "https://github.com/idaholab/moose/discussions/23676#discussioncomment-5256364",
                          "updatedAt": "2023-03-09T16:08:14Z",
                          "publishedAt": "2023-03-09T16:08:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "=2e11 Pa.\nSuper low young modulus in the simulation would impact the results",
                          "url": "https://github.com/idaholab/moose/discussions/23676#discussioncomment-5256384",
                          "updatedAt": "2023-03-09T16:09:23Z",
                          "publishedAt": "2023-03-09T16:09:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RWTHLHK"
                          },
                          "bodyText": "Hello, I changed the young's modulus to 2e11, the result was still the same. Then I used a simple cylinder model to test with same BCs and material properties, and simply used ComputeLinearElasticStress, the maximum von mises stress is still at the top.",
                          "url": "https://github.com/idaholab/moose/discussions/23676#discussioncomment-5265948",
                          "updatedAt": "2023-03-10T10:28:04Z",
                          "publishedAt": "2023-03-10T10:28:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@recuero you may want to check this thread too for context",
                          "url": "https://github.com/idaholab/moose/discussions/23676#discussioncomment-5268981",
                          "updatedAt": "2023-03-10T15:37:06Z",
                          "publishedAt": "2023-03-10T15:37:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "But weirdly the maximum von Mises stress is at the top not at the bottom as expected.\n\nIf you are modeling cracking, the areas with large stresses will suddenly have zero stress. In that case, your results wouldn't look too bad depending on what you are modeling.\nWhen you say you simply used ComputeLinearElasticStress: Is that all you used? Or you also accounted for damage?",
                          "url": "https://github.com/idaholab/moose/discussions/23676#discussioncomment-5269206",
                          "updatedAt": "2023-03-10T15:53:04Z",
                          "publishedAt": "2023-03-10T15:53:03Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I agree with @recuero this is due to your damage model.",
                          "url": "https://github.com/idaholab/moose/discussions/23676#discussioncomment-5291219",
                          "updatedAt": "2023-03-13T12:56:19Z",
                          "publishedAt": "2023-03-13T12:56:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RWTHLHK"
                          },
                          "bodyText": "But weirdly the maximum von Mises stress is at the top not at the bottom as expected.\n\nIf you are modeling cracking, the areas with large stresses will suddenly have zero stress. In that case, your results wouldn't look too bad depending on what you are modeling.\nWhen you say you simply used ComputeLinearElasticStress: Is that all you used? Or you also accounted for damage?\n\nYes this is all what I used. To test I disabled damage computation during the simulation, but the maximum stress is still at the top.",
                          "url": "https://github.com/idaholab/moose/discussions/23676#discussioncomment-5291256",
                          "updatedAt": "2023-03-13T12:59:43Z",
                          "publishedAt": "2023-03-13T12:59:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issue in transferring data in Multiapp module",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello MOOSE Experts\nI am trying to solve phase-field fracture in multi-app modules using different solvers.\nI have set up the problem with the elasticity part in one app and the damage part in one app as shown below.\nelasticity.i\n[Mesh]\nfile = Miehe.inp\n[]\n\n[MultiApps]\n  [fracture]\n    type = TransientMultiApp\n    input_files = fracture.i\n    execute_on = 'TIMESTEP_END'\n  []\n[]\n\n[Transfers]\n  [transfer_damage_variable]\n    source_variable = c\n    direction = from_multiapp\n    variable = to_master\n    type = MultiAppVariableValueSampleTransfer\n    multi_app = fracture\n  []\n   [transfer_disp_x]\n    source_variable = disp_x\n    direction = to_multiapp\n    variable = from_master\n    type = MultiAppVariableValueSampleTransfer\n    multi_app = fracture\n  []\n  [transfer_disp_y]\n    source_variable = disp_y\n    direction = to_multiapp\n    variable = from_master\n    type = MultiAppVariableValueSampleTransfer\n    multi_app = fracture\n  []\n[]\n\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Variables]\n  [./c]\n    family = LAGRANGE\n    order = FIRST\n  [../]\n[]\n\n[AuxVariables]\n  [./resid_x]\n  [../]\n  [./resid_y]\n  [../]\n[]\n\n[Modules]\n  [./TensorMechanics]\n    [./Master]\n      [./All]\n        add_variables = true\n        strain = SMALL\n        additional_generate_output = 'strain_yy stress_yy'\n          planar_formulation = PLANE_STRAIN\n          save_in = 'resid_x resid_y'\n      [../]\n    [../]\n  [../]\n[]\n\n[BCs]\n  [./ydisp]\n    type = FunctionDirichletBC\n    preset = true\n    variable = disp_y\n    boundary = 'NS4'\n    function = 't'\n  [../]\n    [./xdisp]\n    type = DirichletBC\n    preset = true\n    variable = disp_x\n    boundary = 'NS4'\n    value = 0\n  [../]\n  [./yfix]\n    type = DirichletBC\n    preset = true\n    variable = disp_y\n    boundary = 'NS3'\n    value = 0\n  [../]\n  [./xfix]\n  type = DirichletBC\n  preset = true\n    variable = disp_x\n    boundary = 'NS3'\n    value = 0\n  [../]\n[]\n\n\n[Functions]\n  [./dts]\n    type = PiecewiseConstant\n    x = '0 0.005 0.008'\n    y = '1.0e-5 1.0e-6 1.0e-6'\n  [../]\n[]\n\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensor\n    C_ijkl = '121.15e3 80.769e3'\n    fill_method = symmetric_isotropic\n  [../]\n  [./damage_stress]\n    type = ComputeLinearElasticPFFractureStress\n    c = c\n    E_name = 'elastic_energy'\n    D_name = 'degradation'\n    F_name = 'local_fracture_energy'\n    decomposition_type = stress_spectral  \n  [../]\n  [./degradation]\n    type = DerivativeParsedMaterial\n    f_name = degradation\n    args = 'c'\n    function = '(1.0-c)^2*(1.0 - eta) + eta'\n    constant_names       = 'eta'\n    constant_expressions = '1.0e-5'\n    derivative_order = 2\n  [../]\n[]\n\n[Postprocessors]\n  [./resid_x]\n    type = NodalSum\n    variable = resid_x\n    boundary = 'NS3'\n  [../]\n  [./resid_y]\n    type = NodalSum\n    variable = resid_y\n    boundary = 'NS3'\n  [../]\n  outputs = 'csv'\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Executioner]\n  type = Transient\n\n  solve_type = PJFNK\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart'\n  petsc_options_value = 'hypre boomeramg 101'\n  automatic_scaling = true\n\n   nl_rel_tol = 1e-6\n   l_tol = 1e-4\n\n   l_max_its = 100\n   nl_max_its = 30\n\n   end_time = 0.008\n\n  [./TimeStepper]\n    type = FunctionDT\n    function = dts\n  [../]\n\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  interval = 10\n[]\n\nfracture.i\n[Mesh]\nfile = Miehe.inp\n[]\n\n[Variables]\n  [./c]\n    family = LAGRANGE\n    order = FIRST\n  [../]\n    [./disp_x]\n    family = LAGRANGE\n    order = FIRST\n  [../]\n    [./disp_y]\n    family = LAGRANGE\n    order = FIRST\n  [../]\n[]\n\n[AuxVariables]\n  [./bounds_dummy]\n    order = FIRST\n    family = LAGRANGE\n    [../]\n[]\n\n[Kernels]\n  [./ACbulk]\n    type = AllenCahn\n    variable = c\n    f_name = F\n  [../]\n  [./ACInterfaceCleavageFracture]\n    type = ACInterface\n    variable = c\n    kappa_name = kappa_op\n  [../]\n  [./dcdt]\n    type = TimeDerivative\n    variable = c\n  [../]\n  [./solid_x]\n    type = PhaseFieldFractureMechanicsOffDiag\n    variable = disp_x\n    component = 0\n    c = c\n  [../]\n  [./solid_y]\n    type = PhaseFieldFractureMechanicsOffDiag\n    variable = disp_y\n    component = 1\n    c = c\n  [../]\n  [./off_disp]\n    type = AllenCahnElasticEnergyOffDiag\n    variable = c\n    displacements = 'disp_x disp_y'\n    mob_name = L\n  [../]\n[]\n\n\n[Functions]\n  [./dts]\n    type = PiecewiseConstant\n    x = '0 0.005 0.008'\n    y = '1.0e-5 1.0e-6 1.0e-6'\n[]\n[]\n\n\n[Materials]\n  [./pfbulkmat]\n    type = GenericConstantMaterial\n    prop_names = 'gc_prop l visco'\n    prop_values = '2.7 0.015 1e-6'\n  [../]\n  [./define_mobility]\n    type = ParsedMaterial\n    material_property_names = 'gc_prop visco'\n    f_name = L\n    function = '1.0/(gc_prop * visco)'\n  [../]\n  [./define_kappa]\n    type = ParsedMaterial\n    material_property_names = 'gc_prop l'\n    f_name = kappa_op\n    function = 'gc_prop * l'\n  [../]\n  [./local_fracture_energy]\n    type = DerivativeParsedMaterial\n    f_name = local_fracture_energy\n    args = 'c'\n    material_property_names = 'gc_prop l'\n    function = 'c^2 * gc_prop / 2 / l'\n    derivative_order = 2\n  [../]\n  [./fracture_driving_energy]\n    type = DerivativeSumMaterial\n    args = c\n    sum_materials = 'elastic_energy local_fracture_energy'\n    derivative_order = 2\n    f_name = F\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Bounds]\n  [./c_upper_bound]\n    type = ConstantBoundsAux\n    variable = bounds_dummy\n    bounded_variable = c\n    bound_type = upper\n    bound_value = 1.0\n  [../]\n  [./c_lower_bound]\n    type = VariableOldValueBoundsAux\n    variable = bounds_dummy\n    bounded_variable = c\n    bound_type = lower\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n  automatic_scaling = true\n\n   nl_rel_tol = 1e-6\n   l_tol = 1e-4\n\n   l_max_its = 100\n   nl_max_its = 30\n\n   end_time = 0.008\n\n  [./TimeStepper]\n    type = FunctionDT\n    function = dts\n  [../]\n\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nI have already transferred the variables across the apps. But I am wondering, how can I transfer the elastic energy within these apps. However, while running I got the following errors\nfracture0: *** ERROR ***\nfracture0: The following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\nfracture0:\nfracture0: Material property 'elastic_energy', requested by 'fracture_driving_energy' is not defined on block EB1_QUAD4\nfracture0: Material property 'elastic_energy', requested by 'fracture_driving_energy_face' is not defined on block EB1_QUAD4\nfracture0: Material property 'elastic_energy', requested by 'fracture_driving_energy_neighbor' is not defined on block EB1_QUAD4\nfracture0: Material property 'd2Fdcdstrain', requested by 'off_disp' is not defined on block EB1_QUAD4\nfracture0: Material property 'elastic_energy', requested by 'fracture_driving_energy' is not defined on block EB2_QUAD4\nfracture0: Material property 'elastic_energy', requested by 'fracture_driving_energy_face' is not defined on block EB2_QUAD4\nfracture0: Material property 'elastic_energy', requested by 'fracture_driving_energy_neighbor' is not defined on block EB2_QUAD4\nfracture0: Material property 'd2Fdcdstrain', requested by 'off_disp' is not defined on block EB2_QUAD4\n\nPlease help.\nBest\nAvtar",
          "url": "https://github.com/idaholab/moose/discussions/20081",
          "updatedAt": "2023-03-14T09:03:24Z",
          "publishedAt": "2022-01-19T15:29:04Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "avtarsinghh1991"
                  },
                  "bodyText": "Hello\nCan I convert the elastic energy to aux variable using MaterialRealAux in the main app and then convert that aux variable to material property in the sub-app using parsedfuntion?\nin the main app, I did this\n[AuxVariables]\n  [./resid_x]\n  [../]\n  [./resid_y]\n  [../]\n  [./c]\n  [../]\n [./elastic_energy_aux_variable]\n  [../]\n[]\n\n[AuxKernels]\n  [./Materialproperty_to_Aux_variable]\n    type = MaterialRealAux\n    property = elastic_energy\n    variable = elastic_energy_aux_variable\n  [../]\n[]\n\nBut I can't able to figure out how can I convert this aux variable to material property in the sub-app\nIf this is the right approach. What changes should I do in the following snippet for the subapp\n[./phasemap]\ntype = ParsedMaterial\nf_name = phase\nargs = 'eta2 eta3'\nfunction = 'if(eta3>0.5,1,0)-if(eta2>0.5,1,0)'\noutputs = exodus\n[../]\nBest\nAvtar",
                  "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-1999711",
                  "updatedAt": "2022-06-05T08:52:58Z",
                  "publishedAt": "2022-01-19T17:30:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nSo to convert directly an auxvariable to a material property you can use the ParsedMaterial:\n[./phasemap]\n    type = ParsedMaterial\n    f_name = matprop_name_you_want\n    args = 'variable_name'\n    function = 'variable_name'\n[../]",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2000476",
                          "updatedAt": "2022-06-05T08:53:12Z",
                          "publishedAt": "2022-01-19T19:55:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "avtarsinghh1991"
                  },
                  "bodyText": "Thank you.\nI have incorporated that but still, the system is not working.\nI have made a few changes after reading the documentation\nmain app is as:\n[Mesh]\nfile = Miehe.inp\n[]\n\n[MultiApps]\n  [fracture]\n    type = TransientMultiApp\n    input_files = fracture.i\n    execute_on = 'TIMESTEP_END'\n  []\n[]\n\n[Transfers]\n[from_d]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = from_multiapp\n    variable = c\n    source_variable = c\n  []\n  [transfer_disp_x]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = to_multiapp\n    variable = disp_x\n    source_variable = disp_x\n  []\n  [transfer_disp_y]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = to_multiapp\n    variable = disp_y\n    source_variable = disp_y\n  []\n  [transfer_elastic_energy]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = to_multiapp\n    variable = elastic_energy\n    source_variable = elastic_energy_aux_variable\n  []\n[]\n\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n\n[AuxVariables]\n  [./resid_x]\n  [../]\n  [./resid_y]\n  [../]\n  [./c]\n  [../]\n [./elastic_energy_aux_variable]\n     order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./copy_elastic_energy_to_aux_variable]\n    type = MaterialRealAux\n    property = elastic_energy\n    variable = elastic_energy_aux_variable\n  [../]\n[]\n\n\n[Modules]\n  [./TensorMechanics]\n    [./Master]\n      [./All]\n        add_variables = true\n        strain = SMALL\n        additional_generate_output = 'strain_yy stress_yy'\n        planar_formulation = PLANE_STRAIN\n        save_in = 'resid_x resid_y'\n      [../]\n    [../]\n  [../]\n[]\n\n[BCs]\n  [./ydisp]\n    type = FunctionDirichletBC\n    preset = true\n    variable = disp_y\n    boundary = 'NS4'\n    function = 't'\n  [../]\n    [./xdisp]\n    type = DirichletBC\n    preset = true\n    variable = disp_x\n    boundary = 'NS4'\n    value = 0\n  [../]\n  [./yfix]\n    type = DirichletBC\n    preset = true\n    variable = disp_y\n    boundary = 'NS3'\n    value = 0\n  [../]\n  [./xfix]\n  type = DirichletBC\n  preset = true\n    variable = disp_x\n    boundary = 'NS3'\n    value = 0\n  [../]\n[]\n\n\n[Functions]\n  [./dts]\n    type = PiecewiseConstant\n    x = '0 0.005 0.008'\n    y = '1.0e-5 1.0e-6 1.0e-6'\n  [../]\n[]\n\n\n[Materials]\n  [./pfbulkmat]\n    type = GenericConstantMaterial\n    prop_names = 'gc_prop l visco'\n    prop_values = '2.7 0.015 1e-6'\n  [../]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensor\n    C_ijkl = '121.15e3 80.769e3'\n    fill_method = symmetric_isotropic\n  [../]\n  [./damage_stress]\n    type = ComputeLinearElasticPFFractureStress\n    c = c\n    E_name = 'elastic_energy'\n    D_name = 'degradation'\n    F_name = 'local_fracture_energy'\n    decomposition_type = stress_spectral  \n    use_snes_vi_solver = true\n  [../]\n  [./degradation]\n    type = DerivativeParsedMaterial\n    f_name = degradation\n    args = 'c'\n    function = '(1.0-c)^2*(1.0 - eta) + eta'\n    constant_names       = 'eta'\n    constant_expressions = '1.0e-5'\n    derivative_order = 2\n  [../]\n  [./local_fracture_energy]\n    type = DerivativeParsedMaterial\n    f_name = local_fracture_energy\n    args = 'c'\n    material_property_names = 'gc_prop l'\n    function = 'c^2 * gc_prop / 2 / l'\n    derivative_order = 2\n  [../]\n  [./fracture_driving_energy]\n    type = DerivativeSumMaterial\n    args = c\n    sum_materials = 'elastic_energy local_fracture_energy'\n    derivative_order = 2\n    f_name = F\n  [../]\n[]\n\n[Postprocessors]\n  [./resid_x]\n    type = NodalSum\n    variable = resid_x\n    boundary = 'NS3'\n  [../]\n  [./resid_y]\n    type = NodalSum\n    variable = resid_y\n    boundary = 'NS3'\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n  automatic_scaling = true\n\n   nl_rel_tol = 1e-6\n   l_tol = 1e-4\n\n   l_max_its = 100\n   nl_max_its = 30\n\n   end_time = 0.008\n\n  [./TimeStepper]\n    type = FunctionDT\n    function = dts\n  [../]\n\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  interval = 10\n\nsub app is as:\n[Mesh]\nfile = Miehe.inp\n[]\n\n[Variables]\n  [./c]\n    family = LAGRANGE\n    order = FIRST\n  [../]\n  [./disp_x]\n  []\n  [./disp_y]\n  []\n[]\n\n[AuxVariables]\n  [./bounds_dummy]\n    order = FIRST\n    family = LAGRANGE\n    [../]\n  [elastic_energy]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n\n[Kernels]\n  [./ACbulk]\n    type = AllenCahn\n    variable = c\n    f_name = F\n  [../]\n  [./ACInterfaceCleavageFracture]\n    type = ACInterface\n    variable = c\n    kappa_name = kappa_op\n  [../]\n  [./dcdt]\n    type = TimeDerivative\n    variable = c\n  [../]\n  [./solid_x]\n    type = PhaseFieldFractureMechanicsOffDiag\n    variable = disp_x\n    component = 0\n    c = c\n  [../]\n  [./solid_y]\n    type = PhaseFieldFractureMechanicsOffDiag\n    variable = disp_y\n    component = 1\n    c = c\n  [../]\n  [./off_disp]\n    type = AllenCahnElasticEnergyOffDiag\n    variable = c\n    displacements = 'disp_x disp_y'\n    mob_name = L\n  [../]\n[]\n\n\n[Functions]\n  [./dts]\n    type = PiecewiseConstant\n    x = '0 0.005 0.008'\n    y = '1.0e-5 1.0e-6 1.0e-6'\n[]\n[]\n\n\n[Materials]\n  [./pfbulkmat]\n    type = GenericConstantMaterial\n    prop_names = 'gc_prop l visco'\n    prop_values = '2.7 0.015 1e-6'\n  [../]\n  [./define_mobility]\n    type = ParsedMaterial\n    material_property_names = 'gc_prop visco'\n    f_name = L\n    function = '1.0/(gc_prop * visco)'\n  [../]\n  [./define_kappa]\n    type = ParsedMaterial\n    material_property_names = 'gc_prop l'\n    f_name = kappa_op\n    function = 'gc_prop * l'\n  [../]\n  [./local_fracture_energy]\n    type = DerivativeParsedMaterial\n    f_name = local_fracture_energy\n    args = 'c'\n    material_property_names = 'gc_prop l'\n    function = 'c^2 * gc_prop / 2 / l'\n    derivative_order = 2\n  [../]\n  [./fracture_driving_energy]\n    type = DerivativeSumMaterial\n    args = c\n    sum_materials = 'elastic_energy local_fracture_energy'\n    derivative_order = 2\n    f_name = F\n  [../]\n  [./phasemap]\n   type = ParsedMaterial\n   f_name = elastic_energy\n   args = 'elastic_energy'\n   function = 'elastic_energy'\n[../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Bounds]\n  [./c_upper_bound]\n    type = ConstantBoundsAux\n    variable = bounds_dummy\n    bounded_variable = c\n    bound_type = upper\n    bound_value = 1.0\n  [../]\n  [./c_lower_bound]\n    type = VariableOldValueBoundsAux\n    variable = bounds_dummy\n    bounded_variable = c\n    bound_type = lower\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n  automatic_scaling = true\n\n   nl_rel_tol = 1e-6\n   l_tol = 1e-4\n\n   l_max_its = 100\n   nl_max_its = 30\n\n   end_time = 0.008\n\n  [./TimeStepper]\n    type = FunctionDT\n    function = dts\n  [../]\n\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nNow, I am getting the following error\nfracture0: Material property 'd2Fdcdstrain', requested by 'off_disp' is not defined on block EB1_QUAD4\nfracture0: Material property 'd2Fdcdstrain', requested by 'off_disp' is not defined on block EB2_QUAD4\n\nI cannot able to locate if \"d2Fdcdstrain\" is needed by off_disp. Even after blocking the off_disp block, the equations are solved but the damage is not evolving.\nBest\nAvtar",
                  "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2000690",
                  "updatedAt": "2022-06-05T08:53:12Z",
                  "publishedAt": "2022-01-19T20:29:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I recommend you search for other inputs using this off_disp AllenCahnElasticEnergyOffDiag kernel and see what they have that is defining this material property",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2001526",
                          "updatedAt": "2022-06-05T08:53:13Z",
                          "publishedAt": "2022-01-19T23:15:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi\nSo I see a few problems with these inputs.\nBoth solves are on the same mesh, which lets me think that you do not want to be using a variable value sample transfer. This is to take the variable value at a point in the mesh, and create a simulation that is local to that point. For a multiscale approach basically.\nI think you want to be using a MultiAppCopyTrasnfer, to transfer the full field from one app to the other.\nThen disp_x, c are primary variables in both applications. You cant transfer to primary variables, since these are the variables you are solving for. You need to trasnfer to an auxiliary variable with a different name, then use it as an initial condition for the primary variable. Or at least that's what I think you should do, but it really depends on what your coupling scheme is.\nhold that thought, I need to check on this\nEDIT: took a long time to type. I saw you fixed issue number 1\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2000720",
                  "updatedAt": "2022-06-05T08:53:13Z",
                  "publishedAt": "2022-01-19T20:34:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Hello @GiudGiud\nI have one doubt here. Do I need to define disp_x and disp_y in the sub-app as auxiliary variables?\nHowever, I have tried that and found the following error\nfracture0: No nonlinear variable named disp_x found. Did you specify an auxiliary variable when you meant to specify a nonlinear variable (or vice-versa)?\nBest\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2000831",
                          "updatedAt": "2022-06-05T08:53:13Z",
                          "publishedAt": "2022-01-19T20:53:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No since the fracture input also needs displacement. I ll reply again soon once I've looked at what s needed to do what you want",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2001533",
                          "updatedAt": "2022-06-05T08:53:13Z",
                          "publishedAt": "2022-01-19T23:15:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok so transferring to main variables seems supported, and cant think of an actual way to work with auxvariables beyond the first timestep anyway.\nSo you should be able to work with what you have now.\nBut I think you need to be careful with the ordering.\nYou want:\nsolve elastic\nsend c, disp_xy to fracture\nsolve fracture\nsend c_disp_xy to elastic\nright?",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2001865",
                          "updatedAt": "2022-06-05T08:53:13Z",
                          "publishedAt": "2022-01-20T00:11:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@asingh-mit Are you trying to run phase-field fracture in a staggered way? i.e., the main app solves the displacements and sub app solves for damage. If so, you should transfer the displacement from main app to sub app as aux variable.",
                  "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2002985",
                  "updatedAt": "2022-06-05T08:53:13Z",
                  "publishedAt": "2022-01-20T05:04:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "avtarsinghh1991"
                  },
                  "bodyText": "Hello @jiangwen84 @GiudGiud\nNow I am completely shifted to a staggered approach. For that, I do not need to pass the disp_x and disp_y to the fracture. Because fracture needs only the elastic energy and fracture energy as inputs for solving the phase-field equation. Fracture_energy, I am already calculating in the fracture app so I need to pass only the elastic_energy.\nSo the algorithm is like,\n\nSolve displacement field,\ncalculate the elastic energy\nsend the elastic energy to the fracture\nsolve the phase-field fracture\nsend the phase-field parameter back to elasticity\n\nBelow are the input files for both\nelasticity.i\n[Mesh]\nfile = Miehe.inp\n[]\n\n[MultiApps]\n  [fracture]\n    type = TransientMultiApp\n    input_files = fracture.i\n    execute_on = 'TIMESTEP_END'\n  []\n[]\n\n[Transfers]\n[from_d]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = from_multiapp\n    variable = damage\n    source_variable = c\n  []\n  [transfer_elastic_energy]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = to_multiapp\n    variable = elastic_energy\n    source_variable = elastic_energy_aux_variable\n  []\n[]\n\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Variables]\n[./disp_x]\n    family = LAGRANGE\n    order = FIRST\n  [../]\n  [./disp_y]\n      family = LAGRANGE\n    order = FIRST\n  []\n[]\n\n[AuxVariables]\n  [./resid_x]\n  [../]\n  [./resid_y]\n  [../]\n  [./damage]\n  [../]\n [./elastic_energy_aux_variable]\n     order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./copy_elastic_energy_to_aux_variable]\n    type = MaterialRealAux\n    property = elastic_energy\n    variable = elastic_energy_aux_variable\n  [../]\n[]\n\n\n[Modules]\n  [./TensorMechanics]\n    [./Master]\n      [./All]\n        add_variables = true\n        strain = SMALL\n        additional_generate_output = 'strain_yy stress_yy'\n        planar_formulation = PLANE_STRAIN\n        save_in = 'resid_x resid_y'\n      [../]\n    [../]\n  [../]\n[]\n\n[BCs]\n  [./ydisp]\n    type = FunctionDirichletBC\n    preset = true\n    variable = disp_y\n    boundary = 'NS4'\n    function = 't'\n  [../]\n    [./xdisp]\n    type = DirichletBC\n    preset = true\n    variable = disp_x\n    boundary = 'NS4'\n    value = 0\n  [../]\n  [./yfix]\n    type = DirichletBC\n    preset = true\n    variable = disp_y\n    boundary = 'NS3'\n    value = 0\n  [../]\n  [./xfix]\n  type = DirichletBC\n  preset = true\n    variable = disp_x\n    boundary = 'NS3'\n    value = 0\n  [../]\n[]\n\n\n[Functions]\n  [./dts]\n    type = PiecewiseConstant\n    x = '0 0.005 0.008'\n    y = '1.0e-5 1.0e-6 1.0e-6'\n  [../]\n[]\n\n\n[Materials]\n  [./pfbulkmat]\n    type = GenericConstantMaterial\n    prop_names = 'gc_prop l visco'\n    prop_values = '2.7 0.015 1e-6'\n  [../]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensor\n    C_ijkl = '121.15e3 80.769e3'\n    fill_method = symmetric_isotropic\n  [../]\n  [./damage_stress]\n    type = ComputeLinearElasticPFFractureStress\n    c = damage\n    E_name = 'elastic_energy'\n    D_name = 'degradation'\n    F_name = 'local_fracture_energy'\n    decomposition_type = stress_spectral  \n    use_snes_vi_solver = true\n  [../]\n  [./degradation]\n    type = DerivativeParsedMaterial\n    f_name = degradation\n    args = 'damage'\n    function = '(1.0-damage)^2*(1.0 - eta) + eta'\n    constant_names       = 'eta'\n    constant_expressions = '1.0e-5'\n    derivative_order = 2\n  [../]\n  [./local_fracture_energy]\n    type = DerivativeParsedMaterial\n    f_name = local_fracture_energy\n    args = 'damage'\n    material_property_names = 'gc_prop l'\n    function = 'damage^2 * gc_prop / 2 / l'\n    derivative_order = 2\n  [../]\n[]\n\n[Postprocessors]\n  [./resid_x]\n    type = NodalSum\n    variable = resid_x\n    boundary = 'NS3'\n  [../]\n  [./resid_y]\n    type = NodalSum\n    variable = resid_y\n    boundary = 'NS3'\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n  automatic_scaling = true\n\n   nl_rel_tol = 1e-6\n   l_tol = 1e-4\n\n   l_max_its = 100\n   nl_max_its = 30\n\n   end_time = 0.008\n\n  [./TimeStepper]\n    type = FunctionDT\n    function = dts\n  [../]\n\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  interval = 10\n[]\n\nfracture.i\n[Mesh]\nfile = Miehe.inp\n[]\n\n[Variables]\n  [./c]\n    family = LAGRANGE\n    order = FIRST\n  [../]\n[]\n\n[AuxVariables]\n  [./bounds_dummy]\n    order = FIRST\n    family = LAGRANGE\n    [../]\n  [elastic_energy]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n\n[Kernels]\n  [./ACbulk]\n    type = AllenCahn\n    variable = c\n    f_name = F\n  [../]\n  [./ACInterfaceCleavageFracture]\n    type = ACInterface\n    variable = c\n    kappa_name = kappa_op\n  [../]\n  [./dcdt]\n    type = TimeDerivative\n    variable = c\n  [../]\n[]\n\n\n[Functions]\n  [./dts]\n    type = PiecewiseConstant\n    x = '0 0.005 0.008'\n    y = '1.0e-5 1.0e-6 1.0e-6'\n[]\n[]\n\n\n[Materials]\n  [./pfbulkmat]\n    type = GenericConstantMaterial\n    prop_names = 'gc_prop l visco'\n    prop_values = '2.7 0.015 1e-6'\n  [../]\n  [./define_mobility]\n    type = ParsedMaterial\n    material_property_names = 'gc_prop visco'\n    f_name = L\n    function = '1.0/(gc_prop * visco)'\n  [../]\n  [./define_kappa]\n    type = ParsedMaterial\n    material_property_names = 'gc_prop l'\n    f_name = kappa_op\n    function = 'gc_prop * l'\n  [../]\n  [./local_fracture_energy]\n    type = DerivativeParsedMaterial\n    f_name = local_fracture_energy\n    args = 'c'\n    material_property_names = 'gc_prop l'\n    function = 'c^2 * gc_prop / 2 / l'\n    derivative_order = 2\n  [../]\n  [./fracture_driving_energy]\n    type = DerivativeSumMaterial\n    args = c\n    sum_materials = 'elastic_energy_mat local_fracture_energy'\n    derivative_order = 2\n    f_name = F\n  [../]\n  [./phasemap]\n   type = ParsedMaterial\n   f_name = elastic_energy_mat\n   args = 'elastic_energy'\n   function = 'elastic_energy'\n[../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Bounds]\n  [./c_upper_bound]\n    type = ConstantBoundsAux\n    variable = bounds_dummy\n    bounded_variable = c\n    bound_type = upper\n    bound_value = 1.0\n  [../]\n  [./c_lower_bound]\n    type = VariableOldValueBoundsAux\n    variable = bounds_dummy\n    bounded_variable = c\n    bound_type = lower\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n  automatic_scaling = true\n\n   nl_rel_tol = 1e-6\n   l_tol = 1e-4\n\n   l_max_its = 100\n   nl_max_its = 30\n\n   end_time = 0.008\n\n  [./TimeStepper]\n    type = FunctionDT\n    function = dts\n  [../]\n\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n\nNow the equations are getting solved, but the damage is not evolving at all. The residual for the damage field is zero which means it's not getting the driving force to solve. I think there may be some issue with transferring the elastic_energy.\nOUTPUT\nCreating MultiApp fracture of type BabblerTestApp of level 1 and number 0:\nfracture0:\nFramework Information:\nMOOSE Version:           git commit 8eba9cfbca on 2021-11-25\nLibMesh Version:\nPETSc Version:           3.15.1\nSLEPc Version:           3.15.1\nCurrent Time:            Thu Jan 20 08:53:05 2022\nExecutable Timestamp:    Mon Jan 17 13:25:10 2022\n\nParallelism:\n  Num Processors:          4\n  Num Threads:             1\n\nMesh:\n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:\n    Total:                 18366\n    Local:                 4685\n    Min/Max/Avg:           4525/4685/4591\n  Elems:\n    Total:                 18245\n    Local:                 4561\n    Min/Max/Avg:           4561/4562/4561\n  Num Subdomains:          2\n  Num Partitions:          4\n  Partitioner:             metis\n\nNonlinear System:\n  Num DOFs:                36732\n  Num Local DOFs:          9370\n  Variables:               { \"disp_x\" \"disp_y\" }\n  Finite Element Types:    \"LAGRANGE\"\n  Approximation Orders:    \"FIRST\"\n\nAuxiliary System:\n  Num DOFs:                109833\n  Num Local DOFs:          27738\n  Variables:               { \"resid_x\" \"resid_y\" \"damage\" } { \"elastic_energy_aux_variable\" \"strain_yy\"\n                             \"stress_yy\" }\n  Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\"\n  Approximation Orders:    \"FIRST\" \"CONSTANT\"\n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             FunctionDT\n  Solver Mode:             NEWTON\n  MOOSE Preconditioner:    SMP\n\n\nRunning App: main\nfracture0: Parallelism:\nfracture0:   Num Processors:          4\nfracture0:   Num Threads:             1\nfracture0:\nfracture0: Mesh:\nfracture0:   Parallel Type:           replicated\nfracture0:   Mesh Dimension:          2\nfracture0:   Spatial Dimension:       2\nfracture0:   Nodes:\nfracture0:     Total:                 18366\nfracture0:     Local:                 4685\nfracture0:     Min/Max/Avg:           4525/4685/4591\nfracture0:   Elems:\nfracture0:     Total:                 18245\nfracture0:     Local:                 4561\nfracture0:     Min/Max/Avg:           4561/4562/4561\nfracture0:   Num Subdomains:          2\nfracture0:   Num Partitions:          4\nfracture0:   Partitioner:             metis\nfracture0:\nfracture0: Nonlinear System:\nfracture0:   Num DOFs:                18366\nfracture0:   Num Local DOFs:          4685\nfracture0:   Variables:               \"c\"\nfracture0:   Finite Element Types:    \"LAGRANGE\"\nfracture0:   Approximation Orders:    \"FIRST\"\nfracture0:\nfracture0: Auxiliary System:\nfracture0:   Num DOFs:                36611\nfracture0:   Num Local DOFs:          9246\nfracture0:   Variables:               \"bounds_dummy\" \"elastic_energy\"\nfracture0:   Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\"\nfracture0:   Approximation Orders:    \"FIRST\" \"CONSTANT\"\nfracture0:\nfracture0: Execution Information:\nfracture0:   Executioner:             Transient\nfracture0:   TimeStepper:             FunctionDT\nfracture0:   Solver Mode:             NEWTON\nfracture0:   MOOSE Preconditioner:    SMP\nfracture0:\nfracture0:\nfracture0: Running App: fracture0\nfracture0:\nfracture0: Time Step 0, time = 0\n\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+\n| time           | resid_x        | resid_y        |\n+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+----------------+\n\n\nTime Step 1, time = 1e-05, dt = 1e-05\n\nBacking Up MultiApps on TIMESTEP_BEGIN\nFinished Backing Up MultiApps on TIMESTEP_BEGIN\n\n\nStarting Transfers on TIMESTEP_BEGIN To MultiApps\nBeginning MultiAppCopyTransfer transfer_elastic_energy\nFinished MultiAppCopyTransfer transfer_elastic_energy\nTransfers on TIMESTEP_BEGIN Are Finished\n\n\nExecuting MultiApps on TIMESTEP_BEGIN\nSolving MultiApp 'fracture' with target time 1e-05 and dt 1e-05 with auto-advance on\nfracture0:\nfracture0: Time Step 1, time = 1e-05, dt = 1e-05\nfracture0:\nfracture0: Performing automatic scaling calculation\nfracture0:\nfracture0:  0 Nonlinear |R| = 0.000000e+00\nfracture0:  Solve Converged!\nSuccessfully Solved MultiApp fracture.\nFinished Executing MultiApps on TIMESTEP_BEGIN\n\n\nStarting Transfers on TIMESTEP_BEGIN From MultiApps\nBeginning MultiAppCopyTransfer from_d\nFinished MultiAppCopyTransfer from_d\nTransfers on TIMESTEP_BEGIN Are Finished\n\n\nPerforming automatic scaling calculation\n\n Solve Converged!\n  Finished Solving                                                                       [  1.13 s] [  116 MB]\n\nTime Step 2, time = 2e-05, dt = 1e-05\n\nBacking Up MultiApps on TIMESTEP_BEGIN\nFinished Backing Up MultiApps on TIMESTEP_BEGIN\n\n\nStarting Transfers on TIMESTEP_BEGIN To MultiApps\nBeginning MultiAppCopyTransfer transfer_elastic_energy\nFinished MultiAppCopyTransfer transfer_elastic_energy\nTransfers on TIMESTEP_BEGIN Are Finished\n\n\nExecuting MultiApps on TIMESTEP_BEGIN\nSolving MultiApp 'fracture' with target time 2e-05 and dt 1e-05 with auto-advance on\nfracture0:\nfracture0: Time Step 2, time = 2e-05, dt = 1e-05\nfracture0:  0 Nonlinear |R| = 0.000000e+00\nfracture0:  Solve Converged!\nSuccessfully Solved MultiApp fracture.\nFinished Executing MultiApps on TIMESTEP_BEGIN\n\n\nStarting Transfers on TIMESTEP_BEGIN From MultiApps\nBeginning MultiAppCopyTransfer from_d\nFinished MultiAppCopyTransfer from_d\nTransfers on TIMESTEP_BEGIN Are Finished\n\n Solve Converged!\n\nTime Step 3, time = 3e-05, dt = 1e-05\n\nBacking Up MultiApps on TIMESTEP_BEGIN\nFinished Backing Up MultiApps on TIMESTEP_BEGIN\n\n\nStarting Transfers on TIMESTEP_BEGIN To MultiApps\nBeginning MultiAppCopyTransfer transfer_elastic_energy\nFinished MultiAppCopyTransfer transfer_elastic_energy\nTransfers on TIMESTEP_BEGIN Are Finished\n\n\nExecuting MultiApps on TIMESTEP_BEGIN\nSolving MultiApp 'fracture' with target time 3e-05 and dt 1e-05 with auto-advance on\nfracture0:\nfracture0: Time Step 3, time = 3e-05, dt = 1e-05\nfracture0:  0 Nonlinear |R| = 0.000000e+00\nfracture0:  Solve Converged!\nSuccessfully Solved MultiApp fracture.\nFinished Executing MultiApps on TIMESTEP_BEGIN\n\n\nStarting Transfers on TIMESTEP_BEGIN From MultiApps\nBeginning MultiAppCopyTransfer from_d\nFinished MultiAppCopyTransfer from_d\nTransfers on TIMESTEP_BEGIN Are Finished\n\n Solve Converged!\n\nTime Step 4, time = 4e-05, dt = 1e-05\n\nBacking Up MultiApps on TIMESTEP_BEGIN\nFinished Backing Up MultiApps on TIMESTEP_BEGIN\n\n\nStarting Transfers on TIMESTEP_BEGIN To MultiApps\nBeginning MultiAppCopyTransfer transfer_elastic_energy\nFinished MultiAppCopyTransfer transfer_elastic_energy\nTransfers on TIMESTEP_BEGIN Are Finished\n\n\nExecuting MultiApps on TIMESTEP_BEGIN\nSolving MultiApp 'fracture' with target time 4e-05 and dt 1e-05 with auto-advance on\nfracture0:\nfracture0: Time Step 4, time = 4e-05, dt = 1e-05\nfracture0:  0 Nonlinear |R| = 0.000000e+00\nfracture0:  Solve Converged!\nSuccessfully Solved MultiApp fracture.\nFinished Executing MultiApps on TIMESTEP_BEGIN\n\n\nStarting Transfers on TIMESTEP_BEGIN From MultiApps\nBeginning MultiAppCopyTransfer from_d\nFinished MultiAppCopyTransfer from_d\nTransfers on TIMESTEP_BEGIN Are Finished\n\nBest\nAvtar",
                  "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2006702",
                  "updatedAt": "2022-06-05T08:53:13Z",
                  "publishedAt": "2022-01-20T14:02:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Transfer the material property (elastic_energy) through a AuxVariable is not a good idea. It needs first to project the material property to the nodes and then interpolate it back to quadrature points. This will cause accuracy issue. In addition, you should not use CONSTANT MONOMIAL for elastic_energy because that averages the material property as a single value. I am not sure quite sure if the FIRST MONOMIAL would work or not, but you can give it a shot. You can output material property by adding outputs = exodus to visualize them in paraview. Take a look at if you get nonzero elastic energy in the sub app.\nI suggest you transfer displacement variables and recompute the elastic energy in the fracture app. We have been using that for the staggered approach. A better approach is to transfer the material property directly, but as you already discovered, that is not supported yet.\nLastly, you need to add Picard iteration to ensure your solution converges for each time step.",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2007956",
                          "updatedAt": "2022-06-26T03:45:23Z",
                          "publishedAt": "2022-01-20T16:32:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "@asingh-mit You can use these inputs as a reference for setting up your model in moose in a staggered way: https://github.com/hugary1995/raccoon/tree/master/tutorials/mode1_brittle_fracture\n@jiangwen84 is right about the accuracy issue using constant monomials for transferring elastic energy. However, that error is usually quite acceptable in practice in my experience.",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2008030",
                          "updatedAt": "2022-06-26T03:45:23Z",
                          "publishedAt": "2022-01-20T16:34:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "avtarsinghh1991"
                  },
                  "bodyText": "Thank you very much. I have used the approach proposed by @jiangwen84 as\n\"I suggest you transfer displacement variables and recompute the elastic energy in the fracture app. We have been using that for the staggered approach. A better approach is to transfer the material property directly, but as you already discovered, that is not supported yet.\"\nHowever, it works absolutely fine until the damage doesn't reach 1. As soon as it reaches 1, the system is diverging.\nI am using the following options for solving the damage field in the sub app\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n  automatic_scaling = true\n\nBut not working. Please suggest any solution.\nInput files as below:\nElasticity.i\n[Mesh]\n file = Miehe.inp\n[]\n\n[MultiApps]\n  [fracture]\n    type = TransientMultiApp\n    input_files = fracture.i\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n[]\n\n[Transfers]\n[from_d]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = from_multiapp\n    variable = damage\n    source_variable = c\n  []\n  [to_d_disp_x]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = to_multiapp\n    variable = disp_x_aux\n    source_variable = disp_x\n  []\n  [to_d_disp_y]\n    type = MultiAppCopyTransfer\n    multi_app = fracture\n    direction = to_multiapp\n    variable = disp_y_aux\n    source_variable = disp_y\n  []\n[]\n\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n\n[AuxVariables]\n  [./resid_x]\n  [../]\n  [./resid_y]\n  [../]\n  [./damage]\n  [../]\n  [./disp_x_aux]\n    family = LAGRANGE\n    order = FIRST\n  [../]\n  [./disp_y_aux]\n      family = LAGRANGE\n    order = FIRST\n  []\n[]\n\n\n[Modules]\n  [./TensorMechanics]\n    [./Master]\n      [./All]\n        add_variables = true\n        strain = SMALL\n        additional_generate_output = 'strain_yy stress_yy'\n        planar_formulation = PLANE_STRAIN\n        save_in = 'resid_x resid_y'\n      [../]\n    [../]\n  [../]\n[]\n\n[BCs]\n  [./ydisp]\n    type = FunctionDirichletBC\n    preset = true\n    variable = disp_y\n    boundary = 'NS4'\n    function = 't'\n  [../]\n    [./xdisp]\n    type = DirichletBC\n    preset = true\n    variable = disp_x\n    boundary = 'NS4'\n    value = 0\n  [../]\n  [./yfix]\n    type = DirichletBC\n    preset = true\n    variable = disp_y\n    boundary = 'NS3'\n    value = 0\n  [../]\n  [./xfix]\n  type = DirichletBC\n  preset = true\n    variable = disp_x\n    boundary = 'NS3'\n    value = 0\n  [../]\n[]\n\n\n[Functions]\n  [./dts]\n    type = PiecewiseConstant\n    x = '0 0.005 0.008'\n    y = '1.0e-5 1.0e-6 1.0e-6'\n  [../]\n[]\n\n\n[Materials]\n  [./pfbulkmat]\n    type = GenericConstantMaterial\n    prop_names = 'gc_prop l visco'\n    prop_values = '2.7 0.015 1e-6'\n  [../]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensor\n    C_ijkl = '121.15e3 80.769e3'\n    fill_method = symmetric_isotropic\n  [../]\n  [./damage_stress]\n    type = ComputeLinearElasticPFFractureStress\n    c = damage\n    E_name = 'elastic_energy'\n    D_name = 'degradation'\n    F_name = 'local_fracture_energy'\n    decomposition_type = stress_spectral \n    use_snes_vi_solver = true\n  [../]\n  [./degradation]\n    type = DerivativeParsedMaterial\n    f_name = degradation\n    args = 'damage'\n    function = '(1.0-damage)^2*(1.0 - eta) + eta'\n    constant_names       = 'eta'\n    constant_expressions = '1.0e-5'\n    derivative_order = 2\n  [../]\n  [./local_fracture_energy]\n    type = DerivativeParsedMaterial\n    f_name = local_fracture_energy\n    args = 'damage'\n    material_property_names = 'gc_prop l'\n    function = 'damage^2 * gc_prop / 2 / l'\n    derivative_order = 2\n  [../]\n[]\n\n\n[Postprocessors]\n  [./resid_x]\n    type = NodalSum\n    variable = resid_x\n    boundary = 'NS3'\n  [../]\n  [./resid_y]\n    type = NodalSum\n    variable = resid_y\n    boundary = 'NS3'\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Executioner]\n  type = Transient\n\n  solve_type = 'NEWTON'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n#  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart'\n#  petsc_options_value = 'hypre boomeramg 300'\n  automatic_scaling = true\n\n   nl_rel_tol = 1e-6\n   l_tol = 1e-4\n\n   l_max_its = 50\n   nl_max_its = 100\n\n   end_time = 0.008\n\n  [./TimeStepper]\n    type = FunctionDT\n    function = dts\n  [../]\n\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  interval = 10\n[]\n\nand fracture.i\n[Mesh]\nfile = Miehe.inp\n[]\n\n[Variables]\n  [./c]\n    family = LAGRANGE\n    order = FIRST\n  [../]\n[]\n\n[AuxVariables]\n  [./bounds_dummy]\n    order = FIRST\n    family = LAGRANGE\n    [../]\n      [./disp_x_aux]\n    family = LAGRANGE\n    order = FIRST\n  [../]\n  [./disp_y_aux]\n    family = LAGRANGE\n    order = FIRST\n  []\n[]\n\n\n[Kernels]\n  [./ACbulk]\n    type = AllenCahn\n    variable = c\n    f_name = F\n  [../]\n  [./ACInterfaceCleavageFracture]\n    type = ACInterface\n    variable = c\n    kappa_name = kappa_op\n  [../]\n  [./dcdt]\n    type = TimeDerivative\n    variable = c\n  [../]\n[]\n\n\n[Functions]\n  [./dts]\n    type = PiecewiseConstant\n    x = '0 0.005 0.008'\n    y = '1.0e-5 1.0e-6 1.0e-6'\n[]\n[]\n\n\n[Materials]\n  [./pfbulkmat]\n    type = GenericConstantMaterial\n    prop_names = 'gc_prop l visco'\n    prop_values = '2.7 0.015 1e-6'\n  [../]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensor\n    C_ijkl = '121.15e3 80.769e3'\n    fill_method = symmetric_isotropic\n  [../]\n  [./strain]\n    type = ComputeSmallStrain\n    displacements = 'disp_x_aux disp_y_aux'\n   [../]\n  [./damage_stress]\n    type = ComputeLinearElasticPFFractureStress\n    c = c\n    E_name = 'elastic_energy'\n    D_name = 'degradation'\n    F_name = 'local_fracture_energy'\n    decomposition_type = stress_spectral \n    use_snes_vi_solver = true\n  [../]\n  [./degradation]\n    type = DerivativeParsedMaterial\n    f_name = degradation\n    args = 'c'\n    function = '(1.0-c)^2*(1.0 - eta) + eta'\n    constant_names       = 'eta'\n    constant_expressions = '1.0e-5'\n    derivative_order = 2\n  [../]\n  [./define_mobility]\n    type = ParsedMaterial\n    material_property_names = 'gc_prop visco'\n    f_name = L\n    function = '1.0/(gc_prop * visco)'\n  [../]\n  [./define_kappa]\n    type = ParsedMaterial\n    material_property_names = 'gc_prop l'\n    f_name = kappa_op\n    function = 'gc_prop * l'\n  [../]\n  [./local_fracture_energy]\n    type = DerivativeParsedMaterial\n    f_name = local_fracture_energy\n    args = 'c'\n    material_property_names = 'gc_prop l'\n    function = 'c^2 * gc_prop / 2 / l'\n    derivative_order = 2\n  [../]\n  [./fracture_driving_energy]\n    type = DerivativeSumMaterial\n    args = c\n    sum_materials = 'elastic_energy local_fracture_energy'\n    derivative_order = 2\n    f_name = F\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Bounds]\n  [./c_upper_bound]\n    type = ConstantBoundsAux\n    variable = bounds_dummy\n    bounded_variable = c\n    bound_type = upper\n    bound_value = 1.0\n  [../]\n  [./c_lower_bound]\n    type = VariableOldValueBoundsAux\n    variable = bounds_dummy\n    bounded_variable = c\n    bound_type = lower\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n  automatic_scaling = true\n\n   nl_rel_tol = 1e-4\n   l_tol = 1e-6\n\n   l_max_its = 50\n   nl_max_its = 30\n\n   end_time = 0.008\n\n  [./TimeStepper]\n    type = FunctionDT\n    function = dts\n  [../]\n\n[]\n\n[Outputs]\n  exodus = false\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2074865",
                  "updatedAt": "2022-06-26T03:45:31Z",
                  "publishedAt": "2022-01-30T04:42:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is there something unphysical about damage reaching one?\nWhat does it mean for the system?",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2093606",
                          "updatedAt": "2022-06-26T03:45:59Z",
                          "publishedAt": "2022-02-02T06:01:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Actually, the drop of load after reaching the maximum value is quite vertical. However, I checked that with both the module in a single app, the same problem works absolutely fine.",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2096945",
                          "updatedAt": "2022-06-26T03:45:59Z",
                          "publishedAt": "2022-02-02T15:50:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would refine the time steps a lot and try to understand what is physically happening to the app that fails.\nThe system diverging often means something is unacceptable with the physical quantities / the physics being solved in that configuration",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2097015",
                          "updatedAt": "2022-06-26T03:45:59Z",
                          "publishedAt": "2022-02-02T15:56:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thanks, @GiudGiud. I will try to reduce the time step. My only concern is the same problem with all the parameters keeping the same, it is converging absolutely fine within a single app. I will update you after getting the results with the reduced time step.",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2098396",
                          "updatedAt": "2022-07-11T05:31:01Z",
                          "publishedAt": "2022-02-02T16:53:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "are you converging the segregated solve coupling at every time step btw?\nYou should be running fixed point iterations if you want to match the fully coupled results",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2098416",
                          "updatedAt": "2022-07-11T05:31:00Z",
                          "publishedAt": "2022-02-02T16:56:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@asingh-mit any update on this?",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2504866",
                          "updatedAt": "2022-07-11T05:31:00Z",
                          "publishedAt": "2022-04-05T02:54:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Its still not converging. But I am not pursuing it further. Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-2508445",
                          "updatedAt": "2022-07-11T05:31:00Z",
                          "publishedAt": "2022-04-05T14:00:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "any update on this ? is it answered ?",
                          "url": "https://github.com/idaholab/moose/discussions/20081#discussioncomment-5300766",
                          "updatedAt": "2023-03-14T09:03:24Z",
                          "publishedAt": "2023-03-14T09:03:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Accessing View Factor Study inside GrayDiffuseRadiation",
          "author": {
            "login": "mrplants"
          },
          "bodyText": "I am using the GrayDiffuseRadiation action and I want to visualize the rays from the view factor study that I assume it uses internally.  How do I access this view factor study?\nHere is the relevant portion of my HIT file.\n[GrayDiffuseRadiation]\n  [vacuum_radiation]\n    boundary = 'stator_inner_surface_sideset rotor_outer_surface_sideset'\n    emissivity = '0.03 0.03'\n    n_patches = '20 20'\n    temperature = Temperature\n    ray_tracing_face_type = 'GAUSS'\n  []\n[]\n\n...\n\n[Outputs]\n  exodus = true\n  [rays]\n    type = RayTracingExodus\n    study = NOT_SURE_WHAT_TO_PUT_HERE\n    execute_on = FINAL\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23696",
          "updatedAt": "2023-03-14T02:32:01Z",
          "publishedAt": "2023-03-12T21:42:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "mrplants"
                  },
                  "bodyText": "I am using the same code from this question here:  #23590",
                  "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5285055",
                  "updatedAt": "2023-03-12T21:43:16Z",
                  "publishedAt": "2023-03-12T21:43:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I suspect it should be this: vacuum_radiation",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5285673",
                          "updatedAt": "2023-03-12T23:44:10Z",
                          "publishedAt": "2023-03-12T23:44:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Unfortunately, that does not work.  See attached screenshot for the results:",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5286431",
                          "updatedAt": "2023-03-13T02:40:02Z",
                          "publishedAt": "2023-03-13T02:40:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in the code I see ray_study_uo_ + _name\nso try ray_study_uo_vacuum_radiation\nIf that does not work, add Debug/show_actions=true and look for the name of the study there",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5286547",
                          "updatedAt": "2023-03-13T03:04:51Z",
                          "publishedAt": "2023-03-13T03:04:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Good idea!  With that name, the error is:",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5286555",
                          "updatedAt": "2023-03-13T03:06:23Z",
                          "publishedAt": "2023-03-13T03:06:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Maybe the study doesn't cache the rays by default?  Is there a way to force that through the GrayDiffuseRadiation action?",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5286574",
                          "updatedAt": "2023-03-13T03:11:00Z",
                          "publishedAt": "2023-03-13T03:10:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Here's the debug output:\n[DBG][ACT] TASK (           common_output) TYPE (              CommonOutputAction) NAME (         Outputs) Memory usage 57MB\n[DBG][ACT] TASK ( setup_recover_file_base) TYPE (      SetupRecoverFileBaseAction) NAME (                ) Memory usage 57MB\n[DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (     Temperature) Memory usage 57MB\n[DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (                ) Memory usage 57MB\n[DBG][ACT] TASK (              setup_mesh) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 57MB\n[DBG][ACT] TASK (        add_geometric_rm) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 57MB\n[DBG][ACT] TASK (        add_geometric_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 57MB\n[DBG][ACT] TASK (      add_mesh_generator) TYPE (          AddMeshGeneratorAction) NAME (       file_mesh) Memory usage 57MB\n[DBG][ACT] TASK (      add_mesh_generator) TYPE (          AddMeshGeneratorAction) NAME (rotor_outer_surface_sideset) Memory usage 57MB\n[DBG][ACT] TASK (      add_mesh_generator) TYPE (          AddMeshGeneratorAction) NAME (stator_inner_surface_sideset) Memory usage 57MB\n[DBG][ACT] TASK (   append_mesh_generator) TYPE (         RadiationTransferAction) NAME (vacuum_radiation) Memory usage 57MB\n[DBG][ACT] TASK ( execute_mesh_generators) TYPE (           ExecuteMeshGenerators) NAME (                ) Memory usage 58MB\n[DBG][ACT] TASK (       recover_meta_data) TYPE (      SetupRecoverFileBaseAction) NAME (                ) Memory usage 67MB\n[DBG][ACT] TASK (           set_mesh_base) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 67MB\n[DBG][ACT] TASK (     attach_geometric_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 67MB\n[DBG][ACT] TASK (               init_mesh) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 67MB\n[DBG][ACT] TASK (            prepare_mesh) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 67MB\n[DBG][ACT] TASK (     uniform_refine_mesh) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 68MB\n[DBG][ACT] TASK (     setup_mesh_complete) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 68MB\n[DBG][ACT] TASK (     setup_mesh_complete) TYPE (         RadiationTransferAction) NAME (vacuum_radiation) Memory usage 68MB\n[DBG][ACT] TASK (   determine_system_type) TYPE (      CreateProblemDefaultAction) NAME (                ) Memory usage 68MB\n[DBG][ACT] TASK (  create_problem_default) TYPE (      CreateProblemDefaultAction) NAME (                ) Memory usage 68MB\n[DBG][ACT] TASK (       setup_executioner) TYPE (         CreateExecutionerAction) NAME (     Executioner) Memory usage 69MB\n[DBG][ACT] TASK (            add_executor) TYPE (               AddExecutorAction) NAME (                ) Memory usage 70MB\n[DBG][ACT] TASK (   check_integrity_early) TYPE (            CheckIntegrityAction) NAME (                ) Memory usage 70MB\n[DBG][ACT] TASK (  init_displaced_problem) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 70MB\n[DBG][ACT] TASK (        add_aux_variable) TYPE (           DisplayGhostingAction) NAME (            Mesh) Memory usage 70MB\n[DBG][ACT] TASK (            add_variable) TYPE (               AddVariableAction) NAME (     Temperature) Memory usage 70MB\n[DBG][ACT] TASK (add_external_aux_variables) TYPE (    AddExternalAuxVariableAction) NAME (                ) Memory usage 70MB\n[DBG][ACT] TASK (        setup_quadrature) TYPE (           SetupQuadratureAction) NAME (                ) Memory usage 70MB\n[DBG][ACT] TASK (         add_user_object) TYPE (           DisplayGhostingAction) NAME (            Mesh) Memory usage 71MB\n[DBG][ACT] TASK (         add_user_object) TYPE (         RadiationTransferAction) NAME (vacuum_radiation) Memory usage 71MB\n[DBG][ACT] TASK (                  add_ic) TYPE (       AddInitialConditionAction) NAME (        rotor_IC) Memory usage 72MB\n[DBG][ACT] TASK (                  add_ic) TYPE (       AddInitialConditionAction) NAME (       vacuum_IC) Memory usage 72MB\n[DBG][ACT] TASK (                  add_ic) TYPE (       AddInitialConditionAction) NAME (       stator_IC) Memory usage 72MB\n[DBG][ACT] TASK (           ready_to_init) TYPE (                     EmptyAction) NAME (                ) Memory usage 72MB\n[DBG][ACT] TASK (           setup_dampers) TYPE (              SetupDampersAction) NAME (                ) Memory usage 72MB\n[DBG][ACT] TASK (    setup_residual_debug) TYPE (        SetupResidualDebugAction) NAME (           Debug) Memory usage 72MB\n[DBG][ACT] TASK (         copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (     Temperature) Memory usage 72MB\n[DBG][ACT] TASK (         copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (                ) Memory usage 72MB\n[DBG][ACT] TASK (     copy_nodal_aux_vars) TYPE (             CopyNodalVarsAction) NAME (                ) Memory usage 72MB\n[DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (   thermal_rotor) Memory usage 72MB\n[DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (  thermal_vacuum) Memory usage 72MB\n[DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (  thermal_stator) Memory usage 73MB\n[DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (density_rotor_stator) Memory usage 73MB\n[DBG][ACT] TASK (            add_material) TYPE (               AddMaterialAction) NAME (     density_air) Memory usage 73MB\n[DBG][ACT] TASK (add_output_aux_variables) TYPE (            MaterialOutputAction) NAME (                ) Memory usage 73MB\n[DBG][ACT] TASK (              add_output) TYPE (                SetupDebugAction) NAME (           Debug) Memory usage 73MB\n[DBG][ACT] TASK (              add_output) TYPE (              CommonOutputAction) NAME (         Outputs) Memory usage 73MB\n[DBG][ACT] TASK (              add_output) TYPE (                 AddOutputAction) NAME (            rays) Memory usage 73MB\n[DBG][ACT] TASK (              add_output) TYPE (                 AddOutputAction) NAME (          exodus) Memory usage 73MB\n[DBG][ACT] TASK (              add_output) TYPE (                 AddOutputAction) NAME (         console) Memory usage 73MB\n[DBG][ACT] TASK (          add_aux_kernel) TYPE (           DisplayGhostingAction) NAME (            Mesh) Memory usage 73MB\n[DBG][ACT] TASK (          add_aux_kernel) TYPE (            MaterialOutputAction) NAME (                ) Memory usage 73MB\n[DBG][ACT] TASK (                  add_bc) TYPE (         RadiationTransferAction) NAME (vacuum_radiation) Memory usage 73MB\n[DBG][ACT] TASK (                  add_bc) TYPE (                     AddBCAction) NAME (temperature_stator) Memory usage 73MB\n[DBG][ACT] TASK (              add_kernel) TYPE (                 AddKernelAction) NAME ( heat_conduction) Memory usage 73MB\n[DBG][ACT] TASK (              add_kernel) TYPE (                 AddKernelAction) NAME (heat_conduction_time_derivative) Memory usage 73MB\n[DBG][ACT] TASK (resolve_optional_materials) TYPE (ResolveOptionalMaterialPropertiesAction) NAME (                ) Memory usage 73MB\n[DBG][ACT] TASK (        add_algebraic_rm) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 73MB\n[DBG][ACT] TASK (        add_algebraic_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 73MB\n[DBG][ACT] TASK (         add_coupling_rm) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 73MB\n[DBG][ACT] TASK (         add_coupling_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 73MB\n[DBG][ACT] TASK (attach_geometric_rm_final) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 73MB\n[DBG][ACT] TASK (     attach_algebraic_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 73MB\n[DBG][ACT] TASK (      attach_coupling_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 73MB\n[DBG][ACT] TASK (  coupling_functor_check) TYPE (      CouplingFunctorCheckAction) NAME (coupling_functor_check) Memory usage 73MB\n[DBG][ACT] TASK (delete_remote_elements_after_late_geometric_ghosting) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 73MB\n[DBG][ACT] TASK (            init_problem) TYPE (               InitProblemAction) NAME (                ) Memory usage 73MB\n[DBG][ACT] TASK (            check_output) TYPE (               CheckOutputAction) NAME (                ) Memory usage 79MB\n[DBG][ACT] TASK (         check_integrity) TYPE (            CheckIntegrityAction) NAME (                ) Memory usage 79MB\n[DBG][ACT] TASK (               no_action) TYPE (                     EmptyAction) NAME (                ) Memory usage 79MB\n[DBG][ACT] TASK (finish_input_file_output) TYPE (                     EmptyAction) NAME (                ) Memory usage 79MB\n[DBG][ACT] TASK (add_ray_boundary_condition) TYPE (         RadiationTransferAction) NAME (vacuum_radiation) Memory usage 79MB\n[DBG][ACT] Finished executing all actions with memory usage 79MB",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5286581",
                          "updatedAt": "2023-03-13T03:12:33Z",
                          "publishedAt": "2023-03-13T03:12:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it doesnt cache by default and I dont see it in the parameters of the action. So I think you ll have to modify the code a little bit to get this to work.\nadd the caching parameters in the code for the action, when it creates the study, right below this line.\n\n  \n    \n      moose/modules/heat_conduction/src/actions/RadiationTransferAction.C\n    \n    \n         Line 233\n      in\n      935a1fe\n    \n  \n  \n    \n\n        \n          \n           InputParameters params = _factory.getValidParams(\"ViewFactorRayStudy\");",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5286629",
                          "updatedAt": "2023-03-13T03:21:57Z",
                          "publishedAt": "2023-03-13T03:21:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Hmm, I'm a little green so a little more assistance for how to proceed would be awesome.  But let me give this a shot.  After modifying the code, I would need to re-make moose, right?",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5286682",
                          "updatedAt": "2023-03-13T03:31:40Z",
                          "publishedAt": "2023-03-13T03:31:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yup you need to make every time you modify the code.\nIt should only rebuild a few files at most though (unless you touch a header).\nNo need to add a parameter to the RadiationTransferAction, just hard-code a true to caching segments for now",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5286695",
                          "updatedAt": "2023-03-13T03:33:23Z",
                          "publishedAt": "2023-03-13T03:33:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Oh my gosh I think it's working.  Wow.  Code still running- apparently that caching is a lot.  Here's the line I added:",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5286735",
                          "updatedAt": "2023-03-13T03:39:48Z",
                          "publishedAt": "2023-03-13T03:39:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mrplants"
                  },
                  "bodyText": "Further question: when I view the exodus output, I don't see any rays reflecting off the surfaces.  I only see them emanating from the patches.  Here is a screenshot:",
                  "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5290270",
                  "updatedAt": "2023-03-13T11:32:32Z",
                  "publishedAt": "2023-03-13T11:32:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Am I doing something wrong?  Shouldn't these rays be reflecting off the vacuum walls based on emissivity and absorption?",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5290292",
                          "updatedAt": "2023-03-13T11:34:28Z",
                          "publishedAt": "2023-03-13T11:34:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "I did a little more digging and I just want to confirm my understanding of the GrayDiffuseRadiation action:\nIt seems like Moose calculates radiative heat transfer based on material properties and view angles between the surfaces.  The patches emit rays using gaussian quadrature.\nHowever, this model seems like it may break down with highly reflective surfaces like polished aluminum.  If the surface is highly reflective, then shouldn't the patches be modeled based on the angle of incident rays?  In that case, I would expect the radiative heat transfer to be calculated from rays reflected multiple times, rather than having each ray die at its first intersection with a boundary.\nDoes this make sense?  If so, is there a way to allow RadiationTransferAction to reflect rays a few times before killing them?",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5291533",
                          "updatedAt": "2023-03-13T13:21:57Z",
                          "publishedAt": "2023-03-13T13:21:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@loganharbour or @snschune may complement this\nI dont think it would break down. The idea here is to get the view factors between the patches on both sides, then perform the linear (nonlinear with T dependent properties) solve to converge the radiation heat exchange. The reflectivity is naturally baked into the amount of energy communicated between surfaces, as a factor on how much energy gets sent back.\nThe rays are fixed, they are simply here to compute view factors.\nThe idea is not to track rays of light dynamically between the two surfaces until they dissipate.",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5292441",
                          "updatedAt": "2023-03-13T14:38:04Z",
                          "publishedAt": "2023-03-13T14:38:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mrplants"
                          },
                          "bodyText": "Okay, interesting! Do you have some references that go a little deeper. I still don't fully understand. Specifically, I don't understand how this method accounts for specular reflection. It seems to assume only diffuse reflection.",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5294020",
                          "updatedAt": "2023-03-13T17:02:53Z",
                          "publishedAt": "2023-03-13T16:54:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I ll refer to the aforementioned developers for this",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5294094",
                          "updatedAt": "2023-03-13T17:01:18Z",
                          "publishedAt": "2023-03-13T17:01:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "snschune"
                          },
                          "bodyText": "The net radiation transfer method that is implemented is a fairly standard approach to gray (no frequency dependence), diffuse (all boundaries emit & reflect like Lambert radiators). The case of polished Al would be better described by specular reflection which net radiation transfer typically excludes. The difference is that of a white and specular reflected boundary in radiation transport. Note that most engineering surfaces are some mixture of the two.\nTo the question about view factors and rays. @GiudGiud already explained it but I want to add one thing. View factors are essentially first flight surface to surface collision probabilities from the collision probability method in radiation transport. The probability that a photon released in direction Omega makes its first contact with surface patch j. The radiative exchange is can be computed from these first flight exchange probabilities by a little bit of book-keeping and math. That is essentially what @GiudGiud described.\nThat bookkeeping includes diffuse reflection, absorption, and radiation. That is why rays are killed at first contact with the next surface...it's because we only want first flight surface-to-surface collision probabilities.\nNOTE: the full problem with specular reflection, energy dependence, and absorption in any media within the cavity can also be solved using the MOOSE based radiation transport application Griffin.",
                          "url": "https://github.com/idaholab/moose/discussions/23696#discussioncomment-5298398",
                          "updatedAt": "2023-03-14T02:32:02Z",
                          "publishedAt": "2023-03-14T02:32:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Tensor Material Component Notation",
          "author": {
            "login": "ln53"
          },
          "bodyText": "Hi,\nI was using GenericFunctionRankTwoTensor, and outputting the results to an Exodus II file. I noticed that the component indexing specified in the docs ('fcn_00 fcn_01 fcn_02 fcn_10 fcn_11 fcn_12 fcn_20 fcn_21 fcn_22') were flipped when output to the Exodus file (i.e. the same components were named 'fcn_00 fcn_10 fcn_20 fcn_01 fcn_11 fcn_21 fcn_02 fcn_12 fcn_22' in the output).\nLines 219:228 of RankTwoTensorImplementation.h indicate the tensor is filled in a column-major fashion (i.e. the order I experienced in the output exodus), which is opposite to the docs for GenericFunctionRankTwoTensor.\nI did put together a MWE (below) to demonstrate this using GenericConstantRankTwoTensor, which shows if you input the components in a row-major order they get flipped as expected. Is this just a mistake in the docs or am I missing something?\nThanks\n\ntensor.i\n[Mesh]\n  [mesh]\n    type = GeneratedMeshGenerator\n    dim = 3\n  []\n[]\n\n[Variables]\n  [var]\n    initial_condition = 0\n  []\n[]\n\n[Kernels]\n  [dmdt]\n    type = TimeDerivative\n    variable = var\n  []\n[]\n\n[Materials]\n  [const]\n    type = GenericConstantRankTwoTensor\n    tensor_name = const\n    tensor_values = '00 01 02 10 11 12 20 21 22'\n    outputs = exodus\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  dt = 1\n  end_time = 1\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n\nFor example component 2,1 has an output value of 12:",
          "url": "https://github.com/idaholab/moose/discussions/23674",
          "updatedAt": "2023-03-13T17:43:01Z",
          "publishedAt": "2023-03-09T12:37:28Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dschwen what is the preferred order?\nThis should be a simple fix",
                  "url": "https://github.com/idaholab/moose/discussions/23674#discussioncomment-5255714",
                  "updatedAt": "2023-03-09T15:17:39Z",
                  "publishedAt": "2023-03-09T15:17:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "yes this is a documentation typo.",
                  "url": "https://github.com/idaholab/moose/discussions/23674#discussioncomment-5291247",
                  "updatedAt": "2023-03-13T12:59:04Z",
                  "publishedAt": "2023-03-13T12:59:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok I ll fix this. Thanks for pitching in!",
                          "url": "https://github.com/idaholab/moose/discussions/23674#discussioncomment-5294522",
                          "updatedAt": "2023-03-13T17:43:02Z",
                          "publishedAt": "2023-03-13T17:43:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}