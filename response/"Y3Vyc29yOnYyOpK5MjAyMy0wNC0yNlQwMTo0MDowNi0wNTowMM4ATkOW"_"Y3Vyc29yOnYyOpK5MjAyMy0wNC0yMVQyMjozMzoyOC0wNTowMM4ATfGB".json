{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNC0yMVQyMjozMzoyOC0wNTowMM4ATfGB"
    },
    "edges": [
      {
        "node": {
          "title": "How get Node id, element id and id of quadrature point from Aux kernel ?",
          "author": {
            "login": "KamalnathOSU"
          },
          "bodyText": "Hi all,\nI want to create a nodal aux variable and elemental aux variable. From I want to write a new AuxKernel in my app that uses a unique id of a node and element. I also want a unique id of the local quadrature point.\nIn the framework/src , I noticed the use of \"_current_node->unique_id()\" and \"_current_elem->unique_id()\". Will it give what I want ? Also, how to get a unique_id() of a  quadrature point ?\nI also saw \"_current_node->id()\". How does it differ from \"unique_id()\" ?\nRegards,\nKamal",
          "url": "https://github.com/idaholab/moose/discussions/24152",
          "updatedAt": "2023-04-29T02:44:07Z",
          "publishedAt": "2023-04-21T13:30:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe unique_id is tied to the degree of freedom object class, which is both used by elements and nodes. As such both are indexed, uniquely, there\nhttps://libmesh.github.io/doxygen/classlibMesh_1_1DofObject.html#a906c0c4e74e308757ef3dc77f573dd33\nIf you want unique node or element ids you should use id()\nI dont believe we have unique ids for quadrature points. I think you just use sub-indexing, like the 4th quadrature point on element 22.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24152#discussioncomment-5687221",
                  "updatedAt": "2023-04-21T14:41:01Z",
                  "publishedAt": "2023-04-21T14:40:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "Hi Guillaume! @GiudGiud\nJust to confirm,\nEven if I use distributed mesh with multiple MPI processes, then also \"_current_node->id()\" would give unique global node id right ?",
                          "url": "https://github.com/idaholab/moose/discussions/24152#discussioncomment-5688491",
                          "updatedAt": "2023-04-21T16:45:26Z",
                          "publishedAt": "2023-04-21T16:45:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For elements for sure.\nNodes should be as well.",
                          "url": "https://github.com/idaholab/moose/discussions/24152#discussioncomment-5691241",
                          "updatedAt": "2023-04-22T02:25:28Z",
                          "publishedAt": "2023-04-22T02:25:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "Hi @GiudGiud ,\nI am thinking of creating a unique ID for quadrature points like\nint _qp_max_id=5;\nint _qp_unique_id=_current_elem->id()*_qp_max_id+_qp;\nBut how do I set the value for _qp_max_id for my system ? Is there a variable that stores the total number of quadrature points in a given element ?",
                          "url": "https://github.com/idaholab/moose/discussions/24152#discussioncomment-5722635",
                          "updatedAt": "2023-04-25T17:15:24Z",
                          "publishedAt": "2023-04-25T17:15:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "I saw _qrule->n_points() used in some places of the code. Will that do the trick ?  Generally, how MOOSE decides the quadrature rule to be used for numerical integration ?",
                          "url": "https://github.com/idaholab/moose/discussions/24152#discussioncomment-5722688",
                          "updatedAt": "2023-04-25T17:21:32Z",
                          "publishedAt": "2023-04-25T17:21:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Quadrature rule could be block dependent. I swear I thought we had a postprocessor to obtain this\nMOOSE has a default Gauss quadrature, that is of order high enough to integrate exactly the product of shape * test function",
                          "url": "https://github.com/idaholab/moose/discussions/24152#discussioncomment-5722731",
                          "updatedAt": "2023-04-25T17:26:55Z",
                          "publishedAt": "2023-04-25T17:26:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "SolidMaterialProperties dependency on solid temperature in THM",
          "author": {
            "login": "quentin-faure"
          },
          "bodyText": "Hey everyone,\nI am using the SolidMaterialProperties (for 2D heat structures in THM) which says that the material properties can be function. I am trying to have these properties be functions of the heat structure temperatures themselves. I have a very lengthy idea of how to do it (evaluation of the temperature at each element of the heat structure using post processors and then feeding them to functions). Is there a better, quicker and more efficient way to do it?\nThanks,",
          "url": "https://github.com/idaholab/moose/discussions/24156",
          "updatedAt": "2023-04-29T02:45:54Z",
          "publishedAt": "2023-04-21T17:58:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI'm not sure why post processors would be involved?\nThe code is already dependent on the local heat structure temperature? All the function declarations are \"SolidMaterialProperties::k(const ADReal & temp) const\", with an explicit temperature dependence\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24156#discussioncomment-5691207",
                  "updatedAt": "2023-04-22T02:09:36Z",
                  "publishedAt": "2023-04-22T02:09:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "licharlot"
                  },
                  "bodyText": "Hi Quentin,\nAs Guillaume said, you can set your properties as a function, with the variable tas the temperature. Then use the functions into the SolidMaterialProperties, see the example below. Note that there is also the option to define these properties directly in a Materials block, and omit the parameter materials in the heat structure.\n[Functions]\n  [cp_ss_fn]\n    type = PiecewiseLinear\n    x = '255\t283\t311\t533\t700\t811\t1089\t1367'\n    y = '441.25\t443.75\t461.25\t532.5\t551.25\t563.75\t613.75\t613.75'\n  []\n  [k_ss_fn]\n    type = PiecewiseLinear\n    x = '255\t283\t311\t533\t700\t811\t1089\t1367'\n    y = '12.46\t13.71\t14.16\t17.64\t20.25\t22\t26.36\t26.36'\n  []\n[]\n\n[HeatStructureMaterials]\n  [steel]\n    type = SolidMaterialProperties\n    k = k_ss_fn\n    cp = cp_ss_fn\n    rho = 8000\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/24156#discussioncomment-5709192",
                  "updatedAt": "2023-04-24T14:30:34Z",
                  "publishedAt": "2023-04-24T14:30:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "quentin-faure"
                  },
                  "bodyText": "Hi Guillaume and Lise,\nThank you for the answers, they are very useful.\nQuentin",
                  "url": "https://github.com/idaholab/moose/discussions/24156#discussioncomment-5722658",
                  "updatedAt": "2023-04-25T17:18:00Z",
                  "publishedAt": "2023-04-25T17:17:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "gmsh with 1D lower dimensional elements into a 3D mesh",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nwe have been trying to import a gmsh mesh consiting of 3D and 1D elements, but it does seem that the reading capability of the FileMeshGenerator in Moose does not support this type of combination (all is fine if the LD elements have a dim=dim_3d-1).\nAttached the input *.geo file to reproduce the issue.\nOn a side node, we tried to play a bit around by merging and extracting block ids (below our Mesh block), but despite being able to generate the correct IDs for the 1D elements, while running a simulation with that geometry all internal connectivities are lost and the 1D elements does not have any influence on the overall behaviour.\nAny help/hint would be highly appreciated.\nThanks,\nMauro\n[Mesh]\n  [add_inj]\n    type = PolyLineMeshGenerator\n    points = '2.5e3 5e3 -0.2e3\n    2.5e3 5e3 -0.4e3\n    2.5e3 5e3 -0.6e3\n    2.5e3 5e3 -0.8e3\n    2.5e3 5e3 -1.0e3\n    2.5e3 5e3 -1.1e3\n    2.5e3 5e3 -1.2e3\n    2.5e3 5e3 -1.3e3\n    2.5e3 5e3 -1.4e3'\n    loop = false\n  []\n  [add_pro]\n    type = PolyLineMeshGenerator\n    points = '7.5e3 5e3 -0.2e3\n    7.5e3 5e3 -0.4e3\n    7.5e3 5e3 -0.6e3\n    7.5e3 5e3 -0.8e3\n    7.5e3 5e3 -1.0e3\n    7.5e3 5e3 -1.1e3\n    7.5e3 5e3 -1.2e3\n    7.5e3 5e3 -1.3e3\n    7.5e3 5e3 -1.4e3'\n    loop = false\n  []\n  [input]\n    type = FileMeshGenerator\n    file = 'mesh/fiel.msh'\n  []\n  [merge]\n    type = MeshCollectionGenerator\n    inputs = 'input add_inj add_pro'\n  []\n  [extract_inj]\n    type = SubdomainBoundingBoxGenerator\n    input = merge\n    block_id = 1\n    block_name = 'injector'\n    top_right = '2.49e3 4.99e3 -0.19e3'\n    bottom_left = '2.51e3 5.01e3 -1.41e3'\n  []\n  [extract_pro]\n    type = SubdomainBoundingBoxGenerator\n    input = extract_inj\n    block_id = 2\n    block_name = 'producer'\n    top_right = '7.49e3 4.99e3 -0.19e3'\n    bottom_left = '7.51e3 5.01e3 -1.41e3'\n  []\n[] \n\nfiel.zip",
          "url": "https://github.com/idaholab/moose/discussions/24174",
          "updatedAt": "2023-04-29T02:45:23Z",
          "publishedAt": "2023-04-25T09:31:04Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe MeshCollectionGenerator is explicit that it's not merging meshes, just appending. So the internal connectivities are indeed not working.\nThe StitchedMeshGenerator is the only one that merges them.\nhttps://mooseframework.inl.gov/source/meshgenerators/StitchedMeshGenerator.html\nHowever, I've never dealt with 3D & 1D elements in the same simulation in MOOSE. By lowerD we usually mean 2D for a 3D mesh. What physics are you going to use? Did you write your own kernels to deal with 1D?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24174#discussioncomment-5719148",
                  "updatedAt": "2023-04-25T12:19:39Z",
                  "publishedAt": "2023-04-25T12:19:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Dear @GiudGiud,\nthanks a lot for your reply. Indeed, I thought the same (about the MeshCollectionGenerator vs StichedMeshGenerator). However, to be able to stitch the meshes I would need to define a boundary and this breaks down for 3D and 1D (cannot find a common boundary to stitch them). I also see that lowerD means (max_dim-1), but ... We routinely run simulations (based on an in-house developed mesher) with 1D-2D-3D FEMs (there is an example on the gallery page). And, yes, we use our own developed kernel for the simulations.\nThis said, would you suggest us to write our own import routine?\nThanks",
                          "url": "https://github.com/idaholab/moose/discussions/24174#discussioncomment-5721218",
                          "updatedAt": "2023-04-25T15:00:40Z",
                          "publishedAt": "2023-04-25T15:00:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think adding support for importing gmsh 1-2-3D mixed-dimensional meshes would be awesome.\n@jwpeterson will know if it's needed or if there's something we can do right now.",
                          "url": "https://github.com/idaholab/moose/discussions/24174#discussioncomment-5721250",
                          "updatedAt": "2023-04-25T15:03:20Z",
                          "publishedAt": "2023-04-25T15:03:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Excellent! Let me know.\nMauro",
                          "url": "https://github.com/idaholab/moose/discussions/24174#discussioncomment-5721263",
                          "updatedAt": "2023-04-25T15:04:26Z",
                          "publishedAt": "2023-04-25T15:04:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jwpeterson"
                          },
                          "bodyText": "If I recall correctly, the difficulty with Gmsh meshes is that they can use lower-dimensional elements to specify boundary conditions, in which case those elements should not be added to the mesh. We added some support for this which is related to the lower_dimensional_blocks variable declared in GmshIO::read_mesh():\n  // Keep track of lower-dimensional blocks which are not BCs, but\n  // actually blocks of lower-dimensional elements.\n  std::set<subdomain_id_type> lower_dimensional_blocks;\n\nThe internal convention that we created is that if the string \"lower_dimensional_block\" appears in the file, i.e.\n              // The lines in the PhysicalNames section should look like the following:\n              // 2 1 \"frac\" lower_dimensional_block\n              // 2 3 \"top\"\n              // 2 4 \"bottom\"\n              // 3 2 \"volume\"\n\nthen we will treat that block of elements as actual elements and not boundary conditions. I can't recall if there are any issues with having all three dimensions present in the same mesh or not, it's possible that it already works provided that you use the \"lower_dimensional_block\" string like above.",
                          "url": "https://github.com/idaholab/moose/discussions/24174#discussioncomment-5721465",
                          "updatedAt": "2023-04-25T15:22:05Z",
                          "publishedAt": "2023-04-25T15:22:04Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@jwpeterson thanks! Almost right, if I added the lines as suggested I can retrieve the 1D elements though not exactly in the right manner\nsee below (the right way would be to have only the two vertical line elements). Will try to have a look deeper at that.",
                          "url": "https://github.com/idaholab/moose/discussions/24174#discussioncomment-5721857",
                          "updatedAt": "2023-04-25T15:55:04Z",
                          "publishedAt": "2023-04-25T15:55:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "output the Extreme Value of material defined on surface",
          "author": {
            "login": "echo1115"
          },
          "bodyText": "Hi all,\nI want to know how to get the the Extreme Value of material defined on surface by using postprocessor.\n[AuxVariables]\n  [./oxide_thickness]\n    #order = CONSTANT\n    #family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./oxide]\n    type = MaterialRealAux\n    property = oxide_thickness\n    variable = oxide_thickness\n    execute_on = 'initial linear'\n  [../]\n[]\n\n[Materials]\n  [./oxide_thickness]\n    type = OxidationMaterial\n    boundary = side1\n  [../]\n[]\n\n[Postprocessors]\n  [./max_oxide_thickness1]\n    type = ElementExtremeMaterialProperty\n    mat_prop =  oxide_thickness\n    execute_on = 'initial timestep_end'\n  [../]\n  [./max_oxide_thickness2]\n    type = NodalExtremeValue\n    variable = oxide_thickness\n    execute_on = 'initial timestep_end'\n  [../]\n[]\n\nthe material oxide_thickness  is defined on boundary side1 (the side1 is part of block1 ) and I want to obtain its maximum value.\nWhen using the ElementExtremeMaterialProperty PP, it said that\n\noxide_thickness  was not defined on block1\n\nWhile using NodalExtremeValue and setting the AuxVariables to First order Lagrangian, it shows:\n\nNodal AuxKernel 'oxide_thickness' attempted to reference material property 'property'\nConsider using an elemental auxiliary variable for 'oxide_thickness'",
          "url": "https://github.com/idaholab/moose/discussions/24162",
          "updatedAt": "2023-04-25T15:36:53Z",
          "publishedAt": "2023-04-24T11:47:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere's no nodal material property, the \"boundary\" for the material property really refers to quadrature points on element sides on the boundary.\nCan you try using a constant monomial and seeing if the code naturally only populates the DOFs near the side?\nOtherwise there's several things we could try to add here, but will need some developing\n\nSideExtremeMaterialProperty PP\nsome nodal projection to MaterialRealAux\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24162#discussioncomment-5708083",
                  "updatedAt": "2023-04-24T13:07:13Z",
                  "publishedAt": "2023-04-24T13:07:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "the oxide_thickness is in the elements near the side:\n\nthe problem solved when I change into the following input:\n[Materials]\n  [./oxide_thickness]\n    type = OxidationMaterial\n    output_properties = 'oxide_thickness'   #added\n    outputs = all     #added\n    boundary = side1\n  [../]\n[]\n\n[Postprocessors]\n  [./max_oxide]\n    type = ElementExtremeValue\n    variable = oxide_thickness\n    execute_on = 'initial timestep_end'\n  [../]\n[]\n\nAnd the related [AuxVariables] and  [AuxKernels] were deleted.\nThanks for your help. @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/24162#discussioncomment-5708458",
                          "updatedAt": "2023-04-24T13:37:40Z",
                          "publishedAt": "2023-04-24T13:37:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "sounds good. This is equivalent to MaterialRealAux + const monomial auxvariable, it just happens in the background due to matproperty output",
                          "url": "https://github.com/idaholab/moose/discussions/24162#discussioncomment-5708622",
                          "updatedAt": "2023-04-24T13:46:19Z",
                          "publishedAt": "2023-04-24T13:46:18Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "Can I ask another question\uff1f\nExcept none  and all, what else can the outputs parameter be set in the Materials ?",
                          "url": "https://github.com/idaholab/moose/discussions/24162#discussioncomment-5708841",
                          "updatedAt": "2023-04-24T14:02:41Z",
                          "publishedAt": "2023-04-24T14:02:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "any name of Outputs object in the [Outputs] block. For example, below final_exodus\n[Outputs]\n  [final_exodus]\n     type = Exodus\n     execute_on = FINAL\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24162#discussioncomment-5708877",
                          "updatedAt": "2023-04-24T14:05:07Z",
                          "publishedAt": "2023-04-24T14:05:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "Thanks for your reply.",
                          "url": "https://github.com/idaholab/moose/discussions/24162#discussioncomment-5708966",
                          "updatedAt": "2023-04-24T14:11:31Z",
                          "publishedAt": "2023-04-24T14:11:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "When the material object is included in Action, it seems the parameter output_properties and  outputs don't work. Will a SideExtremeMaterialProperty  PP be developed in MOOSE in the future?",
                          "url": "https://github.com/idaholab/moose/discussions/24162#discussioncomment-5721581",
                          "updatedAt": "2023-04-25T15:31:26Z",
                          "publishedAt": "2023-04-25T15:31:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can still use the auxvariable/auxkernel route though.\nWe have no immediate plans on this object afaik. We d welcome the contribution though",
                          "url": "https://github.com/idaholab/moose/discussions/24162#discussioncomment-5721645",
                          "updatedAt": "2023-04-25T15:36:54Z",
                          "publishedAt": "2023-04-25T15:36:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "malamute melt pool 3d example",
          "author": {
            "login": "mcp2001"
          },
          "bodyText": "Hello,\nI am in the process of setting up moose and malamute with the intent to run the melt_pool_3d example from malamute. When I run this, it runs for a single time step, and then stops until I stop the simulation. I am not sure what the problem is and any advice is appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/24027",
          "updatedAt": "2023-04-25T00:23:34Z",
          "publishedAt": "2023-04-11T06:09:20Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cticenhour",
                  "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5580535",
                  "updatedAt": "2023-04-11T12:51:16Z",
                  "publishedAt": "2023-04-11T12:51:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "@mcp2001 did you mean the simulation terminated? What error did you see?\n3D example is really expensive to run, and it requires significant memory because of LU solver. I suspect that your memory is not sufficient. If that is the case, could you run 2D example? We have been working to improve the code efficiency.",
                  "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5580992",
                  "updatedAt": "2023-04-11T13:35:06Z",
                  "publishedAt": "2023-04-11T13:35:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcp2001"
                          },
                          "bodyText": "Hello and thanks for the reply,\nThe 2D example runs and I have run it for the full 1000 time steps with no problems. On the 3D example, there is not actually an error that happens, just after the Jacobian calculates the simulation stops computing and stays at that point for hours without progressing.",
                          "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5582530",
                          "updatedAt": "2023-04-11T15:33:20Z",
                          "publishedAt": "2023-04-11T15:33:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Could you check your memory usage? I suspect it uses swap memory or virtual memory, which makes it extremely slow.",
                          "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5582622",
                          "updatedAt": "2023-04-11T15:41:30Z",
                          "publishedAt": "2023-04-11T15:41:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Could you also run with Problem/error_on_jacobian_nonzero_reallocation=true?",
                          "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5583437",
                          "updatedAt": "2023-04-11T17:04:05Z",
                          "publishedAt": "2023-04-11T17:04:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcp2001"
                          },
                          "bodyText": "Thank you very much, it was the memory that was the problem. What amount of memory would be recommended for this 3D simulation?",
                          "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5583773",
                          "updatedAt": "2023-04-11T17:41:31Z",
                          "publishedAt": "2023-04-11T17:41:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "KamalnathOSU"
                  },
                  "bodyText": "Hi @cticenhour @jiangwen84\nI am trying out the MALAMUTE app. I could compile it fine. But the solve for the inputfile \"examples/meltpool_2d/meltpool.i\" did not converge. I cant figure out what went wrong. Can you guys help ?\nDo you guys have any video of the expected solution ?\nI have attached the output from MALAMUTE as shown below.\nThank you very much.\n\nM     M      A      L            A      M     M  U     U  T T T T  E E E E\nMM   MM     A A     L           A A     MM   MM  U     U     T     E\nM M M M    A   A    L          A   A    M M M M  U     U     T     E E E E\nM  M  M   A A A A   L         A A A A   M  M  M  U     U     T     E\nM     M  A       A  L L L L  A       A  M     M   U U U      T     E E E E\n\n\nMALAMUTE: MOOSE Application Library for Advanced Manufacturing UTilitiEs\n\n\nCopyright 2021 - 2023, Battelle Energy Alliance, LLC\nALL RIGHTS RESERVED\n\n\nNOTICE: These data were produced by BATTELLE ENERGY ALLIANCE, LLC under Contract\nNo. DE-AC07-05ID14517 with the Department of Energy. For ten(10) years from\nJuly 8, 2021, the Government is granted for itself and others acting on its behalf\na nonexclusive, paid-up, irrevocable worldwide license in this data to reproduce,\nprepare derivative works, and perform publicly and display publicly, by or on\nbehalf of the Government. There is provision for the possible extension of the\nterm of this license. Subsequent to that period or any extension granted, the\nGovernment is granted for itself and others acting on its behalf a nonexclusive,\npaid-up, irrevocable worldwide license in this data to reproduce, prepare\nderivative works, distribute copies to the public, perform publicly and display\npublicly, and to permit others to do so. The specific term of the license can be\nidentified by inquiry made to Contractor or DOE. NEITHER THE UNITED STATES NOR\nTHE UNITED STATES DEPARTMENT OF ENERGY, NOR ANY OF THEIR EMPLOYEES, MAKES ANY\nWARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY\nFOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY DATA, APPARATUS, PRODUCT,\nOR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY\nOWNED RIGHTS.\n\n\n\nreinit0:\nreinit0:\nreinit0: M     M      A      L            A      M     M  U     U  T T T T  E E E E\nreinit0: MM   MM     A A     L           A A     MM   MM  U     U     T     E\nreinit0: M M M M    A   A    L          A   A    M M M M  U     U     T     E E E E\nreinit0: M  M  M   A A A A   L         A A A A   M  M  M  U     U     T     E\nreinit0: M     M  A       A  L L L L  A       A  M     M   U U U      T     E E E E\nreinit0:\nreinit0:\nreinit0: MALAMUTE: MOOSE Application Library for Advanced Manufacturing UTilitiEs\nreinit0:\nreinit0:\nreinit0: Copyright 2021 - 2023, Battelle Energy Alliance, LLC\nreinit0: ALL RIGHTS RESERVED\nreinit0:\nreinit0:\nreinit0: NOTICE: These data were produced by BATTELLE ENERGY ALLIANCE, LLC under Contract\nreinit0: No. DE-AC07-05ID14517 with the Department of Energy. For ten(10) years from\nreinit0: July 8, 2021, the Government is granted for itself and others acting on its behalf\nreinit0: a nonexclusive, paid-up, irrevocable worldwide license in this data to reproduce,\nreinit0: prepare derivative works, and perform publicly and display publicly, by or on\nreinit0: behalf of the Government. There is provision for the possible extension of the\nreinit0: term of this license. Subsequent to that period or any extension granted, the\nreinit0: Government is granted for itself and others acting on its behalf a nonexclusive,\nreinit0: paid-up, irrevocable worldwide license in this data to reproduce, prepare\nreinit0: derivative works, distribute copies to the public, perform publicly and display\nreinit0: publicly, and to permit others to do so. The specific term of the license can be\nreinit0: identified by inquiry made to Contractor or DOE. NEITHER THE UNITED STATES NOR\nreinit0: THE UNITED STATES DEPARTMENT OF ENERGY, NOR ANY OF THEIR EMPLOYEES, MAKES ANY\nreinit0: WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LEGAL LIABILITY OR RESPONSIBILITY\nreinit0: FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF ANY DATA, APPARATUS, PRODUCT,\nreinit0: OR PROCESS DISCLOSED, OR REPRESENTS THAT ITS USE WOULD NOT INFRINGE PRIVATELY\nreinit0: OWNED RIGHTS.\nreinit0:\nreinit0:\n\nThe following total 13 aux variables:\n  delta_function\n  enthalpy\n  heaviside_function\n  liquid_mass_fraction\n  liquid_volume_fraction\n  melt_pool_mass_rate\n  mu\n  permeability\n  rho\n  solid_mass_fraction\n  solid_volume_fraction\n  specific_heat\n  thermal_conductivity\nare added for automatic output by MaterialOutputAction.\nFramework Information:\nMOOSE Version:           git commit 459b699a8d on 2023-04-06\nLibMesh Version:         80494219d2293e467392189814d30330c4f87a25\nPETSc Version:           3.16.5\nSLEPc Version:           3.16.2\nCurrent Time:            Mon Apr 24 02:03:38 2023\nExecutable Timestamp:    Mon Apr 24 01:30:16 2023\n\nParallelism:\n  Num Processors:          4\n  Num Threads:             2\n\nMesh:\n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:\n    Total:                 2601\n    Local:                 682\n    Min/Max/Avg:           612/682/650\n  Elems:\n    Total:                 2500\n    Local:                 625\n    Min/Max/Avg:           625/625/625\n  Num Subdomains:          1\n  Num Partitions:          4\n  Partitioner:             metis\n\nNonlinear System:\n  Num DOFs:                20808\n  Num Local DOFs:          5456\n  Variables:               { \"ls\" \"temp\" } { \"grad_ls\" \"velocity\" } { \"p\" \"curvature\" }\n  Finite Element Types:    \"LAGRANGE\" \"LAGRANGE_VEC\" \"LAGRANGE\"\n  Approximation Orders:    \"FIRST\" \"FIRST\" \"FIRST\"\n\nAuxiliary System:\n  Num DOFs:                35000\n  Num Local DOFs:          8750\n  Variables:               { \"box\" \"delta_function\" \"enthalpy\" \"heaviside_function\" \"liquid_mass_fraction\"\n                             ... \"rho\" \"solid_mass_fraction\" \"solid_volume_fraction\" \"specific_heat\"\n                             \"thermal_conductivity\" }\n  Finite Element Types:    \"MONOMIAL\"\n  Approximation Orders:    \"CONSTANT\"\n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  TimeIntegrator:          ImplicitEuler\n  Solver Mode:             NEWTON\n  MOOSE Preconditioner:    SMP\n\nCurrently Executing\n  Performing Initial Setup\n    Performing Initial Adaptivity\n      Finished Handling Mesh Changes                                                     [  1.43 s] [  278 MB]\n    Finished Performing Initial Adaptivity                                               [  3.11 s] [  278 MB]\nreinit0: Parallelism:\nreinit0:   Num Processors:          4\nreinit0:   Num Threads:             2\nreinit0:\nreinit0: Mesh:\nreinit0:   Parallel Type:           replicated\nreinit0:   Mesh Dimension:          2\nreinit0:   Spatial Dimension:       2\nreinit0:   Nodes:\nreinit0:     Total:                 2601\nreinit0:     Local:                 682\nreinit0:     Min/Max/Avg:           612/682/650\nreinit0:   Elems:\nreinit0:     Total:                 2500\nreinit0:     Local:                 625\nreinit0:     Min/Max/Avg:           625/625/625\nreinit0:   Num Subdomains:          1\nreinit0:   Num Partitions:          4\nreinit0:   Partitioner:             metis\nreinit0:\nreinit0: Nonlinear System:\nreinit0:   Num DOFs:                7803\nreinit0:   Num Local DOFs:          2046\nreinit0:   Variables:               \"ls\" \"grad_ls\"\nreinit0:   Finite Element Types:    \"LAGRANGE\" \"LAGRANGE_VEC\"\nreinit0:   Approximation Orders:    \"FIRST\" \"FIRST\"\nreinit0:\nreinit0: Auxiliary System:\nreinit0:   Num DOFs:                5101\nreinit0:   Num Local DOFs:          1307\nreinit0:   Variables:               \"ls_0\" \"box\"\nreinit0:   Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\"\nreinit0:   Approximation Orders:    \"FIRST\" \"CONSTANT\"\nreinit0:\nreinit0: Execution Information:\nreinit0:   Executioner:             Transient\nreinit0:   TimeStepper:             ConstantDT\nreinit0:   TimeIntegrator:          ImplicitEuler\nreinit0:   Solver Mode:             NEWTON\nreinit0:   MOOSE Preconditioner:    SMP (auto)\nreinit0:\n  Finished Performing Initial Setup                                                      [  6.13 s] [  306 MB]\n\nTime Step 0, time = 0\n\nTime Step 1, time = 0.001, dt = 0.001\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 7.961791e-05\n      0 Linear |R| = 7.961791e-05\n      1 Linear |R| = 7.243437e-06\n 1 Nonlinear |R| = 8.609550e+05\n      0 Linear |R| = 8.609550e+05\n      1 Linear |R| = 1.406247e-05\n 2 Nonlinear |R| = 1.411276e+01\n      0 Linear |R| = 1.411276e+01\n      1 Linear |R| = 1.120530e+05\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 2\n Solve Did NOT Converge!\n  Finished Solving                                                                       [913.16 s] [ 3346 MB]\nAborting as solve did not converge\n\nTime Step 1, time = 0.0005, dt = 0.0005\n 0 Nonlinear |R| = 7.961791e-05\n      0 Linear |R| = 7.961791e-05\n      1 Linear |R| = 7.136710e-06\n 1 Nonlinear |R| = 8.609550e+05\n      0 Linear |R| = 8.609550e+05\n      1 Linear |R| = 7.829182e-06\n 2 Nonlinear |R| = 1.171563e+00\n      0 Linear |R| = 1.171563e+00\n      1 Linear |R| = 1.330539e+00\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 2\n Solve Did NOT Converge!\n  Finished Solving                                                                       [302.60 s] [ 3409 MB]\nAborting as solve did not converge\n\nTime Step 1, time = 0.00025, dt = 0.00025\n 0 Nonlinear |R| = 7.961791e-05\n      0 Linear |R| = 7.961791e-05\n      1 Linear |R| = 7.068681e-06\n 1 Nonlinear |R| = 8.609550e+05\n      0 Linear |R| = 8.609550e+05\n      1 Linear |R| = 8.071160e-06\n 2 Nonlinear |R| = 8.106503e+00\n      0 Linear |R| = 8.106503e+00\n      1 Linear |R| = 3.193694e-07\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 2\n Solve Did NOT Converge!\n  Finished Solving                                                                       [418.94 s] [ 3416 MB]\nAborting as solve did not converge",
                  "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5704519",
                  "updatedAt": "2023-04-24T06:44:14Z",
                  "publishedAt": "2023-04-24T06:44:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Examples should be working.\nCan you try in serial?\nand after without threads, only MPI?",
                          "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5708142",
                          "updatedAt": "2023-04-24T13:11:03Z",
                          "publishedAt": "2023-04-24T13:11:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Looks like we only do check_input on that input. Note that malamute does have its own Discussions forum. That would be a more appropriate place for this question",
                          "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5710497",
                          "updatedAt": "2023-04-24T16:22:31Z",
                          "publishedAt": "2023-04-24T16:22:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KamalnathOSU"
                          },
                          "bodyText": "@lindsayad Got it. I move the discussion there.\nLooks like I will be first to start a discussion in that repo !",
                          "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5710534",
                          "updatedAt": "2023-04-24T16:26:12Z",
                          "publishedAt": "2023-04-24T16:26:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "loganharbour"
                          },
                          "bodyText": "For @GiudGiud  and @lindsayad  - we can transfer discussions",
                          "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5713811",
                          "updatedAt": "2023-04-25T00:18:03Z",
                          "publishedAt": "2023-04-25T00:18:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "oh nice",
                          "url": "https://github.com/idaholab/moose/discussions/24027#discussioncomment-5713834",
                          "updatedAt": "2023-04-25T00:23:35Z",
                          "publishedAt": "2023-04-25T00:23:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "moving non-conforming meshes, and/or overset capabilities",
          "author": {
            "login": "slopezcastano"
          },
          "bodyText": "Hi everyone,\nI was just wondering, as a possible newcomer and user of MOOSE with some C++/CFD experience, whether is possible to handle  moving non-conformal meshes (via interfaces, think of a moving propeller attached to a boat), and/or overset within the framework. I'm mostly interested in fluid flow simulations.\nRegards,\nSantiago",
          "url": "https://github.com/idaholab/moose/discussions/24154",
          "updatedAt": "2023-04-25T08:00:24Z",
          "publishedAt": "2023-04-21T16:40:49Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhile we do have fluid flow capabilities, non-conformal meshes are only handled through custom interface treatments in MOOSE and we have not done much of that for fluid flow.\nWere you looking for finite element or finite volume for fluid flow?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24154#discussioncomment-5691257",
                  "updatedAt": "2023-04-22T02:30:10Z",
                  "publishedAt": "2023-04-22T02:30:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "slopezcastano"
                          },
                          "bodyText": "Hi Guillaume,\nIn this particular case, my interest in non-conformal sliding meshes is mostly for fluid flows using FVM. I am also be interested on coupled solvers (as opposed to segregated) in FVM/FEM (for the study of polydisperse multiphase flows); this is one of the strongest reasons regarding my interest in MOOSE (SNES PETSc, under the hood but more abstract interface). I mean, there are some FVM libraries on the wild, but have a rather incipient treatment of coupled solvers and don't support PETSc.\nBasically, I'd like to start with simulations using either sliding meshes (non-conformal, with non trivial topologies) or chimera (overset), if possible using INSE. I, generally, don't shy away from having to develop some code if needed but I'd like to get an idea of how much \"time\" it will require for me to get to the point I'm interested to be.\nMany thanks for the attention,\nSantiago",
                          "url": "https://github.com/idaholab/moose/discussions/24154#discussioncomment-5694825",
                          "updatedAt": "2023-04-22T12:18:34Z",
                          "publishedAt": "2023-04-22T12:16:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So we provide:\n\nseveral FE & FV discretizations of the Navier Stokes equations for various flow regimes\na few turbulence models, with k-epsilon soon (coming months) to be merged for finite volume\nexamples of efficient preconditioning of flow & multiphysics equations through our interface to PETSc\nlimited multiphase capabilities for gas-liquid (in development) and liquid-solid\ncoupled solver is the default for now, we're adding a segregated solver in the coming months\nSummary of flow capabilities: https://mooseframework.inl.gov/modules/navier_stokes/index.html\nthe displaced mesh capabilities are shown best on our gallery\nhttps://mooseframework.inl.gov/gallery.html\n\nI'll let @lindsayad comment on a time estimate for dev of sliding meshes with FE flow",
                          "url": "https://github.com/idaholab/moose/discussions/24154#discussioncomment-5695335",
                          "updatedAt": "2023-04-22T14:16:44Z",
                          "publishedAt": "2023-04-22T14:15:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I would have to read about overset; I\u2019m not familiar with it. We do have mortar methods which we use for sliding frictional contact in solid mechanics simulations. We\u2019ve applied mortar to finite volume discretizations for gap heat transfer. Mortar has been our recent go-to for non conforming meshes. In the past we\u2019ve also used node to face constraints (only in finite element contexts).",
                          "url": "https://github.com/idaholab/moose/discussions/24154#discussioncomment-5701398",
                          "updatedAt": "2023-04-23T18:05:52Z",
                          "publishedAt": "2023-04-23T18:05:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Looking briefly at overset I think a multi app approach with projections of fields between the different meshes would be the easiest approach with MOOSE",
                          "url": "https://github.com/idaholab/moose/discussions/24154#discussioncomment-5701454",
                          "updatedAt": "2023-04-23T18:17:37Z",
                          "publishedAt": "2023-04-23T18:17:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "But that wouldn\u2019t be in line with your principal interest of a fully coupled solve. At the libMesh implementation level we have one EquationSystems object per Mesh(Base). It\u2019s an interesting question of how we might do this with two disconnected meshes in a single MeshBase object with projections between the two. @roystgnr have you ever had anyone interested in this type of thing? Thinking about this made me think of IBAMR but I think these are fundamentally different methods",
                          "url": "https://github.com/idaholab/moose/discussions/24154#discussioncomment-5701487",
                          "updatedAt": "2023-04-23T18:26:09Z",
                          "publishedAt": "2023-04-23T18:26:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Both mortar and IBM are surface couplings whereas you want to do volume couplings\u2026",
                          "url": "https://github.com/idaholab/moose/discussions/24154#discussioncomment-5701505",
                          "updatedAt": "2023-04-23T18:30:37Z",
                          "publishedAt": "2023-04-23T18:30:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "slopezcastano"
                          },
                          "bodyText": "Hi @lindsayad,\nMortar couplings are a good start! For the first part of the study I have in mind \"sliding meshes\" are enough (noise propagation on a confined marine propeller). For this I don't need \"multi-mesh equation coupling\" or overset, since I'll go for classical INSE-LES and the topology of the disjoint meshes can be made non-overlapping.\n... But, down the road, I'd like to study cavitation on said propeller (polydisperse multiphase models) which is more stable when the equations are coupled (Conservation of mass becomes critical between phases, hence a segregated approach tends to \"break down\" when the dispersed n-phase approaches zero). Notice here that level-set may be used for the resolution of the bubbles.\nFinally I'd like to start adding more \"topological features\" (rudders, propellers) which are obviously \"simpler\" to mesh as disjointed, separate volume meshes.\nAt the risk of taking too much of your time, I'd like to expand a bit on the discussion we have now:\n\nMortar Methods: If I understood correctly you guys have a CHT case from which I might be able to use as \"template\" for a multi-region INSE solver.  Is that correct?\nLevel-Set: As I see in the examples, there is a PoC for level-set, however there are some suggestions on how to \"generalize\" it. is there any attempt now to build a two-phase (or multiphase) solver within DG or FVM?\nVolume-coupling (overlapping meshes, Schwartz method, Overset) and Equation coupling: Is it necessary within MOOSE to also couple the \"interpolation contribution\" onto the \"stiffness matrix\", or can it be possible to handle the \"inter-mesh\" coupling explicitely? I understand there will be an interpolation and first-order-in-time error produced there but I suspect adding the interpolation stencils onto the matrix may be quite time consuming (one might need to search the nodes/centroids both in the domain as well as in the matrix) depending how the matrix is also stored in memory (I talk as a complete newbie with MOOSE, but as an avg user of petsc in FVM).\n\nAnyway, I really thank you for taking the time to answer my questions (not very common in some FOSS CFD forums). I'll download the code and start trying it out so to get an idea on the workflow there.\nKind regards,\nSantiago",
                          "url": "https://github.com/idaholab/moose/discussions/24154#discussioncomment-5706811",
                          "updatedAt": "2023-04-24T10:59:32Z",
                          "publishedAt": "2023-04-24T10:59:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Paul Bauman put some code in GRINS (another libMesh-based physics code) using overset grids for solid-fluid interactions.  There was no need to put two separate meshes in the same MeshBase there, though; the solid and fluid domains were just two overlapping subdomains of the same Mesh.  A few libMesh features (like feeding subdomain id sets to a PointLocator) are designed with that in mind, and IIRC Paul added some lookup caching on top of that (the PointLocatorTree is O(log N) and I guess switching to O(1) makes a difference when you're looking at every quadrature point...).  He also wrote a custom GhostingFunctor subclass to use as a coupling functor to handle the additional sparsity entries (and thereby incidentally handle the algebraic and geometric ghosting; man I'm proud of that API...).  I don't recall what he was doing for quadrature on the mismatching meshes, though.",
                          "url": "https://github.com/idaholab/moose/discussions/24154#discussioncomment-5709754",
                          "updatedAt": "2023-04-24T15:18:21Z",
                          "publishedAt": "2023-04-24T15:18:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "We could ping Paul if we have any questions critical enough.  But GRINS is no longer officially maintained, and yet he still gives me a hand keeping it up to date when I run into any issues, and I still rely on it every now and then for added test coverage, so I don't want to abuse that privilege too hard.  His code is all LGPL, so we've got the goahead if there's anything like that ghosting functor that we want to bring into libMesh or MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/24154#discussioncomment-5709811",
                          "updatedAt": "2023-04-24T15:21:50Z",
                          "publishedAt": "2023-04-24T15:21:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Mortar Methods: If I understood correctly you guys have a CHT case from which I might be able to use as \"template\" for a multi-region INSE solver.  Is that correct?\n\n\nYes, we have conjugate heat transfer, mechanical contact, etc. But only heat transfer demonstrated in a finite volume context, so that is probably the best template.\n\n\nis there any attempt now to build a two-phase (or multiphase) solver within DG or FVM?\n\n\nWe have two-phase flow in a 7 equation model using rDG(P0P1) (so finite volume) in the relap-7 application, but we'd like to get something in our MOOSE modules. You can see #22637 for discussion on the topic. In short, our team at Idaho National Laboratory is not currently doing anything, but we'd love to see movement on the topic.\n\n3. olume-coupling (overlapping meshes, Schwartz method, Overset) and Equation coupling\n\nBased on @roystgnr's response, I think we could definitely so something here",
                          "url": "https://github.com/idaholab/moose/discussions/24154#discussioncomment-5710006",
                          "updatedAt": "2023-04-24T15:37:37Z",
                          "publishedAt": "2023-04-24T15:37:36Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "In PP or VPP, display matrix results with changeable size",
          "author": {
            "login": "sSajjad90"
          },
          "bodyText": "Hello,\nI'm attempting to develop a material code '.C' file to determine the number density distribution of three different phases. For each iteration, the results are vectors like [a_11, a_12,...,a_1n] for each phase ( a 3n matrix for three phases), and I want to return them to the app as follows:\nDeclaration of material property in *.C file:\n a1_calc(declareProperty<std::vector<std::vector<Real>>>(\"a1_calc\")),\nThe  relevant part of resizing the vector and assigning values:\n a1_calc[_qp].resize(Phase_Num);\n  for (unsigned int i = 0; i < Phase_Num; i++)\n  {\n    a1_calc[_qp][i].resize((*(InitAtomNum[i]))[_qp]);\n    for (size_t j = 0; j < ((*(InitAtomNum[i]))[_qp]); j++) {\n      a1_calc[_qp][i][j] = 0;\n    }\n  for (unsigned int i = 0; i < Phase_Num; i++)\n  {\n    for (size_t j = 0; j < ((*(InitAtomNum[i]))[_qp]); j++) {\n      a1_calc[_qp][i][j] = InitNumDensitiesVector[i][j];\n     }\n  }\n\nI'd want to have a matrix of results (3*n) returned by 'a1_calc' in postprocessor, or three postprocessor vectors for each phase, comprising all vector values in each iteration.\nPlease keep in mind that the size of vectors varies with each programme iteration. (For example, in the first iteration,it would be 12, and subsequently shift to 30 in the third iteration or 3000 in the 100th iteration.\nI was wondering how I might present this type of result in VPP.\nThanks in advance for your kind support,\nSincerely,\nSajjad",
          "url": "https://github.com/idaholab/moose/discussions/24161",
          "updatedAt": "2023-04-29T02:33:11Z",
          "publishedAt": "2023-04-23T16:20:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nVPP aren\u2019t meant to deal with vectors of vectors.\nyou ll either want to work on a Reporter, which is a more general but more complex object than a VPP\nor simply define multiple VPPs for each vector within the vector of vectors\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24161#discussioncomment-5701245",
                  "updatedAt": "2023-04-23T17:29:32Z",
                  "publishedAt": "2023-04-23T17:29:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sSajjad90"
                          },
                          "bodyText": "Thank you very much.\nThat's precisely what I've been stuck on.  If I define three independent vectors instead of a vector of vectors. I'm still not sure what 'AuxVariables,' 'AuxKernels,' and 'VPP (or Reporter)' might be used to read all dates from a vector with varying sizes.\nFor instance, if there is just a defined vector, supply a vector of values in each iteration, as seen below.\nWould you please kindly tell me which 'AuxVariables,' 'AuxKernels,' and 'VPP' are capable of aggregating and displaying all\u00a0values for each iteration?\n[Materials]\n  [./d]\n  .\n  .\n  .\n  a1_calc = 'a1_calc'\n  [../]\n[ ]\nResults:\nt= 1: a1_calc = {1, 2, 3, 4}\nt= 2: a1_calc = {6, 14, 3, 4, 22, 13, 18}\nt= 3: a1_calc = {56, 14, 3, 4, 72, 13, 48, 16, 0, 0, 12, 13}\nt= n: a1_calc = {a_1, ...a_m}",
                          "url": "https://github.com/idaholab/moose/discussions/24161#discussioncomment-5709167",
                          "updatedAt": "2023-04-24T14:28:06Z",
                          "publishedAt": "2023-04-24T14:28:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "'AuxVariables,' are meant for data sized with the number of elements/nodes in the mesh. So this is not what you want if i understand correctly.\nA VPP should be able to do this.\n(and now that I've taken a closer look, multiple vectors are supported by VPPs! As long as the number of vectors is known at construction as far as I can tell)\nSome examples of dynamically sized vector postprocessors are:\n\nthe samples, derived from SamplerBase. The size is directed by the derived class, the number of nodes for the NodalValueSampler for example\nthe eigenvalues VPP\n\nA lot of the other VPPs have their vectors sized on initialization. It would not be challenging to size on execute instead.",
                          "url": "https://github.com/idaholab/moose/discussions/24161#discussioncomment-5709354",
                          "updatedAt": "2023-04-24T14:45:37Z",
                          "publishedAt": "2023-04-24T14:43:47Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[Mesh] Meshing a small cubic within a big cubic",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear all,\nI want to use MOOSE Mesh blocks to build a small cubic (i.e., 2m2m2m) within a big cubic (i.e., 1km1km1km).\nOne solution may be to build a quite refined mesh (i.e., 0.25m0.25m0.25m) for the whole big cubic (i.e., 1km1km1km) and then use SubdomainBoundingBoxGenerator to select the small cubic. But it needs many elements for the out parts of the small cubic. I don't want this.\nIn addition, I try to build and refine the two cubics by 'FileMeshGenerator' and then using 'StitchedMeshGenerator' to merge them together, but it produces repeated meshing in their intersection parts.\nCould you please give me some suggestions on this? Thanks a lot.\nJ",
          "url": "https://github.com/idaholab/moose/discussions/24158",
          "updatedAt": "2023-04-24T14:18:03Z",
          "publishedAt": "2023-04-22T10:56:23Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthe solution here is likely to use mesh refinement.\nFirst : generate the uniform grid for the whole domain. It should be as coarse as you want the large coarse part to be. CartesianMG or rectilinearMG should both be able to do it\nsecond: use the subdomain bounding box to create a different subdomain for the fine part. You could skip that part if you use the subdomain_ids argument of the rectilinearMG\nThen use the BlockRefineGenerator to refine only the fine part a few levels. You want to get to the fineness required there\nfinally, if the fine part was \u201ctoo big\u201d in step 2, you can redefine it again using another subsomainBoundingBox generator\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24158#discussioncomment-5694683",
                  "updatedAt": "2023-04-22T11:39:15Z",
                  "publishedAt": "2023-04-22T11:39:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "Hello\nthe solution here is likely to use mesh refinement.\nFirst : generate the uniform grid for the whole domain. It should be as coarse as you want the large coarse part to be. CartesianMG or rectilinearMG should both be able to do it\nsecond: use the subdomain bounding box to create a different subdomain for the fine part. You could skip that part if you use the subdomain_ids argument of the rectilinearMG\nThen use the BlockRefineGenerator to refine only the fine part a few levels. You want to get to the fineness required there\nfinally, if the fine part was \u201ctoo big\u201d in step 2, you can redefine it again using another subsomainBoundingBox generator\nGuillaume\n\nThanks a lot. I will try this way.",
                          "url": "https://github.com/idaholab/moose/discussions/24158#discussioncomment-5709072",
                          "updatedAt": "2023-04-24T14:18:02Z",
                          "publishedAt": "2023-04-24T14:18:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Use the code autocomplete in VS Code",
          "author": {
            "login": "tttsss-01"
          },
          "bodyText": "Hello,\nI am trying to use the code autocomplete in VS Code. I have attempted to use the MOOSE Language Support extension, but it keeps displaying the error message \"No MOOSE application executable found\". Where should I provide the path for the MOOSE application? I have noticed in the extension settings that I can provide a HIT format style file, but I am not sure what HIT is and how to provide it. Will providing this file make the extension work? My VS Code is running on Windows and connected to WSL. I am not very familiar with VS Code. Can someone please help me?",
          "url": "https://github.com/idaholab/moose/discussions/24153",
          "updatedAt": "2023-04-22T13:15:56Z",
          "publishedAt": "2023-04-21T16:24:05Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nif you are working in the repository of the application, like in the tests or examples folder for example, it should find it automatically\nif not then you should create a symlink to the executable in your local working folder\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24153#discussioncomment-5694688",
                  "updatedAt": "2023-04-22T11:40:32Z",
                  "publishedAt": "2023-04-22T11:40:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tttsss-01"
                          },
                          "bodyText": "This worked. Thank you very much.",
                          "url": "https://github.com/idaholab/moose/discussions/24153#discussioncomment-5695067",
                          "updatedAt": "2023-04-22T13:15:54Z",
                          "publishedAt": "2023-04-22T13:15:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Whether thermal expansion and creep can be used together\uff1f",
          "author": {
            "login": "Moyiqi"
          },
          "bodyText": "Hello everyone, may I ask a question?\n\u00a0 \u00a0 # [stress]\n\u00a0 \u00a0 # \u00a0 type = ComputeFiniteStrainElasticStress\n\u00a0 \u00a0 # []\n\u00a0 \u00a0 [./thermal_strain1]\n\u00a0 \u00a0 \u00a0 type = ComputeThermalExpansionEigenstrain\n\u00a0 \u00a0 \u00a0 thermal_expansion_coeff = 1.243e-11\n\u00a0 \u00a0 \u00a0 stress_free_temperature = 230\n\u00a0 \u00a0 \u00a0 temperature = temperature\n\u00a0 \u00a0 \u00a0 eigenstrain_name = eigenstrain\n\u00a0 \u00a0 [../]\n\u00a0 \u00a0 [./density1]\n\u00a0 \u00a0 type = Density\n\u00a0 \u00a0 density = 2736\n\u00a0 \u00a0 [../]\n\u00a0 \u00a0 [./radial_return_stress]\n\u00a0 \u00a0 \u00a0 type = ComputeMultipleInelasticStress\n\u00a0 \u00a0 \u00a0 inelastic_models = 'powerlawcrp plas'\n\u00a0 \u00a0 [../]\n\u00a0 \u00a0 [./powerlawcrp]\n\u00a0 \u00a0 \u00a0 type = PowerLawCreepStressUpdate\n\u00a0 \u00a0 \u00a0 coefficient = 3\n\u00a0 \u00a0 \u00a0 n_exponent = 3\n\u00a0 \u00a0 \u00a0 m_exponent = 2\n\u00a0 \u00a0 \u00a0 activation_energy = 0.2\n\u00a0 \u00a0 [../]\n\u00a0 \u00a0 [./plas]\n\u00a0 \u00a0 \u00a0 type = IsotropicPlasticityStressUpdate\n\u00a0 \u00a0 \u00a0 hardening_constant = 0.5\n\u00a0 \u00a0 \u00a0 yield_stress =300\n\u00a0 \u00a0 [../]\n\nWhen I use block [stress] , another block [radial_return_stress]  can't be used. So I had to go into hiding.\nCan I use together?\nLily",
          "url": "https://github.com/idaholab/moose/discussions/24131",
          "updatedAt": "2023-06-01T01:29:22Z",
          "publishedAt": "2023-04-20T01:42:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo you cannot define multiple stress models on the same blocks (subdomains), unless you use either the \"suffix\" parameter to disambiguate them.\nFyi:\n\nSo I had to go into hiding.\n\nYou had to comment it out. Going into hiding means something else.",
                  "url": "https://github.com/idaholab/moose/discussions/24131#discussioncomment-5668804",
                  "updatedAt": "2023-04-20T04:13:52Z",
                  "publishedAt": "2023-04-20T04:13:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Moyiqi"
                          },
                          "bodyText": "We want to add creep, plastic deformation, elastic deformation and thermal expansion into the equation. Is there any similar code available\uff1f\nLily",
                          "url": "https://github.com/idaholab/moose/discussions/24131#discussioncomment-5691219",
                          "updatedAt": "2023-04-22T02:14:22Z",
                          "publishedAt": "2023-04-22T02:14:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think the ComputeMultipleInelasticStress is the way to go, which you are already using.\nOthers may pitch in for alternatives",
                          "url": "https://github.com/idaholab/moose/discussions/24131#discussioncomment-5691253",
                          "updatedAt": "2023-04-22T02:28:30Z",
                          "publishedAt": "2023-04-22T02:28:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Moyiqi"
                          },
                          "bodyText": "Thank you for your reply, may I ask you another question?\nWhen I add '''prop_getter_suffix=prop_name''' in\u00a0'''ComputeMultipleInelasticStress'''\nI get an error '''Material property 'mechanical_strain_prop_name', requested by 'model_name_face' is not defined on block 0''',\nI want to know how to correctly use '''prop_getter_suffix''' parameter.\nLily",
                          "url": "https://github.com/idaholab/moose/discussions/24131#discussioncomment-5691383",
                          "updatedAt": "2023-04-22T03:33:28Z",
                          "publishedAt": "2023-04-22T03:33:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}