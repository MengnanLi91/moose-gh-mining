{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wOS0wNlQwMjoxOToyNC0wNTowMM4AQpNt"
    },
    "edges": [
      {
        "node": {
          "title": "A question about the kernel",
          "author": {
            "login": "wowodejiajia"
          },
          "bodyText": "Dear MOOSE experts,\nIn the original work, the author compiled the program himself. Do you know whether there are ready-made Kernels to choose from? I have excerpted some of the content.\n[Variables]\n  # variables. w: chemical potential, eta: order parameter, pot: applied overpotential.  \n  [./w]\n  [../]\n  [./eta]\n  [../]\n  [./pot]\n  [../]\n[]\n\n[Materials]\n  [./Bultervolmer]\n    type = DerivativeParsedMaterial\n    function = 'Ls*(exp(pot*AA/2.)+14.89*cl*(1-h)*exp(-pot*AA/2.))*dh'\n    args = 'pot eta w'\n    f_name = G\n    derivative_order = 1\n    material_property_names = 'Ls dh:=D[h,eta] h cl:=D[f1,w] AA'\n    outputs = exodus\n  [../]\n\nThe author has compiled a kernel himself. Weak form is G*test.\n[Kernels]\n  [./BV]\n    type = Kinetics\n    variable = eta\n    f_name = G\n    cp=pot\n    cv=eta\n  [../]\n\nCan \"Kinetics\" be replaced with a ready-made kernel?\nI look forward to your reply.\nThank you!\nKinetics.txt",
          "url": "https://github.com/idaholab/moose/discussions/22011",
          "updatedAt": "2022-09-09T03:45:39Z",
          "publishedAt": "2022-09-06T08:10:38Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSince you have the source code, why dont you want to use Kinetics?\nYou ll just need to update it to make sure the parameters are properly handled, see this post:\nhttps://mooseframework.inl.gov/newsletter/2020_04.html#!\nShould this post be categorized as phase field instead of general? What application is this for?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22011#discussioncomment-3572084",
                  "updatedAt": "2022-09-06T14:43:43Z",
                  "publishedAt": "2022-09-06T14:43:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wowodejiajia"
                          },
                          "bodyText": "The first term of this equation is the phase field equation. The second term is the electrochemical kinetic equation.\n\nYou're right. Kinetics can operate normally after being updated. However, I want to know if there is a ready-made kernel like this F(a,b,c)=0 (a, b and c are variables. F is a complex equation defined in [Materials]).",
                          "url": "https://github.com/idaholab/moose/discussions/22011#discussioncomment-3581036",
                          "updatedAt": "2022-09-07T03:33:23Z",
                          "publishedAt": "2022-09-07T03:33:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so you want to be solving an equation to compute F on each quadrature point?\nHow difficult is this equation? The Kinetics kernel doesnt have this, F and its derivatives are computed elsewhere",
                          "url": "https://github.com/idaholab/moose/discussions/22011#discussioncomment-3581390",
                          "updatedAt": "2022-09-07T05:16:35Z",
                          "publishedAt": "2022-09-07T05:16:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wowodejiajia"
                          },
                          "bodyText": "What I said before may not be accurate. Let me put it another way.\nIs there a kernel similar to Kinetics kernel\uff1fI looked on the website and only found BodyForce kernel. Used in this program\n[./BV]\ntype = BodyForce\nvariable = eta\nfunction = G   # It seems wrong here\n[../]",
                          "url": "https://github.com/idaholab/moose/discussions/22011#discussioncomment-3582660",
                          "updatedAt": "2022-09-07T08:28:55Z",
                          "publishedAt": "2022-09-07T08:28:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "BodyForce doesnt have the derivative term you have in Kinetics. If you work with AD, you may use ADBodyForce to get the derivatives right\nimo you should just use kinetics if you know it works for you",
                          "url": "https://github.com/idaholab/moose/discussions/22011#discussioncomment-3588809",
                          "updatedAt": "2022-09-07T20:30:38Z",
                          "publishedAt": "2022-09-07T20:30:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wowodejiajia"
                          },
                          "bodyText": "Oh, I see. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/22011#discussioncomment-3603252",
                          "updatedAt": "2022-09-09T03:45:27Z",
                          "publishedAt": "2022-09-09T03:45:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using different file extensions than .C and .h for source and header files",
          "author": {
            "login": "rks171"
          },
          "bodyText": "I have another code that I want to integrate into MOOSE.  A problem is that it uses different file extensions than \".C\" and \".h\" for the c++ source and header files.  Aside from renaming all the files and updating the include statements, is there a way to tell the MOOSE build system to look for these different file extensions so that I can just copy the files into the MOOSE application?",
          "url": "https://github.com/idaholab/moose/discussions/22053",
          "updatedAt": "2022-09-08T22:24:53Z",
          "publishedAt": "2022-09-08T16:41:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@permcody @cticenhour",
                  "url": "https://github.com/idaholab/moose/discussions/22053#discussioncomment-3599438",
                  "updatedAt": "2022-09-08T19:46:07Z",
                  "publishedAt": "2022-09-08T19:46:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "To my knowledge, it would definitely take a modification of the makefiles (maybe app.mk if we're talking integration into an app?), as we look for specific file extensions for C++, C, F90 etc. there to create the list of source files. I don't know of a way off-hand to perform that build without needing a modification.",
                          "url": "https://github.com/idaholab/moose/discussions/22053#discussioncomment-3599746",
                          "updatedAt": "2022-09-08T19:54:38Z",
                          "publishedAt": "2022-09-08T19:54:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rks171"
                          },
                          "bodyText": "Ok that's pretty much what I gathered from looking through those makefiles.  I just wanted to make sure there wasn't something I was missing.",
                          "url": "https://github.com/idaholab/moose/discussions/22053#discussioncomment-3600479",
                          "updatedAt": "2022-09-08T20:50:34Z",
                          "publishedAt": "2022-09-08T20:50:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "Casey is correct - we just do wildcard searchers in app.mk for specific extensions.",
                          "url": "https://github.com/idaholab/moose/discussions/22053#discussioncomment-3601516",
                          "updatedAt": "2022-09-08T22:24:53Z",
                          "publishedAt": "2022-09-08T22:24:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Generating meshes from CAD assemblies",
          "author": {
            "login": "s-dunnim"
          },
          "bodyText": "Hi,\nI'm working on a MOOSE model which will require external CAD to be meshed. The CAD is provided as an assembly in a STEP file; and I would like to make it into a single, continuous, high quality, tetrahedral mesh. Does anyone have any experience/recommendations for a pipeline/process to achieve this?\nSo far I have tried:\n\nUsing blender to \"boolean\" all the parts together, export to STL, and mesh in tetgen. I struggled to avoid intersecting segments/facets, and the conversion to STL discretises the geometry before meshing, often with \"ugly\" triangles.\nUsing FreeCAD to \"fuse\" parts together, export to STL, and mesh in tetgen. This comes with the same problems as above, as well as the fact FreeCAD struggles to fuse parts which aren't exactly aligned (in Blender I was doing a little manual extrusion to fix this).\n\nI haven't tried:\n\nHand coding a script to make a poly file for tetgen, as the geometry is too complex.\nUsing Cubit as discussed in this post, as it isn't free for commercial use.\nUsing Gmsh. This is likely our next port of call, especially if it is recommended here.\n\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/22032",
          "updatedAt": "2022-09-29T16:28:00Z",
          "publishedAt": "2022-09-07T14:00:03Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHow complicated is the CAD? We have some native support in MOOSE for simple shapes, and we can stitch, rotate etc\n@grmnptr would SALOME be an option here?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22032#discussioncomment-3588803",
                  "updatedAt": "2022-09-07T20:29:35Z",
                  "publishedAt": "2022-09-07T20:29:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "s-dunnim"
                          },
                          "bodyText": "Hi, thanks for the response.\nIt's fairly complex, with fillets, chamfers, round edges, non-planar surfaces etc. I looked into maybe using StitchedMesh, but I can't guarantee the faces I'm stitching will have corresponding nodes, or even be exactly aligned. It also doesn't solve the issue of meshing from CAD without an intermediary STL conversion generating unwanted triangles. I'll look into SALOME.",
                          "url": "https://github.com/idaholab/moose/discussions/22032#discussioncomment-3592042",
                          "updatedAt": "2022-09-08T07:49:00Z",
                          "publishedAt": "2022-09-08T07:48:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grmnptr"
                          },
                          "bodyText": "Both SALOME and gmsh can do this; both have multiple algorithms and python APIs for a fine control over the meshing process. I personally use gmsh for simpler meshes and SALOME for more complex ones. However, I have to admit I haven't tried any of these for meshing such complex geometries. I think SALOME's GUI is nicer, not sure if that matters.",
                          "url": "https://github.com/idaholab/moose/discussions/22032#discussioncomment-3594968",
                          "updatedAt": "2022-09-08T13:38:55Z",
                          "publishedAt": "2022-09-08T13:38:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "s-dunnim"
                          },
                          "bodyText": "Thank you for the advice, I'll have a go with those tools and see what I can do! Will come back and mark as answer if it works out for me.",
                          "url": "https://github.com/idaholab/moose/discussions/22032#discussioncomment-3595138",
                          "updatedAt": "2022-09-08T13:57:48Z",
                          "publishedAt": "2022-09-08T13:57:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "reference to the FEProblem",
          "author": {
            "login": "xiaojbing"
          },
          "bodyText": "My volume score inherits ArrayKernel.C and area score inherits ArrayDGKernel.C. I want to use a reference to the FEProblem class. **_So I wrote the statement \"_fe_problem(parameters.get<FEProblem >(\"fe_problem\"))\" in the constructor of the subclass and successfully used it to fetch something from the FEProblem class, but this statement causes my configuration file to not work properly, i.e. it compiles successfully but does not run the configuration file. I would like to know if there is any way to compile and run it successfully.",
          "url": "https://github.com/idaholab/moose/discussions/22031",
          "updatedAt": "2022-09-29T16:27:50Z",
          "publishedAt": "2022-09-07T13:57:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I don\u2019t think FEProblem is a parameter the user passes.\nthere\u2019s examples in the framework for retrieving the FEProblem, you should grep for it",
                  "url": "https://github.com/idaholab/moose/discussions/22031#discussioncomment-3585642",
                  "updatedAt": "2022-09-07T14:17:25Z",
                  "publishedAt": "2022-09-07T14:17:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "In fact, I want to get the parameters in a problem file I wrote myself in the subclass of ArrayDGKernel. And the problem file I wrote myself inherits FEProblem.cpp",
                          "url": "https://github.com/idaholab/moose/discussions/22031#discussioncomment-3586307",
                          "updatedAt": "2022-09-07T15:14:22Z",
                          "publishedAt": "2022-09-07T15:14:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You wrote your own problem class? and problem is a parameter in the input file, as in you have two problems active?\nSo the way this is done, and you can look at base/ResidualObject.C for example, is to retrieve the problem through a pointer to the problem. The parameter is a pointer. This pointer is set internally, not in the input file.\n_fe_problem(*parameters.get<FEProblem *>(\"_fe_problem\")),",
                          "url": "https://github.com/idaholab/moose/discussions/22031#discussioncomment-3588593",
                          "updatedAt": "2022-09-07T19:52:31Z",
                          "publishedAt": "2022-09-07T19:52:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "xiaojbing"
                  },
                  "bodyText": "I found that _fe_problem can be called in the file that inherits ArrayKernel.C, but _fe_problem cannot be called in the file that inherits ArrayDGKernel.C. I searched for _c_fe_problem,_mci_feproblem,mi_feproblem, sc_fe_problem,_ti_feproblem, what is the difference between these and _fe_problem, and if they have the same meaning, can I use them?",
                  "url": "https://github.com/idaholab/moose/discussions/22031#discussioncomment-3590368",
                  "updatedAt": "2022-09-08T02:23:00Z",
                  "publishedAt": "2022-09-08T02:22:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "_fe_problem can be called in the classes that have this attribute.\nSee the headers or the doxygen for each attribute.\nFor example in the header of the Coupleable interface, you can see that _c_fe_problem is a reference to the FEProblemBase (a base class of FEProblem)",
                          "url": "https://github.com/idaholab/moose/discussions/22031#discussioncomment-3591015",
                          "updatedAt": "2022-09-08T04:46:46Z",
                          "publishedAt": "2022-09-08T04:46:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Confusing Thermal Hydraulics Results",
          "author": {
            "login": "TheBEllis"
          },
          "bodyText": "Hi MOOSE team,\nI'm doing some comparisons between the MOOSE thermal hydraulics module and other methods of solving for outlet temperatures in a counter-current heat exchanger. I have done some comparisons to the NTU method (https://en.wikipedia.org/wiki/NTU_method) (https://www.mathworks.com/help/physmod/hydro/ref/entuheattransfer.html) and some CFD calculations I have done in ANSYS FLUENT. Below I have attached a picture of the cross-section of the heat exchanger I have modelled. The inner channel is referred to as ch1/fch in my input file and carries an ideal gas with an inlet temp of 300 K. There is a 5cm thick wall between this channel and the outer channel, referred to as ch2/fch_outer in my input file which carries another ideal gas with an inlet temperature of 500 K. The ideal gas values are sort of arbitrary but are made sure to be consistent with the values used in fluent.\n\nBelow I have plotted the outlet temperature of the inner channel (ch1/fch). My MOOSE results vary with time as it is a transient solve, but my fluent and NTU method results are steady state hence the straight line. I am seeing a very large differential in my results which I can't explain and was wondering if anyone could spot anything wrong with my input file. As the fluent solve is done on a 3D mesh, the plotted result is the average outlet temperature of the inner channel. Do you know if the FlowChannel1Phase is supposed to approximate the average temperature of the channel as well, or would it just capture the maximum temperature?\n\nI have attached my input file below, sorry as there is a lot of faff in it where I am using lots of postprocessors and functions to calculate my NTU results, but they can be ignored for the most part. Any help is greatly appreciated as I am really lost on this one!\nT_in = 300         # K\nm_dot_in = 10\npress = 1e5         # Pa\n\n# core parameters\nwall_thickness = ${units 5. cm -> m}\nfch_length = 10   # m\nfch_n_elems = 100\nfch_dia = 0.5\nfch_radius_wall = ${fparse fch_dia/2 + wall_thickness}\nconvective_HTC = 2000\n\n#counter flow params\nfch_outer_dia = 1.0\n\n\n\n[GlobalParams]\n  initial_p = ${press}\n  initial_vel = 0\n  initial_T = ${T_in}\n  gravity_vector = '0 0 0'\n  rdg_slope_reconstruction = full\n  closures = simple_closures\n[]\n\n[HeatStructureMaterials]\n  [steel]\n    type = SolidMaterialProperties\n    rho = 8050\n    k = 45\n    cp = 466\n  []\n[]\n\n[Modules/FluidProperties]\n  [fluid_cold]\n    type = IdealGasFluidProperties\n    molar_mass = 2.897e-2\n    gamma = 1.4\n    k = 0.025\n    mu = 3e-5\n  []\n\n  [fluid_hot]\n    type = IdealGasFluidProperties\n    molar_mass = 4e-3\n    gamma = 1.67\n    k = 0.156\n    mu = 3e-5\n  []\n[]\n\n[Closures]\n  [simple_closures]\n    type = Closures1PhaseSimple\n  []\n[]\n\n[Components]\n\n    [ch1]\n        [inlet]\n            type = InletMassFlowRateTemperature1Phase\n            input = 'ch1/fch:in'\n            m_dot = ${m_dot_in}\n            T = ${T_in}\n        []\n\n        #Flow channel setup\n        [fch]\n            type = FlowChannel1Phase\n            position = '0 0 0'\n            orientation = '1 0 0'\n            length = ${fch_length}\n            n_elems = ${fch_n_elems}\n            A = ${fparse pi * fch_dia * fch_dia / 4.}\n            D_h = ${fparse fch_dia}\n            fp = fluid_cold\n            f = 1.6\n        []\n\n        [outlet]\n            type = Outlet1Phase\n            input = 'ch1/fch:out'\n            p = ${press}\n        []\n    []\n\n\n    [ch2]\n        [inlet]\n            type = InletMassFlowRateTemperature1Phase\n            input = 'ch2/fch_outer:out'\n            m_dot = -${m_dot_in}\n            T = 500\n        []\n\n        #Flow channel setup\n        [fch_outer]\n            type = FlowChannel1Phase\n            position = '0 0 0'\n            orientation = '1 0 0'\n            length = ${fch_length}\n            n_elems = ${fch_n_elems}\n            A = ${fparse pi * ((fch_outer_dia * fch_outer_dia/4) - fch_radius_wall * fch_radius_wall)}\n            D_h = ${fparse fch_outer_dia - (2*fch_radius_wall)}\n            f = 1.6\n            fp = fluid_hot\n            initial_T = 500\n        []\n\n        [outlet]\n            type = Outlet1Phase\n            input = 'ch2/fch_outer:in'\n            p = ${press}\n        []\n    []\n\n    #Heat structure setup\n\n    [hs]\n      type = HeatStructureCylindrical\n      position = '0 0 0'\n      orientation = '1 0 0'\n      inner_radius = ${fparse fch_dia / 2.}\n      length = ${fch_length}\n      n_elems = ${fch_n_elems}\n      materials = 'steel'\n      initial_T = ${T_in}\n      names = 'block'\n      widths = ${fparse wall_thickness}\n      n_part_elems = 10\n    []\n\n    [HeatStructureHeatTransferOuter]\n        type = HeatTransferFromHeatStructure1Phase\n        flow_channel = 'ch2/fch_outer'\n        hs = hs\n        hs_side = outer\n        Hw = ${fparse convective_HTC}\n        P_hf = ${fparse 2 * fch_radius_wall * pi}\n    []\n\n    [HeatStructureHeatTransferInner]\n        type = HeatTransferFromHeatStructure1Phase\n        flow_channel = 'ch1/fch'\n        hs = hs\n        hs_side = inner\n        Hw = ${fparse convective_HTC}\n        P_hf = ${fparse fch_dia * pi}\n    []\n[]\n\n[Functions]\n\n  [t_out_percentage_diff]\n    type = ParsedFunction\n    value = '100*(moose_temp-ntu_temp)/moose_temp'\n    vars = 'ntu_temp moose_temp'\n    vals = 'NTU_t_out fch_T_out'\n  []\n\n  [NTU_t_out]\n    type = ParsedFunction\n    value = '300-(q/C_min)'\n    vars = 'C_min q'\n    vals = 'C_min q'\n  []\n\n  [q]\n    type = ParsedFunction\n    value = 'q_max*Effectivness'\n    vars = 'q_max Effectivness'\n    vals = 'q_max Effectivness'\n  []\n\n  [q_max]\n    type = ParsedFunction\n    value = '(C_min) * (300-500)'\n    vars = 'C_min NTU'\n    vals = 'C_min NTU'\n  []\n\n  [Effectivness]\n    type = ParsedFunction\n    value = '(1-exp(-NTU*(1-Cr)))/(1-Cr*exp(-NTU*(1-Cr)))'\n    vars = 'NTU Cr'\n    vals = 'NTU Cr'\n  []\n\n  [NTU]\n    type = ParsedFunction\n    value = 'HTC/(C_min)'\n    vars = 'C_min HTC'\n    vals = 'C_min Total_HTC'\n  [../]\n\n  [C_min]\n    type = ParsedFunction\n    value = 'cp*${m_dot_in}'\n    vars = 'cp'\n    vals = 'cp_cold'\n  []\n\n  [Cr]\n    type = ParsedFunction\n    value = '(cp_cold*${m_dot_in})/(cp_hot*${m_dot_in})'\n    vars = 'cp_cold cp_hot'\n    vals = 'cp_cold cp_hot'\n  []\n\n  #Heat transfer area of the inner channel\n  [HT_Area1]\n    type = ParsedFunction\n    value = '${fch_length} * pi * ${fch_dia}'\n  []\n\n  #Heat transfer area of the outer channel\n  [HT_Area2]\n    type = ParsedFunction\n    value = '${fch_length}*(pi*2*${fch_radius_wall})'\n  []\n\n  [Total_HTC]\n    type = ParsedFunction\n    value = '1/((1/(A1*${convective_HTC})) + (1/(A2*${convective_HTC})) + (${wall_thickness}/45))'\n    vars = 'A1 A2'\n    vals = 'HT_Area1 HT_Area2'\n  []\n\n[]\n\n\n[Postprocessors]\n  [fch_T_out]\n    type = SideAverageValue\n    boundary = 'ch1/fch:out'\n    variable = T\n  []\n\n  [cp_cold]\n    type = ADElementAverageMaterialProperty\n    block = 'ch1/fch'\n    mat_prop = 'cp'\n  []\n\n  [cp_hot]\n    type = ADElementAverageMaterialProperty\n    block = 'ch2/fch_outer'\n    mat_prop = 'cp'\n  []\n\n  [hot_T_out]\n    type = SideAverageValue\n    boundary = 'ch2/fch_outer:in'\n    variable = T\n  []\n\n  [NTU_Temp]\n    type = FunctionValuePostprocessor\n    function = NTU_t_out\n    enable = true\n  []\n\n  [percentage_diff_vs_moose]\n    type = FunctionValuePostprocessor\n    function = t_out_percentage_diff\n    enable = true\n  []\n\n  [dynamic_hyd_outer]\n    type = FunctionValuePostprocessor\n    function = ${fparse fch_outer_dia - (2*fch_radius_wall)}\n    enable = false\n  []\n[]\n\n[Executioner]\n  type = Transient\n  start_time = 0\n  end_time = 2000\n  dt = 10\n  steady_state_detection = false\n  line_search = basic\n  solve_type = NEWTON\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-1\n  nl_max_its = 100\n\n  l_tol = 1e-7\n  l_max_its = 1000\n  \n[]\n\n[Outputs]\n    exodus = true\n    csv = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/22029",
          "updatedAt": "2022-09-29T16:28:12Z",
          "publishedAt": "2022-09-07T10:45:42Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@joshuahansel @licharlot maybe you have some ideas?",
                  "url": "https://github.com/idaholab/moose/discussions/22029#discussioncomment-3585761",
                  "updatedAt": "2022-09-07T14:29:58Z",
                  "publishedAt": "2022-09-07T14:29:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "The ideal gas values are sort of arbitrary but are made sure to be consistent with the values used in fluent.\n\nI'm not sure about the \"arbitrary\" part. I believe gamma and molar_mass are very relevant for this problem, since they determine the relation between internal energy and temperature. It sounds like you've made them consistent with your other runs, but I just want to make sure.\n\nDo you know if the FlowChannel1Phase is supposed to approximate the average temperature of the channel as well, or would it just capture the maximum temperature?\n\nIt approximates the average. More accurately, it approximates the average of the total energy density (and density and momentum density) and then computes temperature at those values.\nThis may be difficult: I don't see anything obviously wrong with your input, and your results are at least following physical trends. We just don't know why it's skewed toward the other end of the temperature range. This is mostly just a question of heat transfer, rather than flow. The key things I can think to look at are:\n\nheat transfer conditions of THM vs. your other codes (make sure they are all doing the same thing: htc*(T - T_wall))\nEOS of the working fluid (gamma and molar_mass)\ncross-sectional area of each channel\nheated perimeter of each channel P_hf\n\nNumber 1 is the most important. I already mentioned 2. 3 and 4 look correct.",
                  "url": "https://github.com/idaholab/moose/discussions/22029#discussioncomment-3587478",
                  "updatedAt": "2022-09-07T17:03:17Z",
                  "publishedAt": "2022-09-07T17:02:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It may be helpful to output more than just one temperature. htc as a function of space for example could be instructive.\ncp is a good idea too but since T is different it's likely to differ a little bit\nThe EOS are indeed very important. Are you using ideal gas across the board here?",
                          "url": "https://github.com/idaholab/moose/discussions/22029#discussioncomment-3588656",
                          "updatedAt": "2022-09-07T20:04:35Z",
                          "publishedAt": "2022-09-07T20:04:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problem about compiling and testing application",
          "author": {
            "login": "AimZhang"
          },
          "bodyText": "Hello, i am the new beginner to use MOOSE, when I compile and test the application, I met the issue (one error: no matching function for call to 'index_range' for (const auto pid : index_range(mesh->comm()))). Please see the attached. Could you please give me some assistance on that? Thank you very much.",
          "url": "https://github.com/idaholab/moose/discussions/22026",
          "updatedAt": "2022-09-07T19:03:25Z",
          "publishedAt": "2022-09-06T22:18:45Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthis is an incompatibility between your moose and libmesh version.\nI recommend you update both, following the procedure on the website\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22026#discussioncomment-3580557",
                  "updatedAt": "2022-09-07T01:17:11Z",
                  "publishedAt": "2022-09-07T01:17:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AimZhang"
                          },
                          "bodyText": "Thank you very much for your comments. I know how to update MOOSE according to the procedure of the website. But I am not sure how to update libmesh, I just downloaded the latest version of libmesh. And then I tried to compile and test the application, i got the same error. If I was wrong with updating libmesh, could you please show the detailed information about updating libmesh? Thank you very much.",
                          "url": "https://github.com/idaholab/moose/discussions/22026#discussioncomment-3580756",
                          "updatedAt": "2022-09-07T02:10:21Z",
                          "publishedAt": "2022-09-07T02:10:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "see this page\nhttps://mooseframework.inl.gov/getting_started/installation/update_moose.html\nthe conda update will update libmesh",
                          "url": "https://github.com/idaholab/moose/discussions/22026#discussioncomment-3581400",
                          "updatedAt": "2022-09-07T05:18:34Z",
                          "publishedAt": "2022-09-07T05:18:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AimZhang"
                          },
                          "bodyText": "Thank you very much for your suggestions and guidance. Now the problem has been figured out. I have succeeded in testing the application.",
                          "url": "https://github.com/idaholab/moose/discussions/22026#discussioncomment-3585069",
                          "updatedAt": "2022-09-07T13:36:34Z",
                          "publishedAt": "2022-09-07T13:36:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "CFD calculation converges when using PeriodicBC but not when using SymmetryBC",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hello, everyone. I want to calculate a simple conjugate heat transfer problem. The inside is a cylindrical internal heat source, the outside has fluid flow, and there is heat exchange between them.\n\nWhen I use periodic boundary conditions on the fluid boundary, the calculation can converge just fine. There are input file and mesh file:\n# Units: specific_heat_capacity--cp--J/(kg.K); density--rho--kg/(cm^3);\n# dynamic_viscosity--mu--kg/(cm.s); thermal_conductivity--k--W/(cm.K);\n# pressure--kg/(cm.s^2); force--kg.cm/s^2\n\noutlet_pressure = 0\ninlet_velocity = 150 # cm/s\nini_temp = 300 # K\nheat_transfer_coefficient = 9 # W/(cm2.K)\ng = -981 # cm/s2\nalpha_fluid = 2e-4 # thermal expansion coefficient of fluid used in INSADBoussinesqBodyForce\n\n[Mesh]\n  file = 'solid_fluid.msh'\n[]\n\n[Variables]\n  [./T]\n    initial_condition = ${ini_temp}\n  [../]\n  [./velocity]\n    family = LAGRANGE_VEC\n    block = 'fluid'\n  [../]\n  [./p]\n    order = FIRST\n    family = LAGRANGE\n    block = 'fluid'\n  [../]\n[]\n\n[AuxVariables]\n  [./heat]\n    family = MONOMIAL\n    order = FIRST\n    block = 'solid'\n  [../]\n[]\n\n[ICs]\n  [./initial_velocity]\n    type = VectorConstantIC\n    x_value = 0\n    y_value = 0\n    z_value = ${inlet_velocity}\n    variable = velocity\n  [../]\n  [./initial_p]\n    type = FunctionIC\n    variable = p\n    function = ini_p\n  [../]\n[]\n\n[Kernels]\n  [./fluid_mass]\n    type = INSADMass\n    variable = p\n  [../]\n  [./fluid_mass_pspg]\n    type = INSADMassPSPG\n    variable = p\n  [../]\n\n  [./fluid_momentum_time]\n    type = INSADMomentumTimeDerivative\n    variable = velocity\n  [../]\n  [./fluid_momentum_convection]\n    type = INSADMomentumAdvection\n    variable = velocity\n  [../]\n  [./fluid_momentum_viscous]\n    type = INSADMomentumViscous\n    variable = velocity\n  [../]\n  [./fluid_momentum_pressure]\n    type = INSADMomentumPressure\n    variable = velocity\n    pressure = p\n    integrate_p_by_parts = true\n  [../]\n  [./fluid_momentum_gravity]\n    type = INSADGravityForce\n    variable = velocity\n    gravity = '0 0 ${g}'\n  [../]\n  [./fluid_momentum_buoyancy]\n    type = INSADBoussinesqBodyForce\n    variable = velocity\n    gravity = '0 0 ${g}'\n    alpha_name = 'alpha_fluid'\n    ref_temp = 'T_ref'\n\ttemperature = T\n  [../]\n  [./fluid_momentum_supg]\n    type = INSADMomentumSUPG\n    variable = velocity\n    velocity = velocity\n  [../]\n\n  [./fluid_temperature_time]\n    type = INSADHeatConductionTimeDerivative\n    variable = T\n    block = 'fluid'\n  [../]\n  [./fluid_temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    block = 'fluid'\n    thermal_conductivity = 'k'\n  [../]\n  [./fluid_temperature_advection]\n    type = INSADEnergyAdvection\n    variable = T\n    block = 'fluid'\n  [../]\n  [./fluid_temperature_supg]\n    type = INSADEnergySUPG\n    variable = T\n    velocity = velocity\n    block = 'fluid'\n  [../]\n\n  [./solid_temperature_time]\n    type = ADHeatConductionTimeDerivative\n    variable = T\n    block = 'solid'\n    density_name = 'rho'\n    specific_heat = 'cp'\n  [../]\n  [./solid_temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    block = 'solid'\n    thermal_conductivity = 'k'\n  [../]\n  [./heat_source]\n    type = ADCoupledForce\n    variable = T\n    block = 'solid'\n    v = heat\n  [../]\n[]\n\n[AuxKernels]\n  [./heat_aux]\n    type = FunctionAux\n    variable = heat\n    function = heat_function\n    block = 'solid'\n  [../]\n[]\n\n[InterfaceKernels]\n  [./convection_heat_transfer]\n    type = ConjugateHeatTransfer\n    variable = T\n    T_fluid = T\n    neighbor_var = 'T'\n    boundary = 'solid_wall'\n    htc = 'htc'\n  [../]\n[]\n\n[BCs]\n  [./inlet_T_fluid]\n    type = DirichletBC\n    variable = T\n    boundary = 'fluid_bottom'\n    value = ${ini_temp}\n  [../]\n  [./inlet_velocity_fluid]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'fluid_bottom'\n    function_z = ${inlet_velocity}\n  [../]\n  [./outlet_p_fluid]\n    type = DirichletBC\n    variable = p\n    boundary = 'fluid_top'\n    value = ${outlet_pressure}\n  [../]\n\n  [./no_slip]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'solid_wall'\n  [../]\n\n  [./Periodic]\n    [./x]\n      variable = velocity\n      primary = 'fluid_wall1'\n      secondary = 'fluid_wall2'\n      translation = '1.6 0 0'\n    [../]\n    [./y]\n      variable = velocity\n      primary = 'fluid_wall3'\n      secondary = 'fluid_wall4'\n      translation = '0 1.6 0'\n    [../]\n  [../]\n[]\n\n[Materials]\n  [./rho_solid]\n    type = ADParsedMaterial\n    f_name = rho\n    function = '0.0110876 * pow(9.9672e-1 + 1.179e-5 * T - 2.429e-9 * pow(T,2) + 1.219e-12 * pow(T,3),-3)'\n    args = 'T'\n    block = 'solid'\n  [../]\n  [./cp_solid]\n    type = ADParsedMaterial\n    f_name = cp\n    function = '0.76 * ((302.27 * pow((548.68/T),2) * exp(548.68 / T)) / pow((exp(548.68 / T) - 1),2) + 2 * 8.463e-3 * T + 8.741e7 * 18531.7 * exp(-18531.7 / T) / pow(T,2)) + 0.24 * ((322.49 * pow((587.41/T),2) * exp(587.41 / T)) / pow((exp(587.41 / T) - 1),2) + 2 * 1.4679e-2 * T)'\n    args = 'T'\n    block = 'solid'\n  [../]\n  [./k_solid]\n    type = ADParsedMaterial\n    f_name = k\n    function = '1.158/(7.5408 + 17.692 * (T / 1000) + 3.6142 * pow((T/1000),2)) + 74.105 * pow((T / 1000),-2.5) * exp(-16.35 / (T / 1000))'\n    args = 'T'\n    block = 'solid'\n  [../]\n\n  [./rho_fluid]\n    type = ADParsedMaterial\n    f_name = rho\n    function = '(11096 - 1.3236 * T) * 1e-6'\n    args = 'T'\n    block = 'fluid'\n  [../]\n  [./cp_fluid]\n    type = ADParsedMaterial\n    f_name = cp\n    function = '159 - 2.72e-2 * T + 7.12e-6 * pow(T,2)'\n    args = 'T'\n    block = 'fluid'\n  [../]\n  [./k_fluid]\n    type = ADParsedMaterial\n    f_name = k\n    function = '(3.61 + 1.517e-2 * T - 1.741e-6 * pow(T,2)) * 1e-2'\n    args = 'T'\n    block = 'fluid'\n  [../]\n  [./mu_fluid]\n    type = ADParsedMaterial\n    f_name = mu\n    function = '4.94e-6 * exp(754.1/T)'\n    args = 'T'\n    block = 'fluid'\n  [../]\n  [./buoyancy_thermal_expansion_coefficient_fluid]\n    type = ADGenericConstantMaterial\n    prop_names = 'alpha_fluid'\n    prop_values = '${alpha_fluid}'\n\tblock = 'fluid'\n  [../]\n  [./buoyancy_reference_temperature_fluid]\n    type = GenericConstantMaterial\n    prop_names = 'T_ref'\n    prop_values = '${ini_temp}'\n\tblock = 'fluid'\n  [../]\n\n  [./ins_mat_fluid]\n    type = INSADStabilized3Eqn\n    velocity = velocity\n    pressure = p\n    temperature = T\n    block = 'fluid'\n  [../]\n\n  [./htc]\n    type = ADGenericFunctionMaterial\n    prop_names = htc\n    prop_values = htc_function\n  [../]\n[]\n\n[Functions]\n  [./htc_function]\n    type = ParsedFunction\n    value = ${heat_transfer_coefficient}\n  [../]\n  [./ini_p]\n    type = ParsedFunction\n    value = '0.01*981*(10-z)'\n  [../]\n  [./heat_function]\n    type = ParsedFunction\n    value = (100+200*sin((z/5)*(pi/2)))\n  [../]\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n    solve_type = 'NEWTON'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  num_steps = 100\n  dt = 0.1\n  #end_time = 15\n\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-10\n\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n  line_search = 'none'\n   # petsc_options_iname = '-snes_type'\n  # petsc_options_value = 'test'\n\n  nl_max_its = 30\n  l_max_its = 100\n  automatic_scaling = true\n[]\n\n[Postprocessors]\n  [./max_T_solid]\n    type = ElementExtremeValue\n    variable = T\n    value_type = max\n    block = 'solid'\n  [../]\n  [./max_T_fluid]\n    type = ElementExtremeValue\n    variable = T\n    value_type = max\n    block = 'fluid'\n  [../]\n  [./min_T_solid]\n    type = ElementExtremeValue\n    variable = T\n    value_type = min\n    block = 'solid'\n  [../]\n  [./min_T_fluid]\n    type = ElementExtremeValue\n    variable = T\n    value_type = min\n    block = 'fluid'\n  [../]\n  [./average_T_solid]\n    type = ElementAverageValue\n    variable = T\n    block = 'solid'\n  [../]\n  [./average_T_fluid]\n    type = ElementAverageValue\n    variable = T\n    block = 'fluid'\n  [../]\n[]\n\n[Outputs]\n  perf_graph = true\n  print_linear_residuals = true\n  [./exodus]\n    type = Exodus\n    file_base = 'periodic'\n    execute_on = 'TIMESTEP_END'\n  [../]\n  [./csv]\n    type = CSV\n    file_base = 'periodic'\n    execute_on = 'TIMESTEP_END'\n  [../]\n[]\n\nsolid_fluid.zip\nBut when I remove the Periodic block, it doesn't converge. Removing the Periodic block is equivalent to using symmetric boundary conditions. It stands to reason that it will be easier to converge, but why does it not converge? This is log of unconvergence:\n\nTime Step 2, time = 0.2, dt = 0.1\n 0 Nonlinear |R| = 8.485714e+01\n      0 Linear |R| = 8.485714e+01\n      1 Linear |R| = 4.318761e-13\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 1 Nonlinear |R| = 6.319871e+01\n      0 Linear |R| = 6.319871e+01\n      1 Linear |R| = 1.686456e-11\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 2 Nonlinear |R| = 3.316557e+03\n      0 Linear |R| = 3.316557e+03\n      1 Linear |R| = 3.042668e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 1\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 2\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nTime Step 2, time = 0.15, dt = 0.05\n 0 Nonlinear |R| = 8.482239e+01\n      0 Linear |R| = 8.482239e+01\n      1 Linear |R| = 3.379981e-13\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 1 Nonlinear |R| = 1.876576e+01\n      0 Linear |R| = 1.876576e+01\n      1 Linear |R| = 7.808751e-14\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 2 Nonlinear |R| = 2.629240e+00\n      0 Linear |R| = 2.629240e+00\n      1 Linear |R| = 8.474293e-15\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 3 Nonlinear |R| = 3.706761e-02\n      0 Linear |R| = 3.706761e-02\n      1 Linear |R| = 8.969932e-17\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 4 Nonlinear |R| = 1.038914e-05\n      0 Linear |R| = 1.038914e-05\n      1 Linear |R| = 1.382428e-20\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 5 Nonlinear |R| = 1.342291e-12\nNonlinear solve converged due to CONVERGED_FNORM_ABS iterations 5\n Solve Converged!\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | average_T_fluid| average_T_solid| max_T_fluid    | max_T_solid    | min_T_fluid    | min_T_solid    |\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n|   1.000000e-01 |   3.005032e+02 |   3.074653e+02 |   3.050133e+02 |   3.111522e+02 |   2.996791e+02 |   3.009880e+02 |\n|   1.500000e-01 |   3.008996e+02 |   3.110674e+02 |   3.078484e+02 |   3.166862e+02 |   2.996454e+02 |   3.014039e+02 |\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n\n\nTime Step 3, time = 0.25, dt = 0.1\n 0 Nonlinear |R| = 7.641333e+01\n      0 Linear |R| = 7.641333e+01\n      1 Linear |R| = 7.351782e-11\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 1 Nonlinear |R| = 6.255840e+03\n      0 Linear |R| = 6.255840e+03\n      1 Linear |R| = 2.664299e-08\n  Linear solve converged due to CONVERGED_RTOL iterations 1\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 1\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nTime Step 3, time = 0.2, dt = 0.05\n 0 Nonlinear |R| = 7.616738e+01\n      0 Linear |R| = 7.616738e+01\n      1 Linear |R| = 2.872117e-12\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 1 Nonlinear |R| = 1.463668e+02\n      0 Linear |R| = 1.463668e+02\n      1 Linear |R| = 1.250203e-12\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 2 Nonlinear |R| = 8.402202e+01\n      0 Linear |R| = 8.402202e+01\n      1 Linear |R| = 8.456488e-12\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 3 Nonlinear |R| = 7.352953e+02\n      0 Linear |R| = 7.352953e+02\n      1 Linear |R| = 9.239700e-11\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 4 Nonlinear |R| = 2.278266e+03\n      0 Linear |R| = 2.278266e+03\n      1 Linear |R| = 6.717040e-11\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 5 Nonlinear |R| = 2.906242e+03\n      0 Linear |R| = 2.906242e+03\n      1 Linear |R| = 7.319267e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 6 Nonlinear |R| = 4.956852e+05\n      0 Linear |R| = 4.956852e+05\n      1 Linear |R| = 6.717372e-08\n  Linear solve converged due to CONVERGED_RTOL iterations 1\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 6\n Solve Did NOT Converge!\n  Finished Solving                                                                       [  6.36 s] [   -8 MB]\nAborting as solve did not converge",
          "url": "https://github.com/idaholab/moose/discussions/21927",
          "updatedAt": "2022-09-06T23:35:46Z",
          "publishedAt": "2022-08-24T06:37:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "It seems to me that your timestep size is too large. Also try turning on line search.",
                  "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3522206",
                  "updatedAt": "2022-08-31T23:05:19Z",
                  "publishedAt": "2022-08-31T23:05:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Hi, Gary.\nI ran it again with the time step set to 1e-3s. It can successfully converge for some time steps, but eventually fails to converge. For example:\nTime Step 232, time = 0.214109, dt = 3.125e-05\n 0 Nonlinear |R| = 7.422914e+05\n      0 Linear |R| = 7.422914e+05\n      1 Linear |R| = 2.432374e-08\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 6.501265030058e+05\n      Line search: Quadratically determined step, lambda=1.2129268301528358e-01\n 1 Nonlinear |R| = 6.501265e+05\n      0 Linear |R| = 6.501265e+05\n      1 Linear |R| = 7.847862e-10\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Using full step: fnorm 6.501265030058e+05 gnorm 1.118199093675e+05\n 2 Nonlinear |R| = 1.118199e+05\n      0 Linear |R| = 1.118199e+05\n      1 Linear |R| = 2.225439e-10\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 7.281967524764e+04\n      Line search: Quadratically determined step, lambda=3.6000185982160982e-01\n 3 Nonlinear |R| = 7.281968e+04\n      0 Linear |R| = 7.281968e+04\n      1 Linear |R| = 1.436124e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 6.041156645469e+04\n      Line search: Quadratically determined step, lambda=1.7742439262738621e-01\n 4 Nonlinear |R| = 6.041157e+04\n      0 Linear |R| = 6.041157e+04\n      1 Linear |R| = 4.112801e-10\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 5.297745502053e+04\n      Line search: Quadratically determined step, lambda=1.2762287523084520e-01\n 5 Nonlinear |R| = 5.297746e+04\n      0 Linear |R| = 5.297746e+04\n      1 Linear |R| = 4.043613e-10\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 4.793660362104e+04\n      Line search: Quadratically determined step, lambda=1.0000000000000001e-01\n 6 Nonlinear |R| = 4.793660e+04\n      0 Linear |R| = 4.793660e+04\n      1 Linear |R| = 4.466409e-10\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 4.362044508014e+04\n      Line search: Quadratically determined step, lambda=1.0000000000000001e-01\n 7 Nonlinear |R| = 4.362045e+04\n      0 Linear |R| = 4.362045e+04\n      1 Linear |R| = 7.653383e-10\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 4.110402361219e+04\n      Line search: Quadratically determined step, lambda=1.0000000000000001e-01\n 8 Nonlinear |R| = 4.110402e+04\n      0 Linear |R| = 4.110402e+04\n      1 Linear |R| = 1.116284e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 4.320918900484e+04\n      Line search: Cubically determined step, current gnorm 4.029554026102e+04 lambda=5.0000000000000003e-02\n 9 Nonlinear |R| = 4.029554e+04\n      0 Linear |R| = 4.029554e+04\n      1 Linear |R| = 9.919788e-10\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 3.946430908802e+04\n      Line search: Quadratically determined step, lambda=1.0000000000000001e-01\n10 Nonlinear |R| = 3.946431e+04\n      0 Linear |R| = 3.946431e+04\n      1 Linear |R| = 8.978292e-10\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 3.747830798144e+04\n      Line search: Quadratically determined step, lambda=1.0000000000000001e-01\n11 Nonlinear |R| = 3.747831e+04\n      0 Linear |R| = 3.747831e+04\n      1 Linear |R| = 1.911727e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 3.633359718944e+04\n      Line search: Quadratically determined step, lambda=1.0000000000000001e-01\n12 Nonlinear |R| = 3.633360e+04\n      0 Linear |R| = 3.633360e+04\n      1 Linear |R| = 1.649189e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 3.905325381595e+04\n      Line search: Cubically determined step, current gnorm 3.591042393373e+04 lambda=5.0000000000000003e-02\n13 Nonlinear |R| = 3.591042e+04\n      0 Linear |R| = 3.591042e+04\n      1 Linear |R| = 2.151981e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 5.380629062127e+04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.832534407157e+04 lambda=5.0000000000000003e-02\n      Line search: Cubically determined step, current gnorm 3.570939662990e+04 lambda=1.4659528459221544e-02\n14 Nonlinear |R| = 3.570940e+04\n      0 Linear |R| = 3.570940e+04\n      1 Linear |R| = 5.412868e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: gnorm after quadratic fit 8.611297102658e+04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.390967672482e+04 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.574989576414e+04 lambda=1.2194848170694494e-02\n      Line search: Cubically determined step, current gnorm 3.560877116320e+04 lambda=5.7755881171468659e-03\n15 Nonlinear |R| = 3.560877e+04\n      0 Linear |R| = 3.560877e+04\n      1 Linear |R| = 5.605505e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 7.739739285272e-01 old ynorm 1.292033185023e+08\n      Line search: gnorm after quadratic fit 2.546263168797e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 6.097184153331e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.180021436634e+07 lambda=2.3412746138196498e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.452025267541e+06 lambda=1.1706373069098249e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.405583705397e+05 lambda=5.8531865345491244e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.425902515669e+05 lambda=2.9265932672745622e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.977028831758e+04 lambda=1.2580249466448837e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.603620005902e+04 lambda=2.5868068594588826e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561231000767e+04 lambda=2.5868068594588828e-05\n      Line search: Cubically determined step, current gnorm 3.560874238039e+04 lambda=2.5868068594588830e-06\n16 Nonlinear |R| = 3.560874e+04\n      0 Linear |R| = 3.560874e+04\n      1 Linear |R| = 4.858024e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 8.357378044938e-01 old ynorm 1.196547523186e+08\n      Line search: gnorm after quadratic fit 2.530777309551e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 6.060100780167e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.173036223579e+07 lambda=2.3412752680334738e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.439880243260e+06 lambda=1.1706376340167369e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.385248576420e+05 lambda=5.8531881700836846e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.421595440284e+05 lambda=2.9265940850418423e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.969265031061e+04 lambda=1.2569751328232106e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.602702716963e+04 lambda=2.5623627691178990e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561214984860e+04 lambda=2.5623627691178990e-05\n      Line search: Cubically determined step, current gnorm 3.560870781887e+04 lambda=2.5623627691178991e-06\n17 Nonlinear |R| = 3.560871e+04\n      0 Linear |R| = 3.560871e+04\n      1 Linear |R| = 4.166111e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 8.772393527081e-01 old ynorm 1.139939740406e+08\n      Line search: gnorm after quadratic fit 2.516839864030e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 6.026726228701e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.166748471741e+07 lambda=2.3412754806928785e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.428921584163e+06 lambda=1.1706377403464393e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.366788363895e+05 lambda=5.8531887017321963e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.417688343804e+05 lambda=2.9265943508660981e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.962263872708e+04 lambda=1.2560106942233907e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.601864773892e+04 lambda=2.5393854751680283e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561200843843e+04 lambda=2.5393854751680285e-05\n      Line search: Cubically determined step, current gnorm 3.560866942741e+04 lambda=2.5393854751680286e-06\n18 Nonlinear |R| = 3.560867e+04\n      0 Linear |R| = 3.560867e+04\n      1 Linear |R| = 3.045657e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 9.023369458712e-01 old ynorm 1.108233464867e+08\n      Line search: gnorm after quadratic fit 2.504164344805e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.996377025191e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.161029533028e+07 lambda=2.3412741544243248e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.418933305317e+06 lambda=1.1706370772121624e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.349870880094e+05 lambda=5.8531853860608121e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.414110180260e+05 lambda=2.9265926930304061e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.955888428768e+04 lambda=1.2551165179515167e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.601091997066e+04 lambda=2.5176210544191225e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561188283598e+04 lambda=2.5176210544191227e-05\n      Line search: Cubically determined step, current gnorm 3.560862875020e+04 lambda=2.5376786754072929e-06\n19 Nonlinear |R| = 3.560863e+04\n      0 Linear |R| = 3.560863e+04\n      1 Linear |R| = 3.307475e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 9.140681030527e-01 old ynorm 1.094010387913e+08\n      Line search: gnorm after quadratic fit 2.492424649958e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.968272464498e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.155732466344e+07 lambda=2.3412711958048487e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.409662500057e+06 lambda=1.1706355979024244e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.334086972698e+05 lambda=5.8531779895121218e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.410774278428e+05 lambda=2.9265889947560609e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.949976470911e+04 lambda=1.2542724307747525e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.600366192771e+04 lambda=2.4966562725673314e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561177017351e+04 lambda=2.4966562725673314e-05\n      Line search: Cubically determined step, current gnorm 3.560858699218e+04 lambda=2.5715181506820231e-06\n20 Nonlinear |R| = 3.560859e+04\n      0 Linear |R| = 3.560859e+04\n      1 Linear |R| = 3.334329e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 9.144694515751e-01 old ynorm 1.093530241254e+08\n      Line search: gnorm after quadratic fit 2.481296733993e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.941635564211e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.150711001999e+07 lambda=2.3412670327588678e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.400853854213e+06 lambda=1.1706335163794339e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.319011985702e+05 lambda=5.8531675818971696e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.407591195821e+05 lambda=2.9265837909485848e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.944363526956e+04 lambda=1.2534563738634610e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.599667995849e+04 lambda=2.4759942720377635e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561166806070e+04 lambda=2.4759942720377637e-05\n      Line search: Cubically determined step, current gnorm 3.560854518121e+04 lambda=2.5735137868507373e-06\n21 Nonlinear |R| = 3.560855e+04\n      0 Linear |R| = 3.560855e+04\n      1 Linear |R| = 1.967260e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 9.049102266596e-01 old ynorm 1.105081996577e+08\n      Line search: gnorm after quadratic fit 2.470791434436e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.916489851769e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.145969766205e+07 lambda=2.3412627068488553e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.392514112922e+06 lambda=1.1706313534244277e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.304662383809e+05 lambda=5.8531567671221384e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.404565008005e+05 lambda=2.9265783835610692e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.939051497768e+04 lambda=1.2526695175192320e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.598998011373e+04 lambda=2.4557014066958874e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561157625610e+04 lambda=2.4557014066958877e-05\n      Line search: Cubically determined step, current gnorm 3.560850422409e+04 lambda=2.5474734432770167e-06\n22 Nonlinear |R| = 3.560850e+04\n      0 Linear |R| = 3.560850e+04\n      1 Linear |R| = 1.990469e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 8.869411844240e-01 old ynorm 1.127470476692e+08\n      Line search: gnorm after quadratic fit 2.460893306831e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.892795570735e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.141501502610e+07 lambda=2.3412594310635304e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.384629462052e+06 lambda=1.1706297155317652e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.291020228765e+05 lambda=5.8531485776588260e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.401692497317e+05 lambda=2.9265742888294130e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.934028989795e+04 lambda=1.2519112711158360e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.598355428271e+04 lambda=2.4358074423502105e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561149417517e+04 lambda=2.4358074423502107e-05\n      Line search: Cubically determined step, current gnorm 3.560846486270e+04 lambda=2.4977232657827421e-06\n23 Nonlinear |R| = 3.560846e+04\n      0 Linear |R| = 3.560846e+04\n      1 Linear |R| = 1.641850e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 8.621387453150e-01 old ynorm 1.159906111904e+08\n      Line search: gnorm after quadratic fit 2.451573394991e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.870480802028e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.137292908793e+07 lambda=2.3412583526507852e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.377176233528e+06 lambda=1.1706291763253926e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.278051704055e+05 lambda=5.8531458816269630e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.398966949876e+05 lambda=2.9265729408134815e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.929278615915e+04 lambda=1.2511802921981875e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.597738886555e+04 lambda=2.4163265333936496e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561142104877e+04 lambda=2.4163265333936496e-05\n      Line search: Cubically determined step, current gnorm 3.560842765849e+04 lambda=2.4286709226844754e-06\n24 Nonlinear |R| = 3.560843e+04\n      0 Linear |R| = 3.560843e+04\n      1 Linear |R| = 2.137988e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 8.320003212091e-01 old ynorm 1.201922612898e+08\n      Line search: gnorm after quadratic fit 2.442798224923e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.849463357191e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.133328738559e+07 lambda=2.3412603921292619e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.370128329629e+06 lambda=1.1706301960646310e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.265719834422e+05 lambda=5.8531509803231548e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.396380769709e+05 lambda=2.9265754901615774e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.924782011130e+04 lambda=1.2504751926443300e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.597147051610e+04 lambda=2.3972717057327050e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561135603797e+04 lambda=2.3972717057327053e-05\n      Line search: Cubically determined step, current gnorm 3.560839301867e+04 lambda=2.3972717057327056e-06\n25 Nonlinear |R| = 3.560839e+04\n      0 Linear |R| = 3.560839e+04\n      1 Linear |R| = 4.714260e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 7.971221144381e-01 old ynorm 1.254512930814e+08\n      Line search: gnorm after quadratic fit 2.434346889249e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.829212769196e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.129509170969e+07 lambda=2.3412662394951971e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.363309769891e+06 lambda=1.1706331197475986e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.253724763575e+05 lambda=5.8531655987379928e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.393871143543e+05 lambda=2.9265827993689964e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.920425791300e+04 lambda=1.2497793678119939e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.596566072956e+04 lambda=2.3782378411351941e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561129778828e+04 lambda=2.3782378411351943e-05\n      Line search: Cubically determined step, current gnorm 3.560836130890e+04 lambda=2.3782378411351944e-06\n26 Nonlinear |R| = 3.560836e+04\n      0 Linear |R| = 3.560836e+04\n      1 Linear |R| = 4.597367e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 7.580179779790e-01 old ynorm 1.319229924686e+08\n      Line search: gnorm after quadratic fit 2.426116837701e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.809481962351e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.125787812483e+07 lambda=2.3412766026448772e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.356638456956e+06 lambda=1.1706383013224386e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.241927363358e+05 lambda=5.8531915066121929e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.391409153010e+05 lambda=2.9265957533060965e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.916156568695e+04 lambda=1.2490849194250980e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.595989518581e+04 lambda=2.3590373697022379e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561124561774e+04 lambda=2.3590373697022379e-05\n      Line search: Cubically determined step, current gnorm 3.560833284163e+04 lambda=2.3590373697022379e-06\n27 Nonlinear |R| = 3.560833e+04\n      0 Linear |R| = 3.560833e+04\n      1 Linear |R| = 2.401699e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 7.152232585786e-01 old ynorm 1.398164821971e+08\n      Line search: gnorm after quadratic fit 2.418063278533e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.790162399849e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.122144387408e+07 lambda=2.3412920942905459e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.350078762317e+06 lambda=1.1706460471452729e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.230269210130e+05 lambda=5.8532302357263647e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.388982782100e+05 lambda=2.9266151178631824e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.911950855337e+04 lambda=1.2483884705477254e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.595414777614e+04 lambda=2.3395987780711495e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561119911604e+04 lambda=2.3395987780711496e-05\n      Line search: Cubically determined step, current gnorm 3.560830787519e+04 lambda=2.3395987780711499e-06\n28 Nonlinear |R| = 3.560831e+04\n      0 Linear |R| = 3.560831e+04\n      1 Linear |R| = 2.741301e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 6.691905348121e-01 old ynorm 1.494342714038e+08\n      Line search: gnorm after quadratic fit 2.410150660565e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.771167955298e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.118562832788e+07 lambda=2.3413132075236050e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.343602780360e+06 lambda=1.1706566037618025e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.218705297629e+05 lambda=5.8532830188090124e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.386582772089e+05 lambda=2.9266415094045062e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.907790364172e+04 lambda=1.2476873788583793e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.594839886229e+04 lambda=2.3198666061369675e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561115794671e+04 lambda=2.3198666061369677e-05\n      Line search: Cubically determined step, current gnorm 3.560828662160e+04 lambda=2.3198666061369680e-06\n29 Nonlinear |R| = 3.560829e+04\n      0 Linear |R| = 3.560829e+04\n      1 Linear |R| = 4.872032e-07\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n      Line search: Scaling step by 6.203052380761e-01 old ynorm 1.612109552874e+08\n      Line search: gnorm after quadratic fit 2.402351194660e+08\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.752431363234e+07 lambda=5.0000000000000003e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.115030625307e+07 lambda=2.3413403180552420e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 2.337189124622e+06 lambda=1.1706701590276210e-02\n      Line search: Cubic step no good, shrinking lambda, current gnorm 5.207202000565e+05 lambda=5.8533507951381049e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 1.384202191881e+05 lambda=2.9266753975690524e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 4.903661209221e+04 lambda=1.2469796415577241e-03\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.594263433027e+04 lambda=2.2997995351909623e-04\n      Line search: Cubic step no good, shrinking lambda, current gnorm 3.561112183318e+04 lambda=2.2997995351909625e-05\n      Line search: Cubically determined step, current gnorm 3.560826925299e+04 lambda=2.2997995351909628e-06\n30 Nonlinear |R| = 3.560827e+04\nNonlinear solve did not converge due to DIVERGED_MAX_IT iterations 30\n Solve Did NOT Converge!\n  Finished Solving                                                                       [ 30.30 s] [    0 MB]\nAborting as solve did not converge\n\nThe following are input and output files:\nfiles.zip\nThe output file looks very weird. Am I missing some default boundary conditions in CFD calculations?",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3523512",
                          "updatedAt": "2022-09-01T05:20:38Z",
                          "publishedAt": "2022-09-01T05:20:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think this result is a nice example of advection induced instability in the velocity field. I suspect the Reynolds number is too high.",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3528123",
                          "updatedAt": "2022-09-01T15:17:18Z",
                          "publishedAt": "2022-09-01T15:17:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Tagging @GiudGiud and @lindsayad to confirm my statement above :)",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3528127",
                          "updatedAt": "2022-09-01T15:17:59Z",
                          "publishedAt": "2022-09-01T15:17:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "SUPG should help reduce oscillatory behavior. I also suspect there may be some issue with boundary conditions. What is this SymmetryBC that you are referring to? The only symmetry BC I'm aware of is the INSFVSymmetryBC which wouldn't be appropriate for the finite element model you're using here. For boundary conditions on the outer \"walls\" I might try a zero velocity boundary condition for the normal velocity and a natural condition (e.g. no boundary condition) for the tangential velocity components. Moreover, I would also use a natural boundary condition on the outlet as opposed to a dirichlet value for pressure.\nA lot of the models you are sharing on Discussions are pretty complex. Have you tried two dimensional versions of these models? Have you tried models starting with just the fluid flow domain and omitting the conjugate heat transfer physics? I always like to walk before I run, so if you haven't tried simplified versions of the models yet (you may very well have), I would highly encourage doing so.",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3528595",
                          "updatedAt": "2022-09-01T16:14:45Z",
                          "publishedAt": "2022-09-01T16:14:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thanks a lot for your advice, @hugary1995 and @lindsayad .\nFor velocity, what I think of as SymmetryBC is the natural boundary condition (ie no boundary condition). And I tried a new simpler 2D fluid model which removes the heat transfer part and just has the continuity and momentum equations. I think problems reflected in simple models may become ideas for solving complex models. This is a steady problem and BCs are given:\n\nThe solved pressure field is a little strange. And I plot a line for pressure in the y direction.\n\nWhy does this oscillation appear at the bottom of the pressure field? I have added PSPG item and SUPG item in input file.\nActually I had this problem a long time ago, but after I integrated the fluid part with the solid part and used PeriodicBC on the outer boundary of the fluid region, the problem disappeared. Now when I want to replace PeriodicBC with SymmetryBC (no BC) , it comes up again. Thanks for your suggestion @lindsayad , I will try simple models first, then complex ones!\nHere are input and output files.\nfiles.zip",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3534786",
                          "updatedAt": "2022-09-02T09:36:18Z",
                          "publishedAt": "2022-09-02T09:36:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Is there a way to set up a slip wall condition with a vector variable? I tried to with the VectorFunctionDirichletBC but the components default to 0 if not supplied.",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3536525",
                          "updatedAt": "2022-09-02T13:22:03Z",
                          "publishedAt": "2022-09-02T13:22:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@maxnezdyur unfortunately with VectorFunctionDirichletBC you cannot currently control what components get set (all will get set). But with ADVectorFunctionDirichletBC you inherit the set_x_comp, set_y_comp, and set_z_comp parameters from ADNodalBC with default settings of true.",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3538091",
                          "updatedAt": "2022-09-02T15:36:31Z",
                          "publishedAt": "2022-09-02T15:36:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@js-jixu I shared this link with @maxnezdyur yesterday and you may also find it informative to read: https://groups.google.com/g/moose-users/c/yWi8bdfZWvU. It discusses the merit (or lack of merit) of Dirichlet boundary conditions for pressure. Anyway if you are determined to use a DirichletBC for pressure, then you should set integrate_p_by_parts = false for your pressure term kernels in the momentum equation.",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3538120",
                          "updatedAt": "2022-09-02T15:39:51Z",
                          "publishedAt": "2022-09-02T15:39:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thanks for your advice @maxnezdyur . I just learned today that for the momentum equation, the SymmetricBC and Slip boundary condition are the same, they both have 0 normal velocity. I thought symmetric boundary conditions were natural boundary conditions before, but obviously I was wrong. Based on the settings of the boundary conditions in your input file, I combined @lindsayad 's advice on ADVectorFunctionDirichletBC to get a new set of boundary conditions:\n[BCs]\n  [./no_slip]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'left'\n  [../]\n  [./inlet_velocity]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'bottom'\n    function_y = ${inlet_velocity}\n  [../]\n  [./symmetry]\n    type = ADVectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'right'\n    function_x = 0\n    set_x_comp = true\n    set_y_comp = false\n    set_z_comp = false\n  [../]\n  [./outlet_p]\n    type = DirichletBC\n    variable = p\n    boundary = 'top'\n    value = ${outlet_pressure}\n  [../]\n[]\n\nThe meaning of the [Symmetry] block is to set the normal component of the velocity on the right boundary to 0, and the tangential component defaults to a natural boundary condition. Combining other parts of the original input file, I get the following velocity distribution and pressure distribution. Do you think this result is reasonable?\n\nHere are complete input and output files:\ncomplete_files.zip",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3541474",
                          "updatedAt": "2022-09-03T07:17:13Z",
                          "publishedAt": "2022-09-03T07:13:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Those results look reasonable to me",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3574233",
                          "updatedAt": "2022-09-06T17:16:19Z",
                          "publishedAt": "2022-09-06T17:16:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "maxnezdyur"
                  },
                  "bodyText": "The input file below is transient but runs to steady-state. I am not sure exactly what the results you are looking for is, so let me know if this works. I implemented the pressure_outlet using a Neumann condition on the velocity to show how I think it is done. This will not impose the pressure condition strongly. If you want to impose the pressure condition strongly then replace the BC portions of the input file with\n  [no_slip_left_x_symmetric_right]\n    type = DirichletBC\n    variable = vel_x\n    boundary = 'left right top'\n    value = 0\n  []\n  # [psuedo_pressure]\n  #   type = NeumannBC\n  #   variable = vel_y\n  #   boundary = 'top'\n  #   value = ${outlet_pressure}\n  # []\n  [pressure_outlet]\n    type = DirichletBC\n    variable = p\n    boundary = 'top'\n    value =  ${outlet_pressure}\n  []\n\nI recommend using the Neumann condition because it is easier to keep the problem well-posed.\nInput File\n# Units: cm K s kg\n\noutlet_pressure = 0.0\ninlet_velocity = 150 # cm/s\nrho_fluid = 0.0077\nmu_fluid = 1.762e-5\n[GlobalParams]\n  u = vel_x\n  v = vel_y\n  pressure = p\n  integrate_p_by_parts = true\n  laplace = false\n  supg = true\n  pspg = true\n  transient_term = true\n[]\n[Mesh]\n  file = '1layers_2d.msh'\n[]\n\n[Variables]\n  [vel_x]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [vel_y]\n    order = FIRST\n    family = LAGRANGE\n  []\n  [p]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[ICs]\n  [vel_x]\n    type = ConstantIC\n    variable = vel_x\n    value = 1e-15\n  []\n  [vel_y]\n    type = ConstantIC\n    variable = vel_y\n    value = 1e-15\n  []\n[]\n[Kernels]\n  [mass]\n    type = INSMass\n    variable = p\n  []\n  [x_momentum_space]\n    type = INSMomentumTractionForm\n    variable = vel_x\n    component = 0\n  []\n  [y_momentum_space]\n    type = INSMomentumTractionForm\n    variable = vel_y\n    component = 1\n  []\n  [x_time]\n    type = INSMomentumTimeDerivative\n    variable = vel_x\n  []\n  [y_time]\n    type = INSMomentumTimeDerivative\n    variable = vel_y\n  []\n[]\n\n[BCs]\n  [no_slip_left_x_symmetric_right]\n    type = DirichletBC\n    variable = vel_x\n    boundary = 'left right'\n    value = 0\n  []\n  [no_slip_y]\n    type = DirichletBC\n    variable = vel_y\n    boundary = 'left'\n    value = 0\n  []\n  [inlet_velocity]\n    type = DirichletBC\n    variable = vel_y\n    boundary = 'bottom'\n    value = ${inlet_velocity}\n  []\n  [psuedo_pressure]\n    type = NeumannBC\n    variable = vel_y\n    boundary = 'top'\n    value = ${outlet_pressure}\n  []\n[]\n\n[Materials]\n  [fluid_mat]\n    type = GenericConstantMaterial\n    prop_names = 'rho mu'\n    prop_values = '${rho_fluid} ${mu_fluid}'\n  []\n[]\n\n[Functions]\n  [ini_p]\n    type = ParsedFunction\n    value = '${rho_fluid} * 981 * (90 - y)'\n  []\n[]\n\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n    solve_type = 'NEWTON'\n  []\n[]\n\n[Executioner]\n  type = Transient\n  dt = 1\n  end_time = 100\n  steady_state_detection = true\n\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-10\n\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n  line_search = 'none'\n\n  nl_max_its = 30\n  l_max_its = 100\n  automatic_scaling = true\n  off_diagonals_in_auto_scaling = true\n  compute_scaling_once = false\n  [TimeIntegrator]\n    type = BDF2\n  []\n[]\n\n[Outputs]\n  [exodus]\n    type = Exodus\n    file_base = 'steady'\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3536994",
                  "updatedAt": "2022-09-02T14:20:29Z",
                  "publishedAt": "2022-09-02T14:20:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "It should be noted that this is implicitly setting on the top boundary:\nny * (p - mu * dvy/dy) = -outlet_pressure\nso I'm a little worried about the signs here. If flow is fully developed, then dvy/dy is 0, and this would lead implicitly to setting\np = -outlet_pressure\nsince at the top ny is +1 ... but since your outlet_pressure is 0, then 0 = -0 and everything is ok in this case. But in general the NeumannBC should be used with caution for a couple reasons:\n\nNeumannBC doesn't include any information about the normal vector direction so you need to account for it when setting the value parameter\nYou will only be setting what you think you're setting (the pressure) if the other stress components in the normal direction are 0. What you are actually setting in general is a the summation of the different stresses\n\nHopefully that all makes sense?",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3538233",
                          "updatedAt": "2022-09-02T15:53:51Z",
                          "publishedAt": "2022-09-02T15:53:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "js-jixu"
                  },
                  "bodyText": "I would like to close this discussion (if my input file above is correct).\nFor this 2D model, I should get the same velocity field distribution whether I use PeriodicBC or SymmetryBC:\n\nIn fact it is. The reason for the so-called \"convergence with PeriodicBC , but not with SymmetryBC \" I encountered before is that the SymmetryBC is set wrong. There is no SymmetryBC in the finite element INS module of MOOSE, so SymmetryBC needs to be obtained by setting DirichletBC and NeumannBC to the velocity variable.\nI used to think that SymmetryBC was equal to the natural boundary condition, which is not the case. SymmetryBC should look like this:\n\nThe normal component of velocity is 0 and the gradient of the tangential component of velocity is 0. The VectorFunctionDirichletBC currently does not support setting a specific component, which means that if you want to use VectorFunctionDirichletBC, you need to set a function for the velocity x_comp, y_comp, z_comp respectively (the components default to 0 if not supplied). But what we want is to set x_comp to 0 and the gradient of y_comp to 0. So we can use ADVectorFunctionDirichletBC, by setting set_y_comp=false to avoid giving DirichletBC to y_comp, which means the y component of velocity has a NeumannBC with a value of 0. The input file is as follows:\n  [./symmetry]\n    type = ADVectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'fluid_wall'\n    function_x = 0\n    set_x_comp = true\n    set_y_comp = false\n    set_z_comp = false\n  [../]\n\nI have calculated a 2D fluid flow problem with PeriodicBC and SummetryBC respectively (please ignore the heat transfer part of it) and they have exactly the same velocity field distribution.\nHere are complete input and output files. Thanks a lot for @lindsayad  @maxnezdyur  @hugary1995 .\ngithub_files.zip",
                  "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3545093",
                  "updatedAt": "2022-09-04T03:03:54Z",
                  "publishedAt": "2022-09-04T03:03:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I am glad you're getting good results now!",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3574364",
                          "updatedAt": "2022-09-06T17:17:31Z",
                          "publishedAt": "2022-09-06T17:17:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I agree that setting the normal component velocity to 0 and implicitly setting the normal gradient of the tangential velocity components to 0 using natural boundary conditions is good for what you are trying to model.",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3574533",
                          "updatedAt": "2022-09-06T17:19:34Z",
                          "publishedAt": "2022-09-06T17:19:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "(\u0e51\u2022\u0301\u03c9\u0e01\u0300\u0e51)\nI have another problem with conservation of energy in fluid heat transfer calculation. Could you please take a look at it?\n#21966",
                          "url": "https://github.com/idaholab/moose/discussions/21927#discussioncomment-3580133",
                          "updatedAt": "2022-09-06T23:35:47Z",
                          "publishedAt": "2022-09-06T23:35:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to impose weak spring boundary condition in MOOSE",
          "author": {
            "login": "BoZeng1997"
          },
          "bodyText": "Hi,\nI want to know how to impose weak spring boundary condition like in ANSYS when using MOOSE. My simulated object swells and I want to have the thermal expansion be almost free on most surfaces. I am trying not to assume how it should swell by fixing the rigid body motion by DirichletBC. I am currently considering Robin BC so that traction will be proportional to the displacement. $\\frac{\\partial u}{\\partial n}=ku$. k will be a small negative number. But simulation did not converged with CoupledVarNeumannBC.\n\nIs Robin BC the right BC to impose weak spring BC in MOOSE? If not, does MOOSE have one?\nIs CoupledVarNeumannBC the right MOOSE object to use for Robin BC for displacement field? If not, does MOOSE have one?\nDoes MOOSE have a warning option for rigid body motion? Sometimes for simple problems, the simulation converged to a reasonable result even the displacement constraints did not forbid rigid body motion.",
          "url": "https://github.com/idaholab/moose/discussions/22022",
          "updatedAt": "2022-09-29T16:28:35Z",
          "publishedAt": "2022-09-06T21:42:07Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "1 & 2, a spring BC looks like stress . normal = k u. So yes, the CoupledVarNeumannBC should work, you may need to repeat it three times for the three components though (twice in 2D, obviously).\n3 is a tricky one. You can test for null space by looking at the singular values of your matrix. To do that, first reduce the size of your problem, then run it with -pc_type svd. If the minimum singular value is near zero then you definitely have a null space. Whether that null space corresponds to a rigid body mode is at your discretion.",
                  "url": "https://github.com/idaholab/moose/discussions/22022#discussioncomment-3579801",
                  "updatedAt": "2022-09-06T22:18:11Z",
                  "publishedAt": "2022-09-06T22:18:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Why can't 'alpha' be found?",
          "author": {
            "login": "MScKarl"
          },
          "bodyText": "Hi!\nUsing the code below,\n[Functions]\n\t[./alpha] \n\ttype = ParsedFunction\n\tvalue = abs(alpha_0)*(sgn_0-sqrt(r_0/sqrt(x*x+y*y))*cos(atan2(x,y)/2))\n\t#  alpha_0, sgn_0, r_0 are constants\n\t[../]\n[]\n\n[Materials]\n        #Total Free Energy \n        [./f_eta]\n        type = ParsedMaterial\n        f_name = f_eta # Name of the function\n        args = 'alpha beta gamma eta' #the coefficients\n        function = '(alpha*eta+beta*eta^3+gamma*eta^5)' \n        [../]\n[]\n\nI get the following error message:\n*** ERROR ***\nf_eta: Coupled variable 'alpha' was not found\n\nMy question is, why can't alpha be found?\nBest regards,\nKarl",
          "url": "https://github.com/idaholab/moose/discussions/20872",
          "updatedAt": "2022-09-06T11:51:45Z",
          "publishedAt": "2022-04-26T13:51:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you look at the docs for ParsedMaterial you ll see that args is to declare variables, not for functions.\nThere is actually not support for functions in this Material, except for parsed expressions. Since alpha is a parsed expression, you can write it directly in the ParsedMaterial.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20872#discussioncomment-2639990",
                  "updatedAt": "2022-06-22T08:43:21Z",
                  "publishedAt": "2022-04-26T15:17:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "Hi again,\nThank you for your answer.\nI am sorry to bother you again. But if I understood your answer correctly, I should just use alpha directly in my main equation. Like this:\n[Materials]\n    #Total Free Energy \n    [./f_eta]\n    type = ParsedMaterial\n    f_name = f_eta # Name of the function\n    args = 'alpha_0 sgn_0 r_0 beta gamma eta' #the coefficients\n    function = '((abs(alpha_0)*(sgn_0-sqrt(r_0/sqrt(x*x+y*y))*cos(atan2(x,y)/2)))*eta+beta*eta^3+gamma*eta^5)' \n    [../]\n\n[]\nWhen I tried this, I got the following error:\n*** ERROR ***\nInvalid function\n((abs(alpha_0)(sgn_0-sqrt(r_0/sqrt(xx+y*y))cos(atan2(x,y)/2)))eta+betaeta^3+gammaeta^5)\nalpha_0,sgn_0,r_0,beta,gamma,eta\nin ParsedMaterialHelper.\nSyntax error: Unknown identifier\nWhat am I missing?\nBest regards\nKarl",
                          "url": "https://github.com/idaholab/moose/discussions/20872#discussioncomment-2649116",
                          "updatedAt": "2022-06-22T08:43:22Z",
                          "publishedAt": "2022-04-27T18:06:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nyou need to declare the constants for the parser to know what it refers to\nconstant_names and constant_expressions are the two to set\nhttps://mooseframework.inl.gov/source/materials/ParsedMaterial.html\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/20872#discussioncomment-2649424",
                          "updatedAt": "2022-06-22T08:46:07Z",
                          "publishedAt": "2022-04-27T18:55:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "But they're declared and given an initial condition.\n[AuxVariables]\n[./alpha_0]\n    order = CONSTANT\n    family = MONOMIAL\n    initial_condition = 1.0\n[../]\n\n[./sgn_0]\norder = CONSTANT\nfamily = MONOMIAL\ninitial_condition = 1.0\n#\u00c4ndra samtida som alpha_0\n[../]\n\n[./beta]\n    order = CONSTANT\n    family = MONOMIAL\n    initial_condition = 1.0\n[../]\n[./gamma]\n    order = CONSTANT\n    family = MONOMIAL\n    initial_condition = 1.0\n[../]\n[./g] #vary\n    order = CONSTANT\n    family = MONOMIAL\n    initial_condition = 0.001\n[../]\n\n[./r_0] \n    order = CONSTANT\n    family = MONOMIAL\n    initial_condition = 1\n[../]\n\n[]\n[Variables]\n[./eta]\n[./InitialCondition]\ntype = RandomIC\nmin = -1\nmax = 1\n[../]\n[../]\n\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/20872#discussioncomment-2649727",
                          "updatedAt": "2022-06-22T08:46:13Z",
                          "publishedAt": "2022-04-27T19:49:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you need to tell the parser about it. It's explicit in the parameters.",
                          "url": "https://github.com/idaholab/moose/discussions/20872#discussioncomment-2649739",
                          "updatedAt": "2022-07-28T14:52:12Z",
                          "publishedAt": "2022-04-27T19:51:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "[Functions]\n[./alpha]  #\u03b1 \u2261 |\u03b1_ 0| (sgn(\u03b1_ 0)-\u221a(r_0/r)*cos(\u03b8/2))\ntype = ParsedFunction\nvalue = abs(alpha_0)*(sgn_0-sqrt(r_0/sqrt(x*x+y*y))*cos(atan2(x,y)/2))\n[../]\n\n[]\n[Materials]\n[./constants]\ntype = GenericConstantMaterial\nprop_names = 'alpha_0 sgn_0 beta gamma r_0'\nprop_values = '1.0 1.0 1.0 1.0 1.0'\n[../]\n\n    #Total Free Energy \n    [./f_eta]\ntype = ParsedMaterial\nf_name = f_eta # Name of the function\nargs = 'sgn_0 r_0 beta gamma eta' #the coefficients\nconstat_names = 'alpha x y'#_0 sgn_0 r_0 x y\nfunction = 'alpha*eta+beta*eta^3+gamma*eta^5'\n#function = 'abs(alpha_0*(sgn_0-sqrt(r_0/(x*x+y*y))*cos(atan2(x,y)/2)))*eta+beta*eta^3+gamma*eta^5'\n[../]\n\n[]\nWhy can't alpha find x and y which are coordinates from my mesh?\nAdditionaly isn't possible to comined coordinates and phase variables in one function as tried in the '#function'?",
                          "url": "https://github.com/idaholab/moose/discussions/20872#discussioncomment-2674786",
                          "updatedAt": "2022-07-28T14:52:12Z",
                          "publishedAt": "2022-05-02T16:07:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "look at the parameters for parsed function. You need to declare what you are using in the parsed expression inside the ParsedFunction block.\nhttps://mooseframework.inl.gov/source/functions/MooseParsedFunction.html",
                          "url": "https://github.com/idaholab/moose/discussions/20872#discussioncomment-2675023",
                          "updatedAt": "2022-07-28T14:52:30Z",
                          "publishedAt": "2022-05-02T16:41:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "Hi again,\nThank you. But I tried this:\n[Functions]\n[./alpha] \ntype = ParsedFunction\nvalue = abs(alpha_0)*(sgn_0-sqrt(r_0/(x^2+y^2))*cos(atan2(x,y)/2))\nvars = 'alpha_0 sgn_0 r_0'\nvals = '1.0 1.0 1.0'\n[../]\n\n[]\n[Materials]\n[./constants]\ntype = GenericConstantMaterial\nprop_names = 'alpha_0 sgn_0 beta gamma r_0'\nprop_values = '1.0 1.0 1.0 1.0 1.0'\n[../]\n\n    #Total Free Energy \n    [./f_eta]\ntype = ParsedMaterial\nf_name = f_eta # Name of the function\nargs = 'beta gamma eta' #the coefficients\n#constant_expressions = 'alpha'\nconstat_names = 'alpha x y'#_0 sgn_0 r_0 x y\nfunction = 'alpha*eta+beta*eta^3+gamma*eta^5'\n[../]\n\n[]\nBut it still givs me,\n*** ERROR ***\nInvalid function\nalphaeta+betaeta^3+gamma*eta^5\nsgn_0,r_0,beta,gamma,eta\nin ParsedMaterialHelper.\nSyntax error: Unknown identifier\nI do belive that it has something to do with that x & y are coordinates in the mesh, but why can't I use mesh coordinates in the function?",
                          "url": "https://github.com/idaholab/moose/discussions/20872#discussioncomment-2675989",
                          "updatedAt": "2022-07-28T14:52:29Z",
                          "publishedAt": "2022-05-02T19:25:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "[./f_eta]\ntype = ParsedMaterial\nf_name = f_eta # Name of the function\nargs = 'beta gamma eta' #the coefficients\n#constant_expressions = 'alpha'\nconstat_names = 'alpha x y'#_0 sgn_0 r_0 x y\nfunction = 'alpha*eta+beta*eta^3+gamma*eta^5'\n[../]\n\nconstant_names is mispelled.\nx and y are no longer in the expression for the parsed material. They are in the parsed function",
                          "url": "https://github.com/idaholab/moose/discussions/20872#discussioncomment-2676132",
                          "updatedAt": "2022-07-28T14:52:58Z",
                          "publishedAt": "2022-05-02T19:52:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MScKarl"
                          },
                          "bodyText": "Thank you for you answer, that solved the problem with the invalid function. :)\nAlthough, in my ParsedMaterial (I belive) , it says that:\n*** ERROR ***\nThe parameter vectors constant_names and constant_values must have equal length.\n\nbut what constant_values is it referring to, the coupled variables are defined as AuxVariables? 'alpha' is a function calculated and referred to in materials, I do not want to give it a value, that would defeat the purpose of the function.\n[AuxVariables]\n\n\t[./alpha_0]\n        order = CONSTANT\n        family = MONOMIAL\n\t[../]\n\t\n\t[./sgn_0]\n\torder = CONSTANT\n\tfamily = MONOMIAL\n\t[../]\n\n\t[./beta]\n        order = CONSTANT\n        family = MONOMIAL\n\t[../]\n\n\t[./gamma]\n        order = CONSTANT\n        family = MONOMIAL\n\t[../]\n\n\t[./r_0] \n        order = CONSTANT\n        family = MONOMIAL\n\t[../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/20872#discussioncomment-2676359",
                          "updatedAt": "2022-07-28T14:53:04Z",
                          "publishedAt": "2022-05-02T20:31:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "alpha should not be in constant_names, it's a function.\nLooks like we are missing support for functions in parsed materials.\nLet's do this instead, put it in a variable,\n [f_eta]\n  type = ParsedMaterial\n  f_name = f_eta # Name of the function\n  args = 'beta gamma eta alpha' #the coefficients\n  function = 'alpha*eta+beta*eta^3+gamma*eta^5'\n []\n\n[AuxVariables]\n  [alpha]\n        order = CONSTANT\n        family = MONOMIAL\n  []\n[]\n\n[AuxKernels]\n  [fill_alpha]\n    type = FunctionAux\n    variable = alpha\n    function = alpha_fun\n  []\n[]\n\n[Functions]\n  [alpha] \n    type = ParsedFunction\n    value = abs(alpha_0)*(sgn_0-sqrt(r_0/(x^2+y^2))*cos(atan2(x,y)/2))\n    vars = 'alpha_0 sgn_0 r_0'\n    vals = '1.0 1.0 1.0'\n  []\n[]\n\nbtw, make sure to use triple back-quotes when pasting code or input files. It looks a lot nicer",
                          "url": "https://github.com/idaholab/moose/discussions/20872#discussioncomment-2676412",
                          "updatedAt": "2022-07-28T14:53:40Z",
                          "publishedAt": "2022-05-02T20:43:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Difference between Coupled and CoupledValue",
          "author": {
            "login": "Oops-Qiao"
          },
          "bodyText": "Hello,\nJust a minor question here,\n_T(coupled(\"temperature\"))\n_T(coupledValue(\"temperature\"))\nare they same? I tried to find \"coupled\" this keyword in moose but could not.\nThen another thing is the following \"jvar\" defined in the bracket, does it has a initial value there?\nif not, how to exactly understand the meaning of  \"if (jvar == _T)\".\nReal\nNewmatrix :: computeQpOffDiagJacobian(unsigned int jvar)\n{\nReal j = 0;\nif (jvar == _T)\n{\nj += _drho_dT[_qp] ;\nj *= _test[_i][_qp];\n}\nreturn j;\n}",
          "url": "https://github.com/idaholab/moose/discussions/22010",
          "updatedAt": "2022-09-12T07:17:56Z",
          "publishedAt": "2022-09-05T16:14:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n_coupled gets you the index of the variable in the system, which is why it s appropriate to compare to jvar\ncoupledValue gets you the value at local quadrature points\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22010#discussioncomment-3561876",
                  "updatedAt": "2022-09-06T03:39:34Z",
                  "publishedAt": "2022-09-05T16:28:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "jvar does not have an initial value. It's the routine's argument. You should have a look at the doxygen to understand what the arguments to the routines mean\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classes.html\nWhen you build the equation's Jacobian, you have to keep track of variable indices, especially on the off-diagonal. This is what _T is doing for temperature",
                          "url": "https://github.com/idaholab/moose/discussions/22010#discussioncomment-3565552",
                          "updatedAt": "2022-09-06T03:42:25Z",
                          "publishedAt": "2022-09-06T03:42:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}