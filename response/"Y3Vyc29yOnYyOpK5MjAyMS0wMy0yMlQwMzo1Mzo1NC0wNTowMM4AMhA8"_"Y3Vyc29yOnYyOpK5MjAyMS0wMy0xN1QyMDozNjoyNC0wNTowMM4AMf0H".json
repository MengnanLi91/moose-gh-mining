{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wMy0xN1QyMDozNjoyNC0wNTowMM4AMf0H"
    },
    "edges": [
      {
        "node": {
          "title": "Initializing Solution in Newton Iterations",
          "author": {
            "login": "nikhilgv91"
          },
          "bodyText": "Hello,\nI am solving a transient problem. I would like to know whether it is possible to initialize the solution before the Netwon iterations for each timestep begin?\nBest,\nNikhil",
          "url": "https://github.com/idaholab/moose/discussions/17384",
          "updatedAt": "2021-05-06T15:01:32Z",
          "publishedAt": "2021-03-19T13:58:10Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "You can look into the Predictor system. We have objects in that system that extrapolate past solutions to obtain a better guess. However you'll be dealing with raw DOF value access.",
                  "url": "https://github.com/idaholab/moose/discussions/17384#discussioncomment-511154",
                  "updatedAt": "2021-03-22T00:35:31Z",
                  "publishedAt": "2021-03-22T00:35:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Add output data after the simulation is over",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Dear MOOSE experts,\nRecently, I recently completed a simulation and output the strain (the three strain components in 2D), but now I want to output the stress component again. Now, could I get the stress data on the basis of previous simulations without recalculating?\nThis is the moose example I used\uff0cpoly_grain_growth_2D_eldrforce.i.\nAny suggestions or recommendations to fix these problems would be greatly appreciated.\nThank you\nWei Peng",
          "url": "https://github.com/idaholab/moose/discussions/17329",
          "updatedAt": "2023-09-26T19:06:16Z",
          "publishedAt": "2021-03-16T14:23:38Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "Give this a try:\n[Outputs]\n  [out]\n    type = Exodus\n    additional_execute_on = FINAL\n  []\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/17329#discussioncomment-489148",
                  "updatedAt": "2023-09-26T19:06:16Z",
                  "publishedAt": "2021-03-16T14:59:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you very much. @aeslaughter\nAccording to your suggestion, I modified the Outputs module and added sub-blocks that require output stress in AuxKernel, Input file is as follows\npoly_grain_growth_2D_eldrforce_0.i \nand then executed the code,\nmpirun -np 10 ~/projects/monkey/monkey-opt -i poly_grain_growth_2D_eldrforce_0.i > poly_grain_growth_2D_eldrforce_0.log \nBut this method shows that it is recalculated.\nCould you talk more about it?",
                          "url": "https://github.com/idaholab/moose/discussions/17329#discussioncomment-492338",
                          "updatedAt": "2023-09-26T19:07:37Z",
                          "publishedAt": "2021-03-17T07:18:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "Can you give me more information, I don't understand \"But this method shows that it is recalculated.\" What method shows what is recalculated?",
                          "url": "https://github.com/idaholab/moose/discussions/17329#discussioncomment-495605",
                          "updatedAt": "2023-09-26T19:07:37Z",
                          "publishedAt": "2021-03-17T20:32:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@aeslaughter I think he means, he wants to use stress calculated from his first simulation directly on his second simulation without re-calculating it.\n\nNow, could I get the stress data on the basis of previous simulations without recalculating?",
                          "url": "https://github.com/idaholab/moose/discussions/17329#discussioncomment-496030",
                          "updatedAt": "2023-09-26T19:07:37Z",
                          "publishedAt": "2021-03-17T22:31:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Yes, what I want to do is to directly obtain the stress component data on the basis of my first simulation, instead of recalculating the model after modifying the input file.\nIn detail, the exodus file now contains strain components (three in two dimensions) and the Euler angle of each grain. Knowing the elastic stiffness tensor, how to pass Hooke's law\nto get the stress component?",
                          "url": "https://github.com/idaholab/moose/discussions/17329#discussioncomment-496392",
                          "updatedAt": "2023-09-26T19:07:37Z",
                          "publishedAt": "2021-03-18T01:15:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi, for uploading the data from .e file, you might want to have a look at 'initial conditions + restart'\n`use_for_exodus_restart = true\n\n`initial_from_file_var`\n\nbut for the 2nd part of your q, I'm not sure either, I'm also very new to MOOSE.\nIs it possible to calculate material property before running the FEM simulation? It might got something to do with AuxKernals\nCould someone help with this? thank you :)",
                          "url": "https://github.com/idaholab/moose/discussions/17329#discussioncomment-500736",
                          "updatedAt": "2023-09-26T19:07:37Z",
                          "publishedAt": "2021-03-18T22:50:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Wei, you should use solution aux https://mooseframework.inl.gov/source/auxkernels/SolutionAux.html and solution user object https://mooseframework.inl.gov/source/userobject/SolutionUserObject.html to read in your previous results.\nIn your Problem block, set solve = false, i.e.\n[Problem]\n  solve = false\n[]\n\nto skip the solve.\nKeep everything else the same, and just add a stress calculator.",
                  "url": "https://github.com/idaholab/moose/discussions/17329#discussioncomment-500896",
                  "updatedAt": "2023-09-26T19:07:38Z",
                  "publishedAt": "2021-03-19T00:05:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "This should work, but only disable the solve if the calculations being done in the second input file are not solving a PDE. Sorry I did understand your initial condition and lead you down the wrong path.",
                          "url": "https://github.com/idaholab/moose/discussions/17329#discussioncomment-503475",
                          "updatedAt": "2023-09-26T19:07:37Z",
                          "publishedAt": "2021-03-19T14:27:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you very much for your enthusiastic help.\nI am not very familiar with some functions of moose, so I solved this problem with paraview. Given the strain component, Euler angle, and elastic modulus without rotation, use the generalized Hooke's law to solve. Of course, if you has a more detailed plan based on moose, and I am happy to try it.",
                          "url": "https://github.com/idaholab/moose/discussions/17329#discussioncomment-508804",
                          "updatedAt": "2023-09-26T19:07:37Z",
                          "publishedAt": "2021-03-21T01:32:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Activate AMR only after criterion?",
          "author": {
            "login": "mangerij"
          },
          "bodyText": "Is it easy to set in the input file to activate AMR only after percent change in energy, F, is below a certain value? Say: if dF/dt = 1e-3 start to aggressively coarsen?\nI also seem to have problems getting the simulation to immediately refine down to max_h_level and stay that way. Say for example I use:\ninitial_steps = 5\nbut I want ALL elements (and not just markers/indicators) to be refined down to this until dF/dt = 1e-3 when the markers/indicators kick in. Then it should coarsen the domains (image attached).\nThings are looking peachy here in ferroelectrics land (big thanks to @SudiptaBiswas for helping us get the \"thin film\" boundary conditions working).\ncheers\nJohn",
          "url": "https://github.com/idaholab/moose/discussions/17125",
          "updatedAt": "2024-07-25T14:33:30Z",
          "publishedAt": "2021-02-24T20:25:50Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi John\nI dont think AMR can be turned on/off using the Control system.\nHowever you could use an AuxVariable to control the refinement criteria, and those could be set using a criterion like the one you mentioned.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17125#discussioncomment-491184",
                  "updatedAt": "2024-07-25T14:33:41Z",
                  "publishedAt": "2021-03-16T22:22:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "It should be possible to create a control that does, but it might be just as easy to create a custom Marker object that can check the criteria. It could use or not-use the results from another marker.",
                          "url": "https://github.com/idaholab/moose/discussions/17125#discussioncomment-495616",
                          "updatedAt": "2024-07-25T14:33:43Z",
                          "publishedAt": "2021-03-17T20:36:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mangerij"
                  },
                  "bodyText": "I am still thinking about this.\n\nWe have an order parameter that is a vector whose components start near zero and small. And randomly oriented so they possible have large gradients. We ideally want to refine down (so value threshold could work initially) but we don't want to refine too far at the early stages.\n\nBut later in the simulation the value of some of the components are much larger but some could be small still!\n\nAt this point we want to have maximum refinement near the phase field interface but maximum coarsening far away. It's pretty tricky. I will try to post a small example...\n\nGet Outlook for Android<https://aka.ms/AAb9ysg>\n\u2026\n________________________________\nFrom: Andrew E Slaughter ***@***.***>\nSent: Wednesday, March 17, 2021 9:36:39 PM\nTo: idaholab/moose ***@***.***>\nCc: Mangeri, John ***@***.***>; Author ***@***.***>\nSubject: Re: [idaholab/moose] Activate AMR only after criterion? (#17125)\n\n\n*Message sent from a system outside of UConn.*\n\n\nIt should be possible to create a control that does, but it might be just as easy to create a custom Marker object that can check the criteria. It could use or not-use the results from another marker.\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub<https://nam10.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fidaholab%2Fmoose%2Fdiscussions%2F17125%23discussioncomment-495616&data=04%7C01%7Cjohn.mangeri%40uconn.edu%7C23ce1c5ae7f044fb4df408d8e9845e82%7C17f1a87e2a254eaab9df9d439034b080%7C0%7C0%7C637516102021675356%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C1000&sdata=L9gmf2fWjqJH%2F9Bzc9%2FboPqQoZXoguOMETY6Ds0hRzo%3D&reserved=0>, or unsubscribe<https://nam10.safelinks.protection.outlook.com/?url=https%3A%2F%2Fgithub.com%2Fnotifications%2Funsubscribe-auth%2FABZ65FBW3OMIMVLDU3KTR6DTEEHFPANCNFSM4YFGGA4Q&data=04%7C01%7Cjohn.mangeri%40uconn.edu%7C23ce1c5ae7f044fb4df408d8e9845e82%7C17f1a87e2a254eaab9df9d439034b080%7C0%7C0%7C637516102021675356%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C1000&sdata=37%2FgRgtqeh5wEER9ejWdkaPInKGcGIABDiU2m425OJ0%3D&reserved=0>.",
                  "url": "https://github.com/idaholab/moose/discussions/17125#discussioncomment-495653",
                  "updatedAt": "2024-07-25T14:33:46Z",
                  "publishedAt": "2021-03-17T20:42:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "Sounds like a case for a custom marker. I made one a long while ago to track a phase-field interface but account for the direction of travel and marked more in the direction of travel.",
                          "url": "https://github.com/idaholab/moose/discussions/17125#discussioncomment-495674",
                          "updatedAt": "2024-07-25T14:33:48Z",
                          "publishedAt": "2021-03-17T20:45:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "This makes sense. As our domains (in the above image) merely coarsen until we kill the simulation. This is what I aim to tackle with the AMR.\nIn the above picture, the domain walls (interface between \"phases\") lie at inclined planes. An example, being [110] and all symmetry equivalent directions.\nIt would be nice to not have to assume this direction of the propagating wall for the Marker/Indicator since different materials have symmetry specific wall angles with respect to a global axis and these can change drastically with temperature.",
                          "url": "https://github.com/idaholab/moose/discussions/17125#discussioncomment-503193",
                          "updatedAt": "2024-07-25T14:33:56Z",
                          "publishedAt": "2021-03-19T13:16:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Calculation of elastic modulus gives Euler angle",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Hi all\uff0c\nI use Euler angles to rotate the elastic stiffness matrix. I only give the first Euler angle 45\u00b0 and the other two to 0\u00b0. Then according to C_ijkl = R_im*R_jn*R_ko*R_lp*C_mnop, the specific calculation is as follows, But the C1111 calculated manually is different from the C1111 calculated by the program running.\n\nThe manually calculated c1111 is 1.1729e5, and the moose calculated c1111 is 1.7245e5.\n\nWhat is the problem with me?\nThe following is the process of my calculation and the input file used.\n\n\n  [./elasticity_euler] type = ComputeElasticityTensor block = 0 base_name = 'euler' fill_method = symmetric9 C_ijkl = '1.27e5 0.708e5 0.708e5 1.27e5 0.708e5 1.27e5 0.7355e5 0.7355e5 0.7355e5' euler_angle_1 = 45.  # same as above but opposite direction because _transpose_ gets built from these angles euler_angle_2 = 0. euler_angle_3 = 0. [../]\nrotation_matrix_1_rotation.i\nThank you and best regards, Wei",
          "url": "https://github.com/idaholab/moose/discussions/17371",
          "updatedAt": "2022-06-11T09:04:05Z",
          "publishedAt": "2021-03-18T15:18:34Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "Did you try rotating by -45 degrees? According to the documentation, the Euler angles are used to calculate the transpose of the rotation matrix due to the Bunge convention.",
                  "url": "https://github.com/idaholab/moose/discussions/17371#discussioncomment-499023",
                  "updatedAt": "2022-06-11T09:04:52Z",
                  "publishedAt": "2021-03-18T15:29:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Also I think that with 4 indices (ijkl) that can either be 1 or 2, you should have at least 8 terms in your summation.",
                          "url": "https://github.com/idaholab/moose/discussions/17371#discussioncomment-500283",
                          "updatedAt": "2022-06-11T09:04:53Z",
                          "publishedAt": "2021-03-18T20:27:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you very much for your guidance. @jessecarterMOOSE\nI already know where my problem is and have overlooked some items. The following is my revised process, I hope other people will not make the same mistake as me.",
                          "url": "https://github.com/idaholab/moose/discussions/17371#discussioncomment-501800",
                          "updatedAt": "2022-06-11T09:04:53Z",
                          "publishedAt": "2021-03-19T06:24:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Solving steady-state problem using explicit solver?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi all,\nIs there a way to solve a steady-state problem using explicit method?\nI know MOOSE is optimised with implicit, but my problem is kinda large (couple million elements) and require to run many steady-state simulations (with a minor change in material property at each run), so my supervisor suggests me to work with explicit solver instead.\nIve attached a simplify version the input file (tensor mech with implicit) here.\nimplicit_to_explicit.zip\nThank you guys.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/17368",
          "updatedAt": "2022-09-12T05:11:59Z",
          "publishedAt": "2021-03-18T00:05:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I'm not sure that your question makes sense, @Traiwit .   \"Implicit\" and \"explicit\" usually refer to the timestepping method, but if you're doing steadystate only then there is no time.  To put it differently - to achieve steadystate, you'd have to time-step to infinity, which would take an explicit solver an infinite amount of time.",
                  "url": "https://github.com/idaholab/moose/discussions/17368#discussioncomment-496272",
                  "updatedAt": "2022-09-12T05:11:59Z",
                  "publishedAt": "2021-03-18T00:16:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thank you for your answer Andy, I just realised that I didn't think of the fundamental of FEM.\nI'm now kinda dig myself into a hole with this mining simulation i'm trying to build.\nI might work on quasi-static instead (you suggested a while ago), where after the elastic steady-state is reached > change the marterial property of 1 block > run steady-state simulation again > repeat.\nI'm not sure if MOOSE can do that, I know it's quite simple with for-loop. This might worth posting in a new discussion.",
                          "url": "https://github.com/idaholab/moose/discussions/17368#discussioncomment-496300",
                          "updatedAt": "2022-09-12T05:11:59Z",
                          "publishedAt": "2021-03-18T00:27:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "If you do that, you probably want to run it in a single simulation.  Make the model transient but have no time-derivative (velocity, acceleration, etc) Kernels.  Then each timestep will be solving the steady-state problem, ie, you'll be doing a quasi-static simulation.  The \"time\" in these simulations isn't a real time, but is simply to help you divide up the mining excavations into stages.  Eg, set dt=1, and in the first timestep you mine stage 1, in the next timestep you mine stage 2, etc.  So the notion of \"time\" essentially allows you to do your \"for loop\" idea.\nAn associated advantage is that you can, if you wish, shove in some time-derivative kernels, and solve the dynamic problem (you'll probably need damping), which can help with convergence when you've got complicated plasticity, and you can use an explicit method if you like.",
                          "url": "https://github.com/idaholab/moose/discussions/17368#discussioncomment-496360",
                          "updatedAt": "2022-09-12T05:12:00Z",
                          "publishedAt": "2021-03-18T00:57:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi Andy, thank you for your reply.\nDo you have (or can think of) any example for this quasi-static simulation? I tried to make the input file transient, but the error said 'i'm the a wrong state' for some reason, maybe because I do not have 'time' term anywhere in the input file.\nagain, thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/17368#discussioncomment-496469",
                          "updatedAt": "2022-09-12T05:12:01Z",
                          "publishedAt": "2021-03-18T02:04:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "@WilkAndy I read your coal-mining example, I see your problem works well with quasi-static as you set the ecavation as a function of time and location\n[./excav_sideways]\n    type = ParsedFunction\n    vars = 'end_t ymin ymax  minval maxval slope'\n    vals = '17.0   0    1000.0 1E-9 1 60'\n    # excavation face at ymin+(ymax-ymin)*min(t/end_t,1)\n    # slope is the distance over which the modulus reduces from maxval to minval\n    value = 'if(y<ymin+(ymax-ymin)*min(t/end_t,1),minval,if(y<ymin+(ymax-ymin)*min(t/end_t,1)+slope,minval+(maxval-minval)*(y-(ymin+(ymax-ymin)*min(t/end_t,1)))/slope,maxval))'\n  [../]\n\nHowever, is it possible to do quasi-static with mining-step plan associate with block ID for example\nt = 1 // excavate block 1 2\nt = 2 // excavate block 3 4 5\nt = 3 // excavate block 6 7 and backfill block 2\netc ...\nwith my very little knowledge of MOOSE, i doubt MOOSE can do what i mentioned above in a single input file.\nI could do that by running each steady-state simulation using the solution from previous step.\nwhat do you think?\nBest regards,\nTraiwit",
                  "url": "https://github.com/idaholab/moose/discussions/17368#discussioncomment-496643",
                  "updatedAt": "2022-09-12T05:12:02Z",
                  "publishedAt": "2021-03-18T04:08:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Yes, this is quite easy.   Just define an appropriate ParsedFunction .  It'll look horrible, eg\nvalue = 'if(t<=1, if(y<2000, 1, 0), if(t <=2 , if(y<5000 & y >= 2000, 1, 0)))'",
                          "url": "https://github.com/idaholab/moose/discussions/17368#discussioncomment-496773",
                          "updatedAt": "2022-09-12T05:12:01Z",
                          "publishedAt": "2021-03-18T05:53:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi Andy, very interesting that MOOSE can do that, and I agree it will be very messy if the excavation blocks are 3D in the middle of the geometry. I will give it a go and get back to you.\nI just hope that it can be done via blockID instead of defining the dimensions\nfor example: at t=1 E of block1 = 0 & E for all the other blocks remain the same as the previous step\nKind regards,\nTrai",
                          "url": "https://github.com/idaholab/moose/discussions/17368#discussioncomment-498008",
                          "updatedAt": "2022-09-12T05:12:01Z",
                          "publishedAt": "2021-03-18T12:34:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "That will be no problem, since you can define your ElasticityTensor block-by-block and deactivate it using it's own elasticity_tensor_prefactor.   Real mining probably happens more like a MovingPlanarFront which allows you to specify a start position, an end position, a mining velocity, and an active_length (which could be your void, for instance).",
                          "url": "https://github.com/idaholab/moose/discussions/17368#discussioncomment-500361",
                          "updatedAt": "2022-09-12T05:12:02Z",
                          "publishedAt": "2021-03-18T20:59:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @WilkAndy thank you again for your suggestion, I will give it a go and probs get back to you in the afternoon.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/17368#discussioncomment-500651",
                          "updatedAt": "2022-09-12T05:12:02Z",
                          "publishedAt": "2021-03-18T22:25:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@WilkAndy it works, but if my input has like 400+ blocks i might need a script to write an input file.\nNow, I fill need to work with backfilling and then I can move on to plasticity.\nagain, thank you very much for your support!\nBelow is the example case, 0 = geology block, 1 2 3 = excavating blocks\n\n[Functions]\n[./E_excav1]\n  type = ParsedFunction\n  value = 'if(t>=1,10e-4,1)'\n[../]\n[./E_excav2]\n  type = ParsedFunction\n  value = 'if(t>=2,10e-4,1)'\n[../]\n[./E_excav3]\n  type = ParsedFunction\n  value = 'if(t>=3,10e-4,1)'\n[../]\n\n[./density_excav1]\n  type = ParsedFunction\n  value = 'if(t>=1,1.225,2700)' # air density or rock density\n[../]\n[./density_excav2]\n  type = ParsedFunction\n  value = 'if(t>=2,1.225,2700)' # air density or rock density\n[../]\n[./density_excav3]\n  type = ParsedFunction\n  value = 'if(t>=3,1.225,2700)' # air density or rock density\n[../]\n[]\n\n[Materials]\n  [./stress]\n    type = ComputeFiniteStrainElasticStress\n  [../]\n\n[./elasticity_tensor_0_unmined]\n  type = ComputeIsotropicElasticityTensor\n  block = '0'\n  youngs_modulus = 20e9\n  poissons_ratio = 0.25\n[../]\n[./elasticity_tensor_1]\n  type = ComputeIsotropicElasticityTensor\n  block = '1'\n  youngs_modulus = 20e9\n  poissons_ratio = 0.25\n  elasticity_tensor_prefactor = E_excav1\n[../]\n[./elasticity_tensor_2]\n  type = ComputeIsotropicElasticityTensor\n  block = '2'\n  youngs_modulus = 20e9\n  poissons_ratio = 0.25\n  elasticity_tensor_prefactor = E_excav2\n[../]\n[./elasticity_tensor_3]\n  type = ComputeIsotropicElasticityTensor\n  block = '3'\n  youngs_modulus = 20e9\n  poissons_ratio = 0.25\n  elasticity_tensor_prefactor = E_excav3\n[../]\n\n[./density_0_unmined]\n  type = GenericConstantMaterial\n  block = '0'\n  prop_names = density\n  prop_values = 2700\n[../]\n[./density_1]\n  type = GenericFunctionMaterial\n  block = '1'\n  prop_names = density\n  prop_values = density_excav1\n[../]\n[./density_2]\n  type = GenericFunctionMaterial\n  block = '2'\n  prop_names = density\n  prop_values = density_excav2\n[../]\n[./density_3]\n  type = GenericFunctionMaterial\n  block = '3'\n  prop_names = density\n  prop_values = density_excav3\n[../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/17368#discussioncomment-501311",
                          "updatedAt": "2022-09-12T05:12:03Z",
                          "publishedAt": "2021-03-19T02:52:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "error installing libmesh on a HPC cluster (petsc-3.14.2)",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nWe are having some problematic times trying to upgrade our moose/libmesh installation on our internal cluster - while installing libmesh. Attached the config.log file.\nNote: for the first time, I did not install manually petsc (3.14.2), but used the script from the framework. Had problems with the direct solver strumpack (deactivated), but I do not think it matters.\nBefore re-installing manually everything, I was wondering if anyone could see what I am missing.\nThank in advance for any help,\nmauro\n\nconfig.log",
          "url": "https://github.com/idaholab/moose/discussions/17040",
          "updatedAt": "2021-03-19T08:45:51Z",
          "publishedAt": "2021-02-17T17:48:46Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "Dear all,\nI am re-opening this post, since I cannot find a solution to the problem above.\nI should add that I am able to compile an older version of the framework (specific commit 54c00d0) against petsc version 3.12.5 (manually compiled). However I cannot upgrade to the newest version. I am installing petsc (3.14.2) relying on the procedure as per the website. I checked the installation and all worked fine., but while trying to build libmesh it always fails with the same error as I posted above (I can link again the log file in case).\nIt would be nice if anyone from the developer team and/or users group could help me sorting out this issue.\nThanks in advance for any help,\nMauro",
                  "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-419008",
                  "updatedAt": "2021-03-01T17:55:23Z",
                  "publishedAt": "2021-03-01T17:55:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Attached the whole build.log (>4 MB) file for libmesh in case it could be of any help (the config.log is as for the one above and it looks OK to me at least)\nbuild.log",
                          "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-419203",
                          "updatedAt": "2021-03-01T18:48:08Z",
                          "publishedAt": "2021-03-01T18:48:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Mauro\nIs this fixed? I ll tag people who may be able to help if not",
                  "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-491295",
                  "updatedAt": "2021-03-16T23:02:46Z",
                  "publishedAt": "2021-03-16T23:02:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "Thanks for your reply @GiudGiud.\nThe problem still persists, though I did not (re)try to compile. This said, I would much appreciate any guidance in this respect.\nLooking forward to feedback.\nMauro",
                  "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-492420",
                  "updatedAt": "2021-03-17T07:48:18Z",
                  "publishedAt": "2021-03-17T07:48:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "I saw this 28 days ago, and I still don't have an idea... @roystgnr or @lindsayad ?",
                  "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-493930",
                  "updatedAt": "2021-03-17T14:06:35Z",
                  "publishedAt": "2021-03-17T14:06:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@fdkong was working on push_parallel_vectors lately he might have an idea too",
                          "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-494011",
                          "updatedAt": "2021-03-17T14:35:50Z",
                          "publishedAt": "2021-03-17T14:35:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "It could be an \"old\" compiler. Could you should the result of \"mpicxx -show\"?",
                  "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-494595",
                  "updatedAt": "2021-03-17T16:46:13Z",
                  "publishedAt": "2021-03-17T16:45:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "@fdkong I am loading gcc 7.2 on openmpi 4. Here is the show on the mpicxx:\ng++ -I/cluster/openmpi/gcc-7.2.0/openmpi-4.0.1/include -pthread -Wl,-rpath -Wl,/cluster/openmpi/gcc-7.2.0/openmpi-4.0.1/lib -Wl,--enable-new-dtags -L/cluster/openmpi/gcc-7.2.0/openmpi-4.0.1/lib -lmpi\nShould I try to see whether I can upgrade?",
                  "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-495067",
                  "updatedAt": "2021-03-17T18:17:36Z",
                  "publishedAt": "2021-03-17T18:17:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "We should definitely still be supporting 7.2; if not then that's something that we should fix or workaround on our part.  But it couldn't hurt to try a newer compiler to confirm or rule that out.",
                          "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-495228",
                          "updatedAt": "2021-03-17T18:57:51Z",
                          "publishedAt": "2021-03-17T18:57:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Oh, wait!  Just looked at your build.log.  We've seen this once before - the trouble is likely that we've started requesting more recent C++ standards support by default, but some older compilers accept the flags to support newer standards, pass our configure-time tests with those flags on, but then fail to actually compile our code.\nTry forcing an older standard by configuring libMesh with --cxx-std=2011 and see if that works any better.",
                          "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-495290",
                          "updatedAt": "2021-03-17T19:16:25Z",
                          "publishedAt": "2021-03-17T19:16:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We really need @jwpeterson to work his m4 C++ standard testing magic",
                          "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-495650",
                          "updatedAt": "2021-03-17T20:42:21Z",
                          "publishedAt": "2021-03-17T20:42:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "The trouble here is that I'm not even sure how we'd write a test for this problem.  It's not a missing feature that we're running into; it'seems to be a compiler bug that gets triggered by a very complex piece of code.  It'd be a ton of work to boil it down into a test small enough for an autoconf macro that still triggers the same problem.\nI'd say we should just downgrade the level of C++ we ask for, since we don't need C++17 yet, but I've been hoping we could actually upgrade to need (and thus to be able to internally use) C++17 later this year, now that even the conservative RHEL distributions default to gcc 8.  But if people are still using gcc 7.2 and if it's responsible for this build failure then perhaps I'm being too optimistic?  gcc 7 is supposed to have full C++17 support too, in theory, but in practice here we are.",
                          "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-495704",
                          "updatedAt": "2021-03-17T20:53:11Z",
                          "publishedAt": "2021-03-17T20:53:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "@roystgnr and all other: Thanks! I really had some terrible time trying to figure out what I was doing wrong ...\nI will set up myself to it tomorrow (CET) and will report asap.",
                  "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-495240",
                  "updatedAt": "2021-03-17T19:01:55Z",
                  "publishedAt": "2021-03-17T19:01:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "After upgrading to gcc 9.2 libmesh install without any problem. @roystgnr: your guess was right. Though I thought I did try to force the 11 standards before, but surely I did mix things up. Thanks for the support.",
                  "url": "https://github.com/idaholab/moose/discussions/17040#discussioncomment-499851",
                  "updatedAt": "2021-03-18T18:33:17Z",
                  "publishedAt": "2021-03-18T18:32:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using AD with constitutive models",
          "author": {
            "login": "joe61vette"
          },
          "bodyText": "Hi:\nI would like to place a set of constitutive models into a file so that they can be called by multiple ADMaterial objects.  Is it possible to propagate AD info back from these functions to the ADMaterial?  If so, what should they inherit from?  Can they just be utility functions?\nFor example, an ADMaterial calls a function \"getHTC(Re, Pr)\" where it is declared:\nADReal getHTC(ADReal Re, ADReal Pr);\nWould something like that work?  Is there a good example to follow?\nThanks,\nJoe Kelly",
          "url": "https://github.com/idaholab/moose/discussions/17339",
          "updatedAt": "2022-07-20T21:11:52Z",
          "publishedAt": "2021-03-16T22:01:33Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Joe\nThis would work, the derivative information stored in the Reynolds and Prandtl number will be propagated in the function (provided ADReals are used inside too) to the output.\nThere are good examples in pronghorn. For example in materials/PebbleBedKappaSolid.C\nFor the inheritance question, I think maybe the thing to do is to have all these utility functions be member functions of a class, and have the ADMaterial you are creating inherit from that class. Pronhorn does that for all the closures that are similar and sharing utility functions.\nJust separate utility functions can also work.\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17339#discussioncomment-491145",
                  "updatedAt": "2022-07-20T21:11:53Z",
                  "publishedAt": "2021-03-16T22:10:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Thanks Guillaume.\nI thought that might be the case but some text in the AD documentation confused me.  Namely:\n\"Leveraging the automatic differentiation capabilities in MOOSE is as simple as inheriting from our AD base classes, e.g., ADKernel, ADIntegratedBC....\".\nAs there isn't an ADUserObject base class, I wasn't sure if AD would work with methods that inherit from UO's.\nThanks,\nJoe",
                          "url": "https://github.com/idaholab/moose/discussions/17339#discussioncomment-499716",
                          "updatedAt": "2022-07-20T21:11:53Z",
                          "publishedAt": "2021-03-18T17:52:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Access information on failed time step in Predictor class",
          "author": {
            "login": "matthiasneuner"
          },
          "bodyText": "Predictors like SimplePredictor are a great tools for increasing the simulation speed.\nHowever, in certain situations it should be possible to omit a prediction.\nFor instance, if a time step is reduced according to a request by a material model (e.g., plasticity requires a smaller time step),\nno prediction should be made in the new, reduced time step. Currently, the prediction is also applied in the new, reduced time step. If the direction of the prediction is not reasonable, this can be the death of a simulation since it may result in an (infinite) request of smaller time steps by the material.\nI was looking for a possibility to request information within the Predictor class wether the current time step is a repeated time step or not. However, I could find nothing helpful.\nIs there any possibility get information about a potential repetition of a time step?\nThank you and best regards, Matthias",
          "url": "https://github.com/idaholab/moose/discussions/16628",
          "updatedAt": "2022-10-04T22:10:47Z",
          "publishedAt": "2021-01-07T14:06:33Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@lindsayad Do you have any insight on this?",
                  "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-267268",
                  "updatedAt": "2023-01-07T17:45:04Z",
                  "publishedAt": "2021-01-07T15:51:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "Have you actually verified that the predictor is run again?  I could have sworn that we just left the (partially solved) solution there from the previous attempt (because that sometimes actually works as a \"predictor\" for the failed step).\nWhat you might be seeing is actually the opposite of this: the predictor may need to be run after the failed step (but with the new timestep).",
                  "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-267831",
                  "updatedAt": "2023-01-07T17:45:04Z",
                  "publishedAt": "2021-01-07T20:52:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "matthiasneuner"
                          },
                          "bodyText": "Good question! I definitively observe some kind of endless loop of smaller time step requests caused by some invalid initial guesses. I will verify the actual cause of the invalid guesses. If the origin is the partially solved guess, is there any possibility to deactivate this feature?",
                          "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-268424",
                          "updatedAt": "2023-01-07T17:45:04Z",
                          "publishedAt": "2021-01-08T06:02:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "matthiasneuner"
                  },
                  "bodyText": "Hello, so the predictor is definitely called directly in the cut back time step.\nI verified it by making a dummy material which constantly requests a smaller time step ( if _t - _dt > 0.5 )\n(Please ignore the designation MarmotMaterial, this is not related to the MOOSE application MARMOT.)\nAs you can see, also in the reduced time steps the SimplePredictor is called, as indicated by the message 'Applying predictor with scale factor = 1':\nTime Step 5, time = 0.5, dt = 0.1                                                                                                                                                                                                                      \n  Applying predictor with scale factor = 1                                                                                                                                                                                                             \n 0 Nonlinear |R| = 1.009537e-08                                                                                                                                                                                                                        \n  Linear solve converged due to CONVERGED_RTOL iterations 35                                                                                                                                                                                           \n 1 Nonlinear |R| = 7.100492e-11                                                                                                                                                                                                                        \nNonlinear solve converged due to CONVERGED_FNORM_ABS iterations 1                                                                                                                                                                                      \n Solve Converged!                                                                                                                                                                                                                                      \n                                                                                                                                                                                                                                                       \nPostprocessor Values:                                                                                                                                                                                                                                  \n+----------------+----------------+                                                                                                                                                                                                                    \n| time           | bot_react_y    |                                                                                                                                                                                                                    \n+----------------+----------------+                                                                                                                                                                                                                    \n|   0.000000e+00 |   0.000000e+00 |                                                                                                                                                                                                                    \n|   1.000000e-01 |  -2.184054e+01 |                                                                                                                                                                                                                    \n|   2.000000e-01 |  -4.368110e+01 |                                                                                                                                                                                                                    \n|   3.000000e-01 |  -6.552164e+01 |                                                                                                                                                                                                                    \n|   4.000000e-01 |  -8.736219e+01 |                                                                                                                                                                                                                    \n|   5.000000e-01 |  -1.092027e+02 |                                                                                                                                                                                                                    \n+----------------+----------------+                                                                                                                                                                                                                    \n                                                                                                                                                                                                                                                       \n                                                                                                                                                                                                                                                       \nTime Step 6, time = 0.6, dt = 0.1                                                                                                                                                                                                                      \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \ninducing failure                                                                                                                                                                                                                                       \n0 0 0 0 0 0                                                                                                                                                                                                                                            \n  Applying predictor with scale factor = 1                                                                                                                                                                                                             \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \nNonlinear solve did not converge due to DIVERGED_FUNCTION_DOMAIN iterations 0                                                                                                                                                                          \ninducing failure                                                                                                                                                                                                                                       \n1.91342e-05 -4.67289e-06 -4.82314e-06 1.8302e-06 -7.0505e-09 8.8664e-09                                                                                                                                                                                \n Solve Did NOT Converge!                                                                                                                                                                                                                               \nAborting as solve did not converge                                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                       \nSolve failed, cutting timestep.                                                                                                                                                                                                                        \n                                                                                                                                                                                                                                                       \nTime Step 6, time = 0.55, dt = 0.05                                                                                                                                                                                                                    \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \ninducing failure                                                                                                                                                                                                                                       \n0 0 0 0 0 0                                                                                                                                                                                                                                            \n  Applying predictor with scale factor = 1                                                                                                                                                                                                             \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \nNonlinear solve did not converge due to DIVERGED_FUNCTION_DOMAIN iterations 0                                                                                                                                                                          \ninducing failure                                                                                                                                                                                                                                       \n9.56711e-06 -2.33644e-06 -2.41157e-06 9.15099e-07 -3.52525e-09 4.4332e-09                                                                                                                                                                              \n Solve Did NOT Converge!                                                                                                                                                                                                                               \nAborting as solve did not converge                                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                       \nSolve failed, cutting timestep.                                                                                                                                                                                                                        \n                                                                                                                                                                                                                                                       \nTime Step 6, time = 0.525, dt = 0.025                                                                                                                                                                                                                  \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \ninducing failure                                                                                                                                                                                                                                       \n0 0 0 0 0 0                                                                                                                                                                                                                                            \n  Applying predictor with scale factor = 1                                                                                                                                                                                                             \nMarmotMaterial LINEARELASTIC requests a smaller timestep.                                                                                                                                                                                              \nNonlinear solve did not converge due to DIVERGED_FUNCTION_DOMAIN iterations 0                                                                                                                                                                          \ninducing failure                                                                                                                                                                                                                                       \n9.56711e-06 -2.33644e-06 -2.41157e-06 9.15099e-07 -3.52525e-09 4.4332e-09                                                                                                                                                                              \n Solve Did NOT Converge!                                     \nAborting as solve did not converge                           \n\nThe 6 numerical numbers are the strain increment.\nWhat I am currently wondering about is the zero strain increment, which means that the material is evaluated always with a zero strain increment before the predictor comes into play. Accordingly, the material throws 2(!) exceptions before the time step is cut back.",
                  "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-283595",
                  "updatedAt": "2023-01-07T17:45:04Z",
                  "publishedAt": "2021-01-15T06:25:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Is this solved?",
                  "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-494169",
                  "updatedAt": "2023-12-11T23:54:01Z",
                  "publishedAt": "2021-03-17T15:05:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Looking in Predictor.C, there is a parameter called skip_after_failed_timestep. This defaults to false, but it sounds like you should set this to true in your Predictor input file block. I believe this is what you were looking for?",
                  "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-495919",
                  "updatedAt": "2023-12-11T23:54:01Z",
                  "publishedAt": "2021-03-17T21:59:55Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "matthiasneuner"
                          },
                          "bodyText": "Yes, this one was implemented by me after opening this thread ;-) .",
                          "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-496805",
                          "updatedAt": "2023-12-11T23:54:05Z",
                          "publishedAt": "2021-03-18T06:10:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Haha excellent!",
                          "url": "https://github.com/idaholab/moose/discussions/16628#discussioncomment-498880",
                          "updatedAt": "2023-12-11T23:54:06Z",
                          "publishedAt": "2021-03-18T15:07:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Linear decomposition of displacement field in computational homogenization",
          "author": {
            "login": "tairoon1"
          },
          "bodyText": "Hi everyone,\nIn first-order computational homogenization, the displacement is typically decomposed into a mean field u_bar and a fluctuation field w(X), i.e.\nu(X) = u_bar(X) + w(X).\nu_bar is actually fully defined everywhere on the domain with u_bar = (F_bar-I) X, where F_bar is given and I is the identity matrix, and w(X) is periodic on the boundaries. So, one is interested in finding the fluctuation field w(X).\nIs it possible to do that inside TensorMechanics module and if yes, how would one write the Input file to do that?\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/17369",
          "updatedAt": "2022-06-11T17:11:58Z",
          "publishedAt": "2021-03-18T11:24:08Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @tairoon1\nI don't think such homogenisation method is already implemented in moose,\nbut it can definitely be implemented by solving for two independent variables u and w.\nSomething similar has been done in this repository:\nhttps://github.com/lanl/tardigrade-micromorphic-element\nBest Regards,\nNicol\u00f2 Grilli",
                  "url": "https://github.com/idaholab/moose/discussions/17369#discussioncomment-498230",
                  "updatedAt": "2022-06-11T17:11:58Z",
                  "publishedAt": "2021-03-18T13:20:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tairoon1"
                          },
                          "bodyText": "Dear Nicol\u00f2,\nThanks for your quick reply. So does that mean, it is not yet possible to use MOOSE for such application? Are there any plans to support such a feature in the future?\nBest regards",
                          "url": "https://github.com/idaholab/moose/discussions/17369#discussioncomment-498758",
                          "updatedAt": "2022-06-11T17:12:19Z",
                          "publishedAt": "2021-03-18T14:40:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Output elastic energy",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Hello MOOSE users,\nIn the poly_grain_growth_2D_eldrforce.i input file, how to add a sub-module in the Auxkernel module to make the output cloud image file (*.e) show elastic energy?\nAnd, the kernel responsible for elastic energy used in this input file is ACGrGrElasticDrivingForce, and the Residual is calculated as follows\uff0c\n    case Residual: return 0.5 * D_stress.doubleContraction(strain); // Compute the deformation energy driving force\nVery grateful for help!\nBest Regards\nWei Peng",
          "url": "https://github.com/idaholab/moose/discussions/17330",
          "updatedAt": "2022-06-09T08:21:46Z",
          "publishedAt": "2021-03-16T14:33:47Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "Perhaps you could add an ElasticEnergyMaterial (documentation). From there you could output the material property directly to the exodus file by setting outputs = exodus in the ElasticEnergyMaterial block, or you could use an AuxKernel like MaterialRealAux (documentation) to sample the elastic energy material.",
                  "url": "https://github.com/idaholab/moose/discussions/17330#discussioncomment-489131",
                  "updatedAt": "2022-06-17T15:27:18Z",
                  "publishedAt": "2021-03-16T14:56:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Thank you for your answer, The problem has been solved.\nI added sub-blocks to the materals block, the code is as follows,\n[./elasticenergy] type = GGElasticEnergyMaterial args = 'gr1 gr2' outputs = exodus [../]\nAfter that, F is displayed in the *.e file, which represents elastic energy.\nThanks again for your help.\nWei Peng",
                          "url": "https://github.com/idaholab/moose/discussions/17330#discussioncomment-496423",
                          "updatedAt": "2022-06-17T15:27:18Z",
                          "publishedAt": "2021-03-18T01:36:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}