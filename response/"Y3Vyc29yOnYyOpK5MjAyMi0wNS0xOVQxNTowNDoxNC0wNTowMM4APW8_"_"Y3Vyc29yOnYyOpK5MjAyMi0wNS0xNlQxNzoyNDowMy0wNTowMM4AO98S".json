{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNS0xNlQxNzoyNDowMy0wNTowMM4AO98S"
    },
    "edges": [
      {
        "node": {
          "title": "installation error",
          "author": {
            "login": "leoving"
          },
          "bodyText": "after installing the conda, and type ./run_tests -j 4\nthere occured the error as following:\nRan 1807 tests in 967.7 seconds. Average test time 0.4 seconds, maximum test time 8.5 seconds.\n1757 passed, 85 skipped, 0 pending, 50 FAILED\nMAX FAILURES REACHED\nrunWorker Exception: Traceback (most recent call last):\n  File \"/home/dell/projects/moose-next/python/TestHarness/schedulers/Scheduler.py\", line 438, in runJob\n    self.queueJobs(jobs, j_lock)\n  File \"/home/dell/projects/moose-next/python/TestHarness/schedulers/Scheduler.py\", line 260, in queueJobs\n    self.run_pool.apply_async(self.runJob, (job, jobs, j_lock))\n  File \"/home/dell/miniconda3/envs/moose/lib/python3.9/multiprocessing/pool.py\", line 455, in apply_async\n    self._check_running()\n  File \"/home/dell/miniconda3/envs/moose/lib/python3.9/multiprocessing/pool.py\", line 350, in _check_running\n    raise ValueError(\"Pool not running\")\nValueError: Pool not running\n\nHOW can I solved\n\n that?",
          "url": "https://github.com/idaholab/moose/discussions/21053",
          "updatedAt": "2022-06-09T01:38:10Z",
          "publishedAt": "2022-05-19T04:38:25Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat are the errors you are getting? Like for each failing test what is the error message? The summary does not give enough information.\nUsually such high test failure rates are an issue with MPI.\nGuillaume\nbtw: please do not paste screenshots. They are not searchable later on.\nPosting guidelines are here: #18270",
                  "url": "https://github.com/idaholab/moose/discussions/21053#discussioncomment-2786074",
                  "updatedAt": "2022-05-19T19:29:09Z",
                  "publishedAt": "2022-05-19T19:29:08Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Postprocessors for values at single named node?",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "I have an input mesh with some nodes I'd like to sample the solution at. The mesh contains separate nodesets for each of those nodes (each nodeset contains exactly one node).\nI thought I could do a boundary-restricted Postprocessor but construct_side_list_from_node_list doesn't seem to work for single-node nodesets. The MOOSE Postprocessors that operate at node take the node id, which I don't necessarily know. I'd like to use the nodeset name instead.\nAny ideas how to handle this? Could I make a new Postprocessor that accepts a nodeset name? Is there an example of that anywhere?",
          "url": "https://github.com/idaholab/moose/discussions/21047",
          "updatedAt": "2022-05-19T14:47:25Z",
          "publishedAt": "2022-05-18T16:36:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Can you try the point value sampler?",
                  "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2778050",
                  "updatedAt": "2022-05-18T17:49:16Z",
                  "publishedAt": "2022-05-18T17:49:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "That takes the coordinates of the point which, like the node id, I may not know. I want to use the name of the nodeset.",
                          "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2778271",
                          "updatedAt": "2022-05-18T18:22:46Z",
                          "publishedAt": "2022-05-18T18:22:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "To give you a bit more information, what I'm doing is generating arbitrary meshes with another program and reading them into MOOSE. The meshes are coming in with the nodes labelled (\"node1\", \"node2\", etc) where I'd like to evaluate the solution. The labels are actually on the single-node-containing nodesets.",
                          "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2778311",
                          "updatedAt": "2022-05-18T18:27:42Z",
                          "publishedAt": "2022-05-18T18:27:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh ok my bad. i think NodalValueSampler will work, with a boundary parameter that is the nodeset\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/NodalValueSampler.html",
                          "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2778978",
                          "updatedAt": "2022-05-18T20:16:49Z",
                          "publishedAt": "2022-05-18T20:16:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if it doesnt work we can try this one too\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/SideValueSampler.html\nbut side should be a sideset not a nodeset. Let's see",
                          "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2778985",
                          "updatedAt": "2022-05-18T20:18:02Z",
                          "publishedAt": "2022-05-18T20:18:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "OK, those work. Also AverageNodalVariableValue with boundary=<nodeset name> works. Guess I was confused between nodeset, sideset, and boundary. Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/21047#discussioncomment-2784118",
                          "updatedAt": "2022-05-19T15:07:38Z",
                          "publishedAt": "2022-05-19T14:28:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Tensor mechanics hardening documents",
          "author": {
            "login": "dineshp1"
          },
          "bodyText": "Hi\nI am interested in the different hardening schemes implemented in the module. The module is not documented yet so could you please provide some reference documents for hardening schemes?\nThank you,\nRegards,\nDinesh P",
          "url": "https://github.com/idaholab/moose/discussions/21022",
          "updatedAt": "2022-06-10T13:15:25Z",
          "publishedAt": "2022-05-13T00:37:07Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe module is actually documented. Please see these pages for the base documentation:\nhttps://mooseframework.inl.gov/modules/tensor_mechanics/index.html\nAnd a few hardening related pages:\nhttps://mooseframework.inl.gov/source/materials/IsotropicPlasticityStressUpdate.html\nhttps://mooseframework.inl.gov/source/materials/IsotropicPowerLawHardeningStressUpdate.html\nWhat kind of hardening are you looking for?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21022#discussioncomment-2746531",
                  "updatedAt": "2022-06-10T13:15:39Z",
                  "publishedAt": "2022-05-13T15:45:23Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dineshp1"
                          },
                          "bodyText": "Thank you for the reply. I want to apply linear softening like this:\n\nI found some hardening class implementation(TensorMechanicsHardeningCutExponential) and I can create linear softening now. Although I have a question, what is the internal parameter here? is it strain or something else?\nTensorMechanicsHardeningCutExponential::TensorMechanicsHardeningCutExponential(\n    const InputParameters & parameters)\n  : TensorMechanicsHardeningModel(parameters),\n    _val_0(getParam<Real>(\"value_0\")),\n    _val_res(parameters.isParamValid(\"value_residual\") ? getParam<Real>(\"value_residual\") : _val_0),\n    _intnl_0(getParam<Real>(\"internal_0\")),\n    _rate(getParam<Real>(\"rate\"))\n{\n}\n\nReal\nTensorMechanicsHardeningCutExponential::value(Real intnl) const\n{\n  Real x = intnl - _intnl_0;\n  if (x <= 0)\n    return _val_0;\n  else\n    return _val_res + (_val_0 - _val_res) * std::exp(-_rate * x);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/21022#discussioncomment-2764248",
                          "updatedAt": "2022-06-10T13:15:48Z",
                          "publishedAt": "2022-05-17T03:07:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "The internal parameter depends on your plastic model.  In your case it will be \"Plastic shear strain\".  Your plastic model (eg, J2, Mohr-Coulomb, etc) must define what \"Plastic shear strain\" actually is.  If you search through the TensorMechanics test cases you'll find many examples of softening and hardening.  Depending on your model, you may find the piecewise linear function that you are proposing leads to convergence problems due to the non-differentiability (unless you use an explicit time-stepping).  I have attached some documentation - not sure whether it's really what you want\nMOOSE Framework - Hardening and Softening.pdf\nMOOSE Framework - Plasticity and the Return-Mapping Algorithm.pdf\nMOOSE Framework - Plasticity and the Consistent Tangent Operator.pdf",
                          "url": "https://github.com/idaholab/moose/discussions/21022#discussioncomment-2764321",
                          "updatedAt": "2022-06-10T13:16:48Z",
                          "publishedAt": "2022-05-17T03:28:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dineshp1"
                          },
                          "bodyText": "@WilkAndy Thank you so much for the reference docs and for explaining issues with the sharp corner in softening function.",
                          "url": "https://github.com/idaholab/moose/discussions/21022#discussioncomment-2780003",
                          "updatedAt": "2022-05-19T01:01:32Z",
                          "publishedAt": "2022-05-19T01:01:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Implementation of Body Force in Peridynamics Module for Dynamic Fracture Modelling",
          "author": {
            "login": "ppandit95"
          },
          "bodyText": "Dear MOOSE Community\nI wish to simulate Dynamic Fracture for which constant stress needs to be applied on top and bottom of the domain but I am not sure how to implement that in MOOSE so any header in this regard will be beneficial.\nMany Thanks\nPushkar",
          "url": "https://github.com/idaholab/moose/discussions/19974",
          "updatedAt": "2022-07-14T20:12:33Z",
          "publishedAt": "2022-01-07T04:22:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc on peridynamics",
                  "url": "https://github.com/idaholab/moose/discussions/19974#discussioncomment-2093521",
                  "updatedAt": "2022-07-14T20:12:53Z",
                  "publishedAt": "2022-02-02T05:22:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@ppandit95 how's the status on this?",
                          "url": "https://github.com/idaholab/moose/discussions/19974#discussioncomment-2754403",
                          "updatedAt": "2022-07-14T20:12:56Z",
                          "publishedAt": "2022-05-15T14:57:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ppandit95"
                          },
                          "bodyText": "@GiudGiud I wanted to work on this but haven't got enough opportunity to look into it due to certain priorities and still I am not certain how this can be done by adding body force although I have looked into Body Force kernel but I guess it does not work with peridynamics module regarding which I may be wrong and in such a case it will be really helpful to get some leads in this regard.\nThanks\nPushkar",
                          "url": "https://github.com/idaholab/moose/discussions/19974#discussioncomment-2772493",
                          "updatedAt": "2022-07-14T20:12:56Z",
                          "publishedAt": "2022-05-18T04:46:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nSo you want to apply load on the surfaces right? For this it wont be a body force kernel, most likely it will be a boundary condition.\nI would go through the tensor mechanics tutorial, I think we have something very similar there, possibly only one side for the application of the force.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/19974#discussioncomment-2777089",
                          "updatedAt": "2022-05-18T15:46:00Z",
                          "publishedAt": "2022-05-18T15:46:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Specific time steps' output",
          "author": {
            "login": "hokonkim"
          },
          "bodyText": "Hello, I have a question about output.\nI set the syntax for output like below.\n[Outputs]\n  exodus = true\n  [csv]\n    type = CSV\n    file_base = outputs/cathode_test\n    append_date = true\n    append_date_format = '%Y-%m-%d-%R-%S'\n  []\n  [exodus1]\n    type = Exodus\n    file_base = outputs/cathode_test1\n    append_date = true\n    append_date_format = '%Y-%m-%d-%R-%S'\n    start_time = 0\n    interval = 100\n    execute_on = 'timestep_end'\n  []\n[]\n\nFor example, this simulation give me results from time = -1 to time = 491.\nWhat I want to do is \"output the results at specific time (time = 0, 100, 200, 300, 400, 491(last time step)).\nPlus, currently always all output result file was generated as well. This is too big, so I don't want this to be generated.\nHow can I get this specific output file without generating the file including all results.\nThank you.\nBest regards,\nHokon Kim",
          "url": "https://github.com/idaholab/moose/discussions/21043",
          "updatedAt": "2022-06-11T06:51:00Z",
          "publishedAt": "2022-05-17T16:19:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou should use the interval parameter of the output. And set it to 100\nThen you also want to execute on final to catch this 491 timestep\nsee these docs, there's an example in the Multiple Output Blocks paragraph or in Common parameters\nhttps://mooseframework.inl.gov/syntax/Outputs/index.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2770790",
                  "updatedAt": "2022-06-11T06:51:02Z",
                  "publishedAt": "2022-05-17T20:44:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "actually it seems you are already using this parameter.\nWhat are you seeing? THe interval is not respected?",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2770802",
                          "updatedAt": "2022-06-11T06:51:02Z",
                          "publishedAt": "2022-05-17T20:46:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "time = 99, 199, 299, 399\nOnly four time steps are stored in the result output(*.e).\nI thought I could get the results when time = 0, 100, 200, 300, 400, ...",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2770834",
                          "updatedAt": "2022-06-11T06:51:02Z",
                          "publishedAt": "2022-05-17T20:53:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you want to offset it by one you should move the start_time of the output.\nYeah adding on final might be tricky with the current capability. I hope execute_on = 'timestep_end final' will do it but I suspect the interval is obeyed first and foremost",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2770907",
                          "updatedAt": "2022-06-11T06:51:02Z",
                          "publishedAt": "2022-05-17T21:09:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "I still don't get it about Output options.\nOptions doesn't work as I wanted.\n[Outputs]\n  [csv]\n    type = CSV\n    file_base = outputs/cathode_test\n    append_date = true\n    append_date_format = '%Y-%m-%d-%R-%S'\n    execute_on = 'initial timestep_end'\n  []\n  [exo]\n    type = Exodus\n    file_base = outputs/cathode_test1\n    append_date = true\n    append_date_format = '%Y-%m-%d-%R-%S'\n    start_time = 0\n    interval = 5\n  []\n[]\n\nI expected that time = 0, 5, 10, ..., but the result really I got was \"time = 4, 9, 14\".\nI think the interval option did not work properly as I wanted.\nI thought \"start_time + interval\", but actually it didn't work like this.\n(e.g, start_time = 1, interval = 3, then 1, 4, 7, 10, ..., but it is not...)\nInterval just printed out the result at \"N\"th time step whatever start_time is...",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2771265",
                          "updatedAt": "2022-06-11T06:51:05Z",
                          "publishedAt": "2022-05-17T22:31:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Yeah, I think the interval param just outputs every n steps, not every n time units. Having output every n time units would be a welcome addition. In the past, I've had to use sync_times and provide a list of times, which can be tedious!",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2771901",
                          "updatedAt": "2022-06-11T06:51:07Z",
                          "publishedAt": "2022-05-18T01:40:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hokonkim"
                          },
                          "bodyText": "I think sync_times is the proper way for my results file, currently.\nThanks for your reply!",
                          "url": "https://github.com/idaholab/moose/discussions/21043#discussioncomment-2772290",
                          "updatedAt": "2022-06-11T06:51:07Z",
                          "publishedAt": "2022-05-18T03:55:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Treatment of templated classes: Generic vs Explicit type specification",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Dear Moose experts,\nAs part of my recent developments on ArrayAuxKernels i am trying to write the list of AuxKernel values on to the auxvariables through the setNodalValue function. One common thing i observed while implementing this function is that the templated class functions are executed both for the case of explict specification of the desired type (RealEigenVector) and for the generic type (OutputType). As a result i could not confine my developments to a single function relevant to my type. The following example will make this case clear.\nCase 1:\ntemplate <>\nvoid\nMooseVariableData<RealEigenVector>::computeValues()\n{\n\ncase 2:\ntemplate <typename OutputType>\nvoid\nMooseVariableData<OutputType>::computeValues()\n{\n\nI expect any calls pertaining to ArrayAuxKernel would go to case 1 rather than case 2. Execution of both these cases can sometimes lead to overwrite of data set by each of these functions and is generally not advisable. My question is how to restrict calls to only case 1 where the type is specified explicity inside <>.",
          "url": "https://github.com/idaholab/moose/discussions/21033",
          "updatedAt": "2022-08-05T18:05:03Z",
          "publishedAt": "2022-05-16T17:54:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "abarun22"
                  },
                  "bodyText": "Another related question is that the following code would not compile throwing the below error.\ntemplate <>\nvoid\nMooseVariableData<RealEigenVector>::setNodalValue(const RealEigenVector & value, unsigned int idx)\n{\n      _has_dof_values = true;\n      _nodal_value = value;\n      for (unsigned int i = 0; i < _u.size(); i++)\n       _u[i] = value(i);\n}\n\nError:\n/home/abalasub/Working/Projects/moose/framework/src/variables/MooseVariableData.C: In member function \u2018void MooseVariableData<OutputType>::setNodalValue(const OutputType&, unsigned int) [with OutputType = Eigen::Matrix<double, -1, 1>]\u2019:\n/home/abalasub/Working/Projects/moose/framework/src/variables/MooseVariableData.C:1620:26: error: no match for \u2018operator=\u2019 (operand types are \u2018Eigen::Matrix<double, -1, 1>\u2019 and \u2018const double\u2019)\n         _u[qp] = value(qp);\n\nThe variable _u is defined in MooseVariableData.h as follows\nFieldVariableValue _u;\nAs can be seen from the compile log the type of RHS variable is evalated wrongly and hence the error. I am sure the explicit declaration of the type of value will certainly resolve this to Eigen::Matrix<double, -1, 1>, but in this case it only sees a const double. The following is the prototype declation in MooseVariableData.h.\ntemplate <typename OutputType>\nclass MooseVariableData\n{\nvoid setNodalValue(const OutputType & value, unsigned int idx = 0);\n\nAny idea what's going on here?\nKind regards,\nArun",
                  "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2761929",
                  "updatedAt": "2022-08-05T18:06:49Z",
                  "publishedAt": "2022-05-16T18:17:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think you want to instantiate this template to RealVectorValue RealEigenVector\nSo OutputType becomes RealVectorValue RealEigenVector.\nSee GenericConstantMaterial for example.\nThe whole class is defined with the parameter is_ad, then it's instantiated to true and false.\nWe want to do the same here, but with OutputType being replaced by RealVectorValue RealEigenVector.\nWhat's going on with your error is that in\n_u[i] = value(i);\nthe quantites on both sides have different types.\nvalue(i) is a single value, because value is a vector\n_u is a tensor material property [i] I believe should be _qp (indexing at quadrature point then into a row/column (I have not checked) )\nPlease look at the documentation for Eigen::Matrix to determine the appropriate indexing into _u[_qp]\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2762162",
                  "updatedAt": "2022-06-09T01:32:21Z",
                  "publishedAt": "2022-05-16T18:54:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Hi Guillaume,\nI think RealVectorValue is the relevant type to be used for this class template. On the question of preferrential execution, i wanted to ask if the templated class is not instantiated for a particular type, but a function has been defined for this type, will that function be executed? Consider the folowing case.\ntemplate <>\nvoid\nMooseVariableData<RealEigenVector>::setNodalValue(const RealEigenVector & value, unsigned int idx)\n{\n\nAnd i comment out this line in the end:\n//template class MooseVariableData<RealEigenVector>;\nWhen i checked this, the function is still executed, which seems quiet weird, as only the explicitly instantiated classes will be called.\nKind regards,\nArun",
                          "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2769050",
                          "updatedAt": "2022-11-18T08:03:56Z",
                          "publishedAt": "2022-05-17T16:12:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abarun22"
                  },
                  "bodyText": "I am working towards replacing the RealEigenVector type with RealVectorValue in all of my array auxkernel developments. After doing this  migration, i encountered this weird error when it reaches the last line in the below code\nArrayRankTwoAux.C:46:9: error: \u2018libMesh::RealVectorValue {aka class libMesh::VectorValue<double>}\u2019 has no member named \u2018resize\u2019; did you mean \u2018rebind\u2019?\n   evalm.resize(teval*_nsubvar);\n\ntemplate <bool is_ad>\nRealVectorValue\nArrayRankTwoAuxTempl<is_ad>::computeValue()\n{\n  auto nqpts=this->_qrule->n_points();\n  RealVectorValue  evalm;\n  std::vector<std::pair<unsigned int, unsigned int>> tindices = {{0,0},{1,1},{2,2},{0,1},{0,2},{1,2}};\n  auto teval = nqpts*tindices.size();\n  evalm.resize(teval*_nsubvar);\n\nSomehow the compiler is interpreting this type wrongly and look for resize inside a class that is mapped to RealVectorValue. Any suggestions/leads here?\nKind regards,\nArun",
                  "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2769619",
                  "updatedAt": "2022-11-18T08:03:56Z",
                  "publishedAt": "2022-05-17T17:29:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@abarun22\nNo I was wrong, it's RealEigenVector you want not RealVectorValue. The latter is fixed 3 size",
                          "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2770461",
                          "updatedAt": "2022-11-18T08:03:57Z",
                          "publishedAt": "2022-05-17T19:44:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I was trying to make a point about the template instantiation, did not think I was mentioning the wrong type",
                          "url": "https://github.com/idaholab/moose/discussions/21033#discussioncomment-2770468",
                          "updatedAt": "2022-11-18T08:03:58Z",
                          "publishedAt": "2022-05-17T19:45:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using X,Y,Z,Variable csv data to define elemental variables using PiecewiseConstantFromCSV",
          "author": {
            "login": "Edward-Eth"
          },
          "bodyText": "I have a csv file of a value (T) as a function of x,y,z in a csv file, and was hoping to use the new PiecewiseConstantFromCSV to read that in such that each element is assigned an elemental value of T from the closest point defined in the csv file. At the moment this is working, except that it is assigning the variable to nodes instead of elements. Is there anyway to force an elemental value while using the nearest style reader?",
          "url": "https://github.com/idaholab/moose/discussions/21037",
          "updatedAt": "2022-07-14T13:53:49Z",
          "publishedAt": "2022-05-17T09:04:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Edward-Eth"
                  },
                  "bodyText": "Never-mind, figured it out. By making the variable an auxiliary variable and setting order = constant and family = monomial you can enforce elemental values from a nearest neighbour/voronoi reader. Not sure this is the best method available but it seems to work for me.",
                  "url": "https://github.com/idaholab/moose/discussions/21037#discussioncomment-2766129",
                  "updatedAt": "2022-07-14T13:53:50Z",
                  "publishedAt": "2022-05-17T09:14:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nyes that's the way",
                          "url": "https://github.com/idaholab/moose/discussions/21037#discussioncomment-2768279",
                          "updatedAt": "2022-07-14T13:54:07Z",
                          "publishedAt": "2022-05-17T14:31:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Edward-Eth"
                          },
                          "bodyText": "Cool, thanks for the confirmation.",
                          "url": "https://github.com/idaholab/moose/discussions/21037#discussioncomment-2768388",
                          "updatedAt": "2022-07-14T13:54:07Z",
                          "publishedAt": "2022-05-17T14:45:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Custom material to compute thermal expansion with a variable thermal expansion coefficient.",
          "author": {
            "login": "Edward-Eth"
          },
          "bodyText": "Previously I had a custom material which allowed for me to pass thermal expansion as a material property name instead of a real, allowing for varying thermal expansion coefficients, however I recently updated MOOSE to get access to a new feature, and the ComputeThermalExpansionEigenstrain material has been edited to use templates, which has broken my custom material and I can't figure out why my new version isn't working. I'm simply trying to edit the base ComputeThermalExpansionEigenstrain and change the type of the thermal_expansion_coeff to a MaterialPropertyName (and the calculation of the thermal strain to take this into account). When I try to build I get the error:\nComputeVariableThermalExpansionEigenstrain.C:22:81: error: use of undeclared identifier 'getParam' _thermal_expansion_coeff(this->template declareGenericProperty<Real, is_ad>(getParam<MaterialPropertyName>(\"thermal_expansion_coeff\")))\nThe code is:\nComputeVariableThermalExpansionEigenstrain.C:\n#include \"ComputeVariableThermalExpansionEigenstrain.h\"\n\nregisterMooseObject(\"TensorMechanicsApp\", ComputeVariableThermalExpansionEigenstrain);\nregisterMooseObject(\"TensorMechanicsApp\", ADComputeVariableThermalExpansionEigenstrain);\n\ntemplate <bool is_ad>\nInputParameters\nComputeVariableThermalExpansionEigenstrainTempl<is_ad>::validParams()\n{\n  InputParameters params = ComputeThermalExpansionEigenstrainBaseTempl<is_ad>::validParams();\n  params.addClassDescription(\"Computes eigenstrain due to thermal expansion \"\n                             \"with a constant coefficient\");\n  params.addRequiredParam<MaterialPropertyName>(\"thermal_expansion_coeff\", \"Thermal expansion coefficient material property\");\n\n  return params;\n}\n\ntemplate <bool is_ad>\nComputeVariableThermalExpansionEigenstrainTempl<is_ad>::ComputeVariableThermalExpansionEigenstrainTempl(\n    const InputParameters & parameters)\n  : ComputeThermalExpansionEigenstrainBaseTempl<is_ad>(parameters),\n    _thermal_expansion_coeff(this->template declareGenericProperty<Real, is_ad>(getParam<MaterialPropertyName>(\"thermal_expansion_coeff\")))\n{\n}\n\ntemplate <bool is_ad>\nValueAndDerivative<is_ad>\nComputeVariableThermalExpansionEigenstrainTempl<is_ad>::computeThermalStrain()\n{\n  return _thermal_expansion_coeff[_qp] * (_temperature[_qp] - _stress_free_temperature[_qp]);\n}\n\ntemplate class ComputeVariableThermalExpansionEigenstrainTempl<false>;\ntemplate class ComputeVariableThermalExpansionEigenstrainTempl<true>;\n\nComputeVariableThermalExpansionEigenstrain.h:\n#pragma once\n\n#include \"ComputeThermalExpansionEigenstrainBase.h\"\n\n/**\n * ComputeThermalExpansionEigenstrain computes an eigenstrain for thermal expansion\n * with a constant expansion coefficient.\n */\ntemplate <bool is_ad>\nclass ComputeVariableThermalExpansionEigenstrainTempl\n  : public ComputeThermalExpansionEigenstrainBaseTempl<is_ad>\n{\npublic:\n  static InputParameters validParams();\n\n  ComputeVariableThermalExpansionEigenstrainTempl(const InputParameters & parameters);\n\nprotected:\n  virtual ValueAndDerivative<is_ad> computeThermalStrain() override;\n\n  GenericMaterialProperty<Real, is_ad> & _thermal_expansion_coeff;\n\n  using ComputeThermalExpansionEigenstrainBaseTempl<is_ad>::_qp;\n  using ComputeThermalExpansionEigenstrainBaseTempl<is_ad>::_temperature;\n  using ComputeThermalExpansionEigenstrainBaseTempl<is_ad>::_stress_free_temperature;\n};\n\ntypedef ComputeVariableThermalExpansionEigenstrainTempl<false> ComputeVariableThermalExpansionEigenstrain;\ntypedef ComputeVariableThermalExpansionEigenstrainTempl<true> ADComputeVariableThermalExpansionEigenstrain;",
          "url": "https://github.com/idaholab/moose/discussions/21039",
          "updatedAt": "2022-06-08T09:07:17Z",
          "publishedAt": "2022-05-17T11:21:08Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Edward-Eth"
                  },
                  "bodyText": "For the second time today I've figured out my problem not long after asking for help, I now have this working.\nThe issue was on the line:\n _thermal_expansion_coeff(this->template declareGenericProperty<Real, is_ad>(getParam<MaterialPropertyName>(\"thermal_expansion_coeff\")))\nI had based this on code from CoupledValueFunctionMaterial, specifically the line:\n_prop(declareGenericProperty<Real, is_ad>(getParam<MaterialPropertyName>(\"prop_name\")))\nBy instead copying from ComputeEigenstrain:\n_prefactor(this->template getGenericMaterialProperty<Real, is_ad>(\"prefactor\"))\nAnd changing the line to:\n_thermal_expansion_coeff(this->template getGenericMaterialProperty<Real, is_ad>(\"thermal_expansion_coeff\"))\nit is working.",
                  "url": "https://github.com/idaholab/moose/discussions/21039#discussioncomment-2767830",
                  "updatedAt": "2022-06-08T09:07:37Z",
                  "publishedAt": "2022-05-17T13:39:53Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Parsed Material for tensor properties",
          "author": {
            "login": "lekah"
          },
          "bodyText": "Hi,\nmy application requires something like ParsedMaterial but to initialize a tensor from arguments and other material properties (each component individually). I could not find such functionality in the code, but since this is maybe a common problem someone has already coded this up? Or I overlooked something?\nCheers",
          "url": "https://github.com/idaholab/moose/discussions/20273",
          "updatedAt": "2022-06-03T11:03:15Z",
          "publishedAt": "2022-02-10T10:36:32Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dschwen have you heard of a ParsedTensorMaterial out there?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20273#discussioncomment-2151215",
                  "updatedAt": "2022-06-03T11:03:15Z",
                  "publishedAt": "2022-02-10T16:48:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lekah"
                          },
                          "bodyText": "That sounds like exactly what I need :)",
                          "url": "https://github.com/idaholab/moose/discussions/20273#discussioncomment-2155860",
                          "updatedAt": "2022-06-03T11:03:35Z",
                          "publishedAt": "2022-02-11T09:09:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont think we have it.\n@lekah you still needing this?\nOther solution is to simply code a regular tensor material, there are a few examples in the codebase.",
                          "url": "https://github.com/idaholab/moose/discussions/20273#discussioncomment-2754410",
                          "updatedAt": "2022-06-03T11:03:36Z",
                          "publishedAt": "2022-05-15T14:58:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lekah"
                          },
                          "bodyText": "Hi @GiudGiud ,\nA regular tensor material would not have the dependencies on arguments of each component, right?\nI've found a workaround for my usecase by adding different tensors together, with variable-dependent weights, aka. CompositeTensor.\nBut a ParsedTensorMaterial would be a nice functionality and still useful to me.",
                          "url": "https://github.com/idaholab/moose/discussions/20273#discussioncomment-2757663",
                          "updatedAt": "2022-06-03T11:03:35Z",
                          "publishedAt": "2022-05-16T08:26:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nWell you can definitely create a new object in the source code and have any dependencies you want. I guess it's not clear what I meant by \"regular\"\nI ll see if i can create one in the near future, I ll let you know here if I have time\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/20273#discussioncomment-2760206",
                          "updatedAt": "2022-06-03T11:04:17Z",
                          "publishedAt": "2022-05-16T14:25:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lekah"
                          },
                          "bodyText": "Thanks Guillaume,\nI was thinking of writing it up, but I didn't find the time as well. It would also take me some time to understand and design how to interface with ParsedFunctions etc... (fairly new to MOOSE). And the workaround with the CompositeTensor is sufficient for my usecase, but not elegant. For newbie-users however, I think it would be a nice functionality.",
                          "url": "https://github.com/idaholab/moose/discussions/20273#discussioncomment-2765029",
                          "updatedAt": "2022-06-03T11:04:15Z",
                          "publishedAt": "2022-05-17T06:34:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Oscillations in INS velocity field",
          "author": {
            "login": "ABallisat"
          },
          "bodyText": "Hello all,\nI am using the FE implementation of the Navier Stokes module with two phase flows, using the Level Set method for interface tracking. I am having some issues with oscillations in the vertical component of the velocity field, see image below. The scenario for this test is just steady state with a less dense fluid sat above a denser fluid. All boundaries except the top are no-penetration (so v dot n = 0 on the boundaries of the mesh) and the pressure on the top boundary is fixed to zero (it also displays the same behaviour without applying it). I am using first order elements for all variables and running with PSPG and SUPG. This scenario is just testing that it produces a stable result, I would expect the velocities to tend to zero but instead these variations are observed and over time their magnitude increases until it will no longer solve.\nAm I missing something obvious?\nThanks,\nAlex",
          "url": "https://github.com/idaholab/moose/discussions/20499",
          "updatedAt": "2022-06-14T19:03:47Z",
          "publishedAt": "2022-03-08T17:17:15Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@lindsayad who can we tag on level set?",
                  "url": "https://github.com/idaholab/moose/discussions/20499#discussioncomment-2319886",
                  "updatedAt": "2022-06-14T19:04:19Z",
                  "publishedAt": "2022-03-08T22:16:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@aeslaughter \ud83d\ude04 I don't think any of our current team members have done much development in that module",
                          "url": "https://github.com/idaholab/moose/discussions/20499#discussioncomment-2320035",
                          "updatedAt": "2022-06-14T19:04:22Z",
                          "publishedAt": "2022-03-08T22:44:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@ABallisat how do things look if you make the two phases the same? (densities, etc.)",
                          "url": "https://github.com/idaholab/moose/discussions/20499#discussioncomment-2320037",
                          "updatedAt": "2022-06-14T19:04:22Z",
                          "publishedAt": "2022-03-08T22:44:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "Same densities work to what I take is numerical error:\n\nIn the original post, the densities ratio was O(1:1000), I also tried O(1:4) (not shown) which also displays similar oscillatory behaviour so I guess it comes down to the densities. Based on that, is the FE INS implementation designed to work with variable density?",
                          "url": "https://github.com/idaholab/moose/discussions/20499#discussioncomment-2322898",
                          "updatedAt": "2022-06-14T19:04:30Z",
                          "publishedAt": "2022-03-09T10:09:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Both convection and time derivative terms (in MOOSE's INS kernels in navier_stokes) assume that the density can be pulled outside the differential operator (d/dt and div respectively) which reflects an assumption of constant density.\nAre you creating your own level set kernels, or are you using the level_set module?",
                          "url": "https://github.com/idaholab/moose/discussions/20499#discussioncomment-2326098",
                          "updatedAt": "2022-06-14T19:04:35Z",
                          "publishedAt": "2022-03-09T18:07:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "I've had a good dig through the literature and there is a mix of formulations, some authors claim to use pulling out the density of the differential operators whilst others include them. At the moment I have not written kernels with them included in the differential operators but I think it would be sensible to see if this has an effect so I will attempt to implement this.\nAs for level set, I have been using the level_set module for propagation but given the reinitialisation implementation seems to not work at times, I have implemented a parallel fast marching implementation to do that bit.",
                          "url": "https://github.com/idaholab/moose/discussions/20499#discussioncomment-2330180",
                          "updatedAt": "2022-06-14T19:04:41Z",
                          "publishedAt": "2022-03-10T09:49:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@ABallisat any update on this?",
                          "url": "https://github.com/idaholab/moose/discussions/20499#discussioncomment-2504992",
                          "updatedAt": "2022-06-14T19:04:41Z",
                          "publishedAt": "2022-04-05T03:25:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "Apologies for just getting around to replying, I have been busy on other things recently. Long story short no, I had a good go at it but could never get it to converge. For now I have switched my attention to the finite volume implementation and seeing if that is any more suited to it. I played around with finite volume a long while ago but hit the caching problem so the memory usage was too high and it did not scale up. I have seen that that has now been fixed so will be interesting to see how much that has improved. I will report back on how I get on.",
                          "url": "https://github.com/idaholab/moose/discussions/20499#discussioncomment-2607563",
                          "updatedAt": "2022-06-14T19:04:41Z",
                          "publishedAt": "2022-04-21T09:26:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Sounds good.\nClosing this for now.\nWe'd be interested in an implementation of phase field in finite volume if you can do the conversion.\nDo we have a final conclusion on whether different densities are supported?",
                          "url": "https://github.com/idaholab/moose/discussions/20499#discussioncomment-2755194",
                          "updatedAt": "2022-06-14T19:04:42Z",
                          "publishedAt": "2022-05-15T19:46:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I said that the INS FE implementation assumes that density is constant such that you can pull it out of derivative terms, so any spatial or temporal derivatives related to density would have to be added by the user if they wanted to also use the INS FE kernels.\nThat being said, density in INS FE is a material property, so you could in theory \"use\" the INS FE objects with a non-constant density. It's just that omission of the additional derivative terms related to density would lead to an incorrect representation of the NS physics",
                          "url": "https://github.com/idaholab/moose/discussions/20499#discussioncomment-2763304",
                          "updatedAt": "2022-06-14T19:04:42Z",
                          "publishedAt": "2022-05-16T22:24:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}