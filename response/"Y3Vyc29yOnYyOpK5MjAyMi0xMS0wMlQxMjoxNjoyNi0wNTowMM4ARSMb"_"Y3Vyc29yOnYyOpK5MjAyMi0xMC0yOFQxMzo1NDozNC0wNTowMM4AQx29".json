{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMC0yOFQxMzo1NDozNC0wNTowMM4AQx29"
    },
    "edges": [
      {
        "node": {
          "title": "How to get the block ID of the current calculating element?",
          "author": {
            "login": "RECHOA"
          },
          "bodyText": "Hi all,\nI want to get the block id of the current calculating element in an Auxkernel   type or a Material  type , and then use the block id as an index of a vector.\nFor example, a type restricted by blocks as following:\n  [./test]\n    type = testType\n    block = ' 18 23 28 33 38 43 '\n  [../]\n\nI tried _current_elem->subdomain_id() but it's incorrect.",
          "url": "https://github.com/idaholab/moose/discussions/22543",
          "updatedAt": "2023-01-03T23:51:40Z",
          "publishedAt": "2022-10-31T12:52:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhy do you say it's incorrect?\nIt should be that\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22543#discussioncomment-4018542",
                  "updatedAt": "2022-10-31T13:08:05Z",
                  "publishedAt": "2022-10-31T13:08:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "RECHOA"
                          },
                          "bodyText": "in the source file, I writed\nelem_subdomain_id = _current_elem->subdomain_id();\nmooseError(elem_subdomain_id);\n\nand test the type object  restricted by block = ' 18 23 28 33 38 43 ' as mentioned before, but it outputs '46'.",
                          "url": "https://github.com/idaholab/moose/discussions/22543#discussioncomment-4018594",
                          "updatedAt": "2022-10-31T13:15:33Z",
                          "publishedAt": "2022-10-31T13:15:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you please paste your input file and which object you block restricted",
                          "url": "https://github.com/idaholab/moose/discussions/22543#discussioncomment-4018617",
                          "updatedAt": "2022-10-31T13:17:23Z",
                          "publishedAt": "2022-10-31T13:17:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RECHOA"
                          },
                          "bodyText": "the mesh and block id were generated by cubit not MOOSE, would it be the cause of the problem?",
                          "url": "https://github.com/idaholab/moose/discussions/22543#discussioncomment-4018672",
                          "updatedAt": "2022-10-31T13:22:20Z",
                          "publishedAt": "2022-10-31T13:22:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "that's unlikely to be the problem",
                          "url": "https://github.com/idaholab/moose/discussions/22543#discussioncomment-4018677",
                          "updatedAt": "2022-10-31T13:23:02Z",
                          "publishedAt": "2022-10-31T13:23:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RECHOA"
                          },
                          "bodyText": "ok I will check it again. If the problem wouldn't be solve, I'll  try to reproduce it in a simple way.",
                          "url": "https://github.com/idaholab/moose/discussions/22543#discussioncomment-4018734",
                          "updatedAt": "2022-10-31T13:28:09Z",
                          "publishedAt": "2022-10-31T13:28:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RECHOA"
                          },
                          "bodyText": "I notice that the mesh of these blocks (block = ' 18 23 28 33 38 43 ') are merged with block 46, which means they share a suface with block 46. so maybe when the calculting occurs in the shared suface, the element would be considered in block 46?",
                          "url": "https://github.com/idaholab/moose/discussions/22543#discussioncomment-4019386",
                          "updatedAt": "2022-10-31T14:39:03Z",
                          "publishedAt": "2022-10-31T14:39:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is this a material property or an auxkernel?\nComputing the neighbor material property might use the neighbor subdomain, I would have to check though",
                          "url": "https://github.com/idaholab/moose/discussions/22543#discussioncomment-4019408",
                          "updatedAt": "2022-10-31T14:41:06Z",
                          "publishedAt": "2022-10-31T14:41:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RECHOA"
                          },
                          "bodyText": "this is an auxkernel.",
                          "url": "https://github.com/idaholab/moose/discussions/22543#discussioncomment-4019423",
                          "updatedAt": "2022-10-31T14:42:13Z",
                          "publishedAt": "2022-10-31T14:42:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Then no it shouldnt happen.\nSomething is wrong with the block assignment or the block restriction.",
                          "url": "https://github.com/idaholab/moose/discussions/22543#discussioncomment-4019432",
                          "updatedAt": "2022-10-31T14:43:48Z",
                          "publishedAt": "2022-10-31T14:43:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RECHOA"
                          },
                          "bodyText": "I put a small case in https://github.com/RECHOA/Cases/tree/main/testblockID\nIn this case, the mesh of block 3 and block 8 was generated and merged together by using cubit,\n\nin the input file, the calculation is restricted in block 3 :\n[AuxKernels]\n  [./testid]\n    type = MooseErrorSubdomainID\n    variable = for_testid\n    block = '3 '\n  [../]\n[]\n\nand in the MooseErrorSubdomainID.C :\n  elem_subdomain_id = _current_elem->subdomain_id();\n\n  mooseWarning(\"here elem_subdomain_id \", elem_subdomain_id,\" .\");\n\nbut the result shows\nhere elem_subdomain_id 8 .",
                          "url": "https://github.com/idaholab/moose/discussions/22543#discussioncomment-4020075",
                          "updatedAt": "2022-10-31T15:45:00Z",
                          "publishedAt": "2022-10-31T15:45:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "compiling with PETSc 3.18",
          "author": {
            "login": "garciapintado"
          },
          "bodyText": "Hello,\nI'm trying to compile moose in a HPC cluster [single user] following:\nhttps://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html\nAnd I'm finding an error message with the indication:\n\nERROR***********\nError during compile, check arch-moose/lib/petsc/conf/make.log\nSend it and arch-moose/lib/petsc/conf/configure.log to\npetsc-maint@mcs.anl.gov\n\n\nWith this, the reponse I've got from a PETSc developer is:\n--\nDear Javier,\nThis has been fixed in later releases of PETSc.\nThe latest to date is version 3.18.1, could you try that instead?\nThanks,\nPierre\nBut on the other hand, I understand that MOOSE is sort of fixed to a specific PETSc version (3.16). Is this so? If not, please could you guide on how compile MOOSE with a more recent PETSc version?\nBest\nJavier\n...",
          "url": "https://github.com/idaholab/moose/discussions/22565",
          "updatedAt": "2022-11-15T19:32:13Z",
          "publishedAt": "2022-11-02T11:28:17Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "I would take a look at the script we use to configure PETSc: moose/scripts/configure_petsc.sh. This is the script that is called by another script, the script we tell everyone to run: update_and_rebuild_petsc.sh. Who's purpose is to obtain the PETSc source at a version we support. But I like the journey you're on, so lets continue!\nOf course I can't promise all of the same arguments will work with 3.18, but they probably will. Also, some tests my fail at this version. And in-turn may incorrectly solve problems. Which is why it's best to stick with an older stable (supported) version.\nThe gist of what you need to do:\n\nobtain PETSc 3.18 source\nExtract it (un-tar it)\nEnter the directory and run\npython ./configure --download-hypre=1 \\\n    --with-shared-libraries=1 \\\n    --download-hdf5=1 \\\n    --download-hdf5-fortran-bindings=0 \\\n    --with-make-np=6 \\\n    --with-debugging=no \\\n    --download-fblaslapack=1 \\\n    --download-metis=1 \\\n    --download-ptscotch=1 \\\n    --download-parmetis=1 \\\n    --download-superlu_dist=1 \\\n    --download-mumps=1 \\\n    --download-strumpack=1 \\\n    --download-scalapack=1 \\\n    --download-slepc=1 \\\n    --with-mpi=1 \\\n    --with-openmp=1 \\\n    --with-cxx-dialect=C++11 \\\n    --with-fortran-bindings=0 \\\n    --with-sowing=0 \\\n    --with-64-bit-indices \\\n    --prefix=/SOME/PATH/WHERE/YOU/WANT/TO/INSTALL\n\n\nObviously change that last bit, to where you plan on installing this version of PETSc. Whatever this path is, you will need to set export PETSC_DIR=<the path you used>, before attempting to build libMesh.\nI hope this works for you! You're exploring new territory \ud83d\ude03  Please let us know how it goes either way!",
                  "url": "https://github.com/idaholab/moose/discussions/22565#discussioncomment-4036605",
                  "updatedAt": "2022-11-02T12:52:47Z",
                  "publishedAt": "2022-11-02T12:49:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "I believe #22562 should satisfy this issue. While it says PETSc 3.8, I believe this update is for PETSc 3.18 compatibility.",
                  "url": "https://github.com/idaholab/moose/discussions/22565#discussioncomment-4037126",
                  "updatedAt": "2022-11-02T13:41:07Z",
                  "publishedAt": "2022-11-02T13:41:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "garciapintado"
                          },
                          "bodyText": "Ah! I see. Then it seems sensible for me to wait until #22562 is solved...",
                          "url": "https://github.com/idaholab/moose/discussions/22565#discussioncomment-4039943",
                          "updatedAt": "2022-11-02T16:48:04Z",
                          "publishedAt": "2022-11-02T16:48:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Questions about SideSetsFromNodeSetsGenerator",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nI am facing some issues with the SideSetsFromNodeSetsGenerator. We are trying to generate a sideset along a boundary of a model from some given input nodes. The model is 3D and contains also lower dimensional elements that are connected to the same boundary from which we are constructing the sides. The problem in itself is that the generated sideset also contains the elements from the lower dimensional material that we would like to exclude. Is there a way we can somehow blockwise the call of the meshgenerator to only specific blocks? Hope all makes sense, but in case I can replicate a simple model showing the issue we are facing.\nThanks for any feedback,\nmauro",
          "url": "https://github.com/idaholab/moose/discussions/22553",
          "updatedAt": "2022-11-01T14:25:16Z",
          "publishedAt": "2022-11-01T11:08:38Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNo there is no block restriction (or even nodeset restriction) currently implemented in SideSetsFromNodeSetsGenerator.\nI'd recommend to use:\nBreakBoundaryAlongBlocks\nhttps://mooseframework.inl.gov/source/meshgenerators/BreakBoundaryOnSubdomainGenerator.html\nor parsed expressions\nhttps://mooseframework.inl.gov/source/meshgenerators/ParsedGenerateSideset.html\nto fix up the sideset after the conversion from the nodeset\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22553#discussioncomment-4027543",
                  "updatedAt": "2022-11-01T13:24:58Z",
                  "publishedAt": "2022-11-01T13:24:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "Thanks @GiudGiud. The BreakBoundaryAlongBlocks might be the solution. Quick question on top, is there a meshgenerators that could merge back the boundaries? Thanks!",
                  "url": "https://github.com/idaholab/moose/discussions/22553#discussioncomment-4027883",
                  "updatedAt": "2022-11-01T14:08:54Z",
                  "publishedAt": "2022-11-01T14:08:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the RenameBoundaryGenerator may be used for merging\nhttps://mooseframework.inl.gov/source/meshgenerators/RenameBoundaryGenerator.html",
                          "url": "https://github.com/idaholab/moose/discussions/22553#discussioncomment-4027902",
                          "updatedAt": "2022-11-01T14:11:09Z",
                          "publishedAt": "2022-11-01T14:11:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "Excellent! That made the trick. Thanks again @GiudGiud",
                  "url": "https://github.com/idaholab/moose/discussions/22553#discussioncomment-4028010",
                  "updatedAt": "2022-11-01T14:24:50Z",
                  "publishedAt": "2022-11-01T14:24:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Inquiry about the flux in x direction",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nI was wondering if there is flux in x direction in 2D model. Since the model is 2D, the flux in x direction means the flux that passes through the y-z plane, however, there is no z axis in 2D model, Why is there still flux in x direction? Is my way of calculating the jx not right?\nThis is how I calculate flux in x direction:\n\n(Mobility=1 here)\nThe following is jx:\n\nThank you,\nBest,",
          "url": "https://github.com/idaholab/moose/discussions/22542",
          "updatedAt": "2022-11-15T19:19:01Z",
          "publishedAt": "2022-10-30T23:07:58Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you please paste your mesh block here?\nI suspect your mesh is actually in the x,y plane?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4018652",
                  "updatedAt": "2022-10-31T13:20:31Z",
                  "publishedAt": "2022-10-31T13:20:30Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "Yes. only in x,y plane. no z axis.\nWhy do I get flux in x direction?",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4018928",
                          "updatedAt": "2022-10-31T13:49:42Z",
                          "publishedAt": "2022-10-31T13:49:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "because the simulation is in the xy plane?\nin the Z direction (out of plane) I would expect 0 flux",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4018976",
                          "updatedAt": "2022-10-31T13:55:14Z",
                          "publishedAt": "2022-10-31T13:55:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "But jx must be normal to y-z plane, if there is no z axis, there is no that plane.\nYes, there is no z axis, so, there is 0 flux in z direction.",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4019060",
                          "updatedAt": "2022-10-31T14:04:34Z",
                          "publishedAt": "2022-10-31T14:04:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "Where is wrong?",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4019072",
                          "updatedAt": "2022-10-31T14:05:52Z",
                          "publishedAt": "2022-10-31T14:05:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "your mesh is in the XY plane not the XZ",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4019145",
                          "updatedAt": "2022-10-31T14:12:52Z",
                          "publishedAt": "2022-10-31T14:12:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "????what? can you explain it clearly?",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4019163",
                          "updatedAt": "2022-10-31T14:14:17Z",
                          "publishedAt": "2022-10-31T14:14:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "nz = 0 there are no elements in the Z direction",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4019179",
                          "updatedAt": "2022-10-31T14:16:31Z",
                          "publishedAt": "2022-10-31T14:16:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "yes. So, there is no z axis, then, why do I get flux in x direction?",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4019221",
                          "updatedAt": "2022-10-31T14:21:22Z",
                          "publishedAt": "2022-10-31T14:21:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you should explain why there should not be flux in the X direction",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4019236",
                          "updatedAt": "2022-10-31T14:23:44Z",
                          "publishedAt": "2022-10-31T14:23:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "because based on the the definition of flux, flux unit, which is #/(m^2*s), it means the amount of solute that pass through per unit area unit time, since , there is no z axis, so there is no y-z plane, ( x direction is normal to y-z plane), if there is no y-z plane, then where does the flux come from?",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4019359",
                          "updatedAt": "2022-10-31T14:37:12Z",
                          "publishedAt": "2022-10-31T14:37:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "abc-hy"
                  },
                  "bodyText": "infinite periodicity? What periodicity? I did not set periodic boundary\ncondition, I used zero flux BC\n\u2026\nOn Mon, Oct 31, 2022 at 10:16 AM Guillaume Giudicelli < ***@***.***> wrote:\n No it's a 2D model.\n You should think about what it means to do a 2D simulation. It usually\n assumes infinite periodicity in the 3rd dimension\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#22542 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/APF2ZCQJI55MVDMZPC5DLF3WF7PDBANCNFSM6AAAAAARSSCVMU>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4019747",
                  "updatedAt": "2022-10-31T15:18:35Z",
                  "publishedAt": "2022-10-31T15:18:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "for the 3rd dimension, you likely effectively have 0 flux which is equivalent to periodic.\nThis is dependent on what was implemented in the kernels. For reactor physics, you can implement 2D systems with an axial model.",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4019817",
                          "updatedAt": "2022-10-31T15:24:51Z",
                          "publishedAt": "2022-10-31T15:24:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "It seems that 2D model and 3D model does not have difference. Could you please clarify the difference of 2D model and 3D model?",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4024032",
                          "updatedAt": "2022-11-01T03:41:49Z",
                          "publishedAt": "2022-11-01T03:41:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "In a 3D model you may have heterogeneity in the 3rd dimension, in 2D you cant",
                          "url": "https://github.com/idaholab/moose/discussions/22542#discussioncomment-4027616",
                          "updatedAt": "2022-11-01T13:32:34Z",
                          "publishedAt": "2022-11-01T13:32:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiapp mesh transfer with adaptivity",
          "author": {
            "login": "xueyang94"
          },
          "bodyText": "I have one mainapp that transfers a few variables from one subapp using FullSolveMultiApp. The transfer only occurs after the subapp is finished. In the subapp, I use mesh Adaptivity starting at initial step. The subapp domain is smaller than the mainapp domain.  How to transfer the subapp mesh after adaptivity? Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/22417",
          "updatedAt": "2022-11-15T19:31:52Z",
          "publishedAt": "2022-10-16T20:12:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nwe don\u2019t transfer meshes. However if you want to refine the main app the same way as the subapp you can transfer the indicator and use it for the criterion for adaptivity\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22417#discussioncomment-3891778",
                  "updatedAt": "2022-10-17T00:14:33Z",
                  "publishedAt": "2022-10-17T00:14:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the trickiness might be to order the transfer and the adaptivity correctly.\nMaybe if you run the mulitapp and do the transfer on timestep_end, then run the adaptivity on timestep_begin that would work for you?",
                          "url": "https://github.com/idaholab/moose/discussions/22417#discussioncomment-3891893",
                          "updatedAt": "2022-10-17T00:58:53Z",
                          "publishedAt": "2022-10-17T00:58:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "Hello Guillaume, you have described what I am doing currently. I transfer the indicator (bnds) from the subapp to mainapp after the subapp is finished, and run the adaptivity of mainapp on timestep_begin. However, since the mainapp does not start with the finest mesh of the subapp, as the mesh refines, the mainapp would crash due to memory.\nI want the mainapp to start with the finest mesh so that at least the crash would happen at the first timestep. The mainapp adaptivity block uses ValueRangeMarker on both the transferred indicator (bnds) and the variables in the mainapp. However, at the initial timestep of mainapp, only its own variables are refined, while bnds is at its coarsest. This is strange to me why bnds is not refined just like other variables.",
                          "url": "https://github.com/idaholab/moose/discussions/22417#discussioncomment-3994000",
                          "updatedAt": "2022-10-28T15:14:07Z",
                          "publishedAt": "2022-10-28T15:14:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "The issue can be visualized using the input files I supplied in Discussion #22342. The meshes of subapp and mainapp at timestep zero are below. There are three phases in the mainapp from left to right. The subapp simulates the left-most phase but with two grains on top of each other. Although mesh cannot be transferred as you mentioned, I would expect the left phase in the mainapp to have a refined horizontal grain boundary because the bnds indicator from subapp is refined together with other variables in the mainapp at timestep zero.\nSubapp at timestep zero:\n\nMainapp at timestep zero:",
                          "url": "https://github.com/idaholab/moose/discussions/22417#discussioncomment-3994239",
                          "updatedAt": "2022-10-28T15:37:50Z",
                          "publishedAt": "2022-10-28T15:37:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I ran your inputs and I think I have a better understanding of what you want but I think there are a few issues:\n\nin the main app I'm seeing etaa0 and etaa1 used as markers, not bnds.\nthe mesh of the main app will never see the updated value from the transfer of bnds from the main app because when the transfer is performed, it does not have nodes in the center/middle of the square.\nOnce the mesh is refined, it could, but at INITIAL when the transfer is performed it does not.\nI made ny be even, so that there's nodes on the horizontal middle of the left box, and got the expected bnds value in the center.\n\nbut even then, looking at the FEProblemBase.C order of execution of things in initialSetup():\n\nmarkers are on line 750\nadaptivity is on line 850\nmultiapps and transfers are on line 1055\n\nso adaptivity is ran before the multiapps are, the values transfered and so on. So the marker would not be used on INITIAL.\nSo your options:\n\nmake a PR to MOOSE moving adaptivity after the first round of multiapps. I doubt anyone relies on the opposite\nrun a fake time step with no physics at the beginning of your main app\nhave a very very small first time step with a coarsened mesh. In a very small time step in the real world, nothing happens, and same in MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/22417#discussioncomment-3998327",
                          "updatedAt": "2022-10-28T21:59:51Z",
                          "publishedAt": "2022-10-28T21:59:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xueyang94"
                          },
                          "bodyText": "Thanks for the reply. I used an updated input file where bnds was transferred instead of grain variables. The transfer does not have nodes in the center of the square, and it only have nodes on the edge of the square? Not sure how this transfer works.\nIf the adaptivity is ran before the multiapps are, I would imagine the markers being used on INITIAL because the marker is associated with adaptivity.",
                          "url": "https://github.com/idaholab/moose/discussions/22417#discussioncomment-4020903",
                          "updatedAt": "2022-10-31T17:17:52Z",
                          "publishedAt": "2022-10-31T17:17:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok for updated input\nThe meshfunction or shapeevaluation transfer evaluates the source variable at the locations of the target mesh.\nYou do not have any mesh node at the right location in the target mesh at initialization\nyes, markers are also pre-multiapp",
                          "url": "https://github.com/idaholab/moose/discussions/22417#discussioncomment-4021831",
                          "updatedAt": "2022-10-31T19:36:13Z",
                          "publishedAt": "2022-10-31T19:36:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "CZM used with HeatConduction",
          "author": {
            "login": "echo1115"
          },
          "bodyText": "Hi,\nI made a case using CZM and HeatConduction modules. In the case, an object (x\u2208[0,1],y\u2208[0,1],z\u2208[0,4]) is consisted of 4 blocks. The mesh of block1-block2 and block2-block3 are broken using BreakMeshByBlockGenerator, block0-block1 are always connected.\n\nAs for the BCs,\nMechanical BCs:  the boundaries x0 (x=0), y0 (y=0), z0 (z=0) are fixed, a tension displacement is applied at z1 (z=4).\nThermal BCs: a heatflux is applied at z0 (z=0), and a DirichletBC is applied at z1 (z=4).\nBesides, to ensure the temperature is continuous between block1-block2, block2-block3, I  used ThermalContact and applied a large\ngap_conductance.\nHere is the figure of temperature calculation result. I ploted the temperature along z axis,\nbut why the temperature is not decrease along z axis\uff1f\n\nThe input shows here\n[Mesh]\n  [./gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 1\n    ny = 1\n    nz = 40\n    zmin = 0\n    zmax = 4\n  [../]\n  [block1]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 0\n    bottom_left = '0 0 0'\n    top_right = '1 1 1'\n    input = gen\n  []\n  [block2]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 1\n    bottom_left = '0 0 1'\n    top_right = '1 1 2'\n    input = block1\n  []\n  [block3]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 2\n    bottom_left = '0 0 2'\n    top_right = '1 1 3'\n    input = block2\n  []\n  [block4]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 3\n    bottom_left = '0 0 3'\n    top_right = '1 1 4'\n    input = block3\n  []\n  [./split]\n    type = BreakMeshByBlockGenerator\n    input = block4 #subdomain_id\n    split_interface = true\n    surrounding_blocks = 2 # added\n    add_interface_on_two_sides = true # added\n  []\n  [add_side_sets]\n    input = split\n    type = SideSetsFromNormalsGenerator\n    normals = '0 -1  0\n               0  1  0\n               -1 0  0\n               1  0  0\n               0  0 -1\n               0  0  1'\n    fixed_normal = true\n    new_boundary = 'y0 y1 x0 x1 z0 z1'\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Variables] # added\n  [./temp]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 500\n  [../]\n  [./disp_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_y]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  [./disp_z]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n[Functions]\n  [./stretch]\n    type = PiecewiseLinear\n    x = '0 1'\n    y = '0 100'\n  [../]\n[]\n\n[Kernels]  # added\n  [./heat]\n    type = HeatConduction\n    variable = temp\n  [../]\n  [./heat_dt]\n    type = HeatConductionTimeDerivative\n    variable = temp\n  [../]\n[]\n\n[Modules]\n  [./TensorMechanics]\n    [./Master]\n      [./all]\n        strain = FINITE\n        add_variables = true\n        use_finite_deform_jacobian = true\n        use_automatic_differentiation = true\n        generate_output = 'stress_xx stress_yy stress_zz stress_xy stress_yz stress_xz'\n      [../]\n    [../]\n  [../]\n[]\n\n[Modules/TensorMechanics/CohesiveZoneMaster]\n  [./czm_ik_012]\n    boundary = ' Block1_Block2 Block2_Block3'  # modified\n    base_name = 'czm_b012'\n  [../]\n[]\n\n[Materials]\n  # cohesive materials\n  [./czm_3dc]\n    type = SalehaniIrani3DCTraction\n    boundary = ' Block1_Block2 Block2_Block3'  # modified\n    normal_gap_at_maximum_normal_traction = 1\n    tangential_gap_at_maximum_shear_traction = 0.5\n    maximum_normal_traction = 500\n    maximum_shear_traction = 300\n    base_name = 'czm_b012'\n  [../]\n  # bulk materials\n  [./stress]\n    type = ADComputeFiniteStrainElasticStress\n  [../]\n  [./elasticity_tensor]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 200e4\n    poissons_ratio = 0.3\n  [../]\n  # added: thermal materials\n  [./density]\n    type = Density\n    density = 3180\n  [../]\n  [./k_cp]\n    type = HeatConductionMaterial\n    thermal_conductivity = 4\n    specific_heat = 620.0\n  [../]\n[]\n\n[BCs]\n  [./fix_x]\n    type = DirichletBC\n    preset = true\n    value = 0.0\n    boundary = x0\n    variable = disp_x\n  [../]\n  [./fix_y]\n    type = DirichletBC\n    preset = true\n    value = 0.0\n    boundary = y0\n    variable = disp_y\n  [../]\n  [./fix_z]\n    type = DirichletBC\n    preset = true\n    value = 0.0\n    boundary = z0\n    variable = disp_z\n  [../]\n  [./back_z]\n    type = FunctionNeumannBC\n    boundary = z1\n    variable = disp_z\n    use_displaced_mesh = false\n    function = stretch\n  [../]\n\n  # added: thermal bc\n  [./innerHeatFlux]\n    type = FunctionNeumannBC\n    boundary = z0\n    variable = temp\n    function = 1.0e4\n  [../]\n  [./outerTemp_z1]\n     type = DirichletBC\n     boundary = z1\n     variable = temp\n     value = 500.0\n  [../]\n[]\n\n[ThermalContact] # added\n  [thermal_contact]\n    type = GapHeatTransfer\n    variable = temp\n    primary = 'Block1_Block2 Block2_Block3'\n    secondary = 'Block2_Block1 Block3_Block2'\n    emissivity_primary = 0\n    emissivity_secondary = 0\n    gap_conductance = 1.0e9\n  []\n[]\n\n[Constraints]\n  [x1]\n    type = EqualValueBoundaryConstraint\n    variable = disp_x\n    secondary = 'x1'    # boundary\n    penalty = 1e6\n  []\n  [y1]\n    type = EqualValueBoundaryConstraint\n    variable = disp_y\n    secondary = 'y1'    # boundary\n    penalty = 1e6\n  []\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-ksp_gmres_restart -pc_type -pc_hypre_type -pc_hypre_boomeramg_max_iter'\n  petsc_options_value = '201                hypre    boomeramg      4'\n\n  line_search = 'none'\n  nl_rel_tol = 1e-8\n  l_tol = 1e-3\n  l_max_its = 100\n\n  start_time = 0.0\n  dt = 0.25\n  dtmin = 0.25\n  num_steps = 10\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/22528",
          "updatedAt": "2022-10-31T16:50:14Z",
          "publishedAt": "2022-10-28T02:24:09Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@jiangwen84 @arovinelli would you guys be able to help or have some suggestions for this user?",
                  "url": "https://github.com/idaholab/moose/discussions/22528#discussioncomment-3998196",
                  "updatedAt": "2022-10-28T21:35:40Z",
                  "publishedAt": "2022-10-28T21:35:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "It's not really a CZM question. This happens when the characteristic time for heat transfer is way larger than the simulation time. The characteristic time can be expressed as\ntau = L^2 rho c / k\nwhere L is the domain size, rho the density, c the specific heat, and k the conduction coef.\nI would first check to see if the material properties you used are realistic. If they are, then it suggests the time scale you might be interested is much larger than what you were using.\nAlternatively, you can remove the time derivative kernel for temperature. Consequently, the solution you get will be the steady state temperature, from which you can check if the conjugate heat transfer is working as expected.",
                          "url": "https://github.com/idaholab/moose/discussions/22528#discussioncomment-3999931",
                          "updatedAt": "2022-10-29T02:02:01Z",
                          "publishedAt": "2022-10-29T02:02:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@hugary1995 Thanks for your reply. Yes it's not a CZM question, this problem exists even though I don't break the mesh and omit the CZM modules. But when I reduce the size of mesh (not applied BreakMeshByBlockGenerator) to 1e-6 times, the temperature decreases along Z axis, since the characteristic time 'tau' you mentioned decreases a lot.",
                          "url": "https://github.com/idaholab/moose/discussions/22528#discussioncomment-4005280",
                          "updatedAt": "2022-10-29T14:05:10Z",
                          "publishedAt": "2022-10-29T14:05:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Glad it's working. Yeah, mesh refinement is another way to resolve this.",
                          "url": "https://github.com/idaholab/moose/discussions/22528#discussioncomment-4005305",
                          "updatedAt": "2022-10-29T14:12:10Z",
                          "publishedAt": "2022-10-29T14:12:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "If you decide to use ThermalContact to enforce the continuity,  you can set ''quadrature=true'' which is a better option for paired interface like CZM you used here.\nIn addtion to ThermalContact option,  you  an also consider use CoupledPenaltyInterfaceDiffusion or ThinLayerHeatTransfer.",
                          "url": "https://github.com/idaholab/moose/discussions/22528#discussioncomment-4005364",
                          "updatedAt": "2022-10-29T14:22:51Z",
                          "publishedAt": "2022-10-29T14:22:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "Thanks for all your suggestions! @hugary1995 @jiangwen84",
                          "url": "https://github.com/idaholab/moose/discussions/22528#discussioncomment-4006788",
                          "updatedAt": "2022-10-29T17:02:27Z",
                          "publishedAt": "2022-10-29T17:02:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Thank you @hugary1995 for all your help on the Discussions board! It is much appreciated",
                          "url": "https://github.com/idaholab/moose/discussions/22528#discussioncomment-4019511",
                          "updatedAt": "2022-10-31T14:51:46Z",
                          "publishedAt": "2022-10-31T14:51:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@echo1115 can we mark this as answered?",
                          "url": "https://github.com/idaholab/moose/discussions/22528#discussioncomment-4019515",
                          "updatedAt": "2022-10-31T14:52:12Z",
                          "publishedAt": "2022-10-31T14:52:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@lindsayad yes, this can be marked as answered. Thank you a lot.",
                          "url": "https://github.com/idaholab/moose/discussions/22528#discussioncomment-4020322",
                          "updatedAt": "2022-10-31T16:11:46Z",
                          "publishedAt": "2022-10-31T16:11:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Same question:Tensor Mechanics and Heat Conduction coupling",
          "author": {
            "login": "DYLDYLDYL"
          },
          "bodyText": "Hi\uff01\nI am  trying to make a code using Tensor Mechanics Action to calculate the  thermal expansion with a temperature transient. When I do the simulation with only Heat Conduction or only Tensor Mechanics, both work, just when I try to put them together it does not converge.\nThanks in advance for your help!\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh]\nfile = fuelm.e\n  []\n\n[Variables]\n  [T]\n  initial_condition = 300.0\n  []\n[]\n\n[Kernels]\n  [heat_conduction]\n    type = HeatConduction\n    variable = T\n  []\n  [heat_source]\n  type = HeatSource\n  function = volumetric_heat\n  variable = T\n[]\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    automatic_eigenstrain_names = true\n    generate_output = 'vonmises_stress'\n  []\n[]\n\n[BCs]\n  [./bottom]\n    type = DirichletBC\n    boundary = 1\n    variable = T\n    value = 300\n  [../]\n    [./top]\n    type = DirichletBC\n    boundary = 3\n    variable = T\n    value = 300\n  [../]\n    [bottom_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 1\n    value = 0\n  []\n[]\n\n[Materials]\n  [./density]\n    type = GenericConstantMaterial\n    prop_names = 'density '\n    prop_values = '10980.0 '\n  [../]\n  [./hcm]\n    type = HeatConductionMaterial\n    specific_heat = 216\n    thermal_conductivity = 7.5\n  [../]\n    [elasticity]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 2.013e11\n    poissons_ratio = 0.316\n  []\n  [expansion1]\n    type = ComputeThermalExpansionEigenstrain\n    temperature = T\n    thermal_expansion_coeff = 9.802e-4\n    stress_free_temperature = 300\n    eigenstrain_name = thermal_expansion\n  []\n  \n    [stress]\n    type = ComputeLinearElasticStress\n  []\n[]\n\n[Functions]\n  [./volumetric_heat]\n     type = ParsedFunction\n     value = 5.96e+5*sin(alpha*pi*z)*t*0.2\n    vars = 'alpha'\n    vals = '5'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  end_time = 5\n  dt = 1\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n 427 Linear |R| = 8.321297e-09\n    428 Linear |R| = 8.243846e-09\n    429 Linear |R| = 8.168653e-09\n    430 Linear |R| = 8.109369e-09\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n Solve Did NOT Converge!\n  Finished Solving                                                                       [ 81.61 s] [  325 MB]\nAborting as solve did not converge\n\nTime Step 1, time = 0.5, dt = 0.5\n 0 Nonlinear |R| = 4.066117e-04\n\n    Computing Jacobian.                                                                  [ 11.48 s] [  -20 MB]\n      0 Linear |R| = 4.066117e-04\n      1 Linear |R| = 3.610152e-04\n      2 Linear |R| = 3.524526e-04\n      3 Linear |R| = 3.472519e-04",
          "url": "https://github.com/idaholab/moose/discussions/22541",
          "updatedAt": "2022-11-15T19:20:23Z",
          "publishedAt": "2022-10-30T09:24:02Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "js-jixu"
                  },
                  "bodyText": "Maybe you can use some preconditioners to get the problem converged. For example, add the following in the [Executioner] block:\n    petsc_options_iname = '-pc_type -pc_factor_shift_type -pc_factor_mat_solver_type'\n    petsc_options_value = 'lu       NONZERO               superlu_dist'",
                  "url": "https://github.com/idaholab/moose/discussions/22541#discussioncomment-4011502",
                  "updatedAt": "2022-10-30T10:59:15Z",
                  "publishedAt": "2022-10-30T10:59:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "DYLDYLDYL"
                          },
                          "bodyText": "Thanks!\nHi, it`s still unconverged.\nTime Step 1, time = 1, dt = 1\n 0 Nonlinear |R| = 8.132233e-04\n\n    Computing Jacobian.                                                                  [ 11.24 s] [  321 MB]\n      0 Linear |R| = 8.132233e-04\n      1 Linear |R| = 2.434529e-14\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n Solve Did NOT Converge!\n  Finished Solving                                                                       [ 74.64 s] [ 4620 MB]\nAborting as solve did not converge\n\nI hope you can add my wechat\uff1a13147778609\uff01",
                          "url": "https://github.com/idaholab/moose/discussions/22541#discussioncomment-4011997",
                          "updatedAt": "2022-10-30T13:07:44Z",
                          "publishedAt": "2022-10-30T13:07:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\ncan you turn off the linear search for now?\nIn executioner:\nline_search = none\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22541#discussioncomment-4012145",
                          "updatedAt": "2022-10-30T13:42:01Z",
                          "publishedAt": "2022-10-30T13:42:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "DYLDYLDYL"
                          },
                          "bodyText": "Thanks\uff01\nIt`s still unconverged.\n48 Nonlinear |R| = 1.250104e-08\n\n    Computing Jacobian.                                                                  [ 11.43 s] [    0 MB]\n      0 Linear |R| = 1.250104e-08\n      1 Linear |R| = 2.749728e-14\n49 Nonlinear |R| = 1.208844e-08\n\n    Computing Jacobian.                                                                  [ 11.23 s] [    0 MB]\n      0 Linear |R| = 1.208844e-08\n      1 Linear |R| = 1.312762e-14\n50 Nonlinear |R| = 1.287461e-08\nNonlinear solve did not converge due to DIVERGED_MAX_IT iterations 50\n Solve Did NOT Converge!\n  Finished Solving                                                                       [2380.17 s] [ 6211 MB]\nAborting as solve did not converge\n\nTime Step 1, time = 0.5, dt = 0.5\n 0 Nonlinear |R| = 4.066117e-04",
                          "url": "https://github.com/idaholab/moose/discussions/22541#discussioncomment-4014676",
                          "updatedAt": "2022-10-31T01:46:21Z",
                          "publishedAt": "2022-10-31T01:46:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you try turning on automatic scaling?\nIs 1e-8 for the residual not converged? The default settings for accepting solutions are not applicable to every physics",
                          "url": "https://github.com/idaholab/moose/discussions/22541#discussioncomment-4015096",
                          "updatedAt": "2022-10-31T03:24:34Z",
                          "publishedAt": "2022-10-31T03:24:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "DYLDYLDYL"
                          },
                          "bodyText": "Thanks a lot \uff01Your answer solves my problem perfectly \uff01",
                          "url": "https://github.com/idaholab/moose/discussions/22541#discussioncomment-4017585",
                          "updatedAt": "2022-10-31T10:59:54Z",
                          "publishedAt": "2022-10-31T10:59:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Iterative Schwarz method for domain decomposition",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hello,\nI have a 1D domain to be decomposed into two subdomains by solving the Poisson equation (at least) using the Additive Schwarz Algorithm.\nMy enquiries:\n\nCan this be solved with MOOSE?\nHow do I go about it? (The modules, multiapp solver, transfers etc).\n\nI have a little understanding of MOOSE as I have been able to use it solve some IB basic FEM analysis of Diffusion-Reaction-Source equation.\nI would be glad to have as much as as possible.\nThank you!\n----The Equation---\n\n---The Algorithm-------",
          "url": "https://github.com/idaholab/moose/discussions/22516",
          "updatedAt": "2022-11-15T18:06:21Z",
          "publishedAt": "2022-10-27T17:34:46Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe support using asm preconditioning from petsc if you want to try that with a simple Poisson problem\nThere are examples for poisson in the tutorial and the petsc options are set in the executioner block\nhttps://mooseframework.inl.gov/source/executioners/Steady.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-3984684",
                  "updatedAt": "2022-10-27T17:59:44Z",
                  "publishedAt": "2022-10-27T17:59:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "otherwise if you want to write your own custom iterative method, then this is possible in MOOSE as well",
                          "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-3984693",
                          "updatedAt": "2022-10-27T18:00:39Z",
                          "publishedAt": "2022-10-27T18:00:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "Hello, thank you for your response.\nI understand I can use the petsc in the executioner block of the input file. I am actually looking for how to do this with Multi-App System where I have two different systems that run iteratively, and only transfer the solution at the interface. The emphasis is on using Mullti-App  (with different input files) and transfer so as to have the same solution as when the problem is solved with a single input file.\nFor instance, I would like to solve this problem between [-1,0] using two subdomains [-1,0] and [0,1] with interface at point (0,0). It admits DirichletBC on the left and NeumanBC on the right. The idea is to enforce u and v at the interface, and to make the flux of the two variables to be the negative of the other at the interface. For some reasons, I amnot getting the results as expected and my first domain (sub1) is returning zero values for the flux and u. So far, I have the following trials:\n---- Sub 1 ---------\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  nx = 64\n  xmin = -1\n  xmax = 0\n[]\n\n[Variables]\n  [u]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [flux_u]\n    order = CONSTANT\n    family = MONOMIAL\n  \n  []\n[]\n\n[Kernels]\n  [diffusion]\n    type = MatDiffusion\n    variable = u\n    diffusivity = 2\n  []\n[]\n\n[AuxKernels]\n  [fluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = 2\n    variable = flux_u\n    diffusion_variable = u\n    component = x\n  []\n[]\n\n[BCs]\n  [leftBC] \n    type = DirichletBC\n    variable = u\n    boundary = 'left'\n    value = 0\n  []\n\n  [rightBC_Neumann] \n    type = FunctionNeumannBC\n    variable = u\n    boundary = 'right' \n    function =  BC_u_right_Neumann\n    #preset = true\n  []\n\n  [rightBC_Dirichlet] \n    type = FunctionDirichletBC\n    variable = u\n    boundary = 'right' \n    function = BC_u_right_Dirichlet\n    preset = true\n  []\n[]\n\n\n[Postprocessors]\n  [right_uflux]\n    type = PointValue\n    variable = 'flux_u'\n    point = '0 0 0'\n   []\n  [right_uval]\n    type = PointValue\n    variable = 'u'\n    point = '0 0 0'\n   []\n  [vval_left]\n    type = Receiver\n  []\n  [v_flux_left]\n    type = Receiver\n  []\n[]\n\n[Functions]\n  [BC_u_right_Neumann]\n    type = ParsedFunction\n    value = '-a'\n    vars = 'a'\n    vals = 'v_flux_left'\n  []\n  [BC_u_right_Dirichlet]\n    type = ParsedFunction\n    value = 'b'\n    vars = 'b'\n    vals = 'vval_left'\n  []\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = 'PJFNK'\n\n  fixed_point_max_its = 20\n  nl_abs_tol = 1e-10\n  fixed_point_rel_tol = 1e-16\n  fixed_point_abs_tol = 1e-10\n\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\n[Outputs]\n  exodus = true\n  #csv = true\n  console = true\n[]\n\n\n[MultiApps]\n  [sub]\n    type = FullSolveMultiApp\n    execute_on = 'timestep_begin'\n    positions = '0 0 0'\n    input_files = sub2.i \n  []\n[]\n\n\n[Transfers]\n  [flux_ut]\n    type = MultiAppPostprocessorTransfer\n    to_multi_app = sub\n    from_postprocessor = right_uflux\n    to_postprocessor = u_flux_right\n  []\n  [uval_t]\n    type = MultiAppPostprocessorTransfer\n    to_multi_app = sub\n    from_postprocessor = right_uval\n    to_postprocessor = uval_right\n  []\n  [flux_vt]\n    type = MultiAppPostprocessorTransfer\n    from_multi_app = sub\n    reduction_type = average\n    from_postprocessor = left_vflux\n    to_postprocessor = v_flux_left\n  []\n  [vval_t]\n    type = MultiAppPostprocessorTransfer\n    from_multi_app = sub\n    reduction_type = average\n    from_postprocessor = left_vval\n    to_postprocessor = vval_left\n  [] \n[]\n\n-----Sub 2 -----\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  nx = 64\n  xmin = 0\n  xmax = 1\n\n[]\n\n[Variables]\n  [v]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [flux_v]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[Kernels]\n  [diffusion]\n    type = MatDiffusion\n    variable = v\n    diffusivity = 2\n  []\n[]\n\n[AuxKernels]\n  [fluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = 2\n    variable = flux_v\n    diffusion_variable = v\n    component = x\n  []\n[]\n\n[BCs]\n  [rightBC] \n    type = NeumannBC\n    variable = v\n    boundary = 'right'\n    value = 3\n  []\n\n  [leftBC_Neumann] \n    type = FunctionNeumannBC\n    variable = v\n    boundary = 'left' \n    function = BC_vleft_Neumann\n  []\n\n  [leftBC_Dirichlet] \n    type = FunctionDirichletBC\n    variable = v\n    boundary = 'left' \n    function = BC_vleft_Dirichlet\n    preset = true\n  []\n\n[]\n\n[Postprocessors]\n  [left_vflux]\n    type = PointValue\n    variable = 'flux_v'\n    point = '0 0 0'\n   []\n  [left_vval]\n    type = PointValue\n    variable = 'v'\n    point = '0 0 0'\n   []\n  [uval_right]\n    type = Receiver\n  []\n  [u_flux_right]\n    type = Receiver\n  []\n[]\n\n[Functions]\n  [BC_vleft_Neumann]\n    type = ParsedFunction\n    value = '-a'\n    vars = 'a'\n    vals = 'u_flux_right'\n\n  []\n  [BC_vleft_Dirichlet]\n    type = ParsedFunction\n    value = 'b'\n    vars = 'b'\n    vals = 'uval_right'\n  []\n[]\n\n\n[Executioner]\n  type = Steady\n  solve_type = 'PJFNK'\n\n  fixed_point_max_its = 20\n  nl_abs_tol = 1e-10\n  fixed_point_rel_tol = 1e-16\n  fixed_point_abs_tol = 1e-10\n\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n[]\n\n[Outputs]\n  exodus = true\n  #csv = true\n  console = true\n[]\n\n----- The reference domain (when solved as a single domain) -------\n[Mesh]\n  type = GeneratedMesh\n  dim = 1\n  nx = 64\n  xmin = -1\n  xmax = 1\n\n[]\n\n[Variables]\n  [v]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n\n[AuxVariables]\n  [flux_v]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[Kernels]\n  [diffusion]\n    type = MatDiffusion\n    variable = v\n    diffusivity = 2\n  []\n[]\n\n[AuxKernels]\n  [fluxKernel]\n    type = DiffusionFluxAux\n    diffusivity = 2\n    variable = flux_v\n    diffusion_variable = v\n    component = x\n  []\n[]\n\n[BCs]\n  [rightBC] \n    type = NeumannBC\n    variable = v\n    boundary = 'right'\n    value = 3\n  []\n\n  [leftBC] \n    type = DirichletBC\n    variable = v\n    boundary = 'left'\n    value = 0\n  []\n\n[]\n\n\n[Executioner]\n  type = Steady\n  solve_type = 'PJFNK'\n[]\n\n[Outputs]\n  exodus = true\n  #csv = true\n  console = true\n[]\n\n\n\nThank you! I hope someone can help spot the problem.",
                          "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-3993206",
                          "updatedAt": "2022-10-28T14:15:36Z",
                          "publishedAt": "2022-10-28T13:51:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so on the right of subapp1 you have a dirichlet and a neumann BC.\nIs that desired? Are you trying to have like a robin BC ?",
                          "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-3995656",
                          "updatedAt": "2022-10-28T17:21:45Z",
                          "publishedAt": "2022-10-28T17:21:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "salaudeen-ya"
                  },
                  "bodyText": "Yes. Exactly. And I've tried the VacuumBC too which doesn't give me the\ndesired results.\n\n\nHow do I go about doing that?\n\u2026\nOn Fri, Oct 28, 2022, 1:21 PM Guillaume Giudicelli ***@***.***> wrote:\n so on the right of subapp1 you have a dirichlet and a neumann BC.\n Is that desired? Are you trying to have like a robin BC ?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#22516 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AJCC7Q3XPJKOBFRM6J2LBPDWFQDTJANCNFSM6AAAAAARQJLYW4>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-3996194",
                  "updatedAt": "2022-10-28T18:14:24Z",
                  "publishedAt": "2022-10-28T18:14:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m actually not sure, I just dont think it's with Dirichlet + Neumann that we make those. This should just set the value of the variable, and the flux, as if you had two equations at the boundary.\nWe have robinBCs in the electromagnetics module, they are fairly complicated though. We have other RobinBC in the test object but they dont look right\n@cticenhour do you know how to make the simple case RobinBC ?",
                          "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-3996459",
                          "updatedAt": "2022-10-28T18:30:59Z",
                          "publishedAt": "2022-10-28T18:30:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "Yeah, we don't add the impact of Dirichlet + Neumann like we do with kernels. In fact, I believe Dirichlet actually manipulates the matrix by zeroing out matrix rows corresponding to the discretized variable at those boundary locations.\nThere is a very simple (maybe too simple) RobinBC in the Squirrel application (a dependency of Zapdos) - see the link here. This only takes in a 1D \"velocity\" value, but could serve as a guide basis for a more complicated custom IntegratedBC object that you could create to fit your scenario.",
                          "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-3997085",
                          "updatedAt": "2022-10-28T19:59:47Z",
                          "publishedAt": "2022-10-28T19:59:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I may be completely misunderstanding the discussion here. But a ConvectiveHeatFluxBC is the simplest Robin BC based on the canonical definition: https://en.m.wikipedia.org/wiki/Robin_boundary_condition",
                          "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-3997853",
                          "updatedAt": "2022-10-28T20:55:21Z",
                          "publishedAt": "2022-10-28T20:55:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "I'll take a look at all the suggestions and see what I can make of it.\nThank you all..!",
                          "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-3999980",
                          "updatedAt": "2022-10-29T02:23:50Z",
                          "publishedAt": "2022-10-29T02:23:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "salaudeen-ya"
                  },
                  "bodyText": "I'm tried to get a Robin on the right of sub1 and left of sub2, which is\nthe interface. Not really a direct dirichlet or Neumann on that interface.\n\nOn Fri, Oct 28, 2022, 2:14 PM Yusuf A. SALAUDEEN <\n***@***.***> wrote:\n\u2026\n Yes. Exactly. And I've tried the VacuumBC too which doesn't give me the\n desired results.\n\n\n How do I go about doing that?\n\n On Fri, Oct 28, 2022, 1:21 PM Guillaume Giudicelli <\n ***@***.***> wrote:\n\n> so on the right of subapp1 you have a dirichlet and a neumann BC.\n> Is that desired? Are you trying to have like a robin BC ?\n>\n> \u2014\n> Reply to this email directly, view it on GitHub\n> <#22516 (reply in thread)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AJCC7Q3XPJKOBFRM6J2LBPDWFQDTJANCNFSM6AAAAAARQJLYW4>\n> .\n> You are receiving this because you authored the thread.Message ID:\n> ***@***.***>\n>",
                  "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-3996248",
                  "updatedAt": "2022-10-28T18:16:30Z",
                  "publishedAt": "2022-10-28T18:16:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "salaudeen-ya"
                  },
                  "bodyText": "I was wondering if I could take a look at the ConvectiveHeatFluxBC file but\nit's registered in Heat Conduction App and not in MOOSE App.\n\nHow can I get that please?\n\nThanks.\n\u2026\nOn Fri, Oct 28, 2022, 4:55 PM Gary (Tianchen) Hu ***@***.***> wrote:\n I may be completely misunderstanding the discussion here. But a\n ConvectiveHeatFluxBC is the simplest Robin BC based on the canonical\n definition: https://en.m.wikipedia.org/wiki/Robin_boundary_condition\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#22516 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AJCC7QZ2VJ7XI2IISDE7EGDWFQ4UJANCNFSM6AAAAAARQJLYW4>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-4014524",
                  "updatedAt": "2022-10-31T01:08:13Z",
                  "publishedAt": "2022-10-31T01:08:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "You can include that module in your application by modifying the makefile.\n\nIf you just want to look it s in modules/heat_conduction/src/bcs\n\u2026\n Le 30 oct. 2022 \u00e0 20:08, Yusuf A. Salaudeen ***@***.***> a \u00e9crit :\n\n \ufeff\n I was wondering if I could take a look at the ConvectiveHeatFluxBC file but\n it's registered in Heat Conduction App and not in MOOSE App.\n\n How can I get that please?\n\n Thanks.\n\n On Fri, Oct 28, 2022, 4:55 PM Gary (Tianchen) Hu ***@***.***>\n wrote:\n\n > I may be completely misunderstanding the discussion here. But a\n > ConvectiveHeatFluxBC is the simplest Robin BC based on the canonical\n > definition: https://en.m.wikipedia.org/wiki/Robin_boundary_condition\n >\n > \u2014\n > Reply to this email directly, view it on GitHub\n > <#22516 (reply in thread)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AJCC7QZ2VJ7XI2IISDE7EGDWFQ4UJANCNFSM6AAAAAARQJLYW4>\n > .\n > You are receiving this because you authored the thread.Message ID:\n > ***@***.***>\n >\n \u2014\n Reply to this email directly, view it on GitHub, or unsubscribe.\n You are receiving this because you commented.",
                  "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-4014600",
                  "updatedAt": "2022-10-31T01:29:21Z",
                  "publishedAt": "2022-10-31T01:29:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "salaudeen-ya"
                  },
                  "bodyText": "Thank you.\n\nOn Sun, Oct 30, 2022, 9:29 PM Guillaume Giudicelli ***@***.***>\nwrote:\n\u2026\n You can include that module in your application by modifying the makefile.\n\n If you just want to look it s in modules/heat_conduction/src/bcs\n\n > Le 30 oct. 2022 \u00e0 20:08, Yusuf A. Salaudeen ***@***.***> a \u00e9crit :\n >\n > \ufeff\n > I was wondering if I could take a look at the ConvectiveHeatFluxBC file\n but\n > it's registered in Heat Conduction App and not in MOOSE App.\n >\n > How can I get that please?\n >\n > Thanks.\n >\n > On Fri, Oct 28, 2022, 4:55 PM Gary (Tianchen) Hu ***@***.***>\n > wrote:\n >\n > > I may be completely misunderstanding the discussion here. But a\n > > ConvectiveHeatFluxBC is the simplest Robin BC based on the canonical\n > > definition: https://en.m.wikipedia.org/wiki/Robin_boundary_condition\n > >\n > > \u2014\n > > Reply to this email directly, view it on GitHub\n > > <\n #22516 (reply in thread)\n >,\n > > or unsubscribe\n > > <\n https://github.com/notifications/unsubscribe-auth/AJCC7QZ2VJ7XI2IISDE7EGDWFQ4UJANCNFSM6AAAAAARQJLYW4\n >\n > > .\n > > You are receiving this because you authored the thread.Message ID:\n > > ***@***.***>\n > >\n > \u2014\n > Reply to this email directly, view it on GitHub, or unsubscribe.\n > You are receiving this because you commented.\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#22516 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AJCC7Q2K6CSX3QRS63ZDHSLWF4OHVANCNFSM6AAAAAARQJLYW4>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/22516#discussioncomment-4014955",
                  "updatedAt": "2022-10-31T02:51:43Z",
                  "publishedAt": "2022-10-31T02:51:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error in compilation while plotting using python script",
          "author": {
            "login": "bha112"
          },
          "bodyText": "Hello,\nUsing this command in my desktop for compilation of the .json file\n **python ../../../python/make_histogram.py main_out.json* -v results:T_avg:value --xlabel 'Average Temperature'** \n\nTraceback (most recent call last):\n  File \"/home/lab_3/projects/moose/modules/stochastic_tools/examples/parameter_study/gold/../../../python/make_histogram.py\", line 17, in <module>  import mooseutils .\n\nModuleNotFoundError: No module named 'mooseutils'\n\nIts seems python script is not working (make_histogram.py).\nCould you please help me to solve the issue?\nBhavesh",
          "url": "https://github.com/idaholab/moose/discussions/22540",
          "updatedAt": "2022-10-31T11:45:27Z",
          "publishedAt": "2022-10-30T06:53:14Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou need to add moose/python to your pythonpath so python knows where to find mooseutils\nlike this:\nexport PYTHONPATH=$PYTHONPATH:/home/lab_3/projects/moose/python\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22540#discussioncomment-4012201",
                  "updatedAt": "2022-10-30T13:56:30Z",
                  "publishedAt": "2022-10-30T13:56:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bha112"
                          },
                          "bodyText": "Thanks for your response.",
                          "url": "https://github.com/idaholab/moose/discussions/22540#discussioncomment-4012475",
                          "updatedAt": "2022-10-30T15:03:41Z",
                          "publishedAt": "2022-10-30T15:03:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Best Transfer Option for Large Deformation Transfer",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "The images below present the problem I am having with the transfer. When there is a large deformation that transfer messes up. I tried a few different transfers, but I can't seem to get them to work. I am trying to transfer just a \"1\" from the solid onto the background mesh. This is to track the solid location within the fluid for an immersed FSI system I am trying to create. I made sure to use  displaced_source_mesh = true",
          "url": "https://github.com/idaholab/moose/discussions/22119",
          "updatedAt": "2022-11-15T19:17:33Z",
          "publishedAt": "2022-09-16T18:17:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Have you tried to set use_displaced_mesh to true in the transfer?",
                  "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3665058",
                  "updatedAt": "2022-09-16T18:42:40Z",
                  "publishedAt": "2022-09-16T18:42:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Yes, that didn't change anything. Also to keep in mind, the parent app doesn't have any displacements just the sub-app, so I don't think use_displaced_mesh would do anything anyways. I also tried this by switching the parent and sub app and tried use_displaced_mesh  and that didn't help either.",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3665084",
                          "updatedAt": "2022-09-16T18:48:24Z",
                          "publishedAt": "2022-09-16T18:47:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I ll have to dig into it to check if we actually support subapp displacements in transfers.\nWhich transfer are you using? There are lots of options and some might support things better",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3665112",
                          "updatedAt": "2022-09-16T18:51:34Z",
                          "publishedAt": "2022-09-16T18:51:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "I used MultiAppShapeEvaluationTransfer for the pictures above. I wanted to use MultiAppProjectionTransfer specifically, but for that one, the \"indicator\" never moved in the background mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3665141",
                          "updatedAt": "2022-09-16T18:55:39Z",
                          "publishedAt": "2022-09-16T18:55:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What do you mean by the indicator?\nCan you try GeometricInterpolation and NearestNode?",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3665222",
                          "updatedAt": "2022-09-16T19:12:49Z",
                          "publishedAt": "2022-09-16T19:12:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "The indicator is the variable that I am transferring from the solid to the background mesh. Both of the options you describe \"work\" but I do not want the background mesh that is not near the solid to have the indicator value of 1. Both of the options you gave would make the entire background mesh equal to 1, if I didn't use my \"hacky\" method. This \"hacky\" method makes it so the boundary of the solid has value 0 so the nearest node for a background node that is not inside the solid is on the boundary. Below shows it works, but this method has faults because of the \"hacky\" method.",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3665264",
                          "updatedAt": "2022-09-16T19:20:08Z",
                          "publishedAt": "2022-09-16T19:20:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you'd need block restriction to make it work without the accuracy issue\nvery few transfers have it, but you can try the ones in this PR which are yet to be merged\n#17417",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3665955",
                          "updatedAt": "2022-09-16T21:56:51Z",
                          "publishedAt": "2022-09-16T21:56:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "I am a bit confused. The background mesh is all 1 block. I need to use the transfer to determine which element gets changed to a new block to model the immersed solid. I can't block restrict the transfer because I do not which element is part of the solid or part of the real fluid before I transfer.",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3665984",
                          "updatedAt": "2022-09-16T22:03:39Z",
                          "publishedAt": "2022-09-16T22:03:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Is it possible for you to share a branch with your inputs (and any necessary code to run the inputs)?",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3666045",
                          "updatedAt": "2022-09-16T22:20:28Z",
                          "publishedAt": "2022-09-16T22:20:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "I\u2019ll create a minimal working example and send that over. I would have to share two branches and the current problem is solving the INS equations and that would be too long to run to debug anyway. Thanks for looking into this!",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3666071",
                          "updatedAt": "2022-09-16T22:27:57Z",
                          "publishedAt": "2022-09-16T22:27:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "While @lindsayad looks into the issue with transfers involving displaced mesh, one workaround for the time being is to run both apps on the undisplaced mesh, and use the displacements to advect the indicator function.",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3666185",
                          "updatedAt": "2022-09-16T23:10:32Z",
                          "publishedAt": "2022-09-16T23:10:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "maxnezdyur"
                  },
                  "bodyText": "Next time I will just share a branch, I didn't know I couldn't paste in a text file. In the parent file, I commented out a transfer that works with the method I described above but not perfectly.\nParent File\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = -1.0\n    xmax = 3.0\n    ymin = 0.0\n    ymax = 1.0\n    nx = 1000\n    ny = 250\n    elem_type = QUAD4\n  []\n[]\n[Problem]\nkernel_coverage_check = false\nmaterial_coverage_check = false\nskip_nl_system_check = false\n[]\n\n\n[AuxVariables]\n  [indicator]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  []\n[]\n\n[Variables]\n[dummy]\n\n[]\n[]\n\n[Materials]\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'NEWTON'\n  # Run for 100+ timesteps to reach stey state.\n\n  dt = 1e-2\n  end_time = 1\n  dtmin = 1.0e-7\n  # Note: -snes_ksp_ew seems to le to more nonlinear iterations, which isn't ideal\n  # when compute_jacobian() is so expensive for this problem.\n  petsc_options = '-snes_converged_reason -ksp_converged_reason'\n\n  # # Direct solver\n  petsc_options_iname = '-pc_type -pc_factor_shift_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu NONZERO superlu_dist'\n\n  # petsc_options_iname = '-pc_type -pc_hypre_type'\n  # petsc_options_value = 'hypre boomeramg'\n  # residual_and_jacobian_together = true\n  line_search = 'bt'\n  nl_rel_tol = 1e-6\n  nl_abs_tol = 2e-7\n  nl_max_its = 5\n  l_max_its = 25\n\n  automatic_scaling = true\n  off_diagonals_in_auto_scaling = true\n  compute_scaling_once = false\n  # scaling_group_variables = 'velocity p'\n  [TimeIntegrator]\n    type = BDF2\n  []\n\n[]\n\n[Outputs]\n  # [exo]\n  #   type = Exodus\n  # []\n  exodus = true\n  print_linear_residuals = false\n[]\n\n[MultiApps]\n  [solid_domain]\n    type = TransientMultiApp\n    execute_on = \"INITIAL TIMESTEP_END\"\n    # positions = '0 0 0'\n    input_files = solid_multiapp.i\n    use_displaced_mesh = true\n    # sub_cycling = true\n    catch_up = true\n    max_catch_up_steps = 5\n    keep_solution_during_restore = true\n  []\n[]\n\n[Transfers]\n\n  # [push_indicator]\n  #   type = MultiAppGeometricInterpolationTransfer\n  #   # Transfer from the sub-app from this app\n  #   from_multi_app =  solid_domain\n  #   # The name of the variable in this app\n  #   source_variable = solid_indicator\n  #   # The name of the auxiliary variable in the sub-app\n  #   variable = indicator\n  #   displaced_source_mesh = true\n  #   use_displaced_mesh = true\n  #   num_points = 1\n  # []\n  [push_indicator]\n    type = MultiAppShapeEvaluationTransfer\n    # Transfer from the sub-app from this app\n    from_multi_app =  solid_domain\n    # The name of the variable in this app\n    source_variable = solid_indicator\n    # The name of the auxiliary variable in the sub-app\n    variable = indicator\n    displaced_source_mesh = true\n    use_displaced_mesh = true\n  []\n[]\n\n\nChild below\nbeta = 0.25\ngamma = 0.5\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    ymin = 0\n    xmax = 0.2\n    ymax = 0.5\n    nx = 50\n    ny = 150\n    elem_type = QUAD4\n  []\n[]\n[Variables]\n  [disp_x]\n    order = FIRST\n  []\n  [disp_y]\n    order = FIRST\n  []\n[]\n\n[AuxVariables] # variables that are calculated for output\n\n  [solid_indicator]\n    order = FIRST\n    family = LAGRANGE\n    [AuxKernel]\n      type = ConstantAux\n      variable = solid_indicator\n      value = 0.0\n      boundary = 'left right top'\n      execute_on = 'INITIAL TIMESTEP_END'\n    []\n    initial_condition = 1.0\n  []\n[]\n\n[Modules/TensorMechanics/DynamicMaster]\n  [all]\n    # displacements = 'disp_x disp_y'\n    add_variables = true\n    # new_system = true\n    incremental = true\n    strain = FINITE\n    decomposition_method = EigenSolution\n    # hht_alpha = 0.25\n  []\n[]\n\n[Materials]\n  [elastic_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 10000.0\n    poissons_ratio = 0.3\n    use_displaced_mesh = true\n  []\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n  []\n  [density]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = '1'\n    use_displaced_mesh = true\n  []\n  [constant_stress]\n    type = GenericConstantRankTwoTensor\n    tensor_values = '100'\n    tensor_name = test_tensor\n  []\n[]\n\n[BCs]\n  [hold_x]\n    type = DirichletBC\n    boundary = bottom\n    variable = disp_x\n    value = 0\n    use_displaced_mesh = true\n    save_in = div_stess_x\n  []\n  [hold_y]\n    type = DirichletBC\n    boundary = bottom\n    variable = disp_y\n    value = 0\n    use_displaced_mesh = true\n    save_in = div_stess_y\n  []\n  [Pressure]\n    [push_left]\n      boundary = left\n      factor = 100\n    []\n  []\n[]\n\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n  []\n[]\n[Executioner]\n  type = Transient\n  end_time = 10\n  dt = 1e-2\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_ksp_ew'\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_type -pc_factor_shift_type -pc_factor_shift_amount'\n  petsc_options_value = 'lu       superlu_dist                  NONZERO               1e-15'\n  nl_max_its = 40\n  l_max_its = 15\n  line_search = 'none'\n  nl_abs_tol = 1e-5\n  nl_rel_tol = 1e-4\n  automatic_scaling = true\n  [TimeIntegrator]\n    type = NewmarkBeta\n    beta = ${beta}\n    gamma = ${gamma}\n  []\n[]\n\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n  print_linear_converged_reason = false\n[]\n\n# [MultiApps]\n#   [fluid_domain]\n#     type = TransientMultiApp\n#     execute_on = \"INITIAL TIMESTEP_END\"\n#     positions = '0 0 0'\n#     input_files = real_fluid_multiapp.i\n#     use_displaced_mesh = true\n#   []\n# []\n\n# [Transfers]\n#   [push_indicator]\n#     type = MultiAppMeshFunctionTransfer\n#     # Transfer to the sub-app from this app\n#     to_multi_app = fluid_domain\n#     # The name of the variable in this app\n#     source_variable = solid_indicator\n#     # The name of the auxiliary variable in the sub-app\n#     variable = indicator\n#     displaced_source_mesh = true\n#     displaced_target_mesh = true\n#     bbox_factor = 0.5\n#     use_displaced_mesh = true\n#   []\n# []",
                  "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3671169",
                  "updatedAt": "2022-09-17T20:28:28Z",
                  "publishedAt": "2022-09-17T20:28:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Any update on this?",
                  "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3937874",
                  "updatedAt": "2022-10-21T23:59:08Z",
                  "publishedAt": "2022-10-21T23:59:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I have not yet investigated",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3952087",
                          "updatedAt": "2022-10-24T15:04:06Z",
                          "publishedAt": "2022-10-24T15:04:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Ok, jotting some notes down here:\n\nlibMesh node ID 89365 (exodus node ID 89366) is an example of a to-node getting a 0 value when it shouldn't\nThis corresponds to the 4833 point that we want to query the from-mesh for (e.g. index 4832 in the incoming/outgoing points vector)\nWhen asking the mesh function to find the from-element containing that to-node we are getting back a null result, indicating that it thinks the point is out of the mesh\nWhen we get to the active nodes in TreeNode, we do get bounds_point but we do not get any elements that contains_point\n\nI don't really know why this would be a hard case ... these are linear elements so I would expect inverse mapping from the physical space to the reference space to essentially be exact.\n@roystgnr do you have any thoughts on what might be the issue here? Pasted below is a figure. The bottom is the sub-application field that we are transferring to the main application on top. You can see that we are getting these \"teeth\" in the transfer with the blue gaps in the teeth essentially indicating a failed transfer",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3989700",
                          "updatedAt": "2022-10-28T07:38:55Z",
                          "publishedAt": "2022-10-28T06:56:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "There is definitely some undesirable stuff happening here. More than enough to create an issue. Any further investigation will be discussed on the issue: #22534",
                          "url": "https://github.com/idaholab/moose/discussions/22119#discussioncomment-3996594",
                          "updatedAt": "2022-10-28T19:00:56Z",
                          "publishedAt": "2022-10-28T18:54:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}