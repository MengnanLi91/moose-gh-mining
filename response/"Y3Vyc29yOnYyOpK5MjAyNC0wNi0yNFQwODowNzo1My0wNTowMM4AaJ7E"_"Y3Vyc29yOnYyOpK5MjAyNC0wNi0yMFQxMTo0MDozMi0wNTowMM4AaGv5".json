{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wNi0yMFQxMTo0MDozMi0wNTowMM4AaGv5"
    },
    "edges": [
      {
        "node": {
          "title": "New boundary creation at intersection of two boundaries",
          "author": {
            "login": "agniksr"
          },
          "bodyText": "So for the given mesh below, i want to create a new boundary called inlet at the intersection of the the top and rmin faces. Similarly, i want to create an outlet boundary at the intersection of the bottom and rmin faces. Could someone please guide me as to how that could be implemented.\n[Mesh]\n   [annular]\n     type = AnnularMeshGenerator\n     nr = 10\n     rmin = 7.5\n     rmax = 10.0\n     nt = 40\n   []\n   [make3D]\n     type = MeshExtruderGenerator\n     extrusion_vector = '0 0 40'\n     num_layers = 10\n     bottom_sideset = 'bottom'\n     top_sideset = 'top'\n     input = annular\n   []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/27961",
          "updatedAt": "2024-07-14T17:11:53Z",
          "publishedAt": "2024-06-21T14:55:45Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou'll want to use the AdvancedExtruderGenerator:\nhttps://mooseframework.inl.gov/source/meshgenerators/AdvancedExtruderGenerator.html\nYou can use the downward_boundary_ids and upward_boundary_ids to create these sidesets inside the extrusion\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27961#discussioncomment-9849941",
                  "updatedAt": "2024-06-23T04:31:07Z",
                  "publishedAt": "2024-06-23T04:31:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "agniksr"
                          },
                          "bodyText": "Thanks for the suggestion, however, when i try to use that as below\n[Mesh]\n   [annular]\n     type = AnnularMeshGenerator\n     nr = 10\n     rmin = 7.5\n     rmax = 10.0\n     nt = 40\n   []\n   [extrude]\n    type = AdvancedExtruderGenerator\n    input = annular\n    heights = '1'\n    num_layers = 10\n    direction = '0 0 40'\n    bottom_boundary = '100'\n    top_boundary = '200'\n    upward_boundary_source_blocks = '0'\n    upward_boundary_ids = '1001'\n    downward_boundary_source_blocks = '0'\n    downward_boundary_ids = '1501'\n  []\n[]\n\nit does not give me  the inner boundary, instead it just gives me the bottom of the lower boundary and the top of the lower bounadry. How exactly can i change it to give only the inner radial elements at the top and bottom boundaries.",
                          "url": "https://github.com/idaholab/moose/discussions/27961#discussioncomment-9850584",
                          "updatedAt": "2024-06-23T08:22:51Z",
                          "publishedAt": "2024-06-23T08:22:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok I misunderstood what you wanted.\nLet's use a ParsedGenerateSideset\nhttps://mooseframework.inl.gov/source/meshgenerators/ParsedGenerateSideset.html\ninner radial elements should obey an analytical parsed expression you can specify in the combinatorial_geometry parameter",
                          "url": "https://github.com/idaholab/moose/discussions/27961#discussioncomment-9852907",
                          "updatedAt": "2024-06-23T16:52:02Z",
                          "publishedAt": "2024-06-23T16:52:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Default syntax-block type for own syntax",
          "author": {
            "login": "jmeier"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nDear Moose Community,\nFor an custom syntax-block I'd like to define a \"default type\" so the user can skip to enter \"type = ...\". Please note the current state of my input file syntax:\n[MyBlock]\n  type = 'MyBlock'   # <-- how can I ask Moose to try to use the block name as type? Like e.g. Moose is doing the for \"Functions\"\n\n  [SubBlock0]\n    type = 'MySubBlock'  # <-- can I define a default subblock-type for MyBlock so I can skip this line?\n    some_parameter = 0.0\n  []\n\n  [SubBlock1]\n    type = 'MySubBlock'  # <-- can I define a default subblock-type for MyBlock so I can skip this line?\n    some_parameter = 0.4\n  []\n\n[]\n\nTo define \"MyBlock\" an \"MySubBlock\" I used registerMooseObjectTask and registerSyntaxTask.\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/27960",
          "updatedAt": "2024-06-23T06:49:07Z",
          "publishedAt": "2024-06-21T09:56:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you only have a single object type you care about in a given syntax then in the Action (likely the AddMyBlockAction) you can not use a type and always create the same object\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27960#discussioncomment-9839976",
                  "updatedAt": "2024-06-21T13:21:15Z",
                  "publishedAt": "2024-06-21T13:21:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Hello\nIf I omit the type parameter, Moose gives \"missing required parameter 'MyBlock/MySubBlock/type'\". This despite the fact, that I ignore the type parameter in AddMyBlockAction and AddMySubBlockAction.\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/27960#discussioncomment-9850124",
                          "updatedAt": "2024-06-23T05:46:54Z",
                          "publishedAt": "2024-06-23T05:46:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is your action derived from MooseObjectAction? If so the 'type' is required. You can change that in validParams",
                          "url": "https://github.com/idaholab/moose/discussions/27960#discussioncomment-9850139",
                          "updatedAt": "2024-06-23T05:52:32Z",
                          "publishedAt": "2024-06-23T05:52:31Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jmeier"
                          },
                          "bodyText": "Dear Guillaume,\nWonderful! That was it. Thank you very much!\nJ\u00f6rg",
                          "url": "https://github.com/idaholab/moose/discussions/27960#discussioncomment-9850311",
                          "updatedAt": "2024-06-23T06:49:07Z",
                          "publishedAt": "2024-06-23T06:49:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Implementation of inclination dependence of the GB energies through $\\gamma$ in New phase-field model by Moelans in 2022",
          "author": {
            "login": "yixishen"
          },
          "bodyText": "Dear MOOSE community,\nI am aiming to develop a phase-field (PF) model with a strong inclination-dependent anisotropic grain boundary (GB) energy and mobility. I understand that GBAnisotropy can be utilized for calculating PF parameters following the framework established by Moelans et al. in their 2008 Phys. Rev. B publication (Phys. Rev. B 78, 024113 \u2013 Published 16 July 2008). To my knowledge, the inclination dependence is incorporated via angle-dependent PF parameters such as $\\kappa(\\theta)$ and $\\gamma(\\theta)$, without necessitating additional terms in the evolution equations (specifically, the Allen-Cahn equation).\nHowever, recent advancements by Moelans (2022) suggests that to have inclination dependent in a fully variational way, as $\\kappa$($\\theta$) is essentially a function of the gradient of order parameters $\\eta_i$ and $\\eta_j$, an extra term is introduced to the evolution equations:\n$$- m \\nabla \\cdot \\left( \\sum_{j \\neq i} \\left( \\frac{\\partial \\gamma_{ij}}{\\partial n_i} \\right) n_i^2 n_j ^2\\right)$$\nAnd my question is, does moose has any kernel that support this term? Or I may need to create my own function/application for this term?\nThanks\nYixi",
          "url": "https://github.com/idaholab/moose/discussions/26842",
          "updatedAt": "2024-06-23T04:40:06Z",
          "publishedAt": "2024-02-19T19:58:14Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen @jiangwen84",
                  "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-8523368",
                  "updatedAt": "2024-02-20T00:45:08Z",
                  "publishedAt": "2024-02-20T00:45:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Hi Yixi- it looks like the extra term you are asking about is the last term in Equation 16 of the 2022 Moelans paper, right? Just wanted to clarify, because the derivative of gamma is actually with respect to grad eta in the paper, rather than with respect to eta as you wrote. We don't have any kernel developed for that type of dependence currently. If you wanted to implement it, you'd need to write a kernel. It would be similar to ACInterfaceKobayashi1 kernel used in the snow.i example: moose/modules/phase_field/examples/anisotropic_interfaces/snow.i\nYou might also need to write a kernel similar to ACInterfaceKobayashi2 to capture the correct Jacobians for the last term of the second line of Eq. 16. We would welcome a contribution if you would like to do this and are willing to help out along the way. I would suggest first figure out what functional form you want to use for \\gamma_{i,j} and what the analytical forms are for the derivative (this might be in the supplemental material for the paper, I didn't double check it)",
                          "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-8533445",
                          "updatedAt": "2024-02-20T17:57:05Z",
                          "publishedAt": "2024-02-20T17:57:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "yixishen"
                          },
                          "bodyText": "Hi Larry,\nThanks for your response. Yes, the extra term is the last term in Eq 16 of 2022 Moelans paper. And thank you for lead me to ACInterfaceKobayashi1 kernel and  ACInterfaceKobayashi2 kernel. I would be happy to make some contribution to the community. Will work on it as your suggested and let you know if I have questions.\nThanks,\nYixi",
                          "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-8535838",
                          "updatedAt": "2024-02-20T22:20:18Z",
                          "publishedAt": "2024-02-20T22:20:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "yixishen"
                          },
                          "bodyText": "Hi Yixi- it looks like the extra term you are asking about is the last term in Equation 16 of the 2022 Moelans paper, right? Just wanted to clarify, because the derivative of gamma is actually with respect to grad eta in the paper, rather than with respect to eta as you wrote. We don't have any kernel developed for that type of dependence currently. If you wanted to implement it, you'd need to write a kernel. It would be similar to ACInterfaceKobayashi1 kernel used in the snow.i example: moose/modules/phase_field/examples/anisotropic_interfaces/snow.i You might also need to write a kernel similar to ACInterfaceKobayashi2 to capture the correct Jacobians for the last term of the second line of Eq. 16. We would welcome a contribution if you would like to do this and are willing to help out along the way. I would suggest first figure out what functional form you want to use for \\gamma_{i,j} and what the analytical forms are for the derivative (this might be in the supplemental material for the paper, I didn't double check it)\n\nHi Larry,\nSorry for my delayed response, I just started working on this very recently. As I go through with ACInterfaceKobayashi1, and some other examples. I noticed there is also a source file \"ADACInterfaceKobayashi1.C\", which applies the Automatic Differentiation feature in MOOSE. If my understanding is right, AD implementation is encouraged and for AD, Jacobian is not required and only residuals is required. Is my understanding correct?\nThank you for your help,\nYixi",
                          "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-9599186",
                          "updatedAt": "2024-05-29T23:33:28Z",
                          "publishedAt": "2024-05-29T23:33:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Yes that is correct! We have not implemented AD versions of many of the phase-field kernels because we already have full Jacobians implemented. AD versions have been found to be slower than non-AD versions which have the full Jacobians implemented. However in cases where the Jacobians are so complex they haven't been implemented, the AD version performs better.",
                          "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-9605813",
                          "updatedAt": "2024-05-30T13:07:58Z",
                          "publishedAt": "2024-05-30T13:07:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "yixishen"
                          },
                          "bodyText": "Thanks for the confirmation. I\u2019m testing the script I coded by creating a custom application as illustrated on the MOOSE website. To use other modules from MOOSE, I edited the Makefile and set ALL_MODULES := yes.\nWhile testing the custom code, I found that the custom application works well on my local MacBook, though it takes a lot of time and almost gets stuck at \u201cSetting up\u201d when running on the UCSB cluster. For both the cluster and MacBook (apple chip), I installed MOOSE using the method described for [Linux and MacOS].\n1.\tI think this issue is due to the custom code because if I don\u2019t use that part on the cluster, it does not get stuck at \u201cSetting up.\u201d\n2.\tI also tried to just copy and paste my header and src files to the ../modules/phase_field/ directory and recompiled the framework, but the issue persists.\n\nI\u2019m confused about why the exact same custom code works well on my local machine but not on the cluster. Could this be due to differences in the compiler or environment?",
                          "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-9655503",
                          "updatedAt": "2024-06-03T23:24:47Z",
                          "publishedAt": "2024-06-03T23:24:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What are the specs on each machine? Could it be that your local machine is just a lot faster",
                          "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-9656827",
                          "updatedAt": "2024-06-04T02:27:13Z",
                          "publishedAt": "2024-06-04T02:27:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "yixishen"
                          },
                          "bodyText": "What are the specs on each machine? Could it be that your local machine is just a lot faster\n\nMy local machine is m3 pro chip, and the cluster is intel Xeon Gold 6248R processors (48 cores/node). For single core, I think m3 pro is faster than intel, but not a lot. I don't think that is the reason, because if I don't use my custom kernels/materials on cluster, it works well. If I use my custom kernels/materials, it will stuck at \"setting up\", which is like the initialization of the simulation?\nI think it might due to some part of my code, I'm working on that.\nThanks,\nYixi",
                          "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-9658683",
                          "updatedAt": "2024-06-04T05:41:58Z",
                          "publishedAt": "2024-06-04T05:41:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It could be slower in parallel if the custom code is not efficient. Do you use all 48 cores on the cluster?",
                          "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-9663031",
                          "updatedAt": "2024-06-04T11:00:32Z",
                          "publishedAt": "2024-06-04T11:00:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "yixishen"
                          },
                          "bodyText": "Yes that is correct! We have not implemented AD versions of many of the phase-field kernels because we already have full Jacobians implemented. AD versions have been found to be slower than non-AD versions which have the full Jacobians implemented. However in cases where the Jacobians are so complex they haven't been implemented, the AD version performs better.\n\nI have some general questions.\n1), If I decided to use AD version, does that mean all other kernel should also be using an AD version? For example, the second term in the evolution equation,  $-Lm(\\eta_i^3 - \\eta_i + 2 \\eta_i \\sum_{j \\neq i} \\gamma_{ij} \\eta_i^2)$, is embedded via kernel ACGrGrMulti.\n2), I noticed that the ACGrGrMulti.C source code has parts for both AD and non-AD version of ACGrGrMulti. By using \"\nregisterMooseObject(\"PhaseFieldApp\", ADACGrGrMulti); \", the ADACGrGrMulti is also register in MOOSE. Does that mean I can just use an AD version by defining the type to ADACGrGrMulti?",
                          "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-9833938",
                          "updatedAt": "2024-06-20T23:13:23Z",
                          "publishedAt": "2024-06-20T23:04:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no you can mix and match AD and non AD objects in the input file. The only thing is that some material properties might be required to be AD to build / use AD kernels\n\n\nyes. When both are registered it means both versions are available, selectable through the type of the object in the input file",
                          "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-9833986",
                          "updatedAt": "2024-06-20T23:15:37Z",
                          "publishedAt": "2024-06-20T23:15:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "yixishen"
                  },
                  "bodyText": "I test it with a very small model, so I only use 4 cores. In fact, the model is initiated at 200 by 200 mesh, one core is ok.On Jun 4, 2024, at 4:00\u202fAM, Guillaume Giudicelli ***@***.***> wrote:\ufeff\nIt could be slower in parallel if the custom code is not efficient. Do you use all 48 cores on the cluster?\n\n\u2014Reply to this email directly, view it on GitHub, or unsubscribe.You are receiving this because you authored the thread.Message ID: ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-9664164",
                  "updatedAt": "2024-06-04T12:38:29Z",
                  "publishedAt": "2024-06-04T12:38:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok let's stick to one core then\nUsing a debugger (see debugging instructions on our website) on the cluster with one core, use the interrupt at regular intervals to find out in which line the code is spending a lot of time / getting stuck\nAlternatively, use a profiler (see profiling instructions) on the Mac to find the slow section",
                          "url": "https://github.com/idaholab/moose/discussions/26842#discussioncomment-9671635",
                          "updatedAt": "2024-06-05T02:14:08Z",
                          "publishedAt": "2024-06-05T02:14:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Materials System shared among the other systems",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nAll,\nIt reads that the Materials System allows properties to be defined in a single object (a Material) and shared among the many other systems such as the Kernel or BoundaryCondition Systems.\nI was trying to share the values obtained in the Materials System with an object in the InterfaceKernels System and seemed not to work.  Can the Materials System share with only Kernel System and BoundaryCondition System?\nPlease help. S. Thomas",
          "url": "https://github.com/idaholab/moose/discussions/27963",
          "updatedAt": "2024-06-22T00:06:34Z",
          "publishedAt": "2024-06-21T20:06:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nInterface kernels have slightly different routine names for retrieving material properties, notably because they need to retrieve both the element and neighbor material properties\nLook for examples among existing interface kernels",
                  "url": "https://github.com/idaholab/moose/discussions/27963#discussioncomment-9844478",
                  "updatedAt": "2024-06-21T23:59:52Z",
                  "publishedAt": "2024-06-21T23:59:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Crack does not propagate with XFEM 3D",
          "author": {
            "login": "leeczway"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi developers,\nI am using the XFEM module to do pressurized cracking, and it works as expected in 2D case with the userobjects of LineSegmentCutUserObject and XFEMRankTwoTensorMarkerUserObject. But the similar combination of CircleCutUserObject and XFEMRankTwoTensorMarkerUserObject does not produce crack propagation even if the Maxprinciple stress was far exceeded.\nIs there a way to do 3D crack propagation simulation without using CrackMeshCut3DUserObject, since it seems cracking direction and speed has to be prescribled with options like growth_direction and growth_rate?\nThanks for your help!\nWei",
          "url": "https://github.com/idaholab/moose/discussions/27946",
          "updatedAt": "2024-06-21T22:56:56Z",
          "publishedAt": "2024-06-19T14:56:32Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@hugary1995",
                  "url": "https://github.com/idaholab/moose/discussions/27946#discussioncomment-9819011",
                  "updatedAt": "2024-06-19T15:06:20Z",
                  "publishedAt": "2024-06-19T15:06:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'll have to defer this question to @jiangwen84 @bwspenc @lynnmunday",
                          "url": "https://github.com/idaholab/moose/discussions/27946#discussioncomment-9822200",
                          "updatedAt": "2024-06-19T21:49:45Z",
                          "publishedAt": "2024-06-19T21:49:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "I haven't done much with the 3d xfem code but I think this test does what you want: moose/modules/xfem/test/tests/solid_mechanics_basic/edge_crack_3d_mhs.i\nThis uses CrackMeshCut3DUserObject to grow the crack.  The growth rate function is just used to grow the crack over that time step to see if it reaches a size where it will no longer grow.  The crack direction is still determined by a fracture integral.  The nucleation objects won't nucleate a new crack in 3D.  You would have to write code to nucleate a small circular crack in 3D.  I think it would follow the steps used to nucleate and grow cracks in 2D so it should be possible.",
                          "url": "https://github.com/idaholab/moose/discussions/27946#discussioncomment-9844293",
                          "updatedAt": "2024-06-22T20:22:50Z",
                          "publishedAt": "2024-06-21T22:56:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get the consumed CPU time in each time step?",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi all,\nWe can get the total consumed CPU time when we finish the calculation. But how do we get the total consumed CPU time in each time step?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/27954",
          "updatedAt": "2024-06-21T13:33:43Z",
          "publishedAt": "2024-06-20T16:08:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI'm not sure we have something for this.\nYou ll want to create a postprocessor to report the delta between the starting CPU time and the current CPU time. or do differences between time steps.\nYou should look through the framework folder first, I may have missed it. It would be in the PPs, Reporters or VPPs if it exists\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27954#discussioncomment-9831231",
                  "updatedAt": "2024-06-20T16:34:14Z",
                  "publishedAt": "2024-06-20T16:34:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Hi, I have searched through the framework folder, but I can not find any type (PPS, Reporters or VPP) that can report the current CPU time.",
                          "url": "https://github.com/idaholab/moose/discussions/27954#discussioncomment-9834647",
                          "updatedAt": "2024-06-21T01:40:15Z",
                          "publishedAt": "2024-06-21T01:40:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok thanks for double checking\nYou can look at the perf graph for this otherwise.\nThe perf graph will have a lot of the relevant code to perform this measurement",
                          "url": "https://github.com/idaholab/moose/discussions/27954#discussioncomment-9839992",
                          "updatedAt": "2024-06-21T13:23:16Z",
                          "publishedAt": "2024-06-21T13:23:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Ok, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/27954#discussioncomment-9840100",
                          "updatedAt": "2024-06-21T13:33:45Z",
                          "publishedAt": "2024-06-21T13:33:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Contravariant basis vectors in Shell Element",
          "author": {
            "login": "Kavan-Khaledi"
          },
          "bodyText": "Dear MOOSE team,\nI am trying to understand the code for the solid shell element in MOOSE. The implementation of the element follows exactly the formulations given in Dvorkin and Bathe (1984) for the MITC4 shell element. However, I ran into a problem when using the element on unstructured meshes. The element works well for structured meshes, but it gives incorrect results for unstructured meshes, and this I believe is due to incorrect contravariant basis vectors introduced to rotate the stiffness matrix. As an example, I have copied the results of simple tension and bending tests on a clamped plate with structured and unstructured meshes (the input file and the mesh file are attached). As you can see, the results of the unstructured mesh are not correct.\n\nTo solve the problem, I tested the following change in the code and now the shell element works fine for unstructured meshes.\nNew results on unstructured mesh:\n\nCurrent Contravariant basis vector calucation in ADComputeIncrementalShellStrain:\nADRankTwoTensor gmninv = local_rotation_mat.transpose() * gmninv_temp * local_rotation_mat;\n      (*_ge[j])[i](0, 0) = (gmninv * (*_dxyz_dxi[j])[i]) * e1;\n      (*_ge[j])[i](0, 1) = (gmninv * (*_dxyz_dxi[j])[i]) * e2;\n      (*_ge[j])[i](0, 2) = (gmninv * (*_dxyz_dxi[j])[i]) * e3;\n      (*_ge[j])[i](1, 0) = (gmninv * (*_dxyz_deta[j])[i]) * e1;\n      (*_ge[j])[i](1, 1) = (gmninv * (*_dxyz_deta[j])[i]) * e2;\n      (*_ge[j])[i](1, 2) = (gmninv * (*_dxyz_deta[j])[i]) * e3;\n      (*_ge[j])[i](2, 0) = (gmninv * (*_dxyz_dzeta[j])[i]) * e1;\n      (*_ge[j])[i](2, 1) = (gmninv * (*_dxyz_dzeta[j])[i]) * e2;\n      (*_ge[j])[i](2, 2) = (gmninv * (*_dxyz_dzeta[j])[i]) * e3;\n\nSuggested changes to calculate the contravariant basis vectors\n      ADRealVectorValue gi0=((*_dxyz_deta[j])[i].cross((*_dxyz_dzeta[j])[i]))/((*_dxyz_dxi[j])[i]*((*_dxyz_deta[j])[i].cross((*_dxyz_dzeta[j])[i])));\n      ADRealVectorValue gi1=((*_dxyz_dzeta[j])[i].cross((*_dxyz_dxi[j])[i]))/((*_dxyz_dxi[j])[i]*((*_dxyz_deta[j])[i].cross((*_dxyz_dzeta[j])[i])));\n      ADRealVectorValue gi2=((*_dxyz_dxi[j])[i].cross((*_dxyz_deta[j])[i]))/((*_dxyz_dxi[j])[i]*((*_dxyz_deta[j])[i].cross((*_dxyz_dzeta[j])[i])));\n\n      (*_ge[j])[i](0, 0) = gi0 * e1;\n      (*_ge[j])[i](0, 1) = gi0 * e2;\n      (*_ge[j])[i](0, 2) = gi0 * e3;\n      (*_ge[j])[i](1, 0) = gi1 * e1;\n      (*_ge[j])[i](1, 1) = gi1 * e2;\n      (*_ge[j])[i](1, 2) = gi1 * e3;\n      (*_ge[j])[i](2, 0) = gi2 * e1;\n      (*_ge[j])[i](2, 1) = gi2 * e2;\n      (*_ge[j])[i](2, 2) = gi2 * e3;\n\nThe above contravarient basis vectors gi0, gi1, gi2 were calculated through:\n$gi0=\\dfrac{(g_s \\times g_t)}{g_r.(g_s \\times g_t)}$\n$gi1=\\dfrac{(g_t \\times g_r)}{g_r.(g_s \\times g_t)}$\n$gi2=\\dfrac{(g_r \\times g_s)}{g_r.(g_s \\times g_t)}$\nwhere, $g_r, g_s, g_t$ are covariant basis vectors.\nHowever, I have not performed any other tests. Therefore, I decided to post the issue here for discussion first.\nShell_MITC4_test.zip\nBest regards,\nKavan",
          "url": "https://github.com/idaholab/moose/discussions/27038",
          "updatedAt": "2024-06-21T09:48:15Z",
          "publishedAt": "2024-03-08T12:43:15Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cbolisetti",
                  "url": "https://github.com/idaholab/moose/discussions/27038#discussioncomment-8721192",
                  "updatedAt": "2024-03-08T15:11:00Z",
                  "publishedAt": "2024-03-08T15:10:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "Thanks for looking into this, and for your input! I'll look into this tomorrow.\nJust so you know, the current version of the shell also only works for flat geometries because the rotation DOFs are in the element local coordinate system, so if there is a change of orientation from one element to another they are not compatible. I have a branch where we have a pretty major update that corrects that, but we haven't merged it in yet because we are still seeing some inconsistencies. I wonder if the changes you proposed might address those.",
                          "url": "https://github.com/idaholab/moose/discussions/27038#discussioncomment-8766164",
                          "updatedAt": "2024-03-13T00:03:25Z",
                          "publishedAt": "2024-03-13T00:03:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Kavan-Khaledi"
                          },
                          "bodyText": "@bwspenc have you been able to find time to look into this? The original MITC4 element was actually developed for non-flat shells, and I think it should also work for curved geometries with unstructured meshes if the compatibility of local coordinates between all elements is preserved.",
                          "url": "https://github.com/idaholab/moose/discussions/27038#discussioncomment-8879396",
                          "updatedAt": "2024-03-24T05:43:48Z",
                          "publishedAt": "2024-03-22T15:09:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "Sorry for being so slow to get to this! I've just been swamped with other things. We have someone in our team that is going to be looking into this.\nI have to admit that I don't understand how one would go about maintaining the compatibility of local coordinates between elements for unstructured meshes or curved geometries. It's been a little while since I've looked into that in depth, but the 1984 Dvorkin & Bathe paper didn't really give any information on that as I recall. Maybe I'm missing something, but on a curved geometry, it seems like the rotational coordinates, which I understand need to be in the local plane of the element, would inherently be different for two neighboring elements if their orientations are different. That would be a problem for any nodes that are connected to multiple elements oriented on different planes.\nWe have a set of changes that have been in the works for a while that modify the element to have 3 rotational DOFs per node, aligned with the Cartesian axes, and then transforms those to a local coordinate system unique to each element. That does result in a zero-energy drilling DOF if you are modeling a flat surface, but we found that can be suppressed easily by giving it a penalty rotational stiffness. They're on this branch:\nhttps://github.com/bwspenc/moose/tree/shell_new\nI'm interested in your thoughts on this.",
                          "url": "https://github.com/idaholab/moose/discussions/27038#discussioncomment-9596553",
                          "updatedAt": "2024-05-29T17:38:56Z",
                          "publishedAt": "2024-05-29T17:23:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Kavan-Khaledi"
                  },
                  "bodyText": "@bwspenc First of all, thanks for sharing the new shell formulation.\nFYI, following the discussion #23874, we decided to extend the existing four-noded shell element in MOOSE to a six-noded triangular element, primarily for applications in modeling support systems in tunnel construction. Another requirement for our application was adding orthotropic elasticity to the shell model. These two requirements, i.e. triangular geometry and anisotropic material, necessitated a slight deviation from Dvorkin\u2019s paper by introducing a compatible material coordinate system. This not only maintains the compatibility of local stresses but also makes the back-calculation of local force and moment resultants possible. To clarify, let me summarize the coordinate systems in Dvorkin\u2019s paper and our modifications. This might be relevant to your new shell formulation as well. Please correct me if I have misunderstood anything.\nThe following coordinate systems are used for the MITC4 shell element (I am trying to use the same terminology as used in the paper):\n\n\nThe stationary Cartesian coordinate system $x_1\u2212x_2\u2212x_3$: This is the global coordinate system in which the nodal locations and displacements are described (equations 1 and 2).\n\n\nThe local nodal coordinate system $V_1\u2212V_2\u2212V_n$ : Three perpendicular unit vectors are defined at each node. The director vector $V_n$ is the node normal vector. The other two unit vectors, $V_1$ and $V_2$, are the axes around which the rotational degrees of freedom are defined at each node. In Dvorkin\u2019s paper, a simple rule is used to maintain the compatibility of in-plane vectors $V_1$ and $V_2$ between elements. This convention is also applicable to curved geometries and unstructured meshes. The convention is described in the caption of Figure 1 and has been correctly implemented in MOOSE.\n\n\n\n\n\nCovariant base vectors $g_1,g_2,g_3 (g_i=dx/dr_i)$: These base vectors are used to define the Green-Lagrange strain components in the convected coordinates ($r_1,r_2,r_3$), as shown in equation 20. These strains are not compatible between elements because the orientation of $g_1,g_2,g_3$ varies from one element to another in curved geometries (or unstructured meshes). However, they become compatible once transformed to the stationary global coordinate system through the element Jacobian transformation (as implemented in MOOSE).\n\ncovariant_transformation_matrix[j])[i] = J\nThe transformation of stress to global coordinate is through the inverse of Jacobean.\n(*_contravariant_transformation_matrix[j])[i] = (*_covariant_transformation_matrix[j])[i].inverse();\n\nThe tricky part in the paper is hidden in the definition of the fourth-order contravariant stiffness matrix, where the elasticity tensor is transformed to a local coordinate system with orthonormal base vectors $\\hat{e}_1,\\hat{e}_2,\\hat{e}_3$, i.e.\n\n\nThe $g^1, g^2, g^3$ are contravariant base vectors of the convected coordinates $r_1,r_2,r_3$.\nI must admit, the mathematics of this part is beyond my knowledge, especially equations 11 and 12 in the paper. However, what I understand is that by multiplying this elasticity tensor with the convected strain tensor, the stress components are obtained in the $\\hat{e_{i}}$ coordinate system. The contravariant vectors $g^1, g^2, g^3$ that I showed in my first post above have an important property, $g^i . g_j = \\delta_{ij}$. This property brings the local stresses to the $\\hat{e}_1,\\hat{e}_2,\\hat{e}_3$ coordinate.\nDvorkin\u2019s paper suggests the following method for calculating the $\\hat{e}_1,\\hat{e}_2,\\hat{e}_3$ unit vectors:\n\nHowever, If we use the above approach for curved geometries, we lose the compatibility of $\\hat{e}_i$ vectors between elements because the $g_i$ base vectors are incompatible. This is also a problem when using anisotropic shells. Therefore, we changed this and incorporated two options in our triangular shell element:\nOption 1: $\\hat{e}_3$ is the normal vector to the shell element. The user defines a vector in the input file (in the strain block). This user-defined vector is projected onto the shell plane to construct $\\hat{e}_1$. Then, $\\hat{e}_2=\\hat{e}_3\\times\\hat{e}_1$\nOption 2: If the user does not provide any vector, the same method as described above in Figure 1 is used to preserve the compatibility of local coordinates.\nNow, having  compatible base vectors $\\hat{e}_1,\\hat{e}_2,\\hat{e}_3$  at the element level, we can transform the global stresses to this local coordinate system and back-calculate the force and moment resultants.\nSorry for the long post!!",
                  "url": "https://github.com/idaholab/moose/discussions/27038#discussioncomment-9838185",
                  "updatedAt": "2024-07-15T06:03:43Z",
                  "publishedAt": "2024-06-21T09:48:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "There is nucleation signal, but the corresponding reserved order parameter can not be observed",
          "author": {
            "login": "YXY101676"
          },
          "bodyText": "Here is my input file\uff1a\n\n\n\nThe nucleation signal can be seen, but the corresponding order parameter gr9 is 0",
          "url": "https://github.com/idaholab/moose/discussions/27935",
          "updatedAt": "2024-06-21T02:41:59Z",
          "publishedAt": "2024-06-19T03:00:06Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "YXY101676"
                  },
                  "bodyText": "Does this mean that the preserving order parameter of the newly inserted nucleation is GR0\uff1f",
                  "url": "https://github.com/idaholab/moose/discussions/27935#discussioncomment-9812564",
                  "updatedAt": "2024-06-19T03:16:46Z",
                  "publishedAt": "2024-06-19T03:16:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@permcody on grain nucleation",
                          "url": "https://github.com/idaholab/moose/discussions/27935#discussioncomment-9812672",
                          "updatedAt": "2024-06-19T03:37:11Z",
                          "publishedAt": "2024-06-19T03:37:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "If I recall correctly, once you see that message, the GrainTracker will \"move\" your grain from the reserved order parameter to one of the \"normal\" order parameters to continue evolving it. Try looking at the reserved order parameter (in your case gr9) one time step earlier, unless your insertion is happening in this step. In any case, visualizing the staging area may not be very interesting. There should be a message about which OP the new grain got remapped to right after that message.\nI assume you found the page on Nucleation here: https://mooseframework.inl.gov/modules/phase_field/Nucleation/DiscreteNucleation.html\nThere are also a few test cases checked in for nucleation that are very small and run quickly. You might run those and observe the behavior along with the screen output. It will help you understand a bit more of what's going on in your simulation.",
                          "url": "https://github.com/idaholab/moose/discussions/27935#discussioncomment-9822486",
                          "updatedAt": "2024-06-19T22:51:26Z",
                          "publishedAt": "2024-06-19T22:51:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YXY101676"
                          },
                          "bodyText": "https://mooseframework.inl.gov/modules/phase_field/Nucleation/DiscreteNucleation.html\nI learned about nucleation on the above page, but there were no examples of polycrystalline nucleation, so I couldn't get more specific guidance.\nAnd in my case, at Step 27, there's a nucleation signal:\n\nBut I couldn't find the output of gr7 in the visualizations of steps 26 and 27, and there was no signal like a rema.\nThere is no output from GR9 until step 30, and there is always evolution\uff1a",
                          "url": "https://github.com/idaholab/moose/discussions/27935#discussioncomment-9823127",
                          "updatedAt": "2024-06-20T01:21:53Z",
                          "publishedAt": "2024-06-20T01:21:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "Oh\u2026 I don\u2019t like seeing those \u201csplit grain detected\u201d messages. Something\nisn\u2019t right with what\u2019s being detected.\n\nEither I or somebody else is going to have to dig into the code, with this\ninput. I hate to say this, but you might try a different random seed to see\nif you can get past this. It might be the case that I just disable split\ngrain detection in a simulation where we shouldn\u2019t expect that (most if not\nall Voroni-based initial conditions).\n\u2026\nOn Wed, Jun 19, 2024 at 7:22\u202fPM YXY101676 ***@***.***> wrote:\n\n https://mooseframework.inl.gov/modules/phase_field/Nucleation/DiscreteNucleation.html\n I learned about nucleation on the above page, but there were no examples\n of polycrystalline nucleation, so I couldn't get more specific guidance.\n And in my case, at Step 27, there's a nucleation signal:\n image.png (view on web)\n <https://github.com/idaholab/moose/assets/154942901/7e154485-1b50-4be7-8f0f-ece5ad6a5da1>\n But I couldn't find the output of gr7 in the visualizations of steps 26\n and 27, and there was no signal like a rema.\n There is no output from GR9 until step 30, and there is always evolution\uff1a\n image.png (view on web)\n <https://github.com/idaholab/moose/assets/154942901/8f84cb8a-336c-463d-b144-d6d4f03b5162>\n image.png (view on web)\n <https://github.com/idaholab/moose/assets/154942901/46799ef4-e5cd-4fdc-a20f-c361b7cc41bc>\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#27935 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAXFOIGJNEO7LLF2RXCQZMDZIIVENAVCNFSM6AAAAABJRFLAHKVHI2DSMVQWIX3LMV43SRDJONRXK43TNFXW4Q3PNVWWK3TUHM4TQMRTGEZDO>\n .\n You are receiving this because you were mentioned.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/27935#discussioncomment-9823253",
                  "updatedAt": "2024-06-20T01:39:29Z",
                  "publishedAt": "2024-06-20T01:39:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "YXY101676"
                          },
                          "bodyText": "So I should change the initial grain structure to avoid the crack problem? What does this GR9 stand for? Aren't they new nucleated grains",
                          "url": "https://github.com/idaholab/moose/discussions/27935#discussioncomment-9823317",
                          "updatedAt": "2024-06-20T01:48:25Z",
                          "publishedAt": "2024-06-20T01:48:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YXY101676"
                          },
                          "bodyText": "Does anyone use moose to complete the nucleation and grain growth process of polycrystalline structure? This is very important to me",
                          "url": "https://github.com/idaholab/moose/discussions/27935#discussioncomment-9823829",
                          "updatedAt": "2024-06-20T03:20:17Z",
                          "publishedAt": "2024-06-20T03:20:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "While definitely not a solution, changing the initial grain structure may get you past the immediate problem so it\u2019s worth a try.  GR9 is simply the name of one of your order parameter fields. In your input file your input file, you requested 10 order parameters with a prefix of \u201cgr\u201d so they are gr0-gr9. The highest numbered order parameter will be the reserved field for nucleation. So to answer your last question. It\u2019s not a nucleated grain, it\u2019s the field that holds your grains as the are starting to nucleate until they are large enough to recognize and transfer.\nWe have done polycrystalline simulations with grain nucleation. @dschwen, do we have an sample input files for that kind of sim?",
                          "url": "https://github.com/idaholab/moose/discussions/27935#discussioncomment-9828407",
                          "updatedAt": "2024-06-20T12:15:16Z",
                          "publishedAt": "2024-06-20T12:15:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YXY101676"
                          },
                          "bodyText": "But the holdtime I set it to 0, it shouldn't actually be here this long",
                          "url": "https://github.com/idaholab/moose/discussions/27935#discussioncomment-9834767",
                          "updatedAt": "2024-06-21T02:06:25Z",
                          "publishedAt": "2024-06-21T02:06:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YXY101676"
                          },
                          "bodyText": "To what extent will be mapped by graintracker, is it set by the reserve parameter",
                          "url": "https://github.com/idaholab/moose/discussions/27935#discussioncomment-9834969",
                          "updatedAt": "2024-06-21T02:42:00Z",
                          "publishedAt": "2024-06-21T02:41:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fractional inverse Laplacian in energy",
          "author": {
            "login": "rnpratoori"
          },
          "bodyText": "Hello,\nI am working on a phase separation problem for block copolymers. Based on the basic phase field equations, I have a $E_d$ term that has a fractional inverse Laplacian operator. The complete equation is given here -\n\nwhere $-\\Delta^{-1/2}$ is the fractional inverse Laplacian.\nI have a general understanding that Laplacian is implemented in the electromagnetism module, but is there an instance of its inverse? How can I implement it in my MOOSE code?",
          "url": "https://github.com/idaholab/moose/discussions/27956",
          "updatedAt": "2024-06-20T17:33:32Z",
          "publishedAt": "2024-06-20T17:33:31Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "In GDB, how can I find out which element is currently being calculated and its material information?",
          "author": {
            "login": "Yasunaoka"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello moose community! I'm encountering a bit of numerical problems with my current models, so I'd like to check step by step how they change.\nI've found that gdb might meet my needs, but what's in the debugging page isn't quite enough for me.\nI've now got gdb running successfully and can perform breakpoints and stepping where I want.\nHowever, when I stop at a particular location in a particular file and want to query some data about the current computational process (e.g. _current_elem,_displacement,_stress, etc.), I don't really know how to get them.\nI did query the relevant commands, such as info locals, info args, info variables, but I didn't find any of the above required data. Can anyone help me with this? Any suggestions are much appreciated!\nSincerely.\nSen Huang",
          "url": "https://github.com/idaholab/moose/discussions/27953",
          "updatedAt": "2024-07-07T16:57:00Z",
          "publishedAt": "2024-06-20T14:29:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThese will be available in the computeValue / computeQpProperty etc, the innermost call in the element loops.\nThey wont be elsewhere and they wont be initialized.\ninfo locals\n\nshould work. Else you can use p <name of variable> iirc\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27953#discussioncomment-9831301",
                  "updatedAt": "2024-06-20T16:40:33Z",
                  "publishedAt": "2024-06-20T16:40:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}