{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wNy0zMFQwOToyODo0Ny0wNTowMM4Aapdv"
    },
    "edges": [
      {
        "node": {
          "title": "How to compile and run an external program in MOOSE?",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello, everyone.\nI want to know how can I compile and run an external program in MOOSE? The code is using fortran. Should I put the codes in the folder src and compile directly?\nEthan",
          "url": "https://github.com/idaholab/moose/discussions/28249",
          "updatedAt": "2024-08-02T01:54:55Z",
          "publishedAt": "2024-07-29T08:19:58Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou could try to do that but it's not very tidy.\nWe usually drop external codes in a contrib folder then modify the Makefile to compile it there\nYou can see examples of this with Cardinal on the neams-th-coe GitHub\nThere are also examples of compiling Fortran in the solid mechanics module for the UMAT",
                  "url": "https://github.com/idaholab/moose/discussions/28249#discussioncomment-10177838",
                  "updatedAt": "2024-07-29T09:34:36Z",
                  "publishedAt": "2024-07-29T09:34:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Thank you Giud. I'll check the Cardinal code.",
                          "url": "https://github.com/idaholab/moose/discussions/28249#discussioncomment-10218239",
                          "updatedAt": "2024-08-02T01:54:56Z",
                          "publishedAt": "2024-08-02T01:54:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Potential ambiguity in the definition of Flow channel area when combined with num_rods",
          "author": {
            "login": "Jake-HW-Miles"
          },
          "bodyText": "Hi there,\nThis may be a bit of a silly questions. However I want to make sure I am not barking up the wrong tree.\nSo I am constructing a Heat exchanger using components and am unsure which area to use. If I have a heat exchanger which has N tubes, each with an area of A, should be flow channel area be N*A or simply A? (I have seen examples of both)",
          "url": "https://github.com/idaholab/moose/discussions/28263",
          "updatedAt": "2024-08-01T17:27:11Z",
          "publishedAt": "2024-07-30T08:52:40Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI could see it coded either way, but it's likely expecting a single channel area. The parameter should say\nwhich object is it so we can update the parameter description?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10192194",
                  "updatedAt": "2024-07-30T15:23:04Z",
                  "publishedAt": "2024-07-30T15:23:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "I have been using HeatStructureCylindrical which is why I mention \"num_rods\", however I assume that all HS are the same. Thank you for clearing this up!",
                          "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10192224",
                          "updatedAt": "2024-07-30T15:25:43Z",
                          "publishedAt": "2024-07-30T15:25:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "But the Area (A) is stemming from the required input for FlowChannel1Phase",
                          "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10192226",
                          "updatedAt": "2024-07-30T15:26:24Z",
                          "publishedAt": "2024-07-30T15:26:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So you have a component that is both a FlowChannel1Phase and a HeatstructureCylindrical? That does not seem right?\nThe volume in HSCylindrical is\n      _volume.push_back(_num_rods * M_PI * (r[i + 1] * r[i + 1] - r[i] * r[i]) * _length);\n\nso the number of rods is multiplying the single-rod design for that class",
                          "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10192267",
                          "updatedAt": "2024-07-30T15:29:29Z",
                          "publishedAt": "2024-07-30T15:29:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Jake-HW-Miles"
                          },
                          "bodyText": "Apologies for not being clear, this is my heat exchanger group (reduced input):\n    [hx]\n        [pipe]\n            type = FlowChannel1Phase\n            position = '${pri_x_core} ${pri_y_core} 0.'\n            orientation = ${right}\n            length = ${hx_length}\n            n_elems = ${n_hx_elements}\n            A = '${fparse **tube_N** * pi * hx_dia_pri * hx_dia_pri * 0.25}'\n            D_h = ${hx_dia_pri}\n      \n            fp = coolant\n            initial_p = ${pri_press}\n            initial_vel = ${vel_ini_pri}\n            initial_T = ${initial_T_hx}\n        []\n        [wall]\n            type = HeatStructureCylindrical\n            orientation = ${right}\n            position = '${pri_x_core} ${pri_y_core} 0.'\n            length = ${hx_length}\n\n            n_elems = ${n_hx_elements}\n            \n            names = 'hx_wall'\n            widths = '${hx_wall_thickness}'\n            n_part_elems = 1\n            solid_properties = 'alloy625'\n            solid_properties_T_ref = '${units 600 degC -> K}'\n        \n            initial_T = ${initial_T_hx}\n            inner_radius = '${fparse hx_dia_pri / 2}'\n            num_rods = ${**tube_N**}\n        []\n    []\n\nI have tried to highlight references to the number of hx tubes, but based on the previous answer, it seems I should remove it from the flow channel",
                          "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10192302",
                          "updatedAt": "2024-07-30T15:33:04Z",
                          "publishedAt": "2024-07-30T15:33:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think so.\n@joshuahansel to check",
                          "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10214038",
                          "updatedAt": "2024-08-01T15:20:37Z",
                          "publishedAt": "2024-08-01T15:20:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "joshuahansel"
                  },
                  "bodyText": "Good question, documentation is lacking on this topic.\nYour flow channel should represent the total flow area. Make sure to set the heated perimeter parameter P_hf in your HeatTransferFromHeatStructure1Phase component to correspond to the total as well. D_h should be the same for individual and total.",
                  "url": "https://github.com/idaholab/moose/discussions/28263#discussioncomment-10215134",
                  "updatedAt": "2024-08-01T17:27:11Z",
                  "publishedAt": "2024-08-01T17:27:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can I use Moose to calculate resonance modes?",
          "author": {
            "login": "ghmechamania"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi all,\nI'm new to FEM and I'm investigating if I can use Moose for my new project.\nFor this project I would like to calculate the resonance frequencies and modes of 2D an 3D objects.\nThis to be able to synthesize the sound an object would make when hitting it at some position.\nSo can I use Moose to calculate these modes? If so, can you give me some hints how to tackle this?\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/28280",
          "updatedAt": "2024-08-01T13:57:41Z",
          "publishedAt": "2024-08-01T13:20:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "maxnezdyur"
                  },
                  "bodyText": "This may be what you are looking for https://mooseframework.inl.gov/modules/solid_mechanics/1d_elastic_waves.html\nThere are two ways to do this, but the modal analysis way would get you more modes at once without needing to sweep.",
                  "url": "https://github.com/idaholab/moose/discussions/28280#discussioncomment-10213173",
                  "updatedAt": "2024-08-01T13:57:41Z",
                  "publishedAt": "2024-08-01T13:57:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Refinement (custom initial MOOSE mesh)",
          "author": {
            "login": "mangerij"
          },
          "bodyText": "Hi,\nIs this AMR scheme possible (attached)?\nNote that the dashed blue line separates two blocks.\nAt t = 0, the mesh needs to look like c)\nHow would I make a) with MOOSE mesh? is it possible to do a uniform refinement in the top block only to get to c) and still preserve the coarsening levels?\nas the simulation evolves, we would like to be able to move between the four levels.\nthanks",
          "url": "https://github.com/idaholab/moose/discussions/28272",
          "updatedAt": "2024-07-31T15:17:59Z",
          "publishedAt": "2024-07-31T13:24:40Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt's not possible with all discretizations. There are more than two levels of refinement  difference between two neighboring cells\nWe support one level of refinement. Beyond that you will need to add an interface kernel and implement a special treatment\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10201625",
                  "updatedAt": "2024-07-31T13:29:43Z",
                  "publishedAt": "2024-07-31T13:29:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "I was very careful to ensure there is only one level of refinement between neighboring cells here.",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10201826",
                          "updatedAt": "2024-07-31T13:46:03Z",
                          "publishedAt": "2024-07-31T13:46:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I must not have zoomed enough on d)\nThis would be supported then",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10201886",
                          "updatedAt": "2024-07-31T13:51:14Z",
                          "publishedAt": "2024-07-31T13:51:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Though it is only supported when libmesh performs this refinement.\nIf this is done in an external mesher and imported in exodus, it s not natively supported",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10201899",
                          "updatedAt": "2024-07-31T13:52:14Z",
                          "publishedAt": "2024-07-31T13:52:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We would need to add the refinement flags to each element when it's read and possibly create the parent elements too",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10201950",
                          "updatedAt": "2024-07-31T13:55:27Z",
                          "publishedAt": "2024-07-31T13:55:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "yeah I only want to do this with the MOOSE mesh but confused on how to make initially a)\nand then if uniform_refine is block restrictable",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10202070",
                          "updatedAt": "2024-07-31T14:04:03Z",
                          "publishedAt": "2024-07-31T14:04:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can make initial a) with the RefineSidesetGenerator though you may want to modify it a bit to get single sided refinement\nThen for block restricted refinement use the RefineBlockGenerator\nThey can be chained in the Mesh block",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10202106",
                          "updatedAt": "2024-07-31T14:07:59Z",
                          "publishedAt": "2024-07-31T14:07:57Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "Beautiful! thanks @GiudGiud  working example:\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 2\n    ny = 2\n    nz = 3\n    xmin = -10.0\n    xmax = 10.0\n    ymin = -10.0\n    ymax = 10.0\n    zmin = -10.0\n    zmax = 10.0\n    elem_type = HEX8\n  []\n  [subdomains]\n    type = SubdomainBoundingBoxGenerator\n    input = gen\n    bottom_left = '-10.0 -10.0 -20.0'\n    block_id = '1'\n    top_right = '10.0 10.0 0.0'\n    location = INSIDE\n  []\n  [film_interface]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = subdomains\n    primary_block = 0\n    paired_block = 1\n    new_boundary = 52\n  []\n  [refine_block0]\n    type = RefineBlockGenerator\n    input = film_interface\n    block = '0'\n    refinement = 1\n  []\n  [refine_sub]\n    type = RefineSidesetGenerator\n    input = refine_block0\n    boundaries = '52'\n    refinement = 2\n    boundary_side = 'secondary'\n    enable_neighbor_refinement = false\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10202478",
                          "updatedAt": "2024-07-31T14:44:04Z",
                          "publishedAt": "2024-07-31T14:42:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mangerij"
                          },
                          "bodyText": "@GiudGiud one more question: will RefineBlockGenerator rewrite the min h_level for AMR?",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10202789",
                          "updatedAt": "2024-07-31T15:15:08Z",
                          "publishedAt": "2024-07-31T15:15:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No you can recover the refined elements with mesh coarsening if needed\nAnd they can be refined further by AMR as well",
                          "url": "https://github.com/idaholab/moose/discussions/28272#discussioncomment-10202821",
                          "updatedAt": "2024-07-31T15:18:00Z",
                          "publishedAt": "2024-07-31T15:17:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "An inquiry about the availability of Arbitrary-Lagrangian-Eulerian (ALE) function",
          "author": {
            "login": "NINGYURICHARD"
          },
          "bodyText": "I am a beginner for MOOSE. Recently, I read the paper \"An arbitrary Lagrangian-Eulerian finite element method for finite strain plasticity\"\nNumerical Meth Engineering - 2003 - Armero - An arbitrary Lagrangian Eulerian finite element method for finite strain.pdf\n(attached), and I want to reproduce some benchmarks using direct ALE methods from this paper. This paper uses ALE method to solve finite strain plasticity, and the ALE contains 3 phases:\n\nLagrangian phase e.g. total Lagrangian formulation solved on reference configuration (a always fixed mesh configuration)\nSmoothing phase\nAdvection phase\n\nTherefore, could anyone tell me whether MOOSE supports the ALE implementation described above? If not, I think the difficult part may be the calculation of integrals on reference configuration, because we need to change the Jacobian inside the integral. Another difficult part may be how to restart the iteration after the advection phase (after re-assigning internal variables on reference configuration). Could anyone give me some help or advice on how to implement the ALE algorithm above using MOOSE? Thank you very much!\nRegards,\nRichard",
          "url": "https://github.com/idaholab/moose/discussions/28245",
          "updatedAt": "2024-07-31T12:06:51Z",
          "publishedAt": "2024-07-28T13:54:06Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "We support ALE in the Navier Stokes module. The laser meltpool example (under modules/nnavier_stokes/examples) and the kernels involved in that input show how to implement ALE in MOOSE\nWe have not built training material for this yet\n@lindsayad for awareness",
                  "url": "https://github.com/idaholab/moose/discussions/28245#discussioncomment-10184424",
                  "updatedAt": "2024-07-29T22:31:02Z",
                  "publishedAt": "2024-07-29T22:31:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "NINGYURICHARD"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/28245#discussioncomment-10200773",
                          "updatedAt": "2024-07-31T12:06:53Z",
                          "publishedAt": "2024-07-31T12:06:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "An inquiry about the total Lagrangian formulation of ComputeMultipleCrystalPlasticityStress class",
          "author": {
            "login": "NINGYURICHARD"
          },
          "bodyText": "Hello everyone!\nCould anyone tell me whether the ComputeMultipleCrystalPlasticityStress class contains the total Lagrangian formulation? I noticed that the updated Lagrangian incremental form is used in this class on\nhttps://mooseframework.inl.gov/source/materials/crystal_plasticity/ComputeMultipleCrystalPlasticityStress.html\nThank you very much!\nRegards,\nRichard",
          "url": "https://github.com/idaholab/moose/discussions/28248",
          "updatedAt": "2024-07-31T12:06:06Z",
          "publishedAt": "2024-07-29T06:45:32Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dewenyushu",
                  "url": "https://github.com/idaholab/moose/discussions/28248#discussioncomment-10184412",
                  "updatedAt": "2024-07-29T22:27:39Z",
                  "publishedAt": "2024-07-29T22:27:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dewenyushu"
                  },
                  "bodyText": "No, we only have this form in this class. As far as I know, this is the only form available in MOOSE.",
                  "url": "https://github.com/idaholab/moose/discussions/28248#discussioncomment-10192273",
                  "updatedAt": "2024-07-30T15:29:58Z",
                  "publishedAt": "2024-07-30T15:29:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "NINGYURICHARD"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/28248#discussioncomment-10200762",
                          "updatedAt": "2024-07-31T12:06:03Z",
                          "publishedAt": "2024-07-31T12:06:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Threashold for residual",
          "author": {
            "login": "ashishdhole"
          },
          "bodyText": "Hello,\nI am working on grain growth model with particles. In my simulations, grain growth stops after certain time and reach a steady state. Although I could see the grain g rowth rate to be reducing with time, They never reach a steady state. instead, dt keeps reducing until the point when the simulation terminates with an error that dt_min is reached. is there a way I can define in my code the minimum threadhold beyond which the residual becomes zero?\nRegards,\nAshish",
          "url": "https://github.com/idaholab/moose/discussions/28247",
          "updatedAt": "2024-07-30T22:30:40Z",
          "publishedAt": "2024-07-29T03:32:45Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is not the normal progression of the simulation. The solver is failing which is why the time step keep getting reduced.\nPlease see our \"troubleshooting failed solves\" instructions.\nThe first step is to identify whether the linear or nonlinear solve is failing\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28247#discussioncomment-10176039",
                  "updatedAt": "2024-07-29T06:13:23Z",
                  "publishedAt": "2024-07-29T06:13:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "what should be my next step after identifying the fail?\nI am certain that non-linear solve is failing.\nfollowing is what my executioner block looks like\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = PJFNK #Preconditioned JFNK (default)\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre    boomeramg'\n  steady_state_detection = true\n  steady_state_start_time = 0\n  steady_state_tolerance = 1e-8\n  l_abs_tol = 1.0e-3\n  nl_abs_tol = 1.0e-3\n  l_tol = 1.0e-3\n  l_max_its = 5\n  nl_max_its = 5\n  nl_rel_tol = 1.0e-3\n  start_time = 0.0\n  #num_steps = 200\n  end_time = 20000000000\n  dtmin = 1e-20\n  #dt = 1\n  line_search = none\n\n  [Adaptivity]\n    initial_adaptivity = 0\n    refine_fraction = 0.7\n    coarsen_fraction = 0.1\n    max_h_level = 1\n  []\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    cutback_factor = 0.8\n    dt = 0.00001\n    growth_factor = 1.2\n    optimal_iterations = 7\n  []\n[]\n\nCan you suggest optimum values for these?\nAshish",
                          "url": "https://github.com/idaholab/moose/discussions/28247#discussioncomment-10184560",
                          "updatedAt": "2024-07-29T23:01:58Z",
                          "publishedAt": "2024-07-29T23:01:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you paste the simulation log here?",
                          "url": "https://github.com/idaholab/moose/discussions/28247#discussioncomment-10192231",
                          "updatedAt": "2024-07-30T15:26:35Z",
                          "publishedAt": "2024-07-30T15:26:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Here is the output file\n0p05.txt",
                          "url": "https://github.com/idaholab/moose/discussions/28247#discussioncomment-10193809",
                          "updatedAt": "2024-07-30T18:35:31Z",
                          "publishedAt": "2024-07-30T18:35:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Th\u00e9 tolerances are super loose\nPlease tighten the nonlinear convergence criterion. Accepting non converged solutions is not helping the solver finish the transient",
                          "url": "https://github.com/idaholab/moose/discussions/28247#discussioncomment-10193958",
                          "updatedAt": "2024-07-30T18:52:11Z",
                          "publishedAt": "2024-07-30T18:52:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "l_abs_tol = 1.0e-4\n  nl_abs_tol = 1.0e-4\n  l_tol = 1.0e-4\n  l_max_its = 30\n  nl_max_its = 30\n  nl_rel_tol = 1.0e-4\n\nwill that work. If I go less than this the solve takes really long time. I tried with tight tolerances earlier, but, for every timesteps it was taking such a huge time.",
                          "url": "https://github.com/idaholab/moose/discussions/28247#discussioncomment-10194125",
                          "updatedAt": "2024-07-30T19:20:03Z",
                          "publishedAt": "2024-07-30T19:20:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There s no way to know ahead of time if it will be enough.\nYou can look at improving preconditioning to make the linear solves faster and be able to afford more nonlinear solves.\nYou should use checkpoitining to make a checkpoint before the problem arises, then tighten the convergence tolerances a few time steps before it occurred",
                          "url": "https://github.com/idaholab/moose/discussions/28247#discussioncomment-10195273",
                          "updatedAt": "2024-07-30T22:30:40Z",
                          "publishedAt": "2024-07-30T22:30:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Periodic function in MOOSE.",
          "author": {
            "login": "AlejandroRiano2023"
          },
          "bodyText": "Good afternoon, I am trying to implement a periodic function in MOOSE.\n\nCurrently, I have defined the red points that can be appreciated in the image, and the idea is to repeat the cycle indefinitely.\nThis is the function defined in just one cycle for the red points in the image.\n  [Delta_def]\n    type = PiecewiseConstant\n    x = '0 20e6 40e6 60e6 80e6 100e6'\n    y = '-0.0047629 -0.0074940 -0.0062045 -0.15252 -0.0090877 -0.0048300'\n    direction = right\n  []\n\nI will be attentive to your comments and thank you so much in advance for your assessment.\nBest regards,\nAlejandro",
          "url": "https://github.com/idaholab/moose/discussions/28268",
          "updatedAt": "2024-11-08T22:47:25Z",
          "publishedAt": "2024-07-30T21:08:01Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe easiest way to do that will be to use the function you have to define the profile, then use a ParsedFunction with an if condition (or the % operator if it works) to create the periodicity on the initial function\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28268#discussioncomment-10195013",
                  "updatedAt": "2024-07-30T21:38:32Z",
                  "publishedAt": "2024-07-30T21:38:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Convergence Issues with a Second-Order Mixed Partial Derivative in MOOSE",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI am currently working on solving an equation with a second-order mixed partial derivative:\n\nThe weak form of this equation is as follows:\n\nHowever, I am encountering convergence issues during computation and can only use JFNK, not PJFNK. I have tried different approaches, including directly computing the residual for the term with the mixed partial derivative using _var.secondSln(), as well as integrating by parts to reduce the mixed partial derivative term to two first-order partial derivative terms.\n\nDespite these attempts, convergence remains unattainable.\nIn my tests, if I simplify the problem to Mat(x,y)\u2202F(x,y)/\u2202y=Q, I can achieve correct convergence by directly computing the residual term for the left-hand side of the equation using _grad_u in the Kernel. However, this approach also has issues since it still requires JFNK instead of PJFNK. When attempting to solve using PJFNK, I receive the following errors:\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 0\n\nDoes anyone know how to address this issue?",
          "url": "https://github.com/idaholab/moose/discussions/28265",
          "updatedAt": "2024-07-30T15:56:18Z",
          "publishedAt": "2024-07-30T15:06:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you using automatic differentiation?\nMaybe the Jacobian has a large mistake.\nThere is some advice on convergence issues here:\nhttps://mooseframework.inl.gov/moose/application_usage/failed_solves.html",
                  "url": "https://github.com/idaholab/moose/discussions/28265#discussioncomment-10192069",
                  "updatedAt": "2024-07-30T15:10:57Z",
                  "publishedAt": "2024-07-30T15:10:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "No, I provide the computeQpJacobian() function manually.",
                          "url": "https://github.com/idaholab/moose/discussions/28265#discussioncomment-10192119",
                          "updatedAt": "2024-07-30T15:15:51Z",
                          "publishedAt": "2024-07-30T15:15:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "then there may be a mistake, or a missing off-diagonal term.\nThe Jacobian tester or the petsc option to test Jacobians are a good idea to see this",
                          "url": "https://github.com/idaholab/moose/discussions/28265#discussioncomment-10192148",
                          "updatedAt": "2024-07-30T15:18:26Z",
                          "publishedAt": "2024-07-30T15:18:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "I thought there was no need to use the computeQpOffDiagJacobian() function because there is only one variable, F(x,y).",
                          "url": "https://github.com/idaholab/moose/discussions/28265#discussioncomment-10192190",
                          "updatedAt": "2024-07-30T15:23:53Z",
                          "publishedAt": "2024-07-30T15:22:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if there is only one variable and no element-to-neighbor coupling you should be fine",
                          "url": "https://github.com/idaholab/moose/discussions/28265#discussioncomment-10192215",
                          "updatedAt": "2024-07-30T15:24:47Z",
                          "publishedAt": "2024-07-30T15:24:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "What do you mean by element-to-neighbor? Do you mean partial derivatives?",
                          "url": "https://github.com/idaholab/moose/discussions/28265#discussioncomment-10192229",
                          "updatedAt": "2024-07-30T15:26:29Z",
                          "publishedAt": "2024-07-30T15:26:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I mean techniques like mortar coupling or specific treatment at interface kernels",
                          "url": "https://github.com/idaholab/moose/discussions/28265#discussioncomment-10192279",
                          "updatedAt": "2024-07-30T15:30:28Z",
                          "publishedAt": "2024-07-30T15:30:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "I only used Kernel, BC, and DGKernel, without any complex techniques. This equation, aside from having a mixed partial derivative, doesn't have any other complexities. I'm also not sure if such an equation requires any special stabilization techniques for computation.",
                          "url": "https://github.com/idaholab/moose/discussions/28265#discussioncomment-10192320",
                          "updatedAt": "2024-07-30T15:35:08Z",
                          "publishedAt": "2024-07-30T15:35:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I can see DGKernels have off diagonal coupling between the element and the side DoFs.\nYou should look at example nonAD DG kernels to see how this is handled",
                          "url": "https://github.com/idaholab/moose/discussions/28265#discussioncomment-10192525",
                          "updatedAt": "2024-07-30T15:56:19Z",
                          "publishedAt": "2024-07-30T15:56:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Handling Mixed Second-Order Partial Derivatives in MOOSE",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi everyone,\nI need to solve an equation that includes a mixed second-order partial derivative with respect to x and y, but I'm unsure how to handle the mixed partial derivative in MOOSE. In 2021, a similar question was asked (##19475), and the recommendation was to use integral transforms for differential reduction. I've tried this method, but MOOSE fails to converge during the computation.\nI'm curious if there have been any updates or advancements in how MOOSE handles second-order mixed partial derivatives. I noticed that the code related to the incompressible Navier-Stokes (INS) equations in MOOSE seems to include variables for second-order derivatives (e.g., _second_u_vel(coupledSecond(\"u\"))), although I recall that the INS module does not include mixed second-order partial derivatives.\nThe specific mixed second-order partial derivative I need to handle is:\n\nAny guidance or insights on how to properly implement this in MOOSE would be greatly appreciated. Thank you!",
          "url": "https://github.com/idaholab/moose/discussions/28246",
          "updatedAt": "2024-07-30T14:29:00Z",
          "publishedAt": "2024-07-28T14:47:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think coupledSecond returns a tensor and you can simply access the off-diagonal component to get the d2f/dxdy\nI have never tried but I would expect that to be the solution.\nYou should make a simple auxkernel with coupledSecond and use it on predefined second order variables, for which you know the correct 2nd order derivatives, to check that it works\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28246#discussioncomment-10174015",
                  "updatedAt": "2024-07-28T23:13:49Z",
                  "publishedAt": "2024-07-28T23:13:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you very much for your response. I also believe this approach should work, but I am unsure how to access the off-diagonal elements of the tensor. I found the definition of VariableSecond in the code, but I am not familiar with the corresponding class. Do you know anything about this? Here is some code I found regarding the definition of VariableSecond:\n// Seconds, this is defined in INSBase and _second_u_vel is a data member.\n  const VariableSecond & _second_u_vel;\n\n// This is declared in framework/include/MooseTypes.h\ntypedef typename OutputTools<Real>::VariableSecond VariableSecond;\n\n// This is also declared in framework/include/MooseTypes.h\ntemplate <typename OutputType>\nstruct OutputTools\n{\n  typedef typename TensorTools::IncrementRank<OutputType>::type OutputGradient;\n  typedef typename TensorTools::IncrementRank<OutputGradient>::type OutputSecond;\n  ......\n  typedef MooseArray<OutputSecond> VariableSecond;\n  ......\n}\n\nIn INSBase, I found the following operations:\n_second_u_vel[_qp].tr();\n_second_u_vel[_qp].row(0);",
                          "url": "https://github.com/idaholab/moose/discussions/28246#discussioncomment-10174926",
                          "updatedAt": "2024-07-29T02:49:25Z",
                          "publishedAt": "2024-07-29T02:49:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I believe you can output the tensor with\nstd::cout << Moose::stringify(..\nIf you do _tensor.row(0)(1) you should get the xy mixed derivative\nNote that you also need to index by quadrature point with [_qp]",
                          "url": "https://github.com/idaholab/moose/discussions/28246#discussioncomment-10176024",
                          "updatedAt": "2024-07-29T06:11:29Z",
                          "publishedAt": "2024-07-29T06:11:29Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you, it works.",
                          "url": "https://github.com/idaholab/moose/discussions/28246#discussioncomment-10191598",
                          "updatedAt": "2024-07-30T14:28:48Z",
                          "publishedAt": "2024-07-30T14:28:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}