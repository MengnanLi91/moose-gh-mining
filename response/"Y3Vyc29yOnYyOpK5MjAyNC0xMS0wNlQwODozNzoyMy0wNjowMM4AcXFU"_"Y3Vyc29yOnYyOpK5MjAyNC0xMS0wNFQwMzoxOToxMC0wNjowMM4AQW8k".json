{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMS0wNFQwMzoxOToxMC0wNjowMM4AQW8k"
    },
    "edges": [
      {
        "node": {
          "title": "CoupledVarThresholdElementSubdomainModifier - moving boundary error",
          "author": {
            "login": "czadeh"
          },
          "bodyText": "Hi,\nI made sure MOOSE and conda were fully updated before testing and posting this and I could not find this issue posted elsewhere.\nI am using CoupledVarThresholdElementSubdomainModifier in my input file to modify my active domain. I start with a thin layer and add more layers in the Z direction. The function used to modify the boundary is called 'layerZ' and its value is displayed in exodus.\nInput file is here:\n[Problem]\n  solve = false\n  kernel_coverage_check = false\n[]\n[Mesh]\n    construct_side_list_from_node_list = true\n    [gen]\n      type = GeneratedMeshGenerator\n      dim = 3\n      nx = 20\n      ny = 20\n      nz = 20\n      xmax = 2\n      ymax = 1\n      zmax = 1\n    []\n    [powder_domain] #the initial domain, the first layer\n      type = SubdomainBoundingBoxGenerator\n      input = 'gen'\n      block_id = 1\n      bottom_left = '0 0 0'\n      top_right = '2 1 0.1'\n    []\n    [gas_domain] #the initially inactive domain\n      type = SubdomainBoundingBoxGenerator\n      input = 'powder_domain'\n      block_id = 2\n      bottom_left = '0 0 0.1'\n      top_right = '2 1 1'\n    []\n[]\n[Variables]\n  [u]\n    initial_condition = 1\n    family = LAGRANGE\n    block = '1 2'\n  []\n[]\n[Kernels]\n  [dummy]\n    type = NullKernel\n    variable = u\n  []\n[]\n[UserObjects]\n  [addLayer] #subdomain modifier\n    type = CoupledVarThresholdElementSubdomainModifier\n    coupled_var = 'layerZ' #the z height of the active layers\n    criterion_type = BELOW\n    threshold = 0\n    subdomain_id = 1\n    # complement_subdomain_id = 2\n    moving_boundary_name = topLayer #the top boundary of the top layer\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n[]\n[Functions]\n  [LayerZFunc] #function to define layerZ\n    type = ParsedFunction\n    value = 'z-0.1*floor(t)-0.1'\n    # value = 'int(10*(z-0.1*floor(t)-0.1))/10'\n  []\n[]\n[AuxVariables]\n  [layerZ]\n    [InitialCondition]\n      type = ConstantIC\n      value = 0.1\n      variable = layerZ\n    []\n  []\n[]\n[AuxKernels]\n  [layerZ]\n    type = FunctionAux\n    variable = layerZ\n    function = LayerZFunc\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n[]\n[Executioner]\n  type = Transient\n  solve_type = JFNK\n  num_steps = 5\n  dt = 1\n[]\n[Outputs]\n  exodus = true\n[]\n\nThe bulk of the domain seems to behave correctly, but some unusual behavior appears on the boundary.\ntime = 2\n\nAccording to the legend it seems like a rounding error. Not a big deal, but the moving boundary labeled 'topLayer' shows some inconsistent behavior.\ntime = 2\n\nAt first it matches block 1 almost exactly.\nBut at some point it diverges from block 1 and somehow the moving boundary is comprised of separate z-planes.\ntime = 4\n\ntime = 4\n\nI need to use the moving boundary as part of my problem but I do not think it will work like this. I am struggling to figure out why this error occurs.\nI appreciate your help in figuring this out.\nThanks,\nCameron",
          "url": "https://github.com/idaholab/moose/discussions/19047",
          "updatedAt": "2024-11-06T14:31:21Z",
          "publishedAt": "2021-10-08T19:53:34Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSince you have already identified the issue as being a rounding error, just change the value field in LayerZfunc to be offset by some small epsilon like 1e-8 and it will resolve this.\nRounding errors can be inconsistent between different computations at different timesteps, there s very little that can done apart from using small offsets\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1456827",
                  "updatedAt": "2022-07-04T08:32:43Z",
                  "publishedAt": "2021-10-11T03:39:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "czadeh"
                  },
                  "bodyText": "Hi Guillaume,\nI tried adding an epsilon starting with e-8 up to e-2. I tried it both within the argument of the floor function and outside of it, but the error persists the same way.\nWould changing the value of\nexecute_on\nin UserObjects or AuxKernels affect this?",
                  "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1460172",
                  "updatedAt": "2022-07-04T08:32:43Z",
                  "publishedAt": "2021-10-11T16:45:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It can affect this if there is an issue with dependency resolution. There should not be.\nyou can try to shift the order of execution of the User object if you want using:\nforce_preaux = true\nor\nforce_postaux = true\nin the user object parameter\nBy default, user objects are executed after aux kernels, so what you did should work since the layer criterion is being computed by an aux kernel.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1461345",
                          "updatedAt": "2022-07-04T08:33:01Z",
                          "publishedAt": "2021-10-11T21:40:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I can test to see if I can reproduce this. I've already recorded several bugs, if this is also a bug in element subdomain modifier, I'll also add this to my to-do list. But right now I don't have a clear idea of when I can get to them.",
                  "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1461627",
                  "updatedAt": "2022-07-04T08:33:07Z",
                  "publishedAt": "2021-10-11T23:53:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Pinging @dewenyushu here because she might have some resources to work on this. I'm not sure.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1461633",
                          "updatedAt": "2022-07-04T08:33:07Z",
                          "publishedAt": "2021-10-11T23:55:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Yes, we can potentially use part of a ldrd project to fix the issues associated with the subdomain modifier, if you may have the availability.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1465346",
                          "updatedAt": "2022-07-04T08:33:03Z",
                          "publishedAt": "2021-10-12T14:47:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "czadeh"
                  },
                  "bodyText": "I tried to circumvent this issue by using SideSetsAroundSubdomainGenerator when defining my mesh and blocks initially. I used it to define the boundaries around block 1. But now the problem is that\n\n\nThe top boundary between blocks 1 and 2 works correctly until the subdomain is modified by CoupledVarThresholdElementSubdomainModifier. At that point, the boundary between the subdomains disappears.\n\n\nThe sides of block 1 (everything except z = 0 and the boundary between blocks 1 and 2) stay at their initially defined geometry and do not update with increasing z.\n\n\nIs there a way to make the mesh generator update the sidesets when CoupledVarThresholdElementSubdomainModifier makes a change?\nThanks,\nCameron",
                  "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1523682",
                  "updatedAt": "2022-07-04T08:33:03Z",
                  "publishedAt": "2021-10-22T22:37:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nNo we currently cant run mesh generators inside a simulation. We ll be able to do that soon, when we can compose the order of execution of executioners. We ll add a MeshGenerator executioner that will be allowed to run then.\nAnother solution is to leverage the adaptivity system to rename sidesets. This is the current cannon way to do this, but no one has implemented it afaik.\nEither that or you can add a user object to run those mesh generators on any execute_on.\nBut for 1.) the CoupledVarThresholdElementSubdomainModifier should be handling the moving interface and updating it as it progresses.\nFor 2. can you share the sideset between block 1 and 2? Then they should still be valid & have the same name as the domains move. Is this for a boundary condition? Are the variables the same in both domains? The latter could be an issue.\nYou could pause the simulation every step and recover, and run the generators then. It s not very efficient though\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1534974",
                          "updatedAt": "2022-07-04T08:33:05Z",
                          "publishedAt": "2021-10-25T21:10:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "also for 2. could you specify those boundaries as moving boundaries of the  CoupledVarThresholdElementSubdomainModifier  ? Hopefully that does the trick",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1534977",
                          "updatedAt": "2022-07-04T08:33:07Z",
                          "publishedAt": "2021-10-25T21:11:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "Hi Guillaume, sorry for the delay in responding.\nI am glad to hear that this feature will be added soon. Are you all working on a set of tools for additive manufacturing modeling?\n\nAnother solution is to leverage the adaptivity system to rename sidesets.\n\nI do not understand how you could use adaptivity, doesn't it just refine or coarsen the mesh? How can you use it rename sidesets?\n\nEither that or you can add a user object to run those mesh generators on any execute_on.\n\nDo you mean something like ActivateElementsByPath or ActivateElementsCoupled?\n\nBut for 1.) the CoupledVarThresholdElementSubdomainModifier should be handling the moving interface and updating it as it progresses.\n\nMy top sideset (shown below) stopped working once CoupledVarThresholdElementSubdomainModifier took effect. So I need to use  moving_boundary_name after the change to the boundary.\n  [sideset_top]\n    input = gas_domain\n    type = SideSetsAroundSubdomainGenerator\n    normal = '0 0 1'\n    block = 1\n    new_boundary = 'active_layer_top'\n  []\n\n\nFor 2. can you share the sideset between block 1 and 2? Then they should still be valid & have the same name as the domains move. Is this for a boundary condition? Are the variables the same in both domains? The latter could be an issue.\n\nI defined it for block 1. I have been trying to only define nonlinear variables in the powder/liquid/solid region, not gas. Yes, I am using this to set the upper boundary condition of the active domain.\n\nYou could pause the simulation every step and recover, and run the generators then\n\nThanks, I will try that.\n\nalso for 2. could you specify those boundaries as moving boundaries of the CoupledVarThresholdElementSubdomainModifier ?\n\nI thought I could only specify a single moving boundary in CoupledVarThresholdElementSubdomainModifier. When I specified it, it only did the top region.\nCameron",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1573232",
                          "updatedAt": "2022-07-04T08:33:07Z",
                          "publishedAt": "2021-11-02T00:04:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nWe pretty much always have people working on that yes, very promising research / engineering field. @friedmud anyone I can tag on additive manufacturing?\n\n\nYou're right that adaptivity currently only does refinement and coarsening. However, \"adapting\" the mesh by changing the sidesets feels like it belongs in adaptivity. Any kind of mesh operation that reacts to simulation variables is \"adaptivity\" to me, but maybe I am abusing the term.\n\n\nI don't think ActivateElementXXX does quite what you want. I think a new UO would need to be created to do what you want. Ideally we can figure out a way to make it run a mesh generator. If not, then you would just have to paste the code in a mesh generator in the UO. It will work there too.\n\n\nFor recovering and running mesh generators, please note that this is disabled by default. You ll have to go in the code and remove the disabling.\n\n\nOk for having a single moving boundary. It was just an idea. Can you use more than one CoupledVarThresholdElementSubdomainModifier with different moving boundaries though??\n\n\nI'm afraid most solutions I am proposing involve coding a new object (1 & 2) or modifying some MOOSE internal code (3, which is kind of hacky, probably gonna get a dislike for this). I can't see how to leverage an existing system to move the multiple sidesets, unless 4 works out of the box.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1574096",
                          "updatedAt": "2022-07-04T08:33:15Z",
                          "publishedAt": "2021-11-02T06:30:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "There are many who are more plugged into what's going on in advanced manufacturing than me... @laagesen @sapitts may have some thoughts.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1577012",
                          "updatedAt": "2022-07-04T08:33:20Z",
                          "publishedAt": "2021-11-02T15:41:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@czadeh  I can partially answer your question on the additive manufacturing development. Currently we can do thermal-mechanical modeling at component level using element activation algorithm and meso-scale melt pool dynamics modeling with level set and ALE methods. The component modeling is available in the MOOSE and melt-pool dynamics is inside our new MOOSE-based application called MALAMUTE.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1577193",
                          "updatedAt": "2022-07-04T08:33:20Z",
                          "publishedAt": "2021-11-02T16:10:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@czadeh  I just ran your input file. It seems that the top layer boundary is shown correctly at every step. Did I miss any thing?\nBTW, I visualized them in Paraview BTW. Maybe there were some issues with the reading the boundary as mesh changes in Peacock.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1577250",
                          "updatedAt": "2022-07-04T08:33:17Z",
                          "publishedAt": "2021-11-02T16:22:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "We're also working to add some advanced manufacturing modeling capabilities to the MALAMUTE app, in addition to the additive manufacturing capabilities @jiangwen84 described. @cticenhour and @lindsayad  are leading that effort, along with the other folks participating in this discussion. We are pretty excited to have one MOOSE app for these types of multiphysics problems!",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1577258",
                          "updatedAt": "2022-07-04T08:33:21Z",
                          "publishedAt": "2021-11-02T16:23:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "That's exciting, will MALAMUTE be released to the public? Is there a place where I can learn more about it?",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1578182",
                          "updatedAt": "2022-07-04T08:33:20Z",
                          "publishedAt": "2021-11-02T18:58:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "czadeh"
                          },
                          "bodyText": "@jiangwen84 interesting, was that with block 1 visible? My image with the error was with only the moving boundary visible, no other domains.\nIf it is just an error in Peacock that's good to know.",
                          "url": "https://github.com/idaholab/moose/discussions/19047#discussioncomment-1578212",
                          "updatedAt": "2022-07-04T08:33:22Z",
                          "publishedAt": "2021-11-02T19:03:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "get drho_dT from Water97FluidProperties",
          "author": {
            "login": "SunJianhang678"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nDear MOOSE experts,\nI'm using the Water97FluidProperties and trying to get drho_dT as a property of my material so that it could be consumed by other kernels. But I don't know how to achieve it. I want to get drho_dT in a way like how i get rho, by declaring _rho in .h file and getting it in .C file, but it seems that Water97Fluidproperties does not have a member named 'drho_dT_from_p_T' corresponding to 'rho_from_p_T'. Part of my current code is as below.\nCould you please offer some guidance? It will be great help if there are some examples using drho_dT this way. Thank you so much!\n.h file\nprivate:\nMaterialProperty & _rho;\nMaterialProperty & _drho_dT;\nMaterialProperty & _drho_dp;\nconst Water97FluidProperties & _fluid;\n.C file\nWater97::Water97(const InputParameters & parameters)\n: Material(parameters),\n_rho(declareProperty(\"rho\")),\n_drho_dT(declareProperty(\"drho_dT\")),\n_drho_dp(declareProperty(\"drho_dp\")),\n_fluid(getUserObject(\"fp\"))\n{\n}\nvoid\nWater97::computeQpProperties()\n{\n_rho[_qp] = _fluid.rho_from_p_T(_p[_qp], _T[_qp]);\n_drho_dT[_qp] = _fluid.drho_dT_from_p_T(_p[_qp], _T[_qp]);\n_drho_dp[_qp] = _fluid.drho_dp_from_p_T(_p[_qp], _T[_qp]);\n}",
          "url": "https://github.com/idaholab/moose/discussions/29016",
          "updatedAt": "2024-11-06T14:18:17Z",
          "publishedAt": "2024-11-06T09:53:56Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "SunJianhang678"
                  },
                  "bodyText": "I solved this problem by replacing the last two lines showed above with the following codes:\ndouble delta = 1e-1;\ndouble rho_dT = _fluid.rho_from_p_T(_p[_qp], _T[_qp] + delta);\ndouble rho_dp = _fluid.rho_from_p_T(_p[_qp] + delta, _T[_qp]);\n_drho_dT[_qp] = (rho_dT - _rho[_qp]) / delta;\n_drho_dp[_qp] = (rho_dp - _rho[_qp]) / delta;\nbut I'm wondering if there were more convenient ways provided by moose, instead of calculating the values by myself?",
                  "url": "https://github.com/idaholab/moose/discussions/29016#discussioncomment-11165152",
                  "updatedAt": "2024-11-06T10:35:18Z",
                  "publishedAt": "2024-11-06T10:35:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is fine but the convenient way is to do this:\nFinite differencing will be a slightly more imprecise than using the routines that compute those derivatives\nReal rho, drho_dT, drho_dp;\n_fluid.rho_from_p_T(_p[_qp], _T[_qp], rho, drho_dT, drho_dp);",
                          "url": "https://github.com/idaholab/moose/discussions/29016#discussioncomment-11166705",
                          "updatedAt": "2024-11-06T13:21:32Z",
                          "publishedAt": "2024-11-06T13:19:30Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SunJianhang678"
                          },
                          "bodyText": "Got it! When I read the source code of Water97FP, I didn't know why more params than needed appear in this function and what they are for, now I understand. Thank you so much!",
                          "url": "https://github.com/idaholab/moose/discussions/29016#discussioncomment-11167230",
                          "updatedAt": "2024-11-06T14:11:59Z",
                          "publishedAt": "2024-11-06T14:11:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "p, T are inputs\nrho, drho_dT, drho_dp are references to a number. So while they are passed as arguments, they are actually outputs of this routine\nso this routine officially returns \"void\" but in practice it computes rho, drho_dT, drho_dp in the (reference to) numbers you pass as parameters",
                          "url": "https://github.com/idaholab/moose/discussions/29016#discussioncomment-11167315",
                          "updatedAt": "2024-11-06T14:18:18Z",
                          "publishedAt": "2024-11-06T14:18:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "SegFault using LinearNodalConstraint with Distributed Mesh",
          "author": {
            "login": "TheBEllis"
          },
          "bodyText": "Hi MOOSE team,\nI've been trying to use LinearNodalConstraint to replicate an RBE3-esque constraint on a problem that will need a distributed mesh, and I am running into a SegFault. I have put together a small reproducible example. I have uploaded the mesh here https://drive.google.com/file/d/1ZlKYpy96iZ3vGojwCULTtBbGSVbFBUxG/view?usp=sharing.\n\nThe independent (primary) nodes in this situation are all the nodes on the cylindrical extrude face, and the dependent (secondary) node is located at 0,0,0 at the centre of the mesh. All the weightings are equal. I have pre-split the mesh into 2 parts. Using a debug executable I immediately get this error, which points to libmesh_assert_valid_neighbors.\n\nUsing an opt executable and running a debugger for each MPI process, the backtrace looks like this,\n\nAlso I am running b9eefd8, so aaedfb9 is included.\nAny help is much appreciated:) The problem converges fine without --use-split, but as soon as the distributed mesh is used the segfault appears.\nEdit: After a bit of digging it seems the problem is the elemPtr() call at line 459 of SystemBase.C, in augmentSendList(). Should this be a queryElemPtr()?\npenalty = 1e13\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh]\n  type = FileMesh\n  file = '../mesh/rbetest_no_elems.e'\n[] \n  \n[Variables]\n  [temperature]\n    initial_condition = 0 # Start at room temperature\n  []\n[]\n  \n[Kernels]\n  # Heat conduction kernels\n  [heat_conduction]\n    type = ADHeatConduction\n    variable = temperature\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    use_automatic_differentiation = true\n    volumetric_locking_correction = true\n    strain = SMALL\n    add_variables = true\n    incremental = false\n    generate_output = 'strain_xx strain_yy strain_zz vonmises_stress'\n    eigenstrain_names = eigenstrain\n  []\n[]\n  \n[Materials]\n  [CCZ_elasticity]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 100000\n    poissons_ratio = 0.33\n  []\n  [CCZ_heat]\n    type = ADHeatConductionMaterial\n    temp = temperature\n    thermal_conductivity = 400.0\n    specific_heat = 330.0\n  []\n\n  [CCZ_thermal_expansion]\n    type = ADComputeThermalExpansionEigenstrain\n    stress_free_temperature = 10\n    thermal_expansion_coeff = 5e-04\n    temperature = temperature\n    eigenstrain_name = eigenstrain\n    block = 1\n  []\n\n  [rbe_thermal_expansion]\n    type = ADComputeThermalExpansionEigenstrain\n    stress_free_temperature = 0\n    thermal_expansion_coeff = 0\n    temperature = temperature\n    eigenstrain_name = eigenstrain\n    block = 2\n  []\n\n  [stress]\n    type = ADComputeLinearElasticStress\n  []\n[]\n\n[Constraints]\n    [rbe3_x]\n        type = LinearNodalConstraint\n        primary = '7 1 149 8 190 191 192 193 13 194 195 196 197 198 199 200 14 15 16 17 18 19 20 21 22 23 2 64 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922'\n        secondary_node_set = 'secondary'\n        variable = disp_x\n        penalty = ${penalty}\n        weights = '0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005'\n    []\n\n    [rbe3_y]\n        type = LinearNodalConstraint\n        primary = '7 1 149 8 190 191 192 193 13 194 195 196 197 198 199 200 14 15 16 17 18 19 20 21 22 23 2 64 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922'\n        secondary_node_set = 'secondary'\n        variable = disp_y\n        penalty = ${penalty}\n        weights = '0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005'\n    []\n\n    [rbe3_z]\n        type = LinearNodalConstraint\n        primary = '7 1 149 8 190 191 192 193 13 194 195 196 197 198 199 200 14 15 16 17 18 19 20 21 22 23 2 64 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922'\n        secondary_node_set = 'secondary'\n        variable = disp_z\n        penalty = ${penalty}\n        weights = '0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005 0.005'\n    []\n[]\n\n[BCs]\n  [temp_high]\n    type = ADDirichletBC\n    variable = temperature\n    boundary = 'hot'\n    value = 100\n  []\n  [temp_low]\n    type = ADDirichletBC\n    variable = temperature\n    boundary = 'cold'\n    value = 0\n  []\n[]\n\n[Postprocessors]\n  [average_x]\n    type = AverageNodalVariableValue\n    variable = disp_x\n    boundary = 'primary'\n  []\n  [average_y]\n    type = AverageNodalVariableValue\n    variable = disp_y\n    boundary = 'primary'\n  []\n  [average_z]\n    type = AverageNodalVariableValue\n    variable = disp_z\n    boundary = 'primary'\n  []\n[]\n  \n#[Preconditioning]\n#  [./SMP]\n#    #Creates the entire Jacobian, for the Newton solve\n#    type = SMP\n#    full = true\n#  [../]\n#[]\n  \n[Executioner]\n  type = Steady\n  automatic_scaling = true\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre    boomeramg'\n  nl_rel_tol = 1e-20\n  nl_abs_tol = 1e-5\n  l_tol = 1e-8\n  l_abs_tol = 1e-10\n  line_search = none\n[]\n\n[Outputs]\n  exodus = true\n  perf_graph = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/29005",
          "updatedAt": "2024-11-06T09:48:10Z",
          "publishedAt": "2024-11-05T11:52:22Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nCan you try this instead:\n\ngenerate the split with --split-mesh as usual\nload the split mesh using a FileMeshGenerator (FileMesh -- like you have now -- can work too probably)\ndo not use --use-split\n\nuse-split follows a different code path that does not do a good job at keeping track of neighbors iirc\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/29005#discussioncomment-11160246",
                  "updatedAt": "2024-11-06T13:24:58Z",
                  "publishedAt": "2024-11-05T22:56:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheBEllis"
                          },
                          "bodyText": "Hi Guillaume,\nThis worked, thank you lots! I should have paid more attention to this.\n\nNote for anyone else who is trying to do this, the only other thing I needed to get it working was to set skip_partitioning to true in FileMeshGenerator, as my mesh was pre-split and it is set to False by default (and use the --distributed-mesh command line argument when running).\nAgain, many thanks,\nBill",
                          "url": "https://github.com/idaholab/moose/discussions/29005#discussioncomment-11164702",
                          "updatedAt": "2024-11-06T09:51:50Z",
                          "publishedAt": "2024-11-06T09:48:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Principal stress is used in a material model",
          "author": {
            "login": "PEI0214"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello\uff0c\nI want to add a material model. The elastic modulus of this model is related to the principal stress. When I use meshmodifiers to simulate construction, the process is shown below.\n\nWhen the type of principal stress is nodal variable, the inactive part also has principal stress. When the principal stress type is elemental variable, the principal stress value of the inactive part is 0, as shown in the figure below.\n\nHowever, the solving type of the principal stress in moose is node type, which will affect my solving of the elastic modulus value. Is there a way to use element type principal stress in a material model?\nminPrincipal in MOOSE:\ntemplate <typename T>\nT\nminPrincipal(const RankTwoTensorTempl<T> & r2tensor, Point & direction)\n{\n  return calcEigenValuesEigenVectors(r2tensor, 0, direction);\n}",
          "url": "https://github.com/idaholab/moose/discussions/28994",
          "updatedAt": "2024-11-05T21:38:58Z",
          "publishedAt": "2024-11-03T15:46:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe have not implemented any default behavior for material properties on newly activated subdomains.\nAll the work has focused on variables so far. If you want a particular behavior you will need to implement it\nFor the figure you show, that's a visualization artefact. That's just how paraview plot nodal variables, as continuous variables by default\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28994#discussioncomment-11135171",
                  "updatedAt": "2024-11-03T16:03:56Z",
                  "publishedAt": "2024-11-03T16:03:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "I don't understand what you are wanting to implement but stress is a material property defined at the gauss points, not the nodes.\nYou can compute a \"nodal stress\" as a post processing step from the stress material property but that \"nodal stress\" isn't the stress used in a constitutive model.  ComputeSmearedCrackingStress is a material that uses principal strains to modify material properties.  Maybe you can do something similar.",
                          "url": "https://github.com/idaholab/moose/discussions/28994#discussioncomment-11159768",
                          "updatedAt": "2024-11-05T21:38:59Z",
                          "publishedAt": "2024-11-05T21:38:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "problem loading mesh from msh file",
          "author": {
            "login": "RWTHLHK"
          },
          "bodyText": "I generated a msh file using Neper. But weirdly, the boundary name in the msh file can never be identified. I always get the error: the following node sets (ids) do not exist on the mesh: y0 (105). But I check in the msh file, boundary y0 indeed exists.\n[BCs]\n[symmy]\ntype = DirichletBC\nvariable = uy\nboundary = y0\nvalue = 0\n[]\n[symmx]\ntype = DirichletBC\nvariable = ux\nboundary = x0\nvalue = 0\n[]\n[symmz]\ntype = DirichletBC\nvariable = uz\nboundary = z0\nvalue = 0\n[]\n[tdisp]\ntype = FunctionDirichletBC\nvariable = uz\nboundary = z1\nfunction = 0.01*t\n[]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/29008",
          "updatedAt": "2024-11-05T20:03:57Z",
          "publishedAt": "2024-11-05T17:49:12Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nis it a sideset in this msh file instead of a nodeset?\nif so you can use this to convert it:\nhttps://mooseframework.inl.gov/source/meshgenerators/NodeSetsFromSideSetsGenerator.html",
                  "url": "https://github.com/idaholab/moose/discussions/29008#discussioncomment-11158275",
                  "updatedAt": "2024-11-05T18:27:57Z",
                  "publishedAt": "2024-11-05T18:27:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "RWTHLHK"
                          },
                          "bodyText": "thanks! I just found BoundingBoxNodeSetGenerator can also do the job.",
                          "url": "https://github.com/idaholab/moose/discussions/29008#discussioncomment-11159004",
                          "updatedAt": "2024-11-05T20:03:58Z",
                          "publishedAt": "2024-11-05T20:03:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Constraining dependent node on LinearNodalConstraint",
          "author": {
            "login": "TheBEllis"
          },
          "bodyText": "Hi MOOSE team,\nI have a question about the behaviour of LinearNodalConstraint. I have a problem where I am trying to constraint the average displacement of the nodes on a boundary to 0. I have been trying to use a LinearNodalConstraint for this.\nI have a central dependent (or secondary as the LinearNodalConstraint calls it) node in the middle of the cylindrical boundary, with all the nodes on the boundary acting as the independent (Primary) nodes. The weightings for all of the nodes are equal to 1/(# of nodes). Therefore the displacement at the dependent node should be.\n$$\\Sigma u_i w_i = u_{dependent}$$\nMy question is, if I use a DirichletBC to prescribe the displacement of the dependent node to 0, will that then force,\n$$\\Sigma u_i w_i = 0$$\nIt feels wrong to prescribe the displacement of a dependent node, that DOF seems like it would have to be removed twice from the system. MOOSE will happily solve the problem, but I don't know what it is doing behind the scenes and whether it is at all what I am actually trying to do.\nI have also tried using a lagrange multiplier approach to constraint the average displacement but the extra lagrange multiplier variables made preconditioning a pain.\nAny help or insight is greatly appreciated!",
          "url": "https://github.com/idaholab/moose/discussions/28945",
          "updatedAt": "2024-11-05T10:22:50Z",
          "publishedAt": "2024-10-28T13:35:41Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@lindsayad",
                  "url": "https://github.com/idaholab/moose/discussions/28945#discussioncomment-11078867",
                  "updatedAt": "2024-10-28T19:15:28Z",
                  "publishedAt": "2024-10-28T19:15:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "TheBEllis"
                  },
                  "bodyText": "Since I posted this I have become aware that constraining the dependent node is a no go.",
                  "url": "https://github.com/idaholab/moose/discussions/28945#discussioncomment-11153078",
                  "updatedAt": "2024-11-05T10:22:51Z",
                  "publishedAt": "2024-11-05T10:22:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Apply velocity boundary condition in an impact problem.",
          "author": {
            "login": "zuckarm"
          },
          "bodyText": "hi all,\ni wanted to know what are the different methods i can use to apply a velocity boundary condition to a particular boundary in the domain?\nso far i am aware of PresetVelocity as one option.",
          "url": "https://github.com/idaholab/moose/discussions/28942",
          "updatedAt": "2024-11-05T05:50:06Z",
          "publishedAt": "2024-10-28T05:52:16Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can use DirichletBCs too. It depends on the rest of the simulation setup. Are you using the Dynamic Solid Mechanics Physics?",
                  "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11081771",
                  "updatedAt": "2024-10-29T02:30:12Z",
                  "publishedAt": "2024-10-29T02:30:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zuckarm"
                          },
                          "bodyText": "Yes i am using DynamicStressDivergenceTensors and InterialForce Kernels, along with TestNewmarkTI AuxKernels for velocity and acceleration. Can you please show an example of prescribing velocity boundary condition using FunctionDirichletBC?",
                          "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11082520",
                          "updatedAt": "2024-10-29T04:44:28Z",
                          "publishedAt": "2024-10-29T04:44:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "There are multiple ways to setup the solid dynamics in MOOSE. IIRC, if you set it up similar to solid_mechanics/test/tests/capped_weak_plane/pull_and_shear.i then the way the InertialForce, velocity and acceleration is calculated you can apply a true initial condition. In this case the velocity is an AuxVariable that is calculated at timestep_end so if you set up  initial condition on the velocity and/or an auxkernel that executes on initial you should be able to apply this velocity IC.",
                          "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11086571",
                          "updatedAt": "2024-10-29T12:17:38Z",
                          "publishedAt": "2024-10-29T12:17:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zuckarm"
                          },
                          "bodyText": "hi @maxnezdyur\ni looked through the input file you mentioned and i had a few questions:\n\n\ni have a ramped velocity boundary condition which is acting throughout the simulation time. is it possible to define this ramped function and then use it in an AuxKernel defined for velocity?\n\n\nThe AuxKernels for velocity and acceleration are of the Newmark type. but i am interested in explicit time integration. what other AuxKernels can i use?\n\n\nI am ultimately trying to solve a coupled problem: dynamic solid mechanics + phase field fracture model. so far, i have not seen any such type of problems solved in MOOSE. could you direct me to any such tutorials, if there are any?\n\n\nthanks",
                          "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11095305",
                          "updatedAt": "2024-10-30T04:45:52Z",
                          "publishedAt": "2024-10-30T04:45:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Well first I misread you initial problem statement. For impact problems, I am used to IC on velocity so that's why I focused on IC so much. Let me answer your question this time!\n\nIf you use PresetVelocity BC it has a function option, so that allows you to presibe the velocity as a function from the start.\nSince you don't need to set IC (aka they are set to 0) then don't use the auxkernels I sent you before and go back to what you first had.\nI think the best resource for what you want is in RACCOON, I don't know if they have any tutorials for solid dynamics but worth a look.",
                          "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11098642",
                          "updatedAt": "2024-10-30T10:29:16Z",
                          "publishedAt": "2024-10-30T10:29:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zuckarm"
                          },
                          "bodyText": "thank you so much!",
                          "url": "https://github.com/idaholab/moose/discussions/28942#discussioncomment-11150381",
                          "updatedAt": "2024-11-05T05:50:07Z",
                          "publishedAt": "2024-11-05T05:50:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Installing libmesh fails due to missing tirpc",
          "author": {
            "login": "aturner-epcc"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\nI am trying to install MOOSE from source on a CPU-based HPE Cray EX system (UK National Supercomputing Service, ARCHER2) and running into problems at the step to install libmesh. Following instructions at:\nhttps://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html\nI use:\nmodule load PrgEnv-gnu\nmodule load cray-python\nmodule load cmake\n\n./update_and_rebuild_libmesh.sh CC=cc CXX=CC FC=ftn\n\n(cc, 'CCandftnare the compiler wrappers within the Cray programming environement, equivalent tompif90` etc. on other clusters.)\nI get the following error:\nchecking for built-in XDR support... no\nchecking for XDR support in /usr/include/tirpc... no\nconfigure: error: *** XDR was not found, but --enable-xdr-required was specified.\n\nIndeed, that path does not exist on the system:\nauser@ln03:|~> ls /usr/include/tirpc\nls: cannot access '/usr/include/tirpc': No such file or directory\n\nI found the source for libtirpc on the internet at: https://www.linuxfromscratch.org/blfs/view/svn/basicnet/libtirpc.html and installed it myself at: /work/z19/z19/auser/software/MOOSE/libtirpc using the same compilers I am using for libmessh (and MOOSE).\nI then added the following options to libmesh ./configure:\n--with-xdr-include=/work/z19/z19/auser/software/MOOSE/libtirpc/include/tirpc\n--with-xdr-libname=/work/z19/z19/auser/software/MOOSE/libtirpc/lib/libtirpc.so\n\nretrying the configure gives:\nchecking for XDR support in /work/z19/z19/auser/software/MOOSE/libtirpc/include/tirpc... no\nconfigure: error: *** XDR was not found, but --enable-xdr-required was specified.\n\nAny idea how I get past this issue?\n(Optional) code in question / simulation log / errors\nNo response\nEncountering Errors? Please include diagnostic output\nNo response",
          "url": "https://github.com/idaholab/moose/discussions/28924",
          "updatedAt": "2024-11-04T17:26:03Z",
          "publishedAt": "2024-10-24T08:10:46Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid you install libtirpc-devel ?\nUsually the cluster administrators will do that one for you",
                  "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11037914",
                  "updatedAt": "2024-10-24T08:13:56Z",
                  "publishedAt": "2024-10-24T08:13:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aturner-epcc"
                          },
                          "bodyText": "Thanks for the quick reply, much appreciated. System adminstrators will not generally change the login node image or install dev packages for requirements for individual user software (as that way madness lies, you could end up having to install extra things all the time as root when your service has over 3000 users as ARCHER2 does). Starting expectation is that dependencies can be satified in user space. Is there no way of satisfying this dependency from a user space install?\nI see I could also install it using Spack:\nhttps://packages.spack.io/package.html?name=libtirpc\nbut I assume this would be the same as my manual install. Why can't libmesh use an install of libtirpc that has not been installed by root?",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11038414",
                          "updatedAt": "2024-10-24T08:51:32Z",
                          "publishedAt": "2024-10-24T08:50:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You most likely can, I just never have.\nMy question was mostly did you install the devel version of that library",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11038633",
                          "updatedAt": "2024-10-24T09:07:10Z",
                          "publishedAt": "2024-10-24T09:07:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aturner-epcc"
                          },
                          "bodyText": "Ah, sorry, misunderstood! My local libtirpc install was from source so includes all headers and library files:\nauser@ln04:/work/z19/z19/auser/software/MOOSE> ls libtirpc\netc  include  lib  share\nauser@ln04:/work/z19/z19/auser/software/MOOSE> ls libtirpc/lib/\nlibtirpc.la  libtirpc.so  libtirpc.so.3  libtirpc.so.3.0.0  pkgconfig\nauser@ln04:/work/z19/z19/auser/software/MOOSE> ls libtirpc/include/tirpc/\nnetconfig.h  rpc  rpcsvc",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11038923",
                          "updatedAt": "2024-10-24T09:35:26Z",
                          "publishedAt": "2024-10-24T09:35:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@roystgnr it seems xdr is still missing. Is there another library we should be installing?",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11039910",
                          "updatedAt": "2024-10-24T11:15:53Z",
                          "publishedAt": "2024-10-24T11:15:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you just want to get moving you can modify update_and_rebuild_libmesh to remove the need for xdr. This won't affect anything in moose iirc (since we switched to ascii checkpoint)",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11039928",
                          "updatedAt": "2024-10-24T11:17:18Z",
                          "publishedAt": "2024-10-24T11:17:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "In the future posting config.log would be helpful so we can see exactly why something isn't being detected.\nThis time, though, it's unfortunately already clear.  From libmesh_optional_packages.m4, \"Note that we currently do not provide a way to specify a library PATH, but that could potentially be added.\"  The --with-xdr-libname=foorpc lets you try to link to libfoorpc.so instead of libtirpc.so if you have a different third-party RPC library, but for some reason we seem to be still assuming that the library is in your libs path already.\nYou can try --with-xdr-include=/work/z19/z19/auser/software/MOOSE/libtirpc/include/tirpc LIBS='-L /work/z19/z19/auser/software/MOOSE/libtirpc/lib/ -Wl,-rpath -Wl,/work/z19/z19/auser/software/MOOSE/libtirpc/lib/' (assuming those flags work for your compiler and linker; looks like your OS is SUSE-based so probably?)\nI'll see if I can fix it in libMesh but it'll be a few weeks until that gets downstream to MOOSE.  In the meantime I'd also agree that (if my LIBS hack doesn't work) just disabling binary XDR is a decent workaround.  IMHO .xda.gz has always been a strictly better option.",
                  "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11043064",
                  "updatedAt": "2024-10-24T16:06:26Z",
                  "publishedAt": "2024-10-24T16:06:25Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aturner-epcc"
                          },
                          "bodyText": "@roystgnr @GiudGiud Thanks both for the helpful suggestions. For the moment, I have gone with disablign XDR support. If it turns out that is critical for people then I may revisit this.",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11049630",
                          "updatedAt": "2024-10-25T08:08:19Z",
                          "publishedAt": "2024-10-25T08:08:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Sounds good thanks for letting us know.",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11081818",
                          "updatedAt": "2024-10-29T02:39:43Z",
                          "publishedAt": "2024-10-29T02:39:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "The configure option you need, in libMesh/libmesh#3985, just went into libMesh.  We should have it available in MOOSE in a week or two.",
                          "url": "https://github.com/idaholab/moose/discussions/28924#discussioncomment-11145438",
                          "updatedAt": "2024-11-04T17:26:04Z",
                          "publishedAt": "2024-11-04T17:26:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fullupwind about conservative like-advection",
          "author": {
            "login": "wangzhaohao"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nDear MOOSE Developers.\nI am solving this problem:\n$\\frac{\\partial p}{\\partial t}+\\nabla\u2022[(1-p)p\\overrightarrow{v}-\\nu\\nabla p]=0$\nin which $p$ is variable, $\\overrightarrow{v}$ is velocity about temperature, $\\nu$ is a diffusion coefficient.\nI would like to creat Fulupwind kernel to compute $\\nabla\u2022(1-p)p\\overrightarrow{v}$, and there is ConservativeAdvection and a disscusion.\nTo be more comprehensive, I paste all the code below\n#pragma once\n#include \"Kernel.h\"\n\n/*\nadcection-diffusion of pores\nthis is advection part\n$\\bigtriangledown \\dot [(1 - p) p \\vec{v}]$\n*/\n\nclass PoreAdvection : public Kernel\n{\npublic:\n  PoreAdvection(const InputParameters & parameters);\n\n  static InputParameters validParams();\n\nprotected:\n  virtual Real computeQpResidual() override;\n  virtual Real computeQpJacobian() override;\n  virtual void computeResidual() override;\n  virtual void computeJacobian() override;\n  RealVectorValue velocity() const; // m/s\n\n  const enum class UpwindType { none, full } _upwinding;\n  enum class JacRes\n  {\n    CALCULATE_RESIDUAL = 0,\n    CALCULATE_JACOBIAN = 1\n  };\n  const VariableValue & _u_nodal;\n  std::vector<bool> _upwind_node;\n  std::vector<Real> _dtotal_mass_out;\n\nprivate:\n  const VariableValue & _temperature;\n  const VariableGradient & _temperature_grad;\n  const VariableValue & _plutonium_concentration;\n  Real negSpeedQp() const;\n  void fullUpwind(JacRes res_or_jac);\n};\n#include \"PoreAdvection.h\"\n\nregisterMooseObject(\"MiracleApp\", PoreAdvection);\n\nInputParameters\nPoreAdvection::validParams()\n{\n  InputParameters params = Kernel::validParams();\n  params.addRequiredCoupledVar(\"temperature\", \"the MOX temperature in K\");\n  params.addCoupledVar(\"plutonium_concentration\", \"the plutonium concentration in range 0 - 1\");\n  MooseEnum upwinding(\"none full\", \"none\");\n  params.addParam<MooseEnum>(\"upwinding\", upwinding, \"the upwinding type\");\n\n  return params;\n}\n\nPoreAdvection::PoreAdvection(const InputParameters & parameters)\n  : Kernel(parameters),\n    _temperature(coupledValue(\"temperature\")),\n    _temperature_grad(coupledGradient(\"temperature\")),\n    _plutonium_concentration(coupledValue(\"plutonium_concentration\")),\n    _upwinding(getParam<MooseEnum>(\"upwinding\").getEnum<UpwindType>()),\n    _u_nodal(_var.dofValues()),\n    _upwind_node(0),\n    _dtotal_mass_out(0)\n{\n}\n\nRealVectorValue\nPoreAdvection::velocity() const\n{\n  RealVectorValue pore_grad = 0; //[K/m]\n  if (_plutonium_concentration[_qp] == 0)\n    pore_grad = 4 * _temperature_grad[_qp];\n  else // MOX\n    pore_grad = 5 * _temperature_grad[_qp];\n\n  Real molecules_volume = 0;              //[m^3]\n  if (_plutonium_concentration[_qp] == 0) // from THE KINETICS OF PORE MOVEMENT IN UOz FUEL RODS\n  {\n    molecules_volume =\n        6.023e23 * 270e-3 /\n        (1e3 * 10.97 /\n         (0.998 + 6.395e-6 * _temperature[_qp] + 3.543e-9 * std::pow(_temperature[_qp], 2) +\n          3e-12 * std::pow(_temperature[_qp], 3)));\n  }\n  else // MOX\n  {\n    Real puo2_mole_fraction =\n        _plutonium_concentration[_qp] / 274. /\n        (_plutonium_concentration[_qp] / 274. + (1 - _plutonium_concentration[_qp] / 270.));\n    Real uo2_mole_fraction =\n        (1 - _plutonium_concentration[_qp]) / 270. /\n        (_plutonium_concentration[_qp] / 274. + (1 - _plutonium_concentration[_qp]) / 270.);\n    molecules_volume =\n        0.25 * std::pow(puo2_mole_fraction * 5.396e-10 + uo2_mole_fraction * 5.470e-10, 3);\n  }\n\n  Real fuel_number_density = 5e17;   //[m^-3]\n  Real gas_number_density = 2.46e25; //[m^-3]\n  Real equivalent_mass = 1 / ((1 / 28.e-3 + 1 / 270e-3) * 6.023e23);//[kg]\n  Real diffusion_coeff =\n      3. / 8. * 1. /\n      (libMesh::pi * (fuel_number_density + gas_number_density) * std::pow(4.33e-10, 2)) *\n      std::sqrt(libMesh::pi * Boltzmann_constant * _temperature[_qp] / (2 *\n equivalent_mass));//[m^2/s]\n\n  RealVectorValue velocity = molecules_volume * diffusion_coeff * molecules_volume_dT * pore_grad;\n  Real universal_gas_constant = 8.31446261815324; //[J/mol/K]\n  Real Boltzmann_constant = 1.380649e-23;         //[J/K]\n  Real Avogadro_constant = 6.02214179e23;         //[molecules/mol]\n  Real corros_section_avg = 3e-10;                //[m^2]\n  Real uo2_molecules = 5e17;                      //[molecules/m^3]\n  Real He_molecules = 2.46e25;                    //[molecules/m^3]\n  Real He_molar = 4.0026020e-3;                   //[kg/mol]\n  Real uo2_molar = 270.03e-3;                     //[kg/mol]\n  Real diffusion_coeff =\n      std::sqrt(8 * universal_gas_constant * _temperature[_qp] / libMesh::pi) /\n      (3 * libMesh::pi * std::pow(corros_section_avg, 2) * (He_molecules + uo2_molecules)) *\n      std::sqrt((He_molar + uo2_molar) / (He_molar * uo2_molar)); //[m^2/s]\n  Real pre_factor_pressure = 0;\n  Real vaporization = 0;\n\n  if (_temperature[_qp] < 2000)\n  {\n    pre_factor_pressure = 0.1 * std::exp(33.785);\n    vaporization = 5.98e5;\n  }\n  else if (_temperature[_qp] < 2200)\n  {\n    pre_factor_pressure = 0.1 * std::exp(34.107);\n    vaporization = 6.17e5;\n  }\n  else\n  {\n    pre_factor_pressure = 0.1 * std::exp(35.813);\n    vaporization = 6.35e5;\n  }\n  Real vapour_pressure =\n      pre_factor_pressure * std::exp(-vaporization / universal_gas_constant / _temperature[_qp]);\n\n  // transport velocity in SI [m/s]\n  Real uo2_density =\n      1e3 * 10.97 /\n      (0.988 + 6.395e-6 * _temperature[_qp] + 3.543e-9 * std::pow(_temperature[_qp], 2) +\n       3e-12 * std::pow(_temperature[_qp], 3)); //[kg/m^3]\n  // material_flow = -D/kT *dp  velocity = -material_flow * \\omega\n  RealVectorValue material_flow = -diffusion_coeff / (Boltzmann_constant * _temperature[_qp]) *\n                                  vapour_pressure * vaporization /\n                                  (universal_gas_constant * std::pow(_temperature[_qp], 2)) * 4 *\n                                  _temperature_grad[_qp]; //[1/m^2s])\n\n  Real molecular_volume_uo2 = uo2_molar / (uo2_density * Avogadro_constant); //[m^3]\n  RealVectorValue velocity = -material_flow * molecular_volume_uo2;\n\n  RealVectorValue velocity_sens =\n      5.006e-12 *\n      (0.988 + 6.395e-6 * _temperature[_qp] + 3.543e-9 * std::pow(_temperature[_qp], 2) +\n       3e-12 * std::pow(_temperature[_qp], 3)) *\n      std::pow(_temperature[_qp], -2.5) * vaporization * vapour_pressure * _temperature_grad[_qp];\n  return velocity_sens;\n}\n\nReal\nPoreAdvection::computeQpResidual()\n{\n  return -_grad_test[_i][_qp] * (_u[_qp] - _u[_qp] * _u[_qp]) * velocity();\n}\n\nReal\nPoreAdvection::computeQpJacobian()\n{\n  return -_grad_test[_i][_qp] * (_phi[_j][_qp] - 2 * _u[_qp] * _phi[_j][_qp]) * velocity();\n}\n\nReal\nPoreAdvection::negSpeedQp() const\n{\n  return -_grad_test[_i][_qp] * velocity();\n}\n\nvoid\nPoreAdvection::computeResidual()\n{\n  switch (_upwinding)\n  {\n    case UpwindType::none:\n      Kernel::computeResidual();\n      break;\n    case UpwindType::full:\n      fullUpwind(JacRes::CALCULATE_RESIDUAL);\n      break;\n  }\n}\n\nvoid\nPoreAdvection::computeJacobian()\n{\n  switch (_upwinding)\n  {\n    case UpwindType::none:\n      Kernel::computeJacobian();\n      break;\n\n    case UpwindType::full:\n      fullUpwind(JacRes::CALCULATE_JACOBIAN);\n      break;\n  }\n}\n\nvoid\nPoreAdvection::fullUpwind(JacRes res_or_jac)\n{\n  // The number of nodes in the element\n  const unsigned int num_nodes = _test.size();\n\n  // Even if we are computing the Jacobian we still need to compute the outflow from each node to\n  // see which nodes are upwind and which are downwind\n  prepareVectorTag(_assembly, _var.number());\n\n  if (res_or_jac == JacRes::CALCULATE_JACOBIAN)\n    prepareMatrixTag(_assembly, _var.number(), _var.number());\n\n  // Compute the outflux from each node and store in _local_re\n  // If _local_re is positive at the node, mass (or whatever the Variable represents) is flowing out\n  // of the node\n  _upwind_node.resize(num_nodes);\n  for (_i = 0; _i < num_nodes; ++_i)\n  {\n    for (_qp = 0; _qp < _qrule->n_points(); _qp++)\n      _local_re(_i) += _JxW[_qp] * _coord[_qp] * negSpeedQp();\n    _upwind_node[_i] = (_local_re(_i) >= 0.0);\n  }\n\n  // Variables used to ensure mass conservation\n  Real total_mass_out = 0.0;\n  Real total_in = 0.0;\n  if (res_or_jac == JacRes::CALCULATE_JACOBIAN)\n    _dtotal_mass_out.assign(num_nodes, 0.0);\n\n  for (unsigned int n = 0; n < num_nodes; ++n)\n  {\n    if (_upwind_node[n])\n    {\n      if (res_or_jac == JacRes::CALCULATE_JACOBIAN)\n      {\n        if (_test.size() == _phi.size())\n          /* u at node=n depends only on the u at node=n, by construction.  For\n           * linear-lagrange variables, this means that Jacobian entries involving the derivative\n           * will only be nonzero for derivatives wrt variable at node=n.  Hence the\n           * (n, n) in the line below.  The above \"if\" statement catches other variable types\n           * (eg constant monomials)\n           */\n          _local_ke(n, n) += _local_re(n) * (1.0 - 2.0 * _u_nodal[n]);\n\n        _dtotal_mass_out[n] += _local_ke(n, n);\n      }\n      _local_re(n) *= _u_nodal[n] * (1.0 - _u_nodal[n]);\n      total_mass_out += _local_re(n);\n    }\n    else                        // downwind node\n      total_in -= _local_re(n); // note the -= means the result is positive\n  }\n\n  // Conserve mass over all phases by proportioning the total_mass_out mass to the inflow nodes,\n  // weighted by their local_re values\n  for (unsigned int n = 0; n < num_nodes; ++n)\n  {\n    if (!_upwind_node[n]) // downwind node\n    {\n      if (res_or_jac == JacRes::CALCULATE_JACOBIAN)\n        for (_j = 0; _j < _phi.size(); _j++)\n        {\n          Real factor = 1.0;\n          if (_j < num_nodes && _upwind_node[_j])\n            factor = (1.0 - 2.0 * _u_nodal[_j]);\n          _local_ke(n, _j) += _local_re(n) * _dtotal_mass_out[_j] * factor / total_in;\n        }\n      _local_re(n) *= total_mass_out / total_in;\n    }\n  }\n\n  // Add the result to the residual and jacobian\n  if (res_or_jac == JacRes::CALCULATE_RESIDUAL)\n  {\n    accumulateTaggedLocalResidual();\n\n    if (_has_save_in)\n    {\n      Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n      for (const auto & var : _save_in)\n        var->sys().solution().add_vector(_local_re, var->dofIndices());\n    }\n  }\n\n  if (res_or_jac == JacRes::CALCULATE_JACOBIAN)\n  {\n    accumulateTaggedLocalMatrix();\n\n    if (_has_diag_save_in)\n    {\n      unsigned int rows = _local_ke.m();\n      DenseVector<Number> diag(rows);\n      for (unsigned int i = 0; i < rows; i++)\n        diag(i) = _local_ke(i, i);\n\n      Threads::spin_mutex::scoped_lock lock(Threads::spin_mtx);\n      for (const auto & var : _diag_save_in)\n        var->sys().solution().add_vector(diag, var->dofIndices());\n    }\n  }\n}\nwhen I run this, I find the results are more oscillation and instability.\n\n\nHow did I fix this problem? I am not very familiar with upwind finite element.\nThank you very much in advance for your help.\nZhaohao Wang",
          "url": "https://github.com/idaholab/moose/discussions/28995",
          "updatedAt": "2024-11-04T13:52:41Z",
          "publishedAt": "2024-11-04T09:43:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI am not that familiar either. The kernel you listed is a good reference.\nI would attempt to separate this kernel in 3 parts and only upwind one of them at a time to see which one is causing the oscillations\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28995#discussioncomment-11142619",
                  "updatedAt": "2024-11-04T13:26:03Z",
                  "publishedAt": "2024-11-04T13:26:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "Yes, I also thought this method. Three part is good. I also read the Ref in the ConservativeAdvection, Umm, hard to understand the method. So does anyone know of a way to do this? I don't want my code to be too verbose.",
                          "url": "https://github.com/idaholab/moose/discussions/28995#discussioncomment-11142910",
                          "updatedAt": "2024-11-04T13:52:41Z",
                          "publishedAt": "2024-11-04T13:52:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "What is the default operation precision in MOOSE?",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nWhat is the default operation precision in MOOSE?\nHow many digits after the decimal point?\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/21799",
          "updatedAt": "2024-11-04T09:19:10Z",
          "publishedAt": "2022-08-08T15:37:50Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe use double precision for floating point numbers.\n\nHow many digits after the decimal point?\n\nIt's not that simple. Very grossly simplifying, 16, but please read more about this topic. (google floating point precision)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-3351249",
                  "updatedAt": "2022-08-08T16:56:00Z",
                  "publishedAt": "2022-08-08T16:55:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ahzeeshan"
                  },
                  "bodyText": "In my solution, I have one variable that can take values from 1e16 to 1 and another that can vary from 1e-33 to 1. How can I increase the moose precision during installation to accommodate these variables?",
                  "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11131681",
                  "updatedAt": "2024-11-02T22:45:26Z",
                  "publishedAt": "2024-11-02T22:45:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nYou'll need to start by modifying the petsc install to increase precision there\nhttps://petsc.org/release/faq/#can-i-run-petsc-with-extended-precision\nThen set LIBMESH_DEFAULT_QUADRUPLE_PRECISION when compiling libmesh.\nThe MOOSE should adapt to the precision chosen in libmesh.\nBut this is not tested, so you'll need to adapt the code in a few places to get it to compile. It should not be too difficult however.",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11131714",
                          "updatedAt": "2024-11-02T22:54:17Z",
                          "publishedAt": "2024-11-02T22:54:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would first try to get the simulations working with the double precision. It's not because the variable values can vary over a large range that:\n\nall of the range is utilized\neven if all of the range is utilized, it can very well be that the matrix is still well conditioned and you get a workable solution",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11131721",
                          "updatedAt": "2024-11-02T22:55:35Z",
                          "publishedAt": "2024-11-02T22:55:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ahzeeshan"
                          },
                          "bodyText": "All of the variable range is utilized because the variable will have two values at the boundaries.\nI have tried running it with default precision but get convergence problems. The code has a parameter V that can be varied - this parameter determines the range of values of the two variables. When V is low, the range of variables is smaller and I am able to get convergence. When I increase V, the solution does not converge. This is why I think it might have to do with precision.",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11132486",
                          "updatedAt": "2024-11-03T04:36:10Z",
                          "publishedAt": "2024-11-03T04:36:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It could be that.\nOr it could be a conditioning issue. See the troubleshooting failed solves instructions to see how to get the condition number of the matrix",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11132579",
                          "updatedAt": "2024-11-03T05:09:25Z",
                          "publishedAt": "2024-11-03T05:09:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ahzeeshan"
                          },
                          "bodyText": "Thanks for the suggestion. You are right, the condition number is very large - it becomes >1e11 after the first 3-4 non-linear iterations. I am using automatic scaling for all variables. Since scaling didn't help, is there any other approach to solve this issue? Will increasing precision help?",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11138390",
                          "updatedAt": "2024-11-04T03:53:13Z",
                          "publishedAt": "2024-11-04T03:53:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I would try manual scaling as that can be more robust.\nThen you could split the domain with multiple variables that cover each different parts of the range of possible values, tied together using interface kernels, so that you can apply scaling independently to each part of the range",
                          "url": "https://github.com/idaholab/moose/discussions/21799#discussioncomment-11140191",
                          "updatedAt": "2024-11-04T09:19:10Z",
                          "publishedAt": "2024-11-04T09:19:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}