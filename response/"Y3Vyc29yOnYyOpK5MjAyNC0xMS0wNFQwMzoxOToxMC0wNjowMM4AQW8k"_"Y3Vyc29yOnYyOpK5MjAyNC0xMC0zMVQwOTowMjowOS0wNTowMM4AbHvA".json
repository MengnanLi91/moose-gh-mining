{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0xMC0zMVQwOTowMjowOS0wNTowMM4AbHvA"
    },
    "edges": [
      {
        "node": {
          "title": "Small time steps",
          "author": {
            "login": "ashishdhole"
          },
          "bodyText": "Hello!\nI have made this kernel where if g = 0 then it is same as ACGrGrPoly (Grain Growth Kernel). when I compare the two I see different values and also the timesteps are very small by using this kernel. Is there anything I am missing. Any suggestion will be appreciated. I am struggling to get this thing done. but the time steps are so small that it is taking more than 5-6 days to finish half of the simulation.\n#include \"AdvanceFrictionPressure.h\"\n\nregisterMooseObject(\"pfubcApp\", AdvanceFrictionPressure);\n\nInputParameters\nAdvanceFrictionPressure::validParams()\n{\n  InputParameters params = JvarMapKernelInterface<Kernel>::validParams();\n  params.addClassDescription(\"Gradient energy Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"mob_name\", \"L\", \"The mobility used with the kernel\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with the kernel\");\n  params.addRequiredCoupledVarWithAutoBuild(\n      \"v\", \"var_name_base\", \"op_num\", \"Array of coupled variables\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  return params;\n}\n\nAdvanceFrictionPressure::AdvanceFrictionPressure(const InputParameters & parameters)\n  : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n    _L(getMaterialProperty<Real>(\"mob_name\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _mu(getMaterialProperty<Real>(\"mu\")),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n    _vals_var(coupledIndices(\"v\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\"))\n{\n}\n\nReal\nAdvanceFrictionPressure::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nAdvanceFrictionPressure::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nRealGradient\nAdvanceFrictionPressure::nablaLPsi()\n{\n  // sum is the product rule gradient \\f$ \\nabla (L\\psi) \\f$\n  RealGradient sum = _L[_qp] * _grad_test[_i][_qp];\n\n  return sum;\n}\n\nRealGradient\nAdvanceFrictionPressure::kappaNablaLPsi()\n{\n  return _kappa[_qp] * nablaLPsi();\n}\n\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  if (total_abs - friction_energy_abs > epsilon * max_abs)\n  {\n    return _L[_qp] * ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) -\n                      (3 * sgn * g * _sigma[_qp] * op * SumOPj));\n  }\n\n  return 0;\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  if (total_abs - friction_energy_abs > epsilon * max_abs)\n  {\n    return _L[_qp] * ((_phi[_j][_qp] * (_mu[_qp] * (3.0 * op * op - 1.0 + 3 * SumOPj))) -\n                      (_phi[_j][_qp] * 3 * _sigma[_qp] * sgn * g * SumOPj));\n  }\n\n  return 0;\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPj = 0.0;\n  Real SumOPGj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      const Real dDFDOP =\n          _phi[_j][_qp] * ((_mu[_qp] * 2.0 * _gamma[_qp] * op * 2.0 * other_ops[i]) -\n                           sgn * ((3 * g * _sigma[_qp] * op)));\n\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return _L[_qp] * _test[_i][_qp] * dDFDOP;\n      else\n        return 0;\n    }\n\n  return 0;\n}\n\nThank you",
          "url": "https://github.com/idaholab/moose/discussions/28797",
          "updatedAt": "2024-11-03T19:56:44Z",
          "publishedAt": "2024-10-07T10:52:22Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHave you run the Jacobian analyser to make sure the Jacobian is correct?\nhttps://mooseframework.inl.gov/moose/application_usage/failed_solves.html\nIf it s not correct that would make taking large time steps difficult",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10866977",
                  "updatedAt": "2024-10-07T12:26:11Z",
                  "publishedAt": "2024-10-07T12:26:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "You are right. The Jacobian seems to be wrong.\nRunning input with executable pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is wrong (off by 52.3 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.2 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 71.0 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 66.6 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.2 %)\n  (1,1) On-diagonal Jacobian is wrong (off by 50.8 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 72.2 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.0 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 71.0 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 72.2 %)\n  (2,2) On-diagonal Jacobian is wrong (off by 46.0 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 67.4 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 66.6 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 67.4 %)\n  (3,3) On-diagonal Jacobian is wrong (off by 43.8 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is inexact (off by 4.411 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 64.1 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.4 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.0 %)\n  (1,1) On-diagonal Jacobian is wrong (off by 27.3 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 68.3 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.5 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 64.0 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.3 %)\n  (2,2) On-diagonal Jacobian is inexact (off by 2.146 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.3 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 65.4 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.5 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 65.3 %)\n  (3,3) On-diagonal Jacobian is slightly off (by 0.000113 %)\n\nBut in the code it looks fine. Can you suggest me what is wrong in the jacobian here?\nThank you",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10871980",
                          "updatedAt": "2024-10-07T18:47:37Z",
                          "publishedAt": "2024-10-07T18:47:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you must have forgotten to include off diagonal terms in your custom kernel.\nyou could start your kernels again (write a new set, and preface the name with AD) using automatic differentiation and automartically the Jacobian would be correct",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10872063",
                          "updatedAt": "2024-10-07T18:57:02Z",
                          "publishedAt": "2024-10-07T18:57:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "ok let me try that.\nThank you very much. I will get back to you.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10872176",
                          "updatedAt": "2024-10-07T19:09:44Z",
                          "publishedAt": "2024-10-07T19:09:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "One small doubt. Do I have to define my variables and properties with AD As shown below?\nyou said\nprotected:\n  virtual ADReal computeQpResidual();\n  const ADVariableValue & _g;\n  const unsigned int _op_num;\n  const std::vector<const ADVariableValue *> _vals;\n  const ADMaterialProperty<Real> & _mu;\n  const ADMaterialProperty<Real> & _sigma;\n  const ADMaterialProperty<Real> & _gamma;\n  /// Mobility\n  const ADMaterialProperty<Real> & _prop_L;\n  /// Mobility property name\n  const MaterialPropertyName & _name_L;\n\n  /// Interfacial parameter\n  const ADMaterialProperty<Real> & _kappa;\n\nyou said\n\nwrite a new set, and preface the name with AD\n\nHere does name means Kernel name?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10873169",
                          "updatedAt": "2024-10-07T21:11:36Z",
                          "publishedAt": "2024-10-07T21:11:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the name is AdvanceFrictionPressure\nyes you would need to use every single property as ADMaterial properties\nif that is too much work, then implement computeQpOffDiagJacobian in your kernels instead",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10873200",
                          "updatedAt": "2024-10-07T21:16:22Z",
                          "publishedAt": "2024-10-07T21:16:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I have added an offdiagonaljacobian to my code\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    if (jvar == _vals_var[i])\n    {\n      // Derivative of Sumopj\n      const Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      const Real dSumOPGj = _phi[_j][_qp];\n      const Real dDFDOP =\n          (_mu[_qp] * 2.0 * _gamma[_qp] * op * dSumOPj) - (_sigma[_qp] * 3.0 * g * op * dSumOPGj);\n\n      // get the coupled variable jvar is referring to\n      const unsigned int cvar = mapJvarToCvar(jvar);\n\n      // dsum is the derivative \\f$ \\frac\\partial{\\partial \\eta} \\left( \\nabla (L\\psi) \\right) \\f$\n      RealGradient dsum =\n          ((*_dkappadarg[cvar])[_qp] * _L[_qp] + _kappa[_qp] * (*_dLdarg[cvar])[_qp]) *\n          _phi[_j][_qp] * _grad_test[_i][_qp];\n      if (total_abs > friction_energy_abs)\n      {\n        return (_L[_qp] * _test[_i][_qp] * dDFDOP) + _grad_u[_qp] * dsum;\n      }\n      else\n      {\n        return 0;\n      }\n    }\n  }\n\n  return 0.0;\n}\n\nbut I am still getting\nRunning input with executable pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is wrong (off by 45.0 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.2 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 71.0 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 66.6 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.2 %)\n  (1,1) On-diagonal Jacobian is wrong (off by 43.8 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 72.2 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.0 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 71.0 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 72.2 %)\n  (2,2) On-diagonal Jacobian is wrong (off by 39.9 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 67.4 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 66.6 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 67.4 %)\n  (3,3) On-diagonal Jacobian is wrong (off by 36.2 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is inexact (off by 4.804 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 64.2 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.8 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.0 %)\n  (1,1) On-diagonal Jacobian is wrong (off by 25.7 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 69.7 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.6 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 64.2 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 69.7 %)\n  (2,2) On-diagonal Jacobian is inexact (off by 2.328 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.6 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 65.8 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.6 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 65.6 %)\n\nwhat is wrong with my offdiagonal jacobian. I am trying to add the jacobian of ACGrGrPoly and ACInterface.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10875112",
                          "updatedAt": "2024-10-08T03:42:33Z",
                          "publishedAt": "2024-10-08T03:42:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you remove your kernel, do you get correct off-diagonals ? just checking",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10875134",
                          "updatedAt": "2024-10-08T03:47:28Z",
                          "publishedAt": "2024-10-08T03:47:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "This is basically same as ACGrGrPoly\nReal\nAdvanceFrictionPressure::AdvanceFrictionPressure::computeQpResidual()\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  // Sum all other order parameters\n  Real SumOPj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n    SumOPj += other_ops[i] * other_ops[i];\n\n  return _L[_qp] * _mu[_qp] * (op * op * op - op + 2.0 * _gamma[_qp] * op * SumOPj);\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  // Sum all other order parameters\n  Real SumOPj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n    SumOPj += other_ops[i] * other_ops[i];\n\n  return _L[_qp] * _mu[_qp] * (_phi[_j][_qp] * (3.0 * op * op - 1.0 + 2.0 * _gamma[_qp] * SumOPj));\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      // Derivative of Sumopj\n      const Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      const Real dDFDOP = _mu[_qp] * 2.0 * _gamma[_qp] * op * dSumOPj;\n\n      return _L[_qp] * _test[_i][_qp] * dDFDOP;\n    }\n\n  return 0.0;\n}\n\nI am getting\nRunning input with executable pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.2 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 71.0 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 66.6 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.2 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 72.2 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.0 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 71.0 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 72.2 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 67.4 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 66.6 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 67.4 %)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.0 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 64.2 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.8 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.0 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 69.7 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 68.6 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 64.2 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 69.7 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 65.6 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 65.8 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 68.6 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 65.6 %)\n\nBut if I run the simulation with actual ACGrGrPoly that is available in moose\nI get this\nRunning input with executable pfubc-opt ...\n\nNo errors detected. :-)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000688 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001599 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001263 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.004878 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000382 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001707 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001477 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000295 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000132 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000076 %)",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10875187",
                          "updatedAt": "2024-10-08T03:57:42Z",
                          "publishedAt": "2024-10-08T03:57:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "well I think this is pretty clear. Something is wrong in your off-diagonals still.\nIt's clearly for the coupling between grains.\nThere seems to be this 2/3rd factor involved, as if 2/3 of the term was missing",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10875319",
                          "updatedAt": "2024-10-08T04:26:53Z",
                          "publishedAt": "2024-10-08T04:26:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "does _gamma depend on the other grain concentrations? what about _mu and _L?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10875332",
                          "updatedAt": "2024-10-08T04:29:58Z",
                          "publishedAt": "2024-10-08T04:29:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello,\nSo meanwhile I made another Kernel that is derived from ACGrGrPoly (Another grain growth kernel in the MOOSE).\nfollowing is the kernel I made (FPACGrGrPoly)\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"FPACGrGrPoly.h\"\n#include \"Kernel.h\"\n\nregisterMooseObject(\"PhaseFieldApp\", FPACGrGrPoly);\n\nInputParameters\nFPACGrGrPoly::validParams()\n{\n  InputParameters params = ACGrGrBase::validParams();\n  params.addClassDescription(\"Grain-Boundary model poly-crystalline interface Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  params.addCoupledVar(\"g\", 0.0, \"Friction pressure\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with the kernel\");\n  return params;\n}\n\nFPACGrGrPoly::FPACGrGrPoly(const InputParameters & parameters)\n  : ACGrGrBase(parameters),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\"))\n{\n}\n\nReal\nFPACGrGrPoly::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nFPACGrGrPoly::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nReal\nFPACGrGrPoly::computeDFDOP(PFFunctionType type)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  // Calculate either the residual or Jacobian of the grain growth free energy\n  switch (type)\n  {\n    case Residual:\n    {\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return (_mu[_qp] * (op * op * op - op + 2.0 * _gamma[_qp] * op * SumOPj)) -\n               (sgn * _sigma[_qp] * 3 * g * op * SumOPGj);\n      else\n        return 0;\n    }\n\n    case Jacobian:\n    {\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return (_mu[_qp] * (_phi[_j][_qp] * (3.0 * op * op - 1.0 + 2.0 * _gamma[_qp] * SumOPj))) -\n               (sgn * _phi[_j][_qp] * _sigma[_qp] * 3 * g * SumOPGj);\n      else\n        return 0;\n    }\n\n    default:\n      mooseError(\"Invalid type passed in\");\n  }\n}\n\nReal\nFPACGrGrPoly::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPj = 0.0;\n  Real SumOPGj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      const Real dDFDOP =\n          _phi[_j][_qp] * ((_mu[_qp] * 2.0 * _gamma[_qp] * op * 2.0 * other_ops[i]) -\n                           sgn * ((3 * g * _sigma[_qp] * op)));\n\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return _L[_qp] * _test[_i][_qp] * dDFDOP;\n      else\n        return 0;\n    }\n\n  return 0;\n}\n\nIt is also there in the repository. Now the only issue I am facing here is this term\nReal total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp];\n\nIf I introduce any term related to it say it is sgn variable or the if() condition inside Residual and Jacobian, I am getting segmentation fault. I tried many times to find the traces of error but not able to get any resolution. Although when I don't use anything related to 'total' the code works fine. I think\n               _grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]\n\nThis particular variables are the problem. Somehow the kernel is not able to take it well. If you can suggest me anything to make it work it will be great.\nI have added all the files to the repository.\n(Note: to run FPACGrGrPoly a small change in AdvanceFrictionPressureKernelAction is to be made. I have made a comment in this action file where the changes need to be made. )\nLooking forward to hearing from you.\nThank you.\nAshish",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10900828",
                  "updatedAt": "2024-10-10T07:41:47Z",
                  "publishedAt": "2024-10-10T07:41:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "didnt we go over this in another post?\nCan you please link it here so i can look if we had made some progress on this or if it was still an open question",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10903165",
                          "updatedAt": "2024-10-10T11:25:31Z",
                          "publishedAt": "2024-10-10T11:25:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "This is that post\n#28048\nBut it was not resolved and then I started working with different approach.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10906988",
                          "updatedAt": "2024-10-10T17:28:03Z",
                          "publishedAt": "2024-10-10T17:25:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "is this is what is causing issue\nKernelGrad\n\nDerive from this base class if your residual is of the form\n\n(\u2026,\u2207\u03c8i)\n(\u2026,\u2207\u03c8i\u200b)\n\ni.e. if the test function \u2207\u03c8i\u2207\u03c8i\u200b (_grad_test[_i][_qp]) can be factored out.\nDerived classes\n\nOverride\n\n    precomputeQpResidual() instead of computeQpResidual() (do not multiply by _grad_test[_i][_qp]).\n\n    precomputeQpJacobian() instead of computeQpJacobian() (do not multiply by _grad_test[_i][_qp])\n\n    computeOffDiagJacobian still has to be implemented as if deriving from Kernel.\n\nNote that precomputeQpResidual() and precomputeQpJacobian() return a RealGradient type. \n\nthe _grad_test[_i][_qp] is causing problem. I think I narrowed it down to this particular equation. Now we only have to figure out how to replace it or use it some other way.\nThank you",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10907726",
                          "updatedAt": "2024-10-10T18:55:31Z",
                          "publishedAt": "2024-10-10T18:55:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Hello,\nI am sorry to bother you like this, But were you able to see my code?\nJust for the reference I am using this paper to replicate the work.\n10.1088/0965-0393/20/6/065008\nLooking forward to hearing from you.\nThank you",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10909751",
                          "updatedAt": "2024-10-11T00:29:35Z",
                          "publishedAt": "2024-10-11T00:29:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont think the new kernel is derived from KernelGrad. In fact it is derived from an interface templated with KernelValue.\nThis is in itself a problem, because KernelValue multiplies the residual by _test[_qp] and you do not seem to be taking that into account in your kernel definition, as you multiply by grad_test[_qp]\nIf you need to multiply by grad_test due to the form of the equation, it looks like you will need to modify all the base classes of your new kernel",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910277",
                          "updatedAt": "2024-10-11T02:06:05Z",
                          "publishedAt": "2024-10-11T02:06:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Let's focus again on the issue for this post\nIn the computeQpOffJacobian, the last line I m pasting is wrong\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPj = 0.0;\n  Real SumOPGj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPj += other_ops[i];\n\nit should be\n SumOPGj += other_ops[i];\n\nwith this change, do you get a numerically correct Jacobian ?",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910296",
                  "updatedAt": "2024-10-11T02:10:00Z",
                  "publishedAt": "2024-10-11T02:09:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "No I have tried that. It shows jacobian off by 65%",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910308",
                          "updatedAt": "2024-10-11T02:11:56Z",
                          "publishedAt": "2024-10-11T02:11:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "well you still need to fix it.\nThe rest of the expression is wrong too\n      const Real dDFDOP =\n          _phi[_j][_qp] * ((_mu[_qp] * 2.0 * _gamma[_qp] * op * 2.0 * other_ops[i]) -\n                           sgn * ((3 * g * _sigma[_qp] * op)));\n\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return _L[_qp] * _test[_i][_qp] * dDFDOP;\n\nshould likely just be\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n          return _test[_i][_qp] * _phi[_j][_qp] * (_L[_qp] * _mu[_qp] * 3 * op -\n                                                                             3 * sgn * g * _sigma[_qp] * op);\n\n\nI might have made mistakes too, so feel free to re-derive it.\nI dont see why:\n\ngamma only comes in for the off diagonal of the Jacobian\nwhere the 2 * other_op is coming from ? there is no sum_OPj * sum_Opj term in the residual?\nwhy _test[_i][_qp] does not appear in the residual? This kernel is derived from the Kernel base class, not from KernelValue",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910380",
                          "updatedAt": "2024-10-11T02:29:40Z",
                          "publishedAt": "2024-10-11T02:25:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "The rest of the expression is wrong too\n\nI have taken this equation from ACGrGrPoly.C\nReal\nACGrGrPoly::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      // Derivative of Sumopj\n      const Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      const Real dDFDOP = _mu[_qp] * 2.0 * _gamma[_qp] * op * dSumOPj;\n\n      return _L[_qp] * _test[_i][_qp] * dDFDOP;\n    }\n\n  return 0.0;\n}\n\nBecause the new term is only subtracted from this , I used the same format.\n\n\ngamma only comes in for the off diagonal of the Jacobian\n\n\ngamma is defined as materials' property and remain constant. in this case gamma = 1.5, that why I replaced 2*gamma = 3 in off diagonal. no other reason\n\n\nwhere the 2 * other_op is coming from ? there is no sum_OPj * sum_Opj term in the residual?\n\n\nin residual\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n   Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\nSo op is the variable that this kernel is acting upon, other_op is the coupled variable (Other order parameters other than op)0\n\"2*other_op\"  you are probably talking about in the off diagonal jacobian, where the residual is differentiated by other order paramater than op.\nin short 2*other_op is basically differentiating SumOPj wrt other_op,\ndSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\nsimilarly\ndSumOPGj = _phi[_j][_qp];\n(as there is only one other_op) in SumOPGj\n\n\nwhy _test[_i][_qp] does not appear in the residual? This kernel is derived from the Kernel base class, not from KernelValue\n\n\nI am not sure about this but my kernel is derived from ACGrGrPoly, and in that kernel, residual is not multiplied by _test[_i][_qp]\n.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910452",
                          "updatedAt": "2024-10-11T02:40:22Z",
                          "publishedAt": "2024-10-11T02:40:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910534",
                          "updatedAt": "2024-10-11T02:54:55Z",
                          "publishedAt": "2024-10-11T02:54:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "running with _test[_qp] in residual and jacobian I get\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is wrong (off by 30.8 %)\n\nKernel for variable 'gr1':\n  (1,1) On-diagonal Jacobian is wrong (off by 30.1 %)\n\nKernel for variable 'gr2':\n  (2,2) On-diagonal Jacobian is wrong (off by 26.7 %)\n\nKernel for variable 'gr3':\n  (3,3) On-diagonal Jacobian is wrong (off by 23.8 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is questionable (off by 7.98 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001379 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003005 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000703 %)\n\nKernel for variable 'gr1':\n  (1,1) On-diagonal Jacobian is questionable (off by 8.50 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.002580 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000827 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001760 %)\n  (2,2) On-diagonal Jacobian is inexact (off by 4.173 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000586 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000881 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.178644 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000943 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.007045 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.036686 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.410310 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003030 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.041288 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.125067 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.031103 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.046662 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.043043 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003851 %)\n\nGreat improvement but I think there is still something missing\nHere is the updated kernel for your reference\n#include \"AdvanceFrictionPressure.h\"\n\nregisterMooseObject(\"pfubcApp\", AdvanceFrictionPressure);\n\nInputParameters\nAdvanceFrictionPressure::validParams()\n{\n  InputParameters params = JvarMapKernelInterface<Kernel>::validParams();\n  params.addClassDescription(\"Gradient energy Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"mob_name\", \"L\", \"The mobility used with the kernel\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with the kernel\");\n  params.addRequiredCoupledVarWithAutoBuild(\n      \"v\", \"var_name_base\", \"op_num\", \"Array of coupled variables\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  return params;\n}\n\nAdvanceFrictionPressure::AdvanceFrictionPressure(const InputParameters & parameters)\n  : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n    _L(getMaterialProperty<Real>(\"mob_name\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _mu(getMaterialProperty<Real>(\"mu\")),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n    _vals_var(coupledIndices(\"v\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\"))\n{\n}\n\nReal\nAdvanceFrictionPressure::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nAdvanceFrictionPressure::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nRealGradient\nAdvanceFrictionPressure::nablaLPsi()\n{\n  // sum is the product rule gradient \\f$ \\nabla (L\\psi) \\f$\n  RealGradient sum = _L[_qp] * _grad_test[_i][_qp];\n\n  return sum;\n}\n\nRealGradient\nAdvanceFrictionPressure::kappaNablaLPsi()\n{\n  return _kappa[_qp] * nablaLPsi();\n}\n\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * (_kappa[_qp] * _grad_test[_i][_qp]);\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  if (total_abs - friction_energy_abs > epsilon * max_abs)\n  {\n    return _L[_qp] * _test[_i][_qp] *\n           ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) -\n            (3 * sgn * g * _sigma[_qp] * op * SumOPj));\n  }\n\n  return 0;\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0, SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * (_kappa[_qp] * _grad_test[_i][_qp]);\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  if (total_abs - friction_energy_abs > epsilon * max_abs)\n  {\n    return _L[_qp] * _test[_i][_qp] *\n           ((_phi[_j][_qp] * (_mu[_qp] * (3.0 * op * op - 1.0 + 3 * SumOPj))) -\n            (_phi[_j][_qp] * 3 * _sigma[_qp] * sgn * g * SumOPj));\n  }\n\n  return 0;\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPj = 0.0;\n  Real SumOPGj = 0.0;\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = _mu[_qp] * (op * op * op - op + 3 * op * SumOPj) +\n               _grad_u[_qp] * (_kappa[_qp] * _grad_test[_i][_qp]);\n  Real friction_energy = _sigma[_qp] * 3 * g * op * SumOPGj;\n\n  Real epsilon = 1e-6;\n  Real total_abs = std::abs(total);\n  Real friction_energy_abs = std::abs(friction_energy);\n  Real max_abs = std::max(total_abs, friction_energy_abs);\n\n  // Manually compute the sign of `total`\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n\n      if (total_abs - friction_energy_abs > epsilon * max_abs)\n        return _L[_qp] * _test[_i][_qp] * _phi[_j][_qp] *\n               ((_mu[_qp] * 3.0 * op * 2.0 * other_ops[i]) - sgn * ((3 * g * _sigma[_qp] * op)));\n      else\n        return 0;\n    }\n\n  return 0;\n}\n\nI am sure I am missing something here.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910584",
                          "updatedAt": "2024-10-11T03:04:11Z",
                          "publishedAt": "2024-10-11T03:04:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok this explains a few things. I forgot that sum was quadratic.\nSo now the on diagonal must have mistakes.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910624",
                          "updatedAt": "2024-10-11T03:09:35Z",
                          "publishedAt": "2024-10-11T03:09:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Please make sure to update the repository. I ll check it tomorrow",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910641",
                          "updatedAt": "2024-10-11T03:11:18Z",
                          "publishedAt": "2024-10-11T03:11:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Sure. Thank you so much.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10910643",
                          "updatedAt": "2024-10-11T03:12:18Z",
                          "publishedAt": "2024-10-11T03:12:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in your input file, did you make sure not to pass the variable of the kernel to the 'v' parameter?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10911138",
                          "updatedAt": "2024-10-11T04:50:32Z",
                          "publishedAt": "2024-10-11T04:50:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Yes. I think the AdvanceFrictionPressureKernelAction is taking care of that.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10911250",
                          "updatedAt": "2024-10-11T05:09:15Z",
                          "publishedAt": "2024-10-11T05:09:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello,\nyou were right about adding one by one the terms see where the problem is.\nI finally have it 99% done.\n#include \"AdvanceFrictionPressure.h\"\n\nregisterMooseObject(\"pfubcApp\", AdvanceFrictionPressure);\n\nInputParameters\nAdvanceFrictionPressure::validParams()\n{\n  InputParameters params = JvarMapKernelInterface<Kernel>::validParams();\n  params.addClassDescription(\"Gradient energy Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"mob_name\", \"L\", \"The mobility used with the kernel\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with the kernel\");\n  params.addParam<bool>(\"variable_L\",\n                        false,\n                        \"The mobility is a function of any MOOSE variable (if \"\n                        \"this is set to false L must be constant over the \"\n                        \"entire domain!)\");\n  params.addRequiredCoupledVarWithAutoBuild(\n      \"v\", \"var_name_base\", \"op_num\", \"Array of coupled variables\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  return params;\n}\n\nAdvanceFrictionPressure::AdvanceFrictionPressure(const InputParameters & parameters)\n  : DerivativeMaterialInterface<JvarMapKernelInterface<Kernel>>(parameters),\n    _L(getMaterialProperty<Real>(\"mob_name\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\")),\n    _variable_L(getParam<bool>(\"variable_L\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _dLdop(getMaterialPropertyDerivative<Real>(\"mob_name\", _var.name())),\n    _d2Ldop2(getMaterialPropertyDerivative<Real>(\"mob_name\", _var.name(), _var.name())),\n    _dkappadop(getMaterialPropertyDerivative<Real>(\"kappa_name\", _var.name())),\n    _dLdarg(_n_args),\n    _d2Ldargdop(_n_args),\n    _d2Ldarg2(_n_args),\n    _dkappadarg(_n_args),\n    _gradarg(_n_args),\n    _mu(getMaterialProperty<Real>(\"mu\")),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n    _vals_var(coupledIndices(\"v\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\"))\n{\n  // Get mobility and kappa derivatives and coupled variable gradients\n  for (unsigned int i = 0; i < _n_args; ++i)\n  {\n    MooseVariable * ivar = _coupled_standard_moose_vars[i];\n    const VariableName iname = ivar->name();\n    if (iname == _var.name())\n    {\n      if (isCoupled(\"args\"))\n        paramError(\"args\",\n                   \"The kernel variable should not be specified in the coupled `args` parameter.\");\n      else\n        paramError(\"coupled_variables\",\n                   \"The kernel variable should not be specified in the coupled `coupled_variables` \"\n                   \"parameter.\");\n    }\n\n    _dLdarg[i] = &getMaterialPropertyDerivative<Real>(\"mob_name\", i);\n    _dkappadarg[i] = &getMaterialPropertyDerivative<Real>(\"kappa_name\", i);\n    _d2Ldargdop[i] = &getMaterialPropertyDerivative<Real>(\"mob_name\", iname, _var.name());\n\n    _gradarg[i] = &(ivar->gradSln());\n\n    _d2Ldarg2[i].resize(_n_args);\n    for (unsigned int j = 0; j < _n_args; ++j)\n      _d2Ldarg2[i][j] = &getMaterialPropertyDerivative<Real>(\"mob_name\", i, j);\n  }\n}\nvoid\nAdvanceFrictionPressure::initialSetup()\n{\n  validateCoupling<Real>(\"mob_name\");\n  validateCoupling<Real>(\"kappa_name\");\n}\n\nReal\nAdvanceFrictionPressure::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nAdvanceFrictionPressure::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_L[_qp] * (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj))) +\n               (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n  Real friction = _L[_qp] * 3 * _sigma[_qp] * op * SumOPGj;\n\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  // Real cond = 0;\n  // if (std::abs(total) > std::abs(friction))\n  //   cond = 1;\n\n  return (\n      (_test[_i][_qp] * (_L[_qp] * (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)))) -\n      (sgn * _test[_i][_qp] * _L[_qp] * 3 * _sigma[_qp] * g * op * SumOPGj) +\n      (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp])); // cond to be multiplied here\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_L[_qp] * (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj))) +\n               (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n  Real friction = _L[_qp] * 3 * _sigma[_qp] * op * SumOPGj;\n\n  Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n  // Real cond = 0;\n  // if (std::abs(total) > std::abs(friction))\n  //   cond = 1;\n\n  return ((_test[_i][_qp] *\n           (_L[_qp] * _phi[_j][_qp] * (_mu[_qp] * (3.0 * op * op - 1.0 + 3 * SumOPj)))) -\n          (sgn * _test[_i][_qp] * _L[_qp] * _phi[_j][_qp] * 3 * _sigma[_qp] * g * SumOPGj) +\n          (_grad_phi[_j][_qp] * _kappa[_qp] * _L[_qp] *\n           _grad_test[_i][_qp])); // cond to be multiplied here\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  const unsigned int cvar = mapJvarToCvar(jvar);\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    Real SumOPGj = 0.0;\n    Real SumOPj = 0.0;\n\n    for (unsigned int a = 0; a < _op_num; ++a)\n    {\n      SumOPj += other_ops[a] * other_ops[a];\n      SumOPGj += other_ops[a];\n    }\n\n    Real total = (_L[_qp] * (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj))) +\n                 (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n    Real friction = _L[_qp] * 3 * _sigma[_qp] * op * SumOPGj;\n\n    Real sgn = (total > 0) ? 1.0 : ((total < 0) ? -1.0 : 0.0);\n\n    if (jvar == _vals_var[i])\n    {\n      const Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      const Real dSumOPGj = _phi[_j][_qp];\n\n      // Real cond = 0;\n      // if (std::abs(total) > std::abs(friction))\n      //   cond = 1;\n\n      const Real dDFDOP =\n          ((_mu[_qp] * 2.0 * _gamma[_qp] * op * dSumOPj) -\n           (sgn * 3 * _sigma[_qp] * g * op * dSumOPGj)); // cond to be multiplied here\n\n      return _L[_qp] * _test[_i][_qp] * dDFDOP;\n    }\n  }\n  return 0;\n}\n\nand jacobian debugger also says\nRunning input with executable ./pfubc-opt ...\n\nNo errors detected. :-)\n\nKernel for variable 'gr0':\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001899 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000302 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000355 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.002775 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000066 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.002453 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.002783 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000711 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.178644 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000945 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.007046 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.036677 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.410309 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003027 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.041293 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.125065 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.031111 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.046655 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.043043 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003850 %)\n\nBut a small problem. if you see the code there is a 'if' condition\nReal cond = 0;\nif (std::abs(total) > std::abs(friction))\n  cond = 1;\n\nI want to multiply them to the Residual, jacobian and offdiagonal jacobian.\nbut when I do that I get\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is questionable (off by 5.32 %)\n\nKernel for variable 'gr1':\n  (1,1) On-diagonal Jacobian is questionable (off by 6.31 %)\n\nKernel for variable 'gr2':\n  (2,2) On-diagonal Jacobian is questionable (off by 7.75 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is inexact (off by 3.461 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (0,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (0,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (1,1) On-diagonal Jacobian is inexact (off by 4.165 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (1,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (2,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (2,2) On-diagonal Jacobian is questionable (off by 5.04 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is inexact (off by 3.461 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (0,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (0,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (1,1) On-diagonal Jacobian is inexact (off by 4.165 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (1,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (2,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (2,2) On-diagonal Jacobian is questionable (off by 5.04 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nI am very close but I don't understand why this if condition should be the problem.\nthank you",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10920082",
                  "updatedAt": "2024-10-12T01:06:11Z",
                  "publishedAt": "2024-10-12T01:06:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so with this if condition, and only with it, do you get a wrong jacobian?\nin the jacobian diagonal you still have this extra term btw\n          (_grad_phi[_j][_qp] * _kappa[_qp] * _L[_qp] *\n           _grad_test[_i][_qp]));\n\nthe way you do the Off diagonal jacobian with the loop on i is not super efficient. you might as well just find the i such that var_vals[i] == jvar, then use that",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10920114",
                          "updatedAt": "2024-10-12T01:18:59Z",
                          "publishedAt": "2024-10-12T01:18:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Yes, only when I use the if condition I get wrong jacobian.\nThe extra term is basically interface gradient term required for grain growth simulation, so it is supposed to be there, that was the intention earlier but because I was facing lot of difficulties earlier, I used ACInterface and add that kernel through action. but this is way more cleaner and just need one kernel for everything.\ncan you suggest any other kernel for reference for off diagonal loop?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10920171",
                          "updatedAt": "2024-10-12T01:36:38Z",
                          "publishedAt": "2024-10-12T01:36:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the other classes derived from the same base class are probably good examples (though check for the type, Kernel or KernelValue)",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10920271",
                          "updatedAt": "2024-10-12T02:18:05Z",
                          "publishedAt": "2024-10-12T02:18:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This if condition is introducing a nonlinearity. I wonder if that's what we are seeing in the Jacobian check.\nCould you please try to make it a continuously varying function between 0 and 1 (for example using a sigmoid, arctan or 1 - 1/(1+x) )\nand see if the Jacobian is perfect again",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10920924",
                          "updatedAt": "2024-10-12T06:06:44Z",
                          "publishedAt": "2024-10-12T06:06:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "The Idea is when total <= friction in the code, there should not be any grain boundary movement. that is the evolution of order parameter at that point should be zero. Hence the condition.\nBut as you suggested by using sigmoidal function\n  Real x = std::abs(total) - std::abs(friction);\n  Real cond = 1 - 1 / (1 + x);\n\nthe jacobian debugger shows this\n Running input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.204828 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 70.5 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 93.6 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 66.2 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 72.4 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.578476 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 97.8 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 63.6 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 89.8 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 97.6 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.413870 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is wrong (off by 53.9 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is wrong (off by 68.9 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is wrong (off by 72.8 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is wrong (off by 55.9 %)\n  (3,3) On-diagonal Jacobian is inexact (off by 1.691 %)\n\nKernel for variable 'gr0':\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000048 %)\n\nKernel for variable 'gr1':\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001300 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000302 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001172 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.000718 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000354 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001456 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.144207 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000194 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.011280 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.006697 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.040923 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001695 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.024055 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.027743 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.004141 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.005559 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.006752 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000002 %)\n\nUsing tan based sigmoid function\n      Real k = 1000.0;\n      Real cond = 0.5 * (1 + tanh(k * (std::abs(total) - std::abs(friction))));\n\nI am getting this\nRunning input with executable ./pfubc-opt ...\n\nNo errors detected. :-)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (0,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (0,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (1,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (1,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (2,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (2,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (0,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (0,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (1,2) Off-diagonal Jacobian for variable 'gr2' needs to be implemented\n  (1,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' needs to be implemented\n  (2,1) Off-diagonal Jacobian for variable 'gr1' needs to be implemented\n  (2,3) Off-diagonal Jacobian for variable 'gr3' needs to be implemented",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10921101",
                          "updatedAt": "2024-10-12T06:51:07Z",
                          "publishedAt": "2024-10-12T06:47:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "This was done using my previous code yesterday which works fine but is very slow. It has 150 grains, mesh size 25x25 uniform refine =3 and adaptivity on. It took me little over 3 hrs on 4 core laptop.\n\nyou can see grain growth but after some time the grain boundary movement stops.\n\n\n  \n    \n    \n\n    output.mov\n    \n  \n\n  \n\n  \n\n\nFor a large system like 6400 grains that I am working on, the time it takes is very large.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10921181",
                          "updatedAt": "2024-10-12T07:25:50Z",
                          "publishedAt": "2024-10-12T07:08:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For sigmoidal and the others you would also need to implement the derivatives of these functions for the on-diagonal and off-diagonal terms.\nIt would be good to see a perfect Jacobian when the 'if' is replaced by a smooth transition instead",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10923345",
                          "updatedAt": "2024-10-12T15:33:42Z",
                          "publishedAt": "2024-10-12T15:27:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "But cond is a scalar value.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10924379",
                          "updatedAt": "2024-10-12T18:49:53Z",
                          "publishedAt": "2024-10-12T18:49:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "not here anymore, it depends on the order parameters and it comes into the residual",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10924431",
                          "updatedAt": "2024-10-12T18:57:34Z",
                          "publishedAt": "2024-10-12T18:57:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am VERY confused about it now.  Can we use the header file to put in condition just like in ACBulk in moose where precomputeresidual and precomputejacobians are calculated based on conuteqpresidulal in .C file?\nlike this\n\ntemplate <typename T>\nReal\nACBulk<T>::precomputeQpResidual()\n{\n  // Get free energy derivative from function\n  Real dFdop = computeDFDOP(Residual);\n\n  // Set residual\n  return _L[_qp] * dFdop;\n}\n\ntemplate <typename T>\nReal\nACBulk<T>::precomputeQpJacobian()\n{\n  // Get free energy derivative and Jacobian\n  Real dFdop = computeDFDOP(Residual);\n\n  Real JdFdop = computeDFDOP(Jacobian);\n\n  // Set Jacobian value using product rule\n  return _L[_qp] * JdFdop + _dLdop[_qp] * _phi[_j][_qp] * dFdop;\n}",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10924449",
                          "updatedAt": "2024-10-12T19:03:15Z",
                          "publishedAt": "2024-10-12T19:03:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello,\nSorry to bother you again with this. So I have reached to this so far\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.003549 %)\n\nKernel for variable 'gr1':\n  (1,1) On-diagonal Jacobian is slightly off (by 0.002575 %)\n\nKernel for variable 'gr2':\n  (2,2) On-diagonal Jacobian is slightly off (by 0.006727 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.653418 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003828 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000663 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000840 %)\n  (1,1) On-diagonal Jacobian is inexact (off by 1.093 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.005968 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000135 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001223 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.312387 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000332 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000833 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.184664 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000815 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.006085 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.034506 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.475991 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003644 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.030764 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.153011 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.028809 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.040603 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.047589 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003503 %)\n\nthe code is\n#include \"AdvanceFrictionPressure.h\"\n\nregisterMooseObject(\"pfubcApp\", AdvanceFrictionPressure);\n\nInputParameters\nAdvanceFrictionPressure::validParams()\n{\n  InputParameters params = JvarMapKernelInterface<Kernel>::validParams();\n  params.addClassDescription(\"Gradient energy Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"mob_name\", \"L\", \"The mobility used with the kernel\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with the kernel\");\n  params.addRequiredCoupledVarWithAutoBuild(\n      \"v\", \"var_name_base\", \"op_num\", \"Array of coupled variables\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  return params;\n}\n\nAdvanceFrictionPressure::AdvanceFrictionPressure(const InputParameters & parameters)\n  : JvarMapKernelInterface<Kernel>(parameters),\n    _L(getMaterialProperty<Real>(\"mob_name\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _mu(getMaterialProperty<Real>(\"mu\")),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n    _vals_var(coupledIndices(\"v\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\"))\n{\n}\n\nReal\nAdvanceFrictionPressure::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nAdvanceFrictionPressure::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n  Real friction = 3 * g * _sigma[_qp] * op * SumOPGj;\n\n  Real k = 100;\n  Real sgn = tanh(k * total);\n\n  ////////////////////\n  Real abs_total = std::abs(total);\n  Real abs_friction = std::abs(friction);\n\n  // Tanh-based smooth condition\n  Real alpha = 100;\n  Real tanh_term = tanh(alpha * (abs_total - abs_friction));\n  Real smooth_condition = 0.5 * (1.0 + tanh_term);\n  ////////////////////\n\n  Real Res = (_test[_i][_qp] * _L[_qp] *\n              ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj) -\n                (sgn * 3 * _sigma[_qp] * g * op * SumOPGj)))) +\n             (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n\n  // return Res;\n  return smooth_condition * Res;\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\n  Real friction = 3 * g * _sigma[_qp] * op * SumOPGj;\n\n  const Real k = 100;\n  Real sgn = tanh(k * total);\n\n  // Derivatives wrt op\n  Real dtotal_dopi = _mu[_qp] * (3 * pow(op, 2) - 1 + 3 * SumOPj) +\n                     (_grad_phi[_j][_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n  Real dfriction_dopi = 3 * g * _sigma[_qp] * SumOPGj;\n  Real dsgn_dopi = k * pow(1 / cosh(k * total), 2) * dtotal_dopi;\n\n  ////////////////////\n  Real abs_total = std::abs(total);\n  Real abs_friction = std::abs(friction);\n\n  // Tanh-based smooth condition\n  Real alpha = 100;\n  Real tanh_term = tanh(alpha * (abs_total - abs_friction));\n  Real smooth_condition = 0.5 * (1.0 + tanh_term);\n\n  // Sign of total and friction\n  Real sgn_total = (total > 0) - (total < 0);          // Sign function for total\n  Real sgn_friction = (friction > 0) - (friction < 0); // Sign function for friction\n\n  // Derivative of the smooth condition wrt op using tanh\n  Real dsmooth_condition_dopi = 0.5 * (1.0 - pow(tanh_term, 2)) * alpha *\n                                (sgn_total * dtotal_dopi - sgn_friction * dfriction_dopi);\n  ////////////////\n\n  Real Res = (_test[_i][_qp] * _L[_qp] *\n              ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj) -\n                (sgn * 3 * _sigma[_qp] * g * op * SumOPGj)))) +\n             (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n\n  // Calculate Jacobian\n  Real Jac = _L[_qp] * _test[_i][_qp] * _phi[_j][_qp] *\n                 (_mu[_qp] * (3 * pow(op, 2) - 1 + 3 * SumOPj) -\n                  ((3 * _sigma[_qp] * g * SumOPGj * sgn) +\n                   (3 * _sigma[_qp] * g * op * SumOPGj * dsgn_dopi))) +\n             (_grad_phi[_j][_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n\n  // return Jac;\n  return smooth_condition * Jac + dsmooth_condition_dopi * Res;\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  const unsigned int cvar = mapJvarToCvar(jvar);\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops(_op_num);\n  other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int a = 0; a < _op_num; ++a)\n  {\n    SumOPj += other_ops[a] * other_ops[a];\n    SumOPGj += other_ops[a];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n  Real friction = 3 * _sigma[_qp] * op * g * SumOPGj;\n\n  Real k = 100;\n  Real sgn = tanh(k * total);\n\n  Real Res = (_test[_i][_qp] * _L[_qp] *\n              ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj) -\n                (sgn * 3 * _sigma[_qp] * g * op * SumOPGj)))) +\n             (_grad_u[_qp] * _kappa[_qp] * _L[_qp] * _grad_test[_i][_qp]);\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      Real dSumOPGj = _phi[_j][_qp];\n\n      // Derivatives wrt opj\n      Real dtotal_dopj = _mu[_qp] * (3 * op * dSumOPj);\n      Real dfriction_dopj = 3 * _sigma[_qp] * g * op * dSumOPGj;\n      Real dsgn_dopj = k * pow(1 / cosh(k * total), 2) * dtotal_dopj;\n\n      ////////////////////\n      Real abs_total = std::abs(total);\n      Real abs_friction = std::abs(friction);\n\n      // Tanh-based smooth condition\n      Real alpha = 100;\n      Real tanh_term = tanh(alpha * (abs_total - abs_friction));\n      Real smooth_condition = 0.5 * (1.0 + tanh_term);\n\n      // Sign of total and friction\n      Real sgn_total = (total > 0) - (total < 0);          // Sign function for total\n      Real sgn_friction = (friction > 0) - (friction < 0); // Sign function for friction\n\n      // Derivative of the smooth condition wrt opj using tanh\n      Real dsmooth_condition_dopj = 0.5 * (1.0 - pow(tanh_term, 2)) * alpha *\n                                    (sgn_total * dtotal_dopj - sgn_friction * dfriction_dopj);\n      ////////////////\n\n      Real offJac =\n          _L[_qp] * _test[_i][_qp] *\n          ((3 * op * dSumOPj * _mu[_qp]) - (sgn * 3 * _sigma[_qp] * g * op * dSumOPGj +\n                                            3 * _sigma[_qp] * g * op * SumOPGj * dsgn_dopj));\n\n      // return offJac;\n      return smooth_condition * offJac + dsmooth_condition_dopj * Res;\n    }\n  return 0;\n}\n\nbut if I don't use the smooth_condition (commented return in residual,  Jacobian and offdiagonal jacobian)\nI get this\nRunning input with executable ./pfubc-opt ...\n\nNo errors detected. :-)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000750 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.007229 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000453 %)\n\nKernel for variable 'gr1':\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.010808 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000894 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.007855 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000597 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000806 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.184664 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000820 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.006076 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.034511 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.475956 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003645 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.030775 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.152983 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.028808 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.040599 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.047593 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003503 %)\n\nwhat exactly is on diagonal jacobian here. I need to look into it but I am not ale to find anything wrong at the moment. can you have a look at it.\nThank you so much\nAshish",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995739",
                  "updatedAt": "2024-10-20T11:29:13Z",
                  "publishedAt": "2024-10-20T11:28:09Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This looks much better.\nAll discrepancies are 1% or less roughly right?\nI think you can move on now. So check if you can take larger time steps now?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995865",
                          "updatedAt": "2024-10-20T11:58:26Z",
                          "publishedAt": "2024-10-20T11:58:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "ok let me try. I will get back. Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995870",
                          "updatedAt": "2024-10-20T11:59:35Z",
                          "publishedAt": "2024-10-20T11:59:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I don't think its working\n\n\n*** Warning, This code is deprecated and will be removed in future versions:\nPlease update your main.C to adapt new main function in MOOSE framework, see'test/src/main.C in MOOSE as an example of moose::main()'. \n\n\n\ufffd[36m\n*** Info ***\n'execute_on' parameter specified in [Outputs] block is ignored for object 'checkpoint'.\nDefine this object in its own sub-block of [Outputs] to modify its execution schedule.\ufffd[39m\n                                                                               [\ufffd[33m  2.78 s\ufffd[39m] [\ufffd[33m  254 MB\ufffd[39m]\nFramework Information:\nMOOSE Version:           git commit 30fe3abb9c on 2024-07-31\nLibMesh Version:         \nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1\nCurrent Time:            Sun Oct 20 05:07:25 2024\nExecutable Timestamp:    Sun Oct 20 04:58:36 2024\n\nCheckpoint:\n  Wall Time Interval:      Every 3600.000000 s\n  User Checkpoint:         Outputs/checkpoint\n  # Checkpoints Kept:      2\n  Execute On:              TIMESTEP_END \n\nParallelism:\n  Num Processors:          4\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           distributed\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   \n    Total:                 58081\n    Local:                 14641\n    Min/Max/Avg:           14400/14641/14520\n  Elems:                   \n    Total:                 57600\n    Local:                 14400\n    Min/Max/Avg:           14400/14400/14400\n  Num Subdomains:          1\n  Num Partitions:          4\n  Partitioner:             parmetis\n\nNonlinear System:\n  Num DOFs:                464648\n  Num Local DOFs:          117128\n  Num Constrained DOFs:    3848\n  Local Constrained DOFs:  8\n  Variables:               { \"gr0\" \"gr1\" \"gr2\" \"gr3\" \"gr4\" \"gr5\" \"gr6\" \"gr7\" } \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                231362\n  Num Local DOFs:          58082\n  Num Constrained DOFs:    962\n  Local Constrained DOFs:  2\n  Variables:               \"bnds\" { \"unique_grains\" \"var_indices\" } \"phi\" \n  Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\" \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \"CONSTANT\" \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             SolutionTimeAdaptiveDT\n  TimeIntegrator:          BDF2\n  Solver Mode:             Preconditioned JFNK\n  PETSc Preconditioner:    hypre boomeramg \n\nCurrently Executing\n  Performing Initial Setup\n    Projecting Initial Solutions                                                         [\ufffd[33m  8.14 s\ufffd[39m] [\ufffd[33m  257 MB\ufffd[39m]\n  Finished Performing Initial Setup                                                      [\ufffd[33m 10.49 s\ufffd[39m] [\ufffd[33m  263 MB\ufffd[39m]\n\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\n\nTime Step 1, time = 0.1, dt = 0.1\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = \ufffd[32m3.764685e+01\ufffd[39m\n      0 Linear |R| = \ufffd[32m3.764685e+01\ufffd[39m\n      1 Linear |R| = \ufffd[32m7.767453e-01\ufffd[39m\n      2 Linear |R| = \ufffd[32m9.018634e-02\ufffd[39m\n      3 Linear |R| = \ufffd[32m5.824438e-03\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m3.629343e+00\ufffd[39m\n      0 Linear |R| = \ufffd[32m3.629343e+00\ufffd[39m\n      1 Linear |R| = \ufffd[32m3.445646e+00\ufffd[39m\n      2 Linear |R| = \ufffd[32m1.739312e+00\ufffd[39m\n      3 Linear |R| = \ufffd[32m1.255872e+00\ufffd[39m\n      4 Linear |R| = \ufffd[32m9.459253e-01\ufffd[39m\n      5 Linear |R| = \ufffd[32m8.909423e-01\ufffd[39m\n      6 Linear |R| = \ufffd[32m7.407877e-01\ufffd[39m\n      7 Linear |R| = \ufffd[33m7.406761e-01\ufffd[39m\n      8 Linear |R| = \ufffd[32m6.656309e-01\ufffd[39m\n      9 Linear |R| = \ufffd[32m6.094072e-01\ufffd[39m\n     10 Linear |R| = \ufffd[33m6.091463e-01\ufffd[39m\n     11 Linear |R| = \ufffd[32m5.400718e-01\ufffd[39m\n     12 Linear |R| = \ufffd[32m3.886766e-01\ufffd[39m\n     13 Linear |R| = \ufffd[33m3.884649e-01\ufffd[39m\n     14 Linear |R| = \ufffd[33m3.696327e-01\ufffd[39m\n     15 Linear |R| = \ufffd[32m2.939678e-01\ufffd[39m\n     16 Linear |R| = \ufffd[32m2.768585e-01\ufffd[39m\n     17 Linear |R| = \ufffd[33m2.742878e-01\ufffd[39m\n     18 Linear |R| = \ufffd[32m2.087444e-01\ufffd[39m\n     19 Linear |R| = \ufffd[33m1.984259e-01\ufffd[39m\n     20 Linear |R| = \ufffd[32m1.657327e-01\ufffd[39m\n     21 Linear |R| = \ufffd[32m1.430778e-01\ufffd[39m\n     22 Linear |R| = \ufffd[32m1.334376e-01\ufffd[39m\n     23 Linear |R| = \ufffd[32m1.112005e-01\ufffd[39m\n     24 Linear |R| = \ufffd[33m1.111823e-01\ufffd[39m\n     25 Linear |R| = \ufffd[32m9.621404e-02\ufffd[39m\n     26 Linear |R| = \ufffd[32m9.086889e-02\ufffd[39m\n     27 Linear |R| = \ufffd[33m8.653964e-02\ufffd[39m\n     28 Linear |R| = \ufffd[33m8.406082e-02\ufffd[39m\n     29 Linear |R| = \ufffd[33m8.279928e-02\ufffd[39m\n     30 Linear |R| = \ufffd[33m8.178184e-02\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 2 Nonlinear |R| = \ufffd[32m8.956907e-01\ufffd[39m\n      0 Linear |R| = \ufffd[32m8.956907e-01\ufffd[39m\n      1 Linear |R| = \ufffd[33m8.956906e-01\ufffd[39m\n      2 Linear |R| = \ufffd[33m8.956883e-01\ufffd[39m\n      3 Linear |R| = \ufffd[33m8.956861e-01\ufffd[39m\n      4 Linear |R| = \ufffd[33m8.956839e-01\ufffd[39m\n      5 Linear |R| = \ufffd[33m8.956816e-01\ufffd[39m\n      6 Linear |R| = \ufffd[33m8.956794e-01\ufffd[39m\n      7 Linear |R| = \ufffd[33m8.956771e-01\ufffd[39m\n      8 Linear |R| = \ufffd[33m8.956749e-01\ufffd[39m\n      9 Linear |R| = \ufffd[33m8.956727e-01\ufffd[39m\n     10 Linear |R| = \ufffd[33m8.956704e-01\ufffd[39m\n     11 Linear |R| = \ufffd[33m8.956682e-01\ufffd[39m\n     12 Linear |R| = \ufffd[33m8.956660e-01\ufffd[39m\n     13 Linear |R| = \ufffd[33m8.956637e-01\ufffd[39m\n     14 Linear |R| = \ufffd[33m8.956615e-01\ufffd[39m\n     15 Linear |R| = \ufffd[33m8.956592e-01\ufffd[39m\n     16 Linear |R| = \ufffd[33m8.956570e-01\ufffd[39m\n     17 Linear |R| = \ufffd[33m8.956548e-01\ufffd[39m\n     18 Linear |R| = \ufffd[33m8.956525e-01\ufffd[39m\n     19 Linear |R| = \ufffd[33m8.956503e-01\ufffd[39m\n     20 Linear |R| = \ufffd[33m8.956481e-01\ufffd[39m\n     21 Linear |R| = \ufffd[33m8.956458e-01\ufffd[39m\n     22 Linear |R| = \ufffd[33m8.956436e-01\ufffd[39m\n     23 Linear |R| = \ufffd[33m8.956414e-01\ufffd[39m\n     24 Linear |R| = \ufffd[33m8.956391e-01\ufffd[39m\n     25 Linear |R| = \ufffd[33m8.956369e-01\ufffd[39m\n     26 Linear |R| = \ufffd[33m8.956346e-01\ufffd[39m\n     27 Linear |R| = \ufffd[33m8.956324e-01\ufffd[39m\n     28 Linear |R| = \ufffd[33m8.956302e-01\ufffd[39m\n     29 Linear |R| = \ufffd[33m8.956279e-01\ufffd[39m\n     30 Linear |R| = \ufffd[33m8.956257e-01\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 3 Nonlinear |R| = \ufffd[33m8.956905e-01\ufffd[39m\n      0 Linear |R| = \ufffd[32m8.956905e-01\ufffd[39m\n      1 Linear |R| = \ufffd[33m8.956904e-01\ufffd[39m\n      2 Linear |R| = \ufffd[33m8.954786e-01\ufffd[39m\n      3 Linear |R| = \ufffd[32m8.295185e-01\ufffd[39m\n      4 Linear |R| = \ufffd[33m8.021139e-01\ufffd[39m\n      5 Linear |R| = \ufffd[33m7.738469e-01\ufffd[39m\n      6 Linear |R| = \ufffd[33m7.716900e-01\ufffd[39m\n      7 Linear |R| = \ufffd[33m7.631383e-01\ufffd[39m\n      8 Linear |R| = \ufffd[33m7.438382e-01\ufffd[39m\n      9 Linear |R| = \ufffd[33m7.075148e-01\ufffd[39m\n     10 Linear |R| = \ufffd[32m6.658380e-01\ufffd[39m\n     11 Linear |R| = \ufffd[32m4.235387e-01\ufffd[39m\n     12 Linear |R| = \ufffd[33m4.116842e-01\ufffd[39m\n     13 Linear |R| = \ufffd[32m3.823932e-01\ufffd[39m\n     14 Linear |R| = \ufffd[32m3.126606e-01\ufffd[39m\n     15 Linear |R| = \ufffd[32m2.908851e-01\ufffd[39m\n     16 Linear |R| = \ufffd[33m2.866650e-01\ufffd[39m\n     17 Linear |R| = \ufffd[33m2.807683e-01\ufffd[39m\n     18 Linear |R| = \ufffd[32m2.661196e-01\ufffd[39m\n     19 Linear |R| = \ufffd[32m2.493560e-01\ufffd[39m\n     20 Linear |R| = \ufffd[33m2.430896e-01\ufffd[39m\n     21 Linear |R| = \ufffd[33m2.392249e-01\ufffd[39m\n     22 Linear |R| = \ufffd[32m2.218393e-01\ufffd[39m\n     23 Linear |R| = \ufffd[33m2.210137e-01\ufffd[39m\n     24 Linear |R| = \ufffd[33m2.135378e-01\ufffd[39m\n     25 Linear |R| = \ufffd[32m2.020795e-01\ufffd[39m\n     26 Linear |R| = \ufffd[33m2.013340e-01\ufffd[39m\n     27 Linear |R| = \ufffd[33m1.924127e-01\ufffd[39m\n     28 Linear |R| = \ufffd[32m1.825820e-01\ufffd[39m\n     29 Linear |R| = \ufffd[32m1.667472e-01\ufffd[39m\n     30 Linear |R| = \ufffd[33m1.646775e-01\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 4 Nonlinear |R| = \ufffd[32m6.777260e-01\ufffd[39m\n      0 Linear |R| = \ufffd[32m6.777260e-01\ufffd[39m\n      1 Linear |R| = \ufffd[32m2.884173e-01\ufffd[39m\n      2 Linear |R| = \ufffd[32m1.403607e-01\ufffd[39m\n      3 Linear |R| = \ufffd[32m1.087947e-01\ufffd[39m\n      4 Linear |R| = \ufffd[33m1.069581e-01\ufffd[39m\n      5 Linear |R| = \ufffd[33m1.062109e-01\ufffd[39m\n      6 Linear |R| = \ufffd[33m1.060233e-01\ufffd[39m\n      7 Linear |R| = \ufffd[33m1.047513e-01\ufffd[39m\n      8 Linear |R| = \ufffd[32m9.796113e-02\ufffd[39m\n      9 Linear |R| = \ufffd[32m8.406850e-02\ufffd[39m\n     10 Linear |R| = \ufffd[32m7.514669e-02\ufffd[39m\n     11 Linear |R| = \ufffd[33m7.266081e-02\ufffd[39m\n     12 Linear |R| = \ufffd[33m7.223395e-02\ufffd[39m\n     13 Linear |R| = \ufffd[32m6.819425e-02\ufffd[39m\n     14 Linear |R| = \ufffd[32m5.452372e-02\ufffd[39m\n     15 Linear |R| = \ufffd[32m4.658762e-02\ufffd[39m\n     16 Linear |R| = \ufffd[32m4.020397e-02\ufffd[39m\n     17 Linear |R| = \ufffd[33m4.001046e-02\ufffd[39m\n     18 Linear |R| = \ufffd[33m3.946197e-02\ufffd[39m\n     19 Linear |R| = \ufffd[32m3.542138e-02\ufffd[39m\n     20 Linear |R| = \ufffd[32m3.163193e-02\ufffd[39m\n     21 Linear |R| = \ufffd[32m2.904052e-02\ufffd[39m\n     22 Linear |R| = \ufffd[33m2.815327e-02\ufffd[39m\n     23 Linear |R| = \ufffd[32m2.463075e-02\ufffd[39m\n     24 Linear |R| = \ufffd[33m2.462958e-02\ufffd[39m\n     25 Linear |R| = \ufffd[33m2.429657e-02\ufffd[39m\n     26 Linear |R| = \ufffd[32m2.027283e-02\ufffd[39m\n     27 Linear |R| = \ufffd[32m1.826535e-02\ufffd[39m\n     28 Linear |R| = \ufffd[33m1.797220e-02\ufffd[39m\n     29 Linear |R| = \ufffd[33m1.753867e-02\ufffd[39m\n     30 Linear |R| = \ufffd[32m1.444272e-02\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 5 Nonlinear |R| = \ufffd[32m9.469957e-02\ufffd[39m\n      0 Linear |R| = \ufffd[32m9.469957e-02\ufffd[39m\n      1 Linear |R| = \ufffd[32m5.551551e-02\ufffd[39m\n      2 Linear |R| = \ufffd[32m4.357779e-02\ufffd[39m\n      3 Linear |R| = \ufffd[32m3.696999e-02\ufffd[39m\n      4 Linear |R| = \ufffd[32m3.234374e-02\ufffd[39m\n      5 Linear |R| = \ufffd[33m3.144135e-02\ufffd[39m\n      6 Linear |R| = \ufffd[32m2.247098e-02\ufffd[39m\n      7 Linear |R| = \ufffd[33m2.178075e-02\ufffd[39m\n      8 Linear |R| = \ufffd[32m1.970162e-02\ufffd[39m\n      9 Linear |R| = \ufffd[32m1.755335e-02\ufffd[39m\n     10 Linear |R| = \ufffd[32m1.603516e-02\ufffd[39m\n     11 Linear |R| = \ufffd[32m1.522744e-02\ufffd[39m\n     12 Linear |R| = \ufffd[33m1.493695e-02\ufffd[39m\n     13 Linear |R| = \ufffd[32m1.369856e-02\ufffd[39m\n     14 Linear |R| = \ufffd[32m1.214335e-02\ufffd[39m\n     15 Linear |R| = \ufffd[33m1.210103e-02\ufffd[39m\n     16 Linear |R| = \ufffd[32m1.099370e-02\ufffd[39m\n     17 Linear |R| = \ufffd[33m1.098430e-02\ufffd[39m\n     18 Linear |R| = \ufffd[33m1.071398e-02\ufffd[39m\n     19 Linear |R| = \ufffd[32m9.883785e-03\ufffd[39m\n     20 Linear |R| = \ufffd[33m9.828523e-03\ufffd[39m\n     21 Linear |R| = \ufffd[32m9.124156e-03\ufffd[39m\n     22 Linear |R| = \ufffd[33m9.014454e-03\ufffd[39m\n     23 Linear |R| = \ufffd[33m8.632032e-03\ufffd[39m\n     24 Linear |R| = \ufffd[33m8.437000e-03\ufffd[39m\n     25 Linear |R| = \ufffd[32m7.049509e-03\ufffd[39m\n     26 Linear |R| = \ufffd[33m7.038395e-03\ufffd[39m\n     27 Linear |R| = \ufffd[32m5.976451e-03\ufffd[39m\n     28 Linear |R| = \ufffd[33m5.953475e-03\ufffd[39m\n     29 Linear |R| = \ufffd[32m4.756918e-03\ufffd[39m\n     30 Linear |R| = \ufffd[33m4.655409e-03\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 6 Nonlinear |R| = \ufffd[32m5.055879e-02\ufffd[39m\n      0 Linear |R| = \ufffd[32m5.055879e-02\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.130905e-02\ufffd[39m\n      2 Linear |R| = \ufffd[33m1.102555e-02\ufffd[39m\n      3 Linear |R| = \ufffd[32m9.659015e-03\ufffd[39m\n      4 Linear |R| = \ufffd[33m9.626112e-03\ufffd[39m\n      5 Linear |R| = \ufffd[33m9.335340e-03\ufffd[39m\n      6 Linear |R| = \ufffd[32m8.558825e-03\ufffd[39m\n      7 Linear |R| = \ufffd[33m8.539813e-03\ufffd[39m\n      8 Linear |R| = \ufffd[32m6.505873e-03\ufffd[39m\n      9 Linear |R| = \ufffd[32m5.286782e-03\ufffd[39m\n     10 Linear |R| = \ufffd[32m4.466903e-03\ufffd[39m\n     11 Linear |R| = \ufffd[33m4.382467e-03\ufffd[39m\n     12 Linear |R| = \ufffd[32m3.272573e-03\ufffd[39m\n     13 Linear |R| = \ufffd[32m2.836778e-03\ufffd[39m\n     14 Linear |R| = \ufffd[33m2.727106e-03\ufffd[39m\n     15 Linear |R| = \ufffd[32m1.825536e-03\ufffd[39m\n     16 Linear |R| = \ufffd[32m1.251776e-03\ufffd[39m\n     17 Linear |R| = \ufffd[32m1.135239e-03\ufffd[39m\n     18 Linear |R| = \ufffd[32m1.027958e-03\ufffd[39m\n     19 Linear |R| = \ufffd[32m7.980705e-04\ufffd[39m\n 7 Nonlinear |R| = \ufffd[32m3.086312e-02\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m117.89 s\ufffd[39m] [\ufffd[33m  398 MB\ufffd[39m]\n\nOutlier Variable Residual Norms:\n  gr1: \ufffd[33m2.040915e-02\ufffd[39m\n  gr6: \ufffd[33m1.566724e-02\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n|   1.000000e-01 |   6.960100e+05 |   2.970342e+02 |   1.000000e-01 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nSteady-State Relative Differential Norm: 1.98569\n\n\nPerformance Graph:\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n|                                Section                               | Calls |   Self(s)  |   Avg(s)   |    %   | Mem(MB) |  Total(s)  |   Avg(s)   |    %   | Mem(MB) |\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n| pfubcApp (main)                                                      |     1 |      0.010 |      0.010 |   0.01 |       5 |    135.422 |    135.422 | 100.00 |     209 |\n|   Action::SetupMeshAction::Mesh::SetupMeshAction::act::setup_mesh    |     1 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n|   Action::SetupMeshAction::Mesh::SetupMeshAction::act::set_mesh_base |     2 |      0.000 |      0.000 |   0.00 |       0 |      0.013 |      0.006 |   0.01 |       6 |\n|   FEProblem::computeUserObjects                                      |     2 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n|   FEProblem::computeUserObjects                                      |     3 |      0.218 |      0.073 |   0.16 |       0 |      1.936 |      0.645 |   1.43 |       7 |\n|   FEProblem::outputStep                                              |     2 |      0.151 |      0.075 |   0.11 |       0 |      0.942 |      0.471 |   0.70 |      32 |\n|   Transient::PicardSolve                                             |     1 |      0.010 |      0.010 |   0.01 |       0 |    121.193 |    121.193 |  89.49 |      50 |\n|     FEProblem::computeUserObjects                                    |     8 |      0.280 |      0.035 |   0.21 |       0 |      3.198 |      0.400 |   2.36 |       0 |\n|     FEProblem::outputStep                                            |     3 |      0.004 |      0.001 |   0.00 |       0 |      0.004 |      0.001 |   0.00 |       0 |\n|     FEProblem::solve                                                 |     1 |      7.472 |      7.472 |   5.52 |      93 |    117.892 |    117.892 |  87.06 |     107 |\n|       FEProblem::computeJacobianInternal                             |     1 |      0.000 |      0.000 |   0.00 |       0 |      1.176 |      1.176 |   0.87 |       0 |\n|         FEProblem::computeUserObjects                                |     2 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n|       FEProblem::computeJacobianInternal                             |     7 |      0.000 |      0.000 |   0.00 |       0 |     11.115 |      1.588 |   8.21 |      12 |\n|         FEProblem::computeUserObjects                                |    14 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n|       FEProblem::computeResidualInternal                             |   191 |      0.006 |      0.000 |   0.00 |       0 |     98.099 |      0.514 |  72.44 |       0 |\n|         FEProblem::computeUserObjects                                |   382 |      0.003 |      0.000 |   0.00 |       0 |      0.003 |      0.000 |   0.00 |       0 |\n|   Transient::final                                                   |     1 |      0.001 |      0.001 |   0.00 |       0 |      0.002 |      0.002 |   0.00 |       0 |\n|     FEProblem::computeUserObjects                                    |     2 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n|     FEProblem::outputStep                                            |     1 |      0.000 |      0.000 |   0.00 |       0 |      0.000 |      0.000 |   0.00 |       0 |\n--------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nFinished Executing                                                                       [\ufffd[33m132.63 s\ufffd[39m] [\ufffd[33m  345 MB\ufffd[39m]",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995924",
                          "updatedAt": "2024-10-20T12:10:39Z",
                          "publishedAt": "2024-10-20T12:10:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Try a Newton solve instead of PJFNK now that the Jacobian is fully correct\nAnd what preconditioners have you tried?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995980",
                          "updatedAt": "2024-10-20T12:21:44Z",
                          "publishedAt": "2024-10-20T12:21:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am using this\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = PJFNK #Preconditioned JFNK (default)\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n  steady_state_detection = true\n  steady_state_start_time = 0\n  steady_state_tolerance = 1e-8\n  automatic_scaling = true\n  compute_scaling_once = false\n  l_tol = 1.0e-3\n  l_abs_tol = 1e-3\n  l_max_its = 30\n  nl_abs_tol = 1e-3\n  nl_max_its = 30\n  nl_rel_tol = 1.0e-3\n  start_time = 0.0\n  #num_steps = 1\n  end_time = 150000\n  dtmin = 1e-20\n  [TimeStepper]\n    type = SolutionTimeAdaptiveDT\n    dt = 0.1\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10995985",
                          "updatedAt": "2024-10-20T12:23:06Z",
                          "publishedAt": "2024-10-20T12:23:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "any suggestion on this other than Newton? with newton the calculations are faster and the timesteps are also increasing.\nBut computing Jacobian step is taking some time.\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\n\nTime Step 1, time = 0.1, dt = 0.1\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 3.764832e+01\n\n    Computing Jacobian                                                                   [  8.28 s] [  489 MB]\n      0 Linear |R| = 3.764832e+01\n      1 Linear |R| = 1.891125e-01\n      2 Linear |R| = 1.255195e-03\n 1 Nonlinear |R| = 3.584128e+00\n    Computing Jacobian.                                                                  [ 12.18 s] [  836 MB]\n      0 Linear |R| = 3.584128e+00\n      1 Linear |R| = 4.056686e-02\n      2 Linear |R| = 7.565497e-04\n 2 Nonlinear |R| = 2.022486e-01\n    Computing Jacobian.                                                                  [ 11.70 s] [  893 MB]\n      0 Linear |R| = 2.022486e-01\n      1 Linear |R| = 1.214415e-03\n      2 Linear |R| = 2.182540e-05\n 3 Nonlinear |R| = 1.389606e-02\n Solve Converged!\n  Finished Solving                                                                       [ 39.28 s] [  491 MB]\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n|   1.000000e-01 |   6.960100e+05 |   2.970350e+02 |   1.000000e-01 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nSteady-State Relative Differential Norm: 1.98581\n\nTime Step 2, time = 0.21, dt = 0.11\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 1.406254e+01\n\n    Computing Jacobian.                                                                  [ 12.17 s] [  495 MB]\n      0 Linear |R| = 1.406254e+01\n      1 Linear |R| = 8.324495e-02\n      2 Linear |R| = 6.581188e-04\n 1 Nonlinear |R| = 9.325223e-01\n    Computing Jacobian.                                                                  [ 11.92 s] [  840 MB]\n      0 Linear |R| = 9.325223e-01\n      1 Linear |R| = 7.408165e-03\n      2 Linear |R| = 5.467525e-05\n 2 Nonlinear |R| = 6.586837e-02\n    Computing Jacobian.                                                                  [ 11.54 s] [  857 MB]\n      0 Linear |R| = 6.586837e-02\n      1 Linear |R| = 4.709918e-04\n 3 Nonlinear |R| = 4.471408e-03\n Solve Converged!\n  Finished Solving                                                                       [ 41.53 s] [  493 MB]\n\nOutlier Variable Residual Norms:\n  gr1: 2.239529e-03\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n|   1.000000e-01 |   6.960100e+05 |   2.970350e+02 |   1.000000e-01 |   3.000000e+02 |\n|   2.100000e-01 |   6.960100e+05 |   2.964918e+02 |   1.000000e-01 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10996196",
                          "updatedAt": "2024-10-20T13:14:38Z",
                          "publishedAt": "2024-10-20T13:14:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is it faster overall?\nBy how much?\nNext suggestions would be passing some options to hypre boomeramg to optimize the preconditioning",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10996387",
                          "updatedAt": "2024-10-20T13:58:01Z",
                          "publishedAt": "2024-10-20T13:58:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "No it didn't worked.\n\n\n*** Warning, This code is deprecated and will be removed in future versions:\nPlease update your main.C to adapt new main function in MOOSE framework, see'test/src/main.C in MOOSE as an example of moose::main()'. \n\nSetting Up\n  Uniformly Refining                                                                     [\ufffd[33m  9.38 s\ufffd[39m] [\ufffd[33m  210 MB\ufffd[39m]\n\n\ufffd[36m\n*** Info ***\n'execute_on' parameter specified in [Outputs] block is ignored for object 'checkpoint'.\nDefine this object in its own sub-block of [Outputs] to modify its execution schedule.\ufffd[39m\n  Initializing\n    Finished Initializing Equation Systems                                               [\ufffd[33m  2.53 s\ufffd[39m] [\ufffd[33m  422 MB\ufffd[39m]\n  Finished Initializing                                                                  [\ufffd[33m  2.64 s\ufffd[39m] [\ufffd[33m  422 MB\ufffd[39m]\nFinished Setting Up                                                                      [\ufffd[33m 15.12 s\ufffd[39m] [\ufffd[33m  422 MB\ufffd[39m]\nFramework Information:\nMOOSE Version:           git commit 30fe3abb9c on 2024-07-31\nLibMesh Version:         \nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1\nCurrent Time:            Sun Oct 20 07:01:41 2024\nExecutable Timestamp:    Sun Oct 20 06:58:17 2024\n\nCheckpoint:\n  Wall Time Interval:      Every 3600.000000 s\n  User Checkpoint:         Outputs/checkpoint\n  # Checkpoints Kept:      2\n  Execute On:              TIMESTEP_END \n\nParallelism:\n  Num Processors:          4\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           distributed\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   \n    Total:                 58081\n    Local:                 14641\n    Min/Max/Avg:           14400/14641/14520\n  Elems:                   \n    Total:                 57600\n    Local:                 14400\n    Min/Max/Avg:           14400/14400/14400\n  Num Subdomains:          1\n  Num Partitions:          4\n  Partitioner:             parmetis\n\nNonlinear System:\n  Num DOFs:                464648\n  Num Local DOFs:          117128\n  Num Constrained DOFs:    3848\n  Local Constrained DOFs:  8\n  Variables:               { \"gr0\" \"gr1\" \"gr2\" \"gr3\" \"gr4\" \"gr5\" \"gr6\" \"gr7\" } \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                231362\n  Num Local DOFs:          58082\n  Num Constrained DOFs:    962\n  Local Constrained DOFs:  2\n  Variables:               \"bnds\" { \"unique_grains\" \"var_indices\" } \"phi\" \n  Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\" \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \"CONSTANT\" \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             IterationAdaptiveDT\n  TimeIntegrator:          BDF2\n  Solver Mode:             NEWTON\n  PETSc Preconditioner:    hypre boomeramg \n  MOOSE Preconditioner:    SMP\n\nCurrently Executing\n  Performing Initial Setup\n    Finished Projecting Initial Solutions                                                [\ufffd[33m  8.33 s\ufffd[39m] [\ufffd[33m  424 MB\ufffd[39m]\n  Finished Performing Initial Setup                                                      [\ufffd[33m 11.67 s\ufffd[39m] [\ufffd[33m  424 MB\ufffd[39m]\n\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   3.000000e+02 |   0.000000e+00 |   3.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\n\nTime Step 1, time = 0.1, dt = 0.1\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = \ufffd[32m3.487374e+01\ufffd[39m\n\n    Computing Jacobian                                                                   [\ufffd[33m  9.21 s\ufffd[39m] [\ufffd[33m  494 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m3.487374e+01\ufffd[39m\n      1 Linear |R| = \ufffd[33m3.487234e+01\ufffd[39m\n      2 Linear |R| = \ufffd[33m3.487167e+01\ufffd[39m\n      3 Linear |R| = \ufffd[33m3.484692e+01\ufffd[39m\n      4 Linear |R| = \ufffd[33m3.461484e+01\ufffd[39m\n      5 Linear |R| = \ufffd[33m3.389344e+01\ufffd[39m\n      6 Linear |R| = \ufffd[33m3.274277e+01\ufffd[39m\n      7 Linear |R| = \ufffd[33m3.196968e+01\ufffd[39m\n      8 Linear |R| = \ufffd[33m3.055167e+01\ufffd[39m\n      9 Linear |R| = \ufffd[32m2.745755e+01\ufffd[39m\n     10 Linear |R| = \ufffd[32m2.578958e+01\ufffd[39m\n     11 Linear |R| = \ufffd[32m2.259508e+01\ufffd[39m\n     12 Linear |R| = \ufffd[32m2.034590e+01\ufffd[39m\n     13 Linear |R| = \ufffd[32m1.621202e+01\ufffd[39m\n     14 Linear |R| = \ufffd[32m1.302885e+01\ufffd[39m\n     15 Linear |R| = \ufffd[32m9.475939e+00\ufffd[39m\n     16 Linear |R| = \ufffd[32m8.173800e+00\ufffd[39m\n     17 Linear |R| = \ufffd[32m6.624792e+00\ufffd[39m\n     18 Linear |R| = \ufffd[32m5.610338e+00\ufffd[39m\n     19 Linear |R| = \ufffd[33m5.375408e+00\ufffd[39m\n     20 Linear |R| = \ufffd[32m4.502182e+00\ufffd[39m\n     21 Linear |R| = \ufffd[33m4.373877e+00\ufffd[39m\n     22 Linear |R| = \ufffd[33m4.366864e+00\ufffd[39m\n     23 Linear |R| = \ufffd[33m4.225973e+00\ufffd[39m\n     24 Linear |R| = \ufffd[33m4.223300e+00\ufffd[39m\n     25 Linear |R| = \ufffd[33m4.135403e+00\ufffd[39m\n     26 Linear |R| = \ufffd[33m3.962511e+00\ufffd[39m\n     27 Linear |R| = \ufffd[32m3.524618e+00\ufffd[39m\n     28 Linear |R| = \ufffd[32m3.162077e+00\ufffd[39m\n     29 Linear |R| = \ufffd[32m2.787070e+00\ufffd[39m\n     30 Linear |R| = \ufffd[32m2.411693e+00\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\n 1 Nonlinear |R| = \ufffd[32m1.936228e+01\ufffd[39m\n    Computing Jacobian.                                                                  [\ufffd[33m 11.09 s\ufffd[39m] [\ufffd[33m  829 MB\ufffd[39m]\n      0 Linear |R| = \ufffd[32m1.936228e+01\ufffd[39m\n      1 Linear |R| = \ufffd[33m1.936228e+01\ufffd[39m\n      2 Linear |R| = \ufffd[33m1.936228e+01\ufffd[39m\n      3 Linear |R| = \ufffd[33m1.936227e+01\ufffd[39m\n      4 Linear |R| = \ufffd[33m1.936224e+01\ufffd[39m\n      5 Linear |R| = \ufffd[33m1.936224e+01\ufffd[39m\n      6 Linear |R| = \ufffd[33m1.936223e+01\ufffd[39m\n      7 Linear |R| = \ufffd[33m1.936222e+01\ufffd[39m\n      8 Linear |R| = \ufffd[33m1.936222e+01\ufffd[39m\n      9 Linear |R| = \ufffd[33m1.936222e+01\ufffd[39m\n     10 Linear |R| = \ufffd[33m1.936221e+01\ufffd[39m\n     11 Linear |R| = \ufffd[33m1.936221e+01\ufffd[39m\n     12 Linear |R| = \ufffd[33m1.936221e+01\ufffd[39m\n     13 Linear |R| = \ufffd[33m1.936219e+01\ufffd[39m\n     14 Linear |R| = \ufffd[33m1.936218e+01\ufffd[39m\n     15 Linear |R| = \ufffd[33m1.936217e+01\ufffd[39m\n     16 Linear |R| = \ufffd[33m1.936216e+01\ufffd[39m\n     17 Linear |R| = \ufffd[33m1.936215e+01\ufffd[39m\n     18 Linear |R| = \ufffd[33m1.936214e+01\ufffd[39m\n     19 Linear |R| = \ufffd[33m1.936213e+01\ufffd[39m\n     20 Linear |R| = \ufffd[33m1.936212e+01\ufffd[39m\n     21 Linear |R| = \ufffd[33m1.936211e+01\ufffd[39m\n     22 Linear |R| = \ufffd[33m1.936210e+01\ufffd[39m\n     23 Linear |R| = \ufffd[33m1.936209e+01\ufffd[39m\n     24 Linear |R| = \ufffd[33m1.936208e+01\ufffd[39m\n     25 Linear |R| = \ufffd[33m1.936207e+01\ufffd[39m\n     26 Linear |R| = \ufffd[33m1.936206e+01\ufffd[39m\n     27 Linear |R| = \ufffd[33m1.936205e+01\ufffd[39m\n     28 Linear |R| = \ufffd[33m1.936204e+01\ufffd[39m\n     29 Linear |R| = \ufffd[33m1.936203e+01\ufffd[39m\n     30 Linear |R| = \ufffd[33m1.936202e+01\ufffd[39m\n  Linear solve did not converge due to DIVERGED_ITS iterations 30\nNonlinear solve did not converge due to DIVERGED_LINE_SEARCH iterations 1\n\ufffd[31m Solve Did NOT Converge!\ufffd[39m\n  Finished Solving                                                                       [\ufffd[33m 43.57 s\ufffd[39m] [\ufffd[33m  503 MB\ufffd[39m]\nAborting as solve did not converge\n\nSolve failed, cutting timestep.\n\nTime Step 1, time = 0.05, dt = 0.05\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = \ufffd[32m3.312768e+01\ufffd[39m\n\n    Computing Jacobian\n\nthe jacobian test shows this\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.003549 %)\n\nKernel for variable 'gr1':\n  (1,1) On-diagonal Jacobian is slightly off (by 0.002575 %)\n\nKernel for variable 'gr2':\n  (2,2) On-diagonal Jacobian is slightly off (by 0.006727 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.653418 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003828 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000663 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000840 %)\n  (1,1) On-diagonal Jacobian is inexact (off by 1.093 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.005968 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000135 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001223 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.312387 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000332 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000833 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.184664 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000815 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.006085 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.034506 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.475991 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003644 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.030764 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.153011 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.028809 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.040603 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.047589 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.003503 %)\n\nThe faster simulation was without smooth_condition.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10996405",
                          "updatedAt": "2024-10-20T14:05:09Z",
                          "publishedAt": "2024-10-20T14:05:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "The on-diagonal is still showing slightly off.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10996431",
                          "updatedAt": "2024-10-20T14:09:46Z",
                          "publishedAt": "2024-10-20T14:09:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Some error is expected due to the way the Jacobian is computed during testing, using finite differencing.\nIf the smoothing does not help you can turn it off but you must keep the ajacobian correct to use Newton",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-10997076",
                          "updatedAt": "2024-10-20T16:09:29Z",
                          "publishedAt": "2024-10-20T16:09:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "This is my residual\n  Real Res = _test[_i][_qp] * _L[_qp] *\n             ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n              (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]) -\n              (sgn * 3 * _sigma[_qp] * g * op * SumOPGj));\n\nhere _test and _grad_test are multiplied. and it happens in Jacobian also. Do I need to add override for both?",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11021197",
                  "updatedAt": "2024-10-22T19:19:06Z",
                  "publishedAt": "2024-10-22T19:19:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "_test multiplies grad_test? Never seen a weak form turn out with that\nare you following an example?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11023208",
                          "updatedAt": "2024-10-23T00:57:36Z",
                          "publishedAt": "2024-10-23T00:57:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "So, Residual of SimpleACInterface has _grad_test  (i.e. (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]))\nResidual of ACGrGrPoly has _test  (i.e.  (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)))\nI just wanted to sum these two so I can get the total variable (\nReal total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\n) which is total local free energy with gradient for my required condition.\nSo when I use it as a new residual for my new kernel it has both, _test and _grad_test.\nIn the kernel System page we have\n\nAnd thought it is common to have these two terms multiplied.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11023245",
                          "updatedAt": "2024-10-23T01:09:35Z",
                          "publishedAt": "2024-10-23T01:04:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello!\nDo you think I made it?\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001893 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.004703 %)\n\nKernel for variable 'gr1':\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.022568 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001990 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.016742 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.004244 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.009922 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.008009 %)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000174 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000069 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001472 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.015580 %)\n\nKernel for variable 'gr2':\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.008885 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000873 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.003285 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000551 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.008100 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.043051 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000211 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.002837 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.122815 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.024219 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000243 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.244533 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.001035 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000584 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.006769 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000082 %)",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11021732",
                  "updatedAt": "2024-10-22T20:32:26Z",
                  "publishedAt": "2024-10-22T20:32:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes this looks good",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11022762",
                          "updatedAt": "2024-10-22T23:25:30Z",
                          "publishedAt": "2024-10-22T23:25:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Great Thanks a lot.\nAshish",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11022783",
                          "updatedAt": "2024-10-22T23:28:25Z",
                          "publishedAt": "2024-10-22T23:28:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello!\nI made a few changes to the code and I am getting\nRunning input with executable ./pfubc-opt ...\n\nNo errors detected. :-)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000965 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000410 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000244 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.022107 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.000763 %)\n\nKernel for variable 'gr2':\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.018285 %)\n\nKernel for variable 'gr3':\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.003120 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001017 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.006927 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.044368 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000239 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.005626 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.123996 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.030329 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000288 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.223532 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.001947 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000465 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.005491 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000106 %)\n\nbut I am still not getting good convergence\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   1.000000e+02 |   0.000000e+00 |   1.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\nWarning:  This MeshOutput subclass only supports meshes which have been serialized!\n\nTime Step 1, time = 0.1, dt = 0.1\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 4.041805e+01\n      0 Linear |R| = 4.041805e+01\n      1 Linear |R| = 1.473850e+00\n      2 Linear |R| = 1.314554e-01\n      3 Linear |R| = 1.473827e-02\n 1 Nonlinear |R| = 3.175248e+01\n      0 Linear |R| = 3.175248e+01\n      1 Linear |R| = 1.061454e+00\n      2 Linear |R| = 9.082835e-02\n      3 Linear |R| = 1.495823e-02\n 2 Nonlinear |R| = 2.227933e+00\n      0 Linear |R| = 2.227933e+00\n      1 Linear |R| = 9.903840e-02\n      2 Linear |R| = 1.072282e-02\n      3 Linear |R| = 1.397335e-03\n 3 Nonlinear |R| = 6.974641e-01\n      0 Linear |R| = 6.974641e-01\n      1 Linear |R| = 2.633254e-02\n      2 Linear |R| = 2.894129e-03\n      3 Linear |R| = 3.809362e-04\n 4 Nonlinear |R| = 3.226597e-01\n      0 Linear |R| = 3.226597e-01\n      1 Linear |R| = 7.780427e-03\n      2 Linear |R| = 8.263551e-04\n 5 Nonlinear |R| = 8.940924e-02\n      0 Linear |R| = 8.940924e-02\n      1 Linear |R| = 1.954140e-03\n      2 Linear |R| = 1.797905e-04\n 6 Nonlinear |R| = 5.126629e-02\n      0 Linear |R| = 5.126629e-02\n      1 Linear |R| = 7.674661e-04\n 7 Nonlinear |R| = 1.378475e-02\n Solve Converged!\nCurrently Executing\n  Finished Solving                                                                       [ 22.06 s] [  308 MB]\n\nOutlier Variable Residual Norms:\n  gr2: 1.273284e-02\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+----------------+\n| time           | DOFs           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   1.000000e+02 |   0.000000e+00 |   1.000000e+02 |\n|   1.000000e-01 |   4.840100e+05 |   9.858465e+01 |   0.000000e+00 |   1.000000e+02 |\n+----------------+----------------+----------------+----------------+----------------+\n\neverything is right now, but don't know what is wrong. Can you please have a look at it?\n#include \"AdvanceFrictionPressure.h\"\n\nregisterMooseObject(\"pfubcApp\", AdvanceFrictionPressure);\n\nInputParameters\nAdvanceFrictionPressure::validParams()\n{\n  InputParameters params = JvarMapKernelInterface<Kernel>::validParams();\n  params.addClassDescription(\"Gradient energy Allen-Cahn Kernel\");\n  params.addParam<MaterialPropertyName>(\"mob_name\", \"L\", \"The mobility used with the kernel\");\n  params.addParam<MaterialPropertyName>(\"kappa_name\", \"kappa_op\", \"The kappa used with thekernel \");\n  params.addRequiredCoupledVarWithAutoBuild(\n      \"v\", \"var_name_base\", \"op_num\", \"Array of coupled variables\");\n  params.addParam<MaterialPropertyName>(\"sigma\", \"GB energy (sigma)\");\n  return params;\n}\n\nAdvanceFrictionPressure::AdvanceFrictionPressure(const InputParameters & parameters)\n  : JvarMapKernelInterface<Kernel>(parameters),\n    _L(getMaterialProperty<Real>(\"mob_name\")),\n    _kappa(getMaterialProperty<Real>(\"kappa_name\")),\n    _g(getMaterialProperty<Real>(\"g\")),\n    _mu(getMaterialProperty<Real>(\"mu\")),\n    _op_num(coupledComponents(\"v\")),\n    _vals(coupledValues(\"v\")),\n    _vals_var(coupledIndices(\"v\")),\n    _sigma(getMaterialProperty<Real>(\"sigma\")),\n    _gamma(getMaterialProperty<Real>(\"gamma_asymm\"))\n{\n}\n\nReal\nAdvanceFrictionPressure::assignThisOp()\n{\n  return _u[_qp];\n}\n\nstd::vector<Real>\nAdvanceFrictionPressure::assignOtherOps()\n{\n  std::vector<Real> other_ops(_op_num);\n  for (unsigned int i = 0; i < _op_num; ++i)\n    other_ops[i] = (*_vals[i])[_qp];\n\n  return other_ops;\n}\n\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\n  Real friction = 3 * g * _sigma[_qp] * op * SumOPGj;\n\n  Real k = 15;\n  Real sgn = tanh(k * total);\n\n  // std::cout << \"total = \" << total << \"sgn = \" << sgn << std::endl;\n\n  ////////////////////\n  Real abs_total = std::abs(total);\n  Real abs_friction = std::abs(friction);\n\n  // smooth condition\n  Real alpha = 20; // Adjust alpha for how sharp you want the transition\n\n  // Real smooth_condition = 1.0 / (1.0 + exp(-alpha * (abs_total - abs_friction - 0.306)));\n  // if (smooth_condition < 1e-3)\n  //   smooth_condition = 0.0;\n  Real tanh_term = tanh(alpha * (abs_total - abs_friction - 0.306));\n  Real smooth_condition = 0.5 * (1.0 + tanh_term);\n  if (smooth_condition < 1e-5)\n    smooth_condition = 0.0;\n  // std::cout << \"abs_total - abs_friction = \" << abs_total - abs_friction\n  //           << \"smooth_condition = \" << smooth_condition << std::endl;\n  ////////////////////\n\n  Real Res = ((_test[_i][_qp] * _mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n              (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]) -\n              (_test[_i][_qp] * sgn * 3 * _sigma[_qp] * g * op * SumOPGj));\n\n  return _L[_qp] * (smooth_condition * Res);\n}\n\nReal\nAdvanceFrictionPressure::computeQpJacobian()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\n  Real friction = 3 * g * _sigma[_qp] * op * SumOPGj;\n\n  const Real k = 15;\n  Real sgn = tanh(k * total);\n\n  // Derivatives wrt op\n  Real dtotal_dopi = _phi[_j][_qp] * _mu[_qp] * (3 * op * op - 1 + 3 * SumOPj) +\n                     (_grad_phi[_j][_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n  Real dfriction_dopi = _phi[_j][_qp] * 3 * g * _sigma[_qp] * SumOPGj;\n  Real dsgn_dopi = k * pow(1 / cosh(k * total), 2) * dtotal_dopi;\n\n  ////////////////////\n  Real abs_total = std::abs(total);\n  Real abs_friction = std::abs(friction);\n\n  // smooth condition\n  Real alpha = 20; // Adjust alpha for how sharp you want the transition\n  // Real smooth_condition = 1.0 / (1.0 + exp(-alpha * (abs_total - abs_friction - 0.306)));\n  // if (smooth_condition < 1e-3)\n  //   smooth_condition = 0.0;\n  Real tanh_term = tanh(alpha * (abs_total - abs_friction - 0.306));\n  Real smooth_condition = 0.5 * (1.0 + tanh_term);\n  if (smooth_condition < 1e-5)\n    smooth_condition = 0.0;\n  // Sign of total and friction\n  Real sgn_total = (total > 0) - (total < 0);          // Sign function for total\n  Real sgn_friction = (friction > 0) - (friction < 0); // Sign function for friction\n\n  // Derivative of the smooth condition wrt op\n  // Real dsmooth_condition_dopi = alpha * smooth_condition * (1.0 - smooth_condition) *\n  //                              (sgn_total * dtotal_dopi - sgn_friction * dfriction_dopi);\n  Real dsmooth_condition_dopi = 0.5 * (1.0 - pow(tanh_term, 2)) * alpha *\n                                (sgn_total * dtotal_dopi - sgn_friction * dfriction_dopi);\n  ////////////////\n\n  Real Res = ((_test[_i][_qp] * _mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n              (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]) -\n              (_test[_i][_qp] * sgn * 3 * _sigma[_qp] * g * op * SumOPGj));\n\n  // Calculate Jacobian\n  Real Jac = ((_test[_i][_qp] * _mu[_qp] * _phi[_j][_qp] * (3 * op * op - 1 + 3 * SumOPj)) +\n              (_grad_phi[_j][_qp] * _kappa[_qp] * _grad_test[_i][_qp]) -\n              ((_test[_i][_qp] * _phi[_j][_qp] * 3 * _sigma[_qp] * g * SumOPGj * sgn) +\n               (_test[_i][_qp] * 3 * _sigma[_qp] * g * op * SumOPGj * dsgn_dopi)));\n\n  return _L[_qp] * (smooth_condition * Jac + dsmooth_condition_dopi * Res);\n}\n\nReal\nAdvanceFrictionPressure::computeQpOffDiagJacobian(unsigned int jvar)\n{\n  const unsigned int cvar = mapJvarToCvar(jvar);\n  // assign op and other_ops\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int a = 0; a < _op_num; ++a)\n  {\n    SumOPj += other_ops[a] * other_ops[a];\n    SumOPGj += other_ops[a];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n  Real friction = 3 * _sigma[_qp] * op * g * SumOPGj;\n\n  Real k = 15;\n  Real sgn = tanh(k * total);\n\n  Real Res = ((_test[_i][_qp] * _mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n              (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]) -\n              (_test[_i][_qp] * sgn * 3 * _sigma[_qp] * g * op * SumOPGj));\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n    if (jvar == _vals_var[i])\n    {\n      Real dSumOPj = 2.0 * other_ops[i] * _phi[_j][_qp];\n      Real dSumOPGj = _phi[_j][_qp];\n\n      // Derivatives wrt opj\n      Real dtotal_dopj = _mu[_qp] * (3 * op * dSumOPj);\n      Real dfriction_dopj = 3 * _sigma[_qp] * g * op * dSumOPGj;\n      Real dsgn_dopj = k * pow(1 / cosh(k * total), 2) * dtotal_dopj;\n\n      ////////////////////\n      Real abs_total = std::abs(total);\n      Real abs_friction = std::abs(friction);\n\n      // smooth condition\n      Real alpha = 20; // Adjust alpha for how sharp you want the transition\n      // Real smooth_condition = 1.0 / (1.0 + exp(-alpha * (abs_total - abs_friction - 0.306)));\n      // if (smooth_condition < 1e-3)\n      //   smooth_condition = 0.0;\n      Real tanh_term = tanh(alpha * (abs_total - abs_friction - 0.306));\n      Real smooth_condition = 0.5 * (1.0 + tanh_term);\n      if (smooth_condition < 1e-5)\n        smooth_condition = 0.0;\n      Real sgn_total = (total > 0) - (total < 0);          // Sign function for total\n      Real sgn_friction = (friction > 0) - (friction < 0); // Sign function for friction\n\n      // Derivative of the smooth condition wrt opj\n      // Real dsmooth_condition_dopj = alpha * smooth_condition * (1.0 - smooth_condition) *\n      //                              (sgn_total * dtotal_dopj - sgn_friction * dfriction_dopj);\n      Real dsmooth_condition_dopj = 0.5 * (1.0 - pow(tanh_term, 2)) * alpha *\n                                    (sgn_total * dtotal_dopj - sgn_friction * dfriction_dopj);\n      ////////////////\n\n      Real offJac = _test[_i][_qp] * ((_mu[_qp] * 3 * op * dSumOPj) -\n                                      (sgn * 3 * _sigma[_qp] * g * op * dSumOPGj +\n                                       3 * _sigma[_qp] * g * op * SumOPGj * dsgn_dopj));\n\n      return _L[_qp] * (smooth_condition * offJac + dsmooth_condition_dopj * Res);\n    }\n  return 0;\n}",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11033167",
                  "updatedAt": "2024-10-23T19:13:56Z",
                  "publishedAt": "2024-10-23T19:13:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is this PJFNK or Newton?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11034717",
                          "updatedAt": "2024-10-23T23:29:57Z",
                          "publishedAt": "2024-10-23T23:29:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "The Jacobian debugger was made with NEWTON, The output shown above was using PJFNK",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11034723",
                          "updatedAt": "2024-10-23T23:33:30Z",
                          "publishedAt": "2024-10-23T23:31:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If it's converging look at improving the preconditioning or reducing the order parameter further\nIf it s not converging look at the troubleshooting failed solves page for more advice on debugging it. Notably the singular value check",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11042963",
                          "updatedAt": "2024-10-24T15:58:46Z",
                          "publishedAt": "2024-10-24T15:58:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am currently having 6500 grains and order parameters are 8. So I think I am already at the lowest number there. Coming to the convergence, I do get convergence but the time steps are little smaller.  For example one of the time steps\n\nThe time step here is 0.0069 and the time of simulation is 371.939 at 2132th time step and it took 12 hrs on 500 cores to reach here. Now with this speed, it is impossible to reach the time of 7e4 sec. so now I think I need to choose the solvers. But there are so many options. I don't know which to use. Because for every option I need to wait for 12 hrs where this small timesteps are appearing. I understand FEM methods are slower than Finite difference method. But this time step is really small.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11045945",
                          "updatedAt": "2024-10-24T22:08:07Z",
                          "publishedAt": "2024-10-24T22:08:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can use checkpoint to restart right when the problem appear. You should not need to wait 12 hours each time",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11046440",
                          "updatedAt": "2024-10-24T23:52:16Z",
                          "publishedAt": "2024-10-24T23:52:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ideally the nonlinear solver would be converging the simulations a little tighter than 1e-3 and would be able to take larger time steps.\nHowever if larger time steps are not possible, converging the solve tighter will slow down the solver further",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11081854",
                          "updatedAt": "2024-10-29T02:45:16Z",
                          "publishedAt": "2024-10-29T02:45:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am currently running two simulations with different tolerances. 1e-3  and 1e-6, I am finding that 1e-6 is much slower than 1e-3 and time steps are also larger for 1e-3. I can go upto 0.5 sec per timestep but I need to run this simulation for t=1e4 to see the significant effect of the model. Earlier work that I used as a reference was made and simulated in finite difference method and it was much faster than FEM used in MOOSE. I will definitely try to optimize the simulation conditions later. Thank you for all the help and patience.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11082366",
                          "updatedAt": "2024-10-29T04:23:09Z",
                          "publishedAt": "2024-10-29T04:23:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "What time integrator have you tried? (specified using the 'scheme' parameter of the executioner)",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11087592",
                          "updatedAt": "2024-10-29T13:45:54Z",
                          "publishedAt": "2024-10-29T13:45:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "[Executioner]\n    type = Transient\n    scheme = bdf2\n    solve_type = PJFNK #Preconditioned JFNK (default)\n    petsc_options_iname = '-pc_type -pc_hypre_type -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths  -pc_hypre_boomeramg_max_levels  -pc_hypre_boomeramg_coarsen_type  -pc_hypre_boomeramg_interp_type  -pc_hypre_boomeramg_P_max  -pc_hypre_boomeramg_truncfactor'\n    petsc_options_value = 'hypre boomeramg  0.15 1 2 25 HMIS FF 1 0.3'\n    steady_state_detection = true\n    steady_state_start_time = 0\n    steady_state_tolerance = 1e-4\n    automatic_scaling = true\n    compute_scaling_once = false\n    l_tol = 1.0e-5\n    l_abs_tol = 1e-5\n    l_max_its = 50\n    nl_abs_tol = 1e-5\n    nl_max_its = 50\n    nl_rel_tol = 1.0e-5\n    start_time = 0.0\n    #num_steps = 2\n    end_time = 2000000\n    dtmin = 1e-20\n    #dt = 0.1\n    #[Adaptivity]\n    #  initial_adaptivity = 2\n    #  refine_fraction = 0.7\n    #  coarsen_fraction = 0.1\n    #  max_h_level = 4\n    #[]\n[TimeStepper]\n    type = IterationAdaptiveDT\n    cutback_factor = 0.1\n    growth_factor = 1.1\n    dt = 0.1\n    optimal_iterations = 8\n[]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11089298",
                          "updatedAt": "2024-10-29T15:55:01Z",
                          "publishedAt": "2024-10-29T15:54:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "How is bdf2 compared to implicit Euler?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11089446",
                          "updatedAt": "2024-10-29T16:00:15Z",
                          "publishedAt": "2024-10-29T16:00:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello,\nAfter trying everything I am still struggling to get the desired results.\nTime Step 10682, time = 4660.52, dt = 0.589581\nPre-SMO residual: 0.243836\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = 2.443673e-01\n      0 Linear |R| = 2.443673e-01\n      1 Linear |R| = 1.803225e-01\n      2 Linear |R| = 6.084074e-02\n      3 Linear |R| = 2.740365e-02\n      4 Linear |R| = 1.318843e-02\n      5 Linear |R| = 6.770792e-03\n      6 Linear |R| = 3.678059e-03\n      7 Linear |R| = 2.161769e-03\n      8 Linear |R| = 1.231317e-03\n      9 Linear |R| = 7.032720e-04\n     10 Linear |R| = 3.503674e-04\n     11 Linear |R| = 1.708096e-04\n     12 Linear |R| = 8.314164e-05\n 1 Nonlinear |R| = 8.220388e-02\n      0 Linear |R| = 8.220388e-02\n      1 Linear |R| = 2.156492e-02\n      2 Linear |R| = 9.120701e-03\n      3 Linear |R| = 4.020085e-03\n      4 Linear |R| = 1.975502e-03\n      5 Linear |R| = 1.084695e-03\n      6 Linear |R| = 5.722968e-04\n      7 Linear |R| = 2.936753e-04\n      8 Linear |R| = 1.511231e-04\n      9 Linear |R| = 7.514336e-05\n 2 Nonlinear |R| = 1.725675e-02\n      0 Linear |R| = 1.725675e-02\n      1 Linear |R| = 4.358433e-03\n      2 Linear |R| = 1.801668e-03\n      3 Linear |R| = 6.793559e-04\n      4 Linear |R| = 2.876081e-04\n      5 Linear |R| = 1.122580e-04\n      6 Linear |R| = 4.996307e-05\n 3 Nonlinear |R| = 1.595820e-03\n      0 Linear |R| = 1.595820e-03\n      1 Linear |R| = 3.442125e-04\n      2 Linear |R| = 1.387527e-04\n      3 Linear |R| = 4.831790e-05\n 4 Nonlinear |R| = 6.045878e-05\n  Finished Solving                                                                       [ 24.32 s] [ 2124 MB]\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  gr3: 3.166659e-05\n  gr5: 3.894508e-05\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+\n:                :                :                :                :\n|   4.655210e+03 |   5.255854e+03 |   5.000000e-01 |   7.590000e+02 |\n|   4.655799e+03 |   5.255863e+03 |   5.000000e-01 |   7.590000e+02 |\n|   4.656389e+03 |   5.255862e+03 |   5.000000e-01 |   7.590000e+02 |\n|   4.656978e+03 |   5.255863e+03 |   5.000000e-01 |   7.590000e+02 |\n|   4.657568e+03 |   5.262798e+03 |   5.000000e-01 |   7.580000e+02 |\n|   4.658158e+03 |   5.262801e+03 |   5.000000e-01 |   7.580000e+02 |\n|   4.658747e+03 |   5.262800e+03 |   5.000000e-01 |   7.580000e+02 |\n|   4.659337e+03 |   5.262795e+03 |   5.000000e-01 |   7.580000e+02 |\n|   4.659926e+03 |   5.262800e+03 |   5.000000e-01 |   7.580000e+02 |\n|   4.660516e+03 |   5.262798e+03 |   5.000000e-01 |   7.580000e+02 |\n+----------------+----------------+----------------+----------------+\n\nSteady-State Relative Differential Norm: 0.00168314\n\nthe system now only have 758 grains yet the time step is so small.",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102703",
                  "updatedAt": "2024-10-30T16:42:54Z",
                  "publishedAt": "2024-10-30T16:42:53Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "have you tried a more aggressive growth?\n[TimeStepper]\n    type = IterationAdaptiveDT\n    cutback_factor = 0.5\n    growth_factor = 2\n    dt = 0.1\n    optimal_iterations = 10\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102747",
                          "updatedAt": "2024-10-30T16:45:38Z",
                          "publishedAt": "2024-10-30T16:45:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "yes. But the solution doesn't converge and ends up with same 0.5-0.8 per time step. also optimal iterations is not allowing the time step to increase further. it stays with same dt even after 10 iterations if optimal_iterations = 10.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102774",
                          "updatedAt": "2024-10-30T16:48:24Z",
                          "publishedAt": "2024-10-30T16:48:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am running this simulation for 4 days on 500 cores and I was only able to get\n\nThe simulation was supposed to come to halt after some time but the time it take to reach there is VERY LARGE.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102816",
                          "updatedAt": "2024-10-30T16:51:22Z",
                          "publishedAt": "2024-10-30T16:51:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what is the legend here?\nhow fine is the mesh again? Did you get improvements from AMR?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102908",
                          "updatedAt": "2024-10-30T16:59:07Z",
                          "publishedAt": "2024-10-30T16:59:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "If you look at my code I posted here there is a variable g (representing the friction pressure) The legend is that friction pressure, it is basically a resistance to grain growth driving pressure. As g increases the resistance increases and after sometime when the driving pressure is less than or equal to friction pressure the grain growth stops.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102926",
                          "updatedAt": "2024-10-30T17:01:04Z",
                          "publishedAt": "2024-10-30T17:01:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "The mesh is fine such that I am getting at least 4-5 mesh points at the interface.  Adaptive meshing is good theoretically, but for large simulation I have seen that the time it takes to reconfigure the mesh is much larger than the actual iterations. And it happens after every time steps. so e.g. if one time step solve takes about 10 sec, then the adapting mesh step was taking more than 80-90 sec. It was way more slower then. So I removed the adapting step and after that I could reach to this time as shown in figure. otherwise it would have been half of what I got now.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11102975",
                          "updatedAt": "2024-10-30T17:06:01Z",
                          "publishedAt": "2024-10-30T17:06:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Would it help to do it less often than every time step?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11104365",
                          "updatedAt": "2024-10-30T19:22:58Z",
                          "publishedAt": "2024-10-30T19:22:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Yes that was the reason I moved to non adaptive mesh,\nBut, How to do it? I don't think we can control that. Turning ON adaptive meshing will automatically introduce that step as grain boundary changes after every time step so are the nonlinear variables.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11104388",
                          "updatedAt": "2024-10-30T19:26:48Z",
                          "publishedAt": "2024-10-30T19:26:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I saw this in one of the other discussion. Does my problem comes under the same criteria where MOOSE is very slow? Just wondering! I am here trying to replicate what was done before in finite difference method. I understand there is always difference in two methods, but can you estimate the difference as I am very new in the field of FEM and phase field.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11104494",
                          "updatedAt": "2024-10-30T19:36:56Z",
                          "publishedAt": "2024-10-30T19:36:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No this kind of study does not apply to anything else than their one case. Besides no one has enough expertise in 5 different tools to perform good timing comparisons so even in that case it's not clear the conclusions would stand\nFEM will be more expensive than finite difference for sure, but it will handle unstructured meshes which should have less dispersion than a regular grid.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11104823",
                          "updatedAt": "2024-10-30T20:21:10Z",
                          "publishedAt": "2024-10-30T20:21:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello!\nIN the following kernel I just want to know if this is correct. If you see 'total' variable it has _grad_test[_qp]\nin residual we can see _test[_qp] multiplied by _grad_test[_qp].\nis this correct? can we multiply _test and _grad_test?\nReal\nAdvanceFrictionPressure::computeQpResidual()\n{\n  Real op = assignThisOp();\n  std::vector<Real> other_ops = assignOtherOps();\n\n  Real g = _g[_qp];\n  Real SumOPGj = 0.0;\n  Real SumOPj = 0.0;\n\n  for (unsigned int i = 0; i < _op_num; ++i)\n  {\n    SumOPj += other_ops[i] * other_ops[i];\n    SumOPGj += other_ops[i];\n  }\n\n  Real total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\n  Real friction = 3 * g * _sigma[_qp] * op * SumOPGj;\n\n  Real k = 20;\n  Real sgn = std::tanh(k * total);\n  if (sgn > 0.5)\n    sgn = 1;\n  if (sgn < 0.5)\n    sgn = 0;\n\n  ////////////////////\n  Real abs_total = std::abs(total);\n  Real abs_friction = std::abs(friction);\n\n  // smooth condition\n  Real alpha = 40; // Adjust alpha for how sharp you want the transition\n\n  Real tanh_term = std::tanh(alpha * (abs_total - abs_friction - 0.15));\n  Real smooth_condition = 0.5 * (1.0 + tanh_term);\n  if (smooth_condition < 1e-4)\n    smooth_condition = 0;\n  // std::cout << \"difference\" << abs_total - abs_friction << std::endl;\n  // std::cout << \"condition\" << smooth_condition << std::endl;\n  ////////////////////\n\n  Real Res = (_test[_i][_qp] * ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) -\n                                (sgn * 3 * _sigma[_qp] * g * op * SumOPGj)) +\n              (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]));\n  // std::cout << \"Res\" << Res << std::endl;\n  return _L[_qp] * (smooth_condition * Res);\n}\n\nThank you",
                  "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132279",
                  "updatedAt": "2024-11-03T03:12:01Z",
                  "publishedAt": "2024-11-03T03:11:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is this correct? can we multiply _test and _grad_test?\n\nwe could in theory, but I don't see what weak format ends up with such a term. Maybe write down the derivation that gets you to this term",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132475",
                          "updatedAt": "2024-11-03T04:29:00Z",
                          "publishedAt": "2024-11-03T04:29:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132550",
                          "updatedAt": "2024-11-03T04:55:31Z",
                          "publishedAt": "2024-11-03T04:55:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So this is the strong form. Do you have the derivation of the weak form from the strong form?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132580",
                          "updatedAt": "2024-11-03T05:10:29Z",
                          "publishedAt": "2024-11-03T05:10:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Its a bit complecated but if you loot at hte second term of R, you see condition is multiplied with total, which has _grad_test",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132620",
                          "updatedAt": "2024-11-03T05:30:44Z",
                          "publishedAt": "2024-11-03T05:30:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I think the problem is in\nReal total = (_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)) +\n               (_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]);\n\nI just need the value of driving pressure (i.e. total, which is basically sum of residual of ACGrGrPoly and ACInterface) here but because of _grad_u[_qp] I have to use _grad_test[_qp]. if somehow I can make this term real without _grad_test[_qp] I think the problem can be solved.",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11132649",
                          "updatedAt": "2024-11-03T05:45:03Z",
                          "publishedAt": "2024-11-03T05:42:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Its a bit complecated but if you loot at hte second term of R, you see condition is multiplied with total, which has _grad_test\n\nI dont think that s quite right.\nIf you look at your strong form, you start with\ndeta/dt = condition (total - sign * friction)\nbut then you derive the weak form for condition, total, sign and friction separately. Which is not right, you should be deriving them for these two terms that are summed not for terms that are multiplied.\ndeta/dt = condition (total )  - (condition * sign * friction)",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11134222",
                          "updatedAt": "2024-11-03T12:56:38Z",
                          "publishedAt": "2024-11-03T12:56:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Hello!\nI changed my residual as you suggested\nReal Res = (smooth_condition * ((_mu[_qp] * (op * op * op - op + 3 * op * SumOPj)))) +\n               (smooth_condition * ((_grad_u[_qp] * _kappa[_qp] * _grad_test[_i][_qp]))) -\n               (smooth_condition * (sgn * 3 * _sigma[_qp] * g * op * SumOPGj));\n\nnow the Jacobian debugger shows\nRunning input with executable ./pfubc-opt ...\n\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.009893 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.008961 %)\n  (0,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.016752 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.009092 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.019589 %)\n  (1,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.012455 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.003363 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.019496 %)\n  (2,3) Off-diagonal Jacobian for variable 'gr3' is slightly off (by 0.014487 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.016370 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.015753 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.016558 %)\n\nKernel for variable 'gr0':\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.000262 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000583 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000066 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.001567 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000276 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.025711 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.000180 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.001715 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000576 %)\n\nKernel for variable 'gr0':\n  (0,0) On-diagonal Jacobian is slightly off (by 0.036075 %)\n  (0,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.012293 %)\n  (0,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000645 %)\n\nKernel for variable 'gr1':\n  (1,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.003952 %)\n  (1,1) On-diagonal Jacobian is slightly off (by 0.149484 %)\n  (1,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.004675 %)\n\nKernel for variable 'gr2':\n  (2,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001425 %)\n  (2,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.642942 %)\n  (2,2) On-diagonal Jacobian is slightly off (by 0.004777 %)\n\nKernel for variable 'gr3':\n  (3,0) Off-diagonal Jacobian for variable 'gr0' is slightly off (by 0.001566 %)\n  (3,1) Off-diagonal Jacobian for variable 'gr1' is slightly off (by 0.024350 %)\n  (3,2) Off-diagonal Jacobian for variable 'gr2' is slightly off (by 0.000094 %)",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11136235",
                          "updatedAt": "2024-11-03T19:40:06Z",
                          "publishedAt": "2024-11-03T19:39:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "could be good enough. Are convergence and results improved?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11136285",
                          "updatedAt": "2024-11-03T19:54:04Z",
                          "publishedAt": "2024-11-03T19:54:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I think so\n0p02I.txt\nIs this looking good?",
                          "url": "https://github.com/idaholab/moose/discussions/28797#discussioncomment-11136293",
                          "updatedAt": "2024-11-03T19:56:45Z",
                          "publishedAt": "2024-11-03T19:56:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to embed a beam element in 3d solid elements?",
          "author": {
            "login": "xiekai-mc"
          },
          "bodyText": "I am trying to embed fibers (modeled with 1D beam elements later) in the matrix (3d solid elements), like this in Gmsh\n\nI have reviewed similar discussions #24887 and #24174, but I feel that they do not address this issue.\nI can generate 1D mesh and 3d mesh separately in Gmsh. For example\nSetFactory(\"OpenCASCADE\");\n//+\nBox(1) = {0, 0, 0, 1, 1, 1};\n//+\nPoint(9) = {0.2, 0.2, 0.2, 1.0};\n//+\nPoint(10) = {0.8, 0.8, 0.8, 1.0};\n//+\nLine(13) = {9, 10};\n//+\nCurve{13} In Volume{1};\n//+\nPhysical Curve(\"fiber\", 21) = {13};\nMesh.SaveAll = 0; \n\nMesh 3;\nSave \"fibers.msh\";\n\nPhysical Surface(\"left\", 13) = {1};\n//+\nPhysical Surface(\"right\", 14) = {2};\n//+\nPhysical Surface(\"top\", 15) = {4};\n//+\nPhysical Surface(\"bottom\", 16) = {3};\n//+\nPhysical Surface(\"front\", 17) = {6};\n//+\nPhysical Surface(\"back\", 18) = {5};\n//+\nPhysical Volume(\"block\", 20) = {1};\nMesh.SaveAll = 1; \n\nSave \"matrix.msh\";\n\nHowever, the 1D boundary \"fiber\" in the 3D mesh is not loaded using FileMeshGenerator.\nSo it seems I cannot use StitchedMeshGenerator either, because I cannot find the corresponding boundary positions between the two meshes.\nCould you provide any suggestions or hints? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/28680",
          "updatedAt": "2024-11-03T09:19:28Z",
          "publishedAt": "2024-09-21T23:07:26Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe Gmsh reader must not be supporting these mixed dimensional mesh if it is not working.\nHow did you check it is not loaded? What does the mesh summary show in the --mesh-only mode?\nThe StitchedMeshGenerator is a good idea. For that to work you will need to:\n\nload the two meshes in two FileMeshGenerator\ncreate nodeset(s) for the ends of the 1D mesh, both in the 1D mesh and the 3D mesh\nuse the nodesets for stitiching",
                  "url": "https://github.com/idaholab/moose/discussions/28680#discussioncomment-10717980",
                  "updatedAt": "2024-09-22T13:21:05Z",
                  "publishedAt": "2024-09-22T13:21:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jmeier"
                  },
                  "bodyText": "Dear @xiekai-mc ,\nThe MSH file format does not differentiate between \"sidesets\" and \"elements of lower dimensionality\". Your beam is embedded in volume elements - this is here considered as \"element of lower dimensionality\". So Moose needs a hint, if those lines are sidesets (default) or elements.\nYou can do that by (1) appending \"lower_dimensional_block\" to the name of the beam or (2) after the name (the second option looks nicer, but you have to edit the msh file):\n$MeshFormat\n4.1 0 8\n$EndMeshFormat\n$PhysicalNames\n...\n0 1 \"PointA\"                                          \u2190 sideset (node)\n1 2 \"topleftedge\"                                     \u2190 sideset (line)\n1 3 \"lineSignPole000_lower_dimensional_block\"         \u2190 block with beam-elements\n1 4 \"lineSignPole001\" lower_dimensional_block         \u2190 block with beam-elements\n2 5 \"BoundaryZMin\"                                    \u2190 sideset (surface)\n2 6 \"Sign\" lower_dimensional_block                    \u2190 block with shell-elements\n...\n\n(Do not copy the \u2190 block with beam-elements. This is just for illustration.)",
                  "url": "https://github.com/idaholab/moose/discussions/28680#discussioncomment-11133247",
                  "updatedAt": "2024-11-03T09:19:29Z",
                  "publishedAt": "2024-11-03T09:19:28Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A question about stiffness matrix, assembly and assembly order in MOOSE",
          "author": {
            "login": "alimostafavi24"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nDear MOOSE experts,\nI am writing this to inquire about stiffness matrix, assembly and assembly order in the framework.\nFirst, is there any documentation regarding the stiffness matrix (or LHS) and RHS in Navier-Stokes and Phase-Field modules?\nSecond, if someone couples the two, the framework forms the assembled matrix. But what would be the order? (Variables are velocity vector, pressure, order parameter and chemical potential). -mat_view gives the matrix data, but how about the order of nonlinear variables? Is there anyway to see the right-hand-side of the equations too or we can just see the stiffness matrix?\nThanks for your assistance.\nRegards,",
          "url": "https://github.com/idaholab/moose/discussions/28626",
          "updatedAt": "2024-11-03T01:53:39Z",
          "publishedAt": "2024-09-16T02:07:01Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nFirst, is there any documentation regarding the stiffness matrix (or LHS) and RHS in Navier-Stokes and Phase-Field modules?\n\nYes in the sense that all the kernels are documented for Navier Stokes, and many of them for phase field (but it's not complete yet there).\nThis tells you how we assemble the residual and Jacobian.\nIn most solves (linear finite volume being the exception I know), we dont form the RHS explicitly. If you want to create it, you can use the tagging system on each kernel that should contribute to it\nhttps://mooseframework.inl.gov/source/interfaces/TaggingInterface.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28626#discussioncomment-10659765",
                  "updatedAt": "2024-09-16T13:25:51Z",
                  "publishedAt": "2024-09-16T13:25:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Ok. I had a question regarding obtaining the stiffness matrix. Considering solving the transient implicit Phase-field in Split form (c order parameter, w chemical potential), -mat_view returns this matrix (it is the sparsity pattern). I reorder it in this way:[k_cc k_cw;k_wc k_ww][c;w]=[F_1;F_2].\nWhat exactly this matrix could be? I am asking this because stiffness matrix sdoes not contain time derivative terms. Am I right? But the figure has the dc/dt term contributions. Can this output be kind of sum of the mass and stiffenss matrix?",
                          "url": "https://github.com/idaholab/moose/discussions/28626#discussioncomment-10698249",
                          "updatedAt": "2024-09-19T22:00:44Z",
                          "publishedAt": "2024-09-19T22:00:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Sorry forgot to reply.\nYes this is the Jacobian not the stiffness matrix. You would need to remove the time derivative terms at least.",
                          "url": "https://github.com/idaholab/moose/discussions/28626#discussioncomment-11132119",
                          "updatedAt": "2024-11-03T01:53:39Z",
                          "publishedAt": "2024-11-03T01:53:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problems reading material property in InterfaceKernel",
          "author": {
            "login": "bmurgas-LANL"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello Moose community,\nI am using a crystal plasticity model where I define material properties that I need to use inside a modified version of ConservativeAdvection kernel and InterfaceDiffusion interface kernel.\nWhen I read the property in the ConservativeAdvection kernel, the material properties are correct and have the same value computed in the crystal plasticity model.\nHowever,  when I read the material properties in the InterfaceDiffusion interface kernel the variables are set to zero. Do you know why this can happen?\nThis is the validParameters and constructor of the \"ConservativeDiffusion\" kernel:\nInputParameters\nConservativeAdvectionDislocation::validParams()\n{\n  InputParameters params = Kernel::validParams();\n  params.addClassDescription(\n      \"Conservative form of $\\\\nabla \\\\cdot \\\\vec{v} u$ which in its weak \"\n      \"form is given by: $(-\\\\nabla \\\\psi_i, \\\\vec{v} u)$. \"\n      \"Velocity is defined as a material property computed in DiscoFluxCPStressUpdate\");\n  MooseEnum upwinding_type(\"none full\", \"none\");\n  params.addParam<MooseEnum>(\"upwinding_type\",\n                             upwinding_type,\n                             \"Type of upwinding used.  None: Typically results in overshoots and \"\n                             \"undershoots, but numerical diffusion is minimized.  Full: Overshoots \"\n                             \"and undershoots are avoided, but numerical diffusion is large\");\n  MooseEnum dislocation_character(\"edge screw\", \"edge\");\n  params.addRequiredParam<MooseEnum>(\n      \"dislocation_character\", dislocation_character, \"Character of dislocation\");\n  MooseEnum dislocation_sign(\"positive negative\", \"positive\");\n  params.addRequiredParam<MooseEnum>(\"dislocation_sign\", dislocation_sign, \"Sign of dislocation\");\n  params.addRequiredParam<int>(\"slip_system_index\",\n                               \"Slip system index to get slip direction\"\n                               \"FCC: 1 to 12.\");\n  return params;\n}\n\n\nConservativeAdvectionDislocation::ConservativeAdvectionDislocation(\n    const InputParameters & parameters)\n  : Kernel(parameters),\n    _dislocationcharacter(\n        getParam<MooseEnum>(\"dislocation_character\").getEnum<DislocationCharacter>()),\n    _dislocationsign(getParam<MooseEnum>(\"dislocation_sign\").getEnum<DislocationSign>()),\n    _slip_direction_edge(getMaterialProperty<std::vector<RealVectorValue>>(\"slip_direction_edge\")),\n    _slip_plane_normalboth(\n        getMaterialProperty<std::vector<RealVectorValue>>(\"slip_plane_normalboth\")),\n    _slip_system_index(getParam<int>(\"slip_system_index\")),\n    _dislo_velocity_CP_edge(getMaterialProperty<std::vector<Real>>(\"dislo_velocity_edge\")),\n    _dislo_velocity_CP_screw(getMaterialProperty<std::vector<Real>>(\"dislo_velocity_screw\")),\n    _upwinding(getParam<MooseEnum>(\"upwinding_type\").getEnum<UpwindingType>()),\n    _u_nodal(_var.dofValues()),\n    _upwind_node(0),\n    _dtotal_mass_out(0)\n{\n}\n\nThis is the validParameters and constructor of the \"InterfaceDiffusion\" interface kernel:\nInputParameters\nInterfaceDiffusionDislocation::validParams()\n{\n  InputParameters params = InterfaceKernel::validParams();\n  params.addParam<Real>(\"density_critical\", 1.0,\"Critical density beyond which there will be dislocation transfer across Grain Boundary\"); \n  params.addParam<Real>(\"tau_critical\", 0.0,\"Critical resolved shear stres beyond which there will be dislocation transfer across Grain Boundary\");   \n  MooseEnum dislocation_character(\"edge screw\", \"edge\");\n  params.addParam<MooseEnum>(\"dislocation_character\", dislocation_character, \"Character of dislocation\");\n  MooseEnum dislocation_sign(\"positive negative\", \"positive\");\n  params.addParam<MooseEnum>(\"dislocation_sign\", dislocation_sign, \"Sign of dislocation\");\n  params.addRequiredParam<int>(\"slip_system_index\",\n                               \"Slip system index to get slip direction\"\n                               \"FCC: 1 to 12.\");\n  params.addRequiredParam<int>(\"slip_system_index_neighbor\",\n                               \"Slip system index to get slip direction of the neighbor\"\n                               \"FCC: 1 to 12.\");\n  params.addClassDescription(\n      \"The kernel is utilized to establish flux equivalence on an interface for dislocation\" \n      \"assuming a divergence free velocity.\");\n  return params;\n}\n\nInterfaceDiffusionDislocation::InterfaceDiffusionDislocation(const InputParameters & parameters)\n  : InterfaceKernel(parameters),\n    _density_critical(getParam<Real>(\"density_critical\")),\n    _tau_critical(getParam<Real>(\"tau_critical\")),\n    _slip_system_index(getParam<int>(\"slip_system_index\")),\n    _slip_system_index_neighbor(getParam<int>(\"slip_system_index_neighbor\")),\n    _dislo_velocity_CP_edge(getMaterialProperty<std::vector<Real>>(\"dislo_velocity_edge\")),\n    _dislo_velocity_CP_edge_neighbor(getNeighborMaterialProperty<std::vector<Real>>(\"dislo_velocity_edge\")),\n    _dislocationcharacter(getParam<MooseEnum>(\"dislocation_character\").getEnum<DislocationCharacter>()),\n    _dislocationsign(getParam<MooseEnum>(\"dislocation_sign\").getEnum<DislocationSign>()), \n    _slip_direction_edge(getMaterialProperty<std::vector<RealVectorValue>>(\"slip_direction_edge\")),\n    _slip_plane_normalboth(getMaterialProperty<std::vector<RealVectorValue>>(\"slip_plane_normalboth\")),\n    _slip_direction_edge_neighbor(getNeighborMaterialProperty<std::vector<RealVectorValue>>(\"slip_direction_edge\")),\n    _slip_plane_normalboth_neighbor(getNeighborMaterialProperty<std::vector<RealVectorValue>>(\"slip_plane_normalboth\")),\n    _tau(getMaterialProperty<std::vector<Real>>(\"applied_shear_stress\")),\n    _slip_resistance(getMaterialProperty<std::vector<Real>>(\"slip_resistance\"))\n{\n}\n\nIn the interface kernel, the only variable that is correct is _slip_resistance. The other variables are always set to zero. Can you please help me with this.\nThanks a lor for your help!\nBest,\nBrayan",
          "url": "https://github.com/idaholab/moose/discussions/28908",
          "updatedAt": "2024-11-03T00:44:45Z",
          "publishedAt": "2024-10-22T21:56:32Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou should share your input and the header as well for the interface kernel.\nThe interface kernel is set to act on an internal boundary between two subdomains right?",
                  "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11029868",
                  "updatedAt": "2024-10-23T14:00:05Z",
                  "publishedAt": "2024-10-23T14:00:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bmurgas-LANL"
                          },
                          "bodyText": "Hi @GiudGiud,\nThank you for the reply.\nThis is the repository I am working on: https://github.com/bmurgas-LANL/discopanther\nI declare the property in the file DiscoFluxCPStressUpdate.C\nFor simplicity, I created a copy of the interfacediffusion kernel named interfacediffusiontest in https://github.com/bmurgas-LANL/discopanther/blob/main/src/interfacekernels/InterfaceDiffusionTest.C\nIn this modified interfaceDiffusion kernel I just tried to read the _slip_direction_edge material property created in DiscoFluxCPStressUpdate.C .\nThis is the source file:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"InterfaceDiffusionTest.h\"\n\nregisterMooseObject(\"MooseApp\", InterfaceDiffusionTest);\n\nInputParameters\nInterfaceDiffusionTest::validParams()\n{\n  InputParameters params = InterfaceKernel::validParams();\n  params.addParam<MaterialPropertyName>(\"D\", \"D\", \"The diffusion coefficient.\");\n  params.addParam<MaterialPropertyName>(\n      \"D_neighbor\", \"D_neighbor\", \"The neighboring diffusion coefficient.\");\n  params.addClassDescription(\n      \"The kernel is utilized to establish flux equivalence on an interface for variables.\");\n  return params;\n}\n\nInterfaceDiffusionTest::InterfaceDiffusionTest(const InputParameters & parameters)\n  : InterfaceKernel(parameters),\n    _D(getMaterialProperty<Real>(\"D\")),\n    _D_neighbor(getNeighborMaterialProperty<Real>(\"D_neighbor\")),\n    _slip_direction_edge(getMaterialProperty<std::vector<RealVectorValue>>(\"slip_direction_edge\")),\n    _slip_plane_normalboth(\n        getMaterialProperty<std::vector<RealVectorValue>>(\"slip_plane_normalboth\"))\n{\n}\n\nReal\nInterfaceDiffusionTest::computeQpResidual(Moose::DGResidualType type)\n{\n  Real r = 0;\n\n  switch (type)\n  {\n    case Moose::Element:\n      r = _test[_i][_qp] * -_D_neighbor[_qp] * _grad_neighbor_value[_qp] * _normals[_qp];\n      break;\n\n    case Moose::Neighbor:\n      r = _test_neighbor[_i][_qp] * _D[_qp] * _grad_u[_qp] * _normals[_qp];\n      break;\n  }\n\n  return r;\n}\n\nReal\nInterfaceDiffusionTest::computeQpJacobian(Moose::DGJacobianType type)\n{\n  Real jac = 0;\n\n  switch (type)\n  {\n    case Moose::ElementElement:\n    case Moose::NeighborNeighbor:\n      break;\n\n    case Moose::NeighborElement:\n      jac = _test_neighbor[_i][_qp] * _D[_qp] * _grad_phi[_j][_qp] * _normals[_qp];\n      break;\n\n    case Moose::ElementNeighbor:\n      jac = _test[_i][_qp] * -_D_neighbor[_qp] * _grad_phi_neighbor[_j][_qp] * _normals[_qp];\n      break;\n  }\n\n  return jac;\n}\n\nAnd this is the header file:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#pragma once\n\n#include \"InterfaceKernel.h\"\n\n/**\n * DG kernel for interfacing diffusion between two variables on adjacent blocks\n */\nclass InterfaceDiffusionTest : public InterfaceKernel\n{\npublic:\n  static InputParameters validParams();\n\n  InterfaceDiffusionTest(const InputParameters & parameters);\n\nprotected:\n  virtual Real computeQpResidual(Moose::DGResidualType type) override;\n  virtual Real computeQpJacobian(Moose::DGJacobianType type) override;\n\n  const MaterialProperty<Real> & _D;\n  const MaterialProperty<Real> & _D_neighbor;\n\n  // dislocation velocities\n  // slip direction and normal element\n  const MaterialProperty<std::vector<RealVectorValue>> & _slip_direction_edge;\n  const MaterialProperty<std::vector<RealVectorValue>> & _slip_plane_normalboth;\n};\n\nIn this case, the two material properties are not correct. The value is always zero.\nThanks again for your help.\nBest,\nBrayan",
                          "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11031052",
                          "updatedAt": "2024-10-23T15:32:39Z",
                          "publishedAt": "2024-10-23T15:32:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bmurgas-LANL"
                          },
                          "bodyText": "I forgot the input file:\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh] \n  [./nepermesh]\n    type = FileMeshGenerator\n    file = '/Users/bmurgas/workspace/meshfiles/bar/px3-bar/px3_bar_hex8_cl16e-3.e'\n  [../]\n  [create_sideset]\n    type = SideSetsFromNodeSetsGenerator\n    input = nepermesh\n  []\n\n  # [./x0_modifier]\n  #   type = BoundingBoxNodeSetGenerator\n  #   input = nepermesh\n  #   new_boundary = x0\n  #   top_right = '0.1 1.1 0.35'\n  #   bottom_left = '-0.1 -0.1 -0.1'\n  # [../]\n  # [./y0_modifier]\n  #   type = BoundingBoxNodeSetGenerator\n  #   input = x0_modifier\n  #   new_boundary = y0\n  #   top_right = '1.1 0.1 0.35'\n  #   bottom_left = '-0.1 -0.1 -0.1'\n  # [../]\n  # [./z0_modifier]\n  #   type = BoundingBoxNodeSetGenerator\n  #   input = y0_modifier\n  #   new_boundary = z0\n  #   top_right = '1.1 1.1 0.1'\n  #   bottom_left = '-0.1 -0.1 -0.1'\n  # [../]\n  # [./x1_modifier]\n  #   type = BoundingBoxNodeSetGenerator\n  #   input = z0_modifier\n  #   new_boundary = x1\n  #   top_right = '1.1 1.1 0.35'\n  #   bottom_left = '0.9 -0.1 -0.1'\n  # [../]\n  # [./y1_modifier]\n  #   type = BoundingBoxNodeSetGenerator\n  #   input = x1_modifier\n  #   new_boundary = y1\n  #   top_right = '1.1 1.1 0.35'\n  #   bottom_left = '-0.1 0.9 -0.1'\n  # [../]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n# [Debug]\n#   #show_execution_order = 'ALWAYS'\n#   show_material_props = true\n#   show_var_residual_norms = true\n# []\n\n[Outputs]\n    file_base = method_Discoflux\n    csv = true\n    exodus = true\n    console = true\n[]\n\n[UserObjects]\n  [./prop_read]\n    type = PropertyReadFile\n    prop_file_name = '/Users/bmurgas/workspace/auxfiles/px3-bar-sp10-sp01.inp' #sxori-0-0-0.inp' #px3-bar-sp10-sp01.inp'\n    nprop = 3\n    read_type = block\n    nblock= 3\n  [../]\n[]\n\n[Variables]\n  [./disp_x]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  [./disp_y]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  [./disp_z]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n  # DISLOCATION DENSITIES\n  ## POSITIVE EDGE\n  [./DD_EdgePositive_1]\n    order = FIRST\n    family = LAGRANGE\n    # [./InitialCondition]\n    #   type = FunctionIC\n    #   function = init_rho_edge_pos_1\n    #   # block = 1\n    # [../]\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_2]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_3]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_4]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_5]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_6]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_7]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_8]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_9]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_10]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_11]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgePositive_12]\n    order = FIRST\n    family = LAGRANGE\n    # [./InitialCondition]\n    #   type = ConstantIC\n    #   value = 0.5\n    # [../]\n    [./InitialCondition]\n      type = FunctionIC\n      function = init_rho_edge_pos_1\n      # block = 1\n    [../]\n  [../]\n  ## NEGATIVE EDGE\n  [./DD_EdgeNegative_1]\n    order = FIRST\n    family = LAGRANGE\n    # [./InitialCondition]\n    #   type = FunctionIC\n    #   function = init_rho_edge_neg_1\n    #   # block = 1\n    # [../]\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n      # block = 1\n    [../]\n  [../]\n  [./DD_EdgeNegative_2]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_3]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_4]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_5]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_6]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_7]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_8]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_9]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_10]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_11]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC \n      value = 0.5\n    [../]\n  [../]\n  [./DD_EdgeNegative_12]\n    order = FIRST\n    family = LAGRANGE\n    # [./InitialCondition]\n    #   type = ConstantIC\n    #   value = 0.5\n    # [../]\n    [./InitialCondition]\n      type = FunctionIC\n      function = init_rho_edge_neg_1\n      # block = 1\n    [../]\n  [../]\n  # POSITIVE SCREW\n  [./DD_ScrewPositive_1]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_2]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_3]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_4]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_5]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_6]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_7]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_8]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_9]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_10]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_11]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewPositive_12]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  ## NEGATIVE Screw\n  [./DD_ScrewNegative_1]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_2]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_3]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_4]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_5]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_6]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_7]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_8]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_9]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_10]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_11]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./DD_ScrewNegative_12]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n[]\n\n[Functions]\n  [./init_rho_edge_pos_1]\n    type = ParsedFunction\n    value = 'if(x>=0.24,1.0,0.0)*if(x<=0.40,1.0,0.0)*if(z>=0.08,1.0,0.0)*if(z<=0.24,1.0,0.0)*0.4+0.1'\n  [../]\n  [./init_rho_edge_neg_1]\n    type = ParsedFunction\n\t  value = 'if(x>=0.24,1.0,0.0)*if(x<=0.40,1.0,0.0)*if(z>=0.08,1.0,0.0)*if(z<=0.24,1.0,0.0)*0.4+0.1'\n  [../]\n  [./disp_load]\n    type = ParsedFunction\n    value = '0.1*t'\n  [../]\n[]\n\n[Kernels]\n  [./dot_DD_EdgePositive_1]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_1\n  [../]\n  # [./Advection_DD_EdgePositive_1]\n  #   type = ConservativeAdvectionDislocation\n  #   variable = DD_EdgePositive_1\n  #   upwinding_type = full\n  #   dislocation_character = edge\n  #   dislocation_sign = positive\n  #   slip_system_index = 1\n  # [../]\n  [./dot_DD_EdgePositive_2]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_2\n  [../]\n  #   [./Advection_DD_EdgePositive_2]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_2\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 2\n  #   [../]\n  [./dot_DD_EdgePositive_3]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_3\n  [../]\n  #   [./Advection_DD_EdgePositive_3]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_3\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 3\n  #   [../]\n  [./dot_DD_EdgePositive_4]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_4\n  [../]\n  #   [./Advection_DD_EdgePositive_4]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_4\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 4\n  #   [../]\n  [./dot_DD_EdgePositive_5]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_5\n  [../]\n  #   [./Advection_DD_EdgePositive_5]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_5\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 5\n  #   [../]\n  [./dot_DD_EdgePositive_6]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_6\n  [../]\n  #   [./Advection_DD_EdgePositive_6]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_6\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 6\n  #   [../]\n  [./dot_DD_EdgePositive_7]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_7\n  [../]\n  #   [./Advection_DD_EdgePositive_7]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_7\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 7\n  #   [../]\n  [./dot_DD_EdgePositive_8]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_8\n  [../]\n  #   [./Advection_DD_EdgePositive_8]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_8\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 8\n  #   [../]\n  [./dot_DD_EdgePositive_9]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_9\n  [../]\n  #   [./Advection_DD_EdgePositive_9]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_9\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 9\n  #   [../]\n  [./dot_DD_EdgePositive_10]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_10\n  [../]\n  #   [./Advection_DD_EdgePositive_10]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_10\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 10\n  #   [../]\n  [./dot_DD_EdgePositive_11]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_11\n  [../]\n  #   [./Advection_DD_EdgePositive_11]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgePositive_11\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     slip_system_index = 11\n  #   [../]\n  [./dot_DD_EdgePositive_12]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgePositive_12\n  [../]\n    [./Advection_DD_EdgePositive_12]\n      type = ConservativeAdvectionDislocation\n      variable = DD_EdgePositive_12\n      upwinding_type = full\n      dislocation_character = edge\n      dislocation_sign = positive\n      slip_system_index = 12\n    [../]\n  \n  [./dot_DD_EdgeNegative_1]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_1\n  [../]\n    # [./Advection_DD_EdgeNegative_1]\n    #   type = ConservativeAdvectionDislocation\n    #   variable = DD_EdgeNegative_1\n    #   upwinding_type = full\n    #   dislocation_character = edge\n    #   dislocation_sign = negative\n    #   slip_system_index = 1\n    # [../]\n  [./dot_DD_EdgeNegative_2]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_2\n  [../]\n  #   [./Advection_DD_EdgeNegative_2]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_2\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 2\n  #   [../]\n  [./dot_DD_EdgeNegative_3]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_3\n  [../]\n  #   [./Advection_DD_EdgeNegative_3]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_3\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 3\n  #   [../]\n  [./dot_DD_EdgeNegative_4]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_4\n  [../]\n  #   [./Advection_DD_EdgeNegative_4]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_4\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 4\n  #   [../]\n  [./dot_DD_EdgeNegative_5]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_5\n  [../]\n  #   [./Advection_DD_EdgeNegative_5]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_5\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 5\n  #   [../]\n  [./dot_DD_EdgeNegative_6]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_6\n  [../]\n  #   [./Advection_DD_EdgeNegative_6]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_6\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 6\n  #   [../]\n  [./dot_DD_EdgeNegative_7]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_7\n  [../]\n  #   [./Advection_DD_EdgeNegative_7]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_7\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 7\n  #   [../]\n  [./dot_DD_EdgeNegative_8]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_8\n  [../]\n  #   [./Advection_DD_EdgeNegative_8]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_8\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 8\n  #   [../]\n  [./dot_DD_EdgeNegative_9]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_9\n  [../]\n  #   [./Advection_DD_EdgeNegative_9]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_9\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 9\n  #   [../]\n  [./dot_DD_EdgeNegative_10]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_10\n  [../]\n  #   [./Advection_DD_EdgeNegative_10]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_10\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 10\n  #   [../]\n  [./dot_DD_EdgeNegative_11]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_11\n  [../]\n  #   [./Advection_DD_EdgeNegative_11]\n  #     type = ConservativeAdvectionDislocation\n  #     variable = DD_EdgeNegative_11\n  #     upwinding_type = full\n  #     dislocation_character = edge\n  #     dislocation_sign = negative\n  #     slip_system_index = 11\n  #   [../]\n  [./dot_DD_EdgeNegative_12]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_EdgeNegative_12\n  [../]\n    [./Advection_DD_EdgeNegative_12]\n      type = ConservativeAdvectionDislocation\n      variable = DD_EdgeNegative_12\n      upwinding_type = full\n      dislocation_character = edge\n      dislocation_sign = negative\n      slip_system_index = 12\n    [../]\n  \n  \n  [./dot_DD_ScrewPositive_1]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_1\n  [../]\n  [./dot_DD_ScrewPositive_2]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_2\n  [../]\n  [./dot_DD_ScrewPositive_3]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_3\n  [../]\n  [./dot_DD_ScrewPositive_4]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_4\n  [../]\n  [./dot_DD_ScrewPositive_5]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_5\n  [../]\n  [./dot_DD_ScrewPositive_6]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_6\n  [../]\n  [./dot_DD_ScrewPositive_7]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_7\n  [../]\n  [./dot_DD_ScrewPositive_8]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_8\n  [../]\n  [./dot_DD_ScrewPositive_9]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_9\n  [../]\n  [./dot_DD_ScrewPositive_10]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_10\n  [../]\n  [./dot_DD_ScrewPositive_11]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_11\n  [../]\n  [./dot_DD_ScrewPositive_12]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewPositive_12\n  [../]\n  \n  [./dot_DD_ScrewNegative_1]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_1\n  [../]\n  [./dot_DD_ScrewNegative_2]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_2\n  [../]\n  [./dot_DD_ScrewNegative_3]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_3\n  [../]\n  [./dot_DD_ScrewNegative_4]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_4\n  [../]\n  [./dot_DD_ScrewNegative_5]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_5\n  [../]\n  [./dot_DD_ScrewNegative_6]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_6\n  [../]\n  [./dot_DD_ScrewNegative_7]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_7\n  [../]\n  [./dot_DD_ScrewNegative_8]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_8\n  [../]\n  [./dot_DD_ScrewNegative_9]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_9\n  [../]\n  [./dot_DD_ScrewNegative_10]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_10\n  [../]\n  [./dot_DD_ScrewNegative_11]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_11\n  [../]\n  [./dot_DD_ScrewNegative_12]\n    # type = TimeDerivative  \n    type = MassLumpedTimeDerivative\n    variable = DD_ScrewNegative_12\n  [../]\n[]\n\n[InterfaceKernels]\n  [./Intf_Avd_DD_EdgePositive_12_1]\n    type = InterfaceDiffusionTest\n    variable = DD_EdgePositive_12\n    neighbor_var = DD_EdgePositive_1\n    boundary = surface_GB\n    D = 1.0\n    D_neighbor = 1.0\n  [../]\n  # [./Intf_Avd_DD_EdgePositive_12_1]\n  #   type = InterfaceDiffusionDislocation\n  #   variable = DD_EdgePositive_12\n  #   slip_system_index = 12\n  #   neighbor_var = DD_EdgePositive_1\n  #   slip_system_index_neighbor = 1\n  #   dislocation_character = edge\n  #   dislocation_sign = positive\n  #   boundary = surface_GB\n  #   density_critical = 0.2\n  #   tau_critical = 2\n  # [../]\n  [./Intf_Avd_DD_EdgePositive_12_2]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_2\n    slip_system_index_neighbor = 2\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_3]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_3\n    slip_system_index_neighbor = 3\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_4]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_4\n    slip_system_index_neighbor = 4\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_5]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_5\n    slip_system_index_neighbor = 5\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_6]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_6\n    slip_system_index_neighbor = 6\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_7]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_7\n    slip_system_index_neighbor = 7\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_8]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_8\n    slip_system_index_neighbor = 8\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_9]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_9\n    slip_system_index_neighbor = 9\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_10]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_10\n    slip_system_index_neighbor = 10\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_11]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_11\n    slip_system_index_neighbor = 11\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  [./Intf_Avd_DD_EdgePositive_12_12]\n    type = InterfaceDiffusionDislocation\n    variable = DD_EdgePositive_12\n    slip_system_index = 12\n    neighbor_var = DD_EdgePositive_12\n    slip_system_index_neighbor = 12\n    dislocation_character = edge\n    dislocation_sign = positive\n    boundary = surface_GB\n    density_critical = 0.2\n    tau_critical = 2\n  [../]\n  # [./Intf_Avd_DD_EdgePositive_1_12]\n  #   type = InterfaceDiffusionDislocation\n  #   variable = DD_EdgePositive_1\n  #   slip_system_index = 1\n  #   neighbor_var = DD_EdgePositive_12\n  #   slip_system_index_neighbor = 12\n  #   dislocation_character = edge\n  #   dislocation_sign = positive\n  #   boundary = surface_GB\n  #   density_critical = 0.2\n  #   tau_critical = 2\n  # [../]\n  #   [./Intf_Avd_DD_EdgePositive_2_12]\n  #     type = InterfaceDiffusionDislocation\n  #     variable = DD_EdgePositive_2\n  #     slip_system_index = 2\n  #     neighbor_var = DD_EdgePositive_12\n  #     slip_system_index_neighbor = 12\n  #     dislocation_character = edge\n  #     dislocation_sign = positive\n  #     boundary = surface_GB\n  #     density_critical = 0.2\n  #     tau_critical = 2\n  #   [../]\n  #     [./Intf_Avd_DD_EdgePositive_3_12]\n  #       type = InterfaceDiffusionDislocation\n  #       variable = DD_EdgePositive_3\n  #       slip_system_index = 3\n  #       neighbor_var = DD_EdgePositive_12\n  #       slip_system_index_neighbor = 12\n  #       dislocation_character = edge\n  #       dislocation_sign = positive\n  #       boundary = surface_GB\n  #       density_critical = 0.2\n  #       tau_critical = 2\n  #     [../]\n  #       [./Intf_Avd_DD_EdgePositive_4_12]\n  #         type = InterfaceDiffusionDislocation\n  #         variable = DD_EdgePositive_4\n  #         slip_system_index = 4\n  #         neighbor_var = DD_EdgePositive_12\n  #         slip_system_index_neighbor = 12\n  #         dislocation_character = edge\n  #         dislocation_sign = positive\n  #         boundary = surface_GB\n  #         density_critical = 0.2\n  #         tau_critical = 2\n  #       [../]\n  #         [./Intf_Avd_DD_EdgePositive_5_12]\n  #           type = InterfaceDiffusionDislocation\n  #           variable = DD_EdgePositive_5\n  #           slip_system_index = 5\n  #           neighbor_var = DD_EdgePositive_12\n  #           slip_system_index_neighbor = 12\n  #           dislocation_character = edge\n  #           dislocation_sign = positive\n  #           boundary = surface_GB\n  #           density_critical = 0.2\n  #           tau_critical = 2\n  #         [../]\n  #           [./Intf_Avd_DD_EdgePositive_6_12]\n  #             type = InterfaceDiffusionDislocation\n  #             variable = DD_EdgePositive_6\n  #             slip_system_index = 6\n  #             neighbor_var = DD_EdgePositive_12\n  #             slip_system_index_neighbor = 12\n  #             dislocation_character = edge\n  #             dislocation_sign = positive\n  #             boundary = surface_GB\n  #             density_critical = 0.2\n  #             tau_critical = 2\n  #           [../]\n  #             [./Intf_Avd_DD_EdgePositive_7_12]\n  #               type = InterfaceDiffusionDislocation\n  #               variable = DD_EdgePositive_7\n  #               slip_system_index = 7\n  #               neighbor_var = DD_EdgePositive_12\n  #               slip_system_index_neighbor = 12\n  #               dislocation_character = edge\n  #               dislocation_sign = positive\n  #               boundary = surface_GB\n  #               density_critical = 0.2\n  #               tau_critical = 2\n  #             [../]\n  #               [./Intf_Avd_DD_EdgePositive_8_12]\n  #                 type = InterfaceDiffusionDislocation\n  #                 variable = DD_EdgePositive_8\n  #                 slip_system_index = 8\n  #                 neighbor_var = DD_EdgePositive_12\n  #                 slip_system_index_neighbor = 12\n  #                 dislocation_character = edge\n  #                 dislocation_sign = positive\n  #                 boundary = surface_GB\n  #                 density_critical = 0.2\n  #                 tau_critical = 2\n  #               [../]\n  #                 [./Intf_Avd_DD_EdgePositive_9_12]\n  #                   type = InterfaceDiffusionDislocation\n  #                   variable = DD_EdgePositive_9\n  #                   slip_system_index = 9\n  #                   neighbor_var = DD_EdgePositive_12\n  #                   slip_system_index_neighbor = 12\n  #                   dislocation_character = edge\n  #                   dislocation_sign = positive\n  #                   boundary = surface_GB\n  #                   density_critical = 0.2\n  #                   tau_critical = 2\n  #                 [../]\n  #                   [./Intf_Avd_DD_EdgePositive_10_12]\n  #                     type = InterfaceDiffusionDislocation\n  #                     variable = DD_EdgePositive_10\n  #                     slip_system_index = 10\n  #                     neighbor_var = DD_EdgePositive_12\n  #                     slip_system_index_neighbor = 12\n  #                     dislocation_character = edge\n  #                     dislocation_sign = positive\n  #                     boundary = surface_GB\n  #                     density_critical = 0.2\n  #                     tau_critical = 2\n  #                   [../]\n  #                     [./Intf_Avd_DD_EdgePositive_11_12]\n  #                       type = InterfaceDiffusionDislocation\n  #                       variable = DD_EdgePositive_11\n  #                       slip_system_index = 11\n  #                       neighbor_var = DD_EdgePositive_12\n  #                       slip_system_index_neighbor = 12\n  #                       dislocation_character = edge\n  #                       dislocation_sign = positive\n  #                       boundary = surface_GB\n  #                       density_critical = 0.2\n  #                       tau_critical = 2\n  #                     [../]\n[]\n\n[AuxVariables]\n  [euler_angle_1]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [euler_angle_2]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  [euler_angle_3]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[AuxKernels]\n  [euler_angle_1]\n    type = MaterialRealVectorValueAux\n    variable = euler_angle_1\n    property = updated_Euler_angle\n    component = 0\n    execute_on = 'initial final'\n  []\n  [euler_angle_2]\n    type = MaterialRealVectorValueAux\n    variable = euler_angle_2\n    property = updated_Euler_angle\n    component = 1\n    execute_on = 'initial final'\n  []\n  [euler_angle_3]\n    type = MaterialRealVectorValueAux\n    variable = euler_angle_3\n    property = updated_Euler_angle\n    component = 2\n    execute_on = 'initial final'\n  []\n[]\n\n[BCs]\n  ##############################################\n  # X : Left and Right\n  # Y : Bottom and Top\n  # Z : Back and Front\n  ##############################################\n  [./BC_X]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = 'x0'\n    # boundary = left\n    function = 0.0\n  [../]\n    [./BC_Y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = 'y0'\n    # boundary = bottom\n    function = 0.0\n  [../]\n    [./BC_Z]\n    type = FunctionDirichletBC\n    variable = disp_z\n    boundary = 'z0'\n    # boundary = back\n    function = 0.0\n  [../]\n\n  [./BC_Loading]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = 'x0 x1 '\n    # boundary = top\n    function = '0.001*x*t'\n  [../]\n\n  # [./BC_X0]\n  #   type = FunctionDirichletBC\n  #   variable = disp_x\n  #   boundary = 'x0 y0 z0'\n  #   function = 0.0\n  # [../]\n  # [./BC_Y0]\n  #   type = FunctionDirichletBC\n  #   variable = disp_y\n  #   boundary = 'x0 y0 z0'\n  #   function = 0.0\n  # [../]\n  # [./BC_Z0]\n  #   type = FunctionDirichletBC\n  #   variable = disp_z\n  #   boundary = 'x0 y0 z0'\n  #   function = 0.0\n  # [../]\n\n  # [./Periodic]\n  #   [./rho_edge_positive_1]\n  #     variable = 'DD_EdgePositive_1 DD_EdgePositive_2 DD_EdgePositive_3 DD_EdgePositive_4 DD_EdgePositive_5 DD_EdgePositive_6 DD_EdgePositive_7 DD_EdgePositive_8 DD_EdgePositive_9 DD_EdgePositive_10 DD_EdgePositive_11 DD_EdgePositive_12'\n  #     auto_direction = 'x y z'\n  #   [../]\n  #   [./rho_edge_negative]\n  #     variable = 'DD_EdgeNegative_1 DD_EdgeNegative_2 DD_EdgeNegative_3 DD_EdgeNegative_4 DD_EdgeNegative_5 DD_EdgeNegative_6 DD_EdgeNegative_7 DD_EdgeNegative_8 DD_EdgeNegative_9 DD_EdgeNegative_10 DD_EdgeNegative_11 DD_EdgeNegative_12'\n  #     auto_direction = 'x y z'\n  #   [../]\n  # [../] \n  \n[]\n\n[Physics/SolidMechanics/QuasiStatic/all]\n  strain = FINITE\n  add_variables = true\n  new_system = true\n  formulation = total\n  incremental = true\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '1.684e5 1.214e5 1.214e5 1.684e5 1.214e5 1.684e5 0.754e5 0.754e5 0.754e5'\n    fill_method = symmetric9\n    read_prop_user_object = prop_read\n  [../]\n  [stress_brass]\n    type = ComputeMultipleCrystalPlasticityStress\n    crystal_plasticity_models = 'CP_DiscoFlux'\n    tan_mod_type = exact\n  []\n  [./CP_DiscoFlux]\n    type = DiscoFluxCPStressUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = /Users/bmurgas/workspace/auxfiles/input_slip_sys.inp\n    lattice_friction = 15\n    Coeff_hardening = 0.85\n    slip_increment_tolerance = 2.0e-2 #2.0e-2 10.0\n    DD_EdgePositive_1 = DD_EdgePositive_1\n    DD_EdgePositive_2 = DD_EdgePositive_2\n    DD_EdgePositive_3 = DD_EdgePositive_3\n    DD_EdgePositive_4 = DD_EdgePositive_4\n    DD_EdgePositive_5 = DD_EdgePositive_5\n    DD_EdgePositive_6 = DD_EdgePositive_6\n    DD_EdgePositive_7 = DD_EdgePositive_7\n    DD_EdgePositive_8 = DD_EdgePositive_8\n    DD_EdgePositive_9 = DD_EdgePositive_9\n    DD_EdgePositive_10 = DD_EdgePositive_10\n    DD_EdgePositive_11 = DD_EdgePositive_11\n    DD_EdgePositive_12 = DD_EdgePositive_12\n    DD_EdgeNegative_1 = DD_EdgeNegative_1\n    DD_EdgeNegative_2 = DD_EdgeNegative_2\n    DD_EdgeNegative_3 = DD_EdgeNegative_3\n    DD_EdgeNegative_4 = DD_EdgeNegative_4\n    DD_EdgeNegative_5 = DD_EdgeNegative_5\n    DD_EdgeNegative_6 = DD_EdgeNegative_6\n    DD_EdgeNegative_7 = DD_EdgeNegative_7\n    DD_EdgeNegative_8 = DD_EdgeNegative_8\n    DD_EdgeNegative_9 = DD_EdgeNegative_9\n    DD_EdgeNegative_10 = DD_EdgeNegative_10\n    DD_EdgeNegative_11 = DD_EdgeNegative_11\n    DD_EdgeNegative_12 = DD_EdgeNegative_12\n    DD_ScrewPositive_1 = DD_ScrewPositive_1\n    DD_ScrewPositive_2 = DD_ScrewPositive_2\n    DD_ScrewPositive_3 = DD_ScrewPositive_3\n    DD_ScrewPositive_4 = DD_ScrewPositive_4\n    DD_ScrewPositive_5 = DD_ScrewPositive_5\n    DD_ScrewPositive_6 = DD_ScrewPositive_6\n    DD_ScrewPositive_7 = DD_ScrewPositive_7\n    DD_ScrewPositive_8 = DD_ScrewPositive_8\n    DD_ScrewPositive_9 = DD_ScrewPositive_9\n    DD_ScrewPositive_10 = DD_ScrewPositive_10\n    DD_ScrewPositive_11 = DD_ScrewPositive_11\n    DD_ScrewPositive_12 = DD_ScrewPositive_12\n    DD_ScrewNegative_1 = DD_ScrewNegative_1\n    DD_ScrewNegative_2= DD_ScrewNegative_2\n    DD_ScrewNegative_3 = DD_ScrewNegative_3\n    DD_ScrewNegative_4 = DD_ScrewNegative_4\n    DD_ScrewNegative_5 = DD_ScrewNegative_5\n    DD_ScrewNegative_6 = DD_ScrewNegative_6\n    DD_ScrewNegative_7 = DD_ScrewNegative_7\n    DD_ScrewNegative_8 = DD_ScrewNegative_8\n    DD_ScrewNegative_9 = DD_ScrewNegative_9\n    DD_ScrewNegative_10 = DD_ScrewNegative_10\n    DD_ScrewNegative_11 = DD_ScrewNegative_11\n    DD_ScrewNegative_12 = DD_ScrewNegative_12\n    print_state_variable_convergence_error_messages = true\n  [../]\n  [updated_euler_angle]\n    type = ComputeUpdatedEulerAngle\n    radian_to_degree = true\n  []\n[]\n\n[Postprocessors]\n  [euler_angle_1] \n    type = ElementAverageValue\n    variable = euler_angle_1\n  []\n  [euler_angle_2]\n    type = ElementAverageValue\n    variable = euler_angle_2\n  []\n  [euler_angle_3]\n    type = ElementAverageValue\n    variable = euler_angle_3\n  []\n[]\n\n[GlobalParams]\n    dislo_density_initial = 1.0e+05\n    C_multi =  0.0  #8.5e-06\n    C_trap =   0.0  #5.5e-03\n    C_m_ann =  0.0  #0.5\n    C_im_ann = 0.0 #0.5\n    burgers_vector_mag = 2.52e-07\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n\n  # solve_type = 'PJFNK'\n  # line_search = 'none'\n  # petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  # petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n  # nl_abs_tol = 1e-5 \n  # nl_max_its = 10\n  # l_abs_tol = 1e-5\n  # l_max_its = 20\n\n  # solver used in cpam\n  solve_type = 'PJFNK'\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart'\n  petsc_options_value = 'hypre    boomeramg          31'\n  line_search = 'none'\n  l_max_its = 50\n  nl_max_its = 50\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-6\n  l_tol = 1e-8\n\n  dtmax = 0.2\n  dtmin = 0.000001\n  end_time = 100 #100\n  [./TimeStepper]\n    type = ConstantDT\n    dt = 0.2\n    growth_factor = 1.01\n  [../]\n[]\n\n[AuxVariables]\n  [./pk2_1]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pk2_2]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pk2_3]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pk2_4]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pk2_5]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./pk2_6]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_1]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_2]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_3]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_4]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_5]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./E_6]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n  [./pk2_1] \n   type = RankTwoAux\n   variable = pk2_1\n   rank_two_tensor = stress\n   index_j = 0\n   index_i = 0\n  [../]\n  [./pk2_2] \n    type = RankTwoAux\n    variable = pk2_2\n    rank_two_tensor = stress\n    index_j = 1\n    index_i = 1\n  [../]\n  [./pk2_3] \n   type = RankTwoAux\n   variable = pk2_3\n   rank_two_tensor = stress\n   index_j = 2\n   index_i = 2\n  [../]\n  [./pk2_4] \n    type = RankTwoAux\n    variable = pk2_4\n    rank_two_tensor = stress\n    index_j = 0\n    index_i = 1\n  [../]\n  [./pk2_5] \n    type = RankTwoAux\n    variable = pk2_5\n    rank_two_tensor = stress\n    index_j = 0\n    index_i = 2\n  [../]\n  [./pk2_6] \n    type = RankTwoAux\n    variable = pk2_6\n    rank_two_tensor = stress\n    index_j = 1\n    index_i = 2\n  [../]\n  [./E_1]\n   type = RankTwoAux\n   variable = E_1\n   rank_two_tensor = total_strain\n   index_j = 0\n   index_i = 0\n  [../]\n  [./E_2] \n    type = RankTwoAux\n    variable = E_2\n    rank_two_tensor = total_strain\n    index_j = 1\n    index_i = 1\n  [../]\n  [./E_3] \n   type = RankTwoAux\n   variable = E_3\n   rank_two_tensor = total_strain\n   index_j = 2\n   index_i = 2\n  [../]\n  [./E_4] \n    type = RankTwoAux\n    variable = E_4\n    rank_two_tensor = total_strain\n    index_j = 0\n    index_i = 1\n  [../]\n  [./E_5] \n    type = RankTwoAux\n    variable = E_5\n    rank_two_tensor = total_strain\n    index_j = 0\n    index_i = 2\n  [../]\n  [./E_6] \n    type = RankTwoAux\n    variable = E_6\n    rank_two_tensor = total_strain\n    index_j = 1\n    index_i = 2\n  [../]\n[]\n\n[Postprocessors]\n  [./pk2_1]\n    type = ElementAverageValue\n    variable = pk2_1\n  [../]\n  [./pk2_2]\n    type = ElementAverageValue\n    variable = pk2_2\n  [../]\n  [./pk2_3]\n    type = ElementAverageValue\n    variable = pk2_3\n  [../]\n  [./pk2_4]\n    type = ElementAverageValue\n    variable = pk2_4\n  [../]\n  [./pk2_5]\n    type = ElementAverageValue\n    variable = pk2_5\n  [../]\n  [./pk2_6]\n    type = ElementAverageValue\n    variable = pk2_6\n  [../]\n  [./E_1]\n    type = ElementAverageValue\n    variable = E_1\n  [../]\n  [./E_2]\n    type = ElementAverageValue\n    variable = E_2\n  [../]\n  [./E_3]\n    type = ElementAverageValue\n    variable = E_3\n  [../]\n  [./E_4]\n    type = ElementAverageValue\n    variable = E_4\n  [../]\n  [./E_5]\n    type = ElementAverageValue\n    variable = E_5\n  [../]\n  [./E_6]\n    type = ElementAverageValue\n    variable = E_6\n  [../]\n[]\n\n# [AuxVariables]\n#   [./DD_EP_01]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_02]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_03]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_04]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_05]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_06]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_07]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_08]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_09]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_10]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_11]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EP_12]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n# []\n\n\n# [AuxKernels]\n#   [./DD_EP_01]\n#    type = MaterialRealAux\n#    variable = DD_EP_01\n#    property = DD_EdgePositive_1\n#   [../]\n#   [./DD_EP_02]\n#    type = MaterialRealAux\n#    variable = DD_EP_02\n#    property = DD_EdgePositive_2  \n#   [../]\n#   [./DD_EP_03]\n#    type = MaterialRealAux\n#    variable = DD_EP_03\n#    property = DD_EdgePositive_3\n#   [../]\n#   [./DD_EP_04]\n#    type = MaterialRealAux\n#    variable = DD_EP_04\n#    property = DD_EdgePositive_4\n#   [../]\n#   [./DD_EP_05]\n#    type = MaterialRealAux\n#    variable = DD_EP_05\n#    property = DD_EdgePositive_5\n#   [../]\n#   [./DD_EP_06]\n#    type = MaterialRealAux\n#    variable = DD_EP_06\n#    property = DD_EdgePositive_6\n#   [../]\n#   [./DD_EP_07]\n#    type = MaterialRealAux\n#    variable = DD_EP_07\n#    property = DD_EdgePositive_7\n#   [../]\n#   [./DD_EP_08]\n#    type = MaterialRealAux\n#    variable = DD_EP_08\n#    property = DD_EdgePositive_8\n#   [../]\n#   [./DD_EP_09]\n#    type = MaterialRealAux\n#    variable = DD_EP_09\n#    property = DD_EdgePositive_9\n#   [../]\n#   [./DD_EP_10]\n#    type = MaterialRealAux\n#    variable = DD_EP_10\n#    property = DD_EdgePositive_10\n#   [../]\n#   [./DD_EP_11]\n#    type = MaterialRealAux\n#    variable = DD_EP_11\n#    property = DD_EdgePositive_11\n#   [../]\n#   [./DD_EP_12]\n#    type = MaterialRealAux\n#    variable = DD_EP_12\n#    property = DD_EdgePositive_12\n#   [../]\n# []\n  \n\n# [AuxVariables]\n#   [./DD_EN_01]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_02]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_03]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_04]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_05]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_06]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_07]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_08]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_09]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_10]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_11]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_EN_12]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n# []\n\n\n# [AuxKernels]\n#   [./DD_EN_01]\n#    type = MaterialRealAux\n#    variable = DD_EN_01\n#    property = DD_EdgeNegative_1\n#   [../]\n#   [./DD_EN_02]\n#    type = MaterialRealAux\n#    variable = DD_EN_02\n#    property = DD_EdgeNegative_2\n#   [../]\n#   [./DD_EN_03]\n#    type = MaterialRealAux\n#    variable = DD_EN_03\n#    property = DD_EdgeNegative_3\n#   [../]\n#   [./DD_EN_04]\n#    type = MaterialRealAux\n#    variable = DD_EN_04\n#    property = DD_EdgeNegative_4\n#   [../]\n#   [./DD_EN_05]\n#    type = MaterialRealAux\n#    variable = DD_EN_05\n#    property = DD_EdgeNegative_5\n#   [../]\n#   [./DD_EN_06]\n#    type = MaterialRealAux\n#    variable = DD_EN_06\n#    property = DD_EdgeNegative_6\n#   [../]\n#   [./DD_EN_07]\n#    type = MaterialRealAux\n#    variable = DD_EN_07\n#    property = DD_EdgeNegative_7\n#   [../]\n#   [./DD_EN_08]\n#    type = MaterialRealAux\n#    variable = DD_EN_08\n#    property = DD_EdgeNegative_8\n#   [../]\n#   [./DD_EN_09]\n#    type = MaterialRealAux\n#    variable = DD_EN_09\n#    property = DD_EdgeNegative_9\n#   [../]\n#   [./DD_EN_10]\n#    type = MaterialRealAux\n#    variable = DD_EN_10\n#    property = DD_EdgeNegative_10\n#   [../]\n#   [./DD_EN_11]\n#    type = MaterialRealAux\n#    variable = DD_EN_11\n#    property = DD_EdgeNegative_11\n#   [../]\n#   [./DD_EN_12]\n#    type = MaterialRealAux\n#    variable = DD_EN_12 \n#    property = DD_EdgeNegative_12\n#   [../]\n# []\n\n# [AuxVariables]\n#   [./DD_SP_01]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_02]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_03]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_04]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_05]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_06]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_07]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_08]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_09]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_10]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_11]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SP_12]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n# []\n\n\n# [AuxKernels]\n#   [./DD_SP_01]\n#    type = MaterialRealAux\n#    variable = DD_SP_01\n#    property = DD_ScrewPositive_1\n#   [../]\n#   [./DD_SP_02]\n#    type = MaterialRealAux\n#    variable = DD_SP_02\n#    property = DD_ScrewPositive_2\n#   [../]\n#   [./DD_SP_03]\n#    type = MaterialRealAux\n#    variable = DD_SP_03\n#    property = DD_ScrewPositive_3\n#   [../]\n#   [./DD_SP_04]\n#    type = MaterialRealAux\n#    variable = DD_SP_04\n#    property = DD_ScrewPositive_4\n#   [../]\n#   [./DD_SP_05]\n#    type = MaterialRealAux\n#    variable = DD_SP_05\n#    property = DD_ScrewPositive_5\n#   [../]\n#   [./DD_SP_06]\n#    type = MaterialRealAux\n#    variable = DD_SP_06\n#    property = DD_ScrewPositive_6\n#   [../]\n#   [./DD_SP_07]\n#    type = MaterialRealAux\n#    variable = DD_SP_07\n#    property = DD_ScrewPositive_7\n#   [../]\n#   [./DD_SP_08]\n#    type = MaterialRealAux\n#    variable = DD_SP_08\n#    property = DD_ScrewPositive_8\n#   [../]\n#   [./DD_SP_09]\n#    type = MaterialRealAux\n#    variable = DD_SP_09\n#    property = DD_ScrewPositive_9\n#   [../]\n#   [./DD_SP_10]\n#    type = MaterialRealAux\n#    variable = DD_SP_10 \n#    property = DD_ScrewPositive_10\n#   [../]\n#   [./DD_SP_11]\n#    type = MaterialRealAux\n#    variable = DD_SP_11 \n#    property = DD_ScrewPositive_11\n#   [../]\n#   [./DD_SP_12]\n#    type = MaterialRealAux\n#    variable = DD_SP_12\n#    property = DD_ScrewPositive_12\n#   [../]\n# []\n  \n\n# [AuxVariables]\n#   [./DD_SN_01]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_02]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_03]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_04]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_05]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_06]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_07]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_08]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_09]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_10]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_11]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n#   [./DD_SN_12]\n#    order = CONSTANT\n#    family = MONOMIAL\n#   [../]\n# []\n\n\n# [AuxKernels]\n#   [./DD_SN_01]\n#    type = MaterialRealAux\n#    variable = DD_SN_01\n#    property = DD_ScrewNegative_1\n#   [../]\n#   [./DD_SN_02]\n#    type = MaterialRealAux\n#    variable = DD_SN_02\n#    property = DD_ScrewNegative_2\n#   [../]\n#   [./DD_SN_03]\n#    type = MaterialRealAux\n#    variable = DD_SN_03\n#    property = DD_ScrewNegative_3\n#   [../]\n#   [./DD_SN_04]\n#    type = MaterialRealAux\n#    variable = DD_SN_04\n#    property = DD_ScrewNegative_4\n#   [../]\n#   [./DD_SN_05]\n#    type = MaterialRealAux\n#    variable = DD_SN_05\n#    property = DD_ScrewNegative_5\n#   [../]\n#   [./DD_SN_06]\n#    type = MaterialRealAux\n#    variable = DD_SN_06\n#    property = DD_ScrewNegative_6\n#   [../]\n#   [./DD_SN_07]\n#    type = MaterialRealAux\n#    variable = DD_SN_07\n#    property = DD_ScrewNegative_7\n#   [../]\n#   [./DD_SN_08]\n#    type = MaterialRealAux\n#    variable = DD_SN_08\n#    property = DD_ScrewNegative_8\n#   [../]\n#   [./DD_SN_09]\n#    type = MaterialRealAux\n#    variable = DD_SN_09\n#    property = DD_ScrewNegative_9\n#   [../]\n#   [./DD_SN_10]\n#    type = MaterialRealAux\n#    variable = DD_SN_10\n#    property = DD_ScrewNegative_10\n#   [../]\n#   [./DD_SN_11]\n#    type = MaterialRealAux\n#    variable = DD_SN_11\n#    property = DD_ScrewNegative_11\n#   [../]\n#   [./DD_SN_12]\n#    type = MaterialRealAux #ElementAverageValue\n#    variable = DD_SN_12\n#    property = DD_ScrewNegative_12\n#   [../]\n# []\n\n[AuxVariables]\n  [./shear_stress_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_01]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n\n[AuxKernels]\n  [./shear_stress_01]\n   type = MaterialStdVectorAux\n   variable = shear_stress_01\n   property = applied_shear_stress  \n   index = 0\n  [../]\n  [./back_stress_01]\n   type = MaterialStdVectorAux\n   variable = back_stress_01\n   property = back_stress\n   index = 0\n  [../]\n  [./shear_resistance_01]\n    type = MaterialStdVectorAux\n    variable = shear_resistance_01\n    property = slip_resistance  \n    index = 0\n  [../]\n  [./DD_mobile_01]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_01\n   property = dislocation_immobile\n   index = 0\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_02]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_02]\n   type = MaterialStdVectorAux\n   variable = shear_stress_02\n   property = applied_shear_stress  \n   index = 1\n  [../]\n[./back_stress_02]\n   type = MaterialStdVectorAux\n   variable = back_stress_02\n   property = back_stress\n   index = 1\n  [../]\n  [./shear_resistance_02]\n    type = MaterialStdVectorAux\n    variable = shear_resistance_02\n    property = slip_resistance  \n    index = 1\n  [../]\n[./DD_mobile_02]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_02\n   property = dislocation_immobile\n   index = 1\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_03]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_03]\n   type = MaterialStdVectorAux\n   variable = shear_stress_03\n   property = applied_shear_stress  \n   index = 2\n  [../]\n[./back_stress_03]\n   type = MaterialStdVectorAux\n   variable = back_stress_03\n   property = back_stress\n   index = 2\n  [../]\n  [./shear_resistance_03]\n    type = MaterialStdVectorAux\n    variable = shear_resistance_03\n    property = slip_resistance  \n    index = 2\n  [../]\n[./DD_mobile_03]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_03\n   property = dislocation_immobile\n   index = 2\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_04]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_04]\n   type = MaterialStdVectorAux\n   variable = shear_stress_04\n   property = applied_shear_stress  \n   index = 3\n  [../]\n[./back_stress_04]\n   type = MaterialStdVectorAux\n   variable = back_stress_04\n   property = back_stress\n   index = 3\n  [../]\n  [./shear_resistance_04]\n    type = MaterialStdVectorAux\n    variable = shear_resistance_04\n    property = slip_resistance  \n    index = 3\n  [../]\n[./DD_mobile_04]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_04\n   property = dislocation_immobile\n   index = 3\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_05]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_05]\n   type = MaterialStdVectorAux\n   variable = shear_stress_05\n   property = applied_shear_stress  \n   index = 4\n  [../]\n[./back_stress_05]\n   type = MaterialStdVectorAux\n   variable = back_stress_05\n   property = back_stress\n   index = 4\n  [../]\n  [./shear_resistance_05]\n    type = MaterialStdVectorAux\n    variable = shear_resistance_05\n    property = slip_resistance  \n    index = 4\n  [../]\n[./DD_mobile_05]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_05\n   property = dislocation_immobile\n   index = 4\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_06]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_06]\n   type = MaterialStdVectorAux\n   variable = shear_stress_06\n   property = applied_shear_stress  \n   index = 5\n  [../]\n[./back_stress_06]\n   type = MaterialStdVectorAux\n   variable = back_stress_06\n   property = back_stress\n   index = 5\n  [../]\n    [./shear_resistance_06]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_06\n      property = slip_resistance\n      index = 5\n    [../]\n[./DD_mobile_06]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_06\n   property = dislocation_immobile\n   index = 5\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_07]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_07]\n   type = MaterialStdVectorAux\n   variable = shear_stress_07\n   property = applied_shear_stress  \n   index = 6\n  [../]\n[./back_stress_07]\n   type = MaterialStdVectorAux\n   variable = back_stress_07\n   property = back_stress\n   index = 6\n  [../]\n    [./shear_resistance_07]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_07\n      property = slip_resistance\n      index = 6\n    [../]\n[./DD_mobile_07]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_07\n   property = dislocation_immobile\n   index = 6\n  [../]\n[]\n\n\n[AuxVariables]\n  [./shear_stress_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_08]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_08]\n   type = MaterialStdVectorAux\n   variable = shear_stress_08\n   property = applied_shear_stress  \n   index = 7\n  [../]\n[./back_stress_08]\n   type = MaterialStdVectorAux\n   variable = back_stress_08\n   property = back_stress\n   index = 7\n  [../]\n    [./shear_resistance_08]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_08\n      property = slip_resistance\n      index = 7\n    [../]\n[./DD_mobile_08]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_08\n   property = dislocation_immobile\n   index = 7\n  [../]\n[]\n\n\n\n[AuxVariables]\n  [./shear_stress_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_09]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_09]\n   type = MaterialStdVectorAux\n   variable = shear_stress_09\n   property = applied_shear_stress  \n   index = 8\n  [../]\n[./back_stress_09]\n   type = MaterialStdVectorAux\n   variable = back_stress_09\n   property = back_stress\n   index = 8\n  [../]\n    [./shear_resistance_09]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_09\n      property = slip_resistance\n      index = 8\n    [../]\n[./DD_mobile_09]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_09\n   property = dislocation_immobile\n   index = 8\n  [../]\n[]\n\n\n[AuxVariables]\n  [./shear_stress_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_10]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_10]\n   type = MaterialStdVectorAux\n   variable = shear_stress_10\n   property = applied_shear_stress  \n   index = 9\n  [../]\n[./back_stress_10]\n   type = MaterialStdVectorAux\n   variable = back_stress_10\n   property = back_stress\n   index = 9\n  [../]\n    [./shear_resistance_10]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_10\n      property = slip_resistance\n      index = 9\n    [../]\n[./DD_mobile_10]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_10\n   property = dislocation_immobile\n   index = 9\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_11]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_11]\n   type = MaterialStdVectorAux\n   variable = shear_stress_11\n   property = applied_shear_stress  \n   index = 10\n  [../]\n[./back_stress_11]\n   type = MaterialStdVectorAux\n   variable = back_stress_11\n   property = back_stress\n   index = 10\n  [../]\n    [./shear_resistance_11]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_11\n      property = slip_resistance\n      index = 10\n    [../]\n[./DD_mobile_11]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_11\n   property = dislocation_immobile\n   index = 10\n  [../]\n[]\n\n[AuxVariables]\n  [./shear_stress_12]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./shear_resistance_12]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./back_stress_12]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./DD_mobile_12]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./shear_stress_12]\n   type = MaterialStdVectorAux\n   variable = shear_stress_12\n   property = applied_shear_stress  \n   index = 11\n  [../]\n[./back_stress_12]\n   type = MaterialStdVectorAux\n   variable = back_stress_12\n   property = back_stress\n   index = 11\n  [../]\n    [./shear_resistance_12]\n      type = MaterialStdVectorAux\n      variable = shear_resistance_12\n      property = slip_resistance\n      index = 11\n    [../]\n[./DD_mobile_12]\n   type = MaterialStdVectorAux\n   variable = DD_mobile_12\n   property = dislocation_immobile\n   index = 11\n  [../]\n[]\n\n[Materials]\n  [./compute_stress_wrapper]\n    type = ComputeLagrangianWrappedStress\n  [../]\n[]\n\n[AuxVariables]\n  [./GND_density_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./GND_density_12]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./GND_density_01]\n    type = MaterialStdVectorAux\n    variable = GND_density_01\n    property = kappa  \n    index = 0\n  [../]\n[./GND_density_02]\n    type = MaterialStdVectorAux\n    variable = GND_density_02\n    property = kappa  \n    index = 1\n  [../]\n[./GND_density_03]\n    type = MaterialStdVectorAux\n    variable = GND_density_03\n    property = kappa  \n    index = 2\n  [../]\n[./GND_density_04]\n    type = MaterialStdVectorAux\n    variable = GND_density_04\n    property = kappa  \n    index = 3\n  [../]\n[./GND_density_05]\n    type = MaterialStdVectorAux\n    variable = GND_density_05\n    property = kappa  \n    index = 4\n  [../]\n[./GND_density_06]\n    type = MaterialStdVectorAux\n    variable = GND_density_06\n    property = kappa  \n    index = 5\n  [../]\n[./GND_density_07]\n    type = MaterialStdVectorAux\n    variable = GND_density_07\n    property = kappa  \n    index = 6\n  [../]\n[./GND_density_08]\n    type = MaterialStdVectorAux\n    variable = GND_density_08\n    property = kappa  \n    index = 7\n  [../]\n[./GND_density_09]\n    type = MaterialStdVectorAux\n    variable = GND_density_09\n    property = kappa  \n    index = 8\n  [../]\n[./GND_density_10]\n    type = MaterialStdVectorAux\n    variable = GND_density_10\n    property = kappa  \n    index = 9\n  [../]\n[./GND_density_11]\n    type = MaterialStdVectorAux\n    variable = GND_density_11\n    property = kappa  \n    index = 10\n  [../]\n[./GND_density_12]\n    type = MaterialStdVectorAux\n    variable = GND_density_12\n    property = kappa  \n    index = 11\n  [../]\n[]\n\n[AuxVariables]\n  [./slip_increment_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./slip_increment_12]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./slip_increment_01]\n    type = MaterialStdVectorAux\n    variable = slip_increment_01\n    property = slip_increment  \n    index = 0\n  [../]\n[./slip_increment_02]\n    type = MaterialStdVectorAux\n    variable = slip_increment_02\n    property = slip_increment  \n    index = 1\n  [../]\n[./slip_increment_03]\n    type = MaterialStdVectorAux\n    variable = slip_increment_03\n    property = slip_increment  \n    index = 2\n  [../]\n[./slip_increment_04]\n    type = MaterialStdVectorAux\n    variable = slip_increment_04\n    property = slip_increment  \n    index = 3\n  [../]\n[./slip_increment_05]\n    type = MaterialStdVectorAux\n    variable = slip_increment_05\n    property = slip_increment  \n    index = 4\n  [../]\n[./slip_increment_06]\n    type = MaterialStdVectorAux\n    variable = slip_increment_06\n    property = slip_increment  \n    index = 5\n  [../]\n[./slip_increment_07]\n    type = MaterialStdVectorAux\n    variable = slip_increment_07\n    property = slip_increment  \n    index = 6\n  [../]\n[./slip_increment_08]\n    type = MaterialStdVectorAux\n    variable = slip_increment_08\n    property = slip_increment  \n    index = 7\n  [../]\n[./slip_increment_09]\n    type = MaterialStdVectorAux\n    variable = slip_increment_09\n    property = slip_increment  \n    index = 8\n  [../]\n[./slip_increment_10]\n    type = MaterialStdVectorAux\n    variable = slip_increment_10\n    property = slip_increment  \n    index = 9\n  [../]\n[./slip_increment_11]\n    type = MaterialStdVectorAux\n    variable = slip_increment_11\n    property = slip_increment  \n    index = 10\n  [../]\n[./slip_increment_12]\n    type = MaterialStdVectorAux\n    variable = slip_increment_12\n    property = slip_increment  \n    index = 11\n  [../]\n[]\n\n[AuxVariables]\n  [./dde_vel_01]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_02]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_03]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_04]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_05]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_06]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_07]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_08]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_09]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_10]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_11]\n   order = CONSTANT\n   family = MONOMIAL\n  [../]\n  [./dde_vel_12]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n[]\n\n[AuxKernels]\n[./dde_vel_01]\n    type = MaterialStdVectorAux\n    variable = dde_vel_01\n    property = dislo_velocity_edge  \n    index = 0\n  [../]\n[./dde_vel_02]\n    type = MaterialStdVectorAux\n    variable = dde_vel_02\n    property = dislo_velocity_edge  \n    index = 1\n  [../]\n[./dde_vel_03]\n    type = MaterialStdVectorAux\n    variable = dde_vel_03\n    property = dislo_velocity_edge  \n    index = 2\n  [../]\n[./dde_vel_04]\n    type = MaterialStdVectorAux\n    variable = dde_vel_04\n    property = dislo_velocity_edge  \n    index = 3\n  [../]\n[./dde_vel_05]\n    type = MaterialStdVectorAux\n    variable = dde_vel_05\n    property = dislo_velocity_edge  \n    index = 4\n  [../]\n[./dde_vel_06]\n    type = MaterialStdVectorAux\n    variable = dde_vel_06\n    property = dislo_velocity_edge  \n    index = 5\n  [../]\n[./dde_vel_07]\n    type = MaterialStdVectorAux\n    variable = dde_vel_07\n    property = dislo_velocity_edge  \n    index = 6\n  [../]\n[./dde_vel_08]\n    type = MaterialStdVectorAux\n    variable = dde_vel_08\n    property = dislo_velocity_edge  \n    index = 7\n  [../]\n[./dde_vel_09]\n    type = MaterialStdVectorAux\n    variable = dde_vel_09\n    property = dislo_velocity_edge  \n    index = 8\n  [../]\n[./dde_vel_10]\n    type = MaterialStdVectorAux\n    variable = dde_vel_10\n    property = dislo_velocity_edge  \n    index = 9\n  [../]\n[./dde_vel_11]\n    type = MaterialStdVectorAux\n    variable = dde_vel_11\n    property = dislo_velocity_edge  \n    index = 10\n  [../]\n[./dde_vel_12]\n    type = MaterialStdVectorAux\n    variable = dde_vel_12\n    property = dislo_velocity_edge  \n    index = 11\n  [../]\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11031841",
                          "updatedAt": "2024-10-23T16:39:50Z",
                          "publishedAt": "2024-10-23T16:39:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "bmurgas-LANL"
                  },
                  "bodyText": "Hi @GiudGiud,\nI have been trying to find the problem with the Material Properties in the InterfaceDiffusion kernel.\nThe values were set to zero because I used the wrong values when initializing the variables in DiscoFluxCPStressUpdate::initQpStatefulProperties().\nI initialize the variables with the correct values and I can read them in the ConservativeAdvection and InterfaceDiffusion kernels. However, the Material Properties are evolving every time step in the crystal plasticity kernel, when reading the updated values I get the correct values in the ConservativeAdvection kernel but I keep getting the initial values in the InterfaceDiffusion.\nI suspect this error is coming from the fact that Moose creates three copies of the Material Properties (https://mooseframework.inl.gov/syntax/Materials/index.html). After reading this, I started to check the memory address of the same variable in the three kernels: DiscoFluxCPStressUpdate, ConservativeAdvection and InterfaceDiffusion.\nThis is the result from lldb:\nIn crystal plasticity\n(lldb) frame var -L _dislo_velocity_edge\n0x00007fd001ec6470: (MaterialProperty<std::vector<double> > &) _dislo_velocity_edge = 0x000060000123c090: {\n0x000060000123c090:   MaterialPropertyBase<std::__1::vector<double, std::__1::allocator<double> >, false> = {\n0x000060000123c090:     PropertyValue = {\n0x000060000123c098:       _id = 23\n    }\n0x000060000123c0a0:     _value = {\n0x000060000123c0a0:       _data_ptr = size=12 {\n0x000060000123c0a0:         pointer = 0x00006000027715f8 size=12\n      }\n0x000060000123c0a8:       _data = 0x00006000027715f8 size=12\n0x000060000123c0b0:       _size = 8\n0x000060000123c0b4:       _allocated_size = 8\n    }\n  }\n}\n\nIn interfacediffusiondislocation\n(lldb) frame var -L _dislo_velocity_CP_edge\n0x00007fd001f81ff0: (const MaterialProperty<std::vector<double> > &) _dislo_velocity_CP_edge = 0x000060000123e970: {\n0x000060000123e970:   MaterialPropertyBase<std::__1::vector<double, std::__1::allocator<double> >, false> = {\n0x000060000123e970:     PropertyValue = {\n0x000060000123e978:       _id = 23\n    }\n0x000060000123e980:     _value = {\n0x000060000123e980:       _data_ptr = size=12 {\n0x000060000123e980:         pointer = 0x0000600003765188 size=12\n      }\n0x000060000123e988:       _data = 0x0000600003765188 size=12\n0x000060000123e990:       _size = 4\n0x000060000123e994:       _allocated_size = 4\n    }\n  }\n}\n\nAnd in conservativeadvectiondislocation\n(lldb) frame var -L _dislo_velocity_CP_edge\n0x00007fd001f57e30: (const MaterialProperty<std::vector<double> > &) _dislo_velocity_CP_edge = 0x000060000123c090: {\n0x000060000123c090:   MaterialPropertyBase<std::__1::vector<double, std::__1::allocator<double> >, false> = {\n0x000060000123c090:     PropertyValue = {\n0x000060000123c098:       _id = 23\n    }\n0x000060000123c0a0:     _value = {\n0x000060000123c0a0:       _data_ptr = size=12 {\n0x000060000123c0a0:         pointer = 0x00006000027715f8 size=12\n      }\n0x000060000123c0a8:       _data = 0x00006000027715f8 size=12\n0x000060000123c0b0:       _size = 8\n0x000060000123c0b4:       _allocated_size = 8\n    }\n  }\n}\n\nAs you can see the memory address of the variable in the crystal plasticity (DiscoFluxCPStressUpdate) and the advection kernel (ConservativeAdvection) is the same. And the address of the interface diffusion kernel is different. Does it means that in the interface kernel system we are using the element face material properties?\nI wonder is there is an issue with Moose when the material properties are being updated in the crystal plasticity model and the elemental material variables don't update.\nI found this discussion #19062 and found it helpful. I'll try to create a Material Object to see if when calling the function copmputeQpProperties both the element and element face material properties are updated with the correct values.\nThank you for your help.\nBrayan",
                  "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11115620",
                  "updatedAt": "2024-10-31T19:35:13Z",
                  "publishedAt": "2024-10-31T19:35:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hi\nsorry for the delay. I ll get to this this weekend. I tried to find a resource to help earlier but failed.",
                          "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11121773",
                          "updatedAt": "2024-11-01T12:32:57Z",
                          "publishedAt": "2024-11-01T12:32:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I can't run the input file, I need the px3_bar_hex8_cl16e-3.e mesh and the px3-bar-sp10-sp01.inp data file.\nI ll make a MWE to see if I can reproduce this without those",
                          "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11131847",
                          "updatedAt": "2024-11-02T23:45:27Z",
                          "publishedAt": "2024-11-02T23:45:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok I made do with sxori-0-0-0.inp instead of px3-bar-sp10-sp01.inp.\nI am not getting uniformly 0 values on my case. So it could have something to do with your mesh. Is it possible for you to share that with me?\nAlternatively, maybe I am not checking the materials the same way as you. How did you determine slip_resistance /... were uniformly 0 in the interface kernels ?\n\nAnd the address of the interface diffusion kernel is different. Does it means that in the interface kernel system we are using the element face material properties?\n\nYes that is expected. The interface kernels request \"boundary material data\" from their inheritance on TwoMaterialPropertyInterface.\nInputParameters\nTwoMaterialPropertyInterface::validParams()\n{\n\n  // Objects inheriting from TwoMaterialPropertyInterface rely on Boundary MaterialData\n  InputParameters params = MaterialPropertyInterface::validParams();\n  params.set<Moose::MaterialDataType>(\"_material_data_type\") = Moose::BOUNDARY_MATERIAL_DATA;\n  return params;\n}\n\nWhich under the hood maps to boundary material data\nMaterialData &\nFEProblemBase::getMaterialData(Moose::MaterialDataType type, const THREAD_ID tid)\n{\n  switch (type)\n  {\n    case Moose::BLOCK_MATERIAL_DATA:\n      return _material_props.getMaterialData(tid);\n    case Moose::NEIGHBOR_MATERIAL_DATA:\n      return _neighbor_material_props.getMaterialData(tid);\n    case Moose::BOUNDARY_MATERIAL_DATA:\n    case Moose::FACE_MATERIAL_DATA:\n    case Moose::INTERFACE_MATERIAL_DATA:\n      return _bnd_material_props.getMaterialData(tid);\n  }\n\nSo it's a different address than the kernels which use block material data, which is from regular materials.",
                          "url": "https://github.com/idaholab/moose/discussions/28908#discussioncomment-11131965",
                          "updatedAt": "2024-11-03T00:45:27Z",
                          "publishedAt": "2024-11-03T00:44:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "make error: fatal error: libmesh/mesh_netgen_interface.h: No such file or directory",
          "author": {
            "login": "frankwugeo"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n I have consulted the Posting Guidelines.\n I have searched the Discussions Forum and MOOSE Framework Troubleshooting and have not found what I was looking for\n Q&A Getting Started is the most appropriate category for my question (trouble installing, beginner user, ...)\n\nIssue or question about MOOSE\nHi all,\nI am installing MOOSE and RACCOON. After building MOOSE, then clone RACCOON, and run below to get the submodule.\ngit submodule update --init --recursive\n\nThen I try to compile RACCOON using make, but got the following error.\nI also checked and found 'mesh_netgen_interface.h' file in the right directory. But for the 'XYZDelaunayGenerator' here, I did not find it in a successfully built MOOSE file on another pc of mine.\nin /projects/raccoon/moose/framework/src/meshgenerators\n\nMany thanks for any help.\nBest\n(Optional) code in question / simulation log / errors\nIn file included from /home/user/projects/raccoon/moose/framework/build/unity_src/meshgenerators_Unity.C:85:\n/home/user/projects/raccoon/moose/framework/src/meshgenerators/XYZDelaunayGenerator.C:19:10: fatal error: libmesh/mesh_netgen_interface.h: No such file or directory\n   19 | #include \"libmesh/mesh_netgen_interface.h\"\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ncompilation terminated.\nmake: *** [/home/user/projects/raccoon/moose/framework/build.mk:150: /home/user/projects/raccoon/moose/framework/build/unity_src/meshgenerators_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1\nEncountering Errors? Please include diagnostic output\nNo response",
          "url": "https://github.com/idaholab/moose/discussions/28987",
          "updatedAt": "2024-11-02T12:30:40Z",
          "publishedAt": "2024-11-01T15:27:25Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n\nBut for the 'XYZDelaunayGenerator' here, I did not find it in a successfully built MOOSE file on another pc of mine.\n\nIt was added only a few month ago so maybe your other version of MOOSE did not have it.\nMost likely, your version of libmesh is not up to date.\nHow are you installing moose? Are you using conda to get moose-petsc/libmesh? Or are you running the scripts to get petsc/libmesh?",
                  "url": "https://github.com/idaholab/moose/discussions/28987#discussioncomment-11124302",
                  "updatedAt": "2024-11-01T16:58:09Z",
                  "publishedAt": "2024-11-01T16:58:08Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Quick and dirty potential solution could be (if you are in a hurry)\ncd ~/projects/racoon/moose/framework\nrm src/meshgenerators/XYZDelaunayGenerator.C\nrm include/meshgenerators/XYZDelaunayGenerator.h\n\nthen build",
                          "url": "https://github.com/idaholab/moose/discussions/28987#discussioncomment-11124315",
                          "updatedAt": "2024-11-01T16:59:22Z",
                          "publishedAt": "2024-11-01T16:59:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "frankwugeo"
                          },
                          "bodyText": "Thanks for the reply.\n\nMost likely, your version of libmesh is not up to date.\n\nI run the scripts again to get petsc/libmesh.\nAnd get the error when update libmesh:\n/usr/include/features-time64.h:21:10: fatal error: bits/timesize.h: No such file or directory\n   21 | #include <bits/timesize.h>\n      |          ^~~~~~~~~~~~~~~~~\ncompilation terminated.\n\nFor the way that remove XYZDelaunayGenerator and build, another error related to libmesh pops up:\nIn file included from /home/user/projects/raccoon/moose/framework/build/unity_src/postprocessors_Unity.C:99:\n/home/user/projects/raccoon/moose/framework/src/postprocessors/Residual.C: In member function 'virtual libMesh::Real Residual::getValue() const':\n/home/user/projects/raccoon/moose/framework/src/postprocessors/Residual.C:49:5: error: 'LibmeshPetscCall' was not declared in this scope\n   49 |     LibmeshPetscCall(SNESGetFunctionNorm(snes, &norm));\n      |     ^~~~~~~~~~~~~~~~",
                          "url": "https://github.com/idaholab/moose/discussions/28987#discussioncomment-11127734",
                          "updatedAt": "2024-11-02T06:52:42Z",
                          "publishedAt": "2024-11-02T06:52:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The second error means you can't move forward without updating libmesh.\nThe first error is a missing system library. This is odd. You could just add it manually, it s a very simple one.\nYou are compiling on Linux right?",
                          "url": "https://github.com/idaholab/moose/discussions/28987#discussioncomment-11129067",
                          "updatedAt": "2024-11-02T12:30:41Z",
                          "publishedAt": "2024-11-02T12:30:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unable to find function",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "Hey, a quick question. I have this auxkernel block that I want to implement a function that works as the comment stated.\n[temperature]\n      type = FunctionAux\n      variable = temperature\n      function = 't < 1 ? 600 : 600' # temperature jumps to 600 at the start and stays constant\n      execute_on = timestep_begin\n    []\n\nBut I get this error\nUnable to find function t < 1 ? 600: 600\n\nHow do I resolve this issue?",
          "url": "https://github.com/idaholab/moose/discussions/28991",
          "updatedAt": "2024-11-01T22:04:35Z",
          "publishedAt": "2024-11-01T20:43:02Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can't specify a parsed function directly in a function parameter\nYou have to create a ParsedFunction in the Functions block",
                  "url": "https://github.com/idaholab/moose/discussions/28991#discussioncomment-11125922",
                  "updatedAt": "2024-11-01T20:56:52Z",
                  "publishedAt": "2024-11-01T20:56:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "I modifed it this way\n[Functions]\n  [temperature]\n    type = ParsedFunction\n    value = 't < 1 ? 300 : 300' # temperature jumps to 600 at the start and stays constant\n    execute_on = 'timestep_begin'\n  []\n[] \n\nAnd I got an error in the parsed function\nERROR: FunctionParser is unable to parse expression: t < 1 ? 300 : 300\nSyntax error: Operator expected\n[0] /home/emmanuel324/projects/moose/scripts/../libmesh/installed/include/libmesh/parsed_function.h, line 564, compiled Aug 12 2024 at 18:26:31\n:\nERROR: FunctionParser is unable to parse expression: t < 1 ? 300 : 300\nSyntax error: Operator expected\n[1] /home/emmanuel324/projects/moose/scripts/../libmesh/installed/include/libmesh/parsed_function.h, line 564, compiled Aug 12 2024 at 18:26:31",
                          "url": "https://github.com/idaholab/moose/discussions/28991#discussioncomment-11126107",
                          "updatedAt": "2024-11-01T21:23:18Z",
                          "publishedAt": "2024-11-01T21:23:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You need to set the parameter use_xyzt iirc\nAlso the if syntax is wrong. You're writing it like c++ but if should be\nif(a, b , c)\nWith a the condition, b the true, and c the false",
                          "url": "https://github.com/idaholab/moose/discussions/28991#discussioncomment-11126147",
                          "updatedAt": "2024-11-01T21:28:40Z",
                          "publishedAt": "2024-11-01T21:28:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "I can modify the if statement as:\nvalue = 'if(t < 1, 300, 300)' # temperature jumps to 300 at t = 1 and stays constant\nBut I do not understand what you mean by\nYou need to set the parameter use_xyzt iirc",
                          "url": "https://github.com/idaholab/moose/discussions/28991#discussioncomment-11126174",
                          "updatedAt": "2024-11-01T21:33:35Z",
                          "publishedAt": "2024-11-01T21:33:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "That's a parameter that is used for parsed expressions. ParsedFunction might not be using it",
                          "url": "https://github.com/idaholab/moose/discussions/28991#discussioncomment-11126194",
                          "updatedAt": "2024-11-01T21:37:18Z",
                          "publishedAt": "2024-11-01T21:37:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "And how do I set that parameter if you do not mind",
                          "url": "https://github.com/idaholab/moose/discussions/28991#discussioncomment-11126329",
                          "updatedAt": "2024-11-01T22:00:21Z",
                          "publishedAt": "2024-11-01T22:00:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "like this\nuse_xyzt=true\n\nbut I just checked and ParsedFunction does not use this parameter. It's for ParsedMaterial",
                          "url": "https://github.com/idaholab/moose/discussions/28991#discussioncomment-11126347",
                          "updatedAt": "2024-11-01T22:04:36Z",
                          "publishedAt": "2024-11-01T22:04:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Access the coordinates of an element and neighbor inside an interface kernel",
          "author": {
            "login": "ambehnam"
          },
          "bodyText": "Hi there. I need to access the coordinates of the element and neighbor inside an interface kernel to compute a penalty term.\nThis is my code:\n  const libMesh::Node* const* curr_node = _var.currentElem()->get_nodes();\n  const libMesh::Node* const* neigh_node = _var.neighbor()->get_nodes();\n  Real dv = curr_node[0]->_coords[0];\n\nand this is the error I get:\nerror: \u2018double libMesh::TypeVector<double>::_coords [3]\u2019 is protected within this context\n   61 |   Real dv = curr_node[0]->_coords[0];\n\nCan anyone help me fix this issue please?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/21510",
          "updatedAt": "2024-11-01T21:32:40Z",
          "publishedAt": "2022-07-05T20:16:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nYou may not access _coords directly from a Node.\nAs you may see on the doxygen\nhttps://libmesh.github.io/doxygen/classlibMesh_1_1Node.html\nand as the compiler tells you, it's protected.\nYou need to access using the () operator\nhttps://libmesh.github.io/doxygen/classlibMesh_1_1Node.html#a3568df25f9c0db5decbcaa9d42420439\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21510#discussioncomment-3088341",
                  "updatedAt": "2022-07-05T23:23:57Z",
                  "publishedAt": "2022-07-05T23:23:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ambehnam"
                          },
                          "bodyText": "Thanks a lot!\nAmir",
                          "url": "https://github.com/idaholab/moose/discussions/21510#discussioncomment-3092775",
                          "updatedAt": "2022-07-06T14:01:30Z",
                          "publishedAt": "2022-07-06T14:01:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "@GiudGiud Wanted to follow up on this. How do you access the () operator on a node to get coordinates? _current_node() does not work. Will _q_point work if it's a nodal kernel?",
                          "url": "https://github.com/idaholab/moose/discussions/21510#discussioncomment-11115045",
                          "updatedAt": "2024-10-31T18:11:00Z",
                          "publishedAt": "2024-10-31T18:10:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "_current_node(0) should work? to get you the X coordinate\nIf q_point works for a nodal kernel it s out of trying to make every kernel look the same. But current_node is better",
                          "url": "https://github.com/idaholab/moose/discussions/21510#discussioncomment-11115082",
                          "updatedAt": "2024-10-31T18:17:46Z",
                          "publishedAt": "2024-10-31T18:17:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Not working in my AuxKernel:\nerror: expression cannot be used as a function\n  114 |   Real x = _current_node(0);\n      |            ~~~~~~~~~~~~~^~~",
                          "url": "https://github.com/idaholab/moose/discussions/21510#discussioncomment-11115366",
                          "updatedAt": "2024-10-31T18:57:25Z",
                          "publishedAt": "2024-10-31T18:57:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "(*_current_node)(0)\ncurrent node is a reference to a pointer, smh\n  /// current node being processed\n  const Node * const & _current_node;",
                          "url": "https://github.com/idaholab/moose/discussions/21510#discussioncomment-11115419",
                          "updatedAt": "2024-10-31T19:01:53Z",
                          "publishedAt": "2024-10-31T19:01:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "ah, there we go. So I need to dereference to use operator (*_current_node)(0) but other methods I can use directly _current_node->id()",
                          "url": "https://github.com/idaholab/moose/discussions/21510#discussioncomment-11115526",
                          "updatedAt": "2024-10-31T19:17:49Z",
                          "publishedAt": "2024-10-31T19:17:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "@GiudGiud what if _current_node isn't available? For instance I'm looping over nodes using _mesh.getLocalNodeRange() in my AuxKernel's initial setup.",
                          "url": "https://github.com/idaholab/moose/discussions/21510#discussioncomment-11126004",
                          "updatedAt": "2024-11-01T21:06:51Z",
                          "publishedAt": "2024-11-01T21:06:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "_current_node should be available in all auxkernels\nSee functionAux for an example of using it",
                          "url": "https://github.com/idaholab/moose/discussions/21510#discussioncomment-11126160",
                          "updatedAt": "2024-11-01T21:35:54Z",
                          "publishedAt": "2024-11-01T21:31:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Or do you mean you nested a loop on all local nodes within an auxkernel ?\nOk that s your situation. I misread your initial post\nIn that case you can use the node from the loop? If you only have an id for the node in the loop, you can retrieve the node from the mesh with nodePtr (or similar from a meshBase)",
                          "url": "https://github.com/idaholab/moose/discussions/21510#discussioncomment-11126167",
                          "updatedAt": "2024-11-01T21:36:34Z",
                          "publishedAt": "2024-11-01T21:32:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MOOSE performance being significantly slower compared to other programs",
          "author": {
            "login": "yanchong-eden"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello there!\nWe are developing a Multiphysics application based on MOOSE, but our tests indicate that MOOSE is significantly slower than other programs in various aspects. We've compared:\n\nThe dynamic poroelastic problem between implementations on MOOSE and FEniCS;\nIsothermal porous flow problem between MOOSE and Tough React Mech (TRM), as well as a bare FE implementation on PETSc;\nThe smeared cracking model in MOOSE against a similar implementation in DefMod (PoroElastoDynamic model based on PETSc).\n\nAll these scenarios show MOOSE being at least x10 slower than the other programs. We've already performed some profiling to optimize the input file, but the order of magnitude difference in performance persists. After some searching, we\u2019ve found some tests done by others too regarding performance differences. For example, a slide from source also suggests that MOOSE is slower compared to many other toolsets, including libMesh on which it is based:\n\nWe enjoy using MOOSE, and appreciate the effort for building this great program, but are also quite confused about why the performance is so different (a few times slower make sense but here is >x10...). We would greatly appreciate any feedback on how to improve the performance!\nDetailed Comparisons:\n1.\tDynamic poroelastic problem\nThis is an application we're developing based on MOOSE, benchmarked against a case on the legacy FEniCS (https://www.sciencedirect.com/science/article/abs/pii/S0045782523005108?via%3Dihub). Both cases use a grid of 500,000 nodes, 2D, with 2,500,000 DoF. Running them in the same environment yields:\n\n\n\n# Nodes\n# CPU\nFEniCS (sec/timestep)\nMOOSE development (sec/timestep)\nSpeed Difference\n\n\n\n\n500K\n1\n~10\n~200\nx20\n\n\n\nWe see more than x10 slower performance on MOOSE compared to the legacy version of FEniCS.\n2.\tThe isothermal porous flow problem\nWe tested the isothermal porous flow problem performance between MOOSE and TRM:\n\n\n\n# Nodes\n# CPU\nTRM (sec/timestep)\nMOOSE (sec/timestep)\nSpeed Difference\n\n\n\n\n214K\n4\n1.2\n40\nx33.3\n\n\n28K\n4\n0.2\n3.9\nx19.5\n\n\n\nAs well as the comparison between MOOSE and a bare PETSc finite element implementation:\n\n\n\n# Nodes\n# CPU\nBare PETSc (sec/NR iteration)\nMOOSE (sec/NR iteration)\nSpeed Difference\n\n\n\n\n214K\n4\n0.21\n10\nx47.6\n\n\n28K\n4\n0.025\n0.62\nx24.8\n\n\n\nIn both comparison MOOSE is >x10, if not more, slower than the other programs.\n3.\tThe smeared cracking model (SCM)\nWe also compared a 2D problem using the smeared cracking model on MOOSE with DefMOD (https://doi.org/10.56952/ARMA-2023-0493). Both cases use explicit solvers (central difference in MOOSE). The performance difference is again more than x10, if not x100. Note that the performance on MOOSE here is already optimized on some degree based on perfgraphoutput:\n\n\n\n# Nodes\n# CPU\nDefMod (sec/timestep)\nMOOSE  SCM (sec/timestep)\nSpeed Difference\n\n\n\n\n50K\n1\n0.0035\n1.5\nx428.6\n\n\n50K\n4\n0.0014\n0.64\nx457\n\n\n13K\n1\n0.00063\n0.3\nx476.2\n\n\n\nEven when we change the problem to pure elastic, MOOSE speed only increases by a factor of ~2, which still doesn't close the significant performance gap. We've performed scaling tests for the MOOSE smeared cracking model, and the performance increase is linear as we increase the number of nodes. All these tests were done for 50 timesteps.\n\nWe've also performed profiling using both PerfGraphOutput and oprof. The current performance is achieved by reducing auxvariables and output from smeared cracking models so that NonlinearSystemBase::Kernels take up most of the time rather than AuxiliarySystem. When we perform oprof profiling, a significant amount of time is consumed by something labeled \"unknown\", which doesn't seem helpful.\n\n\nWe would greatly appreciate any insights or suggestions on how to improve MOOSE's performance for these types of problems. If additional information about our test configurations or profiling results would be helpful, please let us know.\nMOOSE Environment:\nThe environment we used for tests 1 and 3 is on Windows Subsystem of Linux 2 (WSL2). The machine is equipped with I9-13900H CPU and 32 Gb memory. We achieved a similar performance on M3 MacBook pro.\nPart of the output from Diagnostic.sh showing compilers and environment versions:\nCompiler(s) (CC CXX FC F77 F90):\nCC=/home/ycli/miniforge/envs/moose/bin/mpicc\nCC -show:\nx86_64-conda-linux-gnu-cc -I/home/ycli/miniforge/envs/moose/include -I/home/ycli/miniforge/envs/moose/include -L/home/ycli/miniforge/envs/moose/lib -Wl,-rpath,/home/ycli/miniforge/envs/moose/lib -I/home/ycli/miniforge/envs/moose/include -L/home/ycli/miniforge/envs/moose/lib -Wl,-rpath -Wl,/home/ycli/miniforge/envs/moose/lib -Wl,--enable-new-dtags -lmpi\nCC version:     x86_64-conda-linux-gnu-cc (conda-forge gcc 10.4.0-19) 10.4.0\nCXX=/home/ycli/miniforge/envs/moose/bin/mpicxx\nCXX -show:\nx86_64-conda-linux-gnu-c++ -I/home/ycli/miniforge/envs/moose/include -I/home/ycli/miniforge/envs/moose/include -L/home/ycli/miniforge/envs/moose/lib -Wl,-rpath,/home/ycli/miniforge/envs/moose/lib -I/home/ycli/miniforge/envs/moose/include -L/home/ycli/miniforge/envs/moose/lib -lmpicxx -Wl,-rpath -Wl,/home/ycli/miniforge/envs/moose/lib -Wl,--enable-new-dtags -lmpi\nCXX version:    x86_64-conda-linux-gnu-c++ (conda-forge gcc 10.4.0-19) 10.4.0\nFC=/home/ycli/miniforge/envs/moose/bin/mpif90\nFC -show:\nx86_64-conda-linux-gnu-gfortran -I/home/ycli/miniforge/envs/moose/include -fallow-argument-mismatch -L/home/ycli/miniforge/envs/moose/lib -Wl,-rpath,/home/ycli/miniforge/envs/moose/lib -I/home/ycli/miniforge/envs/moose/include -I/home/ycli/miniforge/envs/moose/include -L/home/ycli/miniforge/envs/moose/lib -lmpifort -Wl,-rpath -Wl,/home/ycli/miniforge/envs/moose/lib -Wl,--enable-new-dtags -lmpi\nFC version:     GNU Fortran (conda-forge gcc 10.4.0-19) 10.4.0\nF77=/home/ycli/miniforge/envs/moose/bin/mpif77\nF77 -show:\nx86_64-conda-linux-gnu-gfortran -I/home/ycli/miniforge/envs/moose/include -fallow-argument-mismatch -L/home/ycli/miniforge/envs/moose/lib -Wl,-rpath,/home/ycli/miniforge/envs/moose/lib -I/home/ycli/miniforge/envs/moose/include -I/home/ycli/miniforge/envs/moose/include -L/home/ycli/miniforge/envs/moose/lib -lmpifort -Wl,-rpath -Wl,/home/ycli/miniforge/envs/moose/lib -Wl,--enable-new-dtags -lmpi\nF77 version:    GNU Fortran (conda-forge gcc 10.4.0-19) 10.4.0\nF90=/home/ycli/miniforge/envs/moose/bin/mpif90\nF90 -show:\nx86_64-conda-linux-gnu-gfortran -I/home/ycli/miniforge/envs/moose/include -fallow-argument-mismatch -L/home/ycli/miniforge/envs/moose/lib -Wl,-rpath,/home/ycli/miniforge/envs/moose/lib -I/home/ycli/miniforge/envs/moose/include -I/home/ycli/miniforge/envs/moose/include -L/home/ycli/miniforge/envs/moose/lib -lmpifort -Wl,-rpath -Wl,/home/ycli/miniforge/envs/moose/lib -Wl,--enable-new-dtags -lmpi\nF90 version:    GNU Fortran (conda-forge gcc 10.4.0-19) 10.4.0\n##################################################################################################\nCONDA MOOSE Packages\nmoose-dev                 2024.05.13              build_0    https://conda.software.inl.gov/public\nmoose-libmesh             2024.05.05              build_0    https://conda.software.inl.gov/public\nmoose-libmesh-vtk         9.2.6                   build_9    https://conda.software.inl.gov/public\nmoose-mpich               4.0.2                  build_16    https://conda.software.inl.gov/public\nmoose-peacock             2023.04.11           hb6770a3_0    https://conda.software.inl.gov/public\nmoose-petsc               3.20.3                  build_1    https://conda.software.inl.gov/public\nmoose-tools               2024.05.02           h4a78fc2_0    https://conda.software.inl.gov/public\nmoose-wasp                2024.05.08              build_0    https://conda.software.inl.gov/public",
          "url": "https://github.com/idaholab/moose/discussions/28185",
          "updatedAt": "2024-11-01T20:06:13Z",
          "publishedAt": "2024-07-19T19:26:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThanks for looking into this. There is a lot that comes into performance and it's understandably more complex to get peak performance in MOOSE than in more reduced packages.  I don't think anyone in the team has availability to reproduce these results and re-profile to get a better view of the differences right now. @lindsayad for awareness\nOne thing I have wondered is how unoptimized are our libmesh and PETSc packages delivered through conda. They are built with no architecture-specific optimization, and could be slower than libmesh or petsc built from source.\nThat would be a good thing to examine. @milljm may know if that is a factor or not.\nWith regards to explicit solves, optimizing them is being looked at there\n#28105\nand there is an optimized central difference stepper for solid mechanics in the works there\n#28175\nMOOSE was never optimized for explicit solves. There is a lot to do if we want better performance there.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-10099998",
                  "updatedAt": "2024-07-20T00:47:52Z",
                  "publishedAt": "2024-07-20T00:47:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "wow, this is very interesting to see the performance difference between MOOSE and pure libmesh, thank you for the comparison @yanchong-eden! we are also having the same issue as well (10x slower compared to Abaqus) and not even sure what to do about it, I will keep an eye on this, please keep us updated if you've found anything.",
                          "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-10109985",
                          "updatedAt": "2024-07-22T02:52:46Z",
                          "publishedAt": "2024-07-22T02:49:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Conda packages are considered 'fat' binaries, designed to work on a variety of microarchitecture(s). But not optimized for a single one (except perhaps for the ancient Haswell microarchitecture -mtune=haswell for which all Conda packages are built with. Including MOOSE's). This is so anything newer than haswell can use our packages.\nref:\nhttps://docs.conda.io/projects/conda-build/en/stable/resources/compiler-tools.html#customizing-the-compilers\nand,\nhttps://community.intel.com/t5/Processors/How-to-correctly-determine-march-and-mtune-for-Intel-processors/td-p/734278\n...for comparison when trying to build binaries for a specific machine's specifications. Which is what HPC admins will do when building HPC clusters stacks.",
                          "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-10115017",
                          "updatedAt": "2024-07-22T13:23:38Z",
                          "publishedAt": "2024-07-22T13:20:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is why I dont consider benchmarking between libmesh and petsc built from source and moose, with the max-convenience, max portability, likely lower-performance conda prebuilt binaries for libmesh and petsc to be fair.\nI have not checked how unfair though.",
                          "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-10117145",
                          "updatedAt": "2024-07-22T17:17:01Z",
                          "publishedAt": "2024-07-22T16:50:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "One way we could address this would be to publish a yearly benchmark where we do our best on the MOOSE side, maybe even involve applications, and compare to codes we have access to the source for (so we can take similar precautions building them).\nMaybe some sort \"MOOSE Performance assessment suite\" which is public, instead of the internal performance tracking we already do\n@lindsayad",
                          "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-10117394",
                          "updatedAt": "2024-07-22T17:19:46Z",
                          "publishedAt": "2024-07-22T17:18:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If you can share branches for your case that compares MOOSE and PETSc performance, then I will profile them",
                          "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-10117764",
                          "updatedAt": "2024-07-22T18:08:53Z",
                          "publishedAt": "2024-07-22T18:08:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@yanchong-eden with the end of the FY rush and a small dip in proposal season, we should have some time to look at these cases now.\nCan you please share with us:\n\nthe MOOSE inputs for all cases\nthe bare petsc code for the relevant cases\nthe bare libMesh code for the relevant cases",
                          "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-11125648",
                          "updatedAt": "2024-11-01T20:06:15Z",
                          "publishedAt": "2024-11-01T20:06:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ABallisat"
                  },
                  "bodyText": "From experience you can get hugely different performance depending on how you build the various components of MOOSE. We have done quite a lot of investigation of this with different compilers and MPI implementations which can add up to at least an order of magnitude performance difference, ending up on a best set of compilers and options for our systems. Echoing what has been said above, if you are just using the Conda binaries for benchmarking you are not going to get a real comparison. You should build MOOSE and all components from source with the flags tuned for your system, and probably the same flags you are using to build Libmesh and PETSc. If you do that you should get a fairly significant speed up. @GiudGiud might it be worth adding this to the documentation for the Conda install that it is not necessarily optimised and that people should build from source if they want pure performance?\nOther things to consider:\n\nAre you using a replicated or distributed mesh? We find that for some systems that can be a factor of 2 or more performance. What is PETSc doing?\nAre the preconditioners the same?\nAre the options getting passed through to PETSc the same, e.g. tolerances?\nWhat flags are you passing to compilers? looking at what you posted didn't show any optimisation flags\n\nBenchmarking real systems is a nebulous topic and you really need to take care that you are executing in the same environment with the same options to get fair comparisons",
                  "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-10123909",
                  "updatedAt": "2024-07-23T08:53:25Z",
                  "publishedAt": "2024-07-23T08:53:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I am having to update our Conda instructions for another reason, but I will gladly add some information about this: #28193",
                          "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-10125917",
                          "updatedAt": "2024-07-23T12:19:06Z",
                          "publishedAt": "2024-07-23T12:19:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "yanchong-eden"
                  },
                  "bodyText": "Thanks everyone for your interests and comments!\nYes, we are only compiling following the default conda environment on the website, and as @GiudGiud, @milljm and @ABallisat are suggesting the performance is not optimized on our system in the compilation side. And surely, since not optimized, the performance comparison we have is not fair between MOOSE and other software.\nIt would be really helpful if there is a \"MOOSE Performance Assessment Suite\" as @GiudGiud said for us to compare how far our current performance is compared to an officially optimized performance so that we could know where we are right now. The information from @ABallisat that the one order of magnitude speed up is encouraging, and it would be even better if there's an official version we can compare to for a few specific cases. Forgive me but as a startup company, we are worried that no matter how we optimize, this would be still order of magnitude slower than other software.... For example, for the smeared cracking model case, one order of magnitude speed increase still cannot close the x450 slower gap.... If we have a comparison that can give us an estimation of how good the eventual performance can be, we will have more confidence.\nA few other points:\n@lindsayad Thank you very much for your interest for willing to do the profiling, but unfortunately we are not allowed to share the PETSc implementation :( On MOOSE it would be just solving a diffusion kernel for pressure.\n@GiudGiud Thanks for sharing information about the explicit solver. We were actually using NewmarkBeta implicit time integrator, and switching to explicit because we want to increase the speed. Although not optimized for explicit solver, it still gives us 2-3 times speed increase, which is then applied to the performance analysis we have here.\n@ABallisat Thanks for your suggestions! When we are comparing, we didn't use any distributed mesh. When comparing to the bare PETSc implementation, we did make sure all the options are the same. For compilation, we just follow the conda default information with make -j8. We didn't defined any optimization flag on our own.",
                  "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-10130595",
                  "updatedAt": "2024-07-23T20:09:27Z",
                  "publishedAt": "2024-07-23T20:09:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Are there any of your comparison cases that you can share? The Fenics case? If you want to help us improve MOOSE, making the comparison as easy as possible for us would go a long ways",
                          "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-10132121",
                          "updatedAt": "2024-07-24T01:02:55Z",
                          "publishedAt": "2024-07-24T01:02:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi @lindsayad, thanks for asking. We are not ready to make the MOOSE code public for now, I have shared a clean version repo invitation to you and I also copy the FEniCS code zip on Slack, thanks for your time!",
                          "url": "https://github.com/idaholab/moose/discussions/28185#discussioncomment-10140324",
                          "updatedAt": "2024-07-24T17:55:26Z",
                          "publishedAt": "2024-07-24T16:39:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "INSFV not converging",
          "author": {
            "login": "Spudman105"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A Navier Stokes is the most appropriate category for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (avoid screenshots if possible, triple back quotes before/after pasted text, etc)\n\nQuestion\nHello, I am currently trying to use the Incompressible Navier Stokes Finite Volume module to simulate a shock wave motion moving from one end to another of a cylinder. I realize that there is a chance that this might not be able to be done. At this point I used a velocity equation to control how the loading would be as an input BC. It will run however the linear residual wont converge nor will the non-linear even with really relaxed relative tolerance. Usually it fails due to diverged_breakdown or line_search breakdown. I have tried using preconditioning to see if there is something wrong with the Jacobian but have not come up with any solutions. Below is my code and some of the output.\n'''\nmu = 1  #incompressible, dynamic viscosity\nrho = 8.027 #(g/cm^3), Density\nk = 14.6 #W/m k Thermal conductivity\ncp = 450 #j/kg K, specific heat\n[GlobalParams]\nrhie_chow_user_object = 'rc'\n[]\n[Mesh]\n[face1]\ntype = AnnularMeshGenerator\nrmin = 0 # makes the plane a disk instead of a ring\nrmax = .5 # sets the radius from the center for the outer ring, r=.5 means diameter is 1 which is beam spot size.\nnt = 100 # number of notes along outer ring\nnr = 5 # number of nodes between the center and the outer radius. (increase later but small now for speed of tests)\n[]\n[extrude]\ntype = AdvancedExtruderGenerator\ninput = face1\nheights = '1 2'\nnum_layers = '24 12 ' # the number of between layers from one height to another\ndirection = '0 0 1'\nbiases = '1 2'\n[]\n[]\n[Variables]\n[vel_x]\ntype = INSFVVelocityVariable\n[]\n[vel_y]\ntype = INSFVVelocityVariable\n[]\n[vel_z]\ntype = INSFVVelocityVariable\n[]\n[pressure]\ntype = INSFVPressureVariable\n[]\n[T_fluid]\ntype = INSFVEnergyVariable\n[]\n[]\n[ICs]\n[ic_vel_x]\ntype = ConstantIC\nvariable = vel_x\nvalue = 0\n[]\n[ic_vel_y]\ntype = ConstantIC\nvariable = vel_y\nvalue = 0\n[]\n[ic_vel_z]\ntype = ConstantIC\nvariable = vel_z\nvalue = 0\n[]\n[ic_pressure]\ntype = ConstantIC\nvariable = pressure\nvalue = 1\n[]\n[ic_T_fluid]\ntype = ConstantIC\nvariable = T_fluid\nvalue = 300\n[]\n[]\n[UserObjects]\n[rc]\ntype = INSFVRhieChowInterpolator\nu = vel_x\nv = vel_y\nw = vel_z\npressure = pressure\n[]\n[]\n[FVKernels]\n[mass]\ntype = INSFVMassAdvection\nvariable = pressure\nadvected_interp_method = 'average'\nrho = ${rho}\n[]\n[mass_forcing]\ntype = FVBodyForce\nvariable = pressure\n[]\n[u_advection]\ntype = INSFVMomentumAdvection\nvariable = vel_x\nadvected_interp_method = 'average'\nrho = ${rho}\nmomentum_component = 'x'\n[]\n[u_viscosity]\ntype = INSFVMomentumDiffusion\nvariable = vel_x\nmu = ${mu}\nmomentum_component = 'x'\n[]\n[u_pressure]\ntype = INSFVMomentumPressure\nvariable = vel_x\nmomentum_component = 'x'\npressure = pressure\n[]\n[v_advection]\ntype = INSFVMomentumAdvection\nvariable = vel_y\nadvected_interp_method = 'average'\nrho = ${rho}\nmomentum_component = 'y'\n[]\n[v_viscosity]\ntype = INSFVMomentumDiffusion\nvariable = vel_y\nmu = ${mu}\nmomentum_component = 'y'\n[]\n[v_pressure]\ntype = INSFVMomentumPressure\nvariable = vel_y\nmomentum_component = 'y'\npressure = pressure\n[]\n[w_advection]\ntype = INSFVMomentumAdvection\nvariable = vel_z\nadvected_interp_method = 'average'\nrho = ${rho}\nmomentum_component = 'z'\n[]\n[w_viscosity]\ntype = INSFVMomentumDiffusion\nvariable = vel_z\nmu = ${mu}\nmomentum_component = 'z'\n[]\n[w_pressure]\ntype = INSFVMomentumPressure\nvariable = vel_z\nmomentum_component = 'z'\npressure = pressure\n[]\n[temp_conduction]\ntype = FVDiffusion\ncoeff = 'k'\nvariable = T_fluid\n[]\n[temp_advection]\ntype = INSFVEnergyAdvection\nvariable = T_fluid\nadvected_interp_method = 'average'\n[]\n[]\n[FVBCs]\n[Inlet]\ntype = INSFVInletVelocityBC\nboundary = '3'\nfunctor = 'velocity_z'\nvariable = vel_z\n[]\n[slip_x]\ntype = INSFVNaturalFreeSlipBC\nvariable = vel_x\nboundary = 'rmax'\nmomentum_component = 'x'\n[]\n[slip_y]\ntype = INSFVNaturalFreeSlipBC\nvariable = vel_y\nboundary = 'rmax'\nmomentum_component = 'y'\n[]\n[slip_z]\ntype = INSFVNaturalFreeSlipBC\nvariable = vel_z\nboundary = 'rmax'\nmomentum_component = 'z'\n[]\n[T_hot]\ntype = FVDirichletBC\nvariable = T_fluid\nboundary = '1'\nvalue = 310\n[]\n[T_cold]\ntype = FVDirichletBC\nvariable = T_fluid\nboundary = '3'\nvalue = 290\n[]\n[]\n[AuxVariables]\n[U]\norder = CONSTANT\nfamily = MONOMIAL\nfv = true\n[]\n[]\n[AuxKernels]\n[mag]\ntype = VectorMagnitudeAux\nvariable = U\nx = vel_x\ny = vel_y\nz = vel_z\n[]\n[]\n[FluidProperties]\n[simple_fluid]\ntype = SimpleFluidProperties\nbulk_modulus = 10000\nviscosity = 1\ndensity0 = 8.027\nthermal_expansion = 0\n[]\n[]\n[FunctorMaterials]\n[functor_constants]\ntype = ADGenericFunctorMaterial\nprop_names = 'cp k'\nprop_values = '${cp} ${k}'\n[]\n[ins_fv]\ntype = INSFVEnthalpyFunctorMaterial\ntemperature = 'T_fluid'\nrho = ${rho}\n[]\n[]\n[Functions]\n[velocity_z]\ntype = ParsedFunction\nexpression = (8.904910^5)sin(t((2pi)/(12*10^-9)))\n[]\n[]\n[Postprocessors]\n[element_T]\ntype = ElementAverageValue\nvariable = T_fluid\nexecute_on = 'LINEAR'\n[]\n[nodal_z]\ntype = ElementAverageValue\nvariable = vel_z\nexecute_on = 'LINEAR'\n[]\n[element_pressure]\ntype = ElementAverageValue\nvariable = pressure\nexecute_on = 'LINEAR'\n[]\n[]\n#[Preconditioning]\n[SMP]\ntype = SMP\nfull = true\n[]\n#[]\n[Executioner]\ntype = Transient\nend_time = 1.2e-8\ndt = 5.0e-11\nl_max_its  =  1000 #controls iterations\nnl_rel_tol = 0.01\nline_search = 'none'\npetsc_options_iname = '-snes_linesearch_damping'\npetsc_options_value = '0.75'\n[]\n[Outputs]\nexodus = true\nprint_linear_residuals = true\n[csv]\ntype = CSV\nexecute_on = 'LINEAR'\n[]\n[]\n[Debug]\nshow_var_residual_norms = true\n[]\n'''\nOutput residual example is:\n'''\n148 Linear |R| = 1.756055e+07\n149 Linear |R| = 1.745537e+07\n\nLinear solve did not converge due to DIVERGED_BREAKDOWN iterations 150\n|residual|_2 of individual variables:\nvel_x:    5942.44\nvel_y:    5990.86\nvel_z:    162517\npressure: 216.941\nT_fluid:  2.13954e+07\n14 Nonlinear |R| = 2.139600e+07\n0 Linear |R| = 2.139600e+07\n1 Linear |R| = 2.139600e+07\n2 Linear |R| = 2.139600e+07\n3 Linear |R| = 2.139600e+07\n 28 Linear |R| = 2.139597e+07\n 29 Linear |R| = 2.139596e+07\n\nLinear solve did not converge due to DIVERGED_BREAKDOWN iterations 30\n|residual|_2 of individual variables:\nvel_x:    5942.44\nvel_y:    5990.86\nvel_z:    162517\npressure: 216.941\nT_fluid:  2.13954e+07\n15 Nonlinear |R| = 2.139600e+07\n0 Linear |R| = 2.139600e+07\n1 Linear |R| = 2.139600e+07\n2 Linear |R| = 2.139600e+07\n'''\nThanks\nAdditional information\nMesh size and type:\nReynolds number:\nDiscretization (finite element CG/DG, finite volume, etc):\nModels (turbulence, porous media, etc):\nSolver method (fully coupled, segregated, multiapps, etc):\nBase input you started from:",
          "url": "https://github.com/idaholab/moose/discussions/28909",
          "updatedAt": "2024-11-01T00:17:28Z",
          "publishedAt": "2024-10-23T02:05:17Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAn incompressible formulation won't do much for a shockwave, it will just propagate instantly and change the mean pressure of the system.\nFor preconditioning, you can use LU with a nonzero factor shift for the Newton solve method.\nWith average advected quantity interpolation you can expect checkerboarding of the pressure, we would recommend using upwind here",
                  "url": "https://github.com/idaholab/moose/discussions/28909#discussioncomment-11025332",
                  "updatedAt": "2024-10-23T06:38:12Z",
                  "publishedAt": "2024-10-23T06:38:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Spudman105"
                          },
                          "bodyText": "Would a weakly compressible be better then to allow for some response to the load?",
                          "url": "https://github.com/idaholab/moose/discussions/28909#discussioncomment-11033831",
                          "updatedAt": "2024-10-23T20:57:29Z",
                          "publishedAt": "2024-10-23T20:57:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Spudman105"
                          },
                          "bodyText": "Additionally I made the changes you recommended. I got these errors back and looked in documentation but couldn't find anything about how t solve this error code.\n'''\n[0]PETSC ERROR: Residual norm computed by GMRES recursion formula 36319. is far from the computed residual norm 1.37661e+12 at restart, residual norm at start of cycle 7.29559e+08\nResidual norm computed by GMRES recursion formula 36319. is far from the computed residual norm 1.37661e+12 at restart, residual norm at start of cycle 7.29559e+08\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 3\nlibMesh terminating:\n'''\nAny help is appreciated,\nThanks",
                          "url": "https://github.com/idaholab/moose/discussions/28909#discussioncomment-11034210",
                          "updatedAt": "2024-10-23T21:55:36Z",
                          "publishedAt": "2024-10-23T21:55:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Weakly compressible has the same issues as incompressible.\nWe use the compressible formulation for any fast flow or shock problem. It is less mature though",
                          "url": "https://github.com/idaholab/moose/discussions/28909#discussioncomment-11034688",
                          "updatedAt": "2024-10-23T23:25:37Z",
                          "publishedAt": "2024-10-23T23:25:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I don't know about the errors. You ll have to look at petsc or libmesh to see why that may be",
                          "url": "https://github.com/idaholab/moose/discussions/28909#discussioncomment-11034695",
                          "updatedAt": "2024-10-23T23:26:07Z",
                          "publishedAt": "2024-10-23T23:26:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@lindsayad have you hit that one before?\nLooking there https://petsc.org/release/src/ksp/ksp/impls/gmres/gmres.c.html it seems this error is a sign of non-convergence of GMRES",
                          "url": "https://github.com/idaholab/moose/discussions/28909#discussioncomment-11082060",
                          "updatedAt": "2024-10-29T03:22:22Z",
                          "publishedAt": "2024-10-29T03:22:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I believe I have but it's been a long time. You should run with Executioner/solve_type = NEWTON and then you should only be getting a single KSP iteration if you are using LU. Also use -pc_factor_mat_solver_type mumps to avoid using the PETSc native implementation (which is not very accureate) in serial",
                          "url": "https://github.com/idaholab/moose/discussions/28909#discussioncomment-11117083",
                          "updatedAt": "2024-11-01T00:17:28Z",
                          "publishedAt": "2024-11-01T00:17:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Current Known Issues",
          "author": {
            "login": "milljm"
          },
          "bodyText": "No known issues at this time affecting any of our servers/services.",
          "url": "https://github.com/idaholab/moose/discussions/28494",
          "updatedAt": "2024-10-31T14:02:09Z",
          "publishedAt": "2024-08-29T16:11:19Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "",
                  "url": "https://github.com/idaholab/moose/discussions/28494#discussioncomment-10491871",
                  "updatedAt": "2024-09-09T13:48:12Z",
                  "publishedAt": "2024-08-29T21:10:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Fixed now",
                          "url": "https://github.com/idaholab/moose/discussions/28494#discussioncomment-10577031",
                          "updatedAt": "2024-09-09T13:48:05Z",
                          "publishedAt": "2024-09-07T13:13:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}