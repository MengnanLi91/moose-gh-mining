{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wOS0xNVQwMDoyMTowMS0wNTowMM4AQvl7"
    },
    "edges": [
      {
        "node": {
          "title": "How to transfer strain in spherical coordinates to Cartesian coordinate?",
          "author": {
            "login": "RECHOA"
          },
          "bodyText": "Hi all,\nIf i know the raidal and hoop strain of a material in spherical coordinates as folliws:\n\u03b5r= -0.007T ;  \u03b5t= -0.004T ; T is the tempearature.\nNow i want to analyze its mechanical behaviour by using MOOSE in the Cartesian coordinate (coord-type=XYZ), how should I build the strain tensor \u03b5 in EigenStrain.C?",
          "url": "https://github.com/idaholab/moose/discussions/22105",
          "updatedAt": "2022-09-29T16:59:55Z",
          "publishedAt": "2022-09-15T14:31:41Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@recuero\nI think you ll want to do the math, build a generic constant tensor, and use that in the calculation.\nI doubt we have a utility for you here but Antonio will know",
                  "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3654896",
                  "updatedAt": "2022-09-15T15:07:20Z",
                  "publishedAt": "2022-09-15T15:07:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I doubt we have a utility for that too. It seems that once you perform the transformation from your spherical coordinates to the Cartesian systems, you'll end up with a nontrivial dependency on the temperature. I wonder if a simple way forward can be just to inherit from ComputeEigenstrain and perform the transformation there pulling the temperature variable.\nMaybe @jiangwen84 knows if there is a simpler way to do that.",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3655364",
                          "updatedAt": "2022-09-15T15:54:53Z",
                          "publishedAt": "2022-09-15T15:54:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The general steps are:\n\nCalculate the eigen deformation gradient from the eigen strain, IIRC tensor mechanics uses the log strain measure.\nCalculate the scalar-valued thermal expansion, i.e. the determinant of the eigen deformation gradient, which is convenient as it is an invariant.\nCalculate the eigen deformation gradient in Cartesian from the calculated thermal expansion.\nCalculate the eigen strain from the eigen deformation gradient in Cartesian.\n\nYour eigen strain might be trickier as it seems to be anisotropic. But the general steps should apply, you just do it for the two directions and add the eigen strains.",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3655466",
                          "updatedAt": "2022-09-15T16:06:10Z",
                          "publishedAt": "2022-09-15T16:06:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "And of course you can do it as @recuero suggested -- directly transform the eigen strain tensor using a rotation tensor. It will require users to define the axisymmetric RZ coordinate system, e.g. the symmetry axis.",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3655494",
                          "updatedAt": "2022-09-15T16:09:50Z",
                          "publishedAt": "2022-09-15T16:09:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RECHOA"
                          },
                          "bodyText": "Thanks for your reply. I am sorry i didn't understand the general steps. Are there articles or formula derivation i can refer to?\nAs for the other method (directly transforming the eigen strain tensor using a rotation tensor), If I have multiple spheres like this to simulate, does that mean I have to set up multiple spherical coordinates and convert the strain to cartesian coordinates in each spherical coordinate\uff1f",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3655832",
                          "updatedAt": "2022-09-15T16:46:42Z",
                          "publishedAt": "2022-09-15T16:46:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Are there articles or formula derivation i can refer to?\n\nI'm not aware of any unfortunately.\n\nAs for the other method (directly transforming the eigen strain tensor using a rotation tensor), If I have multiple spheres like this to simulate, does that mean I have to set up multiple spherical coordinates and convert the strain to cartesian coordinates in each spherical coordinate\uff1f\n\nYes. Intuitively that's how it works if I understand your problem description correctly: you know how the spheres are going to expand radially and axially in their respective spherical coordinates, so they can't share a common spherical coordinate system as they are transformed into Cartesian.",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3658267",
                          "updatedAt": "2022-09-16T00:22:36Z",
                          "publishedAt": "2022-09-16T00:22:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "RECHOA"
                          },
                          "bodyText": "you know how the spheres are going to expand radially and axially in their respective spherical coordinates, so they can't share a common spherical coordinate system as they are transformed into Cartesian.\n\nyes, the expansion of the spheres are  konwn in in their respective spherical coordinates. In each sphere it follws \u03b5r= -0.007T ; \u03b5t= -0.004T, i.e. the strain tensor in spherical coordinate is known as\nSsphere =\n\nSo now i need to find a way (maybe a transform matrix M) to convert  Ssphere in  respective spherical coordinates to Sxyz in Cartesian coordinate system",
                          "url": "https://github.com/idaholab/moose/discussions/22105#discussioncomment-3660465",
                          "updatedAt": "2022-09-16T08:11:36Z",
                          "publishedAt": "2022-09-16T08:11:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Coupling Variables Error",
          "author": {
            "login": "FanZhangchen"
          },
          "bodyText": "Hello,\nI am trying to implement a MOOSE framework with two governing equations and two nodal degrees of freedom. I try to use adCoupledVectorValue to represent the coupled variable. MOOSE could compile well, but when I tried to solve it, some errors came up.\n*** ERROR *** The named variable is a standard variable, try a 'coupled[Value/Gradient/Dot/etc]...' function instead\nSo I think it might be wrong with my coupling variables. I am new to MOOSE that I am not sure how to realize the problems with two coupling variables in two equations. Could you give me some suggestions about it? Thanks",
          "url": "https://github.com/idaholab/moose/discussions/22103",
          "updatedAt": "2022-09-16T07:17:13Z",
          "publishedAt": "2022-09-15T11:12:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "FanZhangchen"
                  },
                  "bodyText": "The governing equations are attached here if you need them.\n\n\n$\\rho$ and $\\rho_G$ are the nodal degrees of freedom.",
                  "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3653600",
                  "updatedAt": "2022-09-15T12:47:52Z",
                  "publishedAt": "2022-09-15T12:47:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCoupledVectorValue is a routine for vector variables, not for regular single-component field variables.'\nI think you want to use coupledValue or ADcoupledValue here\nThis retrieves the local quadrature point value of the variable passed\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3654932",
                  "updatedAt": "2022-09-15T15:10:47Z",
                  "publishedAt": "2022-09-15T15:10:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "FanZhangchen"
                          },
                          "bodyText": "Hello\nThank you for your reply. I have tried to use ADcoupledValue and I got some errors. The error is attached here.\nerror: no match for 'operator-' (operand types are 'libMesh::CompareTypes<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true>'} and 'libMesh::boostcopy::enable_if_c<true, libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> > >::type' {aka 'libMesh::TypeVector<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >'})\n   27 |     - _grad_test[_i][_qp] * _rhot[_qp];\n\nI think I might have some C++ syntax errors here. I will also attach my C++ file here. Do you have any ideas about my problem?\n#include \"ADGNDTrans.h\"\n\nregisterMooseObject(\"framework2App\", ADGNDTrans);\n\nInputParameters\nADGNDTrans::validParams()\n{\n  auto params = ADKernel::validParams();\n  params.addParam<Real>(\"backstress\", 1.0, \"Back stress' parameter\");\n  params.addClassDescription(\"The time derivative operator with the weak form of $(\\\\psi_i, \"\n                             \"\\\\frac{\\\\partial rhog}{\\\\partial t})$.\");\n  params.addCoupledVar(\"rhot\", \"The variable representing the total dislocation density.\");\n  return params;\n}\n\nADGNDTrans::ADGNDTrans(const InputParameters & parameters)\n  : ADKernel(parameters),\n    _backstress(getParam<Real>(\"backstress\")),\n    _rhot(adCoupledValue(\"rhot\"))\n{\n}\n\nADReal\nADGNDTrans::computeQpResidual()\n{\n  return _backstress * _grad_u[_qp]*_grad_test[_i][_qp]\n    - _grad_test[_i][_qp] * _rhot[_qp];\n}",
                          "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3658607",
                          "updatedAt": "2022-09-16T02:48:18Z",
                          "publishedAt": "2022-09-16T01:55:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes the syntax is wrong. Basically the two terms being substracted are of a different type.\nFrom the message, one is a single ADReal and the other is a vector of ADReals",
                          "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3658848",
                          "updatedAt": "2022-09-16T02:49:33Z",
                          "publishedAt": "2022-09-16T02:49:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "FanZhangchen"
                          },
                          "bodyText": "Does it mean I need to add another kernel for these different types? Or the easy way to solve this error is to divide two terms into different kernels?",
                          "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3658879",
                          "updatedAt": "2022-09-16T02:56:27Z",
                          "publishedAt": "2022-09-16T02:56:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no you dont, you need to check that the math makes sense here. You have a grad_u * grad_test and a grad_test * some_variable that is not a vector\nI dont think that s right",
                          "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3658952",
                          "updatedAt": "2022-09-16T03:14:07Z",
                          "publishedAt": "2022-09-16T03:13:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "FanZhangchen"
                          },
                          "bodyText": "Yes, I get your point. I will check if there is any math error. Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/22103#discussioncomment-3659000",
                          "updatedAt": "2022-09-16T03:31:07Z",
                          "publishedAt": "2022-09-16T03:31:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Verifying Energy Conservation in Heat Transfer Calculations",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, moose developers.\nI would like to verify the conservation of energy in MOOSE heat transfer calculations. The specific model is like this\uff1a\n\nThere is a heating rod with a sinusoidal distribution of power, the surrounding is a fluid, and the whole system is adiabatic. I gave this system an initial temperature T0, the average temperatures of the solid and liquid after t seconds are Ts and Tf respectively. Then the heat absorbed by the system, which also can be called enthalpy,  should be equal to\n\nOn the other hand, the heat released by the solid heating rod should be equal to the integral of the power over the volume multiplied by t, which is equal to:\n\nIt can be seen from the boundary conditions that the system is adiabatic, and it stands to reason that the enthalpy of the system should be equal to the heat released by the heating rod. But they are not equal. I have some PostProcessors in an input file. The power_integral means the integral of power over the entire heating rod volume. The energy_difference means power_integral * t - enthalpy .\nThe enthalpy rise versus time and the heat released by the heating rod versus time are plotted as follows:\n\nThere are input file and mesh files:\n# Units: cm K s kg\n\noutlet_pressure = 0\ninlet_velocity = 150 # cm/s\nini_temp = 300 # K\nheat_transfer_coefficient = 9 # W cm-2\ng = -981 \nrho_solid = 0.011 # kg cm-3\ncp_solid = 300 # cm s-2\nk_solid = 0.06 # W cm-1 K-1\n# (0.5 * 0.5 * pi * 10) = 7.8539816\nV_solid = 7.8539816\n\nrho_fluid = 0.0077\ncp_fluid = 145\nk_fluid = 0.12\nmu_fluid = 1.762e-5\n# ((1.6 * 1.6 - 0.5 * 0.5 * pi) * 10) = 17.7460184\nV_fluid = 17.7460184\n\n[Mesh]\n  file = 'solid_fluid.msh'\n[]\n\n[Variables]\n  [./T]\n    initial_condition = ${ini_temp}\n  [../]\n  [./velocity]\n    family = LAGRANGE_VEC\n    block = 'fluid'\n  [../]\n  [./p]\n    order = FIRST\n    family = LAGRANGE\n    block = 'fluid'\n  [../]\n[]\n\n[AuxVariables]\n  [./power]\n    family = MONOMIAL\n    order = FIRST\n    block = 'solid'\n  [../]\n[]\n\n[ICs]\n  [./initial_velocity]\n    type = VectorConstantIC\n    x_value = 0\n    y_value = 0\n    z_value = ${inlet_velocity}\n    variable = velocity\n  [../]\n  [./initial_p]\n    type = FunctionIC\n    variable = p\n    function = ini_p\n  [../]\n[]\n\n[Kernels]\n  [./fluid_mass]\n    type = INSADMass\n    variable = p\n  [../]\n  [./fluid_mass_pspg]\n    type = INSADMassPSPG\n    variable = p\n  [../]\n\n  [./fluid_momentum_time]\n    type = INSADMomentumTimeDerivative\n    variable = velocity\n  [../]\n  [./fluid_momentum_convection]\n    type = INSADMomentumAdvection\n    variable = velocity\n  [../]\n  [./fluid_momentum_pressure]\n    type = INSADMomentumPressure\n    variable = velocity\n    pressure = p\n    integrate_p_by_parts = true\n  [../]\n  [./fluid_momentum_gravity]\n    type = INSADGravityForce\n    variable = velocity\n    gravity = '0 0 ${g}'\n  [../]\n  [./fluid_momentum_supg]\n    type = INSADMomentumSUPG\n    variable = velocity\n    velocity = velocity\n  [../]\n\n  [./fluid_temperature_time]\n    type = INSADHeatConductionTimeDerivative\n    variable = T\n    block = 'fluid'\n  [../]\n  [./fluid_temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    block = 'fluid'\n    thermal_conductivity = 'k'\n  [../]\n  [./fluid_temperature_advection]\n    type = INSADEnergyAdvection\n    variable = T\n    block = 'fluid'\n  [../]\n  [./fluid_temperature_supg]\n    type = INSADEnergySUPG\n    variable = T\n    velocity = velocity\n    block = 'fluid'\n  [../]\n\n  [./solid_temperature_time]\n    type = ADHeatConductionTimeDerivative\n    variable = T\n    block = 'solid'\n    density_name = 'rho'\n    specific_heat = 'cp'\n  [../]\n  [./solid_temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    block = 'solid'\n    thermal_conductivity = 'k'\n  [../]\n  [./heat_source]\n    type = ADCoupledForce\n    variable = T\n    block = 'solid'\n    v = power\n  [../]\n[]\n\n[AuxKernels]\n  [./power_aux]\n    type = FunctionAux\n    variable = power\n    function = power_function\n    block = 'solid'\n  [../]\n[]\n\n[InterfaceKernels]\n  [./convection_heat_transfer]\n    type = ConjugateHeatTransfer\n    variable = T\n    T_fluid = T\n    neighbor_var = 'T'\n    boundary = 'solid_wall'\n    htc = 'htc'\n  [../]\n[]\n\n[BCs]\n  [./inlet_velocity_fluid]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'fluid_bottom'\n    function_z = ${inlet_velocity}\n  [../]\n  [./outlet_p_fluid]\n    type = DirichletBC\n    variable = p\n    boundary = 'fluid_top'\n    value = ${outlet_pressure}\n  [../]\n\n  [./no_slip]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'solid_wall'\n  [../]\n\n  [./Periodic]\n    [./x]\n      variable = velocity\n      primary = 'fluid_wall1'\n      secondary = 'fluid_wall2'\n      translation = '1.6 0 0'\n    [../]\n    [./y]\n      variable = velocity\n      primary = 'fluid_wall3'\n      secondary = 'fluid_wall4'\n      translation = '0 1.6 0'\n    [../]\n  [../]\n[]\n\n[Materials]\n  [./solid_mat]\n    type = ADGenericConstantMaterial\n\tprop_names = 'rho cp k'\n\tprop_values = '${rho_solid} ${cp_solid} ${k_solid}'\n\tblock = 'solid'\n  [../]\n  [./fluid_mat]\n    type = ADGenericConstantMaterial\n\tprop_names = 'rho cp k mu'\n\tprop_values = '${rho_fluid} ${cp_fluid} ${k_fluid} ${mu_fluid}'\n\tblock = 'fluid'\n  [../]\n\n  [./ins_mat_fluid]\n    type = INSADStabilized3Eqn\n    velocity = velocity\n    pressure = p\n    temperature = T\n    block = 'fluid'\n  [../]\n\n  [./htc]\n    type = ADGenericFunctionMaterial\n    prop_names = htc\n    prop_values = htc_function\n  [../]\n[]\n\n[Functions]\n  [./htc_function]\n    type = ParsedFunction\n    value = ${heat_transfer_coefficient}\n  [../]\n  [./ini_p]\n    type = ParsedFunction\n    value = '0.011 * 981 * (10-z)'\n  [../]\n  [./power_function]\n    type = ParsedFunction\n    value = '100 + 200 * sin(z / 10 * pi)'\n  [../]\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n    solve_type = 'NEWTON'\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  #num_steps = 100\n  dt = 1\n  end_time = 200\n\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-10\n\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason -snes_linesearch_monitor'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n  line_search = 'none'\n   # petsc_options_iname = '-snes_type'\n  # petsc_options_value = 'test'\n\n  nl_max_its = 30\n  l_max_its = 100\n  automatic_scaling = true\n[]\n\n[Postprocessors]\n  [./average_T_solid]\n    type = ElementAverageValue\n    variable = T\n    block = 'solid'\n  [../]\n  [./average_T_fluid]\n    type = ElementAverageValue\n    variable = T\n    block = 'fluid'\n  [../]\n  [./enthalpy]\n    type = ParsedPostprocessor\n\tfunction = '(average_T_solid - 300) * ${rho_solid} * ${cp_solid} * ${V_solid}  + (average_T_fluid - 300) * ${rho_fluid} * ${cp_fluid} * ${V_fluid}'\n\tpp_names = 'average_T_solid average_T_fluid'\n  [../]\n  [./power_integral]\n    type = ElementIntegralVariablePostprocessor\n\tvariable = power\n\tblock = 'solid'\n  [../]\n  [energy_difference]\n    type = ParsedPostprocessor\n\tfunction = 'power_integral * t - enthalpy'\n\tpp_names = 'power_integral enthalpy'\n\tuse_t = true\n  [../]\n[]\n\n[Outputs]\n  perf_graph = true\n  print_linear_residuals = true\n  [./exodus]\n    type = Exodus\n    file_base = 'energy_balance'\n    execute_on = 'TIMESTEP_END'\n  [../]\n  [./csv]\n    type = CSV\n    file_base = 'energy_balance'\n    execute_on = 'TIMESTEP_END'\n  [../]\n[]\n\ngithub.zip\nWhat do you think of this problem? Am I overlooking a cooling source in the system or some other setting that causes heat to move out of the system\uff1f",
          "url": "https://github.com/idaholab/moose/discussions/21966",
          "updatedAt": "2022-09-16T01:39:57Z",
          "publishedAt": "2022-08-30T06:12:48Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "The way you define enthalpy and total work doesn't look right to me.\nwork = power * dt only holds when power doesn't change with time (I'm not sure if this the case with your model without reading it in detail.).\nThe enthalpy density should be integrated in volume. The expression you used only hold when you have a homogeneous temperature field.",
                  "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3522140",
                  "updatedAt": "2022-08-31T22:44:55Z",
                  "publishedAt": "2022-08-31T22:44:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Hi, Gary.\nPower is a function of z, so I use the following formulas to calculate the work produced in time t:\n\nSolid and fluid don't have homogeneous temperature fields, so I find the average temperature of the solid and liquid first and then calculate their enthalpy.\n\nSo the enthalpy should be equal to the work, but the simulation results are not. These are PostProcessors of enthalpy , power and energy_difference:\n  [./enthalpy]\n    type = ParsedPostprocessor\n    function = '(average_T_solid - 300) * ${rho_solid} * ${cp_solid} * ${V_solid}  + (average_T_fluid - 300) * ${rho_fluid} * ${cp_fluid} * ${V_fluid}'\n    pp_names = 'average_T_solid average_T_fluid'\n  [../]\n  [./power_integral]\n    type = ElementIntegralVariablePostprocessor\n    variable = power\n    block = 'solid'\n  [../]\n  [energy_difference]\n    type = ParsedPostprocessor\n    function = 'power_integral * t - enthalpy'\n    pp_names = 'power_integral enthalpy'\n    use_t = true\n  [../]",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3522911",
                          "updatedAt": "2022-09-01T02:44:22Z",
                          "publishedAt": "2022-09-01T02:41:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Solid and fluid don't have homogeneous temperature fields, so I find the average temperature of the solid and liquid first and then calculate their enthalpy.\n\nThis may be fine, but very inaccurate, and is most likely the source of the difference you are seeing. You need to properly integrate the enthalpy density both in space and in time for it to match the heat source. The equation should be\n\\int_0^t \\int_\\Omega \\rho c_p \\dot{T} \\d{V} \\d{t}\n\nCompute the enthalpy rate density \\rho c_p \\dot{T} as a material property,\nIntegrate the enthalpy rate density in space to get the enthalpy rate, e.g. using a ElementIntegralMaterialProperty postprocessor.\nIntegrate the enthalpy rate in time. Use your favorite integration scheme, as I think the time integration error will be negligible in this case.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3528187",
                          "updatedAt": "2022-09-01T15:23:54Z",
                          "publishedAt": "2022-09-01T15:23:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thank you, Gary. These methods maybe useful, After solving the problem of the fluid pressure field I will add the energy equation as well and use your method to verify the conservation of energy. I'll let you know the result of my attempt.\ud83d\ude00",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3534843",
                          "updatedAt": "2022-09-02T09:43:40Z",
                          "publishedAt": "2022-09-02T09:43:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Hi, Gary.\nI think the following formulas can be used to calculate the enthalpy:\n\nWhen \u03c1 and cp are constants, I define a material property called fluid_enthalpy_density in the Materials block to calculate the increasement of enthalpy at a certain point:\n  [./fluid_enthalpy_density_mat]\n    type = ADParsedMaterial\n    f_name = fluid_enthalpy_density\n    function = '(Tf - ${ini_temp}) * rho * cp'\n    args = 'Tf'\n    material_property_names = 'rho cp'\n    block = 'fluid'\n  [../]\n  [./solid_enthalpy_density_mat]\n    type = ADParsedMaterial\n    f_name = solid_enthalpy_density\n    function = '(Ts - ${ini_temp}) * rho * cp'\n    args = 'Ts'\n    material_property_names = 'rho cp'\n    block = 'solid'\n  [../]\n\nThen I integrate the fluid_enthalpy_density in space to get the fluid_enthalpy:\n  [./solid_enthalpy]\n    type = ADElementIntegralMaterialProperty\n    mat_prop = 'solid_enthalpy_density'\n    block = 'solid'\n  [../]\n  [./fluid_enthalpy]\n    type = ADElementIntegralMaterialProperty\n    mat_prop = 'fluid_enthalpy_density'\n    block = 'fluid'\n  [../]\n\nThe heat absorbed by the system is calculated by these formulas:\n\nThe power_density I defined is:\n[AuxVariables]\n  [./power_density]\n    family = MONOMIAL\n    order = FIRST\n    block = 'solid'\n  [../]\n[]\n[AuxKernels]\n  [./power_density_auxk]\n    type = FunctionAux\n    variable = power_density\n    function = power_density_function\n    block = 'solid'\n  [../]\n[]\n[Functions]\n  [./power_density_function]\n    type = ParsedFunction\n    value = '50'\n  [../]\n[]\n\nThen I integrate the power_density in space to get the power:\n  [./power]\n    type = ElementIntegralVariablePostprocessor\n    variable = power_density\n    block = 'solid'\n  [../]\n\nFinally, I multiply power by time t to get heat:\n  [./heat]\n    type = ParsedPostprocessor\n    function = 'power * t'\n    pp_names = 'power'\n    use_t = true\n  [../]\n\nThe sum of solid_enthalpy and fluid_enthalpy should be equal to heat, but they are not:\n  [./enthalpy]\n    type = ParsedPostprocessor\n    function = 'solid_enthalpy + fluid_enthalpy'\n    pp_names = 'solid_enthalpy fluid_enthalpy'\n  [../]\n  [./energy_relative_error]\n    type = ParsedPostprocessor\n    function = 'abs(enthalpy - heat) / heat'\n    pp_names = 'enthalpy heat'\n  [../]\n\nHere are enthalpy and heat plots of time:\n\nDo you think there is something wrong with the way I integrate? Why is there such a big error? Here are complete files.\nfiles.zip\nBest regards.\nXu.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3560578",
                          "updatedAt": "2022-09-05T14:32:33Z",
                          "publishedAt": "2022-09-05T14:32:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is cp constant? If not then your enthalpy integral is approximate\nsame question for power",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3561862",
                          "updatedAt": "2022-09-05T16:26:40Z",
                          "publishedAt": "2022-09-05T16:26:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Yeah, rho and cp are all constants.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3561919",
                          "updatedAt": "2022-09-05T16:31:35Z",
                          "publishedAt": "2022-09-05T16:31:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "ohhh I didn't see you are using SUPG. The usual form of the SUPG operator introduces dissipation hence enthalpy is not conserved. IIRC there is a straightforward modification you can make to guarantee conservation though.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3561933",
                          "updatedAt": "2022-09-05T16:32:39Z",
                          "publishedAt": "2022-09-05T16:32:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "In other words, I think if you use the unstabilized heat equation in the fluid, you should be able to demonstrate enthalpy conservation, although the advection messes up your solution.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3561970",
                          "updatedAt": "2022-09-05T16:35:08Z",
                          "publishedAt": "2022-09-05T16:35:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Do you mean that if I remove SUPG operator, I can get enthalpy \uff1d heat?",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3562017",
                          "updatedAt": "2022-09-05T16:39:20Z",
                          "publishedAt": "2022-09-05T16:39:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Actually, I've demonstrated the conservation of energy only for solid heat conduction. The results were very good, with an error of one in 10,000. But when I add fluid convective heat transfer, the error is very large.",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3562055",
                          "updatedAt": "2022-09-05T16:42:51Z",
                          "publishedAt": "2022-09-05T16:42:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "js-jixu"
                  },
                  "bodyText": "I have a 2D model. In the middle of the model is a solid area with an internal heat source, with fluid areas on both sides. There is conjugate heat transfer between the solid region and the fluid region. I want to verify the conservation of energy when calculating heat transfer. I set the temperature boundary conditions as natural boundary conditions (no boundary conditions) to achieve the purpose of insulating the entire system.\n\nInitially I wanted to verify the conservation of energy by transient calculations, using rho*cp*\u0394T to calculate the energy absorbed by the fluid. There are problems with this formula, the most obvious one being that it doesn't take velocity into account. And it is not proper to use transient calculations to verify energy conservation.\n@lindsayad wrote an input file for verifying energy conservation using steady-state calculations. He integrates rho*cp*u*\u25bdT to get the energy absorbed by the fluid. Together with the energy of the reaction term, it is exactly equal to the energy released by the solid region.\nIt should be noted that the thermal conductivity equation in the solid region is -k\u25bd\u00b2T=0, while all boundary conditions are \u25bdT=0. Under the above conditions, a definite solution cannot be obtained. So @lindsayad adds a reaction term to the steady state heat conduction equation in the solid region, which is used to remove the null-space in the temperature equation.\nHere is the input file written by @lindsayad:\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    nx = 10\n    ny = 10\n    dim = 2\n  []\n  [subdomain]\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0.5 0 0'\n    top_right = '1 1 0'\n    block_id = 1\n    input = gen\n  []\n  [break_boundary]\n    input = subdomain\n    type = BreakBoundaryOnSubdomainGenerator\n    boundaries = 'bottom top'\n  []\n  [sideset]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = break_boundary\n    primary_block = '1'\n    paired_block = '0'\n    new_boundary = 'fluid_left'\n  []\n  coord_type = RZ\n  second_order = true\n[]\n\n[Variables]\n  [T]\n    order = SECOND\n  []\n  [velocity]\n    family = LAGRANGE_VEC\n    order = SECOND\n    block = 1\n  []\n  [pressure]\n    block = 1\n  []\n[]\n\n[ICs]\n  [vel]\n    type = VectorConstantIC\n    variable = velocity\n    x_value = 1e-15\n    y_value = 1e-15\n    block = 1\n  []\n[]\n\n[Kernels]\n  [mass]\n    type = INSADMass\n    variable = pressure\n    block = 1\n  []\n\n  [momentum_convection]\n    type = INSADMomentumAdvection\n    variable = velocity\n    block = 1\n  []\n  [momentum_viscous]\n    type = INSADMomentumViscous\n    variable = velocity\n    block = 1\n  []\n  [momentum_pressure]\n    type = INSADMomentumPressure\n    variable = velocity\n    pressure = pressure\n    integrate_p_by_parts = true\n    block = 1\n  []\n\n  [temperature_advection]\n    type = INSADEnergyAdvection\n    variable = T\n     block = 1\n  []\n  [temperature_conduction]\n    type = ADHeatConduction\n    variable = T\n    thermal_conductivity = 'k'\n  []\n  [heat_source]\n    type = BodyForce\n    variable = T\n    block = 0\n    function = 'x + y'\n  []\n  [remove_null_space]\n    variable = T\n    block = 0\n    type = Reaction\n  []\n[]\n\n[BCs]\n  [velocity_inlet]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    function_y = 1\n    boundary = 'bottom_to_1'\n  []\n  [wall]\n    type = VectorFunctionDirichletBC\n    variable = velocity\n    boundary = 'fluid_left right'\n  []\n[]\n\n[Materials]\n  [constant]\n    type = ADGenericConstantMaterial\n    prop_names = 'cp rho k mu'\n    prop_values = '1 1   1 1'\n  []\n  [ins]\n    type = INSAD3Eqn\n    pressure = pressure\n    velocity = velocity\n    temperature = T\n    block = 1\n  []\n[]\n\n[Executioner]\n  type = Steady\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_shift_type'\n  petsc_options_value = 'lu       NONZERO'\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n[Postprocessors]\n  [reaction]\n    type = ElementIntegralVariablePostprocessor\n    variable = T\n    block = 0\n  []\n  [advection]\n    type = INSADElementIntegralEnergyAdvection\n    temperature = T\n    velocity = velocity\n    cp = cp\n    rho = rho\n    block = 1\n  []\n  [source]\n    type = FunctionElementIntegral\n    function = 'x + y'\n    block = 0\n  []\n  [sum]\n    type = ParsedPostprocessor\n    function = 'reaction + advection - source'\n    pp_names = 'reaction advection source'\n  []\n[]\n\nSincere thanks to @lindsayad @hugary1995 @GiudGiud for their patient replies.",
                  "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3653072",
                  "updatedAt": "2022-09-15T11:39:12Z",
                  "publishedAt": "2022-09-15T11:37:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Thanks for the summary @js-jixu. Can you mark this discussion as answered?",
                          "url": "https://github.com/idaholab/moose/discussions/21966#discussioncomment-3657017",
                          "updatedAt": "2022-09-15T19:50:39Z",
                          "publishedAt": "2022-09-15T19:50:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Gasket type elements",
          "author": {
            "login": "srinath-chakravarthy"
          },
          "bodyText": "Hi all,\nI would like to develop a gasket type element. One example of this is a QUAD4 element with 4 nodes, however with integration points lying on the mid-plane between bottom and top of the element. How would i go about doing this ?.I have looked at libmesh/elem and libmesh/gaussian_quad. So would i just define a new element QUAD4G and attach a default new quadrature rule to this element ? If so how would i integrate this into moose.\nIn essence this will be like a finite-thickness traditional cohesive element. The nice thing is the finite thckness version is non-singular and can presumably use all existing moose methods.\nI understand that there is a DG version of cohesive element in moose, but i am not able to decipher if this can be used for a finite thickness context.\nCheers\nSrinath",
          "url": "https://github.com/idaholab/moose/discussions/22082",
          "updatedAt": "2022-09-29T16:52:16Z",
          "publishedAt": "2022-09-13T15:19:15Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "Any suggestions anyone ?",
                  "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3647776",
                  "updatedAt": "2022-09-14T19:20:41Z",
                  "publishedAt": "2022-09-14T19:20:40Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@roystgnr",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3648145",
                          "updatedAt": "2022-09-14T20:23:40Z",
                          "publishedAt": "2022-09-14T20:23:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "There seems to be a bit of language difference here - the midplane between the top and bottom of a Quad4 with planar nodes is the Quad4 - it's a Face, a 2-D manifold (albeit not planar in the general case; you can have a \"twist\" between opposing edges) element. You can use it to solve an approximation to a 3-D problem, but that happens in the problem formulation (in the kernel), not the Elem.\nMaybe that's a bigger language difference?  The combination of geometric Elem and FE space and physics kernel all together is what other idioms sometimes lump together as an \"element\" ... but IMHO trying to explicitly add every combination ahead of time is like insisting on finding the \"element name\" key on a keyboard that already has e,l,m,n,t, and a.\nWhen I solve shallow water flow on a quad mesh, I don't need to define QUAD4S as a new ElemType; the depth-integrated equations went from 3D to 2D, so I just derive a weak form, add FE variables (which is what defines the \"Finite Element\" in the mathematical sense; it's not just the geometric element), and then I'd probably use Gaussian quadrature to solve those, but that all works with standard quads and/or triangles on a 2D domain, because while there's a 3D physics, in that formulation it's entirely defined by the 2D depth-averaged equations.  Or suppose I had a beam equation - I might add displacement variables with FEType of HERMITE to solve the $C^1$ weak form, or twice as many variables (e.g. displacements plus rotations) with some $C^0$ type like LAGRANGE to solve a mixed form, but either way I'd be solving on an ordinary EDGE2 or EDGE3 mesh.\nIn your case, then?  What you need to write depends on the shape function and quadrature details.  If you can describe a solution solely on an hex element's midplane and there's a canonical way to extrapolate from that quad midplane to the full hex, then you can almost certainly run on a standard Quad4 or Quad9.  Can you write the space of shape functions on that plane with (a tensor product of!) existing spaces in libMesh?  If so then you're good to go there too; if not then that's what you'll end up having to write a new FE subclass and FEType for.  Are your quadrature points described by one of the standard rules?  Even if not then you definitely don't want to try to edit the Gaussian quadrature, which already has a standard definition on quads, but in that case you'll have to add your own QBase subclass and corresponding QuadratureType.",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3648418",
                          "updatedAt": "2022-09-14T21:13:12Z",
                          "publishedAt": "2022-09-14T21:13:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I believe there's a misunderstanding. @srinath-chakravarthy was asking for a genuine new type of quadrature rule. He was talking about Quad4 in 2-D as a volume element instead of Quad4 in 3-D as a face element. Instead of the standard Gaussian quadrature, he wants to place quadrature points along the midline (not midplane) of the Quad4 element. So I think @roystgnr 's suggestion towards the end should apply.\nWhat I have trouble understanding is that a Quad4 element has two orthogonal midlines, how do you want to tell the new quadrature rule to use one over the other @srinath-chakravarthy ?",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655611",
                          "updatedAt": "2022-09-15T16:22:20Z",
                          "publishedAt": "2022-09-15T16:22:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "ok, I can see that Abaqus has its own convention :-)\nhttps://classes.engineering.wustl.edu/2009/spring/mase5513/abaqus/docs/v6.6/books/usb/default.htm?startat=pt06ch26s06alm47.html",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655652",
                          "updatedAt": "2022-09-15T16:25:35Z",
                          "publishedAt": "2022-09-15T16:25:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "Oh, the midline!  I was imaging a new type of shell element.  Thanks for clarifying!\nYeah, \"your own QBase subclass and corresponding QuadratureType\" would be the way to go here.\n\na Quad4 element has two orthogonal midlines, how do you want to tell the new quadrature rule to use one over the other\n\nThat's actually doable in the mesh generator - since we always map elem->point(0) in physical space back to (-1,-1) in master space (and then go counter-clockwise from there), a quadrature rule that always returns points on the xi axis will always return points on the midline bisecting edges 03 and 12; a rule that always returns points on the eta axis will always return points on the line bisecting 01 and 32",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655667",
                          "updatedAt": "2022-09-15T16:27:06Z",
                          "publishedAt": "2022-09-15T16:27:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "srinath-chakravarthy"
                          },
                          "bodyText": "@hugary1995  thanks for clarifying and @roystgnr for the suggestions. The quadrature point definition is rather easy on the libmesh side. How would i go about the moose part of it, namely attaching this quadrature rule to the Quad4 element ?\n\nThat's actually doable in the mesh generator - since we always map elem->point(0) in physical space back to (-1,-1) in master space (and then go counter-clockwise from there), a quadrature rule that always returns points on the xi axis will always return points on the midline bisecting edges 03 and 12; a rule that always returns points on the eta axis will always return points on the line bisecting 01 and 32\",\nThis would mean i have to make sure that the physical point(0) and side (0,3) and side (1,2) is oriented in the direction of interest ?",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655804",
                          "updatedAt": "2022-09-15T16:42:04Z",
                          "publishedAt": "2022-09-15T16:42:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think once you set up your quadrature rule, you just need to add it to enum_quadrature_type.h. Then the SetupQuadratureAction in MOOSE should be able to pick that up automatically.",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655888",
                          "updatedAt": "2022-09-15T16:53:46Z",
                          "publishedAt": "2022-09-15T16:53:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Oh and also update the conversion table in Conversion.C::initQuadratureType().",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3655939",
                          "updatedAt": "2022-09-15T16:59:11Z",
                          "publishedAt": "2022-09-15T16:59:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "On the libMesh side there's a few places to edit besides the new subclass's files and enum_quadrature_type.h - we'd need a case in quadrature_build.C, a map entry in string_to_enum.C, and we'd really want an instantiation in quadrature_test.C except that I'm not sure the tests there are appropriate for something that's underintegrating in that way.\nOff topic from the conversation here, but I don't like that manual code in Conversion.C.  It has to be edited to add new enums now, but ideally we wouldn't be having to change anything at all in MOOSE.  C++ doesn't even support enough reflection to iterate over a sparse enum's valid values, but maybe libMesh should provide some kind of container (a constexpr initializer_list??) of enum values and then Conversion.C could iterate over that and do enum_to_string (and prepend that extra Q) with each.  We have to write string conversions in libMesh for new enum entries, but we ought to be able to get away with not writing a redundant isomorphic conversion elsewhere.",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3656305",
                          "updatedAt": "2022-09-15T17:48:35Z",
                          "publishedAt": "2022-09-15T17:48:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Off topic from the conversation here, but I don't like that manual code in Conversion.C. It has to be edited to add new enums now, but ideally we wouldn't be having to change anything at all in MOOSE. C++ doesn't even support enough reflection to iterate over a sparse enum's valid values, but maybe libMesh should provide some kind of container (a constexpr initializer_list??) of enum values and then Conversion.C could iterate over that and do enum_to_string (and prepend that extra Q) with each. We have to write string conversions in libMesh for new enum entries, but we ought to be able to get away with not writing a redundant isomorphic conversion elsewhere.\n\nYep, you are apparently on top of this #17810",
                          "url": "https://github.com/idaholab/moose/discussions/22082#discussioncomment-3656436",
                          "updatedAt": "2022-09-15T18:09:48Z",
                          "publishedAt": "2022-09-15T18:09:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Tracking maximum value for a variable over time",
          "author": {
            "login": "skv94"
          },
          "bodyText": "Hello,\nI am simulating a coupled reaction-diffusion system that results in temperature spikes. I am interested in tracking the maximum temperature for the entire domain over the course of the simulation in order to generate a maximum temperature contour. I am currently doing this by generating output files, reading them in Paraview, saving the results as csv files, and then using a postprocessing script in MATLAB to generate the contour as showed below.\n\nHowever, this is quite time consuming and I was wondering if it is possible to use Postprocessors to keep track of the maximum temperature over all time steps. I tried to use a combination of the 'NodalExtremeValue' and 'TimeExtremeValue' postprocessors, but that simply outputs a scalar corresponding to the node with the highest temperature for each time step.\nCan I please get some advice?\nThanks in advance.",
          "url": "https://github.com/idaholab/moose/discussions/22104",
          "updatedAt": "2022-09-29T16:52:54Z",
          "publishedAt": "2022-09-15T13:05:04Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You could use a combination of auxkernels to achieve this\n[AuxVariables]\n  [T_old]\n    [AuxKernel]\n      type = ParsedAux\n      args = 'T'\n      function = 'T'\n      execute_on = 'INITIAL TIMESTEP_END'\n    []\n  []\n  [T_max]\n    [AuxKernel]\n      type = ParsedAux\n      args = 'T T_old'\n      function = 'if(T>T_old, T, T_old)'\n      execute_on = 'LINEAR'\n    []\n  []\n[]\nThe trick is in the execute_on flags.",
                  "url": "https://github.com/idaholab/moose/discussions/22104#discussioncomment-3654140",
                  "updatedAt": "2022-09-15T13:51:23Z",
                  "publishedAt": "2022-09-15T13:51:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "same trick with a ParsedPostprocessor should work",
                          "url": "https://github.com/idaholab/moose/discussions/22104#discussioncomment-3654916",
                          "updatedAt": "2022-09-15T15:09:06Z",
                          "publishedAt": "2022-09-15T15:09:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "ya, although I guess OP was asking for something like what's shown in the image. Anyways...",
                          "url": "https://github.com/idaholab/moose/discussions/22104#discussioncomment-3655387",
                          "updatedAt": "2022-09-15T15:56:56Z",
                          "publishedAt": "2022-09-15T15:56:55Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Interial Forces and Velocity Aux",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "The below input file snippet is from pull_and_shear.i. I am working on a dynamics problem and I was looking at some tests. I see here that the NewmarkVelAux as well as the acceleration aux is only run on timestep_end. Is this just for this test? For an implicit problem, I need this turn run on Linear?\n  [inertia_x] # M*accel + eta*M*vel\n    type = InertialForce\n    use_displaced_mesh = false\n    variable = disp_x\n    velocity = vel_x\n    acceleration = accel_x\n  []\n\n  [vel_x] # Calculates and stores velocity at the end of the time step\n    type = NewmarkVelAux\n    variable = vel_x\n    acceleration = accel_x\n    execute_on = timestep_end\n  []",
          "url": "https://github.com/idaholab/moose/discussions/22096",
          "updatedAt": "2022-09-15T15:30:34Z",
          "publishedAt": "2022-09-14T20:16:37Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "maxnezdyur"
                  },
                  "bodyText": "Never mind, I see that IntertialForce computes the current velocity and acceleration within its own kernel. I mistakenly thought that it used the current velocity and acceleration from the AuxKernel.",
                  "url": "https://github.com/idaholab/moose/discussions/22096#discussioncomment-3652736",
                  "updatedAt": "2022-09-15T10:51:01Z",
                  "publishedAt": "2022-09-15T10:51:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "That's correct.",
                          "url": "https://github.com/idaholab/moose/discussions/22096#discussioncomment-3655110",
                          "updatedAt": "2022-09-15T15:30:35Z",
                          "publishedAt": "2022-09-15T15:30:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get variable gradient at nodes",
          "author": {
            "login": "xiaojbing"
          },
          "bodyText": "I use monomial basic function to discrete my variable. I want to get variable value and variable gradient at nodes of current element to compute a coneffient every timestep.\nI try to use getNodalValue() function\n _mv_fe_problem(*parameters.getCheckedPointerParam<FEProblemBase *>(\"_fe_problem_base\"))\nauto &_variable  = _mv_fe_problem.getStandardVariable(_tid, var_name[i]);\n_variable->getNodalValue(*_current_elem->node_ptr(i))\n\nto get nodal variable value.\nbut I can not find a function to get variable gradient at nodes. How to achieve this?",
          "url": "https://github.com/idaholab/moose/discussions/22098",
          "updatedAt": "2022-09-29T16:59:44Z",
          "publishedAt": "2022-09-15T01:40:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you using the monomial basis function or constant monomials in particular?\nWhy do you want nodal values? It's often better to work with quadrature point values\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22098#discussioncomment-3650365",
                  "updatedAt": "2022-09-15T05:04:34Z",
                  "publishedAt": "2022-09-15T05:04:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "not using constant monomial. In the iterative calculation process, I do use the orthogonal points, and the purpose of getting the node value is to calculate a coefficient, and the calculation of this coefficient rely on the variable value at the node and the variable gradient at nodes. Finally this coefficient will be coupled into my kernel calculation",
                          "url": "https://github.com/idaholab/moose/discussions/22098#discussioncomment-3650657",
                          "updatedAt": "2022-09-15T06:00:35Z",
                          "publishedAt": "2022-09-15T06:00:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Seems like all this should happen at quadrature points to me.\nIf you want to do it at quadrature points you can use the\ncoupledValue and coupledGradient routines from the Coupleable interface.\nNodes are generally quadrature points for nodal variables so I think this should work.\nWhich FE family are you using exactly? what does the variables block look like?",
                          "url": "https://github.com/idaholab/moose/discussions/22098#discussioncomment-3650813",
                          "updatedAt": "2022-09-15T06:28:32Z",
                          "publishedAt": "2022-09-15T06:28:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xiaojbing"
                          },
                          "bodyText": "just like\n[Variables]\n    order = SECOND\n    family = MONOMIAL\n    variables = 'density momx momy momz rhoe'\n []",
                          "url": "https://github.com/idaholab/moose/discussions/22098#discussioncomment-3650898",
                          "updatedAt": "2022-09-15T06:40:24Z",
                          "publishedAt": "2022-09-15T06:40:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "umm never used that syntax. I m used to\n[Variables]\n   [density]\n      order = SECOND\n      family = MONOMIAL\n    []\n...\n []",
                          "url": "https://github.com/idaholab/moose/discussions/22098#discussioncomment-3654966",
                          "updatedAt": "2022-09-15T15:14:47Z",
                          "publishedAt": "2022-09-15T15:14:47Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Utilizing Piecewise Linear function",
          "author": {
            "login": "Aayush-T"
          },
          "bodyText": "Hi everyone, I am trying to do a strain controlled uniaxial fatigue simulation with a specific strain rate with triangular waveform. The specimen is as shown in the figure below with dimensions as 2 x 3 x 7. For that, I applied displacement along z direction using the PiecewiseLinear function as shown below. The csv file contains first column as time-step and second as displacement. The strain rate I wanted was 0.0003 with strain amplitude upto 0.006. So, gave the displacement rate as (0.0003*7 =) 0.0021 and displacement amplitude upto 0.042.\n\n[Functions]\n  [./tdisp]\n  type = PiecewiseLinear\n  data_file = function_0_042.csv\n  format = columns\n  [../]\n\n\nBut on running the simulation, due to convergence issues, it went for time steps as 0.5 in place of 1 and that messed up the whole system and I got the displacement and strain as\n\nAs can be seen, it started as expected but later failed in getting expected result.\nThe BCs were taken as\n[BCs]\n  [symmx] \n    type = DirichletBC\n    variable = disp_x\n    boundary = x0\n    value = 0\n  []\n  [symmy] \n    type = DirichletBC\n    variable = disp_y\n    boundary = y0\n    value = 0\n  []\n  [symmz]\n    type = DirichletBC\n    variable = disp_z\n    boundary = z0\n    value = 0\n  []\n  [tdisp] \n    type = FunctionDirichletBC\n    variable = disp_z\n    boundary = z1\n    function = tdisp\n  []\n[]\n\nPlease help with the situation.\nThanks and Regards",
          "url": "https://github.com/idaholab/moose/discussions/21953",
          "updatedAt": "2022-09-15T12:38:10Z",
          "publishedAt": "2022-08-29T06:52:51Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Could you please post your input file, or at least your Postprocessors.  For instance, your output csv might be recording this type of Postprocessor:\n[tdisp]\n  type = PointValue\n  point = '0 0 7'\n  variable = disp_z\n[]\n\n(which is probably what you want) or it might be recording this type of Postprocessor\n[tdisp]\n  type = PointValue\n  point = '0 0 7'\n  variable = disp_z\n  use_displaced_mesh = true\n[]\n\na",
                  "url": "https://github.com/idaholab/moose/discussions/21953#discussioncomment-3498721",
                  "updatedAt": "2022-08-29T09:30:07Z",
                  "publishedAt": "2022-08-29T09:30:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Aayush-T"
                          },
                          "bodyText": "Hi, thanks for response. This is how the postprocessor and solver parts are.\nThe problem as I understand is related to some numerical error.\nThe mesh file was made using neper.\n[Postprocessors]\n\n[./tdisp]\n  type = ElementAverageValue\n  variable = tdisp\n[../]\n\n  [./e_zz]\n    type = ElementAverageValue\n    variable = e_zz\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n\n  petsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -ksp_type -ksp_gmres_restart'\n  petsc_options_value = ' asm      2              lu            gmres     200'\n  nl_abs_tol = 1e-10\n  nl_rel_tol = 1e-10\n  nl_abs_step_tol = 1e-10\n\n  dt = 1\n  dtmax = 1\n  dtmin = 0.00000001\n\n  num_steps = 100\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/21953#discussioncomment-3523896",
                          "updatedAt": "2022-09-01T15:34:18Z",
                          "publishedAt": "2022-09-01T06:46:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nwhere are x0, y0 and z0, the boundaries for the BC?\nThe two postprocessors you have here are averages over the whole domain.\nI dont think we expect what you want there? It should only be over a boundary?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21953#discussioncomment-3528349",
                  "updatedAt": "2022-09-01T15:41:37Z",
                  "publishedAt": "2022-09-01T15:41:36Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@Aayush-T  I attach below an example input file where I define the load surface as a block of elements and I average the state variables over those elements, so that you can find the average values at the surface, for instance for a stress-strain curve, hope that helps.\n[GlobalParams]\n  displacements = 'ux uy uz'\n[]\n\n[Mesh]\n  [./polycrystal_generated_mesh]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 10\n    ny = 7\n    nz = 1\n    xmax = 75.0\n    ymax = 52.5\n    zmax = 7.5\n    elem_type = HEX8\n    displacements = 'ux uy uz'\n  [../]\n  [./add_load_surface]\n    type = SubdomainBoundingBoxGenerator\n    input = polycrystal_generated_mesh\n    bottom_left = '67.4 -0.001 -0.001'\n\ttop_right = '75.1 55.5 8.0'\n    block_id = 1\n\tblock_name = 'elements_on_load_surface'\n\tlocation = 'INSIDE'\n  [../]\n[]\n\n[Variables]\n  [./ux]\n    order = FIRST\n    family = LAGRANGE\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.0\n    [../]\n  [../]\n\n  [./uy]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  [./uz]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n[Modules/TensorMechanics/Master/all]\n  strain = FINITE\n  add_variables = true\n  generate_output = stress_xx\n[]\n\n[AuxVariables]\n\n  # slip_increment is the slip rate\n  # so units are 1/time\n  [./slip_increment_1]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n  [./slip_increment_2]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n  [./slip_increment_3]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n  [./slip_increment_4]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n  [./slip_increment_5]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n  [./slip_increment_6]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n  [./slip_increment_7]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n  [./slip_increment_8]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n  [./slip_increment_9]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n  [./slip_increment_10]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n  [./slip_increment_11]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n  [./slip_increment_12]\n   order = FIRST\n   family = MONOMIAL\n  [../]\n\n  [./slip_increment_vector]\n    order = FIRST\n    family = MONOMIAL\n    components = 12\n  [../]\n\n  [./dslip_increment_dedge]\n    order = CONSTANT\n    family = MONOMIAL\n    components = 12\n  [../]\n  \n  [./dslip_increment_dscrew]\n    order = CONSTANT\n    family = MONOMIAL\n    components = 12\n  [../]\n  \n  [./rho_ssd_1]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  \n  [./slip_resistance_1]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  \n  [./euler1]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./euler2]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  [./euler3]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n[]\n\n[UserObjects]\n  [./prop_read]\n    type = GrainPropertyReadFile\n    prop_file_name = 'Grain20EBSDf100.txt'\n    nprop = 3\n    read_type = element\n  [../]\n[]\n\n[Functions]\n\n  [./disp_load]\n    type = ParsedFunction\n    value = '75.0*0.01*t/60.0'\n  [../]\n\n[]\n\n[AuxKernels]\n\n  [./slip_increment_1]\n   type = MaterialStdVectorAux\n   variable = slip_increment_1\n   property = slip_increment\n   index = 0\n   execute_on = timestep_end\n  [../]\n  [./slip_increment_2]\n   type = MaterialStdVectorAux\n   variable = slip_increment_2\n   property = slip_increment\n   index = 1\n   execute_on = timestep_end\n  [../]\n  [./slip_increment_3]\n   type = MaterialStdVectorAux\n   variable = slip_increment_3   \n   property = slip_increment\n   index = 2\n   execute_on = timestep_end\n  [../]\n  [./slip_increment_4]\n   type = MaterialStdVectorAux\n   variable = slip_increment_4\n   property = slip_increment\n   index = 3\n   execute_on = timestep_end\n  [../]\n  [./slip_increment_5]\n   type = MaterialStdVectorAux\n   variable = slip_increment_5\n   property = slip_increment\n   index = 4\n   execute_on = timestep_end\n  [../]\n  [./slip_increment_6]\n   type = MaterialStdVectorAux\n   variable = slip_increment_6\n   property = slip_increment\n   index = 5\n   execute_on = timestep_end\n  [../]\n  [./slip_increment_7]\n   type = MaterialStdVectorAux\n   variable = slip_increment_7   \n   property = slip_increment\n   index = 6\n   execute_on = timestep_end\n  [../]\n  [./slip_increment_8]\n   type = MaterialStdVectorAux\n   variable = slip_increment_8\n   property = slip_increment\n   index = 7\n   execute_on = timestep_end\n  [../]\n  [./slip_increment_9]\n   type = MaterialStdVectorAux\n   variable = slip_increment_9\n   property = slip_increment\n   index = 8\n   execute_on = timestep_end\n  [../]\n  [./slip_increment_10]\n   type = MaterialStdVectorAux\n   variable = slip_increment_10\n   property = slip_increment\n   index = 9\n   execute_on = timestep_end\n  [../]\n  [./slip_increment_11]\n   type = MaterialStdVectorAux\n   variable = slip_increment_11   \n   property = slip_increment\n   index = 10\n   execute_on = timestep_end\n  [../]\n  [./slip_increment_12]\n   type = MaterialStdVectorAux\n   variable = slip_increment_12\n   property = slip_increment\n   index = 11\n   execute_on = timestep_end\n  [../]\n\n  [./build_slip_increment_vector]\n    type = BuildArrayVariableAux\n    variable = slip_increment_vector\n    component_variables = 'slip_increment_1 slip_increment_2 slip_increment_3 slip_increment_4 slip_increment_5 slip_increment_6 slip_increment_7 slip_increment_8 slip_increment_9 slip_increment_10 slip_increment_11 slip_increment_12'\n  [../]\n\n  [./edge_directional_derivative]\n    type = ArrayDirectionalDerivative\n    variable = dslip_increment_dedge\n    gradient_variable = slip_increment_vector\n    dislo_character = edge\n  \texecute_on = timestep_end\n  [../]\n  \n  [./screw_directional_derivative]\n    type = ArrayDirectionalDerivative\n    variable = dslip_increment_dscrew\n    gradient_variable = slip_increment_vector\n    dislo_character = screw\n  \texecute_on = timestep_end\n  [../]  \n  \n  [./rho_ssd_1]\n    type = MaterialStdVectorAux\n    variable = rho_ssd_1\n    property = rho_ssd\n    index = 0\n    execute_on = timestep_end\n  [../]\n  \n  [./slip_resistance_1]\n    type = MaterialStdVectorAux\n    variable = slip_resistance_1\n    property = slip_resistance\n    index = 0\n    execute_on = timestep_end\n  [../]\n  \n  [./euler1]\n    type = MaterialRealVectorValueAux\n    variable = euler1\n    property = Euler_angles\n    component = 0\n    execute_on = timestep_end\n  [../]\n  [./euler2]\n    type = MaterialRealVectorValueAux\n    variable = euler2\n    property = Euler_angles\n    component = 1\n    execute_on = timestep_end\n  [../]\n  [./euler3]\n    type = MaterialRealVectorValueAux\n    variable = euler3\n    property = Euler_angles\n    component = 2\n    execute_on = timestep_end\n  [../]\n  \n[]\n\n[BCs]\n  [./z0_back]\n    type = DirichletBC\n    variable = uz\n    boundary = back\n    value = 0.0\n  [../]\n\n  [./y0_bottom]\n    type = DirichletBC\n    variable = uy\n    boundary = bottom\n    value = 0.0\n  [../]\n  \n  [./x0_left]\n    type = DirichletBC\n    variable = ux\n    boundary = left\n    value = 0.0\n  [../]\n\n  [./x1_right]\n    type = FunctionDirichletBC\n    variable = ux\n    boundary = right\n    function = disp_load\n  [../]\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensorCPGrain\n    C_ijkl = '2.046e5 1.377e5 1.377e5 2.046e5 1.377e5 2.046e5 1.262e5 1.262e5 1.262e5'\n    fill_method = symmetric9\n    read_prop_user_object = prop_read\n  [../]\n  [./stress]\n    type = ComputeDislocationCrystalPlasticityStress\n    crystal_plasticity_models = 'trial_xtalpl'\n    tan_mod_type = exact\n    maximum_substep_iteration = 2\n\tmaxiter = 500\n\tmaxiter_state_variable = 500\n  [../]\n  [./trial_xtalpl]\n    type = CrystalPlasticityDislocationUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = input_slip_sys.txt\n\tao = 0.001\n\txm = 0.1\n\tburgers_vector_mag = 0.000256\n\tshear_modulus = 86000.0 # MPa\n\talpha_0 = 0.3\n\tr = 1.4\n\ttau_c_0 = 0.112\n\tk_0 = 0.04347\n\ty_c = 0.0026\n\tinit_rho_ssd = 31.5\n\tinit_rho_gnd_edge = 0.0\n\tinit_rho_gnd_screw = 0.0\n\t# These activate slip gradients\n\t# they are compulsory\n\t# codes currently has problems if not introduced\n\t# to remove slip gradients, zero arrays can be passed\n\tdslip_increment_dedge = dslip_increment_dedge\n\tdslip_increment_dscrew = dslip_increment_dscrew\n\tslip_increment_tolerance = 2.0\n\tstol = 0.1\n\tresistance_tol = 1.0\n\tprint_state_variable_convergence_error_messages = true\n  [../]\n[]\n\n[Postprocessors]\n  [stress_on_load_surface]\n    type = ElementAverageValue\n    variable = stress_xx\n\tblock = 'elements_on_load_surface'\n    use_displaced_mesh = true\n  []\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  dt = 1.0\n  solve_type = 'PJFNK'\n\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths -pc_hypre_boomeramg_max_levels -pc_hypre_boomeramg_coarsen_type -pc_hypre_boomeramg_interp_type -pc_hypre_boomeramg_P_max -pc_hypre_boomeramg_truncfactor -pc_hypre_boomeramg_print_statistics'\n  petsc_options_value = 'hypre boomeramg 51 0.7 4 5 25 PMIS ext+i 2 0.3 0'\n\n  line_search = 'none'\n\n  automatic_scaling = true\n  \n  nl_abs_tol = 1e-5\n  nl_rel_tol = 1e-5\n  \n  end_time = 1338.0\n  dtmin = 0.00001\n\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  interval = 42\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/21953#discussioncomment-3559848",
                  "updatedAt": "2022-09-13T23:57:11Z",
                  "publishedAt": "2022-09-05T13:27:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Aayush-T"
                          },
                          "bodyText": "Hi. Sorry I took a long time to update the situation. I was trying to utilize the given solutions. Thank you so much. The problem that I faced is essentially due to large timestep value that I took and that is why the convergence issues were coming. The reason I took large timesteps was as shown above, I put a data file to read for piecewise function and if I have to do a lot of cycles for triangular waveform, I have to have that many lines in the data file.\n[Functions]\n  [./tdisp]\n  type = PiecewiseLinear\n  **data_file = function_0_042.csv**\n[function_0_042.csv](https://github.com/idaholab/moose/files/9553909/function_0_042.csv)\n\n  format = columns\n  [../]\n\nEg. One triangular waveform cycle require 80 lines in the file at a timestep of 1. If I make timestep smaller, eg. 0.05, it will require 1600 lines, and if I need to run a simulation for 50 cycles, I will have to repeat these lines for 80000 times.\nOne solution I am thinking is I will write a script file that can copy the data repeatedly for me. If there is a better way, please suggest.\nThanks and Regards",
                          "url": "https://github.com/idaholab/moose/discussions/21953#discussioncomment-3632007",
                          "updatedAt": "2022-09-13T23:57:32Z",
                          "publishedAt": "2022-09-13T05:56:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So you are trying to resolve the shape closer with the data file? Isnt it linear since it's triangular??\nThe PiecewiseLinear does linear interpolation between each point in your data file, so unless you are trying to resolve a non linear shape more, you dont need to increase the number of points in the data file?",
                          "url": "https://github.com/idaholab/moose/discussions/21953#discussioncomment-3639835",
                          "updatedAt": "2022-09-13T23:59:56Z",
                          "publishedAt": "2022-09-13T23:59:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Aayush-T"
                          },
                          "bodyText": "Yes thank you. It works absolutely fine for the linear data, I tried doing it for some non-linear data some times back and I had to write a lot of lines, so I assumed it to happen in the case of triangular waveform too.",
                          "url": "https://github.com/idaholab/moose/discussions/21953#discussioncomment-3653500",
                          "updatedAt": "2022-09-15T12:36:38Z",
                          "publishedAt": "2022-09-15T12:36:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can MOOSE sample the values of nodal variable(s) at each quadrature point in the domain?",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "I know the NodalValueSampler can sample nodal variables at each node in the domain. I want to know if there is a vectorpostprocessor can sample nodal variables at each quadrature point in the domain? By the way, I find the Sampler1DReal in Thermal Hydraulics Module. Sampler1DReal can sample material properties at all quadrature points in mesh block, maybe I can modify the Sampler1DReal to obtain the nodal variables at each quadrature point? But I'm not sure if it is too hard.\nEthan",
          "url": "https://github.com/idaholab/moose/discussions/22100",
          "updatedAt": "2022-09-29T16:59:34Z",
          "publishedAt": "2022-09-15T02:00:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you convert a nodal variable to a material property using a ParsedMaterial>? (I ve never done it)\nThen you could just use the MaterialVPP to get it at quadrature points\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/MaterialVectorPostprocessor.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22100#discussioncomment-3650204",
                  "updatedAt": "2022-09-15T04:23:59Z",
                  "publishedAt": "2022-09-15T04:23:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "That sounds clever! I will have a try!",
                          "url": "https://github.com/idaholab/moose/discussions/22100#discussioncomment-3650882",
                          "updatedAt": "2022-09-15T06:38:36Z",
                          "publishedAt": "2022-09-15T06:38:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about MOOSE output",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nI am running simulations with the CH equation using MOOSE. I am using the split form for solving this CH equation in MOOSE.\nThe following is the CH equation and chemical potential.\n\n\nThis is the kernels I used to solve the CH equation.\n\nThe following is the flux. I want to plot the two red parts shown in the flux's expression. One is the derivative of free energy function wrt concentration as a function of location, another is Laplacian of concentration as a function of location.\nHow can I directly get these two parts' value from my MOOSE output file? What are the names of these two parts in the output file?\n\nCould you please give me some advice?\nThank you very much.\nBest,",
          "url": "https://github.com/idaholab/moose/discussions/22086",
          "updatedAt": "2022-09-29T16:59:24Z",
          "publishedAt": "2022-09-13T22:20:14Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dschwen does this already exist as an auxiliary kernel?\nIf not, you ll have to make an auxkernel to output this",
                  "url": "https://github.com/idaholab/moose/discussions/22086#discussioncomment-3639483",
                  "updatedAt": "2022-09-13T22:30:37Z",
                  "publishedAt": "2022-09-13T22:30:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "Is there a aux kernel for this? @GiudGiud\nHow to make an auxkernel?",
                          "url": "https://github.com/idaholab/moose/discussions/22086#discussioncomment-3645232",
                          "updatedAt": "2022-09-14T14:20:08Z",
                          "publishedAt": "2022-09-14T14:20:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I doubt it. Daniel will confirm.\nYou should go through the application dev tutorial, or the main tutorial to learn about this\nhttps://mooseframework.inl.gov/workshop/index.html#/\nhttps://mooseframework.inl.gov/getting_started/examples_and_tutorials/tutorial01_app_development/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/22086#discussioncomment-3646906",
                          "updatedAt": "2022-09-14T17:05:34Z",
                          "publishedAt": "2022-09-14T17:05:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "There should be direct way to output this....\nDo you know how to output derivative of free energy function wrt c?",
                          "url": "https://github.com/idaholab/moose/discussions/22086#discussioncomment-3649008",
                          "updatedAt": "2022-09-14T23:39:21Z",
                          "publishedAt": "2022-09-14T23:39:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "I searched DerivativeParsedMaterial in the MOOSE website, and Currently I added the material_property_names='dF:=D[F,c]' in the free energy function block to calculate the derivative of free energy function wrt concentration. I am not sure. Is this correct? Will this influence my free energy function? Could you please give me some advice?",
                          "url": "https://github.com/idaholab/moose/discussions/22086#discussioncomment-3649198",
                          "updatedAt": "2022-09-15T00:22:18Z",
                          "publishedAt": "2022-09-15T00:22:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Addind the derivative will not influence you free energy function\nI m not sure the derivative gets output to exodus. Do you see it?\nIt gets defined for sure so you could use a MaterialRealAux to output it",
                          "url": "https://github.com/idaholab/moose/discussions/22086#discussioncomment-3650448",
                          "updatedAt": "2022-09-15T05:21:02Z",
                          "publishedAt": "2022-09-15T05:21:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}