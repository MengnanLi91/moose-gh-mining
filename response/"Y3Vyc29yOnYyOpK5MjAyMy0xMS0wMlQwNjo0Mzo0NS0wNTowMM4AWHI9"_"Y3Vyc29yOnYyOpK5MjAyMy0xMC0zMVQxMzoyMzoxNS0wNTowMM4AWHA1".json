{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0xMC0zMVQxMzoyMzoxNS0wNTowMM4AWHA1"
    },
    "edges": [
      {
        "node": {
          "title": "Coupling (gradients of) vectors of variables in MOOSE",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "The documentation (https://mooseframework.inl.gov/source/interfaces/Coupleable.html) is not fully clear on this.\nI have the following variables defined in my input file:\n[GlobalParams]\n  q_trans = 'q_trans_x q_trans_y q_trans_z' \n  order = FIRST\n  family = LAGRANGE\n[]\n\n[Variables]\n  [q_trans_x]\n  []\n  \n  [q_trans_y]\n  []\n  \n  [q_trans_z]\n  []\n[]\n\nDefined with the GlobalParams block because I intend to use that vector of variables in several locations. I also have some places where I need to use the individual components alone. The kernel has:\n  [diffuse_x_trans]\n    type = DiffusionFlux\n    variable = q_trans_x\n    component_flux = 0\n    flux_vector = q_trans\n    block = transducer_material\n  []\n\nNow for the source and header- following the syntax in the documentation, I have this declaration:\n    unsigned int _n_vars;\n    std::vector<MooseVariable *> _flux_vars;\n\nAnd this implementation:\n  params.addRequiredCoupledVar(\"flux_vector\", \"Coupled value\");\n\t// Calculates number of components in vector & adds them to C++ vector\n\t_n_vars(coupledComponents(\"flux_vector\"))\n{\n    for (unsigned int i = 0; i < _n_vars; i++)\n      _flux_vars.push_back(dynamic_cast<MooseVariable *>(getVar(\"v\", i)));\n}\n\nWhat I don't understand is this line: \"...Then, individual components can be obtained by calling coupledValue (or any other method mentioned above) passing in the variable name (as usual) and the component index...\"\nDoes the _flux_vars.push_back(dynamic_cast<MooseVariable *>(getVar(\"v\", i))); not save the value of each of the coupled variables in that vector? Where do I call coupledValue? In my case, I want their gradients- where/how do I call coupledGradients? Should I be replacing getVar with something else?\nAnd I understand that all MOOSE variables need to be accessed at the qudrature point being solved. Is the correct syntax _flux_vars[_qp](j) for j=1 to _n_vars? Again, how do I get the gradient of each variable?",
          "url": "https://github.com/idaholab/moose/discussions/25907",
          "updatedAt": "2023-11-02T03:16:55Z",
          "publishedAt": "2023-10-31T06:25:56Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can look at CoupledForce for an example but essentially, coupledValue and getVar are completely separate APIs.\ngetVar is used to get a pointer to the variable, for various purposes but if you need the value you can use (among others) the \"functor interfaces\".\nso (*var)(ElementQpArg (see MooseFunctorArguments.h))\nEDIT: functors not available for array variables!\ncoupledValue is must simpler to use and gets you a reference to the current value of the variable on the Qps of the element. It also handles array variables if that's what you have right now with coupledArrayValue(s).\nYou use it by retrieving the reference in the constructor initializer's list. For example here for 1 component (you ll want to adapt this to retrieve all components, see Coupleable.h)\nIn header:\nconst ArrayVariableValue & var_comp_0;\nin constructor initializer list\n...,\nvar_comp_0(coupledArrayValue(\"var_name_in_parameter\", 0),\n...",
                  "url": "https://github.com/idaholab/moose/discussions/25907#discussioncomment-7434500",
                  "updatedAt": "2023-10-31T12:02:48Z",
                  "publishedAt": "2023-10-31T12:02:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Thank you, that makes sense. Is it possible to define a vector std::vector<ArrayVariableGradient> _flux_vars; so that I can use coupledComponents to find the number of components the user provides, and then do _flux_vars.push_back(coupledArrayGradient(\"var_name_in_parameter\", i);, where i ranges from 0 to the number of components within a for loop? Or do I need to do them all individually?",
                          "url": "https://github.com/idaholab/moose/discussions/25907#discussioncomment-7437224",
                          "updatedAt": "2023-10-31T16:18:12Z",
                          "publishedAt": "2023-10-31T16:17:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So the difficulty with that is that C++ does not support vectors of references (among so many other things, I m not a fan of C++ anymore). And you MUST use references otherwise the (array gradient) value does not get updated\nSo you ll need to do that individually, on a per-variable component basis.\nUnless there is a coupledArrayGradients that gets you a tensor with all the gradients. Did you check the coupleable interface?",
                          "url": "https://github.com/idaholab/moose/discussions/25907#discussioncomment-7437260",
                          "updatedAt": "2023-10-31T17:15:36Z",
                          "publishedAt": "2023-10-31T16:21:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Ah I see. Yeah I checked coupleable and it seems like working with the individual components will have to do for now. Thanks! I'll check back here if I run into issues with that.",
                          "url": "https://github.com/idaholab/moose/discussions/25907#discussioncomment-7437367",
                          "updatedAt": "2023-10-31T16:32:02Z",
                          "publishedAt": "2023-10-31T16:32:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "@GiudGiud does var_comp_0(coupledArrayValue(\"var_name_in_parameter\", 0), retrieve the 1st component in the input file, or does it retrieve the whole vector? Asking because I got an error saying var_comp_0 was a matrix i.e 'const Eigen::Matrix<double, -1, 1>' that went away after I indexed var_comp_0(i)",
                          "url": "https://github.com/idaholab/moose/discussions/25907#discussioncomment-7441046",
                          "updatedAt": "2023-11-01T01:18:39Z",
                          "publishedAt": "2023-11-01T01:18:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Seems the zero you passed is the index in the vector of array variables that you could have passed to the parameter\nSo it s the whole variable",
                          "url": "https://github.com/idaholab/moose/discussions/25907#discussioncomment-7445226",
                          "updatedAt": "2023-11-01T12:28:58Z",
                          "publishedAt": "2023-11-01T12:28:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "CoupledArrayGradient probably behaves the same way you should be able to get all the gradients at once?",
                          "url": "https://github.com/idaholab/moose/discussions/25907#discussioncomment-7445232",
                          "updatedAt": "2023-11-01T12:29:50Z",
                          "publishedAt": "2023-11-01T12:29:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "So I tried with coupledArrayGradient and it ended up giving me a 'const Eigen::Matrix<double, -1, 3>', which seemed to suggest that for the coupledArrayValue, it really is just a single value, even though its storing it in a Matrix? Or what do you think?\nThen I also ran into another problem- I took out the GlobalParameters block and instead define the vector of variables individually at each location I need them. That is, within the relevant blocks,\nv = 'q_trans_x q_trans_y q_trans_z'\nBut I'm getting the error: Variable 'sample_flux_vector' is of a different C++ type than you tried to fetch it as.\nWhen I left in the GlobalParams block, with\n[GlobalParams]\n  q_trans = 'q_trans_x q_trans_y q_trans_z' \n[]\n\nand then\nv = q_trans\nIt said Coupled variable 'q_samp' was not found\nHow am I supposed to define the vector of variables in the input file?",
                          "url": "https://github.com/idaholab/moose/discussions/25907#discussioncomment-7450027",
                          "updatedAt": "2023-11-02T00:12:15Z",
                          "publishedAt": "2023-11-01T21:22:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "I'm suspecting that it has to do with params.addRequiredCoupledVar(\"v\", \"the flux vector of the transducer\"); , but there is no params.addRequiredCoupledArray\nedit: I ended up just coupling each individual variable/gradient I need instead of trying to use an array",
                          "url": "https://github.com/idaholab/moose/discussions/25907#discussioncomment-7450889",
                          "updatedAt": "2023-11-02T01:40:12Z",
                          "publishedAt": "2023-11-01T23:58:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "addRequiredCoupledVar should work the same way for all types of variables. It s the \"get\" or coupeldXX routines that are differenct.\nCoupled variable 'q_samp' was not found is an odd message for the text you have pasted as it does not refer to q_samp anywhere?\nLook for a parameter where you passed q_samp instead of q_trans",
                          "url": "https://github.com/idaholab/moose/discussions/25907#discussioncomment-7451991",
                          "updatedAt": "2023-11-02T03:10:56Z",
                          "publishedAt": "2023-11-02T03:10:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Oh yeah I just edited the variable name to be consistent here, just forgot to edit the error lol. But in the input file I actually had both q_samp and q_trans and had passed q_samp earlier so it saw that one first. Using individual coupled variables as before worked though.",
                          "url": "https://github.com/idaholab/moose/discussions/25907#discussioncomment-7452017",
                          "updatedAt": "2023-11-02T03:16:56Z",
                          "publishedAt": "2023-11-02T03:16:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "2p2c miscible fluids - How to remove everything which comes with the water?",
          "author": {
            "login": "1runer"
          },
          "bodyText": "Hello,\nI would like to simulate water injection and production of water+CH4 in a two-phase two-component miscible system\nand I hope @cpgr or @WilkAndy can help me with a question about DiracKernels.\nThe idea is to inject pure water into an injection well and to produce with a certain flow rate water + CH4 (in all phases).\nI am not quite sure how to set the DiracKernels to remove a certain (known) rate of water (e.g. 5 kg/s)\nand to remove the entire (unknown) CH4 component (as a gas and dissolved in water) so that the total mass fraction of CH4 is basically zero?\nIs the way to track the amount per dt (SumQuantityUO = borehole_total_outflow_gas) correct?\nPlease see the attached code snipped:\n[DiracKernels]\n [inject_H2O]\n    type = PorousFlowPolyLineSink\n    variable = pgas\n    SumQuantityUO = borehole_total_inflow_water\n    # mass_fraction_component = 0\n    point_file = borehole_vert.bh\n    fluid_phase = 0\n    p_or_t_vals = '-1e9 1e9'\n    fluxes = '-1 -1' # kg/m.s * 25 m length * 0.2 m borehole diameter --> 5 kg/s\n  []\n  [produce_H2O]\n    type = PorousFlowPolyLineSink\n    variable = pgas\n    SumQuantityUO = borehole_total_outflow_water\n    point_file = borehole_vert2.bh\n    p_or_t_vals = '-1e9 1e9' # kg/m.s * 25 m length * 0.2 m borehole diameter --> 5 kg/s\n    fluxes = '1 1'\n  []\n  [produce_CH4]\n    type = PorousFlowPolyLineSink\n    SumQuantityUO = borehole_total_outflow_gas\n    fluxes = ??????\n    p_or_t_vals = 0.0\n    mass_fraction_component = 1\n    point_file = borehole_vert2.bh\n    variable = zi\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/25734",
          "updatedAt": "2023-11-01T23:30:11Z",
          "publishedAt": "2023-10-13T00:13:37Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "Ooops, I missed this one. Did you figure it out?",
                  "url": "https://github.com/idaholab/moose/discussions/25734#discussioncomment-7388550",
                  "updatedAt": "2023-10-26T05:47:00Z",
                  "publishedAt": "2023-10-26T05:47:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "1runer"
                          },
                          "bodyText": "I simply multiplied the flow rates by the relative permeability of the phase to get a rate. However, I am not sure if this is the correct/best solution. I thought about something like an outflowBC instead of a Dirac, but this would require an explicitly meshed cross sectional area which we don't have.\n@cpgr do you have a better idea in mind how to remove fluid with a certain rate\nand at the same time remove all CH4 dissolved in the water and which is present as gas phase?\nIn reality the CH4 gas would just migrate towards the surface in the wellbore?\nAnd for sure, how to track the mass rates?",
                          "url": "https://github.com/idaholab/moose/discussions/25734#discussioncomment-7397457",
                          "updatedAt": "2023-10-26T21:35:09Z",
                          "publishedAt": "2023-10-26T21:35:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "That's probably what I would have tried too",
                          "url": "https://github.com/idaholab/moose/discussions/25734#discussioncomment-7415014",
                          "updatedAt": "2023-10-29T10:01:33Z",
                          "publishedAt": "2023-10-29T10:01:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "1runer"
                          },
                          "bodyText": "Is there something comparable like an outflowBC which allows for degassing within a wellbore?",
                          "url": "https://github.com/idaholab/moose/discussions/25734#discussioncomment-7450754",
                          "updatedAt": "2023-11-01T23:30:12Z",
                          "publishedAt": "2023-11-01T23:30:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "2-phase or 3-phase flow?",
          "author": {
            "login": "Bearunner"
          },
          "bodyText": "Dear all,\nI have a question:\nCan the porous_flow module simulate 3-phase flow including a solid phase?\nFor example, if we get a precipitated solid phase by using the geochemistry module, the data from the geochemistry module will be transferred to the porous_flow module for flow calculation. Can the porous_flow module simulate precipitated solid-phase flow or not?\nBest regards,\nB",
          "url": "https://github.com/idaholab/moose/discussions/25900",
          "updatedAt": "2024-01-30T23:50:25Z",
          "publishedAt": "2023-10-30T17:28:44Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Bearunner"
                  },
                  "bodyText": "dear @GiudGiud and @cpgr , could you please help me with this? thanks",
                  "url": "https://github.com/idaholab/moose/discussions/25900#discussioncomment-7432856",
                  "updatedAt": "2023-10-31T09:16:40Z",
                  "publishedAt": "2023-10-31T09:16:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "You can have precipitation leading to porosity reduction and permeability impairment. Is that what you mean?",
                          "url": "https://github.com/idaholab/moose/discussions/25900#discussioncomment-7433021",
                          "updatedAt": "2023-10-31T09:30:29Z",
                          "publishedAt": "2023-10-31T09:30:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "Sorry, it is not. What I want to know is whether this precipitation will flow with fluid or not.",
                          "url": "https://github.com/idaholab/moose/discussions/25900#discussioncomment-7433104",
                          "updatedAt": "2023-10-31T18:27:41Z",
                          "publishedAt": "2023-10-31T09:37:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "Another question: can the porous flow module simulate 3-phase flow including gas-liquid-solid?",
                          "url": "https://github.com/idaholab/moose/discussions/25900#discussioncomment-7433172",
                          "updatedAt": "2023-10-31T09:43:56Z",
                          "publishedAt": "2023-10-31T09:43:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "So you want the solid phase to flow with the liquid phase I assume, with the same relative permeability? The only way I think it will do that currently is if you can express the solid phase as a liquid component - so converting the solid volume to a mass fraction of liquid volume.\nAll of the physics (kernels etc) are extremely general, so can handle an arbitrary number of fluid phases, with an arbitrary number of fluid components per phase. The difficulty is getting all of the fluid properties, ref perms etc correct for your model.",
                          "url": "https://github.com/idaholab/moose/discussions/25900#discussioncomment-7440708",
                          "updatedAt": "2023-11-01T00:08:30Z",
                          "publishedAt": "2023-11-01T00:08:29Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Bearunner"
                          },
                          "bodyText": "Sorry, the flow of the solid phase has nothing to do with the flow of the liquid phase. Can the porous flow module simulate 3-phase flow including gas-liquid-solid seperately?",
                          "url": "https://github.com/idaholab/moose/discussions/25900#discussioncomment-7447792",
                          "updatedAt": "2023-11-01T16:33:37Z",
                          "publishedAt": "2023-11-01T16:33:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "I think you would have to add your own material to model this",
                          "url": "https://github.com/idaholab/moose/discussions/25900#discussioncomment-7450468",
                          "updatedAt": "2023-11-01T22:32:21Z",
                          "publishedAt": "2023-11-01T22:32:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "GTN model implementation within ADViscoplasticityStressUpdate.C",
          "author": {
            "login": "gka80"
          },
          "bodyText": "Hello-\nI am interested in implementing the GTN model for a study that I am doing. I noticed that the ADViscoplasticityStressUpdate material already has this model incorporated (ADViscoplasticityStressUpdate.C). After reviewing the article linked on the MOOSE Source Page V Tvergaard and A Needleman. Analysis of the cup-cone fracture in a round tensile bar. Acta Metallurgica, 32(1):157\u2013169, 1984.; Reference 5, I am having a little trouble understanding what Lines 188 through 192 are accomplishing when calculating the residual. It appears that there is an extra term when comparing this to Equation 2.2 in the reference (although I am likely overlooking something):\n if (_pore_shape == PoreShapeModel::SPHERICAL) { residual *= 1.0 + _intermediate_porosity / 1.5;  _derivative *= 1.0 + _intermediate_porosity / 1.5; }\n\nAlso, after reviewing the source code for this material, it appears that (relative to the article provided), void nucleation has not been incorporated? (No worries if it has not as it appears fairly straight forward to incorporate).\nThank you,\n-Garrett",
          "url": "https://github.com/idaholab/moose/discussions/25923",
          "updatedAt": "2023-11-01T19:59:51Z",
          "publishedAt": "2023-11-01T15:55:50Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@tophmatthews would you mind explaining this for us?",
                  "url": "https://github.com/idaholab/moose/discussions/25923#discussioncomment-7447749",
                  "updatedAt": "2023-11-01T16:30:22Z",
                  "publishedAt": "2023-11-01T16:30:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tophmatthews"
                          },
                          "bodyText": "I don't think it incorporates nucleation. That model is pretty old and likely incomplete, or rather, hasn't been applied beyond test problems with great success. I've been trying to get back to it, but it seems unlikely this year.",
                          "url": "https://github.com/idaholab/moose/discussions/25923#discussioncomment-7447965",
                          "updatedAt": "2023-11-01T16:49:38Z",
                          "publishedAt": "2023-11-01T16:49:37Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gka80"
                          },
                          "bodyText": "Great, thank you both for the quick response. I will do some \"digging\" and update if I achieve something worth contributing.",
                          "url": "https://github.com/idaholab/moose/discussions/25923#discussioncomment-7449459",
                          "updatedAt": "2023-11-01T19:59:49Z",
                          "publishedAt": "2023-11-01T19:59:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Effect of automatic_scaling in thermal hydraulics",
          "author": {
            "login": "jvwilliams23"
          },
          "bodyText": "I am trying to fix a failing solve in my troublesome THM case by following the webpage \"Troubleshooting failed solves\". I think it is an issue in variable scaling in my case, so I try to use automatic_scaling = true (which did not work). So using the 01_flow_channel.i tutorial, I make the same modification (automatic_scaling=true, as given below) which seems to crash at the second time step.\nMy questions are: is automatic_scaling not appropriate for THM problems? Why is this simple case not working with automatic_scaling=true? Also, in general, are the guidelines in \"Troubleshooting failed solves\" document suitable for THM problems?\nT_in = 300. # K\nm_dot_in = 1e-2 # kg/s\npress = 10e5 # Pa\n\n[GlobalParams]\n  initial_p = ${press}\n  initial_vel = 0.0001\n  initial_T = ${T_in}\n  gravity_vector = '0 0 0'\n\n  rdg_slope_reconstruction = minmod\n  closures = thm_closures\n  fp = he\n[]\n\n[FluidProperties]\n  [he]\n    type = IdealGasFluidProperties\n    molar_mass = 4e-3\n    gamma = 1.67\n    k = 0.2556\n    mu = 3.22639e-5\n  []\n[]\n\n[Closures]\n  [thm_closures]\n    type = Closures1PhaseTHM\n  []\n[]\n\n[Components]\n  [inlet]\n    type = InletMassFlowRateTemperature1Phase\n    input = 'core_chan:in'\n    m_dot = ${m_dot_in}\n    T = ${T_in}\n  []\n\n  [core_chan]\n    type = FlowChannel1Phase\n    position = '0 0 0'\n    orientation = '0 0 1'\n    length = 1\n    n_elems = 25\n    A = 7.2548e-3\n    D_h = 7.0636e-2\n  []\n\n  [outlet]\n    type = Outlet1Phase\n    input = 'core_chan:out'\n    p = ${press}\n  []\n[]\n\n\n[Preconditioning]\n  [pc]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  line_search = basic\n\n  start_time = 0\n  end_time = 1000\n  dt = 10\n\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-8\n  nl_max_its = 25\n\n  automatic_scaling = true\n[]\n\n[Outputs]\n  exodus = true\n\n  print_linear_residuals = true\n[]\n[Debug]\n  show_var_residual_norms = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/25921",
          "updatedAt": "2023-11-01T16:35:53Z",
          "publishedAt": "2023-11-01T13:37:26Z",
          "category": {
            "name": "Q&A Modules: Thermal Hydraulics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont think they use it much for THM, probably because the residuals for the energy equation are initialized closer to their solution so the solver tries to over-converge them.\nAlso automatic scaling scales per variable and in TH simulations the friction factors difference in various components make it advantageous to scale per component\nInstead they pass the scaling factors in the FlowChannel1Phase:\n    scaling_factor_1phase = '1 1 1e-5'\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25921#discussioncomment-7446033",
                  "updatedAt": "2023-11-01T13:50:43Z",
                  "publishedAt": "2023-11-01T13:50:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jvwilliams23"
                          },
                          "bodyText": "Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/25921#discussioncomment-7447813",
                          "updatedAt": "2023-11-01T16:35:54Z",
                          "publishedAt": "2023-11-01T16:35:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error when requesting u_dot_old",
          "author": {
            "login": "bylore"
          },
          "bodyText": "Hi, I was building my own material object which use _dot_old of a scalar field variable.\nAnd I got the error\n\nMooseVariableFE: Old time derivative of solution (u_dot_old) is not stored. Please set uDotOldRequested() to true in FEProblemBase before requesting u_dot_old.\n\nEven I already set uDotOldRequested by _fe_problem.setUDotOldRequested(true); \nHere is my code in the construction function.\n  _fe_problem.setUDotRequested(true); _fe_problem.setUDotOldRequested(true);  _var_dot = &coupledDot(\"coupled_variable\");  _var_dot_old = &coupledDotOld(\"coupled_variable\");\nCould you help me? Thanks",
          "url": "https://github.com/idaholab/moose/discussions/25920",
          "updatedAt": "2023-11-02T02:16:35Z",
          "publishedAt": "2023-11-01T10:07:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis \"setUDotRequested\" is something that is done in the time integrator.\nWhat time integrator are you using?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25920#discussioncomment-7446223",
                  "updatedAt": "2023-11-01T14:08:11Z",
                  "publishedAt": "2023-11-01T14:08:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "I use the default implicit-euler integrator of Transient Executioners.",
                          "url": "https://github.com/idaholab/moose/discussions/25920#discussioncomment-7446456",
                          "updatedAt": "2023-11-01T14:32:12Z",
                          "publishedAt": "2023-11-01T14:32:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you add the request for UDot in ImplicitEuler.C ?\nThere's an example in NewmarkBeta.C for doing that",
                          "url": "https://github.com/idaholab/moose/discussions/25920#discussioncomment-7446568",
                          "updatedAt": "2023-11-01T14:42:43Z",
                          "publishedAt": "2023-11-01T14:42:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "I found ImplicitEuler just inherits from TimeIntegrator where only UDotRequested is set True. Maybe I need build a new time intergrator inheriting from ImplicitEuler if I want ImplicitEuler and u_dot_old at the same time?",
                          "url": "https://github.com/idaholab/moose/discussions/25920#discussioncomment-7446598",
                          "updatedAt": "2023-11-01T14:46:57Z",
                          "publishedAt": "2023-11-01T14:46:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "Yes, I will try it. Thank you~",
                          "url": "https://github.com/idaholab/moose/discussions/25920#discussioncomment-7446610",
                          "updatedAt": "2023-11-01T14:47:45Z",
                          "publishedAt": "2023-11-01T14:47:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "NeumannBC on a single node",
          "author": {
            "login": "Flolaffel"
          },
          "bodyText": "Hello,\nI'd like to create a single node force in MOOSE. In order to apply a NeumannBC in MOOSE a sideset is needed. However I can't seem to figure out how to create a sideset consisting of only one node. How is that done?",
          "url": "https://github.com/idaholab/moose/discussions/25895",
          "updatedAt": "2023-11-01T13:16:33Z",
          "publishedAt": "2023-10-30T13:15:16Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou cant create a sideset with a single node, you need an element side and in 2D that s 2 nodes at least.\nYou can create a nodeset, then look at using a NodalBC\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/25895#discussioncomment-7423952",
                  "updatedAt": "2023-10-30T13:17:47Z",
                  "publishedAt": "2023-10-30T13:17:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Is NodalBC the same thing as NodalKernel? If not where do I find NodalBCs?\nFurthermore, is there a reason why you can apply NeumannBCs to only sidesets but can't make a single node sideset? Especially in regard of said use case of applying single node forces.",
                          "url": "https://github.com/idaholab/moose/discussions/25895#discussioncomment-7424061",
                          "updatedAt": "2023-10-30T13:29:45Z",
                          "publishedAt": "2023-10-30T13:28:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It looks like it yes. i dont see nodalBCs as a system of its own, but nodalKernels can be boundary restricted.\ni think single-node forces are applied differently than NeumannBC but I dont remember how exactly.\n@hugary1995",
                          "url": "https://github.com/idaholab/moose/discussions/25895#discussioncomment-7424108",
                          "updatedAt": "2023-10-30T13:34:05Z",
                          "publishedAt": "2023-10-30T13:34:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "A NeumannBC is an IntegratedBC. IntegratedBCs are naturally associated with surface terms in your weak form. NodalBCs perform strong constraint enforcement and are not associated with the weak form",
                          "url": "https://github.com/idaholab/moose/discussions/25895#discussioncomment-7427132",
                          "updatedAt": "2023-10-30T18:03:03Z",
                          "publishedAt": "2023-10-30T18:03:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "So how would I define a force NodalBC?",
                          "url": "https://github.com/idaholab/moose/discussions/25895#discussioncomment-7443109",
                          "updatedAt": "2023-11-01T07:54:45Z",
                          "publishedAt": "2023-11-01T07:54:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "I think using a ConstantRate NodalKernel on that node would accomplish what you are trying to do.",
                          "url": "https://github.com/idaholab/moose/discussions/25895#discussioncomment-7444487",
                          "updatedAt": "2023-11-01T10:53:46Z",
                          "publishedAt": "2023-11-01T10:53:45Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Works, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/25895#discussioncomment-7445476",
                          "updatedAt": "2023-11-01T12:55:12Z",
                          "publishedAt": "2023-11-01T12:55:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "What I'm wondering though: The documentation says ConstantRate implements a kernel du/dt. Wouldn't that be velocity instead of force? A test I've run shows it acts as a force though. Where is my error in reasoning here?",
                          "url": "https://github.com/idaholab/moose/discussions/25895#discussioncomment-7445505",
                          "updatedAt": "2023-11-01T12:58:59Z",
                          "publishedAt": "2023-11-01T12:58:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "IIRC the NodalKernel adds directly to the residual of the of the nodes for your case that would be force. The example given there shows how to implement du/dt = -1. Where the time derivative  kernel computes du/dt and the ConstantRate add the -1.",
                          "url": "https://github.com/idaholab/moose/discussions/25895#discussioncomment-7445574",
                          "updatedAt": "2023-11-01T13:04:56Z",
                          "publishedAt": "2023-11-01T13:04:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Ah I see. Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/25895#discussioncomment-7445682",
                          "updatedAt": "2023-11-01T13:16:34Z",
                          "publishedAt": "2023-11-01T13:16:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "HPC Linux Configuration",
          "author": {
            "login": "jsevic"
          },
          "bodyText": "Hello,\nA Linux question, I am having an x86 HPC machine configured is there anything specific I should tell the Sys Admin on the Linux flavor or install?\nThx!\nJohn Sevic",
          "url": "https://github.com/idaholab/moose/discussions/25912",
          "updatedAt": "2023-10-31T22:33:06Z",
          "publishedAt": "2023-10-31T17:08:50Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@milljm will be the best counsel on this",
                  "url": "https://github.com/idaholab/moose/discussions/25912#discussioncomment-7437782",
                  "updatedAt": "2023-10-31T17:12:56Z",
                  "publishedAt": "2023-10-31T17:12:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Our build farm is using Rocky-8 for most targets, and in the process for eventually transitioning to Rocky-9.\nMy suggestion is Rocky-9.  Or RedHat Enterprise Linux 9 [RHEL], if that is an option. Rocky is a free clone of RHEL.",
                          "url": "https://github.com/idaholab/moose/discussions/25912#discussioncomment-7437937",
                          "updatedAt": "2023-10-31T17:29:09Z",
                          "publishedAt": "2023-10-31T17:29:09Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jsevic"
                          },
                          "bodyText": "OK thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/25912#discussioncomment-7438893",
                          "updatedAt": "2023-10-31T19:28:39Z",
                          "publishedAt": "2023-10-31T19:28:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Background Files for Bending and Tensile Tests",
          "author": {
            "login": "sreejitsarmac"
          },
          "bodyText": "Hey everyone. Is there a link for the background files (such as include, src, lib, and all the others) for a bending and tensile stress? Thanks!",
          "url": "https://github.com/idaholab/moose/discussions/25916",
          "updatedAt": "2023-10-31T19:20:55Z",
          "publishedAt": "2023-10-31T19:20:54Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Boundary Generation",
          "author": {
            "login": "styyokuda"
          },
          "bodyText": "All,\nI would like to generate boundaries. I used to do like:\n[MeshModifiers]\n  [./inner_BC]\n  type = ParsedAddSideset\n  combinatorial_geometry = 'x < 0.001'\n  new_sideset_name = 'inner_boundary'\n  [../]\n[ ]\n\nBut, this method seems not to work any longer.\nPlease let me know how to generate boundaries, on which I can apply boundary conditions.\nS. Thomas",
          "url": "https://github.com/idaholab/moose/discussions/25903",
          "updatedAt": "2023-10-31T18:23:36Z",
          "publishedAt": "2023-10-30T23:51:16Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "MeshModifiers have been retired years ago!\nWe now use MeshGenerators.\nFor this one:\n[Mesh]\n  [./inner_BC]\n  type = ParsedSidesetGenerator\n  combinatorial_geometry = 'x < 0.001'\n  new_sideset_name = 'inner_boundary'\n  [../]\n[ ]",
                  "url": "https://github.com/idaholab/moose/discussions/25903#discussioncomment-7429529",
                  "updatedAt": "2023-10-31T01:02:43Z",
                  "publishedAt": "2023-10-31T00:07:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you, Guillaume.\nI got the following error messages:\n*** ERROR ***\n~/mesh_generator.i:57: section '[MeshGenerators]' does not have an associated \"Action\".\n Common causes:\n- you misspelled the Action/section name\n- the app you are running does not support this Action/syntax\n\nPlease help.\nS. Thomas",
                          "url": "https://github.com/idaholab/moose/discussions/25903#discussioncomment-7429781",
                          "updatedAt": "2023-10-31T01:02:24Z",
                          "publishedAt": "2023-10-31T00:59:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh my bad\n[Mesh]",
                          "url": "https://github.com/idaholab/moose/discussions/25903#discussioncomment-7429800",
                          "updatedAt": "2023-10-31T01:02:36Z",
                          "publishedAt": "2023-10-31T01:02:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you, Guillaume.\nIt seems to be \"ParsedGeneratorSideset\" instead of \"ParsedSidesetGenerator\" :)\n\"ParsedGeneratorSideset\" works ... thank you.\nIs there anyway to delete the old boundaries?\nor keeping old boundaries, which are not used any longer, doesn't harm the computation?\nS. Thomas",
                          "url": "https://github.com/idaholab/moose/discussions/25903#discussioncomment-7429947",
                          "updatedAt": "2023-10-31T01:31:12Z",
                          "publishedAt": "2023-10-31T01:31:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "there is this one\nhttps://mooseframework.inl.gov/source/meshgenerators/BoundaryDeletionGenerator.html\nbut having old boundaries does not harm anything",
                          "url": "https://github.com/idaholab/moose/discussions/25903#discussioncomment-7434442",
                          "updatedAt": "2023-10-31T11:55:21Z",
                          "publishedAt": "2023-10-31T11:55:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "styyokuda"
                          },
                          "bodyText": "Thank you, Guillaume, as always. :)",
                          "url": "https://github.com/idaholab/moose/discussions/25903#discussioncomment-7438420",
                          "updatedAt": "2023-10-31T18:23:16Z",
                          "publishedAt": "2023-10-31T18:23:14Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}