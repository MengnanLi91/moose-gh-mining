{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNy0wNlQwMjo1MjoxMi0wNTowMM4AUbP2"
    },
    "edges": [
      {
        "node": {
          "title": "is there the possibility of Arc_length method in moose ?",
          "author": {
            "login": "Ttw0626"
          },
          "bodyText": "Dear Moose's developers,\nI thought I am not deep familiar with moose,\n\nI wanna ask a short question, is there a specific module for Arc_length method instead of disp-control solver?\n\nif yes, could I study some examples ?\nIt is important for unloading process in damage.\nThanks,\nTAN",
          "url": "https://github.com/idaholab/moose/discussions/24924",
          "updatedAt": "2023-07-08T13:43:19Z",
          "publishedAt": "2023-07-08T13:43:18Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Adding conda and homebrew PATH to .bash profile.",
          "author": {
            "login": "steam-simulator"
          },
          "bodyText": "Hi, I had a similar problem as discussed in #24342. Although I fixed the error temporarily, I\u2019m wondering how to fix it permanently by adding the PATH to my .bash profile. I can\u2019t figure out where my .bash profile is located. Could someone please direct me? Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/24920",
          "updatedAt": "2023-07-07T23:13:17Z",
          "publishedAt": "2023-07-07T05:35:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "Depends on the system... Homebrew is usually a Macintosh user thing, so what you want to change might actually be your ZSH profile. In either case, if you are using Bash these files (and others) are directly located in your $HOME directory:\n(some files may not exist)\n~/.bashrc         # BASH \n~/.bash_profile   # BASH\n~/.profile        # BASH I've seen Homebrew stick things here sometimes\n~/.zshrc          # Zsh\nWhy so many BASH profiles? I think the man page sums it up best (scroll down to \"INVOCATION\").\nHopefully you are using Zsh. As its a bit less complicated. You can verify what shell your terminal defaults to by running the following command (my machine spits back -zsh):\n\u276f echo $0\n-zsh\nIf you are using a GUI file manager, these files (and others which begin with a period) are hidden. They are also likely hidden without using additional listing arguments to ls. Example:\n\u276f mkdir ~/temp; cd ~/temp\n\u276f touch .hidden\n\u276f ls\n\n\u276f ls -a\n.       ..      .hidden",
                  "url": "https://github.com/idaholab/moose/discussions/24920#discussioncomment-6384219",
                  "updatedAt": "2023-07-07T12:41:38Z",
                  "publishedAt": "2023-07-07T12:39:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "steam-simulator"
                          },
                          "bodyText": "thanks, @milljm!",
                          "url": "https://github.com/idaholab/moose/discussions/24920#discussioncomment-6388761",
                          "updatedAt": "2023-07-07T23:13:07Z",
                          "publishedAt": "2023-07-07T23:13:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiapp transfer",
          "author": {
            "login": "karthichockalingam"
          },
          "bodyText": "Hi,\nI have a master which has two multi-apps (sub1 and sub2) solving time-dependent problems.\nSay you u = 0 in the master, which is passed to sub1, which returns u_new to the mater.\nNow, when I pass u from the mater to sub2, it still pass u = 0 (and not u_new). Only in the\nnext time, does the master pass u_new to the sub app. So my simulation is lagging behind\nby one time step.\nHow can I fix this?\nThank you.\nKarthik.",
          "url": "https://github.com/idaholab/moose/discussions/24880",
          "updatedAt": "2023-07-07T21:39:25Z",
          "publishedAt": "2023-06-30T10:40:37Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou could execute the multiapp on time step end to begin with. This will make sure the field sent to the multiapp is updated.\nIf you want to synchronize the two applications more, you can turn on fixed point iterations between the parent and child apps in the executioner block.\nYou may want to turn verbose_multiapps=true in the executioner block for now to set this up\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24880#discussioncomment-6325639",
                  "updatedAt": "2023-06-30T12:46:23Z",
                  "publishedAt": "2023-06-30T12:46:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "karthichockalingam"
                  },
                  "bodyText": "Hi @GiudGiud\nThank you for your response.\nI have three multi-apps,\nmaster->app1_sub1\nmaster->app2_sub1->app2_sub2->app2_sub3\nmaster->app3_sub1\nSay,\napp1_sub1 solves Equation 1. It needs u3, u2 and provides u1.\napp2_sub1(->sub2->sub3) solves Equation 2. It needs u1 and provides u2.\napp3_sub1 solves Equation 3. It needs u1, u2 and provides u3.\nThere are initial conditions for u3 and u1. The master just collects the variables and transfers all the variables to the respective multi-apps.\nQ1) I am not sure, how to order the apps, probably I can execute app1_sub1 on timestep_begin and app2_sub1 on timestep_end. What do I execute app3_sub1 on?\nQ2) Perhaps Picard (fixed-point) iteration, as you suggested is the way to go to ensure proper coupling between the variables before moving to the next time step. I am not sure how to set up the convergence criteria. All three variables need to be converged before moving to the next time step. What goes into the executioner block? I am new to using Picard iteration.\nThank you,\nKarthik.",
                  "url": "https://github.com/idaholab/moose/discussions/24880#discussioncomment-6374132",
                  "updatedAt": "2023-07-06T13:10:17Z",
                  "publishedAt": "2023-07-06T13:10:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Q1)\nI would execute app3 on timestep end. There's no way to have u1 updated and at the same time provide an updated u3 to app1\nAnd that's where fixed point iterations (Picard) come in.\nbtw if the main app does not provide any field of interest to the sub apps you can execute every subapp on timestep end.\nQ2)\nThere are quite a few parameters to the Picard iterations for multiapps.\nYou can see all these parameters, and the several ways to set the convergence criterion (either main app nonlienar residual or a custom postprocessor) in the Executioner parameters under Fixed Point Iterations parameters\nhttps://mooseframework.inl.gov/source/executioners/Steady.html",
                          "url": "https://github.com/idaholab/moose/discussions/24880#discussioncomment-6375787",
                          "updatedAt": "2023-07-06T15:48:05Z",
                          "publishedAt": "2023-07-06T15:48:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "karthichockalingam"
                          },
                          "bodyText": "@GiudGiud Thank you for your response.\nThe main app only gathers the variables (u1, u2, u3) from the sub-app and does not solve.\n[Problem]\n  type = FEProblem\n  solve = false\n[]\n\nSo only auxiliary variables exist in the main app. However, I would like to set the Picard convergence criterion for u1, u2 and u3 in the main app. Does it make sense to set something like the below in the executioner block of the main app?\n  picard_max_its = 10\n  picard_rel_tol = 1e-6\n  picard_abs_tol = 1e-10\n\nKind regards,\nKarthi",
                          "url": "https://github.com/idaholab/moose/discussions/24880#discussioncomment-6382689",
                          "updatedAt": "2023-07-07T16:47:56Z",
                          "publishedAt": "2023-07-07T09:33:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no this wont work.\nYou ll want to use the custom_pp convergence option.\nYou can create a \"change in a variable\" postprocessor using the existing ones",
                          "url": "https://github.com/idaholab/moose/discussions/24880#discussioncomment-6386620",
                          "updatedAt": "2023-07-07T16:48:26Z",
                          "publishedAt": "2023-07-07T16:48:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "karthichockalingam"
                          },
                          "bodyText": "@GiudGiud,\nI know how to create a post-processor, which I understand returns a single scalar quantity.\nQ1) What is the convergence criterion on i.e like an l2 error norm pp of an aux variable?\nQ2) Will the above pp be checked against the previous iteration for convergence?\nQ3) Sorry, I am not following what you mean by \"change in a variable\" pp. Are we changing the aux variable to a regular variable using pp?\nBest,\nKarthi",
                          "url": "https://github.com/idaholab/moose/discussions/24880#discussioncomment-6387227",
                          "updatedAt": "2023-07-07T18:20:38Z",
                          "publishedAt": "2023-07-07T18:20:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "use this PP\nhttps://mooseframework.inl.gov/source/postprocessors/ChangeOverTimestepPostprocessor.html\nQ1) Yes you should use something like that. Or L1 norm maybe\nQ2) You can work to make that happen. Please refer to the fixed point iteration documentation from the Executioner\nQ3) No, PPs do not convert from regular to aux or aux to regular.",
                          "url": "https://github.com/idaholab/moose/discussions/24880#discussioncomment-6387426",
                          "updatedAt": "2023-07-07T18:52:59Z",
                          "publishedAt": "2023-07-07T18:52:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "karthichockalingam"
                          },
                          "bodyText": "@GiudGiud\nThank you. I almost understand how to get it to work.\nLooks like the ChangeOverTimeStepPostprocessor convergence criterion is something like |y^n+1| -  |y^n| provided a specific norm.\nWhere y is the field variable and n is the Picard iteration number.\nHowever shouldn't the convergence be on |y^n+1 -  y^n| going to zero instead?\nI think this can't be accomplished via ChangeOverTimePostprocessor as it only takes the difference between scalar qualities and not field variables.",
                          "url": "https://github.com/idaholab/moose/discussions/24880#discussioncomment-6388203",
                          "updatedAt": "2023-07-07T20:59:46Z",
                          "publishedAt": "2023-07-07T20:59:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh ok might be another postprocessor.\nYou could compute the residuals in the apps with\nhttps://mooseframework.inl.gov/source/auxkernels/DebugResidualAux.html\nthen transfer the residuals from the apps to main app then use this to compare them to 0\nhttps://mooseframework.inl.gov/source/postprocessors/ElementL2FunctorError.html",
                          "url": "https://github.com/idaholab/moose/discussions/24880#discussioncomment-6388302",
                          "updatedAt": "2023-07-07T21:13:15Z",
                          "publishedAt": "2023-07-07T21:13:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "karthichockalingam"
                          },
                          "bodyText": "@GiudGiud\nAlternatively,  instead of doing the following\napp1_sub1 solves Equation 1. It needs u3, u2 and provides u1.\napp2_sub1(->sub2->sub3) solves Equation 2. It needs u1 and provides u2.\napp3_sub1 solves Equation 3. It needs u1, u2 and provides u3.\nI could do\nMaster solves u3, provided u1,u2\n(but u3 will be zero for the first iteration as u1=u2=0 but Picard iteration will eventually make u3 to converge)\napp1_sub1 solves Equation 1. It needs u3, u2 and provides u1.\napp2_sub1(->sub2->sub3) solves Equation 2. It needs u1 and provides u2.\nThen I set the Picard convergence criterion directly on u3, which would be a non-linear variable not make use of ChangeOverTimeStepPostprocessor?",
                          "url": "https://github.com/idaholab/moose/discussions/24880#discussioncomment-6388396",
                          "updatedAt": "2023-07-07T21:31:03Z",
                          "publishedAt": "2023-07-07T21:31:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "that works too",
                          "url": "https://github.com/idaholab/moose/discussions/24880#discussioncomment-6388440",
                          "updatedAt": "2023-07-07T21:39:26Z",
                          "publishedAt": "2023-07-07T21:39:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Custom PenaltyEqualValueConstraint with prescribed displacement jump",
          "author": {
            "login": "chunhuizhao478"
          },
          "bodyText": "Hi all, this is a follow-up discussion after #24894. I try to setup a simple dynamic problem to test the correctness of this custom constraint, but it seems like it doesn't solve anything with the nonzero prescribed slip, I wonder if there is something wrong in the setup, thanks!\nThis is the input file:\n[Mesh]\n    [./msh]\n        type = GeneratedMeshGenerator\n        dim = 2\n        nx = 10\n        ny = 10\n        xmin = -500\n        xmax = 500\n        ymin = -500\n        ymax = 500\n    []\n    [./new_block]\n        type = ParsedSubdomainMeshGenerator\n        input = msh\n        combinatorial_geometry = 'y<0'\n        block_id = 1\n    []\n    [./split]\n        type = BreakMeshByBlockGenerator\n        input = new_block\n        split_interface = true\n        add_interface_on_two_sides = true\n    []\n[]\n\n[GlobalParams]\n    ##primary variable\n    displacements = 'disp_x disp_y'\n[]\n\n[Variables]\n    [./disp_x]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n    [./disp_y]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n[]\n\n[AuxVariables]\n    [./accel_x]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n    [./vel_x]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n    [./accel_y]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n    [./vel_y]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n    [./slip_iter]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [./slip_zero]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n[]\n\n[AuxKernels]\n    [./accel_x] \n        type = NewmarkAccelAux\n        variable = accel_x\n        displacement = disp_x\n        velocity = vel_x\n        beta = 0.25\n        execute_on = TIMESTEP_END\n    [../]\n    [./vel_x] \n        type = NewmarkVelAux\n        variable = vel_x\n        acceleration = accel_x\n        gamma = 0.5\n        execute_on = TIMESTEP_END\n    [../]\n    [./accel_y]\n        type = NewmarkAccelAux\n        variable = accel_y\n        displacement = disp_y\n        velocity = vel_y\n        beta = 0.25\n        execute_on = TIMESTEP_END\n    [../]\n    [./vel_y]\n        type = NewmarkVelAux\n        variable = vel_y\n        acceleration = accel_y\n        gamma = 0.5\n        execute_on = TIMESTEP_END\n    [../]\n    [./const_val]\n        type = ConstantAux\n        value = 1\n        variable = slip_iter\n        execute_on = 'INITIAL TIMESTEP_BEGIN'\n        boundary = 'Block0_Block1'\n    []\n[]\n\n[Modules]\n    [./TensorMechanics]\n      [./Master]\n        [./all]\n          strain = SMALL\n          displacements = 'disp_x disp_y'\n          planar_formulation = PLANE_STRAIN\n        [../]\n      [../]\n    [../]\n[]\n\n[Kernels]\n    [./inertia_x]\n        type = InertialForce\n        use_displaced_mesh = false\n        variable = disp_x\n        velocity = vel_x\n        acceleration = accel_x\n        beta = 0.25\n        gamma = 0.5\n    []\n    [./inertia_y]\n        type = InertialForce\n        use_displaced_mesh = false\n        variable = disp_y\n        velocity = vel_y\n        acceleration = accel_y\n        beta = 0.25\n        gamma = 0.5\n    []\n[]\n\n[Constraints]\n    [slip_constraint_x]\n        type = PenaltySlipConstraint\n        primary_boundary = 'Block0_Block1'\n        secondary_boundary = 'Block1_Block0'\n        primary_subdomain = 'Block0'\n        secondary_subdomain = 'Block1'\n        slip_iter = slip_iter\n        penalty_value = 1e6\n        primary_variable = disp_x\n        secondary_variable = disp_x\n    []\n    [slip_constraint_y]\n        type = PenaltySlipConstraint\n        primary_boundary = 'Block0_Block1'\n        secondary_boundary = 'Block1_Block0'\n        primary_subdomain = 'Block0'\n        secondary_subdomain = 'Block1'\n        slip_iter = slip_zero\n        penalty_value = 1e6\n        primary_variable = disp_y\n        secondary_variable = disp_y\n    []\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    start_time = 0\n    num_steps = 1\n    l_tol = 1e-6\n    nl_rel_tol = 1e-6\n    nl_max_its = 100\n    nl_abs_tol = 1e-10\n    dt = 0.005\n    timestep_tolerance = 1e-6\n    petsc_options_iname = '-pc_type -ksp_gmres_restart'\n    petsc_options_value = 'lu       101'\n    automatic_scaling = true\n    line_search = 'none'\n[]\n\n[Preconditioning]\n    [smp]\n      type = SMP\n      full = true\n    []\n[]\n\n[Materials]\n    [elasticity]\n        type = ComputeIsotropicElasticityTensor\n        lambda = 1\n        shear_modulus = 1\n        use_displaced_mesh = false\n    []\n    [stress]\n        type = ComputeLinearElasticStress\n    []\n    [density]\n        type = GenericConstantMaterial\n        prop_names = density\n        prop_values = 1\n    []\n[]\n\n[Outputs]\n    exodus = true\n    interval = 1\n[]\n\nThis is the custom constraint file:\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#pragma once\n\n#include \"MortarConstraint.h\"\n#include \"ADMortarConstraint.h\"\n\n// Forward declaration\ntemplate <bool is_ad>\nusing MortarConstraintTempl =\n    typename std::conditional<is_ad, ADMortarConstraint, MortarConstraint>::type;\n\n/**\n * Constrain the value of a variable to be the same on both sides of an\n * interface using a generalized force stemming from a penalty-based enforcement.\n */\ntemplate <bool is_ad>\nclass PenaltySlipConstraintTempl : public MortarConstraintTempl<is_ad>\n{\npublic:\n  static InputParameters validParams();\n\n  PenaltySlipConstraintTempl(const InputParameters & parameters);\n\nprotected:\n  GenericReal<is_ad> computeQpResidual(Moose::MortarType mortar_type) final;\n  GenericReal<is_ad> computeQpJacobian(Moose::ConstraintJacobianType jacobian_type,\n                                       unsigned int jvar);\n\n  /// Penalty value used to enforce the constraint\n  const Real _penalty_value;\n  const VariableValue _slip_iter;\n\n  using MortarConstraintTempl<is_ad>::_u_primary;\n  using MortarConstraintTempl<is_ad>::_u_secondary;\n  using MortarConstraintTempl<is_ad>::_test_primary;\n  using MortarConstraintTempl<is_ad>::_test_secondary;\n  using MortarConstraintTempl<is_ad>::_qp;\n  using MortarConstraintTempl<is_ad>::_i;\n  using MortarConstraintTempl<is_ad>::_j;\n  using MortarConstraintTempl<is_ad>::coupledValue;\n};\n\ntypedef PenaltySlipConstraintTempl<false> PenaltySlipConstraint;\ntypedef PenaltySlipConstraintTempl<true> ADPenaltySlipConstraint;\n\n#include \"PenaltySlipConstraint.h\"\n#include \"MortarConstraintBase.h\"\n\nregisterMooseObject(\"farms_rsfApp\", PenaltySlipConstraint);\nregisterMooseObject(\"farms_rsfApp\", ADPenaltySlipConstraint);\n\ntemplate <bool is_ad>\nInputParameters\nPenaltySlipConstraintTempl<is_ad>::validParams()\n{\n  InputParameters params = MortarConstraintTempl<is_ad>::validParams();\n  params.addClassDescription(\n      \"PenaltySlipConstraint enforces solution continuity between secondary and \"\n      \"primary sides of a mortar interface using a penalty approach (no Lagrange multipliers \"\n      \"needed)\");\n  params.addRequiredRangeCheckedParam<Real>(\n      \"penalty_value\",\n      \"penalty_value>0\",\n      \"Penalty value used to impose a generalized force capturing the mortar constraint equation\");\n  params.addRequiredCoupledVar(\"slip_iter\",\"slip value at current iteration\");\n  return params;\n}\n\ntemplate <bool is_ad>\nPenaltySlipConstraintTempl<is_ad>::PenaltySlipConstraintTempl(\n    const InputParameters & parameters)\n  : MortarConstraintTempl<is_ad>(parameters),\n    _penalty_value(this->template getParam<Real>(\"penalty_value\")),\n    _slip_iter(coupledValue(\"slip_iter\"))\n{\n}\n\ntemplate <bool is_ad>\nGenericReal<is_ad>\nPenaltySlipConstraintTempl<is_ad>::computeQpResidual(Moose::MortarType mortar_type)\n{\n\n  switch (mortar_type)\n  {\n    case Moose::MortarType::Secondary:\n    {\n      auto residual =\n          -(_u_primary[_qp] - _u_secondary[_qp] - _slip_iter[_qp]) * _penalty_value * _test_secondary[_i][_qp];\n\n      return residual;\n    }\n\n    case Moose::MortarType::Primary:\n    {\n      auto residual =\n          (_u_primary[_qp] - _u_secondary[_qp] - _slip_iter[_qp]) * _penalty_value * _test_primary[_i][_qp];\n\n      return residual;\n    }\n\n    default:\n      return 0;\n  }\n}\n\ntemplate <>\nADReal\nPenaltySlipConstraintTempl<true>::computeQpJacobian(\n    Moose::ConstraintJacobianType /*jacobian_type*/, unsigned int /*jvar*/)\n{\n  mooseError(\"ADPenaltySlipConstraint does not implement manual Jacobian calculation.\");\n}\n\ntemplate <>\nReal\nPenaltySlipConstraintTempl<false>::computeQpJacobian(\n    Moose::ConstraintJacobianType jacobian_type, unsigned int jvar)\n{\n  typedef Moose::ConstraintJacobianType JType;\n\n  switch (jacobian_type)\n  {\n    case JType::SecondarySecondary:\n      if (jvar == _secondary_var.number())\n        return (*_phi)[_j][_qp] * _penalty_value * _test_secondary[_i][_qp];\n      break;\n\n    case JType::SecondaryPrimary:\n      if (jvar == _primary_var.number())\n        return -(*_phi)[_j][_qp] * _penalty_value * _test_secondary[_i][_qp];\n      break;\n\n    case JType::PrimarySecondary:\n      if (jvar == _secondary_var.number())\n        return -(*_phi)[_j][_qp] * _penalty_value * _test_primary[_i][_qp];\n      break;\n\n    case JType::PrimaryPrimary:\n      if (jvar == _primary_var.number())\n        return (*_phi)[_j][_qp] * _penalty_value * _test_primary[_i][_qp];\n      break;\n\n    default:\n      return 0;\n  }\n\n  return 0;\n}\n\ntemplate class PenaltySlipConstraintTempl<false>;\ntemplate class PenaltySlipConstraintTempl<true>;",
          "url": "https://github.com/idaholab/moose/discussions/24897",
          "updatedAt": "2023-10-25T15:07:19Z",
          "publishedAt": "2023-07-04T18:22:07Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "_slip_iter(coupledValue(\"slip_iter\"))\n\nyou should probably use the coupledGenericValue templated on is_ad here, for the future to make sure derivatives are not lost here (for now it's ok, slip_iter is an aux variable)\nDoes Debug/show_execution_order show this constraint is executed as expected?",
                  "url": "https://github.com/idaholab/moose/discussions/24897#discussioncomment-6358451",
                  "updatedAt": "2023-07-05T04:13:57Z",
                  "publishedAt": "2023-07-05T04:13:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "It seems like the constraint is not called..\n[DBG] Executing boundary restricted auxkernels on boundary elements on INITIAL\n\nTime Step 0, time = 0\n\nTime Step 1, time = 0.005, dt = 0.005\n[DBG] Executing boundary restricted auxkernels on boundary elements on TIMESTEP_BEGIN\n[DBG] Beginning elemental loop to compute Residual on LINEAR\n[DBG] Execution order on each element:\n[DBG] - kernels on element quadrature points\n[DBG] - finite volume elemental kernels on element\n[DBG] - integrated boundary conditions on element side quadrature points\n[DBG] - DG kernels on element side quadrature points\n[DBG] - interface kernels on element side quadrature points\n[DBG] Ordering of Residual Objects on block  (0)\n[DBG] Ordering of kernels:\n[DBG] TM_all0 TM_all1 inertia_x inertia_y\n\nPerforming automatic scaling calculation\n\n[DBG] Beginning elemental loop to compute Residual on LINEAR\n[DBG] Ordering of Residual Objects on block  (0)\n[DBG] Ordering of kernels:\n[DBG] TM_all0 TM_all1 inertia_x inertia_y\n 0 Nonlinear |R| = 0.000000e+00\n Solve Converged!\n[DBG] Beginning nodal loop of nodal auxiliary kernels on TIMESTEP_END\n[DBG] Ordering of the kernels on each block they are defined on:\n[DBG] accel_x vel_x accel_y vel_y",
                          "url": "https://github.com/idaholab/moose/discussions/24897#discussioncomment-6358518",
                          "updatedAt": "2023-07-05T04:26:54Z",
                          "publishedAt": "2023-07-05T04:26:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok you should check the sidesets then\nI ll have to double check that Constraints are actually output by the Debug option. I could have forgotten them",
                          "url": "https://github.com/idaholab/moose/discussions/24897#discussioncomment-6358533",
                          "updatedAt": "2023-07-05T04:29:45Z",
                          "publishedAt": "2023-07-05T04:29:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "@recuero Hi Antonio, we had a discussion before about this. Do you have any idea? Thanks a lot",
                          "url": "https://github.com/idaholab/moose/discussions/24897#discussioncomment-6364784",
                          "updatedAt": "2023-07-05T16:04:24Z",
                          "publishedAt": "2023-07-05T16:04:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "It's unclear to me how you are generating your lower dimensional domains for your mortar/slip constraint --which you seem to need, e.g. Block0_Block1. Also, you'd need to block restrict your physics if you have mortar constraints in your system.",
                          "url": "https://github.com/idaholab/moose/discussions/24897#discussioncomment-6364990",
                          "updatedAt": "2023-07-05T16:24:17Z",
                          "publishedAt": "2023-07-05T16:24:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "This BreakMeshByBlockGenerator will generate the sideset Block0_Block1 which Block0 is the primary surface and Block1 is the secondary surface, I have add_interface_on_two_sides = true which gives me Block1_Block0, I'm not sure whether this fits into the constraint framework or not",
                          "url": "https://github.com/idaholab/moose/discussions/24897#discussioncomment-6365026",
                          "updatedAt": "2023-07-05T16:29:24Z",
                          "publishedAt": "2023-07-05T16:29:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "You can see if the lower dimensional domains get generated in the output, e.g. in Paraview. In that case, you'd need to block restrict your physics, e.g. your mechanics to not act on those lower-dimensional domains.",
                          "url": "https://github.com/idaholab/moose/discussions/24897#discussioncomment-6365180",
                          "updatedAt": "2023-07-05T16:43:54Z",
                          "publishedAt": "2023-07-05T16:43:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "I checked the lower dimensional domain indeed there in Paraview. How to do \"block restrict\" to be more specific?\n[Constraints]\n    [slip_constraint_x]\n        type = PenaltySlipConstraint\n        primary_boundary = 'Block0_Block1'\n        secondary_boundary = 'Block1_Block0'\n        primary_subdomain = 'Block0'\n        secondary_subdomain = 'Block1'\n        slip_iter = slip_iter\n        penalty_value = 1e6\n        primary_variable = disp_x\n        secondary_variable = disp_x\n    []\n    [slip_constraint_y]\n        type = PenaltySlipConstraint\n        primary_boundary = 'Block0_Block1'\n        secondary_boundary = 'Block1_Block0'\n        primary_subdomain = 'Block0'\n        secondary_subdomain = 'Block1'\n        slip_iter = slip_zero\n        penalty_value = 1e6\n        primary_variable = disp_y\n        secondary_variable = disp_y\n    []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24897#discussioncomment-6365304",
                          "updatedAt": "2023-07-05T16:52:47Z",
                          "publishedAt": "2023-07-05T16:52:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "In:\n[Modules]\n    [./TensorMechanics]\n      [./Master]\n        [./all]\n          strain = SMALL\n          displacements = 'disp_x disp_y'\n          planar_formulation = PLANE_STRAIN\n          block = 'Blocks_that_are_not_lower_dimensional_for_mortar'\n        [../]\n      [../]\n    [../]\n[]\n\nAnd the same for other physics/kernels if you have them.",
                          "url": "https://github.com/idaholab/moose/discussions/24897#discussioncomment-6365359",
                          "updatedAt": "2023-07-05T16:59:08Z",
                          "publishedAt": "2023-07-05T16:59:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "I meant that, in the line below, you should include the higher dimensional blocks. Not the lower-dimensional blocks that are generated to impose constraints with a mortar formulation. I.e. your blocks can be \"1\" and \"2\", in which case you would do blocks = '1 2'\n    block = 'Blocks_that_are_not_lower_dimensional_for_mortar'",
                          "url": "https://github.com/idaholab/moose/discussions/24897#discussioncomment-6365675",
                          "updatedAt": "2023-07-05T17:25:53Z",
                          "publishedAt": "2023-07-05T17:25:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks! I tried, but it doesn't work also..\n[Mesh]\n    [./msh]\n        type = GeneratedMeshGenerator\n        dim = 2\n        nx = 10\n        ny = 10\n        xmin = -500\n        xmax = 500\n        ymin = -500\n        ymax = 500\n    []\n    [./new_block]\n        type = ParsedSubdomainMeshGenerator\n        input = msh\n        combinatorial_geometry = 'y<0'\n        block_id = 1\n    []\n    [./split]\n        type = BreakMeshByBlockGenerator\n        input = new_block\n        split_interface = true\n        add_interface_on_two_sides = true\n    []\n[]\n\n[GlobalParams]\n    ##primary variable\n    displacements = 'disp_x disp_y'\n[]\n\n[Variables]\n    [./disp_x]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n    [./disp_y]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n[]\n\n[AuxVariables]\n    [./accel_x]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n    [./vel_x]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n    [./accel_y]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n    [./vel_y]\n        order = FIRST\n        family = LAGRANGE\n    [../]\n    [./slip_iter]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n    [./slip_zero]\n        order = CONSTANT\n        family = MONOMIAL\n    []\n[]\n\n[AuxKernels]\n    [./accel_x] \n        type = NewmarkAccelAux\n        variable = accel_x\n        displacement = disp_x\n        velocity = vel_x\n        beta = 0.25\n        execute_on = TIMESTEP_END\n        block = '0 1'\n    [../]\n    [./vel_x] \n        type = NewmarkVelAux\n        variable = vel_x\n        acceleration = accel_x\n        gamma = 0.5\n        execute_on = TIMESTEP_END\n        block = '0 1'\n    [../]\n    [./accel_y]\n        type = NewmarkAccelAux\n        variable = accel_y\n        displacement = disp_y\n        velocity = vel_y\n        beta = 0.25\n        execute_on = TIMESTEP_END\n        block = '0 1'\n    [../]\n    [./vel_y]\n        type = NewmarkVelAux\n        variable = vel_y\n        acceleration = accel_y\n        gamma = 0.5\n        execute_on = TIMESTEP_END\n        block = '0 1'\n    [../]\n    [./const_val]\n        type = ConstantAux\n        value = 1\n        variable = slip_iter\n        execute_on = 'INITIAL TIMESTEP_BEGIN'\n        boundary = 'Block0_Block1'\n    []\n[]\n\n[Modules]\n    [./TensorMechanics]\n      [./Master]\n        [./all]\n          strain = SMALL\n          displacements = 'disp_x disp_y'\n          planar_formulation = PLANE_STRAIN\n          block = '0 1'\n        [../]\n      [../]\n    [../]\n[]\n\n[Kernels]\n    [./inertia_x]\n        type = InertialForce\n        use_displaced_mesh = false\n        variable = disp_x\n        velocity = vel_x\n        acceleration = accel_x\n        beta = 0.25\n        gamma = 0.5\n        block = '0 1'\n    []\n    [./inertia_y]\n        type = InertialForce\n        use_displaced_mesh = false\n        variable = disp_y\n        velocity = vel_y\n        acceleration = accel_y\n        beta = 0.25\n        gamma = 0.5\n        block = '0 1'\n    []\n[]\n\n[Constraints]\n    [slip_constraint_x]\n        type = PenaltySlipConstraint\n        primary_boundary = 'Block0_Block1'\n        secondary_boundary = 'Block1_Block0'\n        primary_subdomain = 'Block0'\n        secondary_subdomain = 'Block1'\n        slip_iter = slip_iter\n        penalty_value = 1e6\n        primary_variable = disp_x\n        secondary_variable = disp_x\n    []\n    [slip_constraint_y]\n        type = PenaltySlipConstraint\n        primary_boundary = 'Block0_Block1'\n        secondary_boundary = 'Block1_Block0'\n        primary_subdomain = 'Block0'\n        secondary_subdomain = 'Block1'\n        slip_iter = slip_zero\n        penalty_value = 1e6\n        primary_variable = disp_y\n        secondary_variable = disp_y\n    []\n[]\n\n[Executioner]\n    type = Transient\n    solve_type = 'NEWTON'\n    start_time = 0\n    num_steps = 1\n    l_tol = 1e-6\n    nl_rel_tol = 1e-6\n    nl_max_its = 100\n    nl_abs_tol = 1e-10\n    dt = 0.005\n    timestep_tolerance = 1e-6\n    petsc_options_iname = '-pc_type -ksp_gmres_restart'\n    petsc_options_value = 'lu       101'\n    automatic_scaling = true\n    line_search = 'none'\n[]\n\n[Preconditioning]\n    [smp]\n      type = SMP\n      full = true\n    []\n[]\n\n[Materials]\n    [elasticity]\n        type = ComputeIsotropicElasticityTensor\n        lambda = 1\n        shear_modulus = 1\n        use_displaced_mesh = false\n    []\n    [stress]\n        type = ComputeLinearElasticStress\n    []\n    [density]\n        type = GenericConstantMaterial\n        prop_names = density\n        prop_values = 1\n    []\n[]\n\n[Outputs]\n    exodus = true\n    interval = 1\n[]\n\n[Debug]\n    show_execution_order = ALWAYS\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24897#discussioncomment-6366924",
                          "updatedAt": "2023-07-05T20:09:00Z",
                          "publishedAt": "2023-07-05T20:08:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "solving with other Numerical Methods (MOL)",
          "author": {
            "login": "MohammdReza5106"
          },
          "bodyText": "Hi there,\nWhile working on my thesis, I came across this amazing framework. I'm wondering if it's possible to solve PDE-type problems with other numerical solutions. As an MSc. student in Welding Engineering, I'm particularly interested in using this framework to solve problems related to SMAW moving heat sources and temperature fields. However, in order to meet the requirements of my thesis proposal, I need to use the Method of Lines approach instead. Can you tell me if this is possible with the framework?",
          "url": "https://github.com/idaholab/moose/discussions/24914",
          "updatedAt": "2023-07-07T14:38:49Z",
          "publishedAt": "2023-07-06T13:56:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI suspect the method of lines is similar to the method of characteristics (MOC) (but with the characteristic being a line).\nIf so, then it can be done using the ray tracing module. We have a neutron transport MOC solver, so it can be done, we just can't share it.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24914#discussioncomment-6375488",
                  "updatedAt": "2023-07-06T15:19:00Z",
                  "publishedAt": "2023-07-06T15:19:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "MohammdReza5106"
                          },
                          "bodyText": "Dear Guillaume\ni really appreciate your guide but as i have a limited time to do my work , i wonder that isn't there any written code in these method\nthat i learn and modified them to adjust my case\nthank you.",
                          "url": "https://github.com/idaholab/moose/discussions/24914#discussioncomment-6381711",
                          "updatedAt": "2023-07-07T07:45:31Z",
                          "publishedAt": "2023-07-07T07:45:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There's a few examples in the module\nWe also have this example doing MPM\nhttps://github.com/loganharbour/moose/tree/rt_mpm",
                          "url": "https://github.com/idaholab/moose/discussions/24914#discussioncomment-6385403",
                          "updatedAt": "2023-07-07T14:38:50Z",
                          "publishedAt": "2023-07-07T14:38:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Kernel selection for NS equation",
          "author": {
            "login": "Wolke926"
          },
          "bodyText": "Dear MOOSE experts:\nWhen I try to combine the Navier-Stokes equation and the Allen-Cahn equation, there is a surface tension term(marked in equation 2) and I don't know how to choose a suitable kernel for this term.\nComparing the form of the Cahn-Hilliard equation, the surface tension term in equation 2 looks similar to equation 1. The functional derivative of concentration can be regarded as chemical potential, and the difference between Cahn Hilliard equation and the surface tension term is that the former is \\nebla (\\M*\\nebla miu) while in equation 2 is \\phi*\\ nebla miu (although strictly speaking, only the functional derivative of energy with respect to concentration can be called chemical potential).\nI wonder if I can still use the SplitCHParsed kernel (although )with some other kernels to solve this term or should I write a new one?",
          "url": "https://github.com/idaholab/moose/discussions/24904",
          "updatedAt": "2023-07-06T19:37:16Z",
          "publishedAt": "2023-07-05T15:56:16Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@dschwen any thoughts on this?",
                  "url": "https://github.com/idaholab/moose/discussions/24904#discussioncomment-6365144",
                  "updatedAt": "2023-07-05T16:40:21Z",
                  "publishedAt": "2023-07-05T16:40:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Wolke926"
                  },
                  "bodyText": "Does anybody have some ideas?",
                  "url": "https://github.com/idaholab/moose/discussions/24904#discussioncomment-6377674",
                  "updatedAt": "2023-07-06T19:37:17Z",
                  "publishedAt": "2023-07-06T19:37:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Convergence issue while solving phase-field fracture",
          "author": {
            "login": "avtarsinghh1991"
          },
          "bodyText": "Hello MOOSE Experts\nI am trying to solve rate-independent phase-field fracture using the following example\ncrack2d_iso_wo_time.i\nfor CT specimen geometry, the material properties are taken from Miehe's paper.\nHowever, I am getting the following error as soon as the damage evolves to value 1.\n  Linear solve did not converge due to DIVERGED_ITS iterations 10\n  Linear solve did not converge due to DIVERGED_ITS iterations 10\n  Linear solve did not converge due to DIVERGED_ITS iterations 10\n  Linear solve did not converge due to DIVERGED_ITS iterations 10\n  Linear solve did not converge due to DIVERGED_ITS iterations 10\n  Linear solve did not converge due to DIVERGED_ITS iterations 10\n  Linear solve did not converge due to DIVERGED_ITS iterations 10\n  Linear solve did not converge due to DIVERGED_ITS iterations 10\n  Linear solve did not converge due to DIVERGED_ITS iterations 10\n  Linear solve did not converge due to DIVERGED_ITS iterations 10\nNonlinear solve did not converge due to DIVERGED_MAX_IT iterations 10\n Solve Did NOT Converge!\n\n\nInput file I used is as follows;\n#This input does not add time derivative kernel for phase field equation\n[Mesh]\n  file = 'Miehe.inp'\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[Modules]\n  [./TensorMechanics]\n    [./Master]\n      [./mech]\n        add_variables = true\n        strain = SMALL\n        additional_generate_output = 'stress_yy'\n        save_in = 'resid_x resid_y'\n      [../]\n    [../]\n  [../]\n[]\n\n[Variables]\n  [./c]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n[AuxVariables]\n  [./resid_x]\n  [../]\n  [./resid_y]\n  [../]\n[]\n\n[Kernels]\n  [./solid_x]\n    type = PhaseFieldFractureMechanicsOffDiag\n    variable = disp_x\n    component = 0\n    c = c\n  [../]\n  [./solid_y]\n    type = PhaseFieldFractureMechanicsOffDiag\n    variable = disp_y\n    component = 1\n    c = c\n  [../]\n  [./ACBulk]\n    type = AllenCahn\n    variable = c\n    f_name = F\n  [../]\n\n  [./ACInterface]\n    type = ACInterface\n    variable = c\n    kappa_name = kappa_op\n  [../]\n[]\n\n[BCs]\n  [./ydisp]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = NS4\n    function = 't'\n  [../]\n    [./xdisp]\n    type = DirichletBC\n    variable = disp_x\n    boundary = NS4\n    value = 0\n  [../]\n  [./yfix]\n    type = DirichletBC\n    variable = disp_y\n    boundary = NS3\n    value = 0\n  [../]\n  [./xfix]\n    type = DirichletBC\n    variable = disp_x\n    boundary = NS3\n    value = 0\n  [../]\n[]\n\n[Materials]\n  [./pfbulkmat]\n    type = GenericConstantMaterial\n    prop_names = 'gc_prop l visco'\n    prop_values = '2.7 0.015 3.0e-6'\n  [../]\n  [./define_mobility]\n    type = ParsedMaterial\n    material_property_names = 'gc_prop visco'\n    f_name = L\n    function = '1.0/(gc_prop * visco)'\n  [../]\n  [./define_kappa]\n    type = ParsedMaterial\n    material_property_names = 'gc_prop l'\n    f_name = kappa_op\n    function = 'gc_prop * l'\n  [../]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensor\n    C_ijkl = '121.0e3 80.0e3'\n    fill_method = symmetric_isotropic\n  [../]\n  [./elastic]\n    type = ComputeLinearElasticPFFractureStress\n    c = c\n    E_name = 'elastic_energy'\n    D_name = 'degradation'\n    F_name = 'local_fracture_energy'\n    decomposition_type = strain_spectral\n  [../]\n  [./degradation]\n    type = DerivativeParsedMaterial\n    f_name = degradation\n    args = 'c'\n    function = '(1.0-c)^2*(1.0 - eta) + eta'\n    constant_names       = 'eta'\n    constant_expressions = '0.0'\n    derivative_order = 2\n  [../]\n  [./local_fracture_energy]\n    type = DerivativeParsedMaterial\n    f_name = local_fracture_energy\n    args = 'c'\n    material_property_names = 'gc_prop l'\n    function = 'c^2 * gc_prop / 2 / l'\n    derivative_order = 2\n  [../]\n  [./fracture_driving_energy]\n    type = DerivativeSumMaterial\n    args = c\n    sum_materials = 'elastic_energy local_fracture_energy'\n    derivative_order = 2\n    f_name = F\n  [../]\n[]\n\n[Postprocessors]\n  [./resid_x]\n    type = NodalSum\n    variable = resid_x\n    boundary = NS3\n  [../]\n  [./resid_y]\n    type = NodalSum\n    variable = resid_y\n    boundary = NS3\n  [../]\n[]\n\n[Preconditioning]\n  [./smp]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n\n  automatic_scaling = true\n  compute_scaling_once=false\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_hypre_type -ksp_gmres_restart'\n  petsc_options_value = 'hypre boomeramg 101'\n\n  nl_rel_tol = 1e-3\n  l_tol = 1e-3\n\n  l_max_its = 10\n  nl_max_its = 10\n\n  dt = 1e-5\n  dtmin = 1e-6\n  num_steps = 3500\n[]\n\n[Outputs]\n  exodus = true\n  interval = 10\n[]\n\nFor reference. I have also uploaded the distribution of the damage field at the time just before the system diverged.\nCan you please let me know the procedure to resolve this instability issue?\nI shall be very thankful.\nBest\nAvtar",
          "url": "https://github.com/idaholab/moose/discussions/20016",
          "updatedAt": "2023-07-06T17:57:19Z",
          "publishedAt": "2022-01-11T21:38:27Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you please give us the full output log?\nl_max_its of 10 is not a lot, this is triggering Linear solve did not converge due to DIVERGED_ITS iterations 10, which could be taking down the non linear solver (since linear iterates are not very converged)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20016#discussioncomment-1951054",
                  "updatedAt": "2022-06-10T18:50:22Z",
                  "publishedAt": "2022-01-11T22:41:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Please find the attached file. I increased the linear solver iterations to 50. Still, it's getting crashed at approx the same load step.\noutput.zip",
                          "url": "https://github.com/idaholab/moose/discussions/20016#discussioncomment-1951863",
                          "updatedAt": "2022-06-10T18:50:21Z",
                          "publishedAt": "2022-01-12T02:34:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @asingh-mit\nTry to start from the setup of the example with the variational inequality solver, which is well converging:\nhttps://github.com/idaholab/moose/blob/next/modules/combined/test/tests/phase_field_fracture/crack2d_vi_solver.i\nOther convergence issues can be due to the load applied to quickly or the values of \"l\" and \"visco\"\nMake sure \"l\" is about 4 times your mesh size, at least\nThe only thing I can see in your input file is:\nnl_rel_tol = 1e-3\nl_tol = 1e-3\nThese are too high, just leave them as default.\nAlso increase a bit number of linear and non-linear iterations\nas suggested by @GiudGiud\nYou can see other examples of similar converging simulations here:\nhttps://github.com/ngrilli/c_pfor_am/tree/main/test/tests/CPDamage\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/20016#discussioncomment-1954889",
                  "updatedAt": "2022-06-10T18:50:26Z",
                  "publishedAt": "2022-01-12T13:36:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Please follow @ngrilli 's advice first. And if it unfortunately doesnt work, please reduce your mesh to 1000 dofs or less and run with -pc_type svd -pc_svd_monitor  on the command line. This will let us know if the system becomes singular right when you are getting convergence issues.",
                          "url": "https://github.com/idaholab/moose/discussions/20016#discussioncomment-1955077",
                          "updatedAt": "2022-06-10T18:50:30Z",
                          "publishedAt": "2022-01-12T14:05:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Add one more thing: If your linear solver fails, try to use a direct solver.\n  petsc_options_iname = '-pc_type'\n petsc_options_value = 'lu'",
                          "url": "https://github.com/idaholab/moose/discussions/20016#discussioncomment-1955856",
                          "updatedAt": "2022-06-10T18:50:28Z",
                          "publishedAt": "2022-01-12T15:45:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Thank you very much for the suggestions. Let you know the results after the simulation.\nHey @ngrilli\nAs you suggested about the load applied, I completely agree.\nSo, I am wondering if there is any method to decrease it after certain load steps.\nLet's say,\nI want to apply displacement of 1.0e-5 for the first 500 and then 1.0e-6 for the rest of the simulation.\nBest\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/20016#discussioncomment-1955907",
                          "updatedAt": "2022-06-10T18:50:26Z",
                          "publishedAt": "2022-01-12T15:50:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Take a look at TimeSteppers  https://mooseframework.inl.gov/syntax/Executioner/TimeStepper/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/20016#discussioncomment-1955956",
                          "updatedAt": "2022-06-17T15:56:34Z",
                          "publishedAt": "2022-01-12T15:57:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "avtarsinghh1991"
                  },
                  "bodyText": "Hello MOOSE Experts\nI followed the suggestions given by @ngrilli and @jiangwen84. But the system is still diverging as soon as the damage value reaches 1. Next, as suggested by @GiudGiud, I will decrease the problem size and provide the output.\nI just have one doubt. I need to incorporate anisotropy in the phase-field fracture and also the rate-independent. Is it possible to do that or do I need to write the kernel for the same?\nBest\nAvtar",
                  "url": "https://github.com/idaholab/moose/discussions/20016#discussioncomment-1959947",
                  "updatedAt": "2022-06-10T18:50:28Z",
                  "publishedAt": "2022-01-13T04:42:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @asingh-mit\nPlease attach the new input file, otherwise it's difficult to say.\nAre you setting any initial condition for the damage field? Or does it start from 0 everywhere?\nMy experience is that you need to initialise the phase field with a function exp(-y/l)\nso mimicking the steady state solution, otherwise you get convergence problems at the very beginning.\nIf your initial phase field is zero, there should not be problems.\nYes, anisotropic phase field fracture, to see anisotropic crack propagation, is already available in MOOSE:\nhttps://github.com/idaholab/moose/blob/next/modules/combined/test/tests/phase_field_fracture/crack2d_aniso_cleavage_plane.i\nno need to write any kernel.\nThere is one further 3D example here:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/test/tests/CPDamage/AnisoCleavage.i\nI made this and I am sure this is converging well and show crack propagation.\nThe fracture surface is a constant vector defined by \"cleavage_plane_normal\"\nBest Regards,\nNicol\u00f2",
                          "url": "https://github.com/idaholab/moose/discussions/20016#discussioncomment-1962419",
                          "updatedAt": "2022-06-10T18:50:29Z",
                          "publishedAt": "2022-01-13T13:24:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "avtarsinghh1991"
                          },
                          "bodyText": "Hello @ngrilli @jiangwen84 @GiudGiud\nThank you very much for your help.  I successfully validated the uniaxial tension test problem given in Prof. Miehe's Paper titled \"Thermodynamically consistent phase-field models of fracture: Variational principles and multi-field FE implementations\".\nI have tried many solvers and preconditioners settings. I can only be able to solve with the following solver settings:\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu       superlu_dist                  vinewtonrsls'\n  automatic_scaling = true\n\nOther solvers like PJFNK diverge as soon as the damage value reaches 1 or load started to drop. I have attached the two figures. First with PJFNK solver and second with Newton solver.\nBest\nAvtar",
                          "url": "https://github.com/idaholab/moose/discussions/20016#discussioncomment-1983487",
                          "updatedAt": "2022-06-10T18:50:36Z",
                          "publishedAt": "2022-01-17T13:54:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "vinewtonrsls should work with PJFNK too, but not sure why it fails to converge for this case.\nYes, we typically use direct solver for mechanics/fracture problems, at least for 2D and small 3D cases.",
                          "url": "https://github.com/idaholab/moose/discussions/20016#discussioncomment-1987489",
                          "updatedAt": "2022-06-10T18:50:39Z",
                          "publishedAt": "2022-01-18T03:18:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "New Formulation Dynamics",
          "author": {
            "login": "maxnezdyur"
          },
          "bodyText": "Another issue I ran into with Dynamics that I wanted to make known. I have two input files below, for a dynamics, non-damped example. It's very possible I set up the new formulation incorrectly. I know the problem is not damped, but I don't see why the New formulation seems to become more and more compressed.\n\n  \n    \n    \n\n    dynamics.mov\n    \n  \n\n  \n\n  \n\n\nIn the video, the white block is the new formulation and blue block is the AD version.\nThe other objective rates are worse and make the block seem more and more compressed.\n\nNew Formulation with InterialForce\nbeta = 0.25\ngamma = 0.5\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n  large_kinematics = true\n[]\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmax = 0.30\n    ymax = 0.5\n    nx = 15\n    ny = 25\n    elem_type = QUAD4\n    boundary_name_prefix = flexible\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    strain = FINITE\n    new_system = true\n    add_variables = true\n    formulation = TOTAL\n  []\n[]\n\n[Kernels]\n    [inertia_x]\n      type = InertialForce\n      variable = disp_x\n    []\n    [inertia_y]\n      type = InertialForce\n      variable = disp_y\n  []\n[]\n\n[Materials]\n  [elastic_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 1e+4\n    poissons_ratio = 0.4\n  []\n  [stress]\n    type = ComputeLagrangianLinearElasticStress\n    objective_rate = truesdell\n  []\n  [density]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = '1'\n  []\n[]\n\n[BCs]\n  [hold_x]\n    type = ADDirichletBC\n    boundary = 'flexible_bottom'\n    variable = disp_x\n    value = 0\n  []\n  [hold_y]\n    type = ADDirichletBC\n    boundary = 'flexible_bottom'\n    variable = disp_y\n    value = 0\n  []\n\n  [Pressure]\n    [push]\n      function = 200\n      boundary = 'flexible_left '\n      use_automatic_differentiation = true\n      use_displaced_mesh = true\n    []\n  []\n[]\n\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  end_time = 0.5\n  dt = 1e-2\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason '\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_type -pc_factor_shift_type -pc_factor_shift_amount'\n  petsc_options_value = 'lu       superlu_dist                  NONZERO 1e-15'\n\n  line_search = 'none'\n  nl_abs_tol = 1e-10\n  nl_rel_tol = 1e-10\n\n  [TimeIntegrator]\n    type = NewmarkBeta\n    beta = ${beta}\n    gamma = ${gamma}\n  []\n[]\n\n[Outputs]\n  [exo]\n    type = Exodus\n    execute_on = 'INITIAL TIMESTEP_END'\n  []\n  file_base = \"new\"\n  print_linear_residuals = false\n[]\n\nAD Mechanics Version with InertialForce\nbeta = 0.25\ngamma = 0.5\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmax = 0.30\n    ymax = 0.5\n    nx = 15\n    ny = 25\n    elem_type = QUAD4\n    boundary_name_prefix = flexible\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    strain = FINITE\n    decomposition_method = EigenSolution\n    add_variables = true\n    use_automatic_differentiation = true\n  []\n[]\n\n[Kernels]\n    [inertia_x]\n      type = InertialForce\n      variable = disp_x\n    []\n    [inertia_y]\n      type = InertialForce\n      variable = disp_y\n  []\n[]\n\n[Materials]\n  [elastic_tensor]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = 1e+4\n    poissons_ratio = 0.4\n  []\n  [stress]\n    type = ADComputeLinearElasticStress\n  []\n  [density]\n    type = GenericConstantMaterial\n    prop_names = 'density'\n    prop_values = '1'\n  []\n[]\n\n[BCs]\n  [hold_x]\n    type = ADDirichletBC\n    boundary = 'flexible_bottom'\n    variable = disp_x\n    value = 0\n  []\n  [hold_y]\n    type = ADDirichletBC\n    boundary = 'flexible_bottom'\n    variable = disp_y\n    value = 0\n  []\n\n  [Pressure]\n    [push]\n      function = 200\n      boundary = 'flexible_left '\n      use_automatic_differentiation = true\n      use_displaced_mesh = true\n    []\n  []\n[]\n\n[Preconditioning]\n  [SMP]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n  end_time = 0.5\n  dt = 1e-2\n  solve_type = 'NEWTON'\n  petsc_options = '-snes_converged_reason -ksp_converged_reason '\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_type -pc_factor_shift_type -pc_factor_shift_amount'\n  petsc_options_value = 'lu       superlu_dist                  NONZERO 1e-15'\n\n  line_search = 'none'\n  nl_abs_tol = 1e-10\n  nl_rel_tol = 1e-10\n\n  [TimeIntegrator]\n    type = NewmarkBeta\n    beta = ${beta}\n    gamma = ${gamma}\n  []\n[]\n\n[Outputs]\n  [exo]\n    type = Exodus\n    execute_on = 'INITIAL TIMESTEP_END'\n  []\n  file_base = \"ad\"\n  print_linear_residuals = false\n[]\n\n[Dampers]\n[jac]\ntype = ElementJacobianDamper\n[]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24891",
          "updatedAt": "2023-07-06T16:19:02Z",
          "publishedAt": "2023-07-03T16:42:46Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "What do the equilibrium shapes look like if you run a quasi static analysis?",
                  "url": "https://github.com/idaholab/moose/discussions/24891#discussioncomment-6346026",
                  "updatedAt": "2023-07-03T17:03:28Z",
                  "publishedAt": "2023-07-03T17:03:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "Without the InterialForce Kernels.",
                          "url": "https://github.com/idaholab/moose/discussions/24891#discussioncomment-6346075",
                          "updatedAt": "2023-07-03T17:06:24Z",
                          "publishedAt": "2023-07-03T17:06:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "So this implies a time integration error. Similar to your other post, try reducing the time step size.",
                          "url": "https://github.com/idaholab/moose/discussions/24891#discussioncomment-6363769",
                          "updatedAt": "2023-07-05T14:41:39Z",
                          "publishedAt": "2023-07-05T14:41:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "So for this quasi-static problem, how would you get comparable results? Load-stepping the pressure term?",
                          "url": "https://github.com/idaholab/moose/discussions/24891#discussioncomment-6363924",
                          "updatedAt": "2023-07-05T14:53:25Z",
                          "publishedAt": "2023-07-05T14:53:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "For steady problems and large deformation, does the new formulation require more attention? For 2 type = Steady (no time integration) problems (new vs old), I get the results below.\nBlue is the old method, and white is the new method.\n\nAlso volume postprocessors data:\nOld Method\nPostprocessor Values:\n+----------------+----------------+\n| time           | volume         |\n+----------------+----------------+\n|   0.000000e+00 |   1.500000e-01 |\n|   1.000000e+00 |   1.492346e-01 |\n+----------------+----------------+\n\nNew Method\nPostprocessor Values:\n+----------------+----------------+\n| time           | volume         |\n+----------------+----------------+\n|   0.000000e+00 |   1.500000e-01 |\n|   1.000000e+00 |   1.334580e-01 |\n+----------------+----------------+\n\nThis is seems like such a large difference for this quantity of interest for a steady problem.",
                          "url": "https://github.com/idaholab/moose/discussions/24891#discussioncomment-6364382",
                          "updatedAt": "2023-07-05T15:23:55Z",
                          "publishedAt": "2023-07-05T15:23:54Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Here is a comparison of new (green naghdi, black wireframe) vs old (red with white wireframe) with dt = 5e-4:",
                  "url": "https://github.com/idaholab/moose/discussions/24891#discussioncomment-6363851",
                  "updatedAt": "2023-07-05T14:46:16Z",
                  "publishedAt": "2023-07-05T14:46:15Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "Would you recommend setting up time step recommendations (i.e. time step limits) based on the strain incrementation performed by the new system? Maybe as a material time step?",
                          "url": "https://github.com/idaholab/moose/discussions/24891#discussioncomment-6376108",
                          "updatedAt": "2023-07-06T16:19:02Z",
                          "publishedAt": "2023-07-06T16:19:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error with Compiling",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Dear MOOSEers,\nWhen I compile my application, the error always pop up, as shown in the screenshot, do u have any idea of what's the reason of it? Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/24902",
          "updatedAt": "2023-07-06T16:07:50Z",
          "publishedAt": "2023-07-05T12:19:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Can you please attach the output of running the diagnostics script in moose/scripts",
                  "url": "https://github.com/idaholab/moose/discussions/24902#discussioncomment-6362885",
                  "updatedAt": "2023-07-05T13:23:27Z",
                  "publishedAt": "2023-07-05T13:23:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "do you mean this one?\nlibmesh_diagnostic.log",
                          "url": "https://github.com/idaholab/moose/discussions/24902#discussioncomment-6363248",
                          "updatedAt": "2023-07-05T13:53:20Z",
                          "publishedAt": "2023-07-05T13:53:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "When I cat/grep through your diagnostic log, I am not finding any hits for \"20.02.5\". I am not sure how that path is being made relevant during make of hound.\nHowever, I am finding the following in the log relating to slurm:\n/usr/bin/gcc -I/shared/apps/.gcc/8.3/openmpi/4.0.5/include -fexceptions -pthread -L/shared/apps/.gcc/8.3/hwloc/2.4.1/lib -L/opt/slurm/current/lib -Wl,-rpath -Wl,/shared/apps/.gcc/8.3/hwloc/2.4.1/lib -Wl,-rpath -Wl,/opt/slurm/current/lib -Wl,-rpath -Wl,/shared/apps/.gcc/8.3/openmpi/4.0.5/lib -Wl,--enable-new-dtags -L/shared/apps/.gcc/8.3/openmpi/4.0.5/lib -lmpi\n\nSpecifically:\n-L/opt/slurm/current/lib\nI think perhaps some part of MOOSE was built while on a different machine, where /opt/slurm/20.02.5 was available, but no longer. Did you perchance build some of the MOOSE dependencies/MOOSE itself while on a headnode for your cluster?",
                          "url": "https://github.com/idaholab/moose/discussions/24902#discussioncomment-6363417",
                          "updatedAt": "2023-07-05T14:09:09Z",
                          "publishedAt": "2023-07-05T14:09:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thanks for reply. I cannot fully understand, I do build MOOSE in  the home folder on cluster, in parallel with other apps.",
                          "url": "https://github.com/idaholab/moose/discussions/24902#discussioncomment-6364459",
                          "updatedAt": "2023-07-05T15:30:36Z",
                          "publishedAt": "2023-07-05T15:30:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Something 'changed' from when you built PETSc, to when you built libMesh, to when you built MOOSE, to when you built hound. During one of those steps, /opt/slurm/20.02.5 was available... and then became unavailable.",
                          "url": "https://github.com/idaholab/moose/discussions/24902#discussioncomment-6364596",
                          "updatedAt": "2023-07-05T15:44:53Z",
                          "publishedAt": "2023-07-05T15:44:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Thanks. I cleaned the home folder and reinstalled MOOSE, but there was error after installed Petsc and do the check as below. what's the problem here",
                          "url": "https://github.com/idaholab/moose/discussions/24902#discussioncomment-6374559",
                          "updatedAt": "2023-07-06T13:50:44Z",
                          "publishedAt": "2023-07-06T13:50:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Does not look like a big \"diff\" to me.\nCan you paste text under triple quotes instead of screen shots please\nDoes the rest of the installation work?",
                          "url": "https://github.com/idaholab/moose/discussions/24902#discussioncomment-6375507",
                          "updatedAt": "2023-07-06T15:21:18Z",
                          "publishedAt": "2023-07-06T15:21:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "OK, I'll do copy-paste.\nSo it puzzles me, as I followed the protocol on the MOOSE website, but it does not proceed correctly, even at petsc stage. The rest also does not work.\nBTW, the installation protocol is changing now and then, what's the reason for that?",
                          "url": "https://github.com/idaholab/moose/discussions/24902#discussioncomment-6375997",
                          "updatedAt": "2023-07-06T16:06:27Z",
                          "publishedAt": "2023-07-06T16:06:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We adapt the protocols as we find better ways to explain and more resilient installation methods, nothing wrong there",
                          "url": "https://github.com/idaholab/moose/discussions/24902#discussioncomment-6376010",
                          "updatedAt": "2023-07-06T16:07:50Z",
                          "publishedAt": "2023-07-06T16:07:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "I want to make block rather than rectangular box.",
          "author": {
            "login": "bosxered"
          },
          "bodyText": "Hello Moose experts.\nI want to make a simulation block like the following.\n1. Trapezoid.\n\nFigure 1.\nI wanted to make a trapezoidal block.\nI tried StackGenerator and combined rectangular block and triangular block but it failed.\nHere is the input file and the error message.\n#####\nxmax = 35\nymax = 20\n#####\n\n[Mesh]\n  [./poly]\n    type = PolyLineMeshGenerator\n    points = '0.0 0.0 0.0\n              ${xmax} 2.0 0.0\n              ${xmax} 0.0 0.0'\n    loop = true\n#   num_edges_between_points = 20\n  []\n  [./tri]\n    type = XYDelaunayGenerator\n    boundary = 'poly'\n    refine_boundary = false\n    desired_area = 1\n#    output = true\n  []\n  [./gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 35\n    ny = 20\n    nz = 0\n    xmin = 0.00\n    xmax = ${xmax}\n    ymin = 0.00\n    ymax = ${ymax}\n    zmin = 0\n    zmax = 0\n    elem_type = QUAD4\n  [../]\n  [./stack]\n    type = StackGenerator\n    dim = 2\n    inputs = 'gen tri'\n  []\n[]\n\n===================================================================================\n=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES\n=   RANK 0 PID 72460 RUNNING AT cnode14\n=   KILLED BY SIGNAL: 11 (Segmentation fault)\n===================================================================================\n\nThe reason why I didn't use only the PolyLineMeshGenerator and the XYDelaunayGenerator is that I believed I didn't want to make uneven and rough initial condition like Figure 2. An example of even and clean-cut initial condition is shown in Figure 3.\n\n\nFigure 2. When I used only the PolyLineMeshGenerator and the XYDelaunayGenerator. Uneven and rough initial condition are made.\n\nFigure 3. An example of even and clean-cut initial condition.\n2. Boundary can be expressed as a simple function of x.\nAlso, I want to make a block of which boundary can be expressed as a function of x such as sine function or polynomial.\n\nFigure 4.\nIs there any way to make this? Can you tell me how?\nThank you so much for reading.",
          "url": "https://github.com/idaholab/moose/discussions/24876",
          "updatedAt": "2023-07-06T07:52:12Z",
          "publishedAt": "2023-06-30T08:27:24Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nyou are on the right track by making parsed curves.\nYou just want to not use the stack generator and use a stitchedmeshgenerator instead to merge the two blocks.\nAlso please note that you cannot have BOTH quad4 and tri elements in the same subdomain, they need to be in different subdomains (but they can be in the same mesh)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24876#discussioncomment-6325483",
                  "updatedAt": "2023-07-06T15:40:48Z",
                  "publishedAt": "2023-06-30T12:27:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Thank you so much!",
                          "url": "https://github.com/idaholab/moose/discussions/24876#discussioncomment-6371058",
                          "updatedAt": "2023-07-06T07:52:13Z",
                          "publishedAt": "2023-07-06T07:52:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}