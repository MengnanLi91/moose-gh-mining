{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMS0xNVQyMDo1MjoyMS0wNjowMM4AROBZ"
    },
    "edges": [
      {
        "node": {
          "title": "Error Using AnnularMesh",
          "author": {
            "login": "zsren"
          },
          "bodyText": "Hi,\nI am having receiving error message while using annular mesh. Could you please help on this? Thanks so much!\nZR\n*** ERROR ***\nEach subdomain must contain at least one Kernel.\nThe following block(s) lack an active kernel: 1 \n\nStack frames: 11\n0: 0   libmesh_opt.0.dylib                 0x000000010ae223a3 libMesh::print_trace(std::__1::basic_ostream<char, std::__1::char_traits<char> >&) + 1091\n1: 1   libmoose-opt.0.dylib                0x000000010a2b2a07 moose::internal::mooseErrorRaw(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >) + 823\n2: 2   libmoose-opt.0.dylib                0x00000001094535b1 void mooseError<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >&&) + 257\n3: 3   libmoose-opt.0.dylib                0x0000000109e29f47 NonlinearSystemBase::checkKernelCoverage(std::__1::set<unsigned short, std::__1::less<unsigned short>, std::__1::allocator<unsigned short> > const&) const + 4471\n4: 4   libmoose-opt.0.dylib                0x0000000109942834 FEProblemBase::checkProblemIntegrity() + 1572\n5: 5   libmoose-opt.0.dylib                0x0000000109cc339f ActionWarehouse::executeActionsWithAction(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) + 1359\n6: 6   libmoose-opt.0.dylib                0x0000000109cf2ed8 ActionWarehouse::executeAllActions() + 280\n7: 7   libmoose-opt.0.dylib                0x000000010a2839f2 MooseApp::runInputFile() + 98\n8: 8   libmoose-opt.0.dylib                0x000000010a27ef40 MooseApp::run() + 960\n9: 9   in718-opt                           0x00000001083ffbe4 main + 132\n10: 10  libdyld.dylib                       0x00007fff6bdb7cc9 start + 1\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor",
          "url": "https://github.com/idaholab/moose/discussions/22748",
          "updatedAt": "2022-11-19T10:10:55Z",
          "publishedAt": "2022-11-18T11:53:21Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe mesh contains a block with no kernels.\nVery likely, the variables or the kernels are block restricted, and your mesh contains several blocks. Some of these blocks are not covered by the block restriction you are using\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22748#discussioncomment-4179112",
                  "updatedAt": "2022-11-18T17:17:44Z",
                  "publishedAt": "2022-11-18T17:17:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you could paste your input here if you dont find the block restriction issue",
                          "url": "https://github.com/idaholab/moose/discussions/22748#discussioncomment-4179113",
                          "updatedAt": "2022-11-18T17:18:00Z",
                          "publishedAt": "2022-11-18T17:17:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zsren"
                  },
                  "bodyText": "Hi Guillaume\uff0c\nThanks for your prompt reply and helpful suggestions! I found the issue and it works now.\nZR",
                  "url": "https://github.com/idaholab/moose/discussions/22748#discussioncomment-4183420",
                  "updatedAt": "2022-11-19T10:10:52Z",
                  "publishedAt": "2022-11-19T10:10:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How does Cohesive zone actually works? for modelling stress with faults",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Hi guys,\nThe documentation and examples for CZM are quite insufficient to me, I'm not sure how to implement it to my problem.\nhttps://mooseframework.inl.gov/syntax/Modules/TensorMechanics/CohesiveZoneMaster/\nLet's say the example below.\nthe objective of the simulation is to look into stress/strain change over mining steps (similar to coal mining problem)\n\nBlock = blockID saperation\nRed = faults OR cohesive zone (cohesive element in Abaqus), as I read from 'CohesiveZoneMaster', BreakMeshByBlockGenerator will duplicate the note at the blocks above and below the fault line (red). Can I basically just import a similar Abaqus mesh without having to use BreakMeshByBlockGenerator?\nThen I am not sure how does it work, will CZMInterfaceKernel automatically pick up these fault lines?\nas I see from the example, I only see this ...\n[Modules/TensorMechanics/CohesiveZoneMaster]\n  [./czm1]\n    boundary = 'interface'\n    displacements = 'disp_x disp_y disp_z'\n  [../]\n[]\n\nThen the properties of CohesiveZone is later defined under [Materials] block\n  [./czm_3dc]\n    type = SalehaniIrani3DCTraction\n    boundary = 'interface'\n    normal_gap_at_maximum_normal_traction = 1\n    tangential_gap_at_maximum_shear_traction = 0.5\n    maximum_normal_traction = 100\n    maximum_shear_traction = 70\n    displacements = 'disp_x disp_y disp_z'\n  [../]\n\nand that's pretty much it, I am not sure if MOOSE's czm is applicable to my problem, would be nice if we have cohesive elements like Abaqus instead, so we basically can identify the faults from an input mesh.\nIt would be nice if someone could shed some light. Thank you\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/18240",
          "updatedAt": "2022-11-21T22:34:04Z",
          "publishedAt": "2021-07-02T05:46:08Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "Just wondering if anyone has ever implemented CZM with MOOSE at all?",
                  "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-977205",
                  "updatedAt": "2022-06-08T09:10:44Z",
                  "publishedAt": "2021-07-08T01:34:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "I'm not sure what you mean by \"like Abaqus\". Moose can definitely import a mesh from Abaqus .inp file though. Then BreakMeshByBlockGenerator should work.\n@arovinelli knows more about czm in moose.",
                  "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1015953",
                  "updatedAt": "2022-06-08T09:10:45Z",
                  "publishedAt": "2021-07-17T11:42:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Thanks for your reply @hugary1995.\nAs far as I know, Abaqus use cohesive elements but MOOSE use cohesive interfaces. Hence, I'm not sure if I import mesh with cohesive elements from Abaqus, will MOOSE czm automatically recognise it as an interface OR I have to use BreakMeshByBlockGenerator in order to generate interfaces and remove cohesive elements from the mesh.\n@arovinelli I'm also following your finite strain CZM, looking forward to using it!",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1016050",
                          "updatedAt": "2022-06-08T09:10:53Z",
                          "publishedAt": "2021-07-17T12:45:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I see. I think you'll have to remove those cohesive elements in the Abaqus mesh.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1016075",
                          "updatedAt": "2022-06-08T09:10:53Z",
                          "publishedAt": "2021-07-17T13:02:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@Traiwit It is definitely applicable to your problem as it's very similar to what I use it for.\nThe \"problem\" is setting up the mesh correctly. Unfortunately you can't use an ABAQUS mesh with cohesive elements directly for this problem. You will need to remove the ABAQUS cohesive elements, assign different \"block_ids\" to the different regions of your mesh around which you want cohesive interfaces, you could use cubit to achieve this. Then in your input file use break mesh by block generator to split the mesh. It will create a boundary called interface around all the blocks. That is the boundary representing the cohesive zone.\nSo ideally you should start with a mesh that looks like the figure on the left.\n\nThe cohesive interface, (teh boundary named interface in MOOSE) will be like the on on the right.\nWhen you specify Modules/TensorMechanics/CohesiveZoneMaster/cmz1/boundary=interface will tell MOOSE to add cohesive interface kernels on the boundary called interface, that's how the system work, no much more to do. Finally, in the materials you also specify the boundary=interface .  Nothing more is needed to make the simulation run.\nHope this helps, if you have more questions just let me know",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1016222",
                          "updatedAt": "2022-06-08T09:10:53Z",
                          "publishedAt": "2021-07-17T14:37:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @arovinelli Thank for your reply!\nI've tried to work with this testing mesh (attached), there are 2 blocks but for some reason, BreakMeshByBlockGenerator doesn't seem to work, it does not create an interface between these 2 blocks.\n[mesh]\n  type = FileMeshGenerator\n   file = converting_in.e\n   construct_side_list_from_node_list=true\n   []\n        [./breakmesh]\n          input = mesh\n          type = BreakMeshByBlockGenerator\n          split_interface=true\n          show_info = true\n        [../]\n  show_info = true\n  allow_renumbering=false\n\nNot sure if I miss anything. is there a limitation that I'm not aware of? for example, predefined duplicated nodes etc...\nKind regards,\nTraiwi\n\nmesh_CZM_test.zip",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032649",
                          "updatedAt": "2022-07-06T19:09:41Z",
                          "publishedAt": "2021-07-21T13:52:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Also another question, how would you work around with such a fault (attached figure), where the CZM is right in the middle of the geometry",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032656",
                          "updatedAt": "2022-07-06T19:09:58Z",
                          "publishedAt": "2021-07-21T13:54:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "Hi @arovinelli Thank for your reply!\nI've tried to work with this testing mesh (attached), there are 2 blocks but for some reason, BreakMeshByBlockGenerator doesn't seem to work, it does not create an interface between these 2 blocks.\n[mesh]\n  type = FileMeshGenerator\n   file = converting_in.e\n   construct_side_list_from_node_list=true\n   []\n        [./breakmesh]\n          input = mesh\n          type = BreakMeshByBlockGenerator\n          split_interface=true\n          show_info = true\n        [../]\n  show_info = true\n  allow_renumbering=false\n\nNot sure if I miss anything. is there a limitation that I'm not aware of? for example, predefined duplicated nodes etc...\nKind regards,\nTraiwi\n\nmesh_CZM_test.zip\n\nyes the mesh should not already have duplicated nodes, otherwise the algorithm will not find neighbors. That is exactly what is happening in your case.\nFor your second question is a bit trickier but the same principle apply. One way of doing it is to use the BreakMeshByBlockGenerator block_pair option see here.  That would require careful design of domains id.\nI guess what we should really do in your case is to implement a join mesh algorithm such that you could start from a mesh from which you have removed cohesive elements... If you fill this might be an important tool could you open a ticket requesting for it?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032805",
                          "updatedAt": "2022-07-06T19:10:06Z",
                          "publishedAt": "2021-07-21T14:20:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Hi @arovinelli Thank for your reply!\nI've tried to work with this testing mesh (attached), there are 2 blocks but for some reason, BreakMeshByBlockGenerator doesn't seem to work, it does not create an interface between these 2 blocks.\n[mesh]\n  type = FileMeshGenerator\n   file = converting_in.e\n   construct_side_list_from_node_list=true\n   []\n        [./breakmesh]\n          input = mesh\n          type = BreakMeshByBlockGenerator\n          split_interface=true\n          show_info = true\n        [../]\n  show_info = true\n  allow_renumbering=false\n\nNot sure if I miss anything. is there a limitation that I'm not aware of? for example, predefined duplicated nodes etc...\nKind regards,\nTraiwi\n\nmesh_CZM_test.zip\n\nyes the mesh should not already have duplicated nodes, otherwise the algorithm will not find neighbors. That is exactly what is happening in your case.\nFor your second question is a bit trickier but the same principle apply. One way of doing it is to use the BreakMeshByBlockGenerator block_pair option see here. That would require careful design of domains id.\nI guess what we should really do in your case is to implement a join mesh algorithm such that you could start from a mesh from which you have removed cohesive elements... If you fill this might be an important tool could you open a ticket requesting for it?\n\nIf your mesh already has duplicated nodes along the interface, there is no reason to use BreakMeshByBlockGenerator again to create the interface.\nFor your second question, if you still want to use CZM, maybe another option is to implement a new MeshGenerator that uses a lower dimension mesh (i.e. fracture surface) to create the CZM interface instead of using the blocks.\nFor your application, are you trying to model crack propagation or just model the discrete fracture surfaces?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032894",
                          "updatedAt": "2022-07-06T19:10:24Z",
                          "publishedAt": "2021-07-21T14:33:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @jiangwen84 @arovinelli thank you for your reply\nI am working on mine modelling in order to produce stress field, displacements, and damage (plastic strain) v time.\nThe faults within the mesh are pre-defined (Abaqus with cohesive elements).\nis there a way to manually generate the interface between the two blocks with mesh that has duplicated nodes? or the only way to work around this is to merge them back and apply BreakMeshByBlockGenerator\nIt seems like BreakMeshByBlockGenerator can be split into 2 sub-algorithms (from the attached figure).",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032996",
                          "updatedAt": "2022-07-06T19:10:41Z",
                          "publishedAt": "2021-07-21T14:52:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Yes, we need to start with a fully connected mesh and then apply BreakMeshByBlockGenerator to create the interface and reconstruct the connectivity. The reason for that is that we need to use the neighbor information from the original mesh in our InterfaceCZM kernel.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1033622",
                          "updatedAt": "2022-07-06T19:10:38Z",
                          "publishedAt": "2021-07-21T15:45:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "@jiangwen84 @arovinelli sorry gents, I still can't get over this\nI'm checking BreakMeshByBlockGenerator.C I see it does 3 things, 1) making new duplicated nodes 2) attach the nodes back to the elements and then 3) create the cohesive interface. I only need to extract the last part (3) from the script.\nie I want to create a script that can generate cohesive interface from any of the available data listed below:\nWhat I have available from Abaqus mesh are:\n\nduplicated nodes (list of node pairs)\nlist of surface pairs\nlist of element pairs\n\n\nis it possible to use any of these in order to generate the cohesive interface? I'm not very good with C++ it would be very helpful if you could point out which section of BreakMeshByBlockGenerator.C I should take out?\nThank you very much, much appreciated.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1042118",
                          "updatedAt": "2022-07-06T19:10:40Z",
                          "publishedAt": "2021-07-23T12:31:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "arovinelli"
                  },
                  "bodyText": "@jiangwen84 you need to reconstruct the connectivity somehow... as far as I know, there is not a generator available that start from a split mesh and reconstruct the connectivity or do we?",
                  "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032921",
                  "updatedAt": "2022-06-08T09:10:53Z",
                  "publishedAt": "2021-07-21T14:39:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@jiangwen84 you need to reconstruct the connectivity somehow... as far as I know, there is not a generator available that start from a split mesh and reconstruct the connectivity or do we?\n\n@arovinelli  Yes, we need to implement new generators. The current CZM interface generator uses blocks to define the interface location. A second option I suggest is to use lower dimension mesh to define the interface. But we need to make sure that lower dimension mesh sits on the element edges of the computation mesh. Either way we need reconstruct the connectivity.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1032982",
                          "updatedAt": "2022-06-08T09:10:55Z",
                          "publishedAt": "2021-07-21T14:49:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "arovinelli"
                          },
                          "bodyText": "@jiangwen84 you need to reconstruct the connectivity somehow... as far as I know, there is not a generator available that start from a split mesh and reconstruct the connectivity or do we?\n\n@arovinelli Yes, we need to implement new generators. The current CZM interface generator uses blocks to define the interface location. A second option I suggest is to use lower dimension mesh to define the interface. But we need to make sure that lower dimension mesh sits on the element edges of the computation mesh. Either way we need reconstruct the connectivity.\n\nIf nodes are coincident wouldn't be easier simply to look for element with coincident faces but not sharing all the nodes? once we find the faces we simply add them to a boundary, still it would be difficult to discern between different surfaces...",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-1033011",
                          "updatedAt": "2022-06-08T09:10:55Z",
                          "publishedAt": "2021-07-21T14:56:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "chunhuizhao478"
                  },
                  "bodyText": "I think this question is relevant to our problem, so I would like to post my questions here: Is there a way for CZM to create/identify embedded cracks? I don't think the \"BreakMeshByBlockGenerator\" is able to handle this since there is no actual \"block\" between the crack interfaces. Or we need to get our hand dirty to pre-split, provide the list and write them in the code as suggested by arovinelli?",
                  "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3974914",
                  "updatedAt": "2022-10-26T22:28:57Z",
                  "publishedAt": "2022-10-26T22:28:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "If you mean pre-existing embedded cracks, at the moment we only have two mesh generators for generating cohesive interfaces: BreakMeshByBlockGenerator and ExplodeMeshGenerator. You need to either predefine the subdomains so that you can use the existing mesh generators to generate the embedded cracks, or write your own CZM interface generator.\nIf you want to model actual crack nucleation and propagation, you'll want to use the ExplodeMeshGenerator and apply the CZM model everywhere, as every element-element pair is a potential nucleation site.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3974974",
                          "updatedAt": "2022-10-26T22:39:34Z",
                          "publishedAt": "2022-10-26T22:39:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks for your reply. For the current stage we would like to introduce multiple pre-existing cracks. To use \"BreakMeshByBlockGenerator\", one needs to set different block-id to either side of the crack. For the case where it is not a through crack, what would be the best way to assign block-id? Could subdomains just surrounding the crack be easily identified?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3975178",
                          "updatedAt": "2022-10-26T22:54:25Z",
                          "publishedAt": "2022-10-26T22:54:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Nice figure. How are you generating the mesh with the element edges aligned along the crack? If this mesh is generated using an external meshing tool, there should be an easy way to identify the blocks based on the starting and ending points of the pre-existing cracks.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3975300",
                          "updatedAt": "2022-10-26T23:04:24Z",
                          "publishedAt": "2022-10-26T23:04:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks. If I use Gmsh, after creating the crack, I need to find a way to identify elements ID that surround the crack, then pass the information into MOOSE and assign different ID for elements on either side, then break the crack interface, is this correct?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3984408",
                          "updatedAt": "2022-10-27T17:25:37Z",
                          "publishedAt": "2022-10-27T17:25:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Btw, do you suggest using Gmsh or CUBIT as external mesh generator? Which one would be better?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3984439",
                          "updatedAt": "2022-10-27T17:27:41Z",
                          "publishedAt": "2022-10-27T17:27:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Thanks. If I use Gmsh, after creating the crack, I need to find a way to identify elements ID that surround the crack, then pass the information into MOOSE and assign different ID for elements on either side, then break the crack interface, is this correct?\n\nThat's correct, although I'm not sure how to conditionally assign a physical surface in gmsh, based on my limited experience with gmsh.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3986835",
                          "updatedAt": "2022-10-27T22:39:55Z",
                          "publishedAt": "2022-10-27T22:39:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Btw, do you suggest using Gmsh or CUBIT as external mesh generator? Which one would be better?\n\ngmsh is free while cubit probably has more features. Your institution may be hosting a license of cubit.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3986839",
                          "updatedAt": "2022-10-27T22:41:06Z",
                          "publishedAt": "2022-10-27T22:41:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "BTW, generating a CZM interface based on starting and ending points of a line segment is also useful for us, so I may be able to write a mesh generator to do that later this year. You are welcome to create an issue to help me track that",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3986848",
                          "updatedAt": "2022-10-27T22:43:23Z",
                          "publishedAt": "2022-10-27T22:43:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "\"there should be an easy way to identify the blocks based on the starting and ending points of the pre-existing cracks.\" Just want to make sure if there is another way, all I can think of right now is write scripts and play around in MSH file to get the information, but it is not easy to do.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3986865",
                          "updatedAt": "2022-10-27T22:46:54Z",
                          "publishedAt": "2022-10-27T22:46:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "It might be easier to use the gmsh python api.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-3987007",
                          "updatedAt": "2022-10-27T23:23:07Z",
                          "publishedAt": "2022-10-27T23:23:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "chunhuizhao478"
                  },
                  "bodyText": "I would like to ask for the reference article if possible for cohesive zone model implementation in moose (It is mentioned that the cohesive zone model is implemented using a discrete Galerkin approach).",
                  "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4131864",
                  "updatedAt": "2022-11-14T05:32:02Z",
                  "publishedAt": "2022-11-14T05:32:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "For small strain, it is very simple DG-like constraint. For large strain, this report https://www.osti.gov/biblio/1658575 is a good one. For mesh generator, see https://doi.org/10.1016/j.advengsoft.2014.04.002",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4131951",
                          "updatedAt": "2022-11-14T05:59:18Z",
                          "publishedAt": "2022-11-14T05:59:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks for your reply, for now we are dealing with small strain, but would like to gain more idea behind the model, could you direct me to similar DG-like constraint articles? Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4141277",
                          "updatedAt": "2022-11-14T22:52:19Z",
                          "publishedAt": "2022-11-14T22:52:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Did you read the mesh generator paper? It seems that they have listed a few reference in their introduction section. If you cannot find what you need, let us know.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4141483",
                          "updatedAt": "2022-11-14T23:37:35Z",
                          "publishedAt": "2022-11-14T23:37:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Hi, I checked the mesh generator paper, but I'm not sure that is the same idea in the cohesive zone model implementation in MOOSE: The papers listed there are about hybrid DG/CZM methods, where \"zero thickness interface element\" is still introduced, but in the description of MOOSE, there is no cohesive element introduced in the formulation at all. So could you direct me to more specific articles where MOOSE adopts? Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4150821",
                          "updatedAt": "2022-11-15T21:44:00Z",
                          "publishedAt": "2022-11-15T21:43:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I think if you introduce a discontinuity at an element edge (where this element is connected to its neighbor), that edge can be viewed as the so-called zero thickness element between this element and its neighbor.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4151109",
                          "updatedAt": "2022-11-15T22:27:09Z",
                          "publishedAt": "2022-11-15T22:27:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks, these are very helpful. I'll look into the reference articles.\nTo be more specific, the attempt to explode every element-element boundary as a CZM and study crack nucleation and propagation bring up some questions about its fundamentals:\n\nWhether the jump [[u]] is evaluated at quadrature point of interface element (plus/mins side) or nodal points?\nHow are the nodes sharing the same coordinate (after node duplication) interact with each other if one surface has experience tangential/normal jump and pass the motion forward to other surfaces? Take the three middle nodes in the figure for example.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4151283",
                          "updatedAt": "2022-11-15T22:59:54Z",
                          "publishedAt": "2022-11-15T22:59:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "The jump is computed at qps on element edges. I don't quite get your 2nd question. Could you help me understand what you mean by \"pass the motion forward to other surfaces\"?",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4152116",
                          "updatedAt": "2022-11-16T01:40:35Z",
                          "publishedAt": "2022-11-16T01:40:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Thanks, I\u2019m just wondering if there is some continuity relations among the three nodes in the center so that if one surface has tangential jump, the other two surfaces can be affected (like a rupture propagates towards to other surfaces) or put it in the other way, how is cohesive zone model handle crack propagation in this case.",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4152309",
                          "updatedAt": "2022-11-16T01:58:06Z",
                          "publishedAt": "2022-11-16T01:58:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chunhuizhao478"
                          },
                          "bodyText": "Sorry if this may sound confusing, I try to understand how element cohesive zone surface interact with its neighbors",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4152331",
                          "updatedAt": "2022-11-16T02:00:35Z",
                          "publishedAt": "2022-11-16T02:00:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi guys, I still don't see the current MOOSE CZM and BreakMeshByBlockGenerator could handle more complex systems such as the one below:\n\n\nThese are C3D6 elements embedded within C3D4 mesh and connecting the node pair via NodalConstraint (works well with hydro/porousflow problems, but too expensive for mech problems)\nI still believe introducing cohesive elements (zero thickness elements) still the way to go in the case that we already have pre-defined faults/cracks in the system.\nKind regards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/18240#discussioncomment-4173486",
                          "updatedAt": "2022-11-18T03:35:19Z",
                          "publishedAt": "2022-11-18T03:35:18Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Tensor Mechanics and Heat Conduction coupling",
          "author": {
            "login": "krb-nantes"
          },
          "bodyText": "Hi everyone!\nI am currently trying to make a code using Tensor Mechanics Action to calculate the SED for a piece of Zircaloy-4 with a temperature transient. I will add at the end the input for Initial Conditions, Boundary Conditions, TensorMechanics/Master, and Materials block I used for this code.\nWhen I do the simulation using the same mesh, but with only Heat Conduction or only Tensor Mechanics, both work, just when I try to put them together it does not converge anymore.\n*Note 1: If I do not use the \"use_displaced_mesh = true\" it returns a negative temperature in some elements in ZryThermal material.\n*Note 2: I tried to add the ZryThermalExpansionMATPROEigenstrain in Material, but it did not change.\nIf anyone has any idea on how could I solve this problem, I appreciate the help!\n**INPUT**\n[Functions]\n####### FUNCTION FOR HEAT CONDUCTION PROBLEM #########\n  [temp_IC]\n    type = ParsedFunction\n    value = 588.70              #-35561*x+643.15 Initial T constant or as a gradient, does not change convergency.\n  []\n  [inner_temperature_profile]\n    type = PiecewiseLinear\n    format = columns\n    xy_data = '0                622.26\n               9616346.107      622.36\n               10974285.48      441.15\n               11449485.48      293.15'\n  []\n  [outer_temp_profile]\n    type = PiecewiseLinear\n    format = columns\n    xy_data = '0                588.70\n               9616346.107      588.70\n               10974285.48      293.15\n               11449485.48      293.15'\n  []\n####### FUNCTION FOR TENSOR MECHANICS #########  \n  [inner_disp_profile]\n    type = PiecewiseBilinear\n    axis = 1\n    data_file = inner_disp_x.csv\n  []\n  [outer_disp_profile]\n    type = PiecewiseBilinear\n    axis = 1\n    data_file = outer_disp_x.csv\n  []\n[]\n\n[ICs]\n    [temp_ic]\n        type = FunctionIC\n        variable = temp\n        function = temp_IC\n    []\n[]\n\n[BCs]\n########### BC FOR HEAT CONDUCTION ##########\n  [outer_temp]\n    type = FunctionDirichletBC\n    variable = temp\n    boundary = 'right spallation'\n    function = outer_temp_profile\n    use_displaced_mesh = true\n    preset = false\n  []\n  [inner_temperature]\n    type = FunctionDirichletBC\n    variable = temp\n    boundary = 'left'\n    function = inner_temperature_profile\n    use_displaced_mesh = true\n    preset = false\n  []\n########### BC FOR TENSOR MECHANICS ##########\n [inner_disp]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = 'left'\n    function = inner_disp_profile\n    preset = false\n    use_displaced_mesh = true\n  []\n  [outer_disp]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = 'right'\n    function = outer_disp_profile\n    preset = false\n    use_displaced_mesh = true\n  []\n  [no_disp_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0.0\n    preset = false\n    use_displaced_mesh = true\n  []\n[]\n[Modules/TensorMechanics/Master]\n    [tensor]                        # this division is necessary\n        strain = SMALL\n        incremental = true\n        add_variables = true\n        generate_output = 'stress_xx stress_yy stress_zz vonmises_stress hoop_stress strain_xx strain_yy strain_zz hoop_strain'\n        planar_formulation = PLANE_STRAIN\n    []\n[]\n\n[Materials]\n########### MATERIAL FOR HEAT CONDUCTION #####\n  [clad_thermal]\n    type = ZryThermal\n    block = '0'\n    temperature = temp\n    use_displaced_mesh = true\n  []\n  [density_clad]\n    type = Density\n    block = '0'\n    density = 6550                         # kg/m3\n  []\n  [oxide_conduction]                    # delta-ZrH1.66 @ 500K\n    type = GenericConstantMaterial\n    prop_values =  '1.675 0'            # W/mK\n    prop_names = 'thermal_conductivity thermal_conductivity_dT'\n    block = '1'\n    use_displaced_mesh = true\n  []\n  [oxide_density]\n    type = GenericConstantMaterial\n    prop_values = 6150                  # kg/m3 from AZOMaterials\n    block = '1'\n    prop_names = 'density'\n  []\n  [oxide_cp]\n    type = GenericConstantMaterial\n    prop_values = 540                   # J/kgK\n    block = '1'\n    prop_names = 'specific_heat'\n    use_displaced_mesh = true\n  []\n########### MATERIAL FOR TENSOR MECHANICS #########\n  [strain_energy_density]\n    type = StrainEnergyDensity\n    incremental = true\n    use_displaced_mesh = true\n    block = '0 1'\n  []\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 99e+9 \n    poissons_ratio = 0.3\n    block = '0 1'\n    use_displaced_mesh = true\n  []  \n  [elastic_stress]\n    type = ComputeMultipleInelasticStress\n    inelastic_models = 'isoplas'\n    block = '0 1'\n  []\n  [isoplas]\n    type = IsotropicPlasticityStressUpdate\n    yield_stress = 381e6 \n    hardening_constant = 0.0\n    use_displaced_mesh = true\n  []\n[]\n\n**CSV FILES**\n_outer_disp_x:_\n0,0.003736,0.007472,0.011207\n0,0,0,0,0\n9616346.107,1.29E-06,1.28E-06,1.27E-06,1.27E-06\n10974285.48,-1.08E-05,-1.08E-05,-1.08E-05,-1.08E-05\n11449485.48,-1.20E-05,-1.20E-05,-1.20E-05,-1.20E-05\n\n_inner_disp_x:_\n0,0.003736,0.007472,0.011207\n0,0,0,0,0\n9616346.107,1.72E-06,1.70E-06,1.69E-06,1.69E-06\n10974285.48,-9.20E-06,-9.20E-06,-9.20E-06,-9.20E-06\n11449485.48,-1.05E-05,-1.05E-05,-1.05E-05,-1.05E-05",
          "url": "https://github.com/idaholab/moose/discussions/22348",
          "updatedAt": "2023-01-04T00:00:39Z",
          "publishedAt": "2022-10-10T17:55:00Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "What type of simulation are you trying to do?  If you are trying to do a Steady calculation - you may want to use Transient instead... and ramp up the temperature / boundary conditions.\nYou can also try to \"decouple\" these - but still solve the coupled problem.  Set temperature as an AuxiliaryVariable and then give it a constant value that is reasonable... and couple that in as temperature in your TensorMechanics problem and make sure that solves.  You may just have an unreasonable material property somewhere that depends on temperature.",
                  "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3843445",
                  "updatedAt": "2022-10-10T23:18:57Z",
                  "publishedAt": "2022-10-10T23:18:57Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "Also: you have several HUGE constants in your TensorMechanics.  That will make it tough to converge the heat conduction problem (due to the residual / jacobian entries being so much smaller).  You may want to try scaling / automatic scaling.  The scaling parameters are in the Executioner block... you can see them at the bottom of the page here: https://mooseframework.inl.gov/source/executioners/Transient.html",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3843458",
                          "updatedAt": "2022-10-10T23:21:37Z",
                          "publishedAt": "2022-10-10T23:21:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Also why did you set preset = false in all the BCs? which example input did you work from?",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3875471",
                          "updatedAt": "2022-10-14T03:50:43Z",
                          "publishedAt": "2022-10-14T03:50:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "For solid-mechanics it can sometimes be necessary to turn off preset - imagine a DirichletBC for displacement that is large enough to invert elements... that's exactly what would instantly happen if preset is on.\nOn the other hand - if you're not going to invert elements with your displacement, it is certainly better to use preset.  Double-edged sword.",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3880879",
                          "updatedAt": "2022-10-14T16:50:22Z",
                          "publishedAt": "2022-10-14T16:50:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Probably off-topic here, @friedmud I think I was the person who said preset=true is good for all my (mechanics) problems several years ago when we consolidated preset and dirichlet BCs. But over the years I've found that preset=false performs better for plasticity problems with a high hardening rate (even when the preset BC isn't inverting elements). My hypothesis is that the preset BC is forcing certain elements into the return mapping when they shouldn't in the equilibriated solution.\nAnyways, preset=true is still a good default by in large. But the scenario I mentioned above may be a collective knowledge we should document at some point...",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3881003",
                          "updatedAt": "2022-10-14T17:10:52Z",
                          "publishedAt": "2022-10-14T17:10:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "That's good to know @hugary1995 .  Turning off preset will allow the solver to \"solve to\" the final solution... moving with everything else in the system.  This can be \"softer\"... akin to taking small timesteps and letting everything equilibrate during the solve... so I think it makes sense.",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3881044",
                          "updatedAt": "2022-10-14T17:16:22Z",
                          "publishedAt": "2022-10-14T17:16:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "krb-nantes"
                          },
                          "bodyText": "Hi all, thanks for helping!\n1- I worked based on the examples in: moose/modules/tensor_mechanics/test/tests/strain_energy_density/ , but I am not actually using it in all the BC only for the axial constraint, it was my mistake posting here with this in all of them. And, indeed depending on the displacement value I set its necessary to use the preset = false.\n2- I tried set the constant temperature as an AuxVariable, and it actually did not change;\n3- I think the most possible solution here will be the scaling. As I understood from your suggestion, I apply the scaling parameters on Executioner block (and I am using Transient), however, with these parameters I could only scale the displacement variables and it seems to be going, but very slow. So, I was wondering if it is possible to scale the Material properties as well (Young's modulus and Yield Stress), or this is already done in \"automatic_scaling\", this still not so clear to me?",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3881343",
                          "updatedAt": "2022-10-14T18:06:34Z",
                          "publishedAt": "2022-10-14T18:06:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "The automatic scaling scales the \"result\" of using those large material properties (the residuals and jacobians that are resultant).  When you say \"going slow\"... what does that mean?  Can you post some of your convergence history?",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3897727",
                          "updatedAt": "2022-10-17T15:26:10Z",
                          "publishedAt": "2022-10-17T15:26:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any update on this @krb-nantes ?",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3937906",
                          "updatedAt": "2022-10-22T00:05:26Z",
                          "publishedAt": "2022-10-22T00:05:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "krb-nantes"
                          },
                          "bodyText": "Hi all, so in my first try using the scaling, the code stopped because it reached the wall time of 5h, it did not finished, but also did not have any errors. I do not think I have the performance metrics file for this time, but I have this one below. This one correspond for the same file, I ran it a second time and then I had a non-convergency error.\nmesoscale_TM_HC_performance_metrics.csv",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-3962980",
                          "updatedAt": "2022-10-25T18:00:22Z",
                          "publishedAt": "2022-10-25T18:00:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Any update on this?\nI've also seen some segregate the two solves using a multiapp and do a fixed point iteration. This should be more stable, especially with relaxation, if that s what s needed",
                          "url": "https://github.com/idaholab/moose/discussions/22348#discussioncomment-4149397",
                          "updatedAt": "2022-11-15T18:16:46Z",
                          "publishedAt": "2022-11-15T18:16:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using Variable array and c++ Eigen Library in MOOSE",
          "author": {
            "login": "thewhitewalker10"
          },
          "bodyText": "Hello,\nI\u2019m finding it difficult to replicate the following code I obtained online into MOOSE:\ntemplate <int DisplacementDim>\nPropertyDataType EmbeddedFracturePermeability<DisplacementDim>::value(\n    VariableArray const& variable_array,\n    ParameterLib::SpatialPosition const& pos, double const t,\n    double const /*dt*/) const\n{\n    Eigen::Matrix<double, 3, 1> const n = [&]\n    {\n        if (_n_const)\n        {\n            return _n;\n        }\n        auto const sigma = formEigenTensor<3>(\n            std::get<SymmetricTensor>(variable_array.total_stress));\n        Eigen::SelfAdjointEigenSolver<Eigen::Matrix<double, 3, 3>> e_s(sigma);\n        return (Eigen::Matrix<double, 3, 1>)e_s.eigenvectors().col(2);\n    }();\n\nIn the code, it seems the total stress was obtained and transformed into a symmetric tensor. Then, eigenvectors were derived from this symmetric tensor using various functions from the c++ Eigen Library. The code finally returns the second column of the eigenvectors. Is there a way to do this in moose differently? If not, how do I approach it? My main problem is how to obtain the eigenvectors from the stress. Any clue on how to approach it will be helpful. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/22703",
          "updatedAt": "2022-12-10T07:32:32Z",
          "publishedAt": "2022-11-15T04:50:12Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can use Eigen in MOOSE the same way.\nIs the issue converting from an array variable value to an Eigen::Matrix?\nWhere is this snippet from?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4147816",
                  "updatedAt": "2022-11-15T15:30:36Z",
                  "publishedAt": "2022-11-15T15:30:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "thewhitewalker10"
                          },
                          "bodyText": "Hi @GiudGiud\nYes, the issue is in two folds. First, I\u2019m looking for a way to obtain the total stress (I'm developing a new material using the porousflow module btw). And second, how to obtain the eigenvectors using the eigen library.\nThe code is an OGS (opengeosys) code.",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4148803",
                          "updatedAt": "2022-11-17T19:02:19Z",
                          "publishedAt": "2022-11-15T17:04:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is the stress the quantity you solve the equation for?\nor is it a function/dependent on the quantities you solve the equations for?\ndepending on this, a variable or a material property (which can be a tensor) make more sense",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4148892",
                          "updatedAt": "2022-11-15T17:14:58Z",
                          "publishedAt": "2022-11-15T17:14:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "thewhitewalker10"
                          },
                          "bodyText": "The stress is the quantity being solved for. I'm assuming I need to make the stress an auxvariable. correct?",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4148914",
                          "updatedAt": "2022-11-15T17:17:45Z",
                          "publishedAt": "2022-11-15T17:17:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If the stress is the quantity to solve in the nonlinear system, then stress should be a nonlinear variable, basically a main variable, not an aux variable\nPlease have a look at other porous flow stress models and/or how the tensor mechanics module deals with stress.",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4149094",
                          "updatedAt": "2022-11-15T17:41:11Z",
                          "publishedAt": "2022-11-15T17:41:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "thewhitewalker10"
                          },
                          "bodyText": "Hello @GiudGiud,\nGot it. it works now! Actually, the property I'm solving for is dependent on the stress from the tensor mechanics action. So, I obtained this stress as a material property. I'm however getting an error trying to use \"Eigen::SelfAdjointEigenSolver\" to compute eigenvectors. Does moose compute eigenvectors differently? Here is the error message:\nChecking if header needs updating: /home/thewalker/MOOSE/projects/moose/framework/include/base/MooseRevision.h...\nCompiling C++ (in opt mode) /home/thewalker/MOOSE/projects/ergs/build/unity_src/materials_Unity.C...\nIn file included from /home/thewalker/MOOSE/projects/ergs/build/unity_src/materials_Unity.C:2:\n/home/thewalker/MOOSE/projects/ergs/src/materials/PorousFLowPermeabilityEmbeddedFractures.C: In lambda function:\n/home/thewalker/MOOSE/projects/ergs/src/materials/PorousFLowPermeabilityEmbeddedFractures.C:89:79: error: no matching function for call to 'Eigen::SelfAdjointEigenSolver<Eigen::Matrix<double, 3, 3> >::SelfAdjointEigenSolver(const MaterialProperty<RankTwoTensorTempl<double> >&)'\n   89 |         Eigen::SelfAdjointEigenSolver<Eigen::Matrix<double, 3, 3>> e_s(_stress);\n      |                                                                               ^\nIn file included from /home/thewalker/mambaforge3/libmesh/include/Eigen/Eigenvalues:39,\n                 from /home/thewalker/mambaforge3/libmesh/include/Eigen/Dense:7,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/RankFourTensor.h:26,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/DataIO.h:20,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/MaterialProperty.h:17,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/MaterialData.h:12,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/BlockRestrictable.h:15,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/MaterialBase.h:14,\n                 from /home/thewalker/MOOSE/projects/moose/framework/build/header_symlinks/Material.h:13,\n                 from /home/thewalker/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowMaterial.h:12,\n                 from /home/thewalker/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowMaterialVectorBase.h:12,\n                 from /home/thewalker/MOOSE/projects/moose/modules/porous_flow/build/header_symlinks/PorousFlowPermeabilityBase.h:12,\n                 from /home/thewalker/MOOSE/projects/ergs/build/header_symlinks/PorousFLowPermeabilityEmbeddedFractures.h:3,\n                 from /home/thewalker/MOOSE/projects/ergs/src/materials/PorousFLowPermeabilityEmbeddedFractures.C:1,\n                 from /home/thewalker/MOOSE/projects/ergs/build/unity_src/materials_Unity.C:2:\n/home/thewalker/mambaforge3/libmesh/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:162:14: note: candidate: 'template<class InputType> Eigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const Eigen::EigenBase<OtherDerived>&, int) [with InputType = InputType; _MatrixType = Eigen::Matrix<double, 3, 3>]'\n  162 |     explicit SelfAdjointEigenSolver(const EigenBase<InputType>& matrix, int options = ComputeEigenvectors)",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4161311",
                          "updatedAt": "2022-11-18T21:09:37Z",
                          "publishedAt": "2022-11-16T21:20:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThere is a mismatch in the data types.\nThe error says you are feeding a material property, but the object you may construct only accepts some eigen format (of a tensor I assume)\nYou will need to perform the conversion\nhere you pass const MaterialProperty<RankTwoTensorTempl<double>\nerror: no matching function for call to 'Eigen::SelfAdjointEigenSolver<Eigen::Matrix<double, 3, 3> >::SelfAdjointEigenSolver(const MaterialProperty<RankTwoTensorTempl<double> >&)'\n\nwhat is accepted is Eigen::EigenBase<OtherDerived>&\n/home/thewalker/mambaforge3/libmesh/include/Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h:162:14: note: candidate: 'template<class InputType> Eigen::SelfAdjointEigenSolver<_MatrixType>::SelfAdjointEigenSolver(const Eigen::EigenBase<OtherDerived>&, int) [with InputType = InputType; _MatrixType = Eigen::Matrix<double, 3, 3>]'\n\nYou want to look at examples of code calling Eigen::Matrix. I m sure we have this exact conversion done somewhere already\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22703#discussioncomment-4180725",
                          "updatedAt": "2022-11-18T21:12:42Z",
                          "publishedAt": "2022-11-18T21:12:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "LinearNodalConstraint support for distributed mesh",
          "author": {
            "login": "KhaledNabilSharafeldin"
          },
          "bodyText": "Hello,\nWhen using LinerNodalConstraint with --distributed-mesh flag, it result in an error:\n[bell-a323:116589:0:116589] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x30)\n[bell-a323:116591:0:116591] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x30)\n==== backtrace (tid: 116589) ====\n 0 0x000000000004cb95 ucs_debug_print_backtrace()  ???:0\n 1 0x0000000000036400 killpg()  ???:0\n 2 0x0000000000f85d4c LinearNodalConstraint::LinearNodalConstraint()  ???:0\n 3 0x0000000000fa9159 Registry::build<LinearNodalConstraint, MooseObject>()  ???:0\n 4 0x000000000197a1ff Factory::create()  ???:0\n 5 0x0000000000ce895d Factory::create<Constraint>()  ???:0\n 6 0x0000000000c851c3 NonlinearSystemBase::addConstraint()  ???:0\n 7 0x0000000001124e4d Action::timedAct()  ???:0\n 8 0x000000000112ec99 ActionWarehouse::executeActionsWithAction()  ???:0\n 9 0x00000000011310e1 ActionWarehouse::executeAllActions()  ???:0\n10 0x0000000001988882 MooseApp::runInputFile()  ???:0\n11 0x000000000198a2be MooseApp::run()  ???:0\n12 0x000000000040e3c9 main()  ???:0\n13 0x0000000000022555 __libc_start_main()  ???:0\n14 0x000000000040e60b _start()  ???:0\n=================================\n==== backtrace (tid: 116591) ====\n 0 0x000000000004cb95 ucs_debug_print_backtrace()  ???:0\n 1 0x0000000000036400 killpg()  ???:0\n 2 0x0000000000f85d4c LinearNodalConstraint::LinearNodalConstraint()  ???:0\n 3 0x0000000000fa9159 Registry::build<LinearNodalConstraint, MooseObject>()  ???:0\n 4 0x000000000197a1ff Factory::create()  ???:0\n 5 0x0000000000ce895d Factory::create<Constraint>()  ???:0\n 6 0x0000000000c851c3 NonlinearSystemBase::addConstraint()  ???:0\n 7 0x0000000001124e4d Action::timedAct()  ???:0\n 8 0x000000000112ec99 ActionWarehouse::executeActionsWithAction()  ???:0\n 9 0x00000000011310e1 ActionWarehouse::executeAllActions()  ???:0\n10 0x0000000001988882 MooseApp::runInputFile()  ???:0\n11 0x000000000198a2be MooseApp::run()  ???:0\n12 0x000000000040e3c9 main()  ???:0\n13 0x0000000000022555 __libc_start_main()  ???:0\n14 0x000000000040e60b _start()  ???:0\n=================================\n--------------------------------------------------------------------------\nPrimary job  terminated normally, but 1 process returned\na non-zero exit code. Per user-direction, the job has been aborted.\n--------------------------------------------------------------------------\n------------------------------------------------------------\nA process or daemon was unable to complete a TCP connection\nto another process:\n  Local host:    bell-a323\n  Remote host:   bell-a324\nThis is usually caused by a firewall on the remote host. Please\ncheck that any firewall (e.g., iptables) has been disabled and\ntry again.\n------------------------------------------------------------\n--------------------------------------------------------------------------\nmpiexec noticed that process rank 2 with PID 0 on node bell-a323 exited on signal 11 (Segmentation fault).\n\nYou can recreate this error by running moose/modules/tensor_mechanics/test/tests/dynamics/linear_constraint/disp_mid.i in distributed mesh, you'll just have to edit the mesh block with allow_renumbering = false then running it using 3 or more processes (I guess because then those nodes wont be allocated to the same processor)\nis there a quick fix for this?\nThanks in advance!\nKhaled",
          "url": "https://github.com/idaholab/moose/discussions/20782",
          "updatedAt": "2022-11-18T17:38:51Z",
          "publishedAt": "2022-04-13T14:19:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere's only 2 elements in that test.\nSo yeah it crashes with 3 processes, I've noticed this happen for some applications.\nThis is really not a big concern. We recommend 20,000 elements per process at minimum.\nIf you have a real case where you get a crash, please let us know though.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2564103",
                  "updatedAt": "2022-06-07T04:22:31Z",
                  "publishedAt": "2022-04-14T03:42:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "Thanks Guillaume for your reply!\nI used this example so you can replicate it on your end since I am actually running into this during normal runs, it just refuses to run on even 2 processors for 300k element mesh.\nand to make sure that the problem is indeed in this constraint, I took it out and it runs perfectly fine using distributed mesh without it.\nhere's the terminal error that I get when running my app\n[bell-b004:104102:0:104102] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x5a)\n[bell-b004:104104:0:104104] Caught signal 11 (Segmentation fault: address not mapped to object at address 0x5a)\n==== backtrace (tid: 104102) ====\n 0 0x000000000004cb95 ucs_debug_print_backtrace()  ???:0\n 1 0x0000000000036400 killpg()  ???:0\n 2 0x0000000000c8f0e5 SystemBase::augmentSendList()  ???:0\n 3 0x0000000000444a82 libMesh::DofMap::prepare_send_list()  ???:0\n 4 0x0000000000d90e62 libMesh::System::init_data()  ???:0\n 5 0x0000000000d91436 libMesh::System::init()  ???:0\n 6 0x0000000000d4bd2d libMesh::EquationSystems::init()  ???:0\n 7 0x0000000000b3104d FEProblemBase::init()  ???:0\n 8 0x0000000001124e4d Action::timedAct()  ???:0\n 9 0x000000000112ec99 ActionWarehouse::executeActionsWithAction()  ???:0\n10 0x00000000011310e1 ActionWarehouse::executeAllActions()  ???:0\n11 0x0000000001988882 MooseApp::runInputFile()  ???:0\n12 0x000000000198a2be MooseApp::run()  ???:0\n13 0x000000000040e3c9 main()  ???:0\n14 0x0000000000022555 __libc_start_main()  ???:0\n15 0x000000000040e60b _start()  ???:0\n=================================\n==== backtrace (tid: 104104) ====\n 0 0x000000000004cb95 ucs_debug_print_backtrace()  ???:0\n 1 0x0000000000036400 killpg()  ???:0\n 2 0x0000000000c8f0e5 SystemBase::augmentSendList()  ???:0\n 3 0x0000000000444a82 libMesh::DofMap::prepare_send_list()  ???:0\n 4 0x0000000000d90e62 libMesh::System::init_data()  ???:0\n 5 0x0000000000d91436 libMesh::System::init()  ???:0\n 6 0x0000000000d4bd2d libMesh::EquationSystems::init()  ???:0\n 7 0x0000000000b3104d FEProblemBase::init()  ???:0\n 8 0x0000000001124e4d Action::timedAct()  ???:0\n 9 0x000000000112ec99 ActionWarehouse::executeActionsWithAction()  ???:0\n10 0x00000000011310e1 ActionWarehouse::executeAllActions()  ???:0\n11 0x0000000001988882 MooseApp::runInputFile()  ???:0\n12 0x000000000198a2be MooseApp::run()  ???:0\n13 0x000000000040e3c9 main()  ???:0\n14 0x0000000000022555 __libc_start_main()  ???:0\n15 0x000000000040e60b _start()  ???:0\n=================================\n--------------------------------------------------------------------------\nPrimary job  terminated normally, but 1 process returned\na non-zero exit code. Per user-direction, the job has been aborted.\n--------------------------------------------------------------------------\n--------------------------------------------------------------------------\nmpiexec noticed that process rank 0 with PID 104102 on node bell-b004 exited on signal 11 (Segmentation fault).\n--------------------------------------------------------------------------\n\nI'm setting up these constraints in an action, that might be why the error is slightly different.\nThanks again!\nKhaled",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2594569",
                          "updatedAt": "2022-06-07T04:22:32Z",
                          "publishedAt": "2022-04-19T16:16:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@sveerara @jwpeterson who wrote this object\nIs this supposed to work in parallel?\nIs there another nodal constraint you'd recommend to try here?",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2595466",
                          "updatedAt": "2022-06-07T04:22:38Z",
                          "publishedAt": "2022-04-19T18:37:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "I'm having the same problem with my constraints action > taking so much memory + only can run in replicated mesh version of parallel (which take so much memory), ~15Gb per rank for 4.6 million elements problem.\nI suspect that it's because there might be some node-pairs that are on the different meshes (after splitting).\nRegards,\nTraiwit",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2597436",
                          "updatedAt": "2022-06-07T04:22:38Z",
                          "publishedAt": "2022-04-20T01:15:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The fix might be simple though, it might just be needing more ghosting.",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2597842",
                          "updatedAt": "2022-06-07T04:23:12Z",
                          "publishedAt": "2022-04-20T03:15:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "It seems to be doing something along this line,\n\n  \n    \n      moose/framework/src/constraints/LinearNodalConstraint.C\n    \n    \n        Lines 69 to 81\n      in\n      40ea18c\n    \n  \n  \n    \n\n        \n          \n           // Add elements connected to primary node to Ghosted Elements \n        \n\n        \n          \n           for (const auto & dof : _primary_node_ids) \n        \n\n        \n          \n           { \n        \n\n        \n          \n             // defining primary nodes in base class \n        \n\n        \n          \n             _primary_node_vector.push_back(dof); \n        \n\n        \n          \n            \n        \n\n        \n          \n             auto node_to_elem_pair = node_to_elem_map.find(dof); \n        \n\n        \n          \n             mooseAssert(node_to_elem_pair != node_to_elem_map.end(), \"Missing entry in node to elem map\"); \n        \n\n        \n          \n             const std::vector<dof_id_type> & elems = node_to_elem_pair->second; \n        \n\n        \n          \n            \n        \n\n        \n          \n             for (const auto & elem_id : elems) \n        \n\n        \n          \n               _subproblem.addGhostedElem(elem_id); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nI don't know if _mesh.getNodeList(_mesh.getBoundaryID(_secondary_node_set_id)); on line 51 would work for parallel or not.",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2600276",
                          "updatedAt": "2022-06-07T04:23:12Z",
                          "publishedAt": "2022-04-20T10:53:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "did you run this in debug? Does it crash there?",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2602676",
                          "updatedAt": "2022-06-10T07:37:34Z",
                          "publishedAt": "2022-04-20T16:15:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@lindsayad do you mind taking a look at LinearNodalConstraint ? We have two users who seek to use it in parallel. I think the testing for this was insufficient so it lost that capability",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2606378",
                          "updatedAt": "2022-06-10T07:37:34Z",
                          "publishedAt": "2022-04-21T06:04:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "don't want to hijack this thread, but this is my problem: I make LinearNodalConstraint into an action, so I can easily work with 200k+ pairs of nodes.\nit is basically just a loop feeding each node-pair into LinearNodalConstraint\n\nregisterMooseAction(\"traiApp\", MPCbe, \"add_constraint\");\n\nInputParameters\nMPCbe::validParams()\n{\n  InputParameters params = Action::validParams();\n  params.addParam<std::vector<unsigned int>>(\"primary_node_ids\", \"The primary node IDs.\");\n  params.addParam<std::vector<unsigned int>>(\"secondary_node_ids\",\n                                           \"The list of secondary node ids\");\n  return params;\n}\nMPCbe::MPCbe(const InputParameters & params)\n  : Action(params),\nprimary_node_ids(getParam<std::vector<unsigned int>>(\"primary_node_ids\")),\nsecondary_node_ids(getParam<std::vector<unsigned int>>(\"secondary_node_ids\"))\n\n{\n}\nvoid\nMPCbe::act()\n\n{\nfor (unsigned cur_num = 0; cur_num<primary_node_ids.size() ; cur_num++)\n{\n\n  std::vector<Real> weights_in (1);\n  std::vector<unsigned int> primary_node_ids_in (1);\n  std::vector<unsigned int> secondary_node_ids_in (1);\n\n  weights_in.at(0) = 1;\n  primary_node_ids_in.at(0) = primary_node_ids[cur_num];\n  secondary_node_ids_in.at(0) = secondary_node_ids[cur_num];\n\n  InputParameters params = _factory.getValidParams(\"LinearNodalConstraint\");\n  params.set<NonlinearVariableName>(\"variable\") = \"porepressure\";\n  params.set<std::vector<Real>>(\"weights\")= weights_in;\n  params.set<std::vector<unsigned int>>(\"primary\") = primary_node_ids_in;\n  params.set<std::vector<unsigned int>>(\"secondary_node_ids\") = secondary_node_ids_in;\n  params.set<Real>(\"penalty\") = 1e10;\n  _problem->addConstraint(\"LinearNodalConstraint\", \"MPCbe\" + Moose::stringify(cur_num), params);\n\n}\n}",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2606405",
                          "updatedAt": "2022-06-10T07:37:34Z",
                          "publishedAt": "2022-04-21T06:11:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The problem in a simulation is usually peak memory usage. We could probably add a ghosting functor/relationship manager to keep the elements/nodes around that you need but note that we probably wouldn't end up deleting the remote elements you don't need until the end of all of our MOOSE action execution. So the question is whether your peak memory usage occurs after that point (e.g. during the solve step). If it occurs before that point, then helping you would be more difficult.\nAs it is, it would take time to write the ghosting functor/relationship manager that would support this constraint, which I'm not sure I have. You are welcome to take a look at some of our existing RelationshipManagers and see if there is some inspiration there to help you write your own. If you wanted to take a stab at writing your own, I could help you when you have questions",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2611000",
                          "updatedAt": "2022-06-10T07:37:58Z",
                          "publishedAt": "2022-04-21T18:58:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Related to #16258 (another constraint), needing the same kind of work",
                          "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2612006",
                          "updatedAt": "2022-06-10T07:37:58Z",
                          "publishedAt": "2022-04-21T23:09:04Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jwpeterson"
                  },
                  "bodyText": "Sorry, I don't think I can take any of the credit (or blame) for LinearNodalConstraint.\ngit log --author=Peterson framework/src/constraints/LinearNodalConstraint.C\n\nare all just simple refactoring commits.",
                  "url": "https://github.com/idaholab/moose/discussions/20782#discussioncomment-2595631",
                  "updatedAt": "2022-06-07T04:22:38Z",
                  "publishedAt": "2022-04-19T19:09:52Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "difference",
          "author": {
            "login": "Oops-Qiao"
          },
          "bodyText": "Hello,\nThere is a question in the kernel,\nDoes the following two play the same role in the kernel? Do they have difference or not? Thank you.\nADTimeDerivative::precomputeQpResidual();\n_u_dot[_qp]",
          "url": "https://github.com/idaholab/moose/discussions/22249",
          "updatedAt": "2022-11-17T16:27:32Z",
          "publishedAt": "2022-09-28T12:02:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe are the same\nADReal\nADTimeDerivative::precomputeQpResidual()\n{\n  return _u_dot[_qp];\n}\n\nHowever, this is a precomputeQpResidual routine. So it must be defined alongside a computeQpResidual routine that uses it.\nBe careful with this, it's an optimization and if you dont use it properly you will miss the test function multiplication\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3757362",
                  "updatedAt": "2022-09-28T22:39:50Z",
                  "publishedAt": "2022-09-28T22:39:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Ok\uff0c thank you Guillaume, one question, here\nADTimeDerivative::precomputeQpResidual() is defined as ADReal type. Can I still use it if I have vector like velocity?",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3762353",
                          "updatedAt": "2022-09-29T12:37:52Z",
                          "publishedAt": "2022-09-29T12:37:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "No you ll have to use the corresponding type for an ADvectorKernel.\nIt is likely ADRealVectorValue",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3762418",
                          "updatedAt": "2022-09-29T12:46:17Z",
                          "publishedAt": "2022-09-29T12:46:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "No you ll have to use the corresponding type for an ADvectorKernel. It is likely ADRealVectorValue\n\nSo it is better use  _u_dot[_qp] in the kernel instead of ADTimeDerivative::precomputeQpResidual(), right?",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3762443",
                          "updatedAt": "2022-09-29T12:48:17Z",
                          "publishedAt": "2022-09-29T12:48:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes but don\u2019t forget the test function that\u2019s it",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3762471",
                          "updatedAt": "2022-09-29T12:50:31Z",
                          "publishedAt": "2022-09-29T12:50:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Yes but don\u2019t forget the test function that\u2019s it\n\n\nYes but don\u2019t forget the test function that\u2019s it\n\nSure, since I inherit ADKernelValue, test function will be automatically applied.",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-3762489",
                          "updatedAt": "2022-09-29T12:53:23Z",
                          "publishedAt": "2022-09-29T12:53:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Hello\nThe are the same\nADReal\nADTimeDerivative::precomputeQpResidual()\n{\n  return _u_dot[_qp];\n}\n\nHowever, this is a precomputeQpResidual routine. So it must be defined alongside a computeQpResidual routine that uses it. Be careful with this, it's an optimization and if you dont use it properly you will miss the test function multiplication\nGuillaume\n\nHi Guillaume,\nToday just a question came to my mind regarding your answer above.\nFor example the code below in your moose,\n\nADReal\nADTimeDerivative::precomputeQpResidual()\n{\nreturn _u_dot[_qp];\n\nADHeatConductionTimeDerivative.C\n\nADReal\nADHeatConductionTimeDerivative::precomputeQpResidual()\n{\nreturn _specific_heat[_qp] * _density[_qp] * ADTimeDerivative::precomputeQpResidual();\n}\nI am wondering that if the two bold precomputeQpResidual() plays the same role to multiply the test function, if that is the case, it looks a little bit messed up since we only need to multply once the test function.\nWhat do you suggest to understand it?\nThank you so much.\nQiao",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-4161275",
                          "updatedAt": "2022-11-16T21:15:03Z",
                          "publishedAt": "2022-11-16T21:14:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "This has to do with you modifying precomputeQPResidual. If using precomputeQPResidual then you do not multiply the test function. The link explains it more in-depth https://mooseframework.inl.gov/magpie/syntax/Kernels/ under Optimized Kernel Objects.",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-4161776",
                          "updatedAt": "2022-11-16T22:39:58Z",
                          "publishedAt": "2022-11-16T22:39:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "This has to do with you modifying precomputeQPResidual. If using precomputeQPResidual then you do not multiply the test function. The link explains it more in-depth https://mooseframework.inl.gov/magpie/syntax/Kernels/ under Optimized Kernel Objects.\n\nThanks, that is also my understanding. However, if you see below, it has two times of precomputeQPResidual which means it will then multiply the test function two times. Is it right? This makes me confused.\n@GiudGiud\nADReal\nADHeatConductionTimeDerivative::precomputeQpResidual()\n{\nreturn _specific_heat[_qp] * _density[_qp] * ADTimeDerivative::precomputeQpResidual();\n}",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-4162123",
                          "updatedAt": "2022-11-16T23:48:56Z",
                          "publishedAt": "2022-11-16T23:48:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "maxnezdyur"
                          },
                          "bodyText": "I don't think so. Only the \"final\" precomputeQpResidual() gets multiplied by the test functions. IIRC this is an example of overriding a virtual function so only the ADHeatConductionTimeDerivative::precomputeQpResidual() gets called and multiplied by the test functions. Even though ADTimeDerivative::precomputeQpResidual() is called also by ADHeatConductionTimeDerivative , only the _u_dot[_qp] is incorporated with the ADHeatConductionTimeDerivative. This explanation may be confusing, so sorry for that!",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-4162189",
                          "updatedAt": "2022-11-16T23:59:11Z",
                          "publishedAt": "2022-11-16T23:59:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "ADReal\nADTimeDerivative::precomputeQpResidual()\n{\nreturn _u_dot[_qp];\n\nI really appreciate your patient reply. Just one more question here. if you say \u201conly the _u_dot[_qp] is incorporated \u201d .\nIf we now take look at the ADTimeDerivative document, they have used the following definition with  \"precomputeQpResidual()\" in below.\nDo we have test function multiplied in the code below? If Yes, how to understand your current explanation then. Thanks again.\nADReal\nADTimeDerivative::precomputeQpResidual()\n{\nreturn _u_dot[_qp];\n}",
                          "url": "https://github.com/idaholab/moose/discussions/22249#discussioncomment-4162356",
                          "updatedAt": "2022-11-17T00:11:32Z",
                          "publishedAt": "2022-11-17T00:10:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Does AD support operations except for the four rules?",
          "author": {
            "login": "Raven-pro"
          },
          "bodyText": "Hello, everyone!\nI know AD is based on the chain rule, and using AD variables and kernels can make automatically building jacobian a lot more convenient.\nBut I am wondering if AD support other operations like Exponential operations and Logarithmic operations and many other operations.\nFor now I think exponential operations can be achieved using Utility:pow<> method (I dont know if I am right about that), but how about logarithmic operations and many others. Like, if just use std::log on an AD variable, can the derivative also be calculated correctly?\nI am using MOOSE to develop an APP to solve single-phase flow problem, and the EOS requires operations mentioned above(IAPWS97 formulaitons). The properties are associated with main variables and I think the calculation process may affect the forming of jacobian(like setting them to be constants), increasing the errors, and leding to not convergening.\nSo is there any way to best implement proper operations like Exponential and Logarithmic?\nThank you very much!",
          "url": "https://github.com/idaholab/moose/discussions/22648",
          "updatedAt": "2022-11-17T03:03:15Z",
          "publishedAt": "2022-11-10T06:04:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Raven-pro"
                  },
                  "bodyText": "I just noticed that in the functions, if return type was set to ADReal, no error warning would show up when I use MathUtils:pow or Utility::pow to carry out Exponential operations.\nDoes that mean the derivative can also be properly computed by the both two ways?",
                  "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4105233",
                  "updatedAt": "2022-11-10T08:30:14Z",
                  "publishedAt": "2022-11-10T08:30:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYes AD is supported by most operators. I think atan2 or something similar might be the only one that got reported as not working.\nWill you be re-writing IAWPS properties? You need to have them written with ADReal inputs and return types (or DualReal, an AD number with less derivatives used in fluid properties)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4107444",
                  "updatedAt": "2022-11-10T13:21:42Z",
                  "publishedAt": "2022-11-10T13:21:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Thanks for your reply!\nYes, I am considering adding some functions to the IAPWS properties right now.\nI also have another question, is the derivative of an ADReal variable also an AD?\nIf that's so, when I want to compute some derivatives, I can just use .derivative()[...] to get that, am I right?\nThanks :)",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4113533",
                          "updatedAt": "2022-11-11T03:32:22Z",
                          "publishedAt": "2022-11-11T03:32:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Which IAWPS properties? Do you have your own library?\nYou can get the derivatives through .derivative(), but they dont carry derivatives themselves.\nThey rarely need to?",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4113639",
                          "updatedAt": "2022-11-11T03:57:05Z",
                          "publishedAt": "2022-11-11T03:57:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Can I ask what is missing in IAPWS-IF97 (called Water97FluidProperties) that you need? It was a while since I wrote it, but I though that I had implemented everything in the IAPWS-IF97 paper.",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4113902",
                          "updatedAt": "2022-11-11T05:03:50Z",
                          "publishedAt": "2022-11-11T05:03:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "In fact,  I cannot find formulations of Region4 in Water97FluidProperties, like computing saturation values based on pressure and x, so I added related formulations in it. Except for that, almost all the variables are written in a non-AD manner.\nI am trying to develop a single-phase water flow application, but the result is always wrong, so I am trying to find out the reason, like should I use AD on all the parameters like properties coefficients? I have no idea yet.\nIs there any open-source single-phase MOOSE code available? I think maybe I need more references. :)",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4126363",
                          "updatedAt": "2022-11-13T03:34:02Z",
                          "publishedAt": "2022-11-13T03:34:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Can I ask what is missing in IAPWS-IF97 (called Water97FluidProperties) that you need? It was a while since I wrote it, but I though that I had implemented everything in the IAPWS-IF97 paper.\n\nHello, may I ask you about some convergence issues concerning single-phase 1D flow? I have opened another thread [#22682]. Could you please help me check if there is anything wrong with my code?  I just really cannot find out how to solve it alone, Thank you so much!",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4126655",
                          "updatedAt": "2022-11-13T06:12:24Z",
                          "publishedAt": "2022-11-13T06:12:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Region 4 is the saturation curve - both saturation pressure as a function of temperature and saturation temperature as a function of pressure are implemented. There is a related IAPWS supplementary release for backward equations in Region 4 - is this what is missing?",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4130223",
                          "updatedAt": "2022-11-13T21:22:45Z",
                          "publishedAt": "2022-11-13T21:22:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Yes, I didn't find related formulations in Water97FluidProperties, perhaps that's because I am using the old version MOOSE?\nBut the main problem I am facing is the convergence problem (that's why I tried to implement AD in fp), I am starting to think both AD and non-AD are okay concerning fluid properties as closures (Since my efforts have failed).\nCould you please give me some suggestions about my convergence problem? THX!",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4131484",
                          "updatedAt": "2022-11-14T03:24:41Z",
                          "publishedAt": "2022-11-14T03:24:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Yeah, it sounds like it could be something else",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4131861",
                          "updatedAt": "2022-11-14T05:30:43Z",
                          "publishedAt": "2022-11-14T05:30:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@89018580 do you get convergence with constant fluid properties?\nIf there are some missing properties in Water97FluidProperties we would be very interested in that contribution",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4137148",
                          "updatedAt": "2022-11-14T14:18:51Z",
                          "publishedAt": "2022-11-14T14:18:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Raven-pro"
                          },
                          "bodyText": "Yeah, it sounds like it could be something else\n\nOops, I just checked the Water97FluidProperties.h file, which I have not looked through carefully enough before.\nThe saturation temperature as the function of pressure is achieved in the vaporTemperature function. I thought there weren't formulations of Region4 because I didn't find \"Region4\" in inRegion() function, how careless I am.\nThe Water97FluidProperties does have everything in it.",
                          "url": "https://github.com/idaholab/moose/discussions/22648#discussioncomment-4137792",
                          "updatedAt": "2022-11-14T15:14:54Z",
                          "publishedAt": "2022-11-14T15:14:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "error report in the constructor",
          "author": {
            "login": "Oops-Qiao"
          },
          "bodyText": "Hi expert,\ncould you please help to see how to solve the following problems.\nI have 3 velocity component but in the construtor it generates an error.\nPerhaps I forgot to include some h file? Thank you so much.\nI have following in my constructor:\n_u_x_l(adCoupledValue(\"u_x_l\")),\n_u_y_l(_mesh.dimension() >= 2.0 ? adCoupledValue(\"u_y_l\") : _zero),\nThe reported error is\n_error: operands to '?:' have different types 'const ADVariableValue' {aka 'const MooseArray<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<53> >, true> >'} and 'const VariableValue' {aka 'const MooseArray'}\n_u_y_l(_mesh.dimension() >= 2.0 ? adCoupledValue(\"u_y_l\") : _zero),\nBest regards,\nQiao",
          "url": "https://github.com/idaholab/moose/discussions/22709",
          "updatedAt": "2022-11-16T21:15:33Z",
          "publishedAt": "2022-11-15T18:21:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\n_zero isnt the right value for ad variable values\nyou want to use _ad_zero\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22709#discussioncomment-4149445",
                  "updatedAt": "2022-11-15T18:23:28Z",
                  "publishedAt": "2022-11-15T18:23:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Hello\n_zero isnt the right value for ad variable values\nyou want to use _ad_zero\nGuillaume\n\nThanks very much my dear friend!!!",
                          "url": "https://github.com/idaholab/moose/discussions/22709#discussioncomment-4149531",
                          "updatedAt": "2022-11-15T18:35:07Z",
                          "publishedAt": "2022-11-15T18:35:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "Hello\n_zero isnt the right value for ad variable values\nyou want to use _ad_zero\nGuillaume\n\nHello Guillaume, I have a quick question,\nin the AD version I saw two different ways to define the parameters, what are their differences? Thank you.\n\n\nReal _ambient_convection_alpha;\nhttps://github.com/idaholab/moose/blob/next/modules/navier_stokes/include/materials/INSAD3Eqn.h\n\n\nADReal _hmax;\nhttps://github.com/idaholab/moose/blob/next/modules/navier_stokes/include/materials/INSADTauMaterial.h\n\n\nQiao",
                          "url": "https://github.com/idaholab/moose/discussions/22709#discussioncomment-4150860",
                          "updatedAt": "2022-11-15T21:48:24Z",
                          "publishedAt": "2022-11-15T21:48:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The difference is whether the number carries derivative information or not.\nA constant should pretty much always be a Real not an ADReal, though it s often inconsequential to have it be an ADReal",
                          "url": "https://github.com/idaholab/moose/discussions/22709#discussioncomment-4158921",
                          "updatedAt": "2022-11-16T16:28:36Z",
                          "publishedAt": "2022-11-16T16:28:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Oops-Qiao"
                          },
                          "bodyText": "ok, thanks very much.",
                          "url": "https://github.com/idaholab/moose/discussions/22709#discussioncomment-4161279",
                          "updatedAt": "2022-11-16T21:15:33Z",
                          "publishedAt": "2022-11-16T21:15:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "can the preconditioner be dynamically changed during a simulation?",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Hi everyone,\nSometimes my simulations run nicely until a certain time when they slow down due to some physical occurrence, like applying a new load or flux to the system.  In these cases, it may be advantageous to use a different preconditioner, just for those few timesteps around the physical occurrence.  For instance, usually i could use a \"weak/cheap\" preconditioner like ILU, but around the difficult times, I'd like to use LU.\nIs it possible to instruct MOOSE to use different preconditioners at different nonlinear steps (or time steps), depending on some criterion?   Something like:\nif previous_linear_iterations < 999:\n  preconditioner = ilu\nelse:\n  preconditioner = lu",
          "url": "https://github.com/idaholab/moose/discussions/22692",
          "updatedAt": "2022-11-16T16:52:35Z",
          "publishedAt": "2022-11-14T20:18:07Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "As far as I know we do not support that.\nEven setting the convergence criterion to be time dependent would be super helpful in my mind.\nTagging @friedmud and @lindsayad for awareness and comments.",
                  "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4140441",
                  "updatedAt": "2022-11-14T20:31:25Z",
                  "publishedAt": "2022-11-14T20:31:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Thanks @GiudGiud .   An alternative could be something like:\ntry:\n  ilu\nexcept SolveFailed:\n  try:\n    hypre\n  except SolveFailed:\n    try:\n      lu",
                          "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4140519",
                          "updatedAt": "2022-11-14T20:41:53Z",
                          "publishedAt": "2022-11-14T20:41:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "that could be an alternative strategy to provide more resilience, though you often have to pass options in addition to this, so maybe you d want multiple Preconditioning blocks in the input file.\nI think cutting the time step is a more reasonable choice in the work I do, but I can see that for others.",
                          "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4140550",
                          "updatedAt": "2022-11-14T20:45:29Z",
                          "publishedAt": "2022-11-14T20:45:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Yea, i agree about cutting the timestep - it often works.  However, i would bet the changing the preconditioner also works in many cases, but we haven't had the flexibility to experiment with that approach.  Cutting the timestep usually helps make the problem more linear, but that doesn't necessarily mean easier for the linear solver.",
                          "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4140823",
                          "updatedAt": "2022-11-14T21:29:06Z",
                          "publishedAt": "2022-11-14T21:29:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "To me it also reduces the distance the nonlinear solver has to travel as well.\nfor flow in the NS module there s very few PC that would work without expert settings.",
                          "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4141149",
                          "updatedAt": "2022-11-14T22:22:03Z",
                          "publishedAt": "2022-11-14T22:22:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Strictly speaking you could do this in a custom Executioner but yea we do not have the ability to do this easily from, say, an input file. However, with @reverendbedford's recent changes to allow keeping around the SNES context between timesteps, I think implementing something like this would not be all that difficult. @WilkAndy feel free to create an issue for this if we don't have one already. I don't know when someone from the MOOSE team would be able to take it on, but maybe an external developer would",
                          "url": "https://github.com/idaholab/moose/discussions/22692#discussioncomment-4159187",
                          "updatedAt": "2022-11-16T16:52:35Z",
                          "publishedAt": "2022-11-16T16:52:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Ansys mesh file input to moose",
          "author": {
            "login": "nishant1785"
          },
          "bodyText": "Hi,\nFor first time I have tried using ansys mesh (.msh format) file as an input to a simple diffusion code.  But i get following error in moose:\n*** ERROR ***\nInvalid dimension dim = 4\n\nNote:Actually geometry was generated in abaqus and then imported in ansys to make *.msh mesh file which was later used in MOOSE as mentioned above.\nThank you.",
          "url": "https://github.com/idaholab/moose/discussions/22531",
          "updatedAt": "2022-12-10T07:29:59Z",
          "publishedAt": "2022-10-28T14:06:42Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@jortensi @permcody do you know anyone who has been doing ANSYS->ABAQUS->MOOSE ?",
                  "url": "https://github.com/idaholab/moose/discussions/22531#discussioncomment-3995264",
                  "updatedAt": "2022-10-28T16:49:26Z",
                  "publishedAt": "2022-10-28T16:49:25Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "I don't believe we've ever tried to read Ansys meshes. We do have an Abaqus reader though, but it may not be full featured. libMesh (our I/O library) supports many formats, gmsh, exodus, and even Ascii formats (XDA). You might also consider using our  MeshGenerator system, where you can programmatically build up parameterizeable meshes.",
                          "url": "https://github.com/idaholab/moose/discussions/22531#discussioncomment-3996096",
                          "updatedAt": "2022-10-28T18:09:42Z",
                          "publishedAt": "2022-10-28T18:09:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "nishant1785"
                  },
                  "bodyText": "Okk thank you I will see that.\n\nNishant Gaikwad-7972836355\nM. Tech student\nMaterials Department\nDIAT, DRDO,Girinagar\n411025-Pune\n\u2026\nOn Fri, 28 Oct, 2022, 11:39 pm Cody Permann, ***@***.***> wrote:\n I don't believe we've ever tried to read Ansys meshes. We do have an\n Abaqus reader though, but it may not be full featured. libMesh (our I/O\n library) supports many formats, gmsh, exodus, and even Ascii formats (XDA).\n You might also consider using our MeshGenerator system, where you can\n programmatically build up parameterizeable meshes.\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#22531 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/A3ER5T2G2SHNASQLSQSGP3DWFQJHBANCNFSM6AAAAAARRDM5GI>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/22531#discussioncomment-4000383",
                  "updatedAt": "2022-10-29T03:22:41Z",
                  "publishedAt": "2022-10-29T03:22:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Wang-Yihu"
                  },
                  "bodyText": "Haha, MOOSE Multiphysics cannot read ANSYS mesh (*.msh) in the current version.\nI suggest you:\n\nexport ANSYS Workbench mesh in FLUENT input mesh (*.msh)\nread the *.msh with ICEM CFD\nset the Exodus format, set the boundary conditions, and export it (*.exo)\nThis really works!!!! I use this method!!!!!!",
                  "url": "https://github.com/idaholab/moose/discussions/22531#discussioncomment-4152626",
                  "updatedAt": "2022-11-16T02:52:21Z",
                  "publishedAt": "2022-11-16T02:52:20Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}