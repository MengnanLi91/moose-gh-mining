{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wOS0yNlQwNTo1Mjo0NC0wNTowMM4Abm8l"
    },
    "edges": [
      {
        "node": {
          "title": "Output format for storing and analysing large data",
          "author": {
            "login": "MaheshTummala17"
          },
          "bodyText": "I am working on a model containing nearly 600k elements and storing the different State variable values at ten sync times. For now, I am outputting the data as a CSV, but handling such large data using Excel sheets and importing data via MATLAB/python for plotting is taking a significant amount of time. Which is the better format to store such large data sets? Does MOOSE support HDF5 format?",
          "url": "https://github.com/idaholab/moose/discussions/28727",
          "updatedAt": "2024-10-14T17:43:29Z",
          "publishedAt": "2024-09-29T13:33:03Z",
          "category": {
            "name": "Show and tell"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCSV is likely preferred, a couple of millions of data points should not be unreasonable to work on from Python\nBut if you want to try other techniques, the exodus output can be read in Python using vtk utilities\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28727#discussioncomment-10789396",
                  "updatedAt": "2024-09-29T14:07:21Z",
                  "publishedAt": "2024-09-29T14:07:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to set the BC for certain nodes?",
          "author": {
            "login": "Yulongggggg"
          },
          "bodyText": "I have a 2D square mesh, and I wanted to set the displacement of a node at the bottom of the square, how can I implement it?",
          "url": "https://github.com/idaholab/moose/discussions/28725",
          "updatedAt": "2024-11-20T19:18:15Z",
          "publishedAt": "2024-09-27T19:24:54Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Create a nodeset with just that node then use it in a dirichlet boundary conditions on the dipalacement with that nodeset as the boundary",
                  "url": "https://github.com/idaholab/moose/discussions/28725#discussioncomment-10779355",
                  "updatedAt": "2024-09-27T19:33:01Z",
                  "publishedAt": "2024-09-27T19:33:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "for example using this nodeset-generator\nhttps://mooseframework.inl.gov/source/meshgenerators/BoundingBoxNodeSetGenerator.html\ncreating a tiny bounding box around the node",
                          "url": "https://github.com/idaholab/moose/discussions/28725#discussioncomment-10779745",
                          "updatedAt": "2024-09-27T20:40:07Z",
                          "publishedAt": "2024-09-27T20:40:07Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "RandomIC for different boundaries or blocks",
          "author": {
            "login": "bylore"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi there.\nI am using RandomIC to set the initial condition for my variable 'eta'. When i don't specify the block or the boundary for this random initial conditions, i get the right setting.\n\nWhen i specify the blocks, i get the same right results as above.\nBut when i specify the boundaries instead of the blocks, i get the following.\n\nI use 25 processors for this simulation. It seems that RandomIC only assign random values for every processor in this case.\nHere is my script\n[body_eta_random]\n    type = RandomIC\n    variable = eta\n    #boundary = \"b1_break b2_defect\"\n    block = \"b1_break_QUAD4 b1_break_TRI3 b2_defect_QUAD4\"\n    max = 1.0\n    min = 0.9\n    seed = 0\n  []\n\nMy MOOSE version is git commit 42342ed on 2023-05-18.\nCould you give me some clue?",
          "url": "https://github.com/idaholab/moose/discussions/28720",
          "updatedAt": "2024-09-27T16:11:30Z",
          "publishedAt": "2024-09-27T07:21:40Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe IC does not apply on the interior of the blocks when it is applied on the boundaries. It only applies to the single element that lies on the interior side of the boundary.\nNow as to why each process has a different value anyway, I m not sure.\nWhat are you trying to do here? Block restrict the randomness to a single region?",
                  "url": "https://github.com/idaholab/moose/discussions/28720#discussioncomment-10776015",
                  "updatedAt": "2024-09-27T13:38:18Z",
                  "publishedAt": "2024-09-27T13:38:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "Yeah, I want restrict the randomness to some specific region. At first, I use the parameter block to indict the block where some value I want assign. But I found each node on the boundary of two blocks has two block id number (corresponding to these two blocks). So sometimes I can't assign the right value I want to this kind of nodes. Later I found that making the same set of nodes in one block into boundary and use the parameter boundary can avoid the \"two-block-id\" problem.  This works fine for ConstanIC. But for RandomIC, I got the issue discribled above.",
                          "url": "https://github.com/idaholab/moose/discussions/28720#discussioncomment-10776964",
                          "updatedAt": "2024-09-27T14:57:10Z",
                          "publishedAt": "2024-09-27T14:57:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "boundary and block here represents same set of nodes, but I got different initial values. I'm reporting this to see if I'm using the boundary parameter incorrectly or if this is a potential bug.",
                          "url": "https://github.com/idaholab/moose/discussions/28720#discussioncomment-10777008",
                          "updatedAt": "2024-09-27T15:06:04Z",
                          "publishedAt": "2024-09-27T15:01:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the ICs will likely override each other on those nodes. you have 3 ICs setting a value on the same node",
                          "url": "https://github.com/idaholab/moose/discussions/28720#discussioncomment-10777099",
                          "updatedAt": "2024-09-27T15:08:47Z",
                          "publishedAt": "2024-09-27T15:08:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "are you using multiple ICs then?",
                          "url": "https://github.com/idaholab/moose/discussions/28720#discussioncomment-10777100",
                          "updatedAt": "2024-09-27T15:09:00Z",
                          "publishedAt": "2024-09-27T15:08:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "No, in the issue case, only one IC was used for the concerned variable. I just tied again.\nUsing\n\n[rand_random]\ntype = RandomIC\nvariable = rand\n#boundary = \"b1_break b2_nofail b3_defect\"\nblock = \"b1_break_QUAD4 b1_break_TRI3 b2_nofail_QUAD4 b2_nofail_TRI3 b3_defect_QUAD4\"\nmax = 1.0\nmin = 0.9\nseed = 0\n[]\n\n\n\nI got\n\nWhile using\n\n[rand_random]\ntype = RandomIC\nvariable = rand\nboundary = \"b1_break b2_nofail b3_defect\"\n#block = \"b1_break_QUAD4 b1_break_TRI3 b2_nofail_QUAD4 b2_nofail_TRI3 b3_defect_QUAD4\"\nmax = 1.0\nmin = 0.9\nseed = 0\n[]\nI got\n\nThis time 10 processors were used.",
                          "url": "https://github.com/idaholab/moose/discussions/28720#discussioncomment-10777374",
                          "updatedAt": "2024-09-27T15:32:52Z",
                          "publishedAt": "2024-09-27T15:32:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "does it improve if you specify a distribution?\nI ll raise an issue for this problem. But using \"boundary' does not fix your problem anyway so I recommend you try other ways to get the IC you want.\nProbably a single IC with some logic to work on nodes that are shared between multiple blocks",
                          "url": "https://github.com/idaholab/moose/discussions/28720#discussioncomment-10777428",
                          "updatedAt": "2024-09-27T15:36:56Z",
                          "publishedAt": "2024-09-27T15:36:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bylore"
                          },
                          "bodyText": "Thank you. I can avoid this issue so it does not affect my use.  In my offline installed moose, there is no registered distribution object currently. I\u2018ll get back to you if I have these results later.",
                          "url": "https://github.com/idaholab/moose/discussions/28720#discussioncomment-10777779",
                          "updatedAt": "2024-09-27T16:11:31Z",
                          "publishedAt": "2024-09-27T16:11:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "BC for Use in a Postprocessor",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "How do I resolve this error:\n*** ERROR ***\nTask add_postprocessor is not registered to build BoundaryCondition derived objects",
          "url": "https://github.com/idaholab/moose/discussions/28721",
          "updatedAt": "2024-09-27T15:26:55Z",
          "publishedAt": "2024-09-27T14:33:16Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "You move the boundary condition you placed in the [Postprocessors] block into the [BCs] block",
                  "url": "https://github.com/idaholab/moose/discussions/28721#discussioncomment-10776772",
                  "updatedAt": "2024-09-27T14:38:23Z",
                  "publishedAt": "2024-09-27T14:38:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Thank you. The example code on the website (https://mooseframework.inl.gov/syntax/Postprocessors/index.html#12778715-26f2-4c0c-b586-10bd52d0368e) may not reflect the proper means to accomplish using this postprocessor.\nThe previous error went away, but was replaced with this one:\n*** ERROR ***\nunused parameter 'BCs/totalFlux/coupled_scalar'",
                          "url": "https://github.com/idaholab/moose/discussions/28721#discussioncomment-10777051",
                          "updatedAt": "2024-09-27T15:05:05Z",
                          "publishedAt": "2024-09-27T15:05:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "which object are you using with this parameter?",
                          "url": "https://github.com/idaholab/moose/discussions/28721#discussioncomment-10777065",
                          "updatedAt": "2024-09-27T15:06:11Z",
                          "publishedAt": "2024-09-27T15:06:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ScalarCoupledPostprocessor is a test object, you generally cant use it without adding --allow-test-objects on the command line",
                          "url": "https://github.com/idaholab/moose/discussions/28721#discussioncomment-10777084",
                          "updatedAt": "2024-09-27T15:07:35Z",
                          "publishedAt": "2024-09-27T15:07:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "IntegratedBC",
                          "url": "https://github.com/idaholab/moose/discussions/28721#discussioncomment-10777102",
                          "updatedAt": "2024-09-27T15:09:09Z",
                          "publishedAt": "2024-09-27T15:09:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "IntegratedBC is a base class you could not be using this in an input file.\nCould you please paste your BCs block here?",
                          "url": "https://github.com/idaholab/moose/discussions/28721#discussioncomment-10777164",
                          "updatedAt": "2024-09-27T15:15:39Z",
                          "publishedAt": "2024-09-27T15:15:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 5\n  ny = 5\n  xmax = 1\n  ymax = 1\n  elem_type = QUAD4\n[]\n\n[Variables]\n  [./u]\n    initial_condition = 1\n  [../]\n  [./scalar_variable]\n    family = SCALAR\n    order = FIRST\n    initial_condition = 2\n  [../]\n[]\n\n[Kernels]\n  [./diff]\n    type = Diffusion\n    variable = u\n  [../]\n[]\n\n[ScalarKernels]\n  [./td1]\n    type = ODETimeDerivative\n    variable = scalar_variable\n  [../]\n[]\n\n[BCs]\n  [./leftDirichlet]\n      type = DirichletBC\n      variable = u\n      boundary = 'left'\n      value = 1\n  [../]\n  [./rightDirichlet]\n      type = DirichletBC\n      variable = u\n      boundary = 'right'\n      value = 0\n  [../]\n[]\n\n[Postprocessors]\n  [./totalFlux]\n    type = ScalarCoupledPostprocessor\n    variable = u\n    coupled_scalar = scalar_variable\n    boundary = left\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  dt = 1\n  num_steps = 1\n  solve_type = JFNK\n  l_max_its = 30\n  l_tol = 1e-6\n  nl_max_its = 20\n  nl_rel_tol = 1e-5\n[]\n\n[Outputs]\n  csv = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28721#discussioncomment-10777187",
                          "updatedAt": "2024-09-27T15:24:14Z",
                          "publishedAt": "2024-09-27T15:18:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the issue is here\n[Postprocessors]\n  [./totalFlux]\n    type = ScalarCoupledPostprocessor\n    variable = u\n    coupled_scalar = scalar_variable\n    boundary = left\n  [../]\n[]\n\nthis is a test object. unless you are using the moose executable with --allow-test-objects it wont work\nuse another postprocessor to couple in a scalar variable",
                          "url": "https://github.com/idaholab/moose/discussions/28721#discussioncomment-10777282",
                          "updatedAt": "2024-09-27T15:25:26Z",
                          "publishedAt": "2024-09-27T15:25:26Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TLWise"
                          },
                          "bodyText": "Got it. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/28721#discussioncomment-10777293",
                          "updatedAt": "2024-09-27T15:26:52Z",
                          "publishedAt": "2024-09-27T15:26:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Exodus output skipped timestep when sync only",
          "author": {
            "login": "BoZeng1997"
          },
          "bodyText": "Hi,\nI have an issue with exodus output when running a multiapp problem with output on sync time only. There are timesteps in my sync list that were skipped in exodus output. There is no error message.\nTo reproduce\nI will provide the input file main.i and sub.i in the following comment. Simply run it with {moose-executable} -i main.i (either parallel or serial) then go check the mech.e. You will see step\n0.0004\n0.003 0.004 0.005 0.009\n0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09\n0.1 0.2 0.3\n2.5 3.0 3.5 4.0 4.5\n\nare missing in the file.\nMy moose version\nHere is the info about my MOOSE. I built it on an Ubuntu machine with Conda environment.\nFramework Information:\nMOOSE Version:           git commit e7a20f90 on 2024-03-08\nLibMesh Version:         \nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1",
          "url": "https://github.com/idaholab/moose/discussions/28718",
          "updatedAt": "2024-09-27T14:57:11Z",
          "publishedAt": "2024-09-27T00:34:18Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "BoZeng1997"
                  },
                  "bodyText": "file main.i\ndt=2e-5\nrefine=2\nfilebase=mech\n[Problem]\n  type = FEProblem\n  solve = False\n  kernel_coverage_check = false\n  material_coverage_check = false\n[]\n\n[MultiApps]\n  [sub]\n    type = TransientMultiApp\n    input_files = sub.i\n    cli_args = 'dt=${dt};refine=${refine}'\n    execute_on = 'TIMESTEP_END'\n  []\n[]\n\n[Mesh]\nuniform_refine=${fparse max(0,refine)}\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmax = 25e-3\n    ymin = 0\n    ymax = 5e-3\n    nx = 25\n    ny = 5\n  []\n[]\n\n\n[Variables]\n  [disp_x]\n  []\n[]\n\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu      superlu_dist    '\n\n  start_time = 0\n  end_time = 5.0\n  # dt = ${dt}\n    [TimeSteppers]\n      [time_step]\n        type = FunctionDT\n        function = set_timestep\n      []\n    []\n  fixed_point_max_its = 1\n  accept_on_max_fixed_point_iteration = true\n[]\n\n[Functions]\n  [set_timestep]\n    type = PiecewiseLinear\n    x = '0     0.00198  0.002   0.0089   0.0090  0.0095  0.01  0.098  0.1   0.99   1     5'\n    y = '${dt} ${dt}    1e-4     1e-4     5e-4    5e-4    2e-3   2e-3  0.01  0.01  0.05   0.05'\n  []\n[]\n\n[Outputs]\n  [nemesis]\n    type = Exodus\n    additional_execute_on = 'FINAL'\n    sync_times =  '0.0001 0.0002 0.0003 0.0004 0.0005 0.0006 0.0007 0.0008 0.0009 '\n                  '0.001 0.002 0.003 0.004 0.005 0.006 0.007 0.008 0.009 '\n                  '0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 '\n                  '0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 '\n                  '1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0'\n    sync_only=true\n  []\n  file_base = '${filebase}'\n  print_linear_residuals = false\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/28718#discussioncomment-10769285",
                  "updatedAt": "2024-09-27T00:34:55Z",
                  "publishedAt": "2024-09-27T00:34:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "BoZeng1997"
                          },
                          "bodyText": "file sub.i\n[Problem]\n  type = FEProblem\n  solve = False\n  kernel_coverage_check = false\n[]\n\n[Mesh]\n  uniform_refine=${fparse max(0,refine)}\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmax = 25e-3\n    ymin = 0\n    ymax = 5e-3\n    nx = 25\n    ny = 5\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -snes_type'\n  petsc_options_value = 'lu      superlu_dist     vinewtonrsls'\n\n  start_time = 0\n  end_time = 600\n  # dt = ${dt}\n    [TimeSteppers]\n      [time_step]\n        type = FunctionDT\n        function = set_timestep\n      []\n    []\n[]\n\n[Functions]\n  [set_timestep]\n    type = PiecewiseLinear\n    x = '0     0.00198  0.002   0.0089   0.0090  0.0095  0.01  0.098  0.1   0.99   1     5'\n    y = '${dt} ${dt}    1e-4     1e-4     5e-4    5e-4    2e-3   2e-3  0.01  0.01  0.05   0.05'\n  []\n[]\n\n[Outputs]\n  print_linear_residuals = false\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28718#discussioncomment-10769288",
                          "updatedAt": "2024-09-27T00:35:37Z",
                          "publishedAt": "2024-09-27T00:35:37Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I actually get different time steps in my output. But not the full list.\nI ll create an issue and we ll address it when we can",
                  "url": "https://github.com/idaholab/moose/discussions/28718#discussioncomment-10776927",
                  "updatedAt": "2024-09-27T14:53:56Z",
                  "publishedAt": "2024-09-27T14:53:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "in the mean time just output on all times?",
                          "url": "https://github.com/idaholab/moose/discussions/28718#discussioncomment-10776965",
                          "updatedAt": "2024-09-27T14:57:12Z",
                          "publishedAt": "2024-09-27T14:57:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Modifying the tutorial codes from RACCOON",
          "author": {
            "login": "NeedOfHelp"
          },
          "bodyText": "Hi\nI am a new user of Moose and RACCOON (A parallel finite-element code specialized in phase-field for fracture) and I am currently making simulations of crack and crack growth using phase field. I am using the tutorial code from RACCOON that is named \"Tutorial 2: Mode-I crack propagation\" where the full code can be found in \"tutorials/mode1_brittle_fracture/elasticity.i\". In that code the package\n[elasticity]\ntype = SmallDeformationIsotropicElasticity\nis used, and I'm wondering if it is possible to modify it to Anisotropic elasticity instead?\nIf so, what is the other module called? and how does it affect the rest of the code? and how do I apply it?\nI have looked through the library of RACOON but didn't find anything \"anisotropy\" related.\nI appreciate any help I can get.",
          "url": "https://github.com/idaholab/moose/discussions/23814",
          "updatedAt": "2024-09-27T10:35:29Z",
          "publishedAt": "2023-03-22T13:46:22Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@hugary1995 will know more than me but to go from IsotropicElasticity to an anisotropic model, you just need to find the model that does not specify that it s isotropic.\nSo here, maybe look for SmallDeformationElasticity, and if it doesn't exist, look for a similar model in the phase field module",
                  "url": "https://github.com/idaholab/moose/discussions/23814#discussioncomment-5393663",
                  "updatedAt": "2023-03-22T14:17:43Z",
                  "publishedAt": "2023-03-22T14:17:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "NeedOfHelp"
                          },
                          "bodyText": "Thanks for your relpy.\nI found this, https://mooseframework.inl.gov/source/materials/ComputeElasticityTensor.html , where it shows how to compute different kinds of elasticity tensors. The problem is that I am new to moose and phase field in general so when I tried to modify the codes \"elasticity.i\" and \"fracture.i\", it resulted in bunch of errors since changing/adding in one part of the code, you need to change/add something else in another part of the code.",
                          "url": "https://github.com/idaholab/moose/discussions/23814#discussioncomment-5393828",
                          "updatedAt": "2023-03-22T14:30:13Z",
                          "publishedAt": "2023-03-22T14:30:12Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "RACCOON currently doesn't support anisotropic elasticity.\n\nBad news: You will have to write code to do that, which requires some basic knowledge of C++.\nGood news: It will be a straightforward extension.\nBad news: I currently don't have the bandwidth to do that for you. So you are on your own, though I'd be happy to help along the way.\n\nSo, if you accept the challenge, show me your equations first, and then I can tell you which files to modify/adapt.",
                  "url": "https://github.com/idaholab/moose/discussions/23814#discussioncomment-5410649",
                  "updatedAt": "2023-03-23T19:53:10Z",
                  "publishedAt": "2023-03-23T19:53:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "NeedOfHelp"
                          },
                          "bodyText": "Thank you so much for your assistance!\nI have no background in C++ and I can only program in python and matlab, so it will be difficult for me to implement a new code. So instead I'm wondering if it is possible to modify the mode1_brittle_fracture code so it instead applies cyclic loading?\nOr maybe change the angle on how the force is applied  in order to see how the fracture changes?\nAre those things possible in RACCOON?",
                          "url": "https://github.com/idaholab/moose/discussions/23814#discussioncomment-5416597",
                          "updatedAt": "2023-03-24T10:52:23Z",
                          "publishedAt": "2023-03-24T10:52:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yes, these are possible. In fact, these are regular tasks handled by MOOSE, so I recommend you to go through the MOOSE tutorials first.",
                          "url": "https://github.com/idaholab/moose/discussions/23814#discussioncomment-5417613",
                          "updatedAt": "2023-03-24T12:50:49Z",
                          "publishedAt": "2023-03-24T12:50:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "NeedOfHelp"
                          },
                          "bodyText": "Thanks, will do.",
                          "url": "https://github.com/idaholab/moose/discussions/23814#discussioncomment-5417788",
                          "updatedAt": "2023-03-24T13:08:06Z",
                          "publishedAt": "2023-03-24T13:08:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "d5sneha"
                          },
                          "bodyText": "what is the update on anisotropy in raccoon?",
                          "url": "https://github.com/idaholab/moose/discussions/23814#discussioncomment-10774090",
                          "updatedAt": "2024-09-27T10:35:29Z",
                          "publishedAt": "2024-09-27T10:35:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Query about coupling function with the PropertyReadFile for both temporal and spatial changes",
          "author": {
            "login": "DaijunHU"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nDear Moose Users,\nI am now trying to simulate cracking at varying temperatures using a phase-field model, in which I want to set that the critical energy release rate Gc is not uniformly distributed in the RVE and changing along with temperature increase.\nFirstly I am assigning Gc into the RVE by PropertyReadFile in UserObjects, in the .txt file the G_c is assigned to each element seperately:\n> [UserObjects]\n>   [./Gc_read]\n>     type = ElementPropertyReadFile\n>     prop_file_name = 'non_linear.txt'\n>     nprop = 1\n>     read_type = element\n>   [../]\n> []\n\n\nwhile in the Materials block, I introduce G_c as (gc_prop_read is added in [AuxVariables] ):\n  [./Gc_from_file_object]\n    type = FileParsedMaterial\n    prop_name = 'gc_prop_read'\n    read_prop_user_object = Gc_read\n  [../] \n\nThen in the Functions block I want to implement the temperature dependence of this G_c:\n[Functions]\n  [./temperature_Gc]\n    type = ParsedFunction\n    expression = '1.8*(x-300)/356'\n  [../]\n[]\n\nMy goal is to let the Gc of each element following this temperature function (temperature is changing at different steps following another function), but still keep the spatial dfiference given by the initial value from the read .txt file.\nI tried to use this method in the [Materials] block, but it seems not working:\n  [./Gc_scale]\n    type = CoupledValueFunctionMaterial\n    function = temperature_Gc\n    v = 'temp'\n    prop_name = gc_prop_read\n  [../]  \n\nAlso I tried  DerivativeParsedMaterial, which is also not working well.\nCould you please give some suggestions on this issue?",
          "url": "https://github.com/idaholab/moose/discussions/28704",
          "updatedAt": "2024-09-27T01:08:53Z",
          "publishedAt": "2024-09-25T03:13:08Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat do you mean by it seems it's not working?\nWhat error do you get with the CoupledVariableFunctionMateeial?\nAnd what about with the DericativeParsedMaterial?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/28704#discussioncomment-10745916",
                  "updatedAt": "2024-09-25T03:21:15Z",
                  "publishedAt": "2024-09-25T03:21:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "DaijunHU"
                          },
                          "bodyText": "Hi,\nThank you for your prompt reply.\nActually I did not meet errors when using them. I can find the Gc are correctly distributed in the RVE as expected. But when temperature changes they did not change together, so I guess the coupling between function and propertyreadfile is not right. I want to know whether I am on a right way  to solve it in [Materials] like this or should use other methods instead.\nThank you!\nBest regards,\nDaijun",
                          "url": "https://github.com/idaholab/moose/discussions/28704#discussioncomment-10746007",
                          "updatedAt": "2024-09-25T03:33:50Z",
                          "publishedAt": "2024-09-25T03:33:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "DaijunHU"
                          },
                          "bodyText": "Hi Guillaume,\nSorry that I should provide more information for my query.\nAs mentioned above I made a [Gc_scale] block, where I made the temperature dependence of Gc into a scale factor.\nThis factor is transfered to an auxvariable called gc_scale, while the read gc initial values are stored to another auxvariable gc_read.\n  [./Gc_scale]\n    type = CoupledValueFunctionMaterial\n    function = temperature_Gc\n    v = 'temp'\n    prop_name = gc_prop_scale\n  [../]  \n  [./Gc_from_file_object]\n    type = FileParsedMaterial\n    prop_name = 'gc_prop_read'\n    read_prop_user_object = Gc_read\n  [../] \n\nThen my questions goes to how to combine them together to a final gc_prop which is needed for my fracture modeling.\nI firstly tried ParsedMaterial like:\n  [./Gc_temp_map]\n    type = ParsedMaterial\n    expression = 'gc_prop_scale *gc_prop_read'\n    coupled_variables= 'gc_prop_scale  gc_prop_read'\n    property_name = gc_prop\n  [../] \n\nBut it shows that  ERROR: FunctionParser is unable to parse expression: gc_prop_scale * gc_prop_read\nThen I tried CoupledValueeFunctionMaterial by adding a function Gc_calculation:\n  [./Gc_calculation]\n    type = ParsedFunction\n    expression = 'x*y'\n  [../]\n  [./Gc_temp_map]\n    type = CoupledValueFunctionMaterial\n    function = Gc_calculation\n    v = 'gc_prop_scale  gc_prop_read'\n    prop_name = gc_prop\n  [../] \n\nIt shows no error but not working to give the temperature dependence to Gc. In my opinion this is close and I am also checking the tempearture files used for this method. For my this coupling issue is that the temperature is changing with time, Gc is both temperature dependent and spatially different in each element as assigned.\nThe DerivativeParsedMaterial is not a right way I think, because currently no derivative is included.\nI look forward to your suggestions on using which type for this kind of coupling. If the CoupledValueFunctionMaterial is a correct way, i will check other parts of my input file. Thank you in advance and will keep you updated.\nBest regards,\nDaijun",
                          "url": "https://github.com/idaholab/moose/discussions/28704#discussioncomment-10747510",
                          "updatedAt": "2024-09-25T07:20:03Z",
                          "publishedAt": "2024-09-25T07:20:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\n  [./Gc_temp_map]\n    type = ParsedMaterial\n    expression = 'gc_prop_scale *gc_prop_read'\n    coupled_variables= 'gc_prop_scale  gc_prop_read'\n    property_name = gc_prop\n  [../] \n\nthis is not quite right since gc_prop_scale  and gc_prop_read are not variables, they are material properties\nso it should be\nmaterial_property_names = 'gc_prop_scale  gc_prop_read'\n\ninstead",
                          "url": "https://github.com/idaholab/moose/discussions/28704#discussioncomment-10750399",
                          "updatedAt": "2024-09-25T11:47:07Z",
                          "publishedAt": "2024-09-25T11:47:06Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "DaijunHU"
                          },
                          "bodyText": "Dear Guillaume,\nYes that is the point. I have tried and this made it work.\nThank you!",
                          "url": "https://github.com/idaholab/moose/discussions/28704#discussioncomment-10769428",
                          "updatedAt": "2024-09-27T01:08:43Z",
                          "publishedAt": "2024-09-27T01:08:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "simulations running very slow",
          "author": {
            "login": "ashishdhole"
          },
          "bodyText": "Hello,\nI am running a phase field simulation and the input file looks like this\n  [Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 260\n  ny = 260\n  xmin = 0\n  xmax = 2000\n  ymin = 0\n  ymax = 2000\n  uniform_refine = 2\n[]\n[GlobalParams]\n  op_num = 17\n  var_name_base = gr\n  length_scale = 1.0e-6\n  time_scale = 1.0\n[]\n\n[Variables]\n  [PolycrystalVariables]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n[Modules]\n  [AdvanceFrictionPressureGG]\n    g = phi\n  []\n[]\n\n[UserObjects]\n  [voronoi]\n    type = PolycrystalVoronoi\n    grain_num = 6400 # Number of grains\n    rand_seed = 2878\n    coloring_algorithm = jp\n    int_width = 5\n  []\n  [grain_tracker]\n    type = GrainTracker\n    verbosity_level = 0\n    compute_var_to_feature_map = true\n  []\n[]\n[ICs]\n  [PolycrystalICs]\n    [PolycrystalColoringIC]\n      polycrystal_ic_uo = voronoi\n    []\n  []\n[]\n.\n.\n.\n.\n.\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = PJFNK #Preconditioned JFNK (default)\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n  steady_state_detection = true\n  steady_state_start_time = 0\n  steady_state_tolerance = 1e-8\n  automatic_scaling = true\n  compute_scaling_once = false\n  use_pre_SMO_residual = false\n  l_tol = 1.0e-4 # Linear relative tolerance\n  l_abs_tol = 1.0e-6 # Linear absolute tolerance\n  nl_abs_tol = 1.0e-4 # Nonlinear absolute tolerance\n  nl_rel_tol = 1.0e-4 # Nonlinear relative tolerance\n  l_max_its = 100 # Linear max iterations\n  nl_max_its = 30 # Nonlinear max iterations\n  start_time = 0.0\n  #num_steps = 10\n  end_time = 5000000000\n  dtmin = 1e-20\n  #dt = 1\n  #line_search = none\n  #[Adaptivity]\n  #  initial_adaptivity = 3\n  #  refine_fraction = 0.7\n  #  coarsen_fraction = 0.4\n  #  max_h_level = 2\n  #[]\n  [TimeStepper]\n    type = IterationAdaptiveDT\n    cutback_factor = 0.8\n    dt = 0.1\n    growth_factor = 1.2\n  []\n[]\n\n[Adaptivity]\n  initial_steps = 3\n  max_h_level = 2\n  marker = err_bnds\n  [Markers]\n    [err_bnds]\n      type = ErrorFractionMarker\n      coarsen = 0.4\n      refine = 0.7\n      indicator = ind_bnds\n    []\n  []\n  [Indicators]\n    [ind_bnds]\n      type = GradientJumpIndicator\n      variable = bnds\n    []\n  []\n[]\n\nbut my simulation is running very slow can you suggest what am I I doing wrong?\noutput looks like this\nSetting Up\n  Uniformly Refining...                                                                  [^[[33m 31.72 s^[[39m] [^[[33m  909 MB^[[39m]\n  Initializing\n    Initializing Equation Systems......                                                  [^[[33m 43.78 s^[[39m] [^[[33m 1563 MB^[[39m]\n  Finished Initializing                                                                  [^[[33m 47.48 s^[[39m] [^[[33m 1564 MB^[[39m]\nFinished Setting Up                                                                      [^[[33m 83.60 s^[[39m] [^[[33m 1564 MB^[[39m]\nFramework Information:\nMOOSE Version:           git commit 8b30259223 on 2024-04-17\nLibMesh Version:         7dbd90ade88cb16a5e855a4c345454c9c146ebec\nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1\nCurrent Time:            Thu Sep 12 06:25:21 2024\nExecutable Timestamp:    Thu Sep 12 02:51:06 2024\n\nParallelism:\n  Num Processors:          300\n  Num Threads:             1\n\nMesh:\n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:\t   2\n  Nodes:\n    Total:                 1083681\n    Local:                 3757\n    Min/Max/Avg:           3440/3769/3612\n  Elems:\n    Total:                 1081600\n    Local:                 3625\n    Min/Max/Avg:           3551/3639/3605\n  Num Subdomains:          1\n  Num Partitions:          300\n  Partitioner:             metis\n\nNonlinear System:\n  Num DOFs:                18422577\n  Num Local DOFs:          63869\n  Num Constrained DOFs:    35377\n  Local Constrained DOFs:  0\n  Variables:               { \"gr0\" \"gr1\" \"gr2\" \"gr3\" \"gr4\" ... \"gr12\" \"gr13\" \"gr14\" \"gr15\" \"gr16\" }\n  Finite Element Types:    \"LAGRANGE\"\n  Approximation Orders:    \"FIRST\"\n\nAuxiliary System:\n  Num DOFs:                6493762\n  Num Local DOFs:          22014\n  Num Constrained DOFs:    4162\n  Local Constrained DOFs:  0\n  Variables:               \"bnds\" { \"unique_grains\" \"var_indices\" } \"phi\" { \"err_bnds\" \"ind_bnds\" }\n  Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\" \"LAGRANGE\" \"MONOMIAL\"\n  Approximation Orders:    \"FIRST\" \"CONSTANT\" \"FIRST\" \"CONSTANT\"\n^[[31mLEGACY MODES ENABLED:^[[39m\n This application uses the legacy initial residual evaluation behavior. The legacy behavior performs an often times redundant residual evaluation before the solution modifying objects are executed prior to the initial (0th nonlinear iter$\n^[[39m\nCurrently Executing\n  Performing Initial Setup\n    Computing User Objects\n      Computing Polycrystal Initial Condition.                                           [^[[33m 18.03 s^[[39m] [^[[33m 1610 MB^[[39m]\n      Currently Finalizing Polycrystal Initial Condition\n        Finalizing Polycrystal Initial Condition\n          Communicating and Merging                                                      [^[[33m  5.08 s^[[39m] [^[[33m 1643 MB^[[39m]\n        Finished Finalizing Polycrystal Initial Condition                                [^[[33m  5.16 s^[[39m] [^[[33m 1644 MB^[[39m]\n      Finished Finalizing Polycrystal Initial Condition                                  [^[[33m  6.22 s^[[39m] [^[[33m 1972 MB^[[39m]\n    Finished Computing User Objects                                                      [^[[33m 24.25 s^[[39m] [^[[33m 1972 MB^[[39m]\n    Projecting Initial Solutions........................................................................................................................................................... [^[[33m785.21 s^[[39m] [^[[33m 1972 MB^[[39m]\nMesh unchanged, skipping remaining steps...\n    Finished Building SemiLocalElemMap                                                   [^[[33m  6.75 s^[[39m] [^[[33m 2021 MB^[[39m]\n  Finished Performing Initial Setup                                                      [^[[33m827.94 s^[[39m] [^[[33m 2022 MB^[[39m]\n  Outputting\n    Outputting Step.                                                                     [^[[33m 15.11 s^[[39m] [^[[33m 2257 MB^[[39m]\n\nTime Step 0, time = 0\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   5.917303e+02 |   0.000000e+00 |   6.400000e+03 |\n+----------------+----------------+----------------+----------------+\n\n  Finished Outputting                                                                    [^[[33m 15.14 s^[[39m] [^[[33m 2257 MB^[[39m]\n\nTime Step 1, time = 0.1, dt = 0.1\nPre-SMO residual: 222.403\n\nPerforming automatic scaling calculation\n\n 0 Nonlinear |R| = ^[[32m9.331901e+00^[[39m\n      0 Linear |R| = ^[[32m9.331901e+00^[[39m\n      1 Linear |R| = ^[[32m6.595481e-01^[[39m\n      2 Linear |R| = ^[[32m9.307747e-02^[[39m\n      3 Linear |R| = ^[[32m2.443747e-02^[[39m\n      4 Linear |R| = ^[[32m5.012671e-03^[[39m\n      5 Linear |R| = ^[[32m1.524739e-03^[[39m\n      6 Linear |R| = ^[[32m4.031388e-04^[[39m\n 1 Nonlinear |R| = ^[[32m8.499808e-02^[[39m\n      0 Linear |R| = ^[[32m8.499808e-02^[[39m\n      1 Linear |R| = ^[[32m1.393766e-02^[[39m\n      2 Linear |R| = ^[[32m1.382264e-03^[[39m\n      3 Linear |R| = ^[[32m1.702454e-04^[[39m\n      4 Linear |R| = ^[[32m3.164961e-05^[[39m\n      5 Linear |R| = ^[[32m5.682206e-06^[[39m\n 2 Nonlinear |R| = ^[[32m1.111908e-02^[[39m\n      0 Linear |R| = ^[[32m1.111908e-02^[[39m\n      1 Linear |R| = ^[[32m5.624584e-04^[[39m\n      2 Linear |R| = ^[[32m9.147334e-05^[[39m\n      3 Linear |R| = ^[[32m1.074289e-05^[[39m\n      4 Linear |R| = ^[[32m3.286875e-06^[[39m\n      5 Linear |R| = ^[[32m5.419093e-07^[[39m\n 3 Nonlinear |R| = ^[[32m3.724282e-04^[[39m\n^[[32m Solve Converged!^[[39m\n  Finished Solving                                                                       [^[[33m 26.03 s^[[39m] [^[[33m 2294 MB^[[39m]\n\nOutlier Variable Residual Norms:\n  gr5: ^[[33m1.607098e-04^[[39m\n  gr7: ^[[33m1.786166e-04^[[39m\n\nPostprocessor Values:\n+----------------+----------------+----------------+----------------+\n| time           | avg_grain_vol  | g              | grain_tracker  |\n+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   5.917303e+02 |   0.000000e+00 |   6.400000e+03 |\n|   1.000000e-01 |   5.925049e+02 |   1.000000e-01 |   6.400000e+03 |\n+----------------+----------------+----------------+----------------+\n\nthanks\nAshish",
          "url": "https://github.com/idaholab/moose/discussions/28612",
          "updatedAt": "2024-09-26T19:54:38Z",
          "publishedAt": "2024-09-12T18:11:30Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHow did you install moose? Which installation route?\nAnd where are you running this? I see 300 processes",
                  "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10629454",
                  "updatedAt": "2024-09-12T18:19:05Z",
                  "publishedAt": "2024-09-12T18:19:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am running it on HPC.",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10629625",
                          "updatedAt": "2024-09-12T18:37:43Z",
                          "publishedAt": "2024-09-12T18:37:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "The standard procedure that is shown on the website.",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10629629",
                          "updatedAt": "2024-09-12T18:38:13Z",
                          "publishedAt": "2024-09-12T18:38:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "After 5 hours I could only go till timestep\nTime Step 63, time = 94.4506, dt = 3.68568\nthat is really slow",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10629642",
                          "updatedAt": "2024-09-12T18:39:35Z",
                          "publishedAt": "2024-09-12T18:39:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "which HPC?\nwhich page did you follow on the website?",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10629843",
                          "updatedAt": "2024-09-12T19:01:30Z",
                          "publishedAt": "2024-09-12T19:01:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Its my institute's cluster. And I followed\nhttps://mooseframework.inl.gov/getting_started/installation/hpc_install_moose.html",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10629854",
                          "updatedAt": "2024-09-12T19:02:58Z",
                          "publishedAt": "2024-09-12T19:02:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok good.\nYou can try tuning the hypre preconditioning parameters through the petsc options",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10629869",
                          "updatedAt": "2024-09-12T19:05:22Z",
                          "publishedAt": "2024-09-12T19:05:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "any suggestions?\nAs there are so many options. I had tried many so far like lu ilu but still its very slow.",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10629874",
                          "updatedAt": "2024-09-12T19:06:39Z",
                          "publishedAt": "2024-09-12T19:06:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hypre should be good\nsome info there\nhttps://mooseframework.inl.gov/releases/moose/v1.0.0/application_development/hypre.html",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10629894",
                          "updatedAt": "2024-09-12T19:08:56Z",
                          "publishedAt": "2024-09-12T19:08:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Thanks. I will check it out and get back to you.",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10629995",
                          "updatedAt": "2024-09-12T19:21:54Z",
                          "publishedAt": "2024-09-12T19:21:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello\nI am using following solver for the system posted at the beginning of this discussion thread.\n  type = Transient\n  scheme = bdf2\n  solve_type = PJFNK #Preconditioned JFNK (default)\n  petsc_options_iname = '-pc_type -pc_hypre_type -pc_hypre_boomeramg_strong_threshold -pc_hypre_boomeramg_agg_nl -pc_hypre_boomeramg_agg_num_paths  -pc_hypre_boomeramg_max_levels  -pc_hypre_boomeramg_coarsen_type  -pc_hypre_boomeramg_interp_type  -pc_hypre_boomeramg_P_max  -pc_hypre_boomeramg_truncfactor'\n  petsc_options_value = 'hypre boomeramg  0.7 4 5 25 HMIS ext+i 2 0.3'\n\nfor some reason, my simulations are still very slow. I am using 300 cores and yet the simulations are very slow. Adapting mesh after every time step is taking really long time. more time than actual iterations. I don't think a 2d simulations with 6400 grains takes 2 days. If I increase the mobility then my time step increment reduces. If I try to coarsen the mesh the results do not have enough resolution. Please help.\nThank you",
                  "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10710331",
                  "updatedAt": "2024-09-21T00:31:57Z",
                  "publishedAt": "2024-09-21T00:31:57Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I can't remember, are you using the grain tracker? And how high of an order parameter ?",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10710422",
                          "updatedAt": "2024-09-21T01:12:45Z",
                          "publishedAt": "2024-09-21T01:12:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "yes.\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 250\n  ny = 250\n  xmin = 0\n  xmax = 2000\n  ymin = 0\n  ymax = 2000\n  uniform_refine = 2\n[]\n[GlobalParams]\n  op_num = 17\n  var_name_base = gr\n[]\n\n[Variables]\n  [PolycrystalVariables]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n[Modules]\n  [AdvanceFrictionPressureGG]\n    g = phi\n  []\n[]\n\n[UserObjects]\n  [voronoi]\n    type = PolycrystalVoronoi\n    grain_num = 6400 # Number of grains\n    rand_seed = 2878\n    coloring_algorithm = jp\n    int_width = 3.46\n  []\n  [grain_tracker]\n    type = GrainTracker\n    verbosity_level = 0\n    compute_var_to_feature_map = true\n  []\n[]\n[ICs]\n  [PolycrystalICs]\n    [PolycrystalColoringIC]\n      polycrystal_ic_uo = voronoi\n    []\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10710427",
                          "updatedAt": "2024-09-21T01:15:42Z",
                          "publishedAt": "2024-09-21T01:15:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Simulation environment details\nSetting Up\n  Uniformly Refining...                                                                  [^[[33m 28.40 s^[[39m] [^[[33m  863 MB^[[39m]\n  Initializing\n    Initializing Equation Systems......                                                  [^[[33m 41.54 s^[[39m] [^[[33m 1473 MB^[[39m]\n  Finished Initializing                                                                  [^[[33m 45.25 s^[[39m] [^[[33m 1474 MB^[[39m]\nFinished Setting Up                                                                      [^[[33m 79.66 s^[[39m] [^[[33m 1474 MB^[[39m]\nFramework Information:\nMOOSE Version:           git commit 8b30259223 on 2024-04-17\nLibMesh Version:         7dbd90ade88cb16a5e855a4c345454c9c146ebec\nPETSc Version:           3.20.3\nSLEPc Version:           3.20.1\nCurrent Time:            Fri Sep 20 21:16:02 2024\nExecutable Timestamp:    Fri Sep 20 03:11:08 2024\n\nParallelism:\n  Num Processors:          300\n  Num Threads:             1\n\nMesh:\n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:\t   2\n  Nodes:\n    Total:                 1002001\n    Local:                 3468\n    Min/Max/Avg:           3173/3493/3340\n  Elems:\n    Total:                 1000000\n    Local:                 3342\n    Min/Max/Avg:           3278/3389/3333\n  Num Subdomains:          1\n  Num Partitions:          300\n  Partitioner:             metis\n\nNonlinear System:\n  Num DOFs:                17034017\n  Num Local DOFs:          58956\n  Num Constrained DOFs:    34017\n  Local Constrained DOFs:  0\n  Variables:               { \"gr0\" \"gr1\" \"gr2\" \"gr3\" \"gr4\" ... \"gr12\" \"gr13\" \"gr14\" \"gr15\" \"gr16\" }\n  Finite Element Types:    \"LAGRANGE\"\n  Approximation Orders:    \"FIRST\"\n\nAuxiliary System:\n  Num DOFs:                6004002\n  Num Local DOFs:          20304\n  Num Constrained DOFs:    4002\n  Local Constrained DOFs:  0\n  Variables:               \"bnds\" { \"unique_grains\" \"var_indices\" } \"phi\" { \"err_bnds\" \"ind_bnds\" }\n  Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\" \"LAGRANGE\" \"MONOMIAL\"\n  Approximation Orders:    \"FIRST\" \"CONSTANT\" \"FIRST\" \"CONSTANT\"\n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             IterationAdaptiveDT\n  TimeIntegrator:          BDF2\n  Solver Mode:             Preconditioned JFNK\n  PETSc Preconditioner:    hypre boomeramg\n\n^[[31mLEGACY MODES ENABLED:^[[39m\n This application uses the legacy initial residual evaluation behavior. The legacy behavior performs an often times redundant residual evaluation before the solution modifying objects are executed prior to t$\n^[[39m\nCurrently Executing\n  Performing Initial Setup\n    Computing User Objects\n      Computing Polycrystal Initial Condition.                                           [^[[33m 15.03 s^[[39m] [^[[33m 1495 MB^[[39m]\n      Finished Finalizing Polycrystal Initial Condition                                  [^[[33m  3.16 s^[[39m] [^[[33m 1854 MB^[[39m]\n    Finished Computing User Objects                                                      [^[[33m 18.19 s^[[39m] [^[[33m 1854 MB^[[39m]\n.\n.\n.\n\nRegards",
                  "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10710437",
                  "updatedAt": "2024-09-21T01:19:26Z",
                  "publishedAt": "2024-09-21T01:19:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Have you tried using more and less processors?\n300 might not be optimal",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10710473",
                          "updatedAt": "2024-09-21T01:34:14Z",
                          "publishedAt": "2024-09-21T01:34:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I have tried 240 before and 500 but I was just using the resources. I did not see any difference in the simulations time. Does it usually take this much time? I was told that this particular system is very small and should not take days to run it.",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10710480",
                          "updatedAt": "2024-09-21T01:38:44Z",
                          "publishedAt": "2024-09-21T01:38:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@laagesen @dschwen any advice on improving phase field solve performances?",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10712709",
                          "updatedAt": "2024-09-21T12:49:22Z",
                          "publishedAt": "2024-09-21T12:49:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Do you have a reference for how much time it should take?\nNext steps if we want to improve the time is profiling.  We need to understand what takes time in this simulation\nSee this page for information on how to do this\nhttps://mooseframework.inl.gov/application_development/profiling.html\nOnce we have a call graph we can take a look",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10714049",
                          "updatedAt": "2024-09-21T17:05:16Z",
                          "publishedAt": "2024-09-21T17:05:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I did profiling. and got following 4 files. (Ran a small simulation with 4 cores on local pc, all the parameters kept same just the system is made smaller)\nhttps://drive.google.com/drive/folders/1R9hSCuBlifq9ZwyqjmpVOPBdTPQE-FG0?usp=sharing\npprof takes very long time to even start\n(moose) ashish@ashish-Inspiron-14-5430:~/projects/pfubc/Final_FP/polycrystals$ mpirun -np 4 pprof run1_0.prof \n\n\nit is stuck here. one forum says it is unmaintained package and hence takes time. Can you have a look at these files?",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10714270",
                          "updatedAt": "2024-09-21T17:53:14Z",
                          "publishedAt": "2024-09-21T17:53:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I ll try next week. I think I need the executable as well. I m not sure I ll be able to parse pprof files without it",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10714308",
                          "updatedAt": "2024-09-21T18:05:58Z",
                          "publishedAt": "2024-09-21T18:05:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you could try with google perf tools instead. That's definitely not unmaintained",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10714311",
                          "updatedAt": "2024-09-21T18:06:34Z",
                          "publishedAt": "2024-09-21T18:06:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Hi, it is good that you are using GrainTracker, but you should be able to use fewer than 17 OPs. Try 8-10 for 2D. Also check your adaptivity setting to make sure you are not over-resolving the interfaces. You need about 3 elements through the interface between grains.\nI would start from the example input file moose/modules/phase_field/examples/grain_growth/grain_growth_2D_graintracker.i in the example and slowly make changes starting from this. I think this will be easier than trying to profile the code for your file. Try increasing the size and number of grains by a factor of 2 starting from this input file rather than trying to dramatically increasing the problem size and number of cores all at once. This will make it easier to identify issues.",
                  "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10719645",
                  "updatedAt": "2024-09-22T18:40:08Z",
                  "publishedAt": "2024-09-22T18:40:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I am using following setup,\nother than op num do you think my choice of mesh points are okay. Is there a direct relation between the size of simulation, number of grains?\n  type = GeneratedMesh\n  dim = 2\n  nx = 250\n  ny = 250\n  xmin = 0\n  xmax = 2000\n  ymin = 0\n  ymax = 2000\n  uniform_refine = 2\n[]\n[GlobalParams]\n  op_num = 17\n  var_name_base = gr\n[]\n\n[Variables]\n  [PolycrystalVariables]\n    order = FIRST\n    family = LAGRANGE\n  []\n[]\n[Modules]\n  [AdvanceFrictionPressureGG]\n    g = phi\n  []\n[]\n\n[UserObjects]\n  [voronoi]\n    type = PolycrystalVoronoi\n    grain_num = 6400 # Number of grains\n    rand_seed = 2878\n    coloring_algorithm = jp\n    int_width = 3.46\n  []\n  [grain_tracker]\n    type = GrainTracker\n    verbosity_level = 0\n    compute_var_to_feature_map = true\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10719705",
                          "updatedAt": "2024-09-22T18:56:29Z",
                          "publishedAt": "2024-09-22T18:56:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "From what you have shown here, you'd have 1000 elements in each direction, starting from 250 elements and refining twice. That would give a mesh size of 2000 /  1000 = 2.0 in the x and y directions. This would be a little too coarse for interface width of 3.46. You would want at least 3 elements through the interface so probably at least 1 more level of refinement at the interfaces, adaptive meshing would work well to give you that.\nThat said 6400 is A LOT of grains even for 2D. You are likely going to need a lot more cores. Best performance will be obtained at 20,000 DOF/core. It's very time consuming to troubleshoot performance and adaptivity for large simulations, which is why I strongly suggest to start with a much smaller problem and make sure your settings are working correctly before doing something this large.",
                  "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10719778",
                  "updatedAt": "2024-09-22T19:11:25Z",
                  "publishedAt": "2024-09-22T19:11:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "BAsed on the usage of cores, 1 core for 20000\nmy system has following DOFs\nNonlinear System:\n  Num DOFs:                28774217\n  Num Local DOFs:          82654\n  Num Constrained DOFs:    44217\n  Local Constrained DOFs:  0\n  Variables:               { \"gr0\" \"gr1\" \"gr2\" \"gr3\" \"gr4\" ... \"gr12\" \"gr13\" \"gr14\" \"gr15\" \"gr16\" }\n  Finite Element Types:    \"LAGRANGE\"\n  Approximation Orders:    \"FIRST\"\n\nAuxiliary System:\n  Num DOFs:                6762601\n  Num Local DOFs:          18947\n  Num Constrained DOFs:    2601\n  Local Constrained DOFs:  0\n  Variables:               \"bnds\" { \"unique_grains\" \"var_indices\" \"phi\" }\n  Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\"\n  Approximation Orders:    \"FIRST\" \"CONSTANT\"\n\nthat means I have to use ~1438 cores to run this simulation. Is it correct? That is seriously high number of cores I need.",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10729264",
                          "updatedAt": "2024-09-23T17:12:47Z",
                          "publishedAt": "2024-09-23T17:12:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Well you can reduce that by at least half if you use fewer order parameters",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10729277",
                          "updatedAt": "2024-09-23T17:14:15Z",
                          "publishedAt": "2024-09-23T17:14:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "I have tried that but 17 is the minimum OP I can get the simulation started. if I am using even finer mesh then the simulation terminates with out of memory issue.",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10729297",
                          "updatedAt": "2024-09-23T17:16:07Z",
                          "publishedAt": "2024-09-23T17:16:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you dont \"need\" it. It s just the expected scalability limit\nHaving less is fine\nThe advice on reducing the order parameter is what you should look into",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10729300",
                          "updatedAt": "2024-09-23T17:16:35Z",
                          "publishedAt": "2024-09-23T17:16:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "ok I will see what changes I can make. Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10729329",
                          "updatedAt": "2024-09-23T17:19:57Z",
                          "publishedAt": "2024-09-23T17:19:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Can you post an image of your initial microstructure? Images both with and without the mesh superimposed on top would be helpful. Trying to understand why you are needing such a large number of order parameters",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10729645",
                          "updatedAt": "2024-09-23T17:54:27Z",
                          "publishedAt": "2024-09-23T17:54:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10729721",
                          "updatedAt": "2024-09-23T18:05:20Z",
                          "publishedAt": "2024-09-23T18:02:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "As previously mentioned, you will want more elements across the interfaces, right now the interfaces are under-resolved and you are not going to properly resolve the physics of grain growth. The interfaces are also pretty wide relative to the size of the grains in some places, usually you want the grain size to be at least 10x larger than the interface width (although some variation in initial conditions makes this hard to achieve uniformly). Both of these factors could be part of the reason why you are needing more order parameters than usual.\nAgain I would highly suggest that you start with a much smaller problem and make sure all your settings and parameters are working properly before trying to run something this large.",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10729857",
                          "updatedAt": "2024-09-23T18:18:04Z",
                          "publishedAt": "2024-09-23T18:18:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "okay I get it now. that my mesh grids are not large enough. The number of grains are for a particular reason. The friction pressure model that I am working on need to have theses number of grains to see the pinning effect. So I will try to increase the resolution. I will get back to you with the update. thank you very much",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10729892",
                          "updatedAt": "2024-09-23T18:22:13Z",
                          "publishedAt": "2024-09-23T18:22:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "Hello,\nOne small doubt. If I use Adaptivity will the mesh adjust the resolution on its own?\nI am using an Adaptivity block as follows\n[Adaptivity]\n  initial_steps = 2\n  max_h_level = 2\n  marker = err_bnds\n  [Markers]\n    [err_bnds]\n      type = ErrorFractionMarker\n      coarsen = 0.3\n      refine = 0.8\n      indicator = ind_bnds\n    []\n  []\n  [Indicators]\n    [ind_bnds]\n      type = GradientJumpIndicator\n      variable = bnds\n    []\n  []\n[]\n\nJust curious. Thanks",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10735805",
                          "updatedAt": "2024-09-24T08:13:54Z",
                          "publishedAt": "2024-09-24T08:13:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ashishdhole"
                  },
                  "bodyText": "Hello, do you think GPU will help me do this large simulations? Are there any input files that I can look into?\nThank you",
                  "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10767673",
                  "updatedAt": "2024-09-26T19:46:34Z",
                  "publishedAt": "2024-09-26T19:46:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "we are working on it. There is nothing ready right now for this",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10767702",
                          "updatedAt": "2024-09-26T19:50:18Z",
                          "publishedAt": "2024-09-26T19:50:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ashishdhole"
                          },
                          "bodyText": "ok. I think that would have helped me. I was looking at a paper (https://doi.org/10.1016/j.commatsci.2020.109992)\n\"The domain was divided into a grid of 2560 \u00d7 2560 \u00d7 2560 by regular cubic lattices with a size of \u0394x = 1. The system consisted of 3,125,000 grains that are under periodic boundary conditions in all directions.\n.\n.\n.\nAll simulations were carried out on the GPU-rich supercomputer TSUBAME3.0 at the Tokyo Institute of Technology by utilizing our own parallel GPU code (https://www.sciencedirect.com/science/article/pii/S0927025620304833#b0330). The number of GPUs (NVIDIA Tesla P100) used for each simulation was 256.\"\nThat is a VERY LARGE system.\nLooking forward to the GPU based input parameters.\nThank you",
                          "url": "https://github.com/idaholab/moose/discussions/28612#discussioncomment-10767742",
                          "updatedAt": "2024-09-26T19:54:39Z",
                          "publishedAt": "2024-09-26T19:54:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Attempting to make a mesh of a reactor core with an outer ring, but getting an error when attempting to add the ring to the mesh.",
          "author": {
            "login": "lliw-will"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nWhen running the code using the Reactor Module, following along with the hpmr example, for a mesh without PeripheralRingMeshGenerator  it works fine. When I try to add a ring using PeripheralRingMeshGenerator I get the following error:\n *** ERROR ***\n/home/will/cardinal/sfr/solid.i:463: (Mesh/outer_shield/input_mesh_external_boundary):\n    This mesh generator does not work for the provided external boundary as it has more than one segments.\n\nI am not familiar enough with the module to know what part of my code that differed from the hpmr example caused this problem. I did not add any control drums and did add ducts.\nBelow is the code that I am running:\nfuel_fill_fraction = 0.75\n\nassembly_edgelength_inner = ${fparse 17/sqrt(3)}\nassembly_edgelength_outer = ${fparse assembly_edgelength_inner+0.1}\nassembly_pitch = $fparse{2*sin(pi/3)*assembly_edgelength_outer}\n\npin_clad_inner_diameter = ${fparse 1.300}\npin_clad_outer_diameter = ${fparse 1.400}\nfuel_outer_diameter = ${fparse sqrt(pin_clad_outer_diameter*pin_clad_outer_diameter*fuel_fill_fraction)}\npin_pitch = ${fparse ((assembly_edgelength_inner-(pin_clad_outer_diameter/sqrt(3)))/6)-0.006}\n\nprimary_clad_inner_diameter = ${fparse 1.300}\nprimary_clad_outer_diameter = ${fparse 1.400}\nprimary_pitch = ${fparse ((assembly_edgelength_inner-(primary_clad_outer_diameter/sqrt(3))) / 5)-0.009}\n\nsecondary_clad_inner_diameter = ${fparse primary_clad_inner_diameter*1.5}\nsecondary_clad_outer_diameter = ${fparse secondary_clad_inner_diameter+0.100}\nsecondary_pitch = ${fparse ((assembly_edgelength_inner-(secondary_clad_outer_diameter/sqrt(3)))/3)-0.03}\n\nisotope_clad_inner_diameter = ${fparse 1.27}\nisotope_clad_outer_diameter = ${fparse isotope_clad_inner_diameter+0.100}\nisotope_pitch = ${fparse isotope_clad_inner_diameter*1.5}\n\nreflector_diameter = ${fparse 3}\nreflector_pitch = ${fparse ((assembly_edgelength_inner-(reflector_diameter / sqrt(3))) / 2)-0.04}\n\nshield_diameter = ${fparse 3}\nshield_pitch = ${fparse ((assembly_edgelength_inner-(shield_diameter/sqrt(3))) / 2)-0.04}\n\n[Mesh]\n  [inner_fuel_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse pin_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse fuel_outer_diameter / 2.0} \n                  ${fparse pin_clad_inner_diameter / 2.0}\n                  ${fparse pin_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1 1'\n    ring_block_ids = '1 2 3'\n    ring_block_names = 'inner_fuel_pin inner_fuel_sodium \n                        inner_fuel_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [inner_fuel_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'inner_fuel_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    hexagon_size_style = apothem\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '4'\n    duct_block_names = 'inner_fuel_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n         0 0 0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n               0 0 0 0 0 0 0'\n  []\n\n  [mid_fuel_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse (pin_pitch) / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse fuel_outer_diameter / 2.0} \n                  ${fparse pin_clad_inner_diameter / 2.0}\n                  ${fparse pin_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1 1'\n    ring_block_ids = '5 6 7'\n    ring_block_names = 'mid_fuel_pin mid_fuel_sodium \n                        mid_fuel_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [mid_fuel_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'mid_fuel_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    hexagon_size_style = apothem                \n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '8'\n    duct_block_names = 'mid_fuel_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n         0 0 0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n               0 0 0 0 0 0 0'\n  []\n\n  [outer_fuel_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse pin_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse fuel_outer_diameter / 2.0} \n                  ${fparse pin_clad_inner_diameter / 2.0}\n                  ${fparse pin_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1 1'\n    ring_block_ids = '9 10 11'\n    ring_block_names = 'outer_fuel_pin outer_fuel_sodium \n                        outer_fuel_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [outer_fuel_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'outer_fuel_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_interval = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '12'\n    duct_block_names = 'outer_fuel_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n         0 0 0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n               0 0 0 0 0 0 0'\n  []\n\n  [primary_control_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse primary_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse primary_clad_inner_diameter / 2.0}\n                  ${fparse primary_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1'\n    ring_block_ids = '13 14'\n    ring_block_names = 'primary_control_pin \n                        primary_control_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [primary_control_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'primary_control_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '15'\n    duct_block_names = 'primary_control_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0 0 0 0;\n              0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0;\n               0 0 0 0 0 0'\n  []\n\n  [secondary_control_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse secondary_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse secondary_clad_inner_diameter / 2.0}\n                  ${fparse secondary_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1'\n    ring_block_ids = '16 17'\n    ring_block_names = 'secondary_control_pin \n                        secondary_control_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [secondary_control_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'secondary_control_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '18'\n    duct_block_names = 'secondary_control_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0 0;\n              0 0 0 0 0;\n             0 0 0 0 0 0;\n            0 0 0 0 0 0 0;\n             0 0 0 0 0 0;\n              0 0 0 0 0;\n               0 0 0 0'\n  []\n\n  [isotope_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse isotope_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse isotope_clad_inner_diameter / 2.0}\n                  ${fparse isotope_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1'\n    ring_block_ids = '19 20'\n    ring_block_names = 'isotope_pin isotope_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [isotope_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'isotope_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '21'\n    duct_block_names = 'isotope_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0;\n              0 0 0 0;\n             0 0 0 0 0;\n              0 0 0 0;\n               0 0 0'\n  []\n\n  [reflector_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse reflector_pitch / 2.0} \n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse reflector_diameter / 2.0}'\n    ring_intervals = '1'\n    ring_block_ids = '22'\n    ring_block_names = 'reflector_pin'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [reflector_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'reflector_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '23'\n    duct_block_names = 'reflector_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0;\n              0 0 0 0;\n             0 0 0 0 0;\n              0 0 0 0;\n               0 0 0'\n  []\n\n  [shield_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse shield_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse shield_diameter / 2.0}'\n    ring_intervals = '1'\n    ring_block_ids = '24'\n    ring_block_names = 'shield_pin'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [shield_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'shield_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '25'\n    duct_block_names = 'shield_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0;\n              0 0 0 0;\n             0 0 0 0 0;\n              0 0 0 0;\n               0 0 0'\n  []\n\n  [empty_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse shield_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '1.5'\n    ring_intervals = '1'\n    ring_block_ids = '26'\n    ring_block_names = 'empty_pin'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [empty_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'empty_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '27'\n    duct_block_names = 'empty_clad'\n    duct_intervals = '1'\n    pattern = '0 0;\n              0 0 0;\n               0 0'\n  []\n\n  [dummy_assembly]\n    type = HexagonConcentricCircleAdaptiveBoundaryMeshGenerator\n    num_sectors_per_side = '4 4 4 4 4 4'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_intervals = 2\n    background_block_ids = '28 29'\n    external_boundary_id = 998\n  []\n\n  [core]\n    type = PatternedHexMeshGenerator\n    inputs = 'inner_fuel_assembly mid_fuel_assembly \n              outer_fuel_assembly primary_control_assembly \n              secondary_control_assembly isotope_assembly \n              reflector_assembly shield_assembly\n              empty_assembly dummy_assembly'\n    pattern_boundary = none\n    generate_core_metadata = true\n    pattern = '9 7 7 7 7 7 7 7 9;\n              7 7 6 6 6 6 6 6 7 7;\n             7 6 6 5 2 2 2 5 6 6 7;\n            7 6 5 2 2 1 1 2 2 5 6 7;\n           7 6 2 2 1 1 1 1 1 2 2 6 7;\n          7 6 2 1 1 3 0 0 3 1 1 2 6 7;\n         7 6 2 1 4 0 0 0 0 0 4 1 2 6 7;\n        7 6 5 2 1 0 0 0 0 0 0 1 2 5 6 7;\n       9 7 6 2 1 3 0 0 8 0 0 3 1 2 6 7 9;\n        7 6 5 2 1 0 0 0 0 0 0 1 2 5 6 7;\n         7 6 2 1 1 0 0 0 0 0 1 1 2 6 7;\n          7 6 2 1 1 3 0 0 3 1 1 2 6 7;\n           7 6 2 2 1 1 4 1 1 2 2 6 7;\n            7 6 5 2 2 1 1 2 2 5 6 7;\n             7 6 6 5 2 2 2 5 6 6 7;\n              7 7 6 6 6 6 6 6 7 7;\n               9 7 7 7 7 7 7 7 9'\n    rotate_angle = 60\n  []\n\n  [del_dummy]\n    type = BlockDeletionGenerator\n    block = '2 6 10 26 28 29 30'\n    input = core\n    new_boundary = 10000\n  []\n\n  [outer_shield]\n    type = PeripheralRingMeshGenerator\n    input = del_dummy\n    peripheral_layer_num = 1\n    peripheral_ring_radius = 150\n    input_mesh_external_boundary = 10000\n    peripheral_ring_block_id = 250\n    peripheral_ring_block_name = outer_shield\n  []\n\n\n  [coreslice_1]\n    type = PlaneDeletionGenerator\n    point = '0 0 0'\n    normal = '10 17.32050808 0'\n    input = outer_shield\n  []\n\n  [coreslice_2]\n    type = PlaneDeletionGenerator\n    point = '0 0 0'\n    normal = '10 -17.32050808 0'\n    input = coreslice_1\n  []\n\n  [extrude]\n    type = AdvancedExtruderGenerator\n    input = coreslice_2\n    heights = '150'\n    num_layers = '25'\n    direction = '0 0 1'\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/28706",
          "updatedAt": "2024-09-26T18:30:30Z",
          "publishedAt": "2024-09-25T16:03:29Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhen you delete some assemblies with\n  [del_dummy]\n    type = BlockDeletionGenerator\n    block = '2 6 10 26 28 29 30'\n    input = core\n    new_boundary = 10000\n  []\n\nyou still have assemblies on an outer rim ( 7 and 9s in the pattern in [core]). So the 10000 boundary is on both sides, and it is not a good starting point for drawing the periphery going outwards.",
                  "url": "https://github.com/idaholab/moose/discussions/28706#discussioncomment-10753691",
                  "updatedAt": "2024-09-25T16:19:31Z",
                  "publishedAt": "2024-09-25T16:19:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lliw-will"
                          },
                          "bodyText": "Thanks for the response,\nI don't see what the issue is as the hpmr example had also deleted some blocks on the outer rim while leaving some assemblies. In the same way I removed the assemblies labelled 9 the example had removed the assemblies labelled 19, as seen below:\n[Mesh]\n  [core]\n    type = PatternedHexMeshGenerator\n    inputs = 'fuel_assembly cd1 cd2 cd3 cd4 cd5 cd6 cd7 cd8 cd9 cd10 cd11 cd12 refl1 refl2 refl3 refl4 refl5 refl6 dummy air_center'\n    # Pattern ID  0           1   2   3   4   5   6   7   8   9   10   11   12    13    14    15    16    17    18   19  20\n    pattern_boundary = none\n    generate_core_metadata = true\n    pattern = '19 13 1  18 19;\n             13 12  0  0  2 18;\n           11  0  0  0  0  0  3;\n          14 0  0   0  0  0  0 17;\n        19 10  0  0  20  0  0  4 19;\n          14 0  0   0  0  0  0 17;\n            9  0  0  0  0  0  5;\n             15  8  0  0  6 16;\n               19 15  7 16 19'\n    rotate_angle = 60\n  []\n[]\n\n[Mesh]\n  [del_dummy]\n    type = BlockDeletionGenerator\n    block = '700 701'\n    input = core\n    new_boundary = 10000\n  []\n[]\n\n[Mesh]\n  [outer_shield]\n    type = PeripheralRingMeshGenerator\n    input = del_dummy\n    peripheral_layer_num = 1\n    peripheral_ring_radius = 115.0\n    input_mesh_external_boundary = 10000\n    peripheral_ring_block_id = 250\n    peripheral_ring_block_name = outer_shield\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28706#discussioncomment-10753840",
                          "updatedAt": "2024-09-25T16:35:14Z",
                          "publishedAt": "2024-09-25T16:35:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah the id and the pattern ID are not matching\ncan you use names in del_dummy instead of ids?\nalso use output = true in that generator to see what the mesh and that 10000 boundary look like before the peripheral ring mesh generationr",
                          "url": "https://github.com/idaholab/moose/discussions/28706#discussioncomment-10753935",
                          "updatedAt": "2024-09-25T16:40:56Z",
                          "publishedAt": "2024-09-25T16:40:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "also instead of 10000 for that id, use 123456 because 10000 is likely used internally for other boundaries inside the mesh",
                          "url": "https://github.com/idaholab/moose/discussions/28706#discussioncomment-10753939",
                          "updatedAt": "2024-09-25T16:41:32Z",
                          "publishedAt": "2024-09-25T16:41:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lliw-will"
                          },
                          "bodyText": "I have changed the del_dummy block from ids to names and tried changing the boundary id from 10000 to 123456 but got the following error:\n*** ERROR ***\nBoundaryName 123456 is not within the numeric limits of the expected ID type short.\n\nI then lowered the id until I got to the highest one without exceeding the limits which was 32767 and got the same error as before:\n *** ERROR ***\n/home/will/cardinal/sfr/solid.i:463: (Mesh/outer_shield/input_mesh_external_boundary):\n    This mesh generator does not work for the provided external boundary as it has more than one segments.\n\nHere is my updated code:\nfuel_fill_fraction = 0.75\n\nassembly_edgelength_inner = ${fparse 17/sqrt(3)}\nassembly_edgelength_outer = ${fparse assembly_edgelength_inner+0.1}\nassembly_pitch = $fparse{2*sin(pi/3)*assembly_edgelength_outer}\n\npin_clad_inner_diameter = ${fparse 1.300}\npin_clad_outer_diameter = ${fparse 1.400}\nfuel_outer_diameter = ${fparse sqrt(pin_clad_outer_diameter*pin_clad_outer_diameter*fuel_fill_fraction)}\npin_pitch = ${fparse ((assembly_edgelength_inner-(pin_clad_outer_diameter/sqrt(3)))/6)-0.006}\n\nprimary_clad_inner_diameter = ${fparse 1.300}\nprimary_clad_outer_diameter = ${fparse 1.400}\nprimary_pitch = ${fparse ((assembly_edgelength_inner-(primary_clad_outer_diameter/sqrt(3))) / 5)-0.009}\n\nsecondary_clad_inner_diameter = ${fparse primary_clad_inner_diameter*1.5}\nsecondary_clad_outer_diameter = ${fparse secondary_clad_inner_diameter+0.100}\nsecondary_pitch = ${fparse ((assembly_edgelength_inner-(secondary_clad_outer_diameter/sqrt(3)))/3)-0.03}\n\nisotope_clad_inner_diameter = ${fparse 1.27}\nisotope_clad_outer_diameter = ${fparse isotope_clad_inner_diameter+0.100}\nisotope_pitch = ${fparse isotope_clad_inner_diameter*1.5}\n\nreflector_diameter = ${fparse 3}\nreflector_pitch = ${fparse ((assembly_edgelength_inner-(reflector_diameter / sqrt(3))) / 2)-0.04}\n\nshield_diameter = ${fparse 3}\nshield_pitch = ${fparse ((assembly_edgelength_inner-(shield_diameter/sqrt(3))) / 2)-0.04}\n\n[Mesh]\n  [inner_fuel_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse pin_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse fuel_outer_diameter / 2.0} \n                  ${fparse pin_clad_inner_diameter / 2.0}\n                  ${fparse pin_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1 1'\n    ring_block_ids = '1 2 3'\n    ring_block_names = 'inner_fuel_pin inner_fuel_sodium \n                        inner_fuel_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [inner_fuel_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'inner_fuel_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    hexagon_size_style = apothem\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '4'\n    duct_block_names = 'inner_fuel_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n         0 0 0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n               0 0 0 0 0 0 0'\n  []\n\n  [mid_fuel_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse (pin_pitch) / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse fuel_outer_diameter / 2.0} \n                  ${fparse pin_clad_inner_diameter / 2.0}\n                  ${fparse pin_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1 1'\n    ring_block_ids = '5 6 7'\n    ring_block_names = 'mid_fuel_pin mid_fuel_sodium \n                        mid_fuel_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [mid_fuel_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'mid_fuel_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    hexagon_size_style = apothem                \n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '8'\n    duct_block_names = 'mid_fuel_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n         0 0 0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n               0 0 0 0 0 0 0'\n  []\n\n  [outer_fuel_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse pin_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse fuel_outer_diameter / 2.0} \n                  ${fparse pin_clad_inner_diameter / 2.0}\n                  ${fparse pin_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1 1'\n    ring_block_ids = '9 10 11'\n    ring_block_names = 'outer_fuel_pin outer_fuel_sodium \n                        outer_fuel_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [outer_fuel_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'outer_fuel_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_interval = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '12'\n    duct_block_names = 'outer_fuel_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n         0 0 0 0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0 0;\n               0 0 0 0 0 0 0'\n  []\n\n  [primary_control_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse primary_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse primary_clad_inner_diameter / 2.0}\n                  ${fparse primary_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1'\n    ring_block_ids = '13 14'\n    ring_block_names = 'primary_control_pin \n                        primary_control_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [primary_control_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'primary_control_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '15'\n    duct_block_names = 'primary_control_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0 0 0 0;\n              0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0;\n          0 0 0 0 0 0 0 0 0 0 0;\n           0 0 0 0 0 0 0 0 0 0;\n            0 0 0 0 0 0 0 0 0;\n             0 0 0 0 0 0 0 0;\n              0 0 0 0 0 0 0;\n               0 0 0 0 0 0'\n  []\n\n  [secondary_control_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse secondary_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse secondary_clad_inner_diameter / 2.0}\n                  ${fparse secondary_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1'\n    ring_block_ids = '16 17'\n    ring_block_names = 'secondary_control_pin \n                        secondary_control_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [secondary_control_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'secondary_control_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '18'\n    duct_block_names = 'secondary_control_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0 0;\n              0 0 0 0 0;\n             0 0 0 0 0 0;\n            0 0 0 0 0 0 0;\n             0 0 0 0 0 0;\n              0 0 0 0 0;\n               0 0 0 0'\n  []\n\n  [isotope_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse isotope_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse isotope_clad_inner_diameter / 2.0}\n                  ${fparse isotope_clad_outer_diameter / 2.0}'\n    ring_intervals = '1 1'\n    ring_block_ids = '19 20'\n    ring_block_names = 'isotope_pin isotope_pin_clad'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [isotope_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'isotope_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '21'\n    duct_block_names = 'isotope_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0;\n              0 0 0 0;\n             0 0 0 0 0;\n              0 0 0 0;\n               0 0 0'\n  []\n\n  [reflector_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse reflector_pitch / 2.0} \n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse reflector_diameter / 2.0}'\n    ring_intervals = '1'\n    ring_block_ids = '22'\n    ring_block_names = 'reflector_pin'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [reflector_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'reflector_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '23'\n    duct_block_names = 'reflector_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0;\n              0 0 0 0;\n             0 0 0 0 0;\n              0 0 0 0;\n               0 0 0'\n  []\n\n  [shield_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse shield_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '${fparse shield_diameter / 2.0}'\n    ring_intervals = '1'\n    ring_block_ids = '24'\n    ring_block_names = 'shield_pin'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [shield_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'shield_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '25'\n    duct_block_names = 'shield_clad'\n    duct_intervals = '1'\n    pattern = '0 0 0;\n              0 0 0 0;\n             0 0 0 0 0;\n              0 0 0 0;\n               0 0 0'\n  []\n\n  [empty_pin]\n    type = PolygonConcentricCircleMeshGenerator\n    num_sides = 6\n    num_sectors_per_side = '2 2 2 2 2 2'\n    background_intervals = 1\n    background_block_ids = '30'\n    polygon_size = ${fparse shield_pitch / 2.0}\n    polygon_size_style = 'apothem'\n    ring_radii = '1.5'\n    ring_intervals = '1'\n    ring_block_ids = '26'\n    ring_block_names = 'empty_pin'\n    preserve_volumes = on\n    quad_center_elements = false\n  []\n\n  [empty_assembly]\n    type = PatternedHexMeshGenerator\n    inputs = 'empty_pin'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_block_id = 30\n    background_intervals = 1\n    background_block_name = background\n    duct_sizes = '${fparse (assembly_edgelength_outer * \n                     sqrt(3) / 2) - 0.1}'\n    duct_sizes_style = apothem\n    duct_block_ids = '27'\n    duct_block_names = 'empty_clad'\n    duct_intervals = '1'\n    pattern = '0 0;\n              0 0 0;\n               0 0'\n  []\n\n  [dummy_assembly]\n    type = HexagonConcentricCircleAdaptiveBoundaryMeshGenerator\n    num_sectors_per_side = '4 4 4 4 4 4'\n    hexagon_size = ${fparse assembly_edgelength_outer * \n                     sqrt(3) / 2}\n    background_intervals = 2\n    background_block_ids = '28 29'\n    background_block_names = 'dummy_1 dummy_2'\n  []\n\n  [core]\n    type = PatternedHexMeshGenerator\n    inputs = 'inner_fuel_assembly mid_fuel_assembly \n              outer_fuel_assembly primary_control_assembly \n              secondary_control_assembly isotope_assembly \n              reflector_assembly shield_assembly\n              empty_assembly dummy_assembly'\n    pattern_boundary = none\n    generate_core_metadata = true\n    pattern = '9 7 7 7 7 7 7 7 9;\n              7 7 6 6 6 6 6 6 7 7;\n             7 6 6 5 2 2 2 5 6 6 7;\n            7 6 5 2 2 1 1 2 2 5 6 7;\n           7 6 2 2 1 1 1 1 1 2 2 6 7;\n          7 6 2 1 1 3 0 0 3 1 1 2 6 7;\n         7 6 2 1 4 0 0 0 0 0 4 1 2 6 7;\n        7 6 5 2 1 0 0 0 0 0 0 1 2 5 6 7;\n       9 7 6 2 1 3 0 0 8 0 0 3 1 2 6 7 9;\n        7 6 5 2 1 0 0 0 0 0 0 1 2 5 6 7;\n         7 6 2 1 1 0 0 0 0 0 1 1 2 6 7;\n          7 6 2 1 1 3 0 0 3 1 1 2 6 7;\n           7 6 2 2 1 1 4 1 1 2 2 6 7;\n            7 6 5 2 2 1 1 2 2 5 6 7;\n             7 6 6 5 2 2 2 5 6 6 7;\n              7 7 6 6 6 6 6 6 7 7;\n               9 7 7 7 7 7 7 7 9'\n    rotate_angle = 60\n  []\n\n  [del_dummy]\n    type = BlockDeletionGenerator\n    block = 'inner_fuel_sodium mid_fuel_sodium outer_fuel_sodium \n             empty_pin dummy_1 dummy_2 background'\n    input = core\n    new_boundary = 32767\n  []\n\n  [outer_shield]\n    type = PeripheralRingMeshGenerator\n    input = del_dummy\n    peripheral_layer_num = 1\n    peripheral_ring_radius = 150\n    input_mesh_external_boundary = 32767\n    peripheral_ring_block_id = 250\n    peripheral_ring_block_name = outer_shield\n  []\n\n\n  [coreslice_1]\n    type = PlaneDeletionGenerator\n    point = '0 0 0'\n    normal = '10 17.32050808 0'\n    input = outer_shield\n  []\n\n  [coreslice_2]\n    type = PlaneDeletionGenerator\n    point = '0 0 0'\n    normal = '10 -17.32050808 0'\n    input = coreslice_1\n  []\n\n  [extrude]\n    type = AdvancedExtruderGenerator\n    input = coreslice_2\n    heights = '150'\n    num_layers = '25'\n    direction = '0 0 1'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/28706#discussioncomment-10754469",
                          "updatedAt": "2024-09-25T17:32:41Z",
                          "publishedAt": "2024-09-25T17:32:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "by picking 32767 you could have picked another number being used internally.",
                          "url": "https://github.com/idaholab/moose/discussions/28706#discussioncomment-10754498",
                          "updatedAt": "2024-09-25T17:35:53Z",
                          "publishedAt": "2024-09-25T17:35:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lliw-will"
                          },
                          "bodyText": "Anything above 32767 returns the error:\n*** ERROR ***\nBoundaryName 123456 is not within the numeric limits of the expected ID type short.\n\nFor example when using 32768:\n*** ERROR ***\nBoundaryName 32768 is not within the numeric limits of the expected ID type short.\n\nWhen using 32767:\n *** ERROR ***\n/home/will/cardinal/sfr/solid.i:463: (Mesh/outer_shield/input_mesh_external_boundary):\n    This mesh generator does not work for the provided external boundary as it has more than one segments.",
                          "url": "https://github.com/idaholab/moose/discussions/28706#discussioncomment-10754515",
                          "updatedAt": "2024-09-25T17:44:09Z",
                          "publishedAt": "2024-09-25T17:37:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you have to keep using a short , so it needs to be below 32767\ntry 12345",
                          "url": "https://github.com/idaholab/moose/discussions/28706#discussioncomment-10754662",
                          "updatedAt": "2024-09-25T17:55:04Z",
                          "publishedAt": "2024-09-25T17:55:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lliw-will"
                          },
                          "bodyText": "Using 12345 returns:\n*** ERROR ***\n/home/will/cardinal/sfr/solid.i:463: (Mesh/outer_shield/input_mesh_external_boundary):\n    This mesh generator does not work for the provided external boundary as it has more than one segments.",
                          "url": "https://github.com/idaholab/moose/discussions/28706#discussioncomment-10754705",
                          "updatedAt": "2024-09-25T17:59:07Z",
                          "publishedAt": "2024-09-25T17:59:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok let s output the mesh and look at that boundary",
                          "url": "https://github.com/idaholab/moose/discussions/28706#discussioncomment-10754710",
                          "updatedAt": "2024-09-25T17:59:45Z",
                          "publishedAt": "2024-09-25T17:59:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lliw-will"
                          },
                          "bodyText": "Here is a .png of the paraview output:\n\nLet me know if there is a different way you would like to view this data.",
                          "url": "https://github.com/idaholab/moose/discussions/28706#discussioncomment-10754772",
                          "updatedAt": "2024-09-25T18:06:25Z",
                          "publishedAt": "2024-09-25T18:06:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mismatching block-restrictions are specified for variable with name 'disp_x':",
          "author": {
            "login": "PEI0214"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello\nI updated MOOSE. The new version seems to remove block-restrictions on variables. So that the simulation that could have been performed earlier reported errors. An example is as follows:\n[Problem]\n  kernel_coverage_check = false\n  material_coverage_check = false\n  boundary_restricted_node_integrity_check = false\n  # boundary_restricted_elem_integrity_check = false\n[]\n\nnew_domain_blocks = '1001    1002'\n\n[Mesh]\n  [box]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 10\n    ny = 10\n    nz = 10\n    xmin = 0\n    xmax = 1\n    ymin = 0\n    ymax = 1\n    zmin = 0\n    zmax = 1\n  []\n  [box1]\n    type = SubdomainBoundingBoxGenerator\n    input = box\n    block_id = 1\n    bottom_left = '0 0.5 0'\n    top_right = '1 1 1'\n  []\n\n  add_subdomain_ids = '${new_domain_blocks}'\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Variables]\n  [disp_x]\n    block = '${new_domain_blocks}'\n  []\n  [disp_y]\n    block = '${new_domain_blocks}'\n  []\n  [disp_z]\n    block = '${new_domain_blocks}'\n  []\n[]\n\n# ===== Tensor mechanics for all active domain blocks =====\n[Physics]\n  [SolidMechanics]\n    [QuasiStatic]\n      [all]\n        strain = finite\n        block = '${new_domain_blocks}'\n        add_variables = true\n        generate_output = 'stress_xx stress_zz'\n      []\n    []\n  []\n[]\n\n# ===== Gravity =====\n[Kernels]\n  [Gravity1]\n    type = Gravity\n    block = '${new_domain_blocks}'\n    use_displaced_mesh = false\n    variable = disp_y\n    value = -10\n  []\n[]\n\n# ===== Boundary Conditions =====\n[BCs]\n  [archor_x]\n    type = DirichletBC\n    boundary = 'bottom'\n    variable = disp_x\n    value = 0\n  []\n\n  [archor_y]\n    type = DirichletBC\n    boundary = 'bottom'\n    variable = disp_y\n    value = 0\n  []\n\n  [archor_z]\n    type = DirichletBC\n    boundary = 'bottom'\n    variable = disp_z\n    value = 0\n  []\n[]\n\n# ===== Materials (linear-elastic to keep it simple) =====\n[Materials]\n  [elasticity_tensor1]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 50E6 # 50 MPa\n    poissons_ratio = 0.3\n    block = '${new_domain_blocks}'\n  []\n\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n    block = '${new_domain_blocks}'\n  []\n\n  [density1]\n    type = GenericConstantMaterial\n    prop_names = density\n    prop_values = 2000\n    block = '${new_domain_blocks}'\n  []\n[]\n\n[MeshModifiers]\n  [m1]\n    type = TimedSubdomainModifier\n    times = '200 300'\n    blocks_from = '0 1'\n    blocks_to = '1001    1002'\n  []\n[]\n\n# ===== Executioner =====\n[Executioner]\n  type = Transient\n  automatic_scaling = true\n\n  end_time = 500\n  dt = 100\n\n  solve_type = 'PJFNK'\n\n  nl_abs_tol = 1E-5\n  nl_max_its = 400\n\n  l_tol = 1E-8\n  l_max_its = 200\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nThe error message is as follows:\n*** ERROR ***\n/home/pdd/projects4/moose/modules/solid_mechanics/problems/0925/2/test6.i:1.1:\nThe following error occurred in the Problem 'MOOSE Problem' of type FEProblem.\n\nMismatching block-restrictions are specified for variable with name 'disp_x': {1001, 1002} and {0, 1, 1001, 1002}",
          "url": "https://github.com/idaholab/moose/discussions/28709",
          "updatedAt": "2024-09-26T15:04:27Z",
          "publishedAt": "2024-09-26T02:38:55Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "what does Debug/show_actions = true show?\nThe first action to add the variables is setting the block restriction",
                  "url": "https://github.com/idaholab/moose/discussions/28709#discussioncomment-10758241",
                  "updatedAt": "2024-09-26T02:43:40Z",
                  "publishedAt": "2024-09-26T02:43:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "[DBG][ACT] TASK (               no_action) TYPE (                     EmptyAction) NAME (                ) Memory usage 101MB\n[DBG][ACT] TASK (             meta_action) TYPE (      CommonSolidMechanicsAction) NAME (     QuasiStatic) Memory usage 101MB\n[DBG][ACT] TASK (             meta_action) TYPE (QuasiStaticSolidMechanicsPhysics) NAME (             all) Memory usage 101MB\n[DBG][ACT] TASK (dynamic_object_registration) TYPE ( DynamicObjectRegistrationAction) NAME (         Problem) Memory usage 101MB\n[DBG][ACT] TASK (           common_output) TYPE (              CommonOutputAction) NAME (         Outputs) Memory usage 101MB\n[DBG][ACT] TASK (       set_global_params) TYPE (              GlobalParamsAction) NAME (    GlobalParams) Memory usage 101MB\n[DBG][ACT] TASK ( setup_recover_file_base) TYPE (      SetupRecoverFileBaseAction) NAME (                ) Memory usage 101MB\n[DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (          disp_x) Memory usage 101MB\n[DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (          disp_y) Memory usage 101MB\n[DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (          disp_z) Memory usage 101MB\n[DBG][ACT] TASK (   check_copy_nodal_vars) TYPE (             CopyNodalVarsAction) NAME (                ) Memory usage 101MB\n[DBG][ACT] TASK (              setup_mesh) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 101MB\n[DBG][ACT] TASK (        add_geometric_rm) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 102MB\n[DBG][ACT] TASK (        add_geometric_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 102MB\n[DBG][ACT] TASK (      add_mesh_generator) TYPE (          AddMeshGeneratorAction) NAME (             box) Memory usage 102MB\n[DBG][ACT] TASK (      add_mesh_generator) TYPE (          AddMeshGeneratorAction) NAME (            box1) Memory usage 102MB\n[DBG][ACT] TASK (create_added_mesh_generators) TYPE (       CreateAddedMeshGenerators) NAME (                ) Memory usage 102MB\n[DBG][ACT] TASK ( execute_mesh_generators) TYPE (           ExecuteMeshGenerators) NAME (                ) Memory usage 102MB\n[DBG][ACT] TASK (       recover_meta_data) TYPE (      SetupRecoverFileBaseAction) NAME (                ) Memory usage 113MB\n[DBG][ACT] TASK (           set_mesh_base) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 113MB\n[DBG][ACT] TASK (     attach_geometric_rm) TYPE (          AddRelationshipManager) NAME (                ) Memory usage 113MB\n[DBG][ACT] TASK (               init_mesh) TYPE (                 SetupMeshAction) NAME (            Mesh) Memory usage 113MB\n[DBG][ACT] TASK (            prepare_mesh) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 113MB\n[DBG][ACT] TASK (     uniform_refine_mesh) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 115MB\n[DBG][ACT] TASK (     setup_mesh_complete) TYPE (         SetupMeshCompleteAction) NAME (            Mesh) Memory usage 115MB\n[DBG][ACT] TASK (     setup_mesh_complete) TYPE (QuasiStaticSolidMechanicsPhysics) NAME (             all) Memory usage 115MB\n[DBG][ACT] TASK (   determine_system_type) TYPE (      CreateProblemDefaultAction) NAME (                ) Memory usage 115MB\n[DBG][ACT] TASK (          create_problem) TYPE (             CreateProblemAction) NAME (         Problem) Memory usage 115MB\n[DBG][ACT] TASK (  create_problem_default) TYPE (      CreateProblemDefaultAction) NAME (                ) Memory usage 115MB\n[DBG][ACT] TASK (  init_displaced_problem) TYPE (    CreateDisplacedProblemAction) NAME (            Mesh) Memory usage 118MB\n[DBG][ACT] TASK (validate_coordinate_systems) TYPE (QuasiStaticSolidMechanicsPhysics) NAME (             all) Memory usage 119MB\n[DBG][ACT] TASK (       setup_executioner) TYPE (         CreateExecutionerAction) NAME (     Executioner) Memory usage 119MB\n[DBG][ACT] TASK (            add_executor) TYPE (               AddExecutorAction) NAME (                ) Memory usage 119MB\n[DBG][ACT] TASK (   check_integrity_early) TYPE (            CheckIntegrityAction) NAME (                ) Memory usage 119MB\n[DBG][ACT] TASK (        add_aux_variable) TYPE (           DisplayGhostingAction) NAME (            Mesh) Memory usage 119MB\n[DBG][ACT] TASK (        add_aux_variable) TYPE (QuasiStaticSolidMechanicsPhysics) NAME (             all) Memory usage 119MB\n[DBG][ACT] TASK (            add_variable) TYPE (               AddVariableAction) NAME (          disp_x) Memory usage 120MB\n[DBG][ACT] TASK (            add_variable) TYPE (               AddVariableAction) NAME (          disp_y) Memory usage 120MB\n[DBG][ACT] TASK (            add_variable) TYPE (               AddVariableAction) NAME (          disp_z) Memory usage 120MB\n[DBG][ACT] TASK (            add_variable) TYPE (QuasiStaticSolidMechanicsPhysics) NAME (             all) Memory usage 120MB",
                          "url": "https://github.com/idaholab/moose/discussions/28709#discussioncomment-10758324",
                          "updatedAt": "2024-09-26T02:56:49Z",
                          "publishedAt": "2024-09-26T02:56:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "PEI0214"
                          },
                          "bodyText": "Do you know what the problem is?",
                          "url": "https://github.com/idaholab/moose/discussions/28709#discussioncomment-10758778",
                          "updatedAt": "2024-09-26T04:22:55Z",
                          "publishedAt": "2024-09-26T04:22:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you already add variables in the Variables block\nno need for them here\n      [all]\n        strain = finite\n        block = '${new_domain_blocks}'\n        add_variables = true\n        generate_output = 'stress_xx stress_zz'\n      []\n\nso add_variables = false\nand create variables for stress_xx zz in the AuxVariables block if needed",
                          "url": "https://github.com/idaholab/moose/discussions/28709#discussioncomment-10762110",
                          "updatedAt": "2024-09-26T10:52:45Z",
                          "publishedAt": "2024-09-26T10:52:44Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}