{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMC0xMS0xMVQwOTo0NTo0NC0wNjowMM15KA=="
    },
    "edges": [
      {
        "node": {
          "title": "Material properties and sharp transitions",
          "author": {
            "login": "gka80"
          },
          "bodyText": "I currently have a material property defined using a DerivativeParsedMaterial with an 'if' statement. The 'if' statement acts as a switch for the material property (i.e. similar to a first-order phase transition). I've tested the model above and below the critical point and it behaves as expected. However, because of the way I've modeled this, there's a sharp transition at the critical point. I'd like to \"help the solver out\" around this transition point in the hopes of improving convergence around this point and reducing runtime.\nWhat's a good way to accomplish this? If something doesn't exist, I don't have a problem with contributing if someone has an idea.\nThank you,\n-Garrett",
          "url": "https://github.com/idaholab/moose/discussions/16189",
          "updatedAt": "2023-02-08T07:01:13Z",
          "publishedAt": "2020-11-15T01:28:33Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I think this depends a bit on your physics.  For instance, in my fields where the finite element is frequently a coarse-scale representation of some complicated (unknown?) micro physics, a \"mollifier\" would be appropriate here.  That is, replace if(x<0, -1, 1) with tanh(x/m), where m is the mollifier (or some similar function).\n\na\n\u2026\n________________________________\nFrom: Garrett Kelley <notifications@github.com>\nSent: Sunday, 15 November 2020 11:28 AM\nTo: idaholab/moose <moose@noreply.github.com>\nCc: Subscribed <subscribed@noreply.github.com>\nSubject: [idaholab/moose] Material properties and sharp transitions (#16189)\n\n\nI currently have a material property defined using a DerivativeParsedMaterial with an 'if' statement. The 'if' statement acts as a switch for the material property (i.e. similar to a first-order phase transition). I've tested the model above and below the critical point and it behaves as expected. However, because of the way I've modeled this, there's a sharp transition at the critical point. I'd like to \"help the solver out\" around this transition point in the hopes of improving convergence around this point and reducing runtime.\n\nWhat's a good way to accomplish this? If something doesn't exist, I don't have a problem with contributing if someone has an idea.\n\nThank you,\n-Garrett\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub<#16189>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ABS6CVITDQ5CQ6JOQZIT7VTSP4VE5ANCNFSM4TV4I5KQ>.",
                  "url": "https://github.com/idaholab/moose/discussions/16189#discussioncomment-130123",
                  "updatedAt": "2023-02-08T07:01:14Z",
                  "publishedAt": "2020-11-15T21:28:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "gka80"
                          },
                          "bodyText": "Aha! That seems to have done the trick to get it over the \"hump\". Thank you, Andy.\nJust in case anyone else comes across this, I defined a \"switching\" function, f(x) = 0.5+0.5tanh((x-x_c)/w), where 'x_c' represents the critical point (i.e. a temperature) and 'w' represents the \"transition width.\" If 'p_below(x)' is the property below the critical point and 'p_above(x)' is the property above the critical point, you can transition between these two properties by: p(x) = p_below(x)(1-f(x))+p_above(x)*f(x).",
                          "url": "https://github.com/idaholab/moose/discussions/16189#discussioncomment-131258",
                          "updatedAt": "2023-02-08T07:01:14Z",
                          "publishedAt": "2020-11-17T02:28:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Free Coreform Cubit Learn license available for MOOSE users for meshing",
          "author": {
            "login": "msederberg"
          },
          "bodyText": "Hello MOOSE users,\nCoreform has recently rebranded Trelis to Coreform Cubit, and has made a free license of Coreform Cubit available for non-commercial use. Coreform Cubit Learn is fully functional; exports are limited to 50,000 elements. We are working on a couple of SBIR projects to enhance MOOSE, integrate MOOSE with our Coreform IGA solver, and integrate MOOSE with Coreform Cubit.\nThis new Coreform Cubit Learn license is part of this effort to make Coreform Cubit available to all members of the MOOSE community.\nWe welcome any questions or requests on our forum, we look forward to sharing more information soon on our other efforts regarding MOOSE.\nSincerely,\nMatt Sederberg\nCoreform CEO",
          "url": "https://github.com/idaholab/moose/discussions/16200",
          "updatedAt": "2022-06-29T02:52:53Z",
          "publishedAt": "2020-11-16T16:31:29Z",
          "category": {
            "name": "News"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Creating a temperature field",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Hi everyone,\nI want to create a temperature field (the central region is hot) as follows.\n\nThe temperature field is given by\nwhich from the paper (Hu, Acta Materialia 58 (2010) 3230\u20133237)\nhttps://www.sciencedirect.com/science/article/pii/S1359645410000571\nMy question is that how can I build this temperature field in MOOSE?\nBest,\nPeng",
          "url": "https://github.com/idaholab/moose/discussions/16194",
          "updatedAt": "2023-07-20T13:57:40Z",
          "publishedAt": "2020-11-15T21:32:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "I would use one of the \"Parsed Function\" objects in MOOSE.  For instance, if your temperature field is an IC, then use FunctionIC, while if your temperature field is an AuxVariable, then use a ParsedAux AuxKernel.   Just specify your function in the function input parameter in either case.\na",
                  "url": "https://github.com/idaholab/moose/discussions/16194#discussioncomment-130127",
                  "updatedAt": "2023-07-20T13:57:43Z",
                  "publishedAt": "2020-11-15T21:35:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "Not quite. One way is to use a\n[temperature]\n  type = ParsedAux\n  use_xyzt = true\n  function = 'x^2 + cos(x ...`\n  execute_on = INITIAL\n[]\n\nthe other is to use\n[temperature]\n  type = FunctionAux\n  function = 'x^2 + cos(x ...`\n  execute_on = INITIAL\n[]\n\nNo IC needed",
                          "url": "https://github.com/idaholab/moose/discussions/16194#discussioncomment-130179",
                          "updatedAt": "2023-07-20T13:58:04Z",
                          "publishedAt": "2020-11-15T23:16:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Ordering of Subapps in a MultiApp System",
          "author": {
            "login": "freiler"
          },
          "bodyText": "Hello all,\nI want to solve a problem of 3 equations in a decoupled manner using a Multiapp.\nSubapp1 solves Equation 1. It needs u1 and provides u2.\nSubapp2 solves Equation 2. It needs u2 and provides u3.\nSubapp3 solves Equation 3. It needs u2 and u3, and provides u1.\nThen, I would like to have a Master that calls the three subapp solves and dictates the ordering of the solves. It is important that the 3 equations are sequential.\nCould someone please lead me to the way this can be done? Or maybe guide me to a good example that follows the same idea?\nThank you in advance,\nRamiro",
          "url": "https://github.com/idaholab/moose/discussions/16141",
          "updatedAt": "2022-07-08T07:33:29Z",
          "publishedAt": "2020-11-10T16:03:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "You can have a main app set equation 2 as the subapp, then add equation 1 as a subapp of the equation 2 subapp on timestep_begin, add equation 3 as a subapp of the equation 2 subapp on timestep_end. Eq. 1 and Eq. 3 input are on the same level of app tree, i.e. both subapps of the first level subapp of Eq. 2.",
                  "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-125810",
                  "updatedAt": "2022-07-08T07:33:26Z",
                  "publishedAt": "2020-11-10T16:20:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "Yaqi's comment might be a little confusing, so here is a visualization:\n              u1               u3\n[ SubApp1 ]<------[ MainApp ]----->[ SubApp2 ]\n[ (Eq.1)  ]------>[ (Eq.2)  ]<-----[ (Eq.3)  ]\n              u2               u1\n\nFor the ordering, set SubApp1 execute_on = timestep_begin and SubApp2 execute_on = timestep_end",
                  "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-125850",
                  "updatedAt": "2022-07-08T07:33:26Z",
                  "publishedAt": "2020-11-10T17:10:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ragusa"
                          },
                          "bodyText": "Quick follow-up question: What if one has 4 equations? The sequence of solve to preserve is u1-->u2-->u3-->u4. Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-125860",
                          "updatedAt": "2022-07-08T07:33:36Z",
                          "publishedAt": "2020-11-10T17:20:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Using Actions might solve this problem. Actions can enforce the ordering of adding subapps, which will be used by MOOSE to execute the subapps. We can create an action that takes parameter like inputs = 'input1 input2 input3 input4' and execute_on to add the subapps sequentially. MOOSE currently does not have the ordering capability of multiapps on the same level and the same execute_on flag, i.e. MultiApp does not accept a parameter like 'input' in mesh generators.",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-125877",
                          "updatedAt": "2022-07-08T07:33:36Z",
                          "publishedAt": "2020-11-10T17:37:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Oh, I forgot one thing: The data transfer happens only once both at the beginning and the end of executing multiapps at an execute_on flag. This means if we have 4 subapps on the same execute_on flag, the data outputted by one subapp will not immediately available to the next subapp until next Picard iteration. So basically we are doing Jacobi style sweeping through subapps at the same execute_on flag. So even we enforce the ordering, it does not matter anyway. Sorry about my previous reply.",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-125883",
                          "updatedAt": "2022-07-08T07:33:36Z",
                          "publishedAt": "2020-11-10T17:45:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zachmprince"
                          },
                          "bodyText": "I don't think actions would help in this case because all transfers with a certain execute flag happen at once, either before or after all the subapps have been executed. So the second subapp in the ordering would not receive information from first subapp's solve until until after all subapps have been executed.",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-125884",
                          "updatedAt": "2022-07-08T07:34:14Z",
                          "publishedAt": "2020-11-10T17:46:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Right. Someone wanted the capability of doing data transfer among sibling subapps, i.e. let subapp itself initiate the transfer after it gets executed. That along with action can solve this issue. But that subapp level transfer is something @friedmud dislike alot and could complicate the design and usage significantly.",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-125887",
                          "updatedAt": "2022-07-08T07:34:08Z",
                          "publishedAt": "2020-11-10T17:51:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zachmprince"
                          },
                          "bodyText": "For the case of u1->u2->u3->u4->u1 I would use a tree structure like this:\n          u3                   u2\n    ------------>[ SubApp1 ]------>[ SubSubApp1 ]\n    |            [ Eq. (2) ]<------[   (Eq.1)   ]\n    |                |         u1\n    |          u2    |\n[ MainApp ]<----------\n[ (Eq. 3) ]<----------\n     |         u4    |\n     |               |\n     ----------->[ SubApp 2]\n          u3     [ (Eq.4)  ]",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-125892",
                          "updatedAt": "2022-07-08T07:34:08Z",
                          "publishedAt": "2020-11-10T17:56:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "freiler"
                          },
                          "bodyText": "This makes sense. Thank you very much for your answers!",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-125893",
                          "updatedAt": "2022-07-08T07:34:09Z",
                          "publishedAt": "2020-11-10T17:58:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "freiler"
                          },
                          "bodyText": "Following @zachmprince comment above:\n\nYaqi's comment might be a little confusing, so here is a visualization:\n              u1               u3\n[ SubApp1 ]<------[ MainApp ]----->[ SubApp2 ]\n[ (Eq.1)  ]------>[ (Eq.2)  ]<-----[ (Eq.3)  ]\n              u2               u1\n\nFor the ordering, set SubApp1 execute_on = timestep_begin and SubApp2 execute_on = timestep_end\n\nI would like to transfer u1 in the scheme above to SubApp1 before the timestep ends, so that u1 is available for the upcoming timestep to properly solve for u2.\nIs there any way to do this?\nThank you!",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-128849",
                          "updatedAt": "2022-07-08T07:34:09Z",
                          "publishedAt": "2020-11-13T17:05:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "freiler"
                          },
                          "bodyText": "The transfer in order should happen in the following way:\nu2 From SubApp1 to MainApp\nu3 & u2 From MainApp to SubApp2\nu1 From SubApp2 to SubApp1 (somehow)\nThen a new iteration may start.",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-128859",
                          "updatedAt": "2022-07-08T07:34:16Z",
                          "publishedAt": "2020-11-13T17:21:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zachmprince"
                          },
                          "bodyText": "As long as you don't set the execute_on flag in the transfer, the order of operation should be:\n\nTransfer to_multiapp\nSolve multiapp\nTransfer from_multiapp\n\nSo if your input looks like this in the mainapp:\n[MultiApps]\n  [SubApp1]\n    type = FullSolveMultiApp\n    input = sub1.i\n    execute_on = timestep_begin\n  []\n  [SubApp2]\n    type = FullSolveMultiApp\n    input = sub2.i\n    execute_on = timestep_end\n  []\n[]\n\n[Transfers]\n  [u1_to_sub1]\n    type = MultiAppCopyTransfer\n    multiapp = SubApp1\n    direction = to_multiapp\n    to_variable = u1\n    from_variable = u1\n  []\n  [u2_from_sub1]\n    type = MultiAppCopyTransfer\n    multiapp = SubApp1\n    direction = from_multiapp\n    to_variable = u2\n    from_variable = u2\n  []\n  [u2_u3_to_sub2]\n    type = MultiAppCopyTransfer\n    multiapp = SubApp2\n    direction = to_multiapp\n    to_variable = 'u2 u3'\n    from_variable = 'u2 u3'\n  []\n  [u1_from_sub2]\n    type = MultiAppCopyTransfer\n    multiapp = SubApp2\n    direction = from_multiapp\n    to_variable = u1\n    from_variable = u1\n  []\n[]\n\nThe order of operations will be:\n\nTransfer u1 to SubApp1 from MainApp\nSolve SubApp1\nTransfer u2 to MainApp from SubApp1\nSolve MainApp\nTransfer u2 and u3 to SubApp2 from MainApp\nSolve SubApp2\nTransfer u1 to MainApp from SubApp2\n\nRepeated until convergence",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-128906",
                          "updatedAt": "2022-07-08T07:34:29Z",
                          "publishedAt": "2020-11-13T18:49:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "freiler"
                  },
                  "bodyText": "@YaqiWang @zachmprince Thank you both for your answers Yaqi and Zach. This solves my current problem.\nA follow-up question on this would be if there is another way to order a sequence of subapps than using the \"execute_on\" option. My question aims at what would happen for example if we needed to solve multiple uncoupled equations (at least more than 3). The 'execute_on' option for multiple decoupled equations seems limited for a hypothetical case of this kind.\nThanks again,\nRamiro",
                  "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-125857",
                  "updatedAt": "2022-07-08T07:36:01Z",
                  "publishedAt": "2020-11-10T17:17:02Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "execute_on is the only way to order the apps from the main app. But you can use a nested multiapp structure to facilitate more control on the ordering.  Something like in this image: https://mooseframework.inl.gov/workshop/?_ga=2.38902757.731230092.1603987117-130448754.1603987117#/51/3",
                  "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-125876",
                  "updatedAt": "2022-07-08T07:35:58Z",
                  "publishedAt": "2020-11-10T17:37:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ragusa"
                  },
                  "bodyText": "Thanks. To avoid repeating this until convergence, I suppose we can limit the Picard iterations. This should be done at the master input, I think. In which block and what\u2019s that syntax? Thanks!\n\n\u2014jean ragusa\n\n\nhttp://multiphysics.engr.tamu.edu\nhttp://nustem.engr.tamu.edu\n-.-.-\niPhone, iTypo, iApologize.\n\nOn Nov 13, 2020, at 12:50 PM, Zachary Prince <notifications@github.com> wrote:\n\n\ufeff\n\nAs long as you don't set the execute_on flag in the transfer, the order of operation should be:\n\n  1.  Transfer to_multiapp\n  2.  Solve multiapp\n  3.  Transfer from_multiapp\n\nSo if your input looks like this in the mainapp:\n\n[MultiApps]\n  [SubApp1]\n    type = FullSolveMultiApp\n    input = sub1.i\n    execute_on = timestep_begin\n  []\n  [SubApp2]\n    type = FullSolveMultiApp\n    input = sub2.i\n    execute_on = timestep_end\n  []\n[]\n\n[Transfers]\n  [u1_to_sub1]\n    type = MultiAppCopyTransfer\n    multiapp = SubApp1\n    direction = to_multiapp\n    to_variable = u1\n    from_variable = u1\n  []\n  [u2_from_sub1]\n    type = MultiAppCopyTransfer\n    multiapp = SubApp1\n    direction = from_multiapp\n    to_variable = u2\n    from_variable = u2\n  []\n  [u2_u3_to_sub2]\n    type = MultiAppCopyTransfer\n    multiapp = SubApp2\n    direction = to_multiapp\n    to_variable = 'u2 u3'\n    from_variable = 'u2 u3'\n  []\n  [u1_from_sub2]\n    type = MultiAppCopyTransfer\n    multiapp = SubApp2\n    direction = from_multiapp\n    to_variable = u1\n    from_variable = u1\n  []\n[]\n\n\nThe order of operations will be:\n\n  1.  Transfer u1 to SubApp1 from MainApp\n  2.  Solve SubApp1\n  3.  Transfer u2 to MainApp from SubApp1\n  4.  Solve MainApp\n  5.  Transfer u2 and u3 to SubApp2 from MainApp\n  6.  Solve SubApp2\n  7.  Transfer u1 to MainApp from SubApp2\n\nRepeated until convergence\n\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub<https://urldefense.com/v3/__https://github.com/idaholab/moose/discussions/16141*discussioncomment-128906__;Iw!!KwNVnqRv!Wsz1WSRVbPh_dl643bnIVRrOM6i_pmtwhfq7yOUvba5j4owMbMKZJjX2hgEFXzxG8w$>, or unsubscribe<https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/AAEMAJG6BQ5HW2QASKBAN5DSPV5VPANCNFSM4TQ27IVQ__;!!KwNVnqRv!Wsz1WSRVbPh_dl643bnIVRrOM6i_pmtwhfq7yOUvba5j4owMbMKZJjX2hgF_TbPCaA$>.",
                  "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-128912",
                  "updatedAt": "2022-07-08T07:56:48Z",
                  "publishedAt": "2020-11-13T19:04:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zachmprince"
                          },
                          "bodyText": "Here are all the options regarding picard iterations:\n\nYou can find more details here",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-128918",
                          "updatedAt": "2022-07-08T07:57:38Z",
                          "publishedAt": "2020-11-13T19:21:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zachmprince"
                          },
                          "bodyText": "Oh sorry, this is in the [Executioner] block",
                          "url": "https://github.com/idaholab/moose/discussions/16141#discussioncomment-128919",
                          "updatedAt": "2022-07-08T07:57:49Z",
                          "publishedAt": "2020-11-13T19:21:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Guidance on MultiApps and Transfers",
          "author": {
            "login": "robfairh"
          },
          "bodyText": "Hi folks, I am trying to solve a problem that uses two input files and two different meshes. The first input file solves the temperature in a cylinder. The variable changes in 'z' but not in 'r'. I record the temperature along 'z' in a .csv file using a vector-postprocessor. The second file uses the .csv file data to define the values of a BC on a line. For that, I am using 'FunctionDirichletBC' and defining the function values reading the .csv file.\nI am trying to define this with the MultiApps and the Transfer actions to run only one simulation instead of two. I haven't used these actions before. Is there any easy way to implement this?",
          "url": "https://github.com/idaholab/moose/discussions/16051",
          "updatedAt": "2022-07-07T04:44:13Z",
          "publishedAt": "2020-11-03T00:02:03Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "I am not sure we have a transfer that exists for this case. I think what you need is a VectorPostprocessor transfer that transfers the entire vector from one system to the other. A vector version of this: MultiAppPostprocessorTransfer.\nThe best approach might be to add this capability to the existing MultiAppVectorPostprocessorTransfer, I will take a look and see how that might work. It might be easy to add.",
                  "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-119776",
                  "updatedAt": "2022-07-07T04:44:12Z",
                  "publishedAt": "2020-11-03T03:32:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "I am going to try to add this capability quickly, see #16055",
                          "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-119794",
                          "updatedAt": "2022-07-07T04:44:12Z",
                          "publishedAt": "2020-11-03T04:49:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "robfairh"
                          },
                          "bodyText": "Great! Thank you",
                          "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-120441",
                          "updatedAt": "2022-07-07T04:44:12Z",
                          "publishedAt": "2020-11-03T15:55:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "As you noticed in the issue we are going to build something a bit more generic that should work for this, but it will take some time before it is available. Will the answer below work for you?",
                          "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-121604",
                          "updatedAt": "2022-07-07T04:44:12Z",
                          "publishedAt": "2020-11-05T00:22:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "robfairh"
                          },
                          "bodyText": "I'll try it and see if it works!",
                          "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-121656",
                          "updatedAt": "2022-08-30T20:14:19Z",
                          "publishedAt": "2020-11-05T03:35:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "vincentlaboure"
                  },
                  "bodyText": "I'd think the most direct way to accomplish this is using a LayeredAverage which you can transfer with a MultiAppUserObjectTransfer. Then you might have to create a VariableDirichletBC but that should be pretty straightforward.",
                  "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-120513",
                  "updatedAt": "2022-07-07T04:44:15Z",
                  "publishedAt": "2020-11-03T17:25:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "robfairh"
                          },
                          "bodyText": "Okay, I tried this approach, and it doesn't work.\nThe 'VariableDirichletBC' is the tricky part. As I would be imposing the values of a variable with the values of an auxiliary variable.\nAnd we cannot couple elemental variables into nodal objects.\nCan we?",
                          "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-125903",
                          "updatedAt": "2022-07-07T04:44:16Z",
                          "publishedAt": "2020-11-10T18:14:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "robfairh"
                          },
                          "bodyText": "Maybe I am doing something else wrong.\nIn my sub file, I define the UserObjects action like this:\n[UserObjects]\n  [./sub_app_temp]\n    type = LayeredAverage\n    direction = y\n    variable = temp\n    num_layers = 100\n    execute_on = linear\n    block = 'cool'\n  [../]\n[]\n\nAnd in my master file, I define the MultiApps and the Transfers actions like this:\n[MultiApps]\n  [./sub]\n    type = FullSolveMultiApp\n    input_files = simple.i\n    no_backup_and_restore = true\n  [../]\n[]\n\n[Transfers]\n  [layered_transfer_from_sub_app]\n    type = MultiAppUserObjectTransfer\n    direction = from_multiapp\n    user_object = sub_app_temp\n    variable = sub_app_var\n    multi_app = sub\n    # displaced_source_mesh = true\n    # skip_bounding_box_check = true\n  []\n[]\n\nwhich defines an AuxVariable like this:\n[AuxVariables]\n  [./sub_app_var]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 'cool'\n    initial_condition = 1\n  [../]\n[]\n\nThe transfer of the LayeredAverage object is working, and it modifies the AuxVariable. But defining the BC with the AuxVariable I haven't figured that out. Am I missing something obvious here?",
                          "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-125904",
                          "updatedAt": "2022-07-07T04:44:16Z",
                          "publishedAt": "2020-11-10T18:22:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vincentlaboure"
                          },
                          "bodyText": "Can you try to model your VariableDirichletBC on PenaltyDirichletBC to impose your boundary condition weakly instead of strongly? The problem with a NodalBC (such as DirichletBC) is that it does not know what to do when the variable you impose is discontinuous, as in your case. On the other hand, an IntegratedBC should work fine.",
                          "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-126984",
                          "updatedAt": "2022-07-07T04:44:24Z",
                          "publishedAt": "2020-11-11T15:21:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "robfairh"
                          },
                          "bodyText": "I'll try that. Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-127045",
                          "updatedAt": "2022-07-26T02:11:53Z",
                          "publishedAt": "2020-11-11T16:17:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "robfairh"
                          },
                          "bodyText": "It worked! Thank you so much @vincentlaboure and @aeslaughter for your time. @aeslaughter I will still be willing to try that new capability under development.\nI had to play a little bit around with the value of penalty to get it to work. Here is a figure with my result:\n\nThe transfer sets the values of the AuxVariable sub_app_var and then, AuxDirichletBC imposes those values to the variable temp.\nHere are the .h and the .C just in case someone in the future wants to do something similar.",
                          "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-128880",
                          "updatedAt": "2022-07-26T02:11:52Z",
                          "publishedAt": "2020-11-13T17:49:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "The new transfer capability was just finished off a few days ago: https://mooseframework.inl.gov/source/transfers/MultiAppReporterTransfer.html",
                          "url": "https://github.com/idaholab/moose/discussions/16051#discussioncomment-129019",
                          "updatedAt": "2022-07-26T02:11:56Z",
                          "publishedAt": "2020-11-13T22:24:50Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mortar _q_point",
          "author": {
            "login": "srinath-chakravarthy"
          },
          "bodyText": "Hello all,\nI am attempting to retrieve the location of a _qp within the mortar system. @lindayad or anyone else, do you happen to know if this is available, or any other method i can use to get the coordinates.\nCheers\nSrinath",
          "url": "https://github.com/idaholab/moose/discussions/16171",
          "updatedAt": "2022-06-02T06:19:55Z",
          "publishedAt": "2020-11-12T22:46:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "You misspelled your @lindsayad",
                  "url": "https://github.com/idaholab/moose/discussions/16171#discussioncomment-128457",
                  "updatedAt": "2022-06-02T06:19:55Z",
                  "publishedAt": "2020-11-13T04:24:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@srinath-chakravarthy I am assuming that you want the physical location of the quadrature points, not their location on the reference element. The former we cannot do at this moment, but I've opened #16177 to do so. I'll probably whip that up in the next hour. If you just want the latter, you can do _qrule_msm->qp(_qp)",
                  "url": "https://github.com/idaholab/moose/discussions/16171#discussioncomment-128823",
                  "updatedAt": "2022-06-02T06:20:30Z",
                  "publishedAt": "2020-11-13T16:28:54Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "@lindsayad Thanks so much, i was looking for the latter.",
                  "url": "https://github.com/idaholab/moose/discussions/16171#discussioncomment-128852",
                  "updatedAt": "2022-06-02T06:20:42Z",
                  "publishedAt": "2020-11-13T17:12:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "Oh sorry was looking for the former :).",
                  "url": "https://github.com/idaholab/moose/discussions/16171#discussioncomment-128853",
                  "updatedAt": "2022-06-02T06:21:42Z",
                  "publishedAt": "2020-11-13T17:12:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Problems while compiling MOOSE",
          "author": {
            "login": "Giovar6"
          },
          "bodyText": "Good evening everybody,\nI followed literally the instructions reported at https://mooseframework.inl.gov/getting_started/installation/conda.html, to install MOOSE on Ubuntu 20.04.1 but when I compile MOOSE I got this error:\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/loops_Unity.C...\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/kernels_Unity.C...\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/mesh_Unity.C...\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/interfacekernels_Unity.C...\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/interfaces_Unity.C...\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/timesteppers_Unity.C...\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/problems_Unity.C...\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/systems_Unity.C...\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/predictors_Unity.C...\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/fvbcs_Unity.C...\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/postprocessors_Unity.C...\nCompiling C++ (in opt mode) /home/giovanni/projects/moose/framework/build/unity_src/variables_Unity.C...\n{standard input}: Assembler messages:\n{standard input}:19171: Warning: end of file not at end of a line; newline inserted\nx86_64-conda_cos6-linux-gnu-c++: internal compiler error: Killed (program cc1plus)\nPlease submit a full bug report,\nwith preprocessed source if appropriate.\nSee https://gcc.gnu.org/bugs/ for instructions.\nmake: *** [/home/giovanni/projects/moose/framework/build.mk:118: /home/giovanni/projects/moose/framework/build/unity_src/problems_Unity.x86_64-pc-linux-gnu.opt.lo] Errore 1\nmake: *** Attesa per i processi non terminati....\nI've tried also to run the tests, but obviously all tests failed. So I've tried to uninstall everything and reinstall but did not worked. Sometimes also Ubuntu crashed. When this problem happen generally the computer stop working for some minutes (I cannot move neither the mouse)\nWhat could be the reason for this issue?\nThank you in advance for any suggestion.\nKind regards,\nGiovanni",
          "url": "https://github.com/idaholab/moose/discussions/16151",
          "updatedAt": "2022-09-14T08:38:04Z",
          "publishedAt": "2020-11-11T15:57:57Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Giovar6"
                  },
                  "bodyText": "Good Evevening,\nThe problem was solved. Jeson Miller explained me (at this discussion https://groups.google.com/g/moose-users/c/UjkErXUTfD0) that 6 Gb of RAM are not enough to perform the command make -j4.\nI've used instead the command: make -j3 and MOOSE compiled perfectly.\nI have also performed the test obtaining several pass and some skip.\nThank you anyway.\nGiovanni",
                  "url": "https://github.com/idaholab/moose/discussions/16151#discussioncomment-127165",
                  "updatedAt": "2022-09-14T08:38:09Z",
                  "publishedAt": "2020-11-11T18:43:37Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "@Giovar6  Thank you for re-submitting your question!",
                  "url": "https://github.com/idaholab/moose/discussions/16151#discussioncomment-128770",
                  "updatedAt": "2022-09-14T08:38:11Z",
                  "publishedAt": "2020-11-13T15:17:47Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Rotating the SmoothSuperellipsoid by an arbitrary angle",
          "author": {
            "login": "mnabilbhuiyan"
          },
          "bodyText": "Hello,\nI am looking how to rotate the \"SmoothSuperellipsoid\" by an arbitrary angle say 20 with respect to x or y axis in a two dimensional grain growth simulation. I need some suggestions on how I can rotate the axis of the ellipse? I am using the following block but I am confused how I can define the angle.\n[ICs]\n[./c]\ntype = SpecifiedSmoothSuperellipsoidIC\nvariable = c\nx_positions = '750'\ny_positions = '550'\nz_positions = '0'\nas = '120.0'\nbs = '60.0'\ncs = '60.0'\nns = '2.0'\ninvalue = 1.0\noutvalue = 0.0\nint_width = 1.0\n[../]\n[]\n\nIs it possible to define the angle of the semi axis with length anyhow?\nBest Regards\nNabil",
          "url": "https://github.com/idaholab/moose/discussions/16162",
          "updatedAt": "2020-11-13T04:24:40Z",
          "publishedAt": "2020-11-12T00:10:01Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "Right now the code does not have the capability to do this. It wouldn't be too hard to add if you wanted to try it. It would be a good first MOOSE contribution if you are interested in becoming a contributor. Have a look at SmoothSuperEllipsoidBaseIC to see how the current version works",
                  "url": "https://github.com/idaholab/moose/discussions/16162#discussioncomment-127390",
                  "updatedAt": "2020-11-12T00:41:45Z",
                  "publishedAt": "2020-11-12T00:41:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mnabilbhuiyan"
                          },
                          "bodyText": "Thank you for the direction",
                          "url": "https://github.com/idaholab/moose/discussions/16162#discussioncomment-127787",
                          "updatedAt": "2020-11-12T13:25:06Z",
                          "publishedAt": "2020-11-12T13:25:06Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Variable dependent yield stress",
          "author": {
            "login": "shipinqin"
          },
          "bodyText": "Hello,\nI am trying to define concentration-dependent yield stress in MOOSE, but not sure how to do it (more details on what I am trying to do are below).  Any suggestions from you will be appreciated.\nThe concentration (actually, it is the fraction of a phase) is read from a MOOSE simulation result file generated in another MOOSE simulation, and I am trying to make the yield stress to be dependent on this concentration.  As a starting point, I worked on the simplest strain hardening case - J2 with perfect plasticity, so there is only one parameter, the initial yield stress, that needs to be dependent on the concentration (but I do not know how).\nAs of now, I have successfully made the Young's modulus to be dependent on the concentration by using the \"ComputeVariableIsotropicElasticityTensor\" app.  However, there does not seem to be a yield stress counterpart.  Currently, I implemented the J2 plasticity model through \"IsotropicPlasticityStressUpdate\" and \"ComputeMultipleInelasticStress\", however, \"yield_stress\" in \"IsotropicPlasticityStressUpdate\" takes only numbers, not variables.\nAgain, any suggestions will be appreciated!\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/16111",
          "updatedAt": "2022-06-10T13:21:38Z",
          "publishedAt": "2020-11-07T02:11:09Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "bwspenc"
                  },
                  "bodyText": "You would need to change yield_stress to be a coupled variable. Look at ComputeSmearedCrackingStress, where cracking_stress was recently switched to take a variable in a similar way. If it's constant, the user can supply a single number as before for that parameter. You do need to give some thought to how a variable yield stress would affect the hardening behavior, though.",
                  "url": "https://github.com/idaholab/moose/discussions/16111#discussioncomment-125249",
                  "updatedAt": "2022-06-10T13:21:33Z",
                  "publishedAt": "2020-11-09T19:33:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "shipinqin"
                          },
                          "bodyText": "Hello Ben,\nThank you very much for your suggestions.  I made it work today following them!\nLike you have said, the suggested workaround is ok when assuming perfect plasticity, however, things will be more challenging if strain hardening is involved.  While I am not rushed to move to that stage for now, I am indeed interested to know what you think is the best possible solution.  Is modifying the IsotropicPlasticityStressUpdate.C file a good idea?  I tried to change params.addParam<Real> in line 28 to params.addParam<MaterialPropertyName> and getParam<Real> in line 49 to getMaterialProperty<Real>, but apparently it did not work (not surprising).  Will modifications like this be trivial, or it will actually involve significant modifications to many files?\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/16111#discussioncomment-127364",
                          "updatedAt": "2022-06-10T13:21:34Z",
                          "publishedAt": "2020-11-11T23:43:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Newton Scheme FAILED to converge - Following up",
          "author": {
            "login": "MonikaCarvajal"
          },
          "bodyText": "Hi all,\nThis is a follow up of the this topic on MOOSE-users.\nI get an error during simulation apparently something fails during the mesh adaptivity. I have a rectangular mesh generated with the built-in tool of MOOSE.\nMy simulation on debug mode\n_Building mesh ............................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n..........................................................................................\n................................                                                           [559.82 s]\n*** Warning, This code is deprecated and will be removed in future versions:\nUse set() method for non-const access\nInitializing equation system .............................................................\n..............                                                                             [ 76.19 s]\nUsing EXPERIMENTAL Stateful Material Property projection with Adaptivity!\nWarning! Mesh re-partitioning is disabled while using stateful material properties!  This can lead to large load imbalances and degraded performance!!\nFramework Information:\nMOOSE Version:           git commit 3a7a42a on 2020-10-29\nLibMesh Version:         a62cd9cef65556bd080c8fbed00a43016a2d5bff\nPETSc Version:           3.13.3\nSLEPc Version:           3.13.3\nCurrent Time:            Fri Nov  6 11:43:37 2020\nExecutable Timestamp:    Fri Nov  6 11:27:31 2020\nParallelism:\nNum Processors:          4\nNum Threads:             1\nMesh:\nParallel Type:           replicated\nMesh Dimension:          2\nSpatial Dimension:       2\nNodes:\nTotal:                 44800\nLocal:                 11322\nElems:\nTotal:                 44341\nLocal:                 11085\nNum Subdomains:          1\nNum Partitions:          4\nPartitioner:             metis\nNonlinear System:\nNum DOFs:                134400\nNum Local DOFs:          33966\nVariables:               { \"disp_x\" \"disp_y\" \"porepressure\" }\nFinite Element Types:    \"LAGRANGE\"\nApproximation Orders:    \"FIRST\"\nAuxiliary System:\nNum DOFs:                842479\nNum Local DOFs:          210615\nVariables:               { \"stress_zx\" \"stress_zy\" \"stress_zz\" \"indicator\"\n\"marker\" }\nFinite Element Types:    \"MONOMIAL\"\nApproximation Orders:    \"CONSTANT\"\nExecution Information:\nExecutioner:             Transient\nTimeStepper:             FunctionDT\nSolver Mode:             NEWTON\nPETSc Preconditioner:    lu\nMOOSE Preconditioner:    SMP_\nand the error logs\nTime Step 45, time = 0.1, dt = 0.00150267\nComputing initial residual ...............................................................\n..........................................................................................\n..........                                                                                 [164.37 s]\nUpdating displaced mesh ...................                                                [ 20.57 s]\n0 Nonlinear |R| = 5.252897e+05\nUpdating displaced mesh ...................                                                [ 20.60 s]\n0 Linear |R| = 5.252897e+05\n1 Linear |R| = 7.326103e-07\nLinear solve converged due to CONVERGED_RTOL iterations 1\nUpdating displaced mesh ...................                                                [ 20.61 s]\n1 Nonlinear |R| = 2.330332e-05\nNonlinear solve converged due to CONVERGED_FNORM_ABS iterations 1\nSolve Converged!\n[0] ../src/fe/fe_map.C, line 1953, compiled Oct  7 2020 at 15:55:59\nWARNING: Newton scheme has not converged in 11 iterations:\nphysical_point=(x,y,z)=(  10.232, -1.91367,        0)   physical_guess=(x,y,z)=(  10.232, -1.91367,        0)   dp=(x,y,z)=(1.18837e-06, -1.47947e-07,        0)   p=(x,y,z)=(      -1, -0.577351,        0)   error=1.19754e-06   in element 681466\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\n[0] ../src/fe/fe_map.C, line 1953, compiled Oct  7 2020 at 15:55:59\nWARNING: Newton scheme has not converged in 12 iterations:\nphysical_point=(x,y,z)=(  10.232, -1.91367,        0)   physical_guess=(x,y,z)=(  10.232, -1.91367,        0)   dp=(x,y,z)=(-1.18837e-06, 1.47947e-07,        0)   p=(x,y,z)=(      -1, -0.57735,        0)   error=1.19754e-06   in element 681466\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\n[0] ../src/fe/fe_map.C, line 1953, compiled Oct  7 2020 at 15:55:59\nWARNING: Newton scheme has not converged in 13 iterations:\nphysical_point=(x,y,z)=(  10.232, -1.91367,        0)   physical_guess=(x,y,z)=(  10.232, -1.91367,        0)   dp=(x,y,z)=(1.18837e-06,        0,        0)   p=(x,y,z)=(      -1, -0.57735,        0)   error=1.18837e-06   in element 681466\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\n[0] ../src/fe/fe_map.C, line 1953, compiled Oct  7 2020 at 15:55:59\nWARNING: Newton scheme has not converged in 14 iterations:\nphysical_point=(x,y,z)=(  10.232, -1.91367,        0)   physical_guess=(x,y,z)=(  10.232, -1.91367,        0)   dp=(x,y,z)=(-1.18837e-06, -1.47947e-07,        0)   p=(x,y,z)=(      -1, -0.577351,        0)   error=1.19754e-06   in element 681466\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\n[0] ../src/fe/fe_map.C, line 1953, compiled Oct  7 2020 at 15:55:59\nWARNING: Newton scheme has not converged in 15 iterations:\nphysical_point=(x,y,z)=(  10.232, -1.91367,        0)   physical_guess=(x,y,z)=(  10.232, -1.91367,        0)   dp=(x,y,z)=(1.18837e-06, 1.47947e-07,        0)   p=(x,y,z)=(      -1, -0.57735,        0)   error=1.19754e-06   in element 681466\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\n[0] ../src/fe/fe_map.C, line 1953, compiled Oct  7 2020 at 15:55:59\nWARNING: Newton scheme has not converged in 16 iterations:\nphysical_point=(x,y,z)=(  10.232, -1.91367,        0)   physical_guess=(x,y,z)=(  10.232, -1.91367,        0)   dp=(x,y,z)=(-1.18837e-06,        0,        0)   p=(x,y,z)=(      -1, -0.57735,        0)   error=1.18837e-06   in element 681466\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\n[0] ../src/fe/fe_map.C, line 1953, compiled Oct  7 2020 at 15:55:59\nWARNING: Newton scheme has not converged in 17 iterations:\nphysical_point=(x,y,z)=(  10.232, -1.91367,        0)   physical_guess=(x,y,z)=(  10.232, -1.91367,        0)   dp=(x,y,z)=(1.18837e-06, -1.47947e-07,        0)   p=(x,y,z)=(      -1, -0.577351,        0)   error=1.19754e-06   in element 681466\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\n[0] ../src/fe/fe_map.C, line 1953, compiled Oct  7 2020 at 15:55:59\nWARNING: Newton scheme has not converged in 18 iterations:\nphysical_point=(x,y,z)=(  10.232, -1.91367,        0)   physical_guess=(x,y,z)=(  10.232, -1.91367,        0)   dp=(x,y,z)=(-1.18837e-06, 1.47947e-07,        0)   p=(x,y,z)=(      -1, -0.57735,        0)   error=1.19754e-06   in element 681466\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\n[0] ../src/fe/fe_map.C, line 1953, compiled Oct  7 2020 at 15:55:59\nWARNING: Newton scheme has not converged in 19 iterations:\nphysical_point=(x,y,z)=(  10.232, -1.91367,        0)   physical_guess=(x,y,z)=(  10.232, -1.91367,        0)   dp=(x,y,z)=(1.18837e-06,        0,        0)   p=(x,y,z)=(      -1, -0.57735,        0)   error=1.18837e-06   in element 681466\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\n[0] ../src/fe/fe_map.C, line 1953, compiled Oct  7 2020 at 15:55:59\nWARNING: Newton scheme has not converged in 20 iterations:\nphysical_point=(x,y,z)=(  10.232, -1.91367,        0)   physical_guess=(x,y,z)=(  10.232, -1.91367,        0)   dp=(x,y,z)=(-1.18837e-06, -1.47947e-07,        0)   p=(x,y,z)=(      -1, -0.577351,        0)   error=1.19754e-06   in element 681466\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\n[0] ../src/fe/fe_map.C, line 1953, compiled Oct  7 2020 at 15:55:59\nWARNING: Newton scheme has not converged in 21 iterations:\nphysical_point=(x,y,z)=(  10.232, -1.91367,        0)   physical_guess=(x,y,z)=(  10.232, -1.91367,        0)   dp=(x,y,z)=(1.18837e-06, 1.47947e-07,        0)   p=(x,y,z)=(      -1, -0.57735,        0)   error=1.19754e-06   in element 681466\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\nERROR: Newton scheme FAILED to converge in 21 iterations in element 681466 for physical point = (x,y,z)=(  10.232, -1.91367,        0)\nElem Information\nid()=681466, unique_id()=1272447, processor_id()=0\ntype()=QUAD4\ndim()=2\nn_nodes()=4\n0  Node id()=590977, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449085) (0/1/449086) (0/2/449087)\n1  Node id()=578621, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/439701) (0/1/439702) (0/2/439703)\n2  Node id()=590980, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449094) (0/1/449095) (0/2/449096)\n3  Node id()=590978, processor_id()=0, Point=(x,y,z)=(  10.232, -1.91367,        0)\nDoFs=(0/0/449088) (0/1/449089) (0/2/449090)\nn_sides()=4\nneighbor(0)=681492\nneighbor(1)=666946\nneighbor(2)=681468\nneighbor(3)=681465\nhmin()=2.98957e-09, hmax()=4.23646e-09\nvolume()=8.97373e-18\nactive()=1, ancestor()=0, subactive()=0, has_children()=0\nparent()=666945\nlevel()=24, p_level()=0\nrefinement_flag()=DO_NOTHING\np_refinement_flag()=DO_NOTHING\nDoFs=(1/0/2501616) (1/1/2501617) (1/2/2501618) (1/3/2501619) (1/4/2501620) (1/5/2501621) (1/6/2501622) (1/7/2501623) (1/8/2501624) (1/9/2501625) (1/10/2501626) (1/11/2501627) (1/12/2501628) (1/13/2501629) (1/14/2501630) (1/15/2501631) (1/16/2501632) (1/17/2501633) (1/18/2501634)\nExiting...\n[0] ../src/fe/fe_map.C, line 1992, compiled Oct  7 2020 at 15:55:59\nOutputting console ...........\nOutlier Variable Residual Norms:\nporepressure: 2.330332e-05\nPostprocessor Values:\n+----------------+----------------+\n| time           | dt             |\n+----------------+----------------+\n:                :                :\n|   2.853117e-02 |   1.000000e-03 |\n|   3.138428e-02 |   1.000000e-03 |\n|   3.452271e-02 |   1.000000e-03 |\n|   3.797498e-02 |   1.000000e-03 |\n|   4.177248e-02 |   1.000000e-03 |\n|   4.594973e-02 |   1.000000e-03 |\n|   5.054470e-02 |   1.000000e-03 |\n|   5.559917e-02 |   1.000000e-03 |\n|   6.115909e-02 |   1.000000e-03 |\n|   6.727500e-02 |   1.000000e-03 |\n|   7.400250e-02 |   1.000000e-03 |\n|   8.140275e-02 |   1.000000e-03 |\n|   8.954302e-02 |   1.000000e-03 |\n|   9.849733e-02 |   1.000000e-03 |\n|   1.000000e-01 |   1.000000e-03 |\n+----------------+----------------+\n                                                         [ 12.52 s]\n\nOutputting exodus ........................................................................\n............................                                                               [101.15 s]\nAdaptivity step 1 of 1 ...........Assertion `flags_were_consistent' failed.\nAssertion `flags_were_consistent' failed.\nAssertion `flags_were_consistent' failed.\nAssertion `flags_were_consistent' failed.\n[[2] ../src/mesh/mesh_refinement.C, line 536, compiled Oct  7 2020 at [3] ../src/mesh/mesh_refinement.C, line 536, compiled Oct  7 2020 at 15:56:30\n0] ../src/mesh/mesh_refinement.C, line 536, compiled Oct  7 2020 at 15:56:30\n[1] ../src/mesh/mesh_refinement.C, line 536, compiled Oct  7 2020 at 15:56:30\n15:56:30\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 2\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 1\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 3\nThanks in advance!\nMonika",
          "url": "https://github.com/idaholab/moose/discussions/16120",
          "updatedAt": "2022-06-11T11:43:41Z",
          "publishedAt": "2020-11-09T09:09:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@fdkong or @roystgnr Can you offer some advice on this question?",
                  "url": "https://github.com/idaholab/moose/discussions/16120#discussioncomment-125747",
                  "updatedAt": "2022-06-11T11:43:56Z",
                  "publishedAt": "2020-11-10T15:09:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "roystgnr"
                  },
                  "bodyText": "The fe_map.C warnings are coming from inverse_map.  Typically that means a badly twisted element where the mapping Jacobian goes singular, but we do have an outstanding issue with pyramids that can be triggered near their apex vertex: libMesh/libmesh#2749\nThe flags_were_consistent failure means that there's an element which has one refinement flag on one processor but a different refinement (or lack-of-refinement) flag on another processor.  If you're using a libMesh flagging routine then this is probably a bug in libMesh.  If you're using a homebrewed flagging routine that you're certain is correct on local elements, you can call MeshRefinement::make_flags_parallel_consistent() to sync your flags onto ghost elements.",
                  "url": "https://github.com/idaholab/moose/discussions/16120#discussioncomment-126003",
                  "updatedAt": "2022-06-11T11:43:57Z",
                  "publishedAt": "2020-11-10T20:23:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "MeshRefinement::make_flags_parallel_consistent()  is called only when distributed mesh is used. For replicated mesh, do we need that? For replicated mesh, we mark flags for all elements redundantly in parallel. That could generate inconsistency?\nIt might be a good idea to fix the first issue (inverted elements) before we dig into the second one.",
                  "url": "https://github.com/idaholab/moose/discussions/16120#discussioncomment-126012",
                  "updatedAt": "2022-06-11T11:43:57Z",
                  "publishedAt": "2020-11-10T20:35:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "For replicated mesh, do we need that?\n\nWhether you need make_flags_parallel_consistent() is completely independent of whether your mesh is replicated or not.  You could write flags only to the local portion of a replicated mesh, and so then need make_flags_parallel_consistent() to sync the ghost flags.  Or you could use a parallel-consistent algorithm to write flags to local and ghost flags of a distributed mesh, after which no further sync would be required.\n\nFor replicated mesh, we mark flags for all elements redundantly in parallel. That could generate inconsistency?\n\nIt depends on how you mark flags.  Elem::set_refinement_flag() doesn't do any parallel communication; if you call it with one flag on one processor and another flag on a different processor, we can't stop you; we can't even find that out until (in dbg mode) you hit the above failed assert later on.\n\nIt might be a good idea to fix the first issue (inverted elements) before we dig into the second one.\n\nAlways a good heuristic.  In this case, if you're calculating data for flagging purposes based on local copies of element geometry, and the geometry is differing from processor to processor, then fix the geometry and the flagging would fix itself.  If that's not what's going on, well, you probably want to fix the geometry anyways (I just caught an IGA bug last month from an inverse_map warning about 2e-6 error...), so you might as well do that first and then look at the flagging afterwards.",
                          "url": "https://github.com/idaholab/moose/discussions/16120#discussioncomment-126045",
                          "updatedAt": "2022-06-11T11:43:57Z",
                          "publishedAt": "2020-11-10T21:05:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MonikaCarvajal"
                  },
                  "bodyText": "Thanks for the replies. So it looks like comes from a bug... Can you advice on how to proceed?",
                  "url": "https://github.com/idaholab/moose/discussions/16120#discussioncomment-126730",
                  "updatedAt": "2022-06-11T11:44:03Z",
                  "publishedAt": "2020-11-11T09:47:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "You could use ParaView or other visualization tools to look into the mesh after the first time step. Check if there are any invalid elements.",
                          "url": "https://github.com/idaholab/moose/discussions/16120#discussioncomment-127019",
                          "updatedAt": "2022-06-11T11:44:03Z",
                          "publishedAt": "2020-11-11T15:45:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}