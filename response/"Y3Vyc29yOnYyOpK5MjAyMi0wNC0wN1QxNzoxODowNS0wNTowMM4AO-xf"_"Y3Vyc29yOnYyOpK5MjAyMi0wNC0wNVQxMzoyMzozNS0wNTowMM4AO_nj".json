{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNC0wNVQxMzoyMzozNS0wNTowMM4AO_nj"
    },
    "edges": [
      {
        "node": {
          "title": "Trouble building Libmesh on HPC system, VectorSetAction is used but never defined.",
          "author": {
            "login": "TheBEllis"
          },
          "bodyText": "Hi MOOSE team, I am currently having some issues when trying to get MOOSE installed in my local directory of a HPC system. I am able to build PETSC fine, but when it comes to building libmesh I get a huge array of errors, which are shown in the image below.\n\nMy currently loaded modules in my HPC environment are cmake-3.19.4-gcc-5-a7pima, git-2.31.0-gcc-5.4.0, python/3.8, gcc/9, openmpi-3.1.3-gcc-7.2.0 , and in my mooseenvironment script I have these variables exported.\nCC=mpicc\nCXX=mpicxx\nF90=mpif90\nF77=mpif77\nFC=mpif90\nThis may well be question to ask to people on the HPC side of things, but thought I would ask in case it is something you can help with, if there's any more information I can provide to help just let me know.",
          "url": "https://github.com/idaholab/moose/discussions/20733",
          "updatedAt": "2022-07-06T12:58:02Z",
          "publishedAt": "2022-04-07T11:19:09Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDo you have mpich or mvapich available on this machine? We work routinely with those.\nThe openmpi module is consistent with gcc 9 right? What does mpicc --version returns?\nFor future reference we prefer you copy paste text in triple quotes over screenshots.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20733#discussioncomment-2524451",
                  "updatedAt": "2022-07-06T12:58:29Z",
                  "publishedAt": "2022-04-07T14:52:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheBEllis"
                          },
                          "bodyText": "Hi, I believe MPICH is available but only up to 3.2. running mpicc --version returned gcc 7.2.0, I can replace the current module I am running with one that supports gcc 9.2. There are also later gcc versions available, I am currently using the modules I am using just because they are what was recommended.\nI have tried re-running with\n./scripts/update_and_rebuild_libmesh.sh --with-mpi --with-cxx-std=2011\n\nAnd I get slightly further in the build I believe, but get this error instead.\n  CXX      src/numerics/libmesh_opt_la-distributed_vector.lo\nIn file included from ../src/numerics/distributed_vector.C:21:\n./include/libmesh/distributed_vector.h: In member function 'virtual void libMesh::DistributedVector<T>::set(libMesh::numeric_index_type, T)':\n./include/libmesh/distributed_vector.h:580:8: error: 'scoped_lock' is not a member of 'std'\n  580 |   std::scoped_lock lock(this->_numeric_vector_mutex);\n      |        ^~~~~~~~~~~\n./include/libmesh/distributed_vector.h:580:8: note: 'std::scoped_lock' is only available from C++17 onwards\n./include/libmesh/distributed_vector.h: In member function 'virtual void libMesh::DistributedVector<T>::add(libMesh::numeric_index_type, T)':\n./include/libmesh/distributed_vector.h:600:8: error: 'scoped_lock' is not a member of 'std'\n  600 |   std::scoped_lock lock(this->_numeric_vector_mutex);\n      |        ^~~~~~~~~~~\n./include/libmesh/distributed_vector.h:600:8: note: 'std::scoped_lock' is only available from C++17 onwards\nmake[1]: *** [src/numerics/libmesh_opt_la-distributed_vector.lo] Error 1\nmake[1]: Leaving directory `/home/ir-elli2/projects/moose/libmesh/build'\n\n\nWould you recommend trying to build with the mpich module despite it being a bit outdated?",
                          "url": "https://github.com/idaholab/moose/discussions/20733#discussioncomment-2525961",
                          "updatedAt": "2022-07-06T12:58:29Z",
                          "publishedAt": "2022-04-07T18:38:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You need C++17 support so this flag isnt going to work.\nA bit outdated is OK, as long as you meet these requirements\nhttps://mooseframework.inl.gov/getting_started/installation/manual_installation_gcc.html",
                          "url": "https://github.com/idaholab/moose/discussions/20733#discussioncomment-2526176",
                          "updatedAt": "2022-07-06T13:05:29Z",
                          "publishedAt": "2022-04-07T19:20:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "mpicc on a different gcc version than your gcc module is a no-go of course.",
                          "url": "https://github.com/idaholab/moose/discussions/20733#discussioncomment-2526182",
                          "updatedAt": "2022-07-06T13:05:29Z",
                          "publishedAt": "2022-04-07T19:21:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "dyld[28218]: missing symbol called",
          "author": {
            "login": "xchengood"
          },
          "bodyText": "Hi Moose experts,\nI got one error named \"dyld[28218]: missing symbol called\". I am not sure it is caused by my test file or some other reasons. Any ideas to solve it?",
          "url": "https://github.com/idaholab/moose/discussions/20709",
          "updatedAt": "2022-06-29T14:37:29Z",
          "publishedAt": "2022-04-04T22:57:04Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIs this post-reinstalling all your environment?\nDId you make clobberall after re-installing?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20709#discussioncomment-2504836",
                  "updatedAt": "2022-06-29T14:37:25Z",
                  "publishedAt": "2022-04-05T02:45:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @GiudGiud. Yes. I did make clobberall after re-installing. Some programs can be smoothly ran but my test file cannot. Actually, my test file can also be successfully ran before. I do not know why what happened.",
                          "url": "https://github.com/idaholab/moose/discussions/20709#discussioncomment-2508974",
                          "updatedAt": "2022-06-29T14:37:25Z",
                          "publishedAt": "2022-04-05T15:05:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Weird.\nCan you get us a full backtrace, following these instructions:\nAlso, what does ldd <your executable> return ?\nIs this mac or linux btw?\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/20709#discussioncomment-2511461",
                          "updatedAt": "2022-06-29T14:37:25Z",
                          "publishedAt": "2022-04-05T21:38:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @GiudGiud. Sorry. I cannot see those instructions you suggest using to check the backtrace. Could you write one more? Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/20709#discussioncomment-2524445",
                          "updatedAt": "2022-06-29T14:37:25Z",
                          "publishedAt": "2022-04-07T14:51:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "https://mooseframework.inl.gov/application_development/debugging.html",
                          "url": "https://github.com/idaholab/moose/discussions/20709#discussioncomment-2524463",
                          "updatedAt": "2022-06-29T14:37:49Z",
                          "publishedAt": "2022-04-07T14:53:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Test setup and teardown with Python TestHarness",
          "author": {
            "login": "bielsnohr"
          },
          "bodyText": "From my inspection of the documentation about the Python TestHarness and the source itself, it doesn't appear there is an easy way to do any sort of test setup or teardown. In the particular case for the MOOSE app I have developed, I need to copy a file to a specific location before the test and then remove it after the test.\nAny ideas how I might go about this?\nI suspect writing my own Tester might be the answer, but then how to link that into the existing TestHarness framework?",
          "url": "https://github.com/idaholab/moose/discussions/20433",
          "updatedAt": "2022-08-24T23:58:40Z",
          "publishedAt": "2022-03-01T10:07:17Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "milljm"
                  },
                  "bodyText": "You can create several tests which all depend on one another, each doing a special job:\n[Tests]\n  [./testA]\n    type = RunCommand\n    command = \"cp ../foo.i .\"\n  [../]\n  [./testB]\n    type = RunApp\n    input = foo.i\n    prereq = testA\n  [../]\n  [./testC]\n    type = RunCommand\n    command = \"cp foo.e ../\"\n    prereq = testB\n  [../]\n[]\n\nThere are a lot of examples available in moose/test/tests/test_harness which we use as controls/unittests.",
                  "url": "https://github.com/idaholab/moose/discussions/20433#discussioncomment-2273667",
                  "updatedAt": "2022-08-24T23:58:50Z",
                  "publishedAt": "2022-03-01T14:35:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "While this would indeed work, I'm not a huge fan of \"abusing\" the system like this. You can certainly add a custom Tester to the system. If you have your own app, it's just a matter of dropping it into the right directory in your App and our system will automatically pick it up, register it, and let you use it. While setup and tear down is a normal operation, we don't have a lot of need for that in our integration test suite. Note that if you use Gtest for \"component\" level testing, you can create those methods like you'd expect.\nWhat are you trying to do? Can you just soft link those files into the right locations so you don't have to setup and tear down? Maybe we can come up with other ways of solving your problem.",
                          "url": "https://github.com/idaholab/moose/discussions/20433#discussioncomment-2282964",
                          "updatedAt": "2022-08-24T23:58:50Z",
                          "publishedAt": "2022-03-02T19:59:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Specifically this directory:\n<app_dir>/scripts/TestHarness/testers",
                          "url": "https://github.com/idaholab/moose/discussions/20433#discussioncomment-2282990",
                          "updatedAt": "2022-08-24T23:58:53Z",
                          "publishedAt": "2022-03-02T20:03:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bielsnohr"
                          },
                          "bodyText": "Thank you for answering this, and apologies for not coming back to reply. I did go with @milljm 's first suggestion in the end, and it worked for me.\nHowever, I do agree this is a bit of an 'abuse' of the system that should be moved to the more robust solution of writing a bespoke Tester as suggested by @permcody . My use case was a slightly abnormal one: the input file for an externally run program (called from an ExternalProblem class) also functioned as the output file for that external program. So, a simple symlink won't work because the input file will have changed by the end of the test run, making it unsuitable for future use. This is why I needed the proper clone copy.",
                          "url": "https://github.com/idaholab/moose/discussions/20433#discussioncomment-2524112",
                          "updatedAt": "2022-08-24T23:58:53Z",
                          "publishedAt": "2022-04-07T14:07:56Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Deformation results are abnormal",
          "author": {
            "login": "amosaha"
          },
          "bodyText": "I made a thermal expansion model of a fuel, but one of the fuels cannot be deformed. What is the problem?\n\nand this is my input file.\ncchf2.txt",
          "url": "https://github.com/idaholab/moose/discussions/20724",
          "updatedAt": "2022-08-11T03:00:41Z",
          "publishedAt": "2022-04-06T01:18:06Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nWe're going to need to see the mesh as well, I dont see anything wrong in the input file, but maybe the blocks or the surface definitions are wrong.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20724#discussioncomment-2512730",
                  "updatedAt": "2022-08-11T03:00:44Z",
                  "publishedAt": "2022-04-06T03:03:50Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "amosaha"
                          },
                          "bodyText": "I have checked  the mesh many times. Thank you for your help\uff01\ncchf.zip",
                          "url": "https://github.com/idaholab/moose/discussions/20724#discussioncomment-2512745",
                          "updatedAt": "2022-08-11T03:00:46Z",
                          "publishedAt": "2022-04-06T03:09:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "i think your material defintions are wrong?\nFor example the claddings are 1 4 7 but really it should be 1 3 5 ?\nI would just not use the block IDs. Use the block names that way you will be sure to get it right",
                          "url": "https://github.com/idaholab/moose/discussions/20724#discussioncomment-2512869",
                          "updatedAt": "2022-08-11T03:00:46Z",
                          "publishedAt": "2022-04-06T03:45:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "amosaha"
                  },
                  "bodyText": "Unfortunately, after I fixed the problem, it still did not solve the problem.\n\n\n\n\n\n\n\u53d1\u81ea\u6211\u7684iPhone\n\u2026\n------------------ Original ------------------\nFrom: Guillaume Giudicelli ***@***.***&gt;\nDate: Wed,Apr 6,2022 11:45 AM\nTo: idaholab/moose ***@***.***&gt;\nCc: amosaha ***@***.***&gt;, Author ***@***.***&gt;\nSubject: Re: [idaholab/moose] Deformation results are abnormal (Discussion #20724)\n\n\n\n\n\n\ni think your material defintions are wrong?\n For example the claddings are 1 4 7 but really it should be 1 3 5 ?\n\nI would just not use the block IDs. Use the block names that way you will be sure to get it right\n\n\u2014\nReply to this email directly, view it on GitHub, or unsubscribe.\nYou are receiving this because you authored the thread.Message ID: ***@***.***&gt;",
                  "url": "https://github.com/idaholab/moose/discussions/20724#discussioncomment-2513375",
                  "updatedAt": "2022-08-11T03:00:50Z",
                  "publishedAt": "2022-04-06T06:11:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Can you have the updated input file here?",
                          "url": "https://github.com/idaholab/moose/discussions/20724#discussioncomment-2516961",
                          "updatedAt": "2022-08-11T03:00:53Z",
                          "publishedAt": "2022-04-06T15:17:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "amosaha"
                          },
                          "bodyText": "Input file is here. I think there may be some problems when moose calculates the deformation of multiple objects\ncchfupdata.txt\n.",
                          "url": "https://github.com/idaholab/moose/discussions/20724#discussioncomment-2519973",
                          "updatedAt": "2022-08-11T03:00:53Z",
                          "publishedAt": "2022-04-07T00:39:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you have    block = ''2 4 6' instead of     block = '2 4 6'\nin your conduction material\ncan you please check if that is the problem?",
                          "url": "https://github.com/idaholab/moose/discussions/20724#discussioncomment-2520697",
                          "updatedAt": "2022-08-11T03:00:54Z",
                          "publishedAt": "2022-04-07T04:14:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Lagrange multiplier constraint",
          "author": {
            "login": "KhaledNabilSharafeldin"
          },
          "bodyText": "Hello,\nI am currently using LinearNodalConstraint to apply   constraints.\nThere are two formulation types, penalty and kinematic. the kinematic implementation seem to produce the intended result, however, as the mesh gets finer, the convergence fails most of the time for a simple elastic test.\nThe way that these constraints are set up is by forming a constraint for each node pair+independent node.\nso my question is:\n\nDo you have any suggestion of why would the convergence become very slow/fails with the kinematic formulation\nif I were to implement this constraint using LM, what are your suggestions for doing so in MOOSE. I did see NodalEqualValueConstraint and it seems to do this using LM. is there a way to extend this function for my purposes?\n\nThanks in advance!",
          "url": "https://github.com/idaholab/moose/discussions/20648",
          "updatedAt": "2022-07-05T06:12:09Z",
          "publishedAt": "2022-03-27T19:08:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "KhaledNabilSharafeldin"
                  },
                  "bodyText": "I am a bit confused on how the residual is computed in NodalEqualValueConstraint\nso basically, we get the residual for the LM variable, and define it as\n\n  \n    \n      moose/framework/src/kernels/NodalEqualValueConstraint.C\n    \n    \n        Lines 34 to 43\n      in\n      40ea18c\n    \n  \n  \n    \n\n        \n          \n           void \n        \n\n        \n          \n           NodalEqualValueConstraint::computeResidual() \n        \n\n        \n          \n           { \n        \n\n        \n          \n             prepareVectorTag(_assembly, _var.number()); \n        \n\n        \n          \n            \n        \n\n        \n          \n             for (unsigned int k = 0; k < _value.size(); k++) \n        \n\n        \n          \n               _local_re(k) = (*_value[k])[0] - (*_value[k])[1]; \n        \n\n        \n          \n            \n        \n\n        \n          \n             assignTaggedLocalResidual(); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nnow the _value holds the constrained variable value, the way it is indexed in that for loop doesn't make sense to me.\nshouldnt it be  (*_value[0])[0] - (*_value[1])[0] since it's a nodal variable and only the first index that holds the variable values?\nalso, the value changes every time the the loop itterates, so not sure how does this work.\nthanks again in advance!",
                  "url": "https://github.com/idaholab/moose/discussions/20648#discussioncomment-2457618",
                  "updatedAt": "2022-06-02T07:03:42Z",
                  "publishedAt": "2022-03-29T02:29:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "any suggestions on applying Nodal LM constraints in 3D would be greatly appreciated, I can see it's been used extensively in the contact module. but it's more general approach than what I need it to be since my problem is more straightforward than that.\nI'm currently messing with NodalEqualValueConstraint along with OneDEqualValueConstraintBC. But I am not entirely sure on the role of OneDEqualValueConstraintBC in the process and how to adapt it for my purposes.\nthanks again!",
                          "url": "https://github.com/idaholab/moose/discussions/20648#discussioncomment-2479075",
                          "updatedAt": "2022-06-02T07:01:55Z",
                          "publishedAt": "2022-03-31T15:01:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@lindsayad",
                          "url": "https://github.com/idaholab/moose/discussions/20648#discussioncomment-2479594",
                          "updatedAt": "2022-06-02T07:01:55Z",
                          "publishedAt": "2022-03-31T16:04:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Can you explain more what\n\nmeans? I take L to mean \"left\" and R to mean \"right\", but I don't know what \"1\" denotes",
                          "url": "https://github.com/idaholab/moose/discussions/20648#discussioncomment-2480220",
                          "updatedAt": "2022-06-02T07:01:55Z",
                          "publishedAt": "2022-03-31T17:28:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "*      E_________H\n   *      /|       /|\n   *    F/_______G/ |     the x node pairs correspond to the {AB,HG} edge pairs\n   *     | |     |  |     the y node pairs correspond to the {AD,FG} edge pairs\n   *     |A|_____|__|D    the z node pairs correspond to the {AE,CG} edge pairs\n   *     |/      | /\n   *    B|_______|/C\n   *\n   * B->1, D->2, E->4\n\n would be one of the corner nodes in the mesh, and it would be defined using a FunctionDirichletBC.\nso basically for the equation above,  would correspond to one of the nodes on the face, and  is the \"paired\" node to it.\nThe LHS of the equation can be treated as a secondary variable that can vary to satisfy the primary RHS.",
                          "url": "https://github.com/idaholab/moose/discussions/20648#discussioncomment-2480268",
                          "updatedAt": "2022-06-02T07:03:22Z",
                          "publishedAt": "2022-03-31T17:36:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "@lindsayad let me know if I should go over more details of what I am trying to do.",
                          "url": "https://github.com/idaholab/moose/discussions/20648#discussioncomment-2494924",
                          "updatedAt": "2022-06-02T07:03:22Z",
                          "publishedAt": "2022-04-03T13:52:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "What physics is this? I've never seen something like this before. NodalEqualValueConstraint relies on a global (scalar) variable for the Lagrange Multiplier, however, I would imagine that you want to apply your constraint for multiple node pairs, so you would want your LM variable to be a field, not a global scalar. However, I can't visualize geometrically where the Lagrange multiplier degrees of freedom should live.",
                          "url": "https://github.com/idaholab/moose/discussions/20648#discussioncomment-2502454",
                          "updatedAt": "2022-06-02T07:03:22Z",
                          "publishedAt": "2022-04-04T17:48:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "I am trying to impose this type of constraint mentioned in section 4.5.1 to form homogenous RVE from micro to macro scale.\nif there is a way to impose this constraint using direct elimination that would be much better solution, but I imagined that LM method might be easier.\nso for example here, one of the equations used is the  which apply to faces of the cube. by prescribing this relation the micro fluctuations in displacement should be equal to zero at the boundaries\nthere exists also similar equations for the corner nodes and the cube edges\nexample corner: \nexample edge:",
                          "url": "https://github.com/idaholab/moose/discussions/20648#discussioncomment-2502695",
                          "updatedAt": "2022-06-02T07:03:30Z",
                          "publishedAt": "2022-04-04T18:26:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@dschwen are you familiar with this kind of thing?",
                          "url": "https://github.com/idaholab/moose/discussions/20648#discussioncomment-2503316",
                          "updatedAt": "2022-06-02T07:03:32Z",
                          "publishedAt": "2022-04-04T20:13:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "KhaledNabilSharafeldin"
                          },
                          "bodyText": "I would imagine that you want to apply your constraint for multiple node pairs, so you would want your LM variable to be a field\n\nI guess I did a similar thing, where i created a global scalar for each constraint equation at each node (which is a lot of variables, but I am trying to resolve this ASAP) but I couldn't figure out what to do to adapt the OneDEqualValueConstraintBC for my use.\nthis is the input file\n\n  \n    \n      moose/test/tests/mortar/1d/1d.i\n    \n    \n        Lines 50 to 66\n      in\n      f18a0bf\n    \n  \n  \n    \n\n        \n          \n             [./evc1] \n        \n\n        \n          \n               type = OneDEqualValueConstraintBC \n        \n\n        \n          \n               variable = u \n        \n\n        \n          \n               boundary = '100' \n        \n\n        \n          \n               lambda = lm \n        \n\n        \n          \n               component = 0 \n        \n\n        \n          \n               vg = 1 \n        \n\n        \n          \n             [../] \n        \n\n        \n          \n            \n        \n\n        \n          \n             [./evc2] \n        \n\n        \n          \n               type = OneDEqualValueConstraintBC \n        \n\n        \n          \n               variable = u \n        \n\n        \n          \n               boundary = '101' \n        \n\n        \n          \n               lambda = lm \n        \n\n        \n          \n               component = 0 \n        \n\n        \n          \n               vg = -1 \n        \n\n        \n          \n             [../]",
                          "url": "https://github.com/idaholab/moose/discussions/20648#discussioncomment-2513968",
                          "updatedAt": "2022-06-02T07:03:32Z",
                          "publishedAt": "2022-04-06T07:59:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "In multiple dimensions, that IntegratedBC is not going to do what you want (it seems). I think what you'll want to do to continue with your methodology of multiple SCALAR lagrange multipliers is to use something similar to NodalEqualValueConstraint (modified to do your uL = uR + u1 physics) as the object that defines the Lagrange multiplier constraint residual, and then use CoupledForceNodalKernel to apply the Lagrange Multiplier to the primal variable u. CoupledForceNodalKernel is a NodalKernel which can be either block or boundary restricted. You will want to boundary restrict, and the \"boundary\" (nodeset) will correspond to the nodes that you are trying to constrain",
                          "url": "https://github.com/idaholab/moose/discussions/20648#discussioncomment-2516998",
                          "updatedAt": "2022-06-02T07:03:33Z",
                          "publishedAt": "2022-04-06T15:22:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error while compiling GriddedData.C after MOOSE Update",
          "author": {
            "login": "Flolaffel"
          },
          "bodyText": "Hello,\nI just updated MOOSE and got the following errors while compiling\nCompiling C++ (in opt mode) /home/florian/projects/moose/framework/src/utils/GriddedData.C...\n[In file included from /home/florian/projects/moose/framework/build/header_symlinks/GriddedData.h:14,]\n                 from /home/florian/projects/moose/framework/src/utils/GriddedData.C:10:\n/home/florian/projects/moose/framework/build/header_symlinks/MooseUtils.h: In instantiation of 'class MooseUtils::SemidynamicVector<unsigned int, 4>':\n/home/florian/projects/moose/framework/src/utils/GriddedData.C:94:10:   required from here\n/home/florian/projects/moose/framework/build/header_symlinks/MooseUtils.h:1006:7: error: 'std::array<unsigned int, 4> MetaPhysicL::DynamicStdArrayWrapper<unsigned int, MetaPhysicL::NWrapper<4> >::_data' is private within this context\n 1006 | class SemidynamicVector : public MetaPhysicL::DynamicStdArrayWrapper<T, MetaPhysicL::NWrapper<N>>\n      |       ^~~~~~~~~~~~~~~~~\nIn file included from /home/florian/miniconda3/envs/moose/libmesh/include/metaphysicl/semidynamicsparsenumberarray_decl.h:28,\n                 from /home/florian/miniconda3/envs/moose/libmesh/include/metaphysicl/dualsemidynamicsparsenumberarray_decl.h:28,\n                 from /home/florian/miniconda3/envs/moose/libmesh/include/metaphysicl/dualsemidynamicsparsenumberarray.h:31,\n                 from /home/florian/projects/moose/framework/build/header_symlinks/SparseOps.h:13,\n                 from /home/florian/projects/moose/framework/build/header_symlinks/DualRealOps.h:16,\n                 from /home/florian/projects/moose/framework/build/header_symlinks/ADReal.h:13,\n                 from /home/florian/projects/moose/framework/build/header_symlinks/MooseTypes.h:13,\n                 from /home/florian/projects/moose/framework/build/header_symlinks/GriddedData.h:12,\n                 from /home/florian/projects/moose/framework/src/utils/GriddedData.C:10:\n/home/florian/miniconda3/envs/moose/libmesh/include/metaphysicl/dynamic_std_array_wrapper.h:148:20: note: declared private here\n  148 |   std::array<T, N> _data;\n      |                    ^~~~~\nIn file included from /home/florian/projects/moose/framework/build/header_symlinks/GriddedData.h:14,\n                 from /home/florian/projects/moose/framework/src/utils/GriddedData.C:10:\n/home/florian/projects/moose/framework/build/header_symlinks/MooseUtils.h:1006:7: error: 'std::size_t MetaPhysicL::DynamicStdArrayWrapper<unsigned int, MetaPhysicL::NWrapper<4> >::_dynamic_n' is private within this context\n 1006 | class SemidynamicVector : public MetaPhysicL::DynamicStdArrayWrapper<T, MetaPhysicL::NWrapper<N>>\n      |       ^~~~~~~~~~~~~~~~~\nIn file included from /home/florian/miniconda3/envs/moose/libmesh/include/metaphysicl/semidynamicsparsenumberarray_decl.h:28,\n                 from /home/florian/miniconda3/envs/moose/libmesh/include/metaphysicl/dualsemidynamicsparsenumberarray_decl.h:28,\n                 from /home/florian/miniconda3/envs/moose/libmesh/include/metaphysicl/dualsemidynamicsparsenumberarray.h:31,\n                 from /home/florian/projects/moose/framework/build/header_symlinks/SparseOps.h:13,\n                 from /home/florian/projects/moose/framework/build/header_symlinks/DualRealOps.h:16,\n                 from /home/florian/projects/moose/framework/build/header_symlinks/ADReal.h:13,\n                 from /home/florian/projects/moose/framework/build/header_symlinks/MooseTypes.h:13,\n                 from /home/florian/projects/moose/framework/build/header_symlinks/GriddedData.h:12,\n                 from /home/florian/projects/moose/framework/src/utils/GriddedData.C:10:\n/home/florian/miniconda3/envs/moose/libmesh/include/metaphysicl/dynamic_std_array_wrapper.h:149:15: note: declared private here\n  149 |   std::size_t _dynamic_n = 0;\n      |               ^~~~~~~~~~\nCompiling C++ (in opt mode) /home/florian/projects/moose/framework/src/utils/SerializerGuard.C...\nmake: *** [/home/florian/projects/moose/framework/build.mk:144: /home/florian/projects/moose/framework/src/utils/GriddedData.x86_64-conda-linux-gnu.opt.lo] Error 1\nmake: *** Waiting for unfinished jobs....\n\nWhat could the problem be?",
          "url": "https://github.com/idaholab/moose/discussions/20727",
          "updatedAt": "2022-10-03T19:00:28Z",
          "publishedAt": "2022-04-06T15:20:22Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid you update libmesh?\nYou re getting errors with libmesh data structures that have changed.\nmamba update --all should do it\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20727#discussioncomment-2517128",
                  "updatedAt": "2022-10-03T19:00:29Z",
                  "publishedAt": "2022-04-06T15:38:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Flolaffel"
                          },
                          "bodyText": "Yeah, I just saw the announcement. Thanks for the fast answer!",
                          "url": "https://github.com/idaholab/moose/discussions/20727#discussioncomment-2517138",
                          "updatedAt": "2022-10-03T19:00:29Z",
                          "publishedAt": "2022-04-06T15:40:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Smoothed-Finite Element",
          "author": {
            "login": "Rahim-Habibi"
          },
          "bodyText": "Hi dear MOOSE experts and users,\nI am simulating a large scale geomechanical model including fault. In order to avoid sharp change of the material properties near the fault, I decided to apply phase-field approach for properly modeling. But, as you probably guess, by doing so  much time is needed for convergence. Then, I just found Smoothed Finite Element, which is more or less different in creating shape function in respect to standard FEM implemented in MOOSE, but it has higher convergence rate.\nNow, I wondering to know, is there any way to control the shape functions. Since, based on the formulation of the Smoothed FEM, after obtaining the displacement using standard FEM, smoothing process is being performed on elements resulting a smooth matrix. So, I want to know whether it is possible to perform smoothing process in MOOSE.\nThank you in advance",
          "url": "https://github.com/idaholab/moose/discussions/20725",
          "updatedAt": "2022-12-01T01:47:05Z",
          "publishedAt": "2022-04-06T12:09:48Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe shape functions are provided by our underlying finite element library, libmesh. So I'd encourage you to ask this on their github.\nhttps://github.com/libMesh/libmesh/discussions\nAre you looking to develop this feature?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20725#discussioncomment-2517076",
                  "updatedAt": "2023-01-17T16:07:37Z",
                  "publishedAt": "2022-04-06T15:29:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Checkpoint system does not work with an explicit solver",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Trying to use --recover with an explicit calculation leads to the following error\n[2]PETSC ERROR: --------------------- Error Message --------------------------------------------------------------\n[2]PETSC ERROR: Object is in the wrong state\n[2]PETSC ERROR: Matrix is missing diagonal entry 0\n[2]PETSC ERROR: See https://petsc.org/release/faq/ for trouble shooting.\n[2]PETSC ERROR: Petsc Release Version 3.16.5, unknown\n\nI have been using the checkpoint system without issue for the same simulation but with an implicit time integrator.\nHere is my executioner block\n[Executioner]\n  type = Transient\n  end_time = 9e-5\n  dt = 8e-10\n  solve_type = LINEAR\n  dtmin = 1e-20\n\n  [TimeIntegrator]\n    type = CentralDifference\n    use_constant_mass = true\n  []\n[]\n\nI can give more information as needed, but before that I want to check if this is an inherent limitation that I am unaware of.\nThank you in advance",
          "url": "https://github.com/idaholab/moose/discussions/20718",
          "updatedAt": "2022-06-30T02:00:12Z",
          "publishedAt": "2022-04-05T19:45:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nrecover and central difference time integration should work, it's tested by the test suite.\nuse_constant_mass = true might not be supported though\nmight also be the solve_type = LINEAR that is an issue.\nCould you please try to comment these out and report on your findings? (they are optimizations, the code should run without)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20718#discussioncomment-2511323",
                  "updatedAt": "2022-06-30T02:01:02Z",
                  "publishedAt": "2022-04-05T21:13:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Thank you for your answer!\nIt seems that the issue was with use_constant_mass = true\nWithout that option enabled I able to use the checkpoint system",
                          "url": "https://github.com/idaholab/moose/discussions/20718#discussioncomment-2515742",
                          "updatedAt": "2022-06-30T02:01:02Z",
                          "publishedAt": "2022-04-06T12:40:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "great thanks for reporting this. I ll submit an issue and we ll fix this at some point.",
                          "url": "https://github.com/idaholab/moose/discussions/20718#discussioncomment-2516941",
                          "updatedAt": "2022-06-30T02:01:02Z",
                          "publishedAt": "2022-04-06T15:13:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Preconditioner reuse -- speeding up Newton/LU runs by 10x",
          "author": {
            "login": "reverendbedford"
          },
          "bodyText": "For better or worse some of us run apps using a full Newton solve and superlu_dist to solve the linear equations.  Typically in my group here at ANL we run \"medium sized\" jobs like this all the time on workstations.  They might take a few hours to a few days and typically involve up to a couple million dofs.  Anything larger and we move to HPC and use an iterative linear solver preconditioned by hypre.  But running jobs with superlu is much faster, assuming you have enough memory to factor the linearized system of equations.\nWe do a lot of these medium sized problems.  Here's an example -- some RVE type model of a microstructure with a bunch of inclusions providing some strength and we're pulling on it to simulate a flow curve.  I can provide the input file and mesh for those who are curious, but it uses one of the things we have in deer that's not in tensor_mechanics.\n\nIf I run this example problem on 24 ranks (~25000 dofs/rank) with the following solver block it takes about 116 minutes to run 10 time steps.\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -ksp_type'\n  petsc_options_value = 'lu superlu_dist preonly'\n\nIf I run with this solver block, which involves some new options I added over here and needs a hacked version of libmesh, the exact same problem takes 11 minutes.  So it's 10ish times faster.\n  petsc_options_iname = '-pc_type -pc_factor_mat_solver_package -ksp_type'\n  petsc_options_value = 'lu superlu_dist gmres'\n  l_tol = 1e-8\n\n  reuse_preconditioner = true\n  reuse_l_max_its = 50\n\nWhat the new options do is allow NonlinearProblem and the associated libmesh PetscNonlinearSolver to reuse the LU factored Jacobian from previous nonlinear iterations and even previous timesteps as the preconditioner for GMRES to continue to solve the current linearized system of equations.  The heuristic is you just keep reusing your LU decomposition until the number of GMRES iterations exceeds some number -- here 50.  At that point you just refactor the system, do your GMRES (which is just iterative refinement during this first nonlinear iteration), and then keep using that new LU decomposition as a preconditioner for awhile.\nThis is definitely a heuristic but in my experience it works very, very well because really the structure of the nonlinear equations isn't changing all that much between iterations and changes only very slowly across timesteps.  In this problem with reuse we only factor the linear system only 1 time, versus 30 times for the \"base\" set.  And I'm not the only one to have noticed how well this works: the Intel PARDISO folks have been using it for 8 years or so and it's supported in PETSc via SNESSetLagPreconditionerPersists and SNESSetLagPreconditioner, which are of course how I implemented it in the branch.\nReconfiguring things to allow preconditioner reuse within a single time step is easy.  Allowing use across multiple time steps requires a change to libmesh because right now it clears the SNES instance in between each time step.  I started a discussion over in libmesh on changing this behavior, my preliminary tests suggest it's not that hard and doesn't seem to cause any memory issues.\nSo all that said:\n\nWould anyone else find this useful?\nDoes anyone more informed than me foresee problems in not releasing the SNES instance between time steps?  If we go ahead I'll make the old \"release after every nonlinear solve\" behavior the default, but it would be good to know if MOOSE (or libmesh) somehow relies on this behavior to ensure cross-compatibility with arbitrary apps wanting to use this heuristic.",
          "url": "https://github.com/idaholab/moose/discussions/20627",
          "updatedAt": "2022-06-13T14:09:47Z",
          "publishedAt": "2022-03-23T13:23:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "I'm interested. We use Newton/LU for Navier Stokes too currently (we will have a segregated solver soon though). But the problem is pretty non-linear so no guarantees reusing preconditioners would work.",
                  "url": "https://github.com/idaholab/moose/discussions/20627#discussioncomment-2423475",
                  "updatedAt": "2022-06-14T16:58:01Z",
                  "publishedAt": "2022-03-23T15:13:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "This would be very useful. Also, defaults could be set on a per-app basis, so that shouldn't create any compatibility issue moving forward -- we could keep the current moose behavior as the default and let apps opt in using this new capability by chaging their default.",
                  "url": "https://github.com/idaholab/moose/discussions/20627#discussioncomment-2426049",
                  "updatedAt": "2022-06-14T16:58:16Z",
                  "publishedAt": "2022-03-23T21:59:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "reverendbedford"
                  },
                  "bodyText": "For those who are interested you can play with this branch.  Note that it points to a fork of libmesh here.  There is a PR open on libmesh to get my changes in over there, then I can make a proper PR on MOOSE.\nThe solver parameters to play with are\n  reuse_preconditioner = true\n  reuse_preconditioner_max_its = 30\n\nand you'll want to use that with something like\n  petsc_options_iname = '-ksp_type -pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'gmres lu superlu_dist'",
                  "url": "https://github.com/idaholab/moose/discussions/20627#discussioncomment-2440374",
                  "updatedAt": "2022-06-14T16:58:23Z",
                  "publishedAt": "2022-03-25T20:43:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "reverendbedford"
                          },
                          "bodyText": "I should add I'm curious how it will work for other physics outside of tensor_mechanics.",
                          "url": "https://github.com/idaholab/moose/discussions/20627#discussioncomment-2440407",
                          "updatedAt": "2022-06-14T16:58:24Z",
                          "publishedAt": "2022-03-25T20:51:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "bwspenc"
                  },
                  "bodyText": "Agreed that this is useful, and a 10x speedup definitely warrants develping this! Our group also runs in this mode (moderate sized problems with superlu) quite a bit, and I've often wondered how much time we could save by reusing the preconditioner. It seems like this might be even more helpful if you're using PJFNK rather than Newton because in that case, you can often get more mileage with a less-than-perfect preconditioner than you would with Newton.\nI guess it depends on the problem, but I can see the benefit of allowing to reuse the preconditioner between steps. I can't think of anything offhand that would be an issue there, other than the fact that the problem might change and the preconditioner might not be that great. In particular, we often use damage models in which we lag the damage by one step, and I imagine the performance would be hampered considerably by that. I'd just add separate options that control whether to reuse the preconditioner between steps or within the current step only.",
                  "url": "https://github.com/idaholab/moose/discussions/20627#discussioncomment-2476227",
                  "updatedAt": "2022-06-14T16:58:25Z",
                  "publishedAt": "2022-03-31T08:00:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "@reverendbedford thanks for sharing!\nI find it slower compared to hypre for my problem:\nPorousflow, highly heterogenous, have many faults (discontinuity), a massive model (6 million elements), complex surface drainage setup.\nhypre would take 15 mins for 1 steady-step to converge on my workstation, but reuse_preconditioner wouldn't converge after 30 mins:\n\nhere is my setup for hypre:\n[Executioner]\n  type = Steady\n  solve_type = NEWTON\n  petsc_options = '-snes_converged_reason'\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre    boomeramg'\n\n  nl_rel_tol = 1e-15\n  l_tol = 1e-06\n  l_max_its = 150\n  nl_max_its = 50\n[]\n\nmaybe I didn't setup reuse_preconditioner correctly\nKind regards,\nTraiwit",
                  "url": "https://github.com/idaholab/moose/discussions/20627#discussioncomment-2496818",
                  "updatedAt": "2022-06-14T16:58:29Z",
                  "publishedAt": "2022-04-04T01:20:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "reverendbedford"
                          },
                          "bodyText": "You need to run a transient problem to see if it helps or not (or have a steady problem with a huge number of nonlinear iterations).  It reuses the preconditioner across times steps, which is why I was able to get such good speedup.",
                          "url": "https://github.com/idaholab/moose/discussions/20627#discussioncomment-2512229",
                          "updatedAt": "2022-06-16T21:13:37Z",
                          "publishedAt": "2022-04-06T00:57:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "I see, noted, I will give it a go with pit backfill + reflooding problem, and get back to you soon\nthank you @reverendbedford",
                          "url": "https://github.com/idaholab/moose/discussions/20627#discussioncomment-2512242",
                          "updatedAt": "2022-06-16T21:13:37Z",
                          "publishedAt": "2022-04-06T01:00:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "reverendbedford"
                          },
                          "bodyText": "Also: I don't know your problems but\n  nl_rel_tol = 1e-15\n\nseems a bit much.  It might have trouble solving the linearized systems in a reasonable amount of iterations when you're trying to converge things down that fine.  But maybe it would be okay as long as you are comparing everything at the same tolerances?\nCould you try something like:\n  petsc_options_iname = '-ksp_type -pc_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'gmres lu superlu_dist'\n\n  nl_rel_tol = 1e-8\n  l_tol = 1e-5\n  l_max_its = 50\n  nl_max_its = 50\n\n  reuse_preconditioner = true\n  reuse_preconditioner_max_its = 30\n\nand see if that works for you?\nBy the way, there's nothing to stop you from using this with hypre.  In your example above you could also just do\n[Executioner]\n  type = Steady\n  solve_type = NEWTON\n  petsc_options = '-snes_converged_reason'\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre    boomeramg'\n\n  nl_rel_tol = 1e-15\n  l_tol = 1e-06\n  l_max_its = 150\n  nl_max_its = 50\n\n  reuse_preconditioner = true\n  reuse_preconditioner_max_its = 100\n[]\n\nand see what happens.",
                          "url": "https://github.com/idaholab/moose/discussions/20627#discussioncomment-2512261",
                          "updatedAt": "2022-06-16T21:13:38Z",
                          "publishedAt": "2022-04-06T01:06:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "\u201cOpen\u201d Boundary Condition for Species Fluxes?",
          "author": null,
          "bodyText": "My goal is to have a defined flux of species and associated energy coming into a chamber, reacting inside, and then leaving freely through an outlet on the other end. Setting a FunctionNeumann on the inlet and proper BCs where there is a solid surface is easy enough, but the \"open\" boundary at the outlet appears to be much trickier.\nThe system I'm simulating primarily uses the application Zapdos/Crane, but I was wondering if there exists a BC in the basic MOOSE framework or in one of its modules that computes the values of a given variable on the boundary to be the same values in the elements/points adjacent to it, or perhaps something similar to this to effectively \"open\" the boundary?\nEdit: I came across \"PorousFlowOutflowBC\" which seems to do exactly what I want from the description of it, but I've never used this module before and I'm unsure of what I would need to add to my simulation to make it work, if anything. \"ChemicalOutFlowBC\" also seems like an option, but I'm confused about the porosity term.\nThank you!",
          "url": "https://github.com/idaholab/moose/discussions/20533",
          "updatedAt": "2022-05-15T15:57:27Z",
          "publishedAt": "2022-03-11T12:59:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIs this a flow simulation? If so then you could set a pressure boundary condition for an outlet.\nIs there an advective component and/or a diffusive component?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20533#discussioncomment-2340185",
                  "updatedAt": "2022-03-11T17:26:27Z",
                  "publishedAt": "2022-03-11T16:02:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": null,
                          "bodyText": "Well, it's a weird mix because I'm simulating the plasma using Zapdos/Crane on top of a background flow from INS. I ran a simple INS input file with a defined velocity at the inlet, no slip everywhere else, and left the outlet undefined and it produced a velocity field as expected. I used this INS exodus file as the mesh for my plasma simulation, and I have a kernel that couples my plasma species to the flow field for a \"convection\" (not sure if thats the correct term; just going off what the kernel is called). My thought process for this is that the background gas is much higher in density than the plasma species, so any plasma interactions have very little effect on the flow field. The plasma species indeed experience diffusion and advection from the electric fields. (I'm unsure if this advection is the same as what you're thinking; It seems advection & convection are often used interchangeably and mean different things in different contexts.)\nI hope this helped clarify!",
                          "url": "https://github.com/idaholab/moose/discussions/20533#discussioncomment-2340772",
                          "updatedAt": "2022-03-11T17:33:46Z",
                          "publishedAt": "2022-03-11T17:33:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So a BC with values at the boundary being the same as values on the element would be 0 normal face gradient or no flux.\nIn flow this is typically a fully developed conditions, where while there is a pressure gradient, the velocity profile does not change when those are reached. In the INS-FE part of the NS module, I think this is https://mooseframework.inl.gov/source/bcs/INSMomentumNoBCBCLaplaceForm.html\nor a Dirichlet boundary condition on pressure.\n@lindsayad knows more about that part of the NS module",
                          "url": "https://github.com/idaholab/moose/discussions/20533#discussioncomment-2505036",
                          "updatedAt": "2022-04-05T03:41:01Z",
                          "publishedAt": "2022-04-05T03:34:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If your advection term is not integrated by parts, then a natural boundary condition (no bc specification at all) will often work well. However, this does implicitly impose a zero-gradient condition as @GiudGiud stated since you are implicitly saying that your diffusive flux is zero. If you want no conditions on the boundary, then you have to code up BCs of the variety that @GiudGiud linked-to. Essentially you will want to write in code-form the surface terms that result when you integrate your weak form by parts. If you are working with Zapdos, I see there are a lot of *DoNothingBC classes that I wrote a very long time ago. I can't guarantee that they still work (they are probably mostly untested) but the concepts in there should be good",
                          "url": "https://github.com/idaholab/moose/discussions/20533#discussioncomment-2510402",
                          "updatedAt": "2022-04-05T18:24:10Z",
                          "publishedAt": "2022-04-05T18:23:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}