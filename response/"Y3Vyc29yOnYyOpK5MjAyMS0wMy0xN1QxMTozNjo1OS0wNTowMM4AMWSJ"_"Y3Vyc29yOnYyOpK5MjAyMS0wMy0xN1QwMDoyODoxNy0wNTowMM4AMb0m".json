{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wMy0xN1QwMDoyODoxNy0wNTowMM4AMb0m"
    },
    "edges": [
      {
        "node": {
          "title": "How to restart a simulation with a new layer of mesh added?",
          "author": {
            "login": "YYang-farm"
          },
          "bodyText": "Dear MOOSE team as well as users:\nI am recently considering a multilayer phase-field simulation in moose. After the simulation of one layer, I want to add a new layer of mesh, then restart the simulation (and I hope the new mesh will be with the same domain label as the old one, meaning no interface between meshes). Could anybody share with me the possible method to achieve this in moose or any alternatives?\nI really appreciate any help you can provide.\nBy the way, I have also tried using SolutionUserObject to map the result of the old layer to a larger mesh (containing two layers) as the IC, which never succeeded since SolutionUserObject kept returning \"Failed to access the data\" for the points located out of the old mesh.",
          "url": "https://github.com/idaholab/moose/discussions/16971",
          "updatedAt": "2022-07-15T18:45:40Z",
          "publishedAt": "2021-02-11T21:44:33Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHas this been solved?\nIf not,\nMaybe have the entire mesh in the initial calculation and block restrict the variables / kernels, and load the initial solution only in the relevant blocks.\nAnother option would be to use (maybe modify) the control system to activate kernels in more and more blocks as the simulation progresses.\nSolutionUserObject and checkpoint restart will struggle with having different meshes. The meshes must be the same in the two simulations\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16971#discussioncomment-494495",
                  "updatedAt": "2022-07-15T18:45:40Z",
                  "publishedAt": "2021-03-17T16:21:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Generalized Maxwell Model - convergence issues and negative Jacobians",
          "author": {
            "login": "s-dunnim"
          },
          "bodyText": "Hi,\nI'm trying to model a compression moulding process, using a GeneralizedMaxwellModel. I'm using a generated mesh for the charge to be moulded, and another pre-made mesh for the inside edge of the mould (see picture). The bottom of the mould (-y) is modelled by a 0 displacement BC, and the top of the mould (+y), which moves downwards to compress the charge, is modelled with a variable disp BC. There is a 0 disp BC along the left face of the charge (-x), to stop it from separating from the inside of the mould (this would be due to friction from the top and bottom of the mould in real life), although the corner is free, allowing it to fill the rounded corner of the mould. The charge has been halved (in the xy plane), and a 0 disp BC applied to the front face (+z), using symmetry to reduce the calculation required. Frictionless contact is enforced between the inner mould surface and the outer charge surfaces.\n\nUnfortunately, the model fails about halfway through, producing multiple negative Jacobian errors and failing to converge. I've tried adaptive time stepping, mesh adaptivity, different contact formulations, turning off contact completely, and different sizes of geometry, none of which fixed the problem (although different configurations did result in the failure occurring at different times).\nDoes anyone know what the problem could be, and what I can do to fix it? Ideally I'd like to get the charge squashing out to fill the mould shape. I've attached the input file, as well as the mould mesh and the .csv used for the mould top height.\nThanks\nCompressionMoulding.i.txt\nMouldMesh.ucd.txt\nMouldTopDisp.csv.txt",
          "url": "https://github.com/idaholab/moose/discussions/17092",
          "updatedAt": "2022-06-27T08:30:59Z",
          "publishedAt": "2021-02-22T16:34:58Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi\nDid you check the mesh for bad displaced/inverted elements before the solver fails?\n@aeslaughter who can I tag to help with this?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17092#discussioncomment-494291",
                  "updatedAt": "2022-06-27T08:31:01Z",
                  "publishedAt": "2021-03-17T15:31:29Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "s-dunnim"
                          },
                          "bodyText": "Hi there, thanks for the reply. Some of the elements were pretty highly deformed and displaced - in the end I came to the conclusion the strain and deformation levels were perhaps more than TensorMechanics is really made for, and I'm investigating other methods to model this in MOOSE instead.",
                          "url": "https://github.com/idaholab/moose/discussions/17092#discussioncomment-494321",
                          "updatedAt": "2022-10-13T18:13:01Z",
                          "publishedAt": "2021-03-17T15:39:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok thanks a lot for letting us know.",
                          "url": "https://github.com/idaholab/moose/discussions/17092#discussioncomment-494411",
                          "updatedAt": "2022-10-13T18:13:01Z",
                          "publishedAt": "2021-03-17T16:00:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Ways to reduce the calculation time",
          "author": {
            "login": "LiuPengPeter"
          },
          "bodyText": "Hello,\nIn my model, the time_scale is 1.0E+9 (from s to ns). The length dt=1000. So 1.0E+6 of steps have to be used to get the result of  200s. So huge!\nWhat's more, the situation won't be better if I change the time_scale and dt. (Larger dt will be adapted to around 1000 finally.)\nIs there any other methods recommended  to reduce the calculation time? Will scaling factor help?\nThank you a lot!\nMy execution is in the following:\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = 'PJFNK'\n  #########PETSC_OPTIONS###################very_important###################\n  petsc_options_iname = '-pc_type -sub_pc_type   -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm       ilu            nonzero'\n  l_max_its = 50\n  l_tol = 1e-4\n  nl_max_its = 20\n  nl_rel_tol = 1e-10\n  nl_abs_tol = 1e-10\n  end_time = 2.00E+11\n[./TimeStepper]\n    type = IterationAdaptiveDT\n    dt = 1.00E+03\n    cutback_factor = 0.8\n    growth_factor = 2.0 \n    optimal_iterations = 7\n [../]\n[]\n[Preconditioning]\n  active = 'full'\n  [./full]\n    type = SMP\n    full = true\n  [../]\n  [./mydebug]\n    type = FDP\n    full = true\n  [../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/16483",
          "updatedAt": "2022-08-26T14:25:24Z",
          "publishedAt": "2020-12-14T11:51:17Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@fdkong Can you help here?",
                  "url": "https://github.com/idaholab/moose/discussions/16483#discussioncomment-205366",
                  "updatedAt": "2022-08-26T14:25:28Z",
                  "publishedAt": "2020-12-14T16:03:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "It is often problem dependent.\n\n\nRun the code in parallel may be able to make the code faster\n\n\nIf the Jacobian matrix is accurate, use solve_typ=newton could speedup a bit\n\n\nIf the number of linear iterations is not small, could increase the fill-in levels -sub_pc_factor_levels 2",
                  "url": "https://github.com/idaholab/moose/discussions/16483#discussioncomment-205567",
                  "updatedAt": "2022-08-26T14:25:29Z",
                  "publishedAt": "2020-12-14T16:56:26Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "LiuPengPeter"
                          },
                          "bodyText": "It runs very quickly, about 5 seconds for one time step.\nI set the end_time =  1.0E+9, (200 s), but after one day only get the result of 1.0E+7. So maybe 100 days are needed...\nThe unit of time is ns (10E-9 s) and the simulation won't converge well if I change it. Why is it so small?\nThank you for your help!\nTime Step 20412, time = 3.48711e+07, dt = 2063.65\n0 Nonlinear |R| = 1.301949e-08\n|residual|_2 of individual variables:\nw:    1.30195e-08\nc:    4.55567e-14\neta1: 9.17821e-19\neta2: 7.08598e-20\neta3: 2.41848e-15\nc1:   5.31692e-13\nc2:   5.29201e-13\nc3:   3.56361e-14\n0 Linear |R| = 1.301949e-08\n1 Linear |R| = 1.301949e-08\n2 Linear |R| = 1.301947e-08\n3 Linear |R| = 1.301946e-08\n4 Linear |R| = 1.301945e-08\n5 Linear |R| = 1.301943e-08\n6 Linear |R| = 1.301939e-08\n7 Linear |R| = 1.301930e-08\n8 Linear |R| = 1.301916e-08\n9 Linear |R| = 1.301889e-08\n10 Linear |R| = 1.301845e-08\n11 Linear |R| = 1.301758e-08\n12 Linear |R| = 1.301579e-08\n13 Linear |R| = 1.301191e-08\n14 Linear |R| = 1.300521e-08\n15 Linear |R| = 1.299228e-08\n16 Linear |R| = 1.297684e-08\n17 Linear |R| = 1.294398e-08\n18 Linear |R| = 1.290817e-08\n19 Linear |R| = 1.283983e-08\n20 Linear |R| = 1.274005e-08\n21 Linear |R| = 1.255210e-08\n22 Linear |R| = 1.225769e-08\n23 Linear |R| = 1.176580e-08\n24 Linear |R| = 1.112838e-08\n25 Linear |R| = 1.033345e-08\n26 Linear |R| = 9.153863e-09\n27 Linear |R| = 8.003364e-09\n28 Linear |R| = 6.622598e-09\n29 Linear |R| = 5.597964e-09\n30 Linear |R| = 8.052611e-09\n31 Linear |R| = 8.052609e-09\n32 Linear |R| = 8.052323e-09\n33 Linear |R| = 8.052207e-09\n34 Linear |R| = 8.052110e-09\n35 Linear |R| = 8.051696e-09\n36 Linear |R| = 8.051194e-09\n37 Linear |R| = 8.049746e-09\n38 Linear |R| = 8.047512e-09\n39 Linear |R| = 8.043057e-09\n40 Linear |R| = 8.036283e-09\n41 Linear |R| = 8.022776e-09\n42 Linear |R| = 7.995286e-09\n43 Linear |R| = 7.937876e-09\n44 Linear |R| = 7.842004e-09\n45 Linear |R| = 7.663963e-09\n46 Linear |R| = 7.471331e-09\n47 Linear |R| = 7.100422e-09\n48 Linear |R| = 6.752856e-09\n49 Linear |R| = 6.194370e-09\n50 Linear |R| = 5.573689e-09\nLinear solve did not converge due to DIVERGED_ITS iterations 50\n1 Nonlinear |R| = 9.034513e-09\n|residual|_2 of individual variables:\nw:    8.13015e-10\nc:    1.20437e-09\neta1: 3.7189e-15\neta2: 6.26328e-18\neta3: 3.23551e-12\nc1:   5.46881e-09\nc2:   5.46157e-09\nc3:   4.44682e-09\n0 Linear |R| = 9.034513e-09\n1 Linear |R| = 9.034496e-09\n2 Linear |R| = 9.033128e-09\n3 Linear |R| = 9.032453e-09\n4 Linear |R| = 9.031768e-09\n5 Linear |R| = 9.030367e-09\n6 Linear |R| = 9.027351e-09\n7 Linear |R| = 9.020515e-09\n8 Linear |R| = 9.010147e-09\n9 Linear |R| = 8.988535e-09\n10 Linear |R| = 8.955818e-09\n11 Linear |R| = 8.893175e-09\n12 Linear |R| = 8.763566e-09\n13 Linear |R| = 8.504297e-09\n14 Linear |R| = 8.103937e-09\n15 Linear |R| = 7.454319e-09\n16 Linear |R| = 6.839006e-09\n17 Linear |R| = 5.880821e-09\n18 Linear |R| = 5.170450e-09\n19 Linear |R| = 4.222539e-09\n20 Linear |R| = 3.376157e-09\n21 Linear |R| = 2.587485e-09\n22 Linear |R| = 1.984959e-09\n23 Linear |R| = 1.508259e-09\n24 Linear |R| = 1.178323e-09\n25 Linear |R| = 9.336882e-10\n26 Linear |R| = 7.058346e-10\n27 Linear |R| = 5.551710e-10\n28 Linear |R| = 4.198611e-10\n29 Linear |R| = 3.374034e-10\n30 Linear |R| = 5.871209e-09\n31 Linear |R| = 5.847506e-09\n32 Linear |R| = 2.595568e-09\n33 Linear |R| = 2.313918e-09\n34 Linear |R| = 2.085521e-09\n35 Linear |R| = 1.767244e-09\n36 Linear |R| = 1.421870e-09\n37 Linear |R| = 1.051410e-09\n38 Linear |R| = 8.035187e-10\n39 Linear |R| = 5.871254e-10\n40 Linear |R| = 4.542527e-10\n41 Linear |R| = 3.245219e-10\n42 Linear |R| = 2.340989e-10\n43 Linear |R| = 1.600106e-10\n44 Linear |R| = 1.141013e-10\n45 Linear |R| = 8.264118e-11\n46 Linear |R| = 6.363237e-11\n47 Linear |R| = 4.606866e-11\n48 Linear |R| = 3.695673e-11\n49 Linear |R| = 3.015359e-11\n50 Linear |R| = 2.427008e-11\nLinear solve did not converge due to DIVERGED_ITS iterations 50\n2 Nonlinear |R| = 4.032112e-10\n|residual|_2 of individual variables:\nw:    3.84205e-12\nc:    2.47542e-11\neta1: 1.08331e-13\neta2: 6.64417e-17\neta3: 1.3091e-12\nc1:   2.84151e-10\nc2:   2.84007e-10\nc3:   2.34102e-11\n0 Linear |R| = 4.032112e-10\n1 Linear |R| = 9.910058e-11\n2 Linear |R| = 2.129399e-11\n3 Linear |R| = 1.666190e-11\n4 Linear |R| = 1.177270e-11\n5 Linear |R| = 8.907619e-12\n6 Linear |R| = 6.862658e-12\n7 Linear |R| = 4.720409e-12\n8 Linear |R| = 3.422265e-12\n9 Linear |R| = 2.714312e-12\n10 Linear |R| = 2.103812e-12\n11 Linear |R| = 1.671415e-12\n12 Linear |R| = 1.394507e-12\n13 Linear |R| = 1.047202e-12\n14 Linear |R| = 8.452052e-13\n15 Linear |R| = 6.944958e-13\n16 Linear |R| = 5.150750e-13\n17 Linear |R| = 4.053526e-13\n18 Linear |R| = 3.429931e-13\n19 Linear |R| = 2.808270e-13\n20 Linear |R| = 2.169458e-13\n21 Linear |R| = 1.632714e-13\n22 Linear |R| = 1.290776e-13\n23 Linear |R| = 9.948311e-14\n24 Linear |R| = 7.628235e-14\n25 Linear |R| = 5.842547e-14\n26 Linear |R| = 4.751091e-14\n27 Linear |R| = 3.907655e-14\nLinear solve converged due to CONVERGED_RTOL iterations 27\n3 Nonlinear |R| = 7.619928e-13\n|residual|_2 of individual variables:\nw:    4.22469e-15\nc:    4.47435e-14\neta1: 1.57013e-16\neta2: 8.84063e-20\neta3: 2.382e-15\nc1:   5.3707e-13\nc2:   5.37337e-13\nc3:   3.78424e-14\nNonlinear solve converged due to CONVERGED_FNORM_ABS iterations 3\nSolve Converged!",
                          "url": "https://github.com/idaholab/moose/discussions/16483#discussioncomment-207647",
                          "updatedAt": "2022-08-26T14:25:33Z",
                          "publishedAt": "2020-12-15T07:42:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "Could the problem have reached a steady state?",
                          "url": "https://github.com/idaholab/moose/discussions/16483#discussioncomment-210194",
                          "updatedAt": "2022-08-26T14:26:40Z",
                          "publishedAt": "2020-12-15T15:49:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "What are the initial residuals  for the first several steps?\nYou could  use \"steady_state_detection=true\" to Executioner block, if the steady state is reached, no nonlinear solver will be involved",
                          "url": "https://github.com/idaholab/moose/discussions/16483#discussioncomment-210843",
                          "updatedAt": "2022-08-26T14:26:40Z",
                          "publishedAt": "2020-12-15T18:47:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "LiuPengPeter"
                          },
                          "bodyText": "The initial residuals for the first several steps are:\nSteady-State Relative Differential Norm:\n0.000996499\n1.3265e-05\n1.33776e-06\n1.02387e-06\n6.08638e-07\n5.03052e-07",
                          "url": "https://github.com/idaholab/moose/discussions/16483#discussioncomment-212067",
                          "updatedAt": "2022-09-28T08:35:50Z",
                          "publishedAt": "2020-12-16T00:27:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "LiuPengPeter"
                  },
                  "bodyText": "Do I need normalization to improve the converge?",
                  "url": "https://github.com/idaholab/moose/discussions/16483#discussioncomment-207715",
                  "updatedAt": "2022-08-26T14:26:40Z",
                  "publishedAt": "2020-12-15T08:17:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You could use scaling. Either manually scale the variables with a scaling = xx in the variable blocks or turn on automatic_scaling = true in the Executioner block",
                          "url": "https://github.com/idaholab/moose/discussions/16483#discussioncomment-494379",
                          "updatedAt": "2022-08-26T14:26:40Z",
                          "publishedAt": "2021-03-17T15:51:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Installing PETSC with MPICH 3.3 and GCC9",
          "author": {
            "login": "jinca"
          },
          "bodyText": "Hello, these are the modules I am using:\n\nslurm                 3) turbovnc/2.0.1        5) singularity/current   7) cmake/latest          9) gcc/9\ndot                   4) vgl/2.5.1/64          6) rhel7/global          8) python/3.8\n\nThen I got this error:\n[ir-inca1@login-e-10 moose]$ cd petsc/\n[ir-inca1@login-e-10 petsc]$ make PETSC_DIR=/home/ir-inca1/projects/moose/scripts/../petsc PETSC_ARCH=arch-moose check\nRunning check examples to verify correct installation\nUsing PETSC_DIR=/home/ir-inca1/projects/moose/scripts/../petsc and PETSC_ARCH=arch-moose\nPossible error running C/C++ src/snes/tutorials/ex19 with 1 MPI process\nSee http://www.mcs.anl.gov/petsc/documentation/faq.html\nsrun: error: Unable to allocate resources: Invalid account or account/partition combination specified\nPossible error running C/C++ src/snes/tutorials/ex19 with 2 MPI processes\nSee http://www.mcs.anl.gov/petsc/documentation/faq.html\nsrun: error: Unable to allocate resources: Invalid account or account/partition combination specified\n1,5c1\n< lid velocity = 0.0016, prandtl # = 1., grashof # = 1.\n<   0 SNES Function norm 0.0406612\n<   1 SNES Function norm 4.12227e-06\n<   2 SNES Function norm 6.098e-11\n< Number of SNES iterations = 2\n\nsrun: error: Unable to allocate resources: Invalid account or account/partition combination specified\n/home/ir-inca1/projects/moose/petsc/src/snes/tutorials\nPossible problem with ex19 running with hypre, diffs above\n=========================================\n1,9c1\n< lid velocity = 0.0625, prandtl # = 1., grashof # = 1.\n<   0 SNES Function norm 0.239155\n<     0 KSP Residual norm 0.235858\n<     1 KSP Residual norm < 1.e-11\n<   1 SNES Function norm 6.81968e-05\n<     0 KSP Residual norm 2.30906e-05\n<     1 KSP Residual norm < 1.e-11\n<   2 SNES Function norm < 1.e-11\n< Number of SNES iterations = 2\n\n\n\nsrun: error: Unable to allocate resources: Invalid account or account/partition combination specified\n/home/ir-inca1/projects/moose/petsc/src/snes/tutorials\nPossible problem with ex19 running with mumps, diffs above\n=========================================\n1,2c1\n< lid velocity = 0.0025, prandtl # = 1., grashof # = 1.\n< Number of SNES iterations = 2\n\n\n\nsrun: error: Unable to allocate resources: Invalid account or account/partition combination specified\n/home/ir-inca1/projects/moose/petsc/src/snes/tutorials\nPossible problem with ex19 running with superlu_dist, diffs above\n=========================================\nCompleted test examples",
          "url": "https://github.com/idaholab/moose/discussions/16542",
          "updatedAt": "2022-11-26T07:49:49Z",
          "publishedAt": "2020-12-18T18:15:45Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "See #16546, issues with srun",
                  "url": "https://github.com/idaholab/moose/discussions/16542#discussioncomment-494357",
                  "updatedAt": "2023-02-14T04:10:26Z",
                  "publishedAt": "2021-03-17T15:48:58Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to define an integral based function as the material properties",
          "author": {
            "login": "sSajjad90"
          },
          "bodyText": "Hi all,\nI will implement a code to calculate microstructure parameters associated with the precipitation and solute growth and then use the computed parameters to evaluate mechanical properties. One of those parameters (a1) is calculated in the attached equation for the given C* at each time step (t). Assume the other parameters ( C, C*beta, D,e12, and e13) are constant.\nI was wondering there is any material class as same as the \"DerivativeParsedMaterial\" function to implement an integral base function (like this) to calculate parameters in the material block? Or I have to define user objects to compute this function? If so, is there any suggestion or example?\nThanks in advanced",
          "url": "https://github.com/idaholab/moose/discussions/16852",
          "updatedAt": "2022-08-22T15:53:12Z",
          "publishedAt": "2021-02-02T15:44:48Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre you looking to parse this function from the input file? I dont know if FParser can parse that. @roystgnr will know more.\nI would recommend computing it in your own material class, and just supply the parameters / variables in the input.\nDepending on what a1 is, you may also be able to define this as a new Function and call it from a FunctionMaterial.\nBut this is only worth the effort if you are using this function in other places.\nBest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16852#discussioncomment-335151",
                  "updatedAt": "2022-08-22T15:53:18Z",
                  "publishedAt": "2021-02-03T15:33:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "It's possible @dschwen has added something (IIRC he was responsible for the differentiation capabilities in our FParser fork) for integrals, but I don't recall seeing anything of the sort.",
                          "url": "https://github.com/idaholab/moose/discussions/16852#discussioncomment-335208",
                          "updatedAt": "2022-08-22T15:53:23Z",
                          "publishedAt": "2021-02-03T15:54:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sSajjad90"
                  },
                  "bodyText": "To explain a bit more...\nIn fact, C* and a1 are unknown material properties that changed over time and are the input parameters for the primary analysis. I will solve C* in a separate function; then, it will be used to compute a1 in the attached equation for each time step and then update it in the next step. My difficulty is to find a relevant function to define this equation (includes an integral).\nI do not know any predefined class function to solve integrals (like \"DerivativeParsedMaterial.\" using for the differentiation of the function expression) to calculate this equation.\nmany thanks,\nSajjad",
                  "url": "https://github.com/idaholab/moose/discussions/16852#discussioncomment-335463",
                  "updatedAt": "2022-08-22T15:53:22Z",
                  "publishedAt": "2021-02-03T17:19:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nDid you solve this?\nI think you may have to add the integration yourself. There are plenty of numerical integration techniques that will compute this integral to your desired accuracy.\nWe would welcome the contribution as a general utility to integrate functions. See framework/src/utils for examples of these utility functions.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/16852#discussioncomment-494350",
                  "updatedAt": "2022-08-22T15:53:34Z",
                  "publishedAt": "2021-03-17T15:47:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "scalar kernel for average of coupled nonlinear variable value",
          "author": {
            "login": "yuegu2013"
          },
          "bodyText": "Hello,\nIs there an existing Scalar kernel that assigns the average (element or nodal) of a coupled nonlinear variable to it?\nThis can be achieved by adding a postprocessor and then assign the postprocessor value to the scalar; however, this misses the off-diagonal jacobian term.\nThis seems to be a common need. I looked through the MOOSE source code, but did not find one. Can you please help point me to the right class, if there is one?\nThanks,\nGuojun",
          "url": "https://github.com/idaholab/moose/discussions/17098",
          "updatedAt": "2022-08-01T06:50:36Z",
          "publishedAt": "2021-02-22T23:31:58Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi\nI dont think so but we would welcome a PR.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17098#discussioncomment-494282",
                  "updatedAt": "2022-08-01T06:50:38Z",
                  "publishedAt": "2021-03-17T15:29:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Executable not running - no error given - RedHat 6.10",
          "author": {
            "login": "ngrilli"
          },
          "bodyText": "Dear MOOSE Users,\nAfter a maintainance break of the NSCC cluster (Singapore) I am having the following problem:\nIt is a RedHat 6.10\nI install MOOSE using the manual procedure, so gcc 9.2.0 and mpich 3.3 compiled successfully,\nthen all the MOOSE installation goes well and MOOSE compiles and links properly.\nWhen I run the executable on an input file:\n./moose_test-opt -i input_file.i\nThe system just gets stuck and nothing happens.\nThe executable never starts and never finishes.\nBecause of this, running ./run_tests leads to timeout errors in all the tests.\nI am repeating the same installation procedure that I was doing two weeks back and MOOSE was working well before.\nAlso, ldd on the executable gives the right linking.\nThe problem is both on the front node and on the computational nodes (PBS system)\nOther executable (for instance: mpiexec -n 2 echo \"hello\") works fine on the terminal.\nAny idea where to start investigating this issue?\nSince I do not get any error message, it's difficult to decide what to try next.\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
          "url": "https://github.com/idaholab/moose/discussions/16579",
          "updatedAt": "2022-10-21T23:56:49Z",
          "publishedAt": "2020-12-23T07:43:24Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "Our primary technician is out until after the new year, so it might take a bit to get the help you need. Did you perform a clean before re-compiling the new version: \"make clobberall\" or better yet \"git clean -fxd\"?",
                  "url": "https://github.com/idaholab/moose/discussions/16579#discussioncomment-237526",
                  "updatedAt": "2022-10-21T23:56:35Z",
                  "publishedAt": "2020-12-23T15:37:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "Dear @aeslaughter\nThank you very much for your suggestions.\nI tried but unfortunately my executable is still stuck and not starting.\nThe only other thing I tried is to compile in debug mode,\nthen I followed the gdb instructions on your website,\nbut also executing with gdb does not give useful information and I paste what I get below.\nIs there any specific breakpoint I should set to understand what is going on?\nI have tried compiling simple hello worlds programs with the same g++ and I can run them.\nHopefully our IT will be able to fix the problem as it appeared after a maintainance break.\n[e0546229@nus04 projects]$ gdb --args ./moose/test/moose_test-dbg -i 3d_bar.i\nGNU gdb (GDB) Red Hat Enterprise Linux (7.2-92.el6)\nCopyright (C) 2010 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later http://gnu.org/licenses/gpl.html\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-redhat-linux-gnu\".\nFor bug reporting instructions, please see:\nhttp://www.gnu.org/software/gdb/bugs/...\nReading symbols from /home/users/nus/e0546229/projects/moose/test/moose_test-dbg...done.\n(gdb) b MPI_Abort\nFunction \"MPI_Abort\" not defined.\nMake breakpoint pending on future shared library load? (y or [n]) y\nBreakpoint 1 (MPI_Abort) pending.\n(gdb) r\nStarting program: /home/users/nus/e0546229/projects/moose/test/moose_test-dbg -i 3d_bar.i\n[Thread debugging using libthread_db enabled]",
                          "url": "https://github.com/idaholab/moose/discussions/16579#discussioncomment-240860",
                          "updatedAt": "2022-10-21T23:56:35Z",
                          "publishedAt": "2020-12-25T03:39:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "@milljm Can you help with this?",
                  "url": "https://github.com/idaholab/moose/discussions/16579#discussioncomment-260293",
                  "updatedAt": "2022-10-21T23:56:39Z",
                  "publishedAt": "2021-01-04T15:38:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Is this still an issue?",
                  "url": "https://github.com/idaholab/moose/discussions/16579#discussioncomment-494214",
                  "updatedAt": "2022-10-21T23:56:39Z",
                  "publishedAt": "2021-03-17T15:17:04Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Action system not working as intended",
          "author": {
            "login": "sahu07"
          },
          "bodyText": "Dear all,\nI wanted to use MOOSE action system to create custom syntax for my problem: ( precipitation growth problem in phase-field using KKS model). I created an action called \"PrecipitateKKS\" which will add the necessary variables for solving the KKS model namely c, w, eta, cs, and cl. But in my case, with and without action, I am getting different results. My solution does not converge when I use action.\nMy input script without using the action (explicity declaring variables):\nkks_example_noflux.i.txt\nMy input script with action:\ntest_action.i.txt\nDo you have any suggestions?\nThanks!\nSarita",
          "url": "https://github.com/idaholab/moose/discussions/17277",
          "updatedAt": "2022-06-02T14:58:51Z",
          "publishedAt": "2021-03-10T18:41:50Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sahu07"
                  },
                  "bodyText": "My output from kks_example_noflux.i.txt (without using action) :\nFramework Information:\nMOOSE Version:           git commit b57161c312 on 2020-10-24\nLibMesh Version:         f33331f6ebb0f31dff7526106268ca0c4300049e\nPETSc Version:           3.13.3\nSLEPc Version:           3.13.3\nCurrent Time:            Wed Mar 10 13:31:36 2021\nExecutable Timestamp:    Wed Mar 10 13:28:38 2021\n\nParallelism:\n  Num Processors:          1\n  Num Threads:             1\n\nMesh:\n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:\n    Total:                 302\n    Local:                 302\n  Elems:\n    Total:                 150\n    Local:                 150\n  Num Subdomains:          1\n  Num Partitions:          1\n\nNonlinear System:\n  Num DOFs:                1510\n  Num Local DOFs:          1510\n  Variables:               { \"eta\" \"c\" \"w\" \"cl\" \"cs\" }\n  Finite Element Types:    \"LAGRANGE\"\n  Approximation Orders:    \"FIRST\"\n\nAuxiliary System:\n  Num DOFs:                150\n  Num Local DOFs:          150\n  Variables:               \"Fglobal\"\n  Finite Element Types:    \"MONOMIAL\"\n  Approximation Orders:    \"CONSTANT\"\n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  Solver Mode:             Preconditioned JFNK\n  MOOSE Preconditioner:    SMP\n\nLEGACY MODES ENABLED:\n This application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate diffs due to zero values being stored, and these tests should be re-golded.\n\n\nTime Step 0, time = 0\n\nTime Step 1, time = 0.1, dt = 0.1\n 0 Nonlinear |R| = 8.087000e-03\n      0 Linear |R| = 8.087000e-03\n      1 Linear |R| = 7.207973e-05\n      2 Linear |R| = 7.672729e-08\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 1 Nonlinear |R| = 6.631482e-05\n      0 Linear |R| = 6.631482e-05\n      1 Linear |R| = 3.320994e-09\n      2 Linear |R| = 4.311615e-12\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 2 Nonlinear |R| = 4.472570e-09\n      0 Linear |R| = 4.472570e-09\n      1 Linear |R| = 1.548033e-14\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 3 Nonlinear |R| = 2.413821e-14\nNonlinear solve converged due to CONVERGED_FNORM_RELATIVE iterations 3\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  w: 2.069201e-14\n\nTime Step 2, time = 0.2, dt = 0.1\n 0 Nonlinear |R| = 2.542850e-02\n      0 Linear |R| = 2.542850e-02\n      1 Linear |R| = 2.381447e-05\n      2 Linear |R| = 2.813298e-08\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 1 Nonlinear |R| = 2.576841e-05\n      0 Linear |R| = 2.576841e-05\n      1 Linear |R| = 7.007496e-11\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 2 Nonlinear |R| = 5.260274e-11\nNonlinear solve converged due to CONVERGED_FNORM_RELATIVE iterations 2\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  w: 5.199483e-11\n\nTime Step 3, time = 0.3, dt = 0.1\n 0 Nonlinear |R| = 1.320623e-02\n      0 Linear |R| = 1.320623e-02\n      1 Linear |R| = 9.670223e-06\n      2 Linear |R| = 1.391580e-08\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 1 Nonlinear |R| = 8.772165e-06\n      0 Linear |R| = 8.772165e-06\n      1 Linear |R| = 2.688458e-11\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 2 Nonlinear |R| = 2.616407e-11\nNonlinear solve converged due to CONVERGED_FNORM_RELATIVE iterations 2\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  w: 2.590734e-11\n\nTime Step 4, time = 0.4, dt = 0.1\n 0 Nonlinear |R| = 8.096215e-03\n      0 Linear |R| = 8.096215e-03\n      1 Linear |R| = 6.143268e-06\n      2 Linear |R| = 1.362328e-08\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 1 Nonlinear |R| = 8.130053e-06\n      0 Linear |R| = 8.130053e-06\n      1 Linear |R| = 1.762284e-11\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 2 Nonlinear |R| = 2.202310e-11\nNonlinear solve converged due to CONVERGED_FNORM_RELATIVE iterations 2\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  w: 2.190078e-11\n\nTime Step 5, time = 0.5, dt = 0.1\n 0 Nonlinear |R| = 5.579708e-03\n      0 Linear |R| = 5.579708e-03\n      1 Linear |R| = 4.738043e-06\n      2 Linear |R| = 8.232030e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 1 Nonlinear |R| = 6.019499e-06\n      0 Linear |R| = 6.019499e-06\n      1 Linear |R| = 2.878569e-11\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 2 Nonlinear |R| = 2.070648e-11\nNonlinear solve converged due to CONVERGED_FNORM_RELATIVE iterations 2\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  w: 2.061760e-11\n\nTime Step 6, time = 0.6, dt = 0.1\n 0 Nonlinear |R| = 4.181643e-03\n      0 Linear |R| = 4.181643e-03\n      1 Linear |R| = 3.425304e-06\n      2 Linear |R| = 6.315085e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 1 Nonlinear |R| = 4.768709e-06\n      0 Linear |R| = 4.768709e-06\n      1 Linear |R| = 2.748674e-11\n  Linear solve converged due to CONVERGED_RTOL iterations 1\n 2 Nonlinear |R| = 2.958004e-11\nNonlinear solve converged due to CONVERGED_FNORM_RELATIVE iterations 2\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  w: 2.935928e-11\n\nTime Step 7, time = 0.7, dt = 0.1\n 0 Nonlinear |R| = 3.330081e-03\n      0 Linear |R| = 3.330081e-03\n      1 Linear |R| = 1.926500e-06\n      2 Linear |R| = 4.362328e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 1 Nonlinear |R| = 2.455853e-06\n      0 Linear |R| = 2.455853e-06\n      1 Linear |R| = 3.612094e-11\n      2 Linear |R| = 4.778077e-14\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 2 Nonlinear |R| = 6.189539e-11\n      0 Linear |R| = 6.189539e-11\n      1 Linear |R| = 7.858545e-16\n      2 Linear |R| = 6.422992e-17\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 3 Nonlinear |R| = 1.178853e-14\nNonlinear solve converged due to CONVERGED_FNORM_RELATIVE iterations 3\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  eta: 1.065176e-14\n\nTime Step 8, time = 0.8, dt = 0.1\n 0 Nonlinear |R| = 2.771103e-03\n      0 Linear |R| = 2.771103e-03\n      1 Linear |R| = 2.252814e-06\n      2 Linear |R| = 3.566844e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 1 Nonlinear |R| = 3.094698e-06\n      0 Linear |R| = 3.094698e-06\n      1 Linear |R| = 4.545581e-11\n      2 Linear |R| = 4.768397e-14\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 2 Nonlinear |R| = 3.363598e-11\n      0 Linear |R| = 3.363598e-11\n      1 Linear |R| = 7.664732e-16\n      2 Linear |R| = 7.144396e-17\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 3 Nonlinear |R| = 1.089912e-14\nNonlinear solve converged due to CONVERGED_FNORM_RELATIVE iterations 3\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  eta: 9.665256e-15\n\nTime Step 9, time = 0.9, dt = 0.1\n 0 Nonlinear |R| = 2.379972e-03\n      0 Linear |R| = 2.379972e-03\n      1 Linear |R| = 1.517193e-06\n      2 Linear |R| = 3.293289e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 1 Nonlinear |R| = 2.729719e-06\n      0 Linear |R| = 2.729719e-06\n      1 Linear |R| = 4.848212e-11\n      2 Linear |R| = 9.728383e-14\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 2 Nonlinear |R| = 4.995673e-11\n      0 Linear |R| = 4.995673e-11\n      1 Linear |R| = 5.492085e-16\n      2 Linear |R| = 4.371777e-17\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 3 Nonlinear |R| = 1.194506e-14\nNonlinear solve converged due to CONVERGED_FNORM_RELATIVE iterations 3\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  eta: 1.090797e-14\n\nTime Step 10, time = 1, dt = 0.1\n 0 Nonlinear |R| = 2.090711e-03\n      0 Linear |R| = 2.090711e-03\n      1 Linear |R| = 1.562819e-06\n      2 Linear |R| = 1.978178e-09\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 1 Nonlinear |R| = 1.488655e-06\n      0 Linear |R| = 1.488655e-06\n      1 Linear |R| = 4.883450e-11\n      2 Linear |R| = 7.438869e-14\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 2 Nonlinear |R| = 4.332149e-11\n      0 Linear |R| = 4.332149e-11\n      1 Linear |R| = 6.359041e-16\n      2 Linear |R| = 1.139856e-16\n  Linear solve converged due to CONVERGED_RTOL iterations 2\n 3 Nonlinear |R| = 1.126573e-14\nNonlinear solve converged due to CONVERGED_FNORM_RELATIVE iterations 3\n Solve Converged!\n\nOutlier Variable Residual Norms:\n  eta: 1.024457e-14",
                  "url": "https://github.com/idaholab/moose/discussions/17277#discussioncomment-464688",
                  "updatedAt": "2022-06-02T14:59:03Z",
                  "publishedAt": "2021-03-10T18:44:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sahu07"
                          },
                          "bodyText": "My output from test_action.i.txt (using action to declare variables):\ntest_action_output.txt",
                          "url": "https://github.com/idaholab/moose/discussions/17277#discussioncomment-464740",
                          "updatedAt": "2022-06-02T14:59:31Z",
                          "publishedAt": "2021-03-10T18:54:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dschwen"
                  },
                  "bodyText": "Can you point us to the source code for your action object?",
                  "url": "https://github.com/idaholab/moose/discussions/17277#discussioncomment-465057",
                  "updatedAt": "2022-06-02T14:59:27Z",
                  "publishedAt": "2021-03-10T19:56:04Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sahu07"
                          },
                          "bodyText": "Hi,\nThese are the source code for my action.\nPrecipitateAction.C:\n#include \"PrecipitateKKSAction.h\"\n\n// MOOSE includes\n#include \"AddVariableAction.h\"\n#include \"Conversion.h\"\n#include \"FEProblem.h\"\n#include \"Factory.h\"\n#include \"MooseMesh.h\"\n#include \"MooseObjectAction.h\"\n#include \"NonlinearSystemBase.h\"\n\n#include \"libmesh/string_to_enum.h\"\n\nregisterMooseAction(\"HorseApp\", PrecipitateKKSAction, \"add_variable\");\n\nInputParameters PrecipitateKKSAction::validParams() {\n  InputParameters params = Action::validParams();\n  params.addClassDescription(\n      \"Set up the variables required for precipitate growth \");\n  params.addParam<unsigned int>(\n      \"op_num\", 1, \"specifies the number of order parameters to create\");\n  params.addParam<std::string>(\"var_name_base\", \"eta\",\n                               \"specifies the base name of the variables\");\n  params.addParam<bool>(\"add_basic_variables\", \"true\",\n                        \"For adding the variables cs,cl,c,eta,w \");\n\n  // Get MooseEnums for the possible order/family options for this variable\n  MooseEnum families(AddVariableAction::getNonlinearVariableFamilies());\n  MooseEnum orders(AddVariableAction::getNonlinearVariableOrders());\n  params.addParam<MooseEnum>(\"family\", families,\n                             \"Specifies the family of FE \"\n                             \"shape function to use for the order parameters\");\n  params.addParam<MooseEnum>(\"order\", orders,\n                             \"Specifies the order of the FE \"\n                             \"shape function to use for the order parameters\");\n  params.addParam<Real>(\n      \"scaling\", 1.0,\n      \"Specifies a scaling factor to apply to the order parameters\");\n\n  return params;\n}\n\nPrecipitateKKSAction::PrecipitateKKSAction(const InputParameters &params)\n    : Action(params), _op_num(getParam<unsigned int>(\"op_num\")),\n      _var_name_base(getParam<std::string>(\"var_name_base\")),\n      _add_basic_variables(getParam<bool>(\"add_basic_variables\")),\n      _fe_type(\n          Utility::string_to_enum<Order>(getParam<MooseEnum>(\"order\")),\n          Utility::string_to_enum<FEFamily>(getParam<MooseEnum>(\"family\"))) {}\n\nvoid PrecipitateKKSAction::act() {\n  std::vector<VariableName> basic_variables;\n  basic_variables.push_back(\"eta\");\n  basic_variables.push_back(\"c\");\n  basic_variables.push_back(\"w\");\n  basic_variables.push_back(\"cs\");\n  basic_variables.push_back(\"cl\");\n\n  if (_add_basic_variables) {\n    for (auto var_name : basic_variables) {\n      auto type = AddVariableAction::determineType(_fe_type, 1);\n      auto var_params = _factory.getValidParams(type);\n\n      var_params.applySpecificParameters(_pars, {\"family\", \"order\"});\n      var_params.set<std::vector<Real>>(\"scaling\") = {\n          getParam<Real>(\"scaling\")};\n\n      // Add variable\n      if (_current_task == \"add_variable\") {\n        _problem->addVariable(type, var_name, var_params);\n        std::cout << _current_task << \":\"\n                  << \"added variables\" << var_name << std::endl;\n      }\n    }\n  }\n}```\n\n**PrecipitateAction.h**:\n```cpp\n#pragma once\n\n#include \"Action.h\"\n#include \"libmesh/fe_type.h\"\n\nclass PrecipitateKKSAction : public Action\n{\n        public:\n                static InputParameters validParams();\n                PrecipitateKKSAction( const InputParameters & params);\n                virtual void act();\n        protected:\n                const unsigned int _op_num;\n                const std::string _var_name_base;\n                const bool & _add_basic_variables;\n\n  /// FEType for the variable being created\n  const FEType _fe_type;\n\n};",
                          "url": "https://github.com/idaholab/moose/discussions/17277#discussioncomment-465461",
                          "updatedAt": "2022-06-02T14:59:27Z",
                          "publishedAt": "2021-03-10T21:23:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sahu07"
                  },
                  "bodyText": "Hi Daniel (@dschwen),\nDo you have any suggestions about the action system? I have attached the source code above.\nThanks,\nSarita",
                  "url": "https://github.com/idaholab/moose/discussions/17277#discussioncomment-484320",
                  "updatedAt": "2022-06-02T14:59:47Z",
                  "publishedAt": "2021-03-15T15:01:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "I'm a bit stumped here. Diff between the two inputs:\n23,28c23,24\n< [Variables]\n<   # order parameter\n<   [eta]\n<     order = FIRST\n<     family = LAGRANGE\n<   []\n---\n> [PrecipitateKKS]\n> []\n30,33c26,30\n<   # solute concentration\n<   [c]\n<     order = FIRST\n<     family = LAGRANGE\n---\n> [ICs]\n>   [ic_cs]\n>     type = ConstantIC\n>     value = 0.9\n>     variable = cs\n35,52c32,35\n<\n<   # chemical potential\n<   [w]\n<     order = FIRST\n<     family = LAGRANGE\n<   []\n<\n<   # Liquid phase solute concentration\n<   [cl]\n<     order = FIRST\n<     family = LAGRANGE\n<     initial_condition = 0.1\n<   []\n<   # Solid phase solute concentration\n<   [cs]\n<     order = FIRST\n<     family = LAGRANGE\n<     initial_condition = 0.9\n---\n>   [ic_cl]\n>     type = ConstantIC\n>     value = 0.1\n>     variable = cl",
                          "url": "https://github.com/idaholab/moose/discussions/17277#discussioncomment-484468",
                          "updatedAt": "2022-06-02T14:59:48Z",
                          "publishedAt": "2021-03-15T15:26:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dschwen"
                          },
                          "bodyText": "One difference I notice is the order of variables. Could you make those equal, please. (it should not have that strong an impact, but let's try get the two cases as close as possible)\n  Variables:               { \"eta\" \"c\" \"w\" \"cs\" \"cl\" } \n\nvs.\n  Variables:               { \"eta\" \"c\" \"w\" \"cl\" \"cs\" }",
                          "url": "https://github.com/idaholab/moose/discussions/17277#discussioncomment-484476",
                          "updatedAt": "2022-06-02T15:00:07Z",
                          "publishedAt": "2021-03-15T15:27:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sahu07"
                          },
                          "bodyText": "Thank you, Daniel (@dschwen)!\nI changed the variable order in my actions to { \"eta\" \"c\" \"w\" \"cl\" \"cs\" }.  And now it worked. I am getting the same output in both cases.\nThanks,\nSarita",
                          "url": "https://github.com/idaholab/moose/discussions/17277#discussioncomment-493376",
                          "updatedAt": "2022-06-02T15:00:07Z",
                          "publishedAt": "2021-03-17T12:08:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Material Point Method in MOOSE (moved from mailing list)",
          "author": {
            "login": "fdkong"
          },
          "bodyText": "This topic is moved from mailing list\n\nOn Tue, Nov 10, 2020 at 10:20 PM Jed Brown <jed@jedbrown.org> wrote:\nFande Kong <fdkong.jd@gmail.com> writes:\n\n> On Tue, Nov 10, 2020 at 3:08 PM Nathan Miller <nathan.a.mill@gmail.com>\n> wrote:\n>\n>> Hi All,\n>>\n>> I'm collaborating with the ASC PSAAP III program at CU Boulder ( see here\n>> <https://www.colorado.edu/engineering/2020/10/01/engineering-leads-new-doe-predictive-science-academic-alliance-program-center-particulate>)\n>> and they are using my micromorphic continuum mechanics code (\n>> https://github.com/lanl/tardigrade ). As a part of the project, they\n>> would like to try and use the material point method to solve the\n>> micromorphic balance equations. Jed Brown, who is also collaborating on the\n>> project, mentioned that PETSc's DMSwarm capabilities might be able to do\n>> this but that it may require modification to libMesh or for MOOSE to\n>> support some additional PETSc features that he wasn't sure you did.\n>>\n>\n> Yes, we need to refactor DM a bit to bring DMSwarm in, and do some\n> transfers between MOOSE MESH and PETSc DM. It is interesting for me.\n> Unfortunately, we do not have any funded project that has such\n> requirements right now. That being said, we might not get that really soon.\n>\n> Outside contributions are always welcome : -)\n\nThanks, Fande. We may be able to drive this forward under the PSAAP, but would\n like some guidance from the MOOSE team about how you would like to see it\n integrated. If you or other MOOSE developers have thoughts on that, perhaps\n we could discuss be email or a short screen-share meeting. This is a bit preliminary\n in that Nathan and myself are the only members of our current team who have\n experience with MOOSE, but I don't think either of us have free cycles to start\n implementing this right away. (We are hiring, if anyone is reading this and interested...)\n\nThe PSAAP center's needs include MPM for micromorphic mechanics (with Tardigrade)\n and MPM for grain-resolving simulation that is much more performance sensitive and\n will likely not use MOOSE. The project just started and strategy for the latter\n component is still in flux, but there's a good chance it will use DMSwarm\n (and upstream anything relevant).",
          "url": "https://github.com/idaholab/moose/discussions/16152",
          "updatedAt": "2022-06-11T16:56:56Z",
          "publishedAt": "2020-11-11T16:06:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "@jedbrown want to introduce DMSwarm to MOOSE for MPM.\n@idaholab/moose-team Any thoughts on how to integrate this capability?",
                  "url": "https://github.com/idaholab/moose/discussions/16152#discussioncomment-127041",
                  "updatedAt": "2022-06-11T17:10:03Z",
                  "publishedAt": "2020-11-11T16:10:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Let's make sure to pull in @nathan-miller-LANL (I think I got this tag right). I think I could give a more educated answer if I was a little more educated on DMSwarm. I am always intrigued by a potential increase in integration between PETSc and libMesh/MOOSE. I think it would be a great idea to sit down and do the screen-share meeting that @jedbrown bought up. We would make sure to dial @roystgnr into that call as well",
                          "url": "https://github.com/idaholab/moose/discussions/16152#discussioncomment-127222",
                          "updatedAt": "2022-06-11T17:10:03Z",
                          "publishedAt": "2020-11-11T20:27:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nathan-miller-LANL"
                          },
                          "bodyText": "Yep, that's me. Let me know when you all want to try and to the web-meeting.",
                          "url": "https://github.com/idaholab/moose/discussions/16152#discussioncomment-127838",
                          "updatedAt": "2022-06-11T17:10:05Z",
                          "publishedAt": "2020-11-12T14:47:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "fdkong"
                          },
                          "bodyText": "Nathan, go ahead to schedule a meeting next week or so.\nIt might be very really helpful if you could have a background introduction of this problem because we might not be familiar with this topic.",
                          "url": "https://github.com/idaholab/moose/discussions/16152#discussioncomment-127871",
                          "updatedAt": "2022-06-11T17:10:05Z",
                          "publishedAt": "2020-11-12T15:41:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "Dear all,\nI followed with interest this discussion. I will have a post doctoral position starting (hopefully) soon where the candidate, among other things, would be asked to (at least try) to integrate Particle in Cell (PIC) capabilities to one of our moose based app, possibly based on DMSwarm from Petsc. This said, even if for a different applications than what discussed above, we would also be interested in any progress made in this field, and will also be willing to actively do some coding from our part. My comment  was meant on an informative level, but I would be glad to be informed if possible of any progress and/or decision about it. Thanks and sorry for stepping in.\nMauro",
                          "url": "https://github.com/idaholab/moose/discussions/16152#discussioncomment-130432",
                          "updatedAt": "2022-06-11T17:10:45Z",
                          "publishedAt": "2020-11-16T08:47:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "nathan-miller-LANL"
                          },
                          "bodyText": "@fdkong, okay. I'll try and coordinate that.\n@mcacace I'm glad to hear others are interested. Note that the method that we would want to implement MPM for would be a higher order continuum theory which includes as a subset classical (i.e. Cauchy) continuum mechanics. I would hope that what we would do would be at least tangentially applicable to your problem.",
                          "url": "https://github.com/idaholab/moose/discussions/16152#discussioncomment-130758",
                          "updatedAt": "2022-06-11T17:10:47Z",
                          "publishedAt": "2020-11-16T15:00:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "wjin33"
                  },
                  "bodyText": "I am working on granular flow physics, and would like to see the development of MPM in MOOSE.",
                  "url": "https://github.com/idaholab/moose/discussions/16152#discussioncomment-127289",
                  "updatedAt": "2022-06-11T17:11:32Z",
                  "publishedAt": "2020-11-11T22:36:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@wjin33 @loganharbour @friedmud and I have taken a look at mpm in moose if people want to join in on the effort",
                  "url": "https://github.com/idaholab/moose/discussions/16152#discussioncomment-491816",
                  "updatedAt": "2022-06-11T17:11:37Z",
                  "publishedAt": "2021-03-17T03:04:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mcacace"
                          },
                          "bodyText": "@GiudGiud et al: this is great news! As written in my previous post, we have some applications, for which usage of mpm (was considering more PIC) methods based on DMSwarm Petsc capabilities would be an asset. Would be interesting to learn more about the status and try to help the development.\nMauro",
                          "url": "https://github.com/idaholab/moose/discussions/16152#discussioncomment-492450",
                          "updatedAt": "2022-06-11T17:11:37Z",
                          "publishedAt": "2021-03-17T07:53:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How do I create stress-free strain using eigenstrain?",
          "author": {
            "login": "jlinBE"
          },
          "bodyText": "I am building a simple model for mine simulations.\nThe workflow goes like this:\n\nstart with a uniform mesh with a number of blocks pre-defined; everything has the same Young's modulus at this point\napply gravity and solve for steady-state\nimport the result from pervious step, except in one of the pre-defined blocks, reduce Young's modulus by several orders of magnitude. again solve for steady-state, so that the mesh deforms.\nimport the result from previous step, except in the same block as before, increase Young's modulus to simulate backfill.  This results in the block pushing back against neighboring blocks because the initial strain is nonzero, which is not what I want.  Instead I would like to set a reference strain (or eigenstrain), which is equal to the previous strain at steady state, and calculate stress using E*(strain - eigenstrain).\n\nI am stuck at step 4.  I think it should be possible using ComputeEigenstrain or ComputeVariableEigenstrain, but not sure about the syntax.\nAny help?\n@WilkAndy @Traiwit",
          "url": "https://github.com/idaholab/moose/discussions/17270",
          "updatedAt": "2022-06-13T08:31:33Z",
          "publishedAt": "2021-03-10T06:44:01Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @jlinBE\nThe reduction of the stiffness tensor is not the same thing as introducing an eigenstrain.\nFor instance during plastic deformation you can have a large eigenstrain (plastic deformation) but still large stress and stiffness.\nOr you can have stiffness reduction without any eigenstrain, for instance in a linear elastic model.\nAn example of code for stiffness reduction based on the temperature is in my repository:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/ComputeElasticityTensorMelting.C\nThe choice between stiffness degradation and introducing eigenstrain depends on the specific phenomenon.\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/17270#discussioncomment-462842",
                  "updatedAt": "2022-06-13T08:31:55Z",
                  "publishedAt": "2021-03-10T14:32:50Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "About your point 4)\nI suggest you to check for elastic-perfectly plastic material models, which is what you are describing.\nIt may be already available in the tensor mechanics module.",
                  "url": "https://github.com/idaholab/moose/discussions/17270#discussioncomment-462895",
                  "updatedAt": "2022-06-13T08:31:59Z",
                  "publishedAt": "2021-03-10T14:39:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ngrilli"
                          },
                          "bodyText": "IsotropicPlasticityStressUpdate object with zero hardening should do that.\nYour elements will deform permanently and will not apply stress on the rest of the geometry at the beginning\nof your final step (step 4).",
                          "url": "https://github.com/idaholab/moose/discussions/17270#discussioncomment-462918",
                          "updatedAt": "2022-06-13T08:32:20Z",
                          "publishedAt": "2021-03-10T14:43:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "Hi @ngrilli,\nThank you for your suggestion, I tried to set zero hardening at the backfill block, but the simulation does not seem to converge. Not sure if I did anything wrong.\n  [./isotropic_plasticity_backfill]\n    type = IsotropicPlasticityStressUpdate\n    yield_stress = 50.0\n    hardening_constant = 0\n    block = '1'\n    use_displaced_mesh = true\n  [../]\n  [./return_stress_backfill]\n  type = ComputeMultipleInelasticStress\n     # tangent_operator = elastic\n     inelastic_models = 'isotropic_plasticity_backfill'\n     block = '1'\n  [../]\n\nI also attempted @WilkAndy suggestion from #16387: \"At the start of each timestep, set the strain in certain elements (block ID) to zero. The \"certain elements\" are defined by another time-dependent Function, etc. Zeroing the strain should not impact the positions of the nodes in any element. Its purpose is to ensure the stress in these elements is zero (at the start of the timestep). This means an alternative would be to introduce a new reference strain, strain_ref, which is the strain in those elements at the start of the timestep, and calculate stress using stress = E * (strain - strain_ref). You haven't be able to achieve this, since there appears to be nothing in MOOSE that enables either of these ideas.\"\nSo for stress = E * (strain - strain_ref), I managed to maintain the deformed mesh using negative values of strain_ref in ComputeEigenstrain (https://mooseframework.inl.gov/source/materials/CompositeEigenstrain.html).\n[./eigen_backfill]\n    type = ComputeEigenstrain\n    eigenstrain_name = eigen_true\n    eigen_base = '-3e-3 0 0 0 -0 0 0 0 -3e-3' \n    block = '1'\n    use_displaced_mesh = true\n  [../]\n  [./eigen_therest]\n    type = ComputeEigenstrain\n    eigenstrain_name = eigen_true\n    eigen_base = '0'\n    block = '0'\n    use_displaced_mesh = true\n  [../]\n\n-3e-3 is obtained from a trial and error method.\nThe question now is: how do we obtain the exact value of \"strain_ref\" so we can make sure that the backfill material doesn't push back the deformed mesh. should it be the value of the difference of strain before and after backfilling at that particular block? if so, how do I obtain such a value from 2 output files.\nalso 1 quick question, why doesn\u2019t moose read second-order AuxVariables (monomial family) from an input file (previous simulation step) when using\n  [./e11_aux]\n    order = SECOND\n    family = MONOMIAL\n      initial_from_file_var = e11_aux\n  [../]\n\nit works fine when the order is constant.\nAgain, thank you for your time guys \ud83d\udc4d",
                          "url": "https://github.com/idaholab/moose/discussions/17270#discussioncomment-466306",
                          "updatedAt": "2022-06-13T08:32:21Z",
                          "publishedAt": "2021-03-11T00:53:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @Traiwit\nIt's difficult to say what is your convergence problem.\nCould you share the complete input file?\nThe first thing to check for the convergence problem in plasticity is the time step:\nan elasto-plastic stress-strain curve must be solved with enough time steps,\nmaybe you can start with about 1000 time steps to reach 1% total strain or so.\nBoundary conditions may also affect.\nI suggest you start from the setting of this example with small strain:\nhttps://github.com/idaholab/moose/blob/next/modules/tensor_mechanics/test/tests/strain_energy_density/rate_incr_model_elas_plas.i\nBest Regards,\nNicol\u00f2 Grilli\nNational University of Singapore",
                  "url": "https://github.com/idaholab/moose/discussions/17270#discussioncomment-468214",
                  "updatedAt": "2022-06-13T08:36:01Z",
                  "publishedAt": "2021-03-11T10:45:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Traiwit"
                  },
                  "bodyText": "To simplify the question, is there a way that I can change the elasitcity_tensor (E and passion ration) of a block without changing the disp_x,y,z of that block from the previous step.\nThanks guys!",
                  "url": "https://github.com/idaholab/moose/discussions/17270#discussioncomment-492093",
                  "updatedAt": "2022-06-13T08:36:05Z",
                  "publishedAt": "2021-03-17T05:28:17Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}