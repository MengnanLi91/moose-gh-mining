{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wMS0wNVQwNTo1MTo0OC0wNjowMM4AW_gz"
    },
    "edges": [
      {
        "node": {
          "title": "Trouble Integrating gperftools with Moose in Conda Environment",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "I'm using a moose environment installed with conda. Recently, I've been attempting to analyze my moose program using gperftools. I followed the instructions in the tutorial at https://mooseframework.inl.gov/application_development/profiling.html, but I'm unsure whether I need to make modifications to libmesh and wasp. My focus is specifically on using gperftools when METHOD=oprof.\n\nlibMesh automatically adds -fno-omit-frame-pointer to METHOD=oprof builds. However, if you want to do profiling with other methods (e.g. opt, which will not give line number information), both libMesh and MOOSE should be built with CXXFLAGS=-fno-omit-frame-pointer. (On a related node, MOOSE will error if the user attempts to compile with either METHOD=devel or METHOD=dbg and with a non-empty GPERF_DIR as those methods add assertions that will make the resulting profiles misleading). When building libMesh, ensure that the METHODS environment variable is either empty (in which case the script will build opt, oprof, devel, and dbg methods), or that METHODS contains oprof (or not if you wish to profile with another method and have specified CXXFLAGS=-fno-omit-frame-pointer).\n\nUpon updating only Petsc, I encountered some errors like this:\n/home/zu/anaconda3/envs/moose-gperf/bin/../lib/gcc/x86_64-conda-linux-gnu/10.4.0/../../../../x86_64-conda-linux-gnu/bin/ld: /home/zu/ProgramFiles/gperftools/installed/lib/libtcmalloc_and_profiler.so: undefined reference to pthread_key_create@GLIBC_2.34'`\nWhen attempting to update libmesh, I received the following message:\nNo LSB modules are available.\nERROR: LIBMESH_DIR=/home/zu/anaconda3/envs/moose-gperf/libmesh exists within the conda base /home/zu/anaconda3\nExiting in order to stop you from overwriting your conda environment\n\nCan anyone provide guidance on how to successfully integrate gperftools? Thank you in advance for your assistance.",
          "url": "https://github.com/idaholab/moose/discussions/26490",
          "updatedAt": "2024-01-06T19:35:24Z",
          "publishedAt": "2024-01-06T14:23:24Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you want to hack a little and use the conda environment AND re-install a custom libmesh, then unset LIBMESH_DIR before doing so.\nHave you really optimized to the point that oprof is no longer sufficient for detecting the slower parts of the program?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26490#discussioncomment-8031145",
                  "updatedAt": "2024-01-06T14:43:24Z",
                  "publishedAt": "2024-01-06T14:43:24Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "In fact, I am not familiar with oprof and gperftools at all. I just hope to analyze the memory usage and came across this tutorial. So, does moose inherently support a tool called oprof for memory analysis?",
                          "url": "https://github.com/idaholab/moose/discussions/26490#discussioncomment-8031233",
                          "updatedAt": "2024-01-06T15:01:04Z",
                          "publishedAt": "2024-01-06T15:01:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "OPROF is the build method which is recommended for profiling",
                          "url": "https://github.com/idaholab/moose/discussions/26490#discussioncomment-8031282",
                          "updatedAt": "2024-01-06T15:09:41Z",
                          "publishedAt": "2024-01-06T15:09:40Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you once again for your assistance.",
                          "url": "https://github.com/idaholab/moose/discussions/26490#discussioncomment-8031546",
                          "updatedAt": "2024-01-06T15:49:37Z",
                          "publishedAt": "2024-01-06T15:49:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "I am a little confused on hacking libMesh. We ship moose-libmesh with the following methods built: opt, dbg, devel, oprof. So it should not be necessary rebuilding libMesh in OPROF mode. But maybe I am missing something in this discussion?\n\u276f conda activate moose\n\u276f ls $LIBMESH_DIR/lib | grep oprof\nlibmesh_oprof.0.dylib\nlibmesh_oprof.dylib\nlibtimpi_oprof.11.dylib\nlibtimpi_oprof.dylib",
                          "url": "https://github.com/idaholab/moose/discussions/26490#discussioncomment-8032740",
                          "updatedAt": "2024-01-06T18:24:58Z",
                          "publishedAt": "2024-01-06T18:24:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "He wants to build in opt with the frame flag added",
                          "url": "https://github.com/idaholab/moose/discussions/26490#discussioncomment-8033032",
                          "updatedAt": "2024-01-06T19:19:42Z",
                          "publishedAt": "2024-01-06T19:19:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "Ah, I think is see the disconnect... I figured those instructions would explain that we have performance tools from google available as a Conda package:\nconda activate moose\nconda install moose-pprof\n(I receive a bunch of warnings during installation on my Apple Silicon machine, but resulting pprof still seems to work fine)\nAfter which, you will need to re-activate the environment in order to have GPERF_DIR set:\nconda deactivate\nconda activate moose\necho $GPERF_DIR\n/Users/milljm/mamba3/envs/moose",
                          "url": "https://github.com/idaholab/moose/discussions/26490#discussioncomment-8033092",
                          "updatedAt": "2024-01-06T19:35:25Z",
                          "publishedAt": "2024-01-06T19:35:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Unusual Memory Usage Issue with MOOSE InversePowerMethod Executioner 'LINEAR' Solver",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "I have developed an SN-DFEM program using MOOSE, and recently, I've been experimenting with the 'LINEAR' solver of the InversePowerMethod executioner. However, I've encountered a peculiar phenomenon: initially, I tested it on a one-dimensional problem with 800,000 degrees of freedom, and according to the system monitor, MOOSE occupied around 700MB of memory. However, when I tested it on a three-dimensional problem with only 80,000 degrees of freedom, the system monitor showed that MOOSE reached a maximum memory usage of around 9.9GB. Conversely, when I used PJFNK to solve the three-dimensional problem, MOOSE only occupied approximately 200MB of memory.\nMy understanding of the LINEAR solver is that it solves a linear problem Ax=b where b=Bx^(n-1)/\u03bb^(n-1) using the krylov method (not JFNK) and requires the complete solution of the entire Jacobian matrix. Storing the Jacobian matrix can indeed be memory-intensive, but the memory usage observed in the tests seems excessively large and unreasonable.\nCould anyone shed light on what might be causing this issue? Additionally, where can I find the code for the LINEAR solver of the InversePowerMethod executioner?\nThank you in advance for any insights.",
          "url": "https://github.com/idaholab/moose/discussions/26419",
          "updatedAt": "2024-01-06T15:52:33Z",
          "publishedAt": "2023-12-26T04:43:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you use Newton or PJFNK with\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\ndo you see the same memory utilization as LINEAR?\nIn 3D, are you using a hex mesh or a tetrahedral mesh?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26419#discussioncomment-7950587",
                  "updatedAt": "2023-12-26T18:08:35Z",
                  "publishedAt": "2023-12-26T18:08:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Oh, yes! When I use the SMP preconditioner with either the Newton or PJFNK methods, MOOSE exhibits the same memory usage behavior. In 3D, I used a cuboidal mesh. While I've identified the cause of the memory usage, is it expected for storing the complete Jacobian matrix to require such a significant amount of memory? I noticed the option to set auto_preconditioning=false to disable SMP, but according to MOOSE's description in the Steady executioner, this might lead to incorrect computation results, correct?\n\nLINEAR will use PETSc control parameter -ksp_only to set the type of SNES for solving the linear system. Note that it only works when you have an exact Jacobian because it is not activating matrix-free calculations.\nNEWTON means PETSc will use the Jacobian provided by kernels (typically not exact) to do the Krylov solve. If the Jacobian is not exact, Newton update in Eq. (4) will not reduce the residual effectively and typically results into an unconverged Newton iteration.\n\nI vaguely remember seeing in MOOSE that it's possible to set the off-diagonal level of the Jacobian matrix to determine the range of off-diagonal terms that need to be stored.",
                          "url": "https://github.com/idaholab/moose/discussions/26419#discussioncomment-7953351",
                          "updatedAt": "2023-12-27T05:41:46Z",
                          "publishedAt": "2023-12-27T05:41:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This may be the problem then; storing the Jacobian.\nThe next thing you can do to make sure is memory profiling\nhttps://mooseframework.inl.gov/application_development/profiling.html",
                          "url": "https://github.com/idaholab/moose/discussions/26419#discussioncomment-7955563",
                          "updatedAt": "2023-12-27T11:24:19Z",
                          "publishedAt": "2023-12-27T11:24:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If the Jacobian is incomplete, how are you going to use the LINEAR solve? Or are you planning to go back to PJFNK or a variant?\nI think the state of the art for DFEM-SN is sweeping methods btw. These form local systems that are much smaller",
                          "url": "https://github.com/idaholab/moose/discussions/26419#discussioncomment-7955591",
                          "updatedAt": "2023-12-27T11:26:49Z",
                          "publishedAt": "2023-12-27T11:26:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Actually, this is a point that has puzzled me. I presumed it directly solves Ax=b using the Krylov method, rather than Jx=R. Consequently, it shouldn't necessitate a Jacobian matrix. I attempted to search for information on the -ksp_only parameter of Petsc via Google but couldn't find any pertinent documentation.",
                          "url": "https://github.com/idaholab/moose/discussions/26419#discussioncomment-7956477",
                          "updatedAt": "2023-12-27T13:18:46Z",
                          "publishedAt": "2023-12-27T13:18:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "I'm also interested in the sweeping method, but that's part of my future plans. Currently, I don't have the capacity to implement a sweeping solver.",
                          "url": "https://github.com/idaholab/moose/discussions/26419#discussioncomment-7956520",
                          "updatedAt": "2023-12-27T13:24:59Z",
                          "publishedAt": "2023-12-27T13:24:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "LINEAR will use PETSc control parameter -ksp_only to set the type of SNES for solving the linear system. Note that it only works when you have an exact Jacobian because it is not activating matrix-free calculations.\n\nthis is the only documentation on our side. This is basically pointing you to PETSC ksp_only indeed.\nLet me know what you find on the petsc side and I ll add a little more on our side on what this actually does",
                          "url": "https://github.com/idaholab/moose/discussions/26419#discussioncomment-7956617",
                          "updatedAt": "2023-12-27T13:32:20Z",
                          "publishedAt": "2023-12-27T13:32:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Additionally, may I ask you another question? I've seen that you have responded to similar error messages before. In the last two days, I consistently encountered an error in a postprocessor I wrote myself: \"Coupled variable 'psi_0_0' was not found.\" However, I'm quite certain that I have the variable 'psi_0_0'. I'm calling this postprocessor in an action, and I've double-checked that I initialize it only after declaring all the variables.",
                          "url": "https://github.com/idaholab/moose/discussions/26419#discussioncomment-7956643",
                          "updatedAt": "2023-12-27T13:36:20Z",
                          "publishedAt": "2023-12-27T13:36:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Let me know what you find on the petsc side and I ll add a little more on our side on what this actually does\n\nCurrently, I haven't found any helpful information. If I come across other resources later, I'll update you here.",
                          "url": "https://github.com/idaholab/moose/discussions/26419#discussioncomment-7956684",
                          "updatedAt": "2023-12-27T13:40:30Z",
                          "publishedAt": "2023-12-27T13:40:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If it s a postprocessor then it is a not a (field) variable.\nThis error message is asking for a variable with that name. If you want to be able to specify either a variable or a postprcoessor, you need to use the functor interfaces. (functors are a base class for both variables and postprocessors)",
                          "url": "https://github.com/idaholab/moose/discussions/26419#discussioncomment-7956694",
                          "updatedAt": "2023-12-27T13:41:29Z",
                          "publishedAt": "2023-12-27T13:41:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "If it s a postprocessor then it is a not a (field) variable.\n\nI might not fully understand your response.\n'psi_0_0' is a nonlinear variable that I declared in the action. When I disable this postprocessor, I can find it in the output information:\nNonlinear System:\n  Num DOFs:                23125248\n  Num Local DOFs:          937728\n  Variables:               { \"psi_0_0\" \"psi_0_1\"",
                          "url": "https://github.com/idaholab/moose/discussions/26419#discussioncomment-7956824",
                          "updatedAt": "2023-12-27T13:56:47Z",
                          "publishedAt": "2023-12-27T13:56:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "|Bx| = 0! Issue with InversePowerMethod Executioner",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "Hello everyone,\nI hope this message finds you well. I'm encountering a problem using the InversePowerMethod executioner in MOOSE when multiple blocks are involved. The error message I'm encountering is as follows:\nThe following error occurred in the object \"Executioner\", of type \"InversePowerMethod\".\n\n|Bx| = 0!\n\nUpon examining the relevant code, it appears that this error is triggered because the program detects that the _integral_value returned by the ElementIntegralVariablePostprocessor used to calculate |Bx| (Ax=1/lambda*Bx) is 0. Interestingly, this issue doesn't arise in uniform problems, indicating situations where there is only one block.\nTo investigate further, I used show_execution_order = LINEAR to analyze MOOSE's execution order and obtained the following outputs. I'm using an auxkernel named source to calculate Bx values on each element. Subsequently, I use total_source (an ElementIntegralVariablePostprocessor object) to compute the volume integral of the source. Due to the dependency of total_source on source, I specifically added execute_on = 'INITIAL LINEAR' for source. To examine the invocation of total_source, I also configured MOOSE to output this value each time _integral_value is called. In the uniform scenario, it was output twice, whereas in the case of multiple blocks, it was only output once.\nMultiple blocks:\n[DBG] Executing auxiliary kernels on elements on LINEAR\n[DBG] Ordering of AuxKernels on block 1\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n[DBG] Ordering of AuxKernels on block 2\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n[DBG] Ordering of AuxKernels on block 4\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n[DBG] Ordering of AuxKernels on block 3\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n[DBG] Ordering of AuxKernels on block 5\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n[DBG] Ordering of AuxKernels on block 11\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n[DBG] Ordering of AuxKernels on block 12\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n[DBG] Ordering of AuxKernels on block 6\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n[DBG] Ordering of AuxKernels on block 7\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n[DBG] Ordering of AuxKernels on block 8\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n[DBG] Ordering of AuxKernels on block 9\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n[DBG] Ordering of AuxKernels on block 10\n[DBG] aux_phi_0 aux_phi_1 aux_phi_2 aux_phi_3 source\n_integral_value = 0\n[DBG] Computing elemental user objects on LINEAR\n[DBG] Execution order of objects types on each element then its sides:\n[DBG] - element user objects\n[DBG] - domain user objects\n[DBG] - element user objects contributing to the Jacobian\n[DBG] - side user objects\n[DBG] - domain user objects executing on sides\n[DBG] - side user objects contributing to the Jacobian\n[DBG] - internal side user objects\n[DBG] - domain user objects executing on internal sides\n[DBG] - interface user objects\n[DBG] - domain user objects executing at interfaces\n[DBG] Ordering of User Objects on block 1\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Ordering of User Objects on block 2\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Ordering of User Objects on block 4\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Ordering of User Objects on block 3\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Ordering of User Objects on block 5\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Ordering of User Objects on block 11\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Ordering of User Objects on block 12\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Ordering of User Objects on block 6\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Ordering of User Objects on block 7\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Ordering of User Objects on block 8\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Ordering of User Objects on block 9\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Ordering of User Objects on block 10\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n\n\n*** ERROR ***\nThe following error occurred in the object \"Executioner\", of type \"InversePowerMethod\".\n\n|Bx| = 0!\n\nUniform situation:\n[DBG] Executing auxiliary kernels on elements on LINEAR\n[DBG] Ordering of AuxKernels on block 0\n[DBG] aux_phi_0 source\n_integral_value = 0\n[DBG] Computing elemental user objects on LINEAR\n[DBG] Execution order of objects types on each element then its sides:\n[DBG] - element user objects\n[DBG] - domain user objects\n[DBG] - element user objects contributing to the Jacobian\n[DBG] - side user objects\n[DBG] - domain user objects executing on sides\n[DBG] - side user objects contributing to the Jacobian\n[DBG] - internal side user objects\n[DBG] - domain user objects executing on internal sides\n[DBG] - interface user objects\n[DBG] - domain user objects executing at interfaces\n[DBG] Ordering of User Objects on block 0\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n[DBG] Executing auxiliary kernels on elements on LINEAR\n[DBG] Ordering of AuxKernels on block 0\n[DBG] aux_phi_0 source\n_integral_value = 1.48512\n[DBG] Computing elemental user objects on LINEAR\n[DBG] Ordering of User Objects on block 0\n[DBG] Executing ElementUserObject on LINEAR\n[DBG] Order of execution:\n[DBG] total_source\n                             \n[DBG] Only user objects active on local element/sides are executed\n\n|Bx| = 1.0000000000\n\nI'm seeking advice on how to resolve this issue. Any insights or suggestions would be greatly appreciated.\nThank you in advance for your assistance.",
          "url": "https://github.com/idaholab/moose/discussions/26489",
          "updatedAt": "2024-01-15T20:26:42Z",
          "publishedAt": "2024-01-06T13:42:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nwhy is _integral_value 0 in the first case? Can you initialize the source variable with an initial condition so it s not 0 ?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26489#discussioncomment-8031120",
                  "updatedAt": "2024-01-06T14:38:14Z",
                  "publishedAt": "2024-01-06T14:38:13Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you very much for your suggestion. By checking the output through setting initial values, I identified the issue: I mistakenly used an assignment operation instead of an accumulation operation in the code.",
                          "url": "https://github.com/idaholab/moose/discussions/26489#discussioncomment-8031532",
                          "updatedAt": "2024-01-06T15:47:04Z",
                          "publishedAt": "2024-01-06T15:47:03Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Multiple Mesh Files Import",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I am wanting to use multiple mesh files in the contact modeling module. The mesh domains are not required to be stitched but have to be separated to control individual file sized. Can multiple .e files be opened with FileMesh?",
          "url": "https://github.com/idaholab/moose/discussions/25801",
          "updatedAt": "2024-01-06T12:52:25Z",
          "publishedAt": "2023-10-21T00:41:35Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Not with file mesh but with FileMeshGenerator you can do that with a generator for each mesh file",
                  "url": "https://github.com/idaholab/moose/discussions/25801#discussioncomment-7344478",
                  "updatedAt": "2023-10-21T02:40:03Z",
                  "publishedAt": "2023-10-21T02:40:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "then use a CombineMeshGenerator to combine them without stitiching",
                          "url": "https://github.com/idaholab/moose/discussions/25801#discussioncomment-8030557",
                          "updatedAt": "2024-01-06T12:52:25Z",
                          "publishedAt": "2024-01-06T12:52:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error: unable to find closest node! in the mortar contact introduction",
          "author": {
            "login": "b1llg"
          },
          "bodyText": "Hi,\nI tried the examples in the contact module (https://mooseframework.inl.gov/modules/contact/tutorials/introduction/step02.html) and came up with this error while doing the step 2:\nTime Step 4, time = 2, dt = 0.5\n  Applying predictor with scale factor = 1\n 0 Nonlinear |R| = 8.693401e+05\n 1 Nonlinear |R| = 4.300712e+06\n  Linear solve did not converge due to DIVERGED_PC_FAILED iterations 0\n                 PC failed due to FACTOR_NUMERIC_ZEROPIVOT \n\n\n*** ERROR ***\nUnable to find closest node!\n\nStack frames: 37\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)\n2: void mooseError<char const (&) [29]>(char const (&) [29])\n3: /home/bill/projects/moose/framework/libmoose-opt.so.0(+0x21d1ec7) [0x7f52d2347ec7]\n4: KDTree::neighborSearch(libMesh::Point const&, unsigned int, std::vector<unsigned long, std::allocator<unsigned long> >&)\n5: SecondaryNeighborhoodThread::operator()(libMesh::StoredRange<__gnu_cxx::__normal_iterator<unsigned long*, std::vector<unsigned long, std::allocator<unsigned long> > >, unsigned long> const&)\n6: /home/bill/projects/moose/framework/libmoose-opt.so.0(+0x1b8977c) [0x7f52d1cff77c]\n7: NearestNodeLocator::findNodes()\n8: GeometricSearchData::update(GeometricSearchData::GeometricSearchType)\n9: DisplacedProblem::updateMesh(bool)\n10: FEProblemBase::computeResidualTags(std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n11: FEProblemBase::computeResidualInternal(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, std::set<unsigned int, std::less<unsigned int>, std::allocator<unsigned int> > const&)\n12: FEProblemBase::computeResidualSys(libMesh::NonlinearImplicitSystem&, libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&)\n13: ComputeResidualFunctor::residual(libMesh::NumericVector<double> const&, libMesh::NumericVector<double>&, libMesh::NonlinearImplicitSystem&)\n14: libmesh_petsc_snes_residual\n15: SNESComputeFunction\n16: /home/bill/miniforge/envs/moose/lib/libpetsc.so.3.20(+0xf8f5aa) [0x7f52cbade5aa]\n17: SNESLineSearchApply\n18: /home/bill/miniforge/envs/moose/lib/libpetsc.so.3.20(+0xf6afdc) [0x7f52cbab9fdc]\n19: SNESSolve\n20: libMesh::PetscNonlinearSolver<double>::solve(libMesh::SparseMatrix<double>&, libMesh::NumericVector<double>&, libMesh::NumericVector<double>&, double, unsigned int)\n21: libMesh::NonlinearImplicitSystem::solve()\n22: TimeIntegrator::solve()\n23: NonlinearSystem::solve()\n24: FEProblemBase::solve(unsigned int)\n25: FEProblemSolve::solve()\n26: FixedPointSolve::solveStep(double&, double&, std::set<unsigned long, std::less<unsigned long>, std::allocator<unsigned long> > const&)\n27: FixedPointSolve::solve()\n28: TimeStepper::step()\n29: Transient::takeStep(double)\n30: Transient::execute()\n31: MooseApp::executeExecutioner()\n32: MooseApp::run()\n33: main\n34: /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7f52c7da3d90]\n35: __libc_start_main\n36: ./contact_mech-opt(+0x33ef) [0x5629024053ef]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\n\nI copy and pasted the whole input file from the link above. The only difference between step01 and step02 is replacing the penalty formulation by mortar. Here is the input file, is the the exact same as the one in the link above:\n#\n# A first attempt at mechanical contact\n# https://mooseframework.inl.gov/modules/contact/tutorials/introduction/step01.html\n#\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n  block = 0\n[]\n\n[Mesh]\n  [generated1]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 5\n    ny = 15\n    xmin = -0.6\n    xmax = -0.1\n    ymax = 5\n    bias_y = 0.9\n    boundary_name_prefix = pillar1\n  []\n  [generated2]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 5\n    ny = 15\n    xmin = 0.1\n    xmax = 0.6\n    ymax = 5\n    bias_y = 0.9\n    boundary_name_prefix = pillar2\n    boundary_id_offset = 4\n  []\n  [collect_meshes]\n    type = MeshCollectionGenerator\n    inputs = 'generated1 generated2'\n  []\n\n  patch_update_strategy = iteration\n[]\n\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = FINITE\n    generate_output = 'vonmises_stress'\n  []\n[]\n\n[Contact]\n  [pillars]\n    primary = pillar1_right\n    secondary = pillar2_left\n    model = frictionless\n    formulation = mortar\n\n  []\n[]\n\n[BCs]\n  [bottom_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'pillar1_bottom pillar2_bottom'\n    value = 0\n  []\n  [bottom_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'pillar1_bottom pillar2_bottom'\n    value = 0\n  []\n  [Pressure]\n    [sides]\n      boundary = 'pillar1_left pillar2_right'\n      # we square time here to get a more progressive loading curve\n      # (more pressure later on once contact is established)\n      function = 1e4*t^2\n    []\n  []\n[]\n\n[Materials]\n  [elasticity]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 1e9\n    poissons_ratio = 0.3\n  []\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  line_search = none\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n  end_time = 5\n  dt = 0.5\n  [Predictor]\n    type = SimplePredictor\n    scale = 1\n  []\n[]\n\n[Outputs]\n  exodus = true\n  print_linear_residuals = false\n  perf_graph = true\n[]\n\nI started using Moose 2 days ago and I made sure it was up to date after the install.",
          "url": "https://github.com/idaholab/moose/discussions/26441",
          "updatedAt": "2024-01-05T22:37:42Z",
          "publishedAt": "2023-12-31T11:20:12Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Thanks for reporting. It looks like this input has fallen in disrepair.\n@recuero should be able to help next week. Let's use issue #26442 for the patch",
                  "url": "https://github.com/idaholab/moose/discussions/26441#discussioncomment-7983989",
                  "updatedAt": "2023-12-31T15:57:01Z",
                  "publishedAt": "2023-12-31T15:52:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "The solve will go to completion if you add the petsc option -pc_factor_shift_type NONZERO",
                  "url": "https://github.com/idaholab/moose/discussions/26441#discussioncomment-8017977",
                  "updatedAt": "2024-01-04T23:08:15Z",
                  "publishedAt": "2024-01-04T23:08:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Opened #26482",
                          "url": "https://github.com/idaholab/moose/discussions/26441#discussioncomment-8018058",
                          "updatedAt": "2024-01-04T23:20:20Z",
                          "publishedAt": "2024-01-04T23:20:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "b1llg"
                          },
                          "bodyText": "It works. There seems to be a little bit more penetration than expected however: max is 8.6e-4 and expected was 5.1e-9.",
                          "url": "https://github.com/idaholab/moose/discussions/26441#discussioncomment-8018291",
                          "updatedAt": "2024-01-05T00:05:50Z",
                          "publishedAt": "2024-01-05T00:05:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Did you make other modifications to the input? The largest penetration I see is 2.1e-9",
                          "url": "https://github.com/idaholab/moose/discussions/26441#discussioncomment-8019193",
                          "updatedAt": "2024-01-05T03:09:58Z",
                          "publishedAt": "2024-01-05T03:09:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "b1llg"
                          },
                          "bodyText": "Apparently, if you use the input from the tensor mechanics module and work your way up to the contact tutorial (as it is suggested), there is a difference in the dimension:\n\nOn the left: the input if you start from tensor mechanics tutorials. (8.6e-9)\nOn the right: the input from step 2 in the contact tutorials. (2.1e-9)\nSo the difference is the number of elements.\nIn both case I added -pc_factor_shift_type=NONZERO",
                          "url": "https://github.com/idaholab/moose/discussions/26441#discussioncomment-8021074",
                          "updatedAt": "2024-01-05T09:17:43Z",
                          "publishedAt": "2024-01-05T09:16:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The relevant parameter is actually ymax. If you have ymax = 4.999 and you vary the number of elements you should hopefully always see the penetration of order 1e-9 or less.\nHowever, if you keep ymax = 5, can you try adding correct_edge_dropping = true in the Contact/pillars block? That resolves the 1e-4 penetration issue for me (as well as dramatically improves the solver convergence)",
                          "url": "https://github.com/idaholab/moose/discussions/26441#discussioncomment-8026165",
                          "updatedAt": "2024-01-05T19:11:18Z",
                          "publishedAt": "2024-01-05T19:11:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "b1llg"
                          },
                          "bodyText": "I get 1.5e-11.",
                          "url": "https://github.com/idaholab/moose/discussions/26441#discussioncomment-8026632",
                          "updatedAt": "2024-01-05T20:15:49Z",
                          "publishedAt": "2024-01-05T20:15:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "sounds good!",
                          "url": "https://github.com/idaholab/moose/discussions/26441#discussioncomment-8027579",
                          "updatedAt": "2024-01-05T22:37:43Z",
                          "publishedAt": "2024-01-05T22:37:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Inquiry Regarding MOOSE Eigenvalue executioner's Free Power Iteration Process",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "Dear community members,\nI have a question regarding the free power iteration process in the Eigenvalue executioner of MOOSE. Some literature suggests that this process is intended to provide an initial guess for the Newton iteration of the JFNK eigensolver. However, upon reviewing the code in the EigenProblem.C, it appears that the free power iteration also calls JFNK for solving, and this is the same solver used in the subsequent Newton iteration.\nAs per my understanding, in power iteration, the formula for updating eigenvalues is \u03bb^(n) = \u03bb^(n\u22121) |B(x^(n))|/|B(x^(n\u22121))|, but I haven't found any relevant code implementing this. It seems that in power iteration, eigenvalues are also obtained as part of the nonlinear system of equations directly using JFNK just like Newton iteration. The only apparent difference between Newton iteration and free power iteration seems to be the use of the Moose::SlepcSupport::setFreeNonlinearPowerIterations function, which modifies some Petsc parameters specifically for free power iteration. However, does this have any impact on the computation of eigenvalues? I couldn't find documentation for the Petsc parameter -eps_power_update on Google.\nI would appreciate any insights or clarification on how the free power iteration process is implemented in MOOSE. Thank you in advance for your assistance and responses!\nvoid\nEigenProblem::solve(const unsigned int nl_sys_num)\n{\n#if !PETSC_RELEASE_LESS_THAN(3, 12, 0)\n  // Master has the default database\n  if (!_app.isUltimateMaster())\n    PetscOptionsPush(_petsc_option_data_base);\n#endif\n\n  setCurrentNonlinearSystem(nl_sys_num);\n\n  if (_solve)\n  {\n    TIME_SECTION(\"solve\", 1);\n\n    // Set necessary slepc callbacks\n    // We delay this call as much as possible because libmesh\n    // could rebuild matrices due to mesh changes or something else.\n    _nl_eigen->attachSLEPcCallbacks();\n\n    // If there is an eigenvalue, we scale 1/|Bx| to eigenvalue\n    if (_active_eigen_index < _nl_eigen->getNumConvergedEigenvalues())\n    {\n      std::pair<Real, Real> eig = _nl_eigen->getConvergedEigenvalue(_active_eigen_index);\n      preScaleEigenVector(eig);\n    }\n\n    if (isNonlinearEigenvalueSolver() &&\n        solverParams()._eigen_solve_type != Moose::EST_NONLINEAR_POWER)\n    {\n      // Let do an initial solve if a nonlinear eigen solver but not power is used.\n      // The initial solver is a Inverse Power, and it is used to compute a good initial\n      // guess for Newton\n      if (solverParams()._free_power_iterations && _first_solve)\n      {\n        _console << std::endl << \" -------------------------------\" << std::endl;\n        _console << \" Free power iteration starts ...\" << std::endl;\n        _console << \" -------------------------------\" << std::endl << std::endl;\n        doFreeNonlinearPowerIterations(solverParams()._free_power_iterations);\n        _first_solve = false;\n      }\n\n      // Let us do extra power iterations here if necessary\n      if (solverParams()._extra_power_iterations)\n      {\n        _console << std::endl << \" --------------------------------------\" << std::endl;\n        _console << \" Extra Free power iteration starts ...\" << std::endl;\n        _console << \" --------------------------------------\" << std::endl << std::endl;\n        doFreeNonlinearPowerIterations(solverParams()._extra_power_iterations);\n      }\n    }\n\n    // We print this for only nonlinear solver\n    if (isNonlinearEigenvalueSolver())\n    {\n      _console << std::endl << \" -------------------------------------\" << std::endl;\n\n      if (solverParams()._eigen_solve_type != Moose::EST_NONLINEAR_POWER)\n        _console << \" Nonlinear Newton iteration starts ...\" << std::endl;\n      else\n        _console << \" Nonlinear power iteration starts ...\" << std::endl;\n\n      _console << \" -------------------------------------\" << std::endl << std::endl;\n    }\n\n    _current_nl_sys->solve();\n    _current_nl_sys->update();\n\n    // with PJFNKMO solve type, we need to evaluate the linear objects to bring them up-to-date\n    if (solverParams()._eigen_solve_type == Moose::EST_PJFNKMO)\n      execute(EXEC_LINEAR);\n\n    // Scale eigen vector if users ask\n    postScaleEigenVector();\n  }\n\n#if !PETSC_RELEASE_LESS_THAN(3, 12, 0)\n  if (!_app.isUltimateMaster())\n    PetscOptionsPop();\n#endif\n\n  // sync solutions in displaced problem\n  if (_displaced_problem)\n    _displaced_problem->syncSolutions();\n\n  // Reset the matrix flag, so that we reform matrix in next picard iteration\n  _matrices_formed = false;\n}\n\n\nvoid\nEigenProblem::doFreeNonlinearPowerIterations(unsigned int free_power_iterations)\n{\n  mooseAssert(_current_nl_sys, \"This needs to be non-null\");\n\n  doFreePowerIteration(true);\n  // Set free power iterations\n  Moose::SlepcSupport::setFreeNonlinearPowerIterations(free_power_iterations);\n\n  // Call solver\n  _current_nl_sys->solve();\n  _current_nl_sys->update();\n\n  // Clear free power iterations\n  auto executioner = getMooseApp().getExecutioner();\n  if (executioner)\n    Moose::SlepcSupport::clearFreeNonlinearPowerIterations(executioner->parameters());\n  else\n    mooseError(\"There is no executioner for this moose app\");\n\n  doFreePowerIteration(false);\n}\n\nvoid\nsetFreeNonlinearPowerIterations(unsigned int free_power_iterations)\n{\n  Moose::PetscSupport::setSinglePetscOption(\"-eps_power_update\", \"0\");\n  Moose::PetscSupport::setSinglePetscOption(\"-snes_max_it\", \"2\");\n  // During each power iteration, we want solver converged unless linear solver does not\n  // work. We here use a really loose tolerance for this purpose.\n  // -snes_no_convergence_test is a perfect option, but it was removed from PETSc\n  Moose::PetscSupport::setSinglePetscOption(\"-snes_rtol\", \"0.99999999999\");\n  Moose::PetscSupport::setSinglePetscOption(\"-eps_max_it\", stringify(free_power_iterations));\n  // We always want the number of free power iterations respected so we don't want to stop early if\n  // we've satisfied a convergence criterion. Consequently we make this tolerance very tight\n  Moose::PetscSupport::setSinglePetscOption(\"-eps_tol\", \"1e-50\");\n}",
          "url": "https://github.com/idaholab/moose/discussions/26380",
          "updatedAt": "2024-01-06T14:53:55Z",
          "publishedAt": "2023-12-20T14:58:21Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think you mostly answered the question with all the relevant code.\nWe do free power iterations by calling the same nonlinear eigenvalue system solve but with different parameters.\nThey go like:\nwe set max 2 non linear iterations (snes_max_it) so once we solve the nonlinear problem we update the eigenvalue and move on to the next power iteration\nwe set the non linear tolerance extra loose (with snes_rtol) to always accept the solution (so only 1 nonlinear iteration per power iteration in practice?)\nwe make sure not to go beyond the desired number of free power iterations (set from eps_max_it)\nwe use a really fine eigenvalue solver tolerance to avoid accepting too early (eps_tol)\nIt does seem a little hacky. Maybe if you pass some petsc versbose (ksp_view, snes_view) option we can look at a log and see how the solve goes?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26380#discussioncomment-7913824",
                  "updatedAt": "2023-12-21T02:31:41Z",
                  "publishedAt": "2023-12-21T02:31:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Dear Guillaume,\nFollowing your advice, I ran a case and added the 'petsc_options = -ksp_view -snes_view' input to the case's input file (input.i). The partial output, including one free power iteration and one Newton iteration (for readability, some information has been abbreviated; detailed output can be found at the end), is as follows:\nIteration 2 eigenvalue = 1.5781199155\n 0 Nonlinear |R| = 2.058230e+00\n      0 Linear |R| = 2.058230e+00\n      1 Linear |R| = 1.292650e+00\nKSP Object: 12 MPI processes\n  type: gmres\n  ...\n 1 Nonlinear |R| = 1.292650e+00\nSNES Object: 12 MPI processes\n  type: newtonls\n  ...\n Iteration 3 eigenvalue = 1.6852500568\n\n -------------------------------------\n Nonlinear Newton iteration starts ...\n -------------------------------------\n\n 0 Nonlinear |R| = 1.301606e+00\n Iteration 0 eigenvalue = 1.6852500568\n      0 Linear |R| = 1.301606e+00\n      1 Linear |R| = 9.687840e-01\nKSP Object: 12 MPI processes\n  type: gmres\n  ...\n 1 Nonlinear |R| = 9.685810e-01\n Iteration 1 eigenvalue = 1.7610308835\n\nWhat confuses me is that in the free power iteration, both SNES and KSP objects are invoked, with the SNES object using the nonlinear Newton method. Conversely, in the Newton iteration, only the KSP object is invoked. This appears to be the opposite of my understanding.\nDetailed output:\n Iteration 2 eigenvalue = 1.5781199155\n 0 Nonlinear |R| = 2.058230e+00\n      0 Linear |R| = 2.058230e+00\n      1 Linear |R| = 1.292650e+00\nKSP Object: 12 MPI processes\n  type: gmres\n    restart=30, using Classical (unmodified) Gram-Schmidt Orthogonalization with no iterative refinement\n    happy breakdown tolerance 1e-30\n  maximum iterations=500, initial guess is zero\n  tolerances:  relative=0.8, absolute=1e-50, divergence=10000.\n  right preconditioning\n  using UNPRECONDITIONED norm type for convergence test\nPC Object: 12 MPI processes\n  type: bjacobi\n    number of blocks = 12\n    Local solver information for first block is in the following KSP and PC objects on rank 0:\n    Use -ksp_view ::ascii_info_detail to display information for all blocks\n  KSP Object: (sub_) 1 MPI process\n    type: preonly\n    maximum iterations=10000, initial guess is zero\n    tolerances:  relative=1e-05, absolute=1e-50, divergence=10000.\n    left preconditioning\n    using NONE norm type for convergence test\n  PC Object: (sub_) 1 MPI process\n    type: ilu\n      out-of-place factorization\n      0 levels of fill\n      tolerance for zero pivot 2.22045e-14\n      matrix ordering: natural\n      factor fill ratio given 1., needed 1.\n        Factored matrix follows:\n          Mat Object: (sub_) 1 MPI process\n            type: seqaij\n            rows=419840, cols=419840, bs=160\n            package used to perform factorization: petsc\n            total: nonzeros=10516480, allocated nonzeros=10516480\n              using I-node routines: found 104960 nodes, limit used is 5\n    linear system matrix = precond matrix:\n    Mat Object: (sub_) 1 MPI process\n      type: seqaij\n      rows=419840, cols=419840, bs=160\n      total: nonzeros=10516480, allocated nonzeros=10516480\n      total number of mallocs used during MatSetValues calls=0\n        using I-node routines: found 104960 nodes, limit used is 5\n  linear system matrix followed by preconditioner matrix:\n  Mat Object: 12 MPI processes\n    type: mffd\n    rows=5120000, cols=5120000\n      Matrix-free approximation:\n        err=1.49012e-08 (relative error in function evaluation)\n        Using wp compute h routine\n            Does not compute normU\n  Mat Object: () 12 MPI processes\n    type: mpiaij\n    rows=5120000, cols=5120000, bs=160\n    total: nonzeros=137216000, allocated nonzeros=137216000\n    total number of mallocs used during MatSetValues calls=0\n      using I-node (on process 0) routines: found 104960 nodes, limit used is 5\n 1 Nonlinear |R| = 1.292650e+00\nSNES Object: 12 MPI processes\n  type: newtonls\n  maximum iterations=2, maximum function evaluations=10000\n  tolerances: relative=1., absolute=1e-09, solution=0.\n  total number of linear solver iterations=1\n  total number of function evaluations=4\n  norm schedule ALWAYS\n  Jacobian is applied matrix-free with differencing\n  SNESLineSearch Object: 12 MPI processes\n    type: bt\n      interpolation: cubic\n      alpha=1.000000e-04\n    maxstep=1.000000e+08, minlambda=1.000000e-12\n    tolerances: relative=1.000000e-08, absolute=1.000000e-15, lambda=1.000000e-08\n    maximum iterations=40\n  KSP Object: 12 MPI processes\n    type: gmres\n      restart=30, using Classical (unmodified) Gram-Schmidt Orthogonalization with no iterative refinement\n      happy breakdown tolerance 1e-30\n    maximum iterations=500, initial guess is zero\n    tolerances:  relative=0.8, absolute=1e-50, divergence=10000.\n    right preconditioning\n    using UNPRECONDITIONED norm type for convergence test\n  PC Object: 12 MPI processes\n    type: bjacobi\n      number of blocks = 12\n      Local solver information for first block is in the following KSP and PC objects on rank 0:\n      Use -ksp_view ::ascii_info_detail to display information for all blocks\n    KSP Object: (sub_) 1 MPI process\n      type: preonly\n      maximum iterations=10000, initial guess is zero\n      tolerances:  relative=1e-05, absolute=1e-50, divergence=10000.\n      left preconditioning\n      using NONE norm type for convergence test\n    PC Object: (sub_) 1 MPI process\n      type: ilu\n        out-of-place factorization\n        0 levels of fill\n        tolerance for zero pivot 2.22045e-14\n        matrix ordering: natural\n        factor fill ratio given 1., needed 1.\n          Factored matrix follows:\n            Mat Object: (sub_) 1 MPI process\n              type: seqaij\n              rows=419840, cols=419840, bs=160\n              package used to perform factorization: petsc\n              total: nonzeros=10516480, allocated nonzeros=10516480\n                using I-node routines: found 104960 nodes, limit used is 5\n      linear system matrix = precond matrix:\n      Mat Object: (sub_) 1 MPI process\n        type: seqaij\n        rows=419840, cols=419840, bs=160\n        total: nonzeros=10516480, allocated nonzeros=10516480\n        total number of mallocs used during MatSetValues calls=0\n          using I-node routines: found 104960 nodes, limit used is 5\n    linear system matrix followed by preconditioner matrix:\n    Mat Object: 12 MPI processes\n      type: mffd\n      rows=5120000, cols=5120000\n        Matrix-free approximation:\n          err=1.49012e-08 (relative error in function evaluation)\n          Using wp compute h routine\n              Does not compute normU\n    Mat Object: () 12 MPI processes\n      type: mpiaij\n      rows=5120000, cols=5120000, bs=160\n      total: nonzeros=137216000, allocated nonzeros=137216000\n      total number of mallocs used during MatSetValues calls=0\n        using I-node (on process 0) routines: found 104960 nodes, limit used is 5\n Iteration 3 eigenvalue = 1.6852500568\n\n -------------------------------------\n Nonlinear Newton iteration starts ...\n -------------------------------------\n\n 0 Nonlinear |R| = 1.301606e+00\n Iteration 0 eigenvalue = 1.6852500568\n      0 Linear |R| = 1.301606e+00\n      1 Linear |R| = 9.687840e-01\nKSP Object: 12 MPI processes\n  type: gmres\n    restart=30, using Classical (unmodified) Gram-Schmidt Orthogonalization with no iterative refinement\n    happy breakdown tolerance 1e-30\n  maximum iterations=500, initial guess is zero\n  tolerances:  relative=0.8, absolute=1e-50, divergence=10000.\n  right preconditioning\n  using UNPRECONDITIONED norm type for convergence test\nPC Object: 12 MPI processes\n  type: bjacobi\n    number of blocks = 12\n    Local solver information for first block is in the following KSP and PC objects on rank 0:\n    Use -ksp_view ::ascii_info_detail to display information for all blocks\n  KSP Object: (sub_) 1 MPI process\n    type: preonly\n    maximum iterations=10000, initial guess is zero\n    tolerances:  relative=1e-05, absolute=1e-50, divergence=10000.\n    left preconditioning\n    using NONE norm type for convergence test\n  PC Object: (sub_) 1 MPI process\n    type: ilu\n      out-of-place factorization\n      0 levels of fill\n      tolerance for zero pivot 2.22045e-14\n      matrix ordering: natural\n      factor fill ratio given 1., needed 1.\n        Factored matrix follows:\n          Mat Object: (sub_) 1 MPI process\n            type: seqaij\n            rows=419840, cols=419840, bs=160\n            package used to perform factorization: petsc\n            total: nonzeros=10516480, allocated nonzeros=10516480\n              using I-node routines: found 104960 nodes, limit used is 5\n    linear system matrix = precond matrix:\n    Mat Object: (sub_) 1 MPI process\n      type: seqaij\n      rows=419840, cols=419840, bs=160\n      total: nonzeros=10516480, allocated nonzeros=10516480\n      total number of mallocs used during MatSetValues calls=0\n        using I-node routines: found 104960 nodes, limit used is 5\n  linear system matrix followed by preconditioner matrix:\n  Mat Object: 12 MPI processes\n    type: mffd\n    rows=5120000, cols=5120000\n      Matrix-free approximation:\n        err=1.49012e-08 (relative error in function evaluation)\n        Using wp compute h routine\n            Does not compute normU\n  Mat Object: () 12 MPI processes\n    type: mpiaij\n    rows=5120000, cols=5120000, bs=160\n    total: nonzeros=137216000, allocated nonzeros=137216000\n    total number of mallocs used during MatSetValues calls=0\n      using I-node (on process 0) routines: found 104960 nodes, limit used is 5\n 1 Nonlinear |R| = 9.685810e-01\n Iteration 1 eigenvalue = 1.7610308835",
                          "url": "https://github.com/idaholab/moose/discussions/26380#discussioncomment-7917894",
                          "updatedAt": "2023-12-21T12:31:17Z",
                          "publishedAt": "2023-12-21T12:31:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We made a decision to always respect the user requested number of free power iterations based on this conversation: #25204 (comment)",
                          "url": "https://github.com/idaholab/moose/discussions/26380#discussioncomment-7921172",
                          "updatedAt": "2023-12-21T18:36:06Z",
                          "publishedAt": "2023-12-21T18:35:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "You should get SNES output from the nonlinear eigen solve at the end of the Newton iteration, e.g.\n11 Nonlinear |R| = 1.073733e-10\n Iteration 11 eigenvalue = 1.0063926406\nSNES Object: 1 MPI process\n  type: newtonls\n  maximum iterations=50, maximum function evaluations=10000\n  tolerances: relative=1e-08, absolute=2e-10, solution=0.\n  total number of linear solver iterations=132\n  total number of function evaluations=161\n  norm schedule ALWAYS\n  Jacobian is applied matrix-free with differencing\n  SNESLineSearch Object: 1 MPI process\n    type: bt\n      interpolation: cubic\n      alpha=1.000000e-04\n    maxstep=1.000000e+08, minlambda=1.000000e-12\n    tolerances: relative=1.000000e-08, absolute=1.000000e-15, lambda=1.000000e-08\n    maximum iterations=40\n  KSP Object: 1 MPI process\n    type: gmres\n      restart=30, using Classical (unmodified) Gram-Schmidt Orthogonalization with no iterative refinement\n      happy breakdown tolerance 1e-30\n    maximum iterations=10000, initial guess is zero\n    tolerances:  relative=0.01, absolute=1e-50, divergence=10000.\n    right preconditioning\n    using UNPRECONDITIONED norm type for convergence test\n  PC Object: 1 MPI process\n    type: ilu\n      out-of-place factorization\n      0 levels of fill\n      tolerance for zero pivot 2.22045e-14\n      matrix ordering: natural\n      factor fill ratio given 1., needed 1.\n        Factored matrix follows:\n          Mat Object: 1 MPI process\n            type: seqaij\n            rows=81, cols=81\n            package used to perform factorization: petsc\n            total: nonzeros=625, allocated nonzeros=625\n              not using I-node routines\n    linear system matrix followed by preconditioner matrix:\n    Mat Object: 1 MPI process\n      type: mffd\n      rows=81, cols=81\n        Matrix-free approximation:\n          err=1.49012e-08 (relative error in function evaluation)\n          Using wp compute h routine\n              Does not compute normU\n    Mat Object: () 1 MPI process\n      type: seqaij\n      rows=81, cols=81\n      total: nonzeros=625, allocated nonzeros=625\n      total number of mallocs used during MatSetValues calls=0\n        not using I-node routines\n\nSo basically immediately after where you \"cut\" your pasted output (I'm quoting \"cut\" because maybe you really don't see the SNES view output in which case something weird is going on)",
                          "url": "https://github.com/idaholab/moose/discussions/26380#discussioncomment-7921192",
                          "updatedAt": "2023-12-21T18:40:03Z",
                          "publishedAt": "2023-12-21T18:40:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you for your clarification. I did find information about SNES at the end of Newton iteration. However, I still have uncertainties regarding the implementation of free power iteration. For an eigenvalue problem represented as A(x) = 1/\u03bb * B(x), the system of equations that JFNK needs to solve during the Newton iteration is given by: R1(x, \u03bb) = A(x) - 1/\u03bb * B(x) = 0 and R2(x, \u03bb) = \u03bb - |B(x)| = 0. In contrast, during free power iteration, the system of equations that JFNK needs to solve includes only R1(x, \u03bb) = 0 (which, when material properties are constant, forms a linear system of equations). \u03bb is not determined through JFNK; instead, it is iteratively computed between nonlinear iterations as \u03bb^(n) = \u03bb^(n\u22121) * |B(x^(n))| / |B(x^(n\u22121))|. The computational process of free power iteration should be akin to the InversePowerMethod, but the specific calculation step \u03bb^(n) = \u03bb^(n\u22121) * |B(x^(n))| / |B(x^(n\u22121))| seems to be absent in the free power iteration.",
                          "url": "https://github.com/idaholab/moose/discussions/26380#discussioncomment-7927590",
                          "updatedAt": "2023-12-22T13:01:47Z",
                          "publishedAt": "2023-12-22T13:01:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The algorithm assumes and enforces your R2: lambda = |B(x)|, see e.g. line 458 of SLEPc's power.c:\n    else if (power->nonlinear) theta = 1.0/(norm*sign); /* Eigenvalue: 1/|Bx| */\nRecall that the eigenvalue is equal to 1/lambda as you have written lambda. So with R2 in mind, then the lambda update is always very simple because lambda^n / |B(x^n)| = lambda^(n - 1) / |B(x^(n-1))| = 1. So after you solve for the solution vector x^k, and compute B(x^k), then we assign lambda^k = |B(x^k)|",
                          "url": "https://github.com/idaholab/moose/discussions/26380#discussioncomment-7930379",
                          "updatedAt": "2023-12-22T19:09:41Z",
                          "publishedAt": "2023-12-22T19:09:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "Eigenvalue is eliminated in the system by letting the residual be R(x) = A(x) - B(x) / |B(x)|. Otherwise the understanding is correct. I was hoping to have two separate SLEPc functions for the power method and the newton method, but because they are so similar, they are implemented in SLEPc in the current way. It does complicate the interface between MOOSE and SLEPc. The reasoning of the residual formula can be found in https://mooseframework.inl.gov/source/executioners/InversePowerMethod.html and https://mooseframework.inl.gov/source/executioners/NonlinearEigen.html. Hope this helps.",
                          "url": "https://github.com/idaholab/moose/discussions/26380#discussioncomment-7967484",
                          "updatedAt": "2023-12-28T19:23:44Z",
                          "publishedAt": "2023-12-28T19:23:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you for your response. As a beginner, my subsequent questions might seem perplexing, and feel free to choose not to answer. I've recently posed numerous questions, taking up a considerable amount of time from experienced individuals like yourself. I don't want my inquiries to impose too much on your time.\nWhen you mentioned similarity, were you referring to their mathematical forms? I believe the primary distinction between the Newton method and power iteration lies in:\nIn the Newton method, the eigenvalue is also a variable to be solved in JFNK. Although we eliminate the eigenvalue variable lambda by defining R(x) = A(x) - B(x) / |B(x)|, it still influences the Jacobian matrix of the problem: J_newton = (A(x) - B(x) / |B(x)|)'\nHowever, in power iteration, the calculation of the eigenvalue (lambda) is independent of JFNK, resulting in a simpler Jacobian matrix: J_power = (A(x) - B(x) / lambda)', where lambda is a constant for JFNK.\nWe employ power iteration to provide a reasonable initial value for Newton iteration, but ultimately, this initial value is obtained using another Newton method (JFNK). This is the aspect that perplexes me the most.",
                          "url": "https://github.com/idaholab/moose/discussions/26380#discussioncomment-7973485",
                          "updatedAt": "2023-12-29T15:24:25Z",
                          "publishedAt": "2023-12-29T15:24:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Here is relevant code in SLEPc's EPSSetUp_Power:\n    if (power->update) {\n      PetscCall(SNESSetFunction(power->snes,res,EPSPowerFormFunction_Update,ctx));\n      PetscCall(PetscObjectQueryFunction((PetscObject)A,\"formFunctionAB\",&power->formFunctionAB));\n      PetscCall(SNESMonitorSet(power->snes,SNESMonitor_PowerUpdate,NULL,NULL));\n    }\n    else PetscCall(SNESSetFunction(power->snes,res,formFunctionA,ctx));\nand also\nstatic PetscErrorCode EPSPowerApply_SNES(EPS eps,Vec x,Vec y)\n{\n  EPS_POWER      *power = (EPS_POWER*)eps->data;\n  Vec            Bx;\n\n  PetscFunctionBegin;\n  PetscCall(VecCopy(x,y));\n  if (power->update) PetscCall(SNESSolve(power->snes,NULL,y));\n  else {\n    Bx = eps->work[2];\n    PetscCall(SNESSolve(power->snes,Bx,y));\n  }\n  PetscFunctionReturn(PETSC_SUCCESS);\n}\nSo when doing power iterations (this corresponds to !power->update), the SNES function is only A(x), and we solve A(x^(n)) = B(x^(n-1))/|B(x^(n-1)| (see the SNESSolve man page). However, when are doing full Newton (this corresponds to power->update), the SNES function includes both evaluations of A and B and solves A(x^(n)) - B(x^(n))/|B(x^(n)| = 0",
                          "url": "https://github.com/idaholab/moose/discussions/26380#discussioncomment-8027494",
                          "updatedAt": "2024-01-05T22:27:53Z",
                          "publishedAt": "2024-01-05T22:27:52Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Note that if you look through the SLEPc power code, B(x) is always normalized by |B(x)| such that in the code Bx always stands for B(x)/|B(x)|",
                          "url": "https://github.com/idaholab/moose/discussions/26380#discussioncomment-8027500",
                          "updatedAt": "2024-01-05T22:29:00Z",
                          "publishedAt": "2024-01-05T22:28:59Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Adding deformation gradient to AD version of computeStrain classes",
          "author": {
            "login": "srinath-chakravarthy"
          },
          "bodyText": "Hello all,\ndeformation_gradient is not available for the AD versions of the computeStrain classes but seem to be available to the non-AD versions. Any chance this can be included into the tensor_mechanics classes. I have a local implementation that i can perhaps spruce up and submit as a PR if necessary",
          "url": "https://github.com/idaholab/moose/discussions/26381",
          "updatedAt": "2024-01-05T18:01:34Z",
          "publishedAt": "2023-12-20T19:16:52Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@dschwen @gambka",
                  "url": "https://github.com/idaholab/moose/discussions/26381#discussioncomment-7913830",
                  "updatedAt": "2023-12-21T02:32:23Z",
                  "publishedAt": "2023-12-21T02:32:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "srinath-chakravarthy"
                          },
                          "bodyText": "Any update on this ?",
                          "url": "https://github.com/idaholab/moose/discussions/26381#discussioncomment-7996910",
                          "updatedAt": "2024-01-02T20:56:32Z",
                          "publishedAt": "2024-01-02T20:56:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "Do you have a PR where you add something like this to ADComputeIncrementalStrainBase.h:\nMaterialProperty<RankTwoTensor> & _deformation_gradient;\n\nand then copy in the all the code needed to compute _deformation_gradient[_qp] from ComputeFiniteStrain.C into ADComputeFiniteStrain.C?",
                          "url": "https://github.com/idaholab/moose/discussions/26381#discussioncomment-8018492",
                          "updatedAt": "2024-01-05T00:50:34Z",
                          "publishedAt": "2024-01-05T00:50:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "I do not have a PR, but i do have the code. Let me know what i need to do.\n\u2026\nOn Thu, Jan 4, 2024 at 7:50\u202fPM Lynn Munday ***@***.***> wrote:\n Do you have a PR where you add something like this to\n ADComputeIncrementalStrainBase.h:\n\n MaterialProperty<RankTwoTensor> & _deformation_gradient;\n\n and then copy in the all the code needed to compute\n _deformation_gradient[_qp] from ComputeFiniteStrain.C into\n ADComputeFiniteStrain.C?\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#26381 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ACYC6LKIXRHYVTCJWFYGYLDYM5E6JAVCNFSM6AAAAABA5JVMPCVHI2DSMVQWIX3LMV43SRDJONRXK43TNFXW4Q3PNVWWK3TUHM4DAMJYGQ4TE>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/26381#discussioncomment-8022597",
                  "updatedAt": "2024-01-05T12:15:24Z",
                  "publishedAt": "2024-01-05T12:15:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "I'm not sure how familiar you are with the moose process for merging code changes, there is probably a better explanation of this somewhere in the documentation or training but you need to do something like the following:\nFirst submit an issue to MOOSE for this enhancement using the github tab, you can look at a few others to see the format.  You need to create your own fork of moose.  Then you will create a branch on your fork of moose, push that branch to your github account and then create a pull request from your fork onto the inl labs moose repository.",
                          "url": "https://github.com/idaholab/moose/discussions/26381#discussioncomment-8025114",
                          "updatedAt": "2024-01-05T16:57:00Z",
                          "publishedAt": "2024-01-05T16:56:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "Then someone will review and merge it into the main repository.",
                          "url": "https://github.com/idaholab/moose/discussions/26381#discussioncomment-8025118",
                          "updatedAt": "2024-01-05T16:57:44Z",
                          "publishedAt": "2024-01-05T16:57:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is the page on how to contribute to MOOSE\nhttps://mooseframework.inl.gov/framework_development/index.html",
                          "url": "https://github.com/idaholab/moose/discussions/26381#discussioncomment-8025178",
                          "updatedAt": "2024-01-05T17:01:46Z",
                          "publishedAt": "2024-01-05T17:01:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "srinath-chakravarthy"
                  },
                  "bodyText": "Fantastic,\nWill work on this over the next few days and submit.\n\nCheers\nSrinath\n\u2026\nOn Fri, Jan 5, 2024 at 12:01\u202fPM Guillaume Giudicelli < ***@***.***> wrote:\n this is the page on how to contribute to MOOSE\n https://mooseframework.inl.gov/framework_development/index.html\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#26381 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/ACYC6LLBDIATYJ73TCAWTALYNAWYLAVCNFSM6AAAAABA5JVMPCVHI2DSMVQWIX3LMV43SRDJONRXK43TNFXW4Q3PNVWWK3TUHM4DAMRVGE3TQ>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/26381#discussioncomment-8025668",
                  "updatedAt": "2024-01-05T18:01:35Z",
                  "publishedAt": "2024-01-05T18:01:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "segfault when restarting a simulation from 'checkpoint'.",
          "author": {
            "login": "schakrabortygithub"
          },
          "bodyText": "Hi,\nI was trying to use the checkpoint feature to restart a crystal plasticity simulation. But on restart, simulation throws segfault error. The error seems to originate from 'CrystalPlasticityStressUpdateBase::calculateSchmidTensor'.\nHere is the basic input script to reproduce the problem:\n[Mesh]\n[./gmg]\n  type = GeneratedMeshGenerator\n  dim = 3\n  nx = 2\n  ny = 2\n  nz = 2\n  xmax = 0.1\n  ymax = 0.1\n  zmax = 0.01\n  elem_type = HEX8 #TET4\n [../]\n[]\n\n[Outputs]\n    file_base = Data_CP_Comp\n    csv = true\n    exodus = true\n  [./my_checkpoint]\n    type = Checkpoint\n    num_files = 2\n    interval = 5\n  [../]\n[]\n\n[Problem]\n  type = FEProblem\n  #solve = false\n  restart_file_base = Data_CP_Comp_cp/LATEST\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Modules/TensorMechanics/Master/all]\n  strain = FINITE\n  add_variables = true  \n[]\n\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensorCP\n    C_ijkl = '1.684e5 1.214e5 1.214e5 1.684e5 1.214e5 1.684e5 0.754e5 0.754e5 0.754e5'\n    fill_method = symmetric9\n  [../]\n  [./stress]\n    type = ComputeMultipleCrystalPlasticityStress\n    crystal_plasticity_models = 'trial_xtalpl'\n    tan_mod_type = exact\n    abs_tol = 1.0e-02\n  [../]\n  [./trial_xtalpl]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = input_slip_sys.inp\n  [../]\n[]\n\n[BCs]\n  [./BC_disp_x]\n    type = FunctionDirichletBC\n    variable = disp_x\n    boundary = 'bottom'\n    function = '0.0'\n  [../] \n  [./BC_disp_y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = 'top bottom'\n    function = '(0.0*x + (-0.1)*y + 0.0*z)*t'\n  [../]\n  [./BC_disp_z]\n    type = FunctionDirichletBC\n    variable = disp_z\n    boundary = 'bottom'\n    function = '0.0'\n  [../]\n[]\n\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK' #'NEWTON' 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_asm_overlap -sub_pc_type -ksp_type -ksp_gmres_restart'\n  petsc_options_value = ' asm      2              lu            gmres     200'\n  nl_rel_tol = 1e-5\n  nl_max_its = 10\n  l_tol = 1e-5\n  l_max_its = 50\n\n  dt = 0.002 #0.01\n  dtmin = 0.00001\n  dtmax = 0.02\n  end_time = 0.2\n[]\n\n\nHere is some useful information from the debugger:\nTime Step 0, time = 0.01\n\nTime Step 1, time = 0.012, dt = 0.002\nProcess 28121 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)\n    frame #0: 0x00000001041b6904 libtensor_mechanics-dbg.0.dylib`CrystalPlasticityStressUpdateBase::calculateSchmidTensor(this=0x0000000123856618, number_slip_systems=0x0000000123857320, plane_normal_vector=size=12, direction_vector=size=12, schmid_tensor=size=0, crysrot=0x0000000124a643c8) at CrystalPlasticityStressUpdateBase.C:414:32\n   411 \t    for (const auto j : make_range(LIBMESH_DIM))\n   412 \t      for (const auto k : make_range(LIBMESH_DIM))\n   413 \t      {\n-> 414 \t        schmid_tensor[i](j, k) = local_direction_vector[i](j) * local_plane_normal[i](k);\n   415 \t      }\n   416 \t  }\n   417 \t}\n(lldb) bt\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)\n  * frame #0: 0x00000001041b6904 libtensor_mechanics-dbg.0.dylib`CrystalPlasticityStressUpdateBase::calculateSchmidTensor(this=0x0000000123856618, number_slip_systems=0x0000000123857320, plane_normal_vector=size=12, direction_vector=size=12, schmid_tensor=size=0, crysrot=0x0000000124a643c8) at CrystalPlasticityStressUpdateBase.C:414:32\n    frame #1: 0x00000001041a9540 libtensor_mechanics-dbg.0.dylib`CrystalPlasticityStressUpdateBase::calculateFlowDirection(this=0x0000000123856618, crysrot=0x0000000124a643c8) at CrystalPlasticityStressUpdateBase.C:378:3\n    frame #2: 0x00000001041a8f7f libtensor_mechanics-dbg.0.dylib`ComputeMultipleCrystalPlasticityStress::updateStress(this=0x0000000123870e18, cauchy_stress=0x0000000124a7b9a8, jacobian_mult=0x000000012580cc00) at ComputeMultipleCrystalPlasticityStress.C:237:17\n    frame #3: 0x00000001041d02cc libtensor_mechanics-dbg.0.dylib`ComputeMultipleCrystalPlasticityStress::computeQpStress(this=0x0000000123870e18) at ComputeMultipleCrystalPlasticityStress.C:205:3\n    frame #4: 0x0000000103d82b3d libtensor_mechanics-dbg.0.dylib`ComputeGeneralStressBase::computeQpProperties(this=0x0000000123870e18) at ComputeGeneralStressBase.C:46:3\n    frame #5: 0x00000001094e7a58 libmoose-dbg.0.dylib`Material::computeProperties(this=0x0000000123870e18) at Material.C:132:7\n    frame #6: 0x000000010a1b1cd9 libmoose-dbg.0.dylib`void MaterialData::reinit<std::__1::vector<std::__1::shared_ptr<MaterialBase>, std::__1::allocator<std::__1::shared_ptr<MaterialBase> > > >(this=0x00000001249e45a0, mats=size=3) at MaterialData.h:313:10\n    frame #7: 0x000000010a1b1c46 libmoose-dbg.0.dylib`FEProblemBase::reinitMaterials(this=0x000000012500d418, blk_id=0, tid=0, swap_stateful=true) at FEProblemBase.C:3392:21\n    frame #8: 0x000000010ae186e6 libmoose-dbg.0.dylib`NonlinearThread::onElement(this=0x00007ffeefbf6e68, elem=0x0000000124a52010) at NonlinearThread.C:131:15\n    frame #9: 0x0000000109cff166 libmoose-dbg.0.dylib`ThreadedElementLoopBase<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> >::operator(this=0x00007ffeefbf6e68, range=0x0000000124b6a5e0, bypass_threading=false)(libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> const&, bool) at ThreadedElementLoopBase.h:248:9\n    frame #10: 0x000000010ae20ef1 libmoose-dbg.0.dylib`NonlinearThread::operator(this=0x00007ffeefbf6e68, range=0x0000000124b6a5e0, bypass_threading=false)(libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*> const&, bool) at NonlinearThread.C:60:42\n    frame #11: 0x000000010af406de libmoose-dbg.0.dylib`void libMesh::Threads::parallel_reduce<libMesh::StoredRange<libMesh::MeshBase::const_element_iterator, libMesh::Elem const*>, ComputeResidualThread>(range=0x0000000124b6a5e0, body=0x00007ffeefbf6e68) at threads_pthread.h:380:5\n    frame #12: 0x000000010af37c79 libmoose-dbg.0.dylib`NonlinearSystemBase::computeResidualInternal(this=0x000000012500fa18, tags=size=3) at NonlinearSystemBase.C:1569:5\n    frame #13: 0x000000010af35569 libmoose-dbg.0.dylib`NonlinearSystemBase::computeResidualTags(this=0x000000012500fa18, tags=size=3) at NonlinearSystemBase.C:781:5\n    frame #14: 0x000000010a09ed49 libmoose-dbg.0.dylib`FEProblemBase::computeResidualTags(this=0x000000012500d418, tags=size=3) at FEProblemBase.C:6395:20\n    frame #15: 0x000000010a09cfc7 libmoose-dbg.0.dylib`FEProblemBase::computeResidualInternal(this=0x000000012500d418, soln=0x00000001249f8d20, residual=0x00000001249f9730, tags=size=3) at FEProblemBase.C:6241:5\n    frame #16: 0x000000010a09b713 libmoose-dbg.0.dylib`FEProblemBase::computeResidual(this=0x000000012500d418, soln=0x00000001249f8d20, residual=0x00000001249f9730, nl_sys_num=0) at FEProblemBase.C:6012:3\n    frame #17: 0x000000010a0e11bc libmoose-dbg.0.dylib`FEProblemBase::computeResidualSys(this=0x000000012500d418, sys=0x00000001249f9340, soln=0x00000001249f8d20, residual=0x00000001249f9730) at FEProblemBase.C:5979:3\n    frame #18: 0x000000010af666b6 libmoose-dbg.0.dylib`NonlinearSystem::solve(this=0x000000012500fa18) at NonlinearSystem.C:147:17\n    frame #19: 0x000000010a1033f7 libmoose-dbg.0.dylib`FEProblemBase::solve(this=0x000000012500d418, nl_sys_num=0) at FEProblemBase.C:5672:22\n    frame #20: 0x000000010941af65 libmoose-dbg.0.dylib`FEProblemSolve::solve(this=0x000000012500c6a8) at FEProblemSolve.C:284:14\n    frame #21: 0x0000000109414f65 libmoose-dbg.0.dylib`FixedPointSolve::solveStep(this=0x0000000124b2bcd0, begin_norm=0x0000000122cfc990, end_norm=0x0000000122efc290, transformed_dofs=size=0) at FixedPointSolve.C:426:22\n    frame #22: 0x00000001094129be libmoose-dbg.0.dylib`FixedPointSolve::solve(this=0x0000000124b2bcd0) at FixedPointSolve.C:278:28\n    frame #23: 0x000000010ac33bcd libmoose-dbg.0.dylib`TimeStepper::step(this=0x0000000122e16168) at TimeStepper.C:168:52\n    frame #24: 0x0000000109418987 libmoose-dbg.0.dylib`Transient::takeStep(this=0x000000012500c418, input_dt=-1) at Transient.C:430:18\n    frame #25: 0x0000000109425429 libmoose-dbg.0.dylib`Transient::execute(this=0x000000012500c418) at Transient.C:305:5\n    frame #26: 0x000000010b4c3bc0 libmoose-dbg.0.dylib`MooseApp::executeExecutioner(this=0x0000000123854418) at MooseApp.C:1142:19\n    frame #27: 0x000000010b4bba0a libmoose-dbg.0.dylib`MooseApp::run(this=0x0000000123854418) at MooseApp.C:1517:5\n    frame #28: 0x0000000100011d75 moose_discoflux-dbg`main(argc=3, argv=0x00007ffeefbfd990) at main.C:33:8\n    frame #29: 0x00007fff20519f3d libdyld.dylib`start + 1\n(lldb) p schmid_tensor[i](j, k)\nerror: Couldn't apply expression side effects : Couldn't dematerialize a result variable: couldn't read its memory\n(lldb) p local_direction_vector[i](j)\n(double) $1 = 0\n(lldb) p local_plane_normal[i](k)\n(double) $2 = 0.57735026918962584\n\nWhen simulation is run from the beginning, without any error, the arguments to the function call 'calculateSchmidTensor' is:\nTime Step 1, time = 0.002, dt = 0.002\nProcess 28502 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x00000001041b6830 libtensor_mechanics-dbg.0.dylib`CrystalPlasticityStressUpdateBase::calculateSchmidTensor(this=0x0000000127008618, number_slip_systems=0x0000000127009320, plane_normal_vector=size=12, direction_vector=size=12, schmid_tensor=size=12, crysrot=0x0000000122e2ec98) at CrystalPlasticityStressUpdateBase.C:414:57\n   411 \t    for (const auto j : make_range(LIBMESH_DIM))\n   412 \t      for (const auto k : make_range(LIBMESH_DIM))\n   413 \t      {\n-> 414 \t        schmid_tensor[i](j, k) = local_direction_vector[i](j) * local_plane_normal[i](k);\n   415 \t      }\n   416 \t  }\n   417 \t}\n\nNot sure why during restart 'schmid_tensor=size=0'. The correct one is 'schmid_tensor=size=12'.\nBest\nSubhendu Chakraborty",
          "url": "https://github.com/idaholab/moose/discussions/26449",
          "updatedAt": "2024-01-05T15:28:34Z",
          "publishedAt": "2024-01-02T16:06:38Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "schakrabortygithub"
                  },
                  "bodyText": "problem seems to be from resizing the state variables, stateVarible[_qp].resize(_number_slip_systems), inside initQpStatefulProperties(). The function initQpStatefulProperties() is not getting called when simulation is restarted from a checkpoint.",
                  "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-7997123",
                  "updatedAt": "2024-01-02T21:35:24Z",
                  "publishedAt": "2024-01-02T21:35:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "I've confirmed this issue on my end with a generic regression test modification. I have in the past been able to successfully run restart simulations with the crystal plasticity capability, so I suspect a recent-ish change. Thanks for reporting the issue.\nWe also definitely take pull requests, if you are able to track down the issue quicker!",
                          "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-7997292",
                          "updatedAt": "2024-01-02T22:04:17Z",
                          "publishedAt": "2024-01-02T22:04:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Issue posted in #26458",
                          "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-7997353",
                          "updatedAt": "2024-01-02T22:14:43Z",
                          "publishedAt": "2024-01-02T22:14:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "I did not recall if I used the restart before. @sapitts do you remember when was last time you were able to use the restart?",
                          "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-7997387",
                          "updatedAt": "2024-01-02T22:22:17Z",
                          "publishedAt": "2024-01-02T22:22:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "May or June of 2023 I believe. Even if my use was further back, I do view the restart capability as necessary, so hopefully it won't be too challenging to sort out what changed.....if the affecting change was outside of the crystal plasticity material classes, then it will be a lot more difficult",
                          "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-7997401",
                          "updatedAt": "2024-01-02T22:30:01Z",
                          "publishedAt": "2024-01-02T22:25:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "schakrabortygithub"
                          },
                          "bodyText": "@sapitts @jiangwen84\nI have fixed the issue. I will create a pull request.",
                          "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-8014001",
                          "updatedAt": "2024-01-04T15:27:03Z",
                          "publishedAt": "2024-01-04T15:27:02Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Please add a regression test that uses the restart capability so that we have a better way to maintain this capability in the future",
                          "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-8014034",
                          "updatedAt": "2024-01-04T15:30:07Z",
                          "publishedAt": "2024-01-04T15:30:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "@schakrabortygithub Great!  Could you ping me when you submit your PR? thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-8016977",
                          "updatedAt": "2024-01-04T20:44:07Z",
                          "publishedAt": "2024-01-04T20:44:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "schakrabortygithub"
                          },
                          "bodyText": "@jiangwen84 @sapitts\nI created the pull Request. #26485",
                          "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-8020779",
                          "updatedAt": "2024-01-05T08:41:04Z",
                          "publishedAt": "2024-01-05T08:41:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Thank you @schakrabortygithub! I've asked @loganharbour to take the first review pass, since he is the restart expert, and I and/or Wen will add our comments after that",
                          "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-8024351",
                          "updatedAt": "2024-01-05T15:28:35Z",
                          "publishedAt": "2024-01-05T15:28:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "initQpStatefulProperties() is not to be called when restarting from a statepoint. This is intentional.\nWe currently require that no new material properties be introduced on restart. Thus, the previous state is to be used.",
                  "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-8017909",
                  "updatedAt": "2024-01-04T22:57:07Z",
                  "publishedAt": "2024-01-04T22:57:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "that makes sense: not recalling initQpStatefulProperties() on restart. Do you know why the non-stateful (e.g. no Old material property requested) material properties lost their size on restart? Is that intentional?",
                          "url": "https://github.com/idaholab/moose/discussions/26449#discussioncomment-8017941",
                          "updatedAt": "2024-01-04T23:03:09Z",
                          "publishedAt": "2024-01-04T23:03:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Grand potential Phase field model coupled with mechanics",
          "author": {
            "login": "mishkat1096"
          },
          "bodyText": "Hi,\nI am trying to use Grand potential phase-field model to simulate a binary phase material. I want to include the elastic energy from the interface in the calculation.\nIs there a similar example to begin with?\nI have seen mechanics coupled KKS model but not grand potential model.\nThanks\nMishkat",
          "url": "https://github.com/idaholab/moose/discussions/20751",
          "updatedAt": "2024-01-05T14:56:00Z",
          "publishedAt": "2022-04-08T19:45:52Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can have a look at this test\nhttps://github.com/idaholab/moose/blob/next/modules/phase_field/test/tests/phase_field_kernels/ACInterfaceStress.i\n@SudiptaBiswas do you know of another example?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/20751#discussioncomment-2568299",
                  "updatedAt": "2022-06-14T08:45:14Z",
                  "publishedAt": "2022-04-14T16:54:14Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "@mishkat1096 You probably should take a look at this paper first, https://doi.org/10.1016/j.commatsci.2020.109790",
                          "url": "https://github.com/idaholab/moose/discussions/20751#discussioncomment-2568360",
                          "updatedAt": "2022-06-14T08:52:54Z",
                          "publishedAt": "2022-04-14T17:00:38Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mishkat1096"
                          },
                          "bodyText": "Thanks for the help.",
                          "url": "https://github.com/idaholab/moose/discussions/20751#discussioncomment-2569451",
                          "updatedAt": "2022-06-14T08:52:54Z",
                          "publishedAt": "2022-04-14T20:23:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "THOMPSONFLORIDA"
                          },
                          "bodyText": "@mishkat1096\nplease can i have a copy of the kks phase field coupled with elastic energy\nthompsonigunma@ufl.edu",
                          "url": "https://github.com/idaholab/moose/discussions/20751#discussioncomment-8024073",
                          "updatedAt": "2024-01-05T14:56:00Z",
                          "publishedAt": "2024-01-05T14:56:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to get old value or time derivative of a defined ADMaterial property?",
          "author": {
            "login": "SomnusYu"
          },
          "bodyText": "Hi all,\nI would like to calculate the time derivative of a defined ADMaterial property. But I can not use adCoupledDot like coupledVar. Then, I try to calculate the time derivative use: (material_current - material_old)/_dt. But I can not get old value of ADMaterial, since getADMaterialPropertyOld does not exist. So, what should I do? Using getMaterialPropertyOld? But it is for non-AD material.\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/26475",
          "updatedAt": "2024-01-05T11:51:52Z",
          "publishedAt": "2024-01-04T06:48:44Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Yes, you can use getMaterialPropertyOld for both AD and non-AD material properties since the old state is guaranteed to not depend on the nonlinear system degrees of freedom",
                  "url": "https://github.com/idaholab/moose/discussions/26475#discussioncomment-8019582",
                  "updatedAt": "2024-01-05T04:50:51Z",
                  "publishedAt": "2024-01-05T04:50:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/26475#discussioncomment-8019625",
                          "updatedAt": "2024-01-05T05:02:27Z",
                          "publishedAt": "2024-01-05T05:02:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "Hi,\nI used the getMaterialPropertyOld to get the value of material_old and then calculated as: (material_current - material_old)/_dt.\nBut some warnings occurred:\n\nDo these warnings matter? Can I ignore these warnings?",
                          "url": "https://github.com/idaholab/moose/discussions/26475#discussioncomment-8020869",
                          "updatedAt": "2024-01-05T08:51:43Z",
                          "publishedAt": "2024-01-05T08:51:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "initQpStatefulProperties is used to define the inital value of the property. So that's the very first value of material_old for example.\nYou can ignore them if the initial value is 0. But it s not best practice.",
                          "url": "https://github.com/idaholab/moose/discussions/26475#discussioncomment-8021379",
                          "updatedAt": "2024-01-05T09:55:35Z",
                          "publishedAt": "2024-01-05T09:55:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SomnusYu"
                          },
                          "bodyText": "ok",
                          "url": "https://github.com/idaholab/moose/discussions/26475#discussioncomment-8022400",
                          "updatedAt": "2024-01-05T11:51:49Z",
                          "publishedAt": "2024-01-05T11:51:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}