{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0xMi0xMlQxNTo1NDoyMS0wNjowMM4ARt1A"
    },
    "edges": [
      {
        "node": {
          "title": "Test errors",
          "author": {
            "login": "felixcrazzolara"
          },
          "bodyText": "I tried to build Moose on an Ubuntu 20.04 distribution and exactly followed the install instructions. All steps went smoothly without errors, except for the following tests failing:\nmisc/hit_cli.find/parameter_exists ........................................................... FAILED (CODE 1)\nmisc/hit_cli.find/parameter_does_not_exist ................................................... FAILED (CODE 1)\nmisc/hit_cli.find/positive_pattern ........................................................... FAILED (CODE 1)\nmisc/hit_cli.find/negative_pattern ........................................................... FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern ......................................................... FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern_negative ................................................ FAILED (CODE 1)\nmisc/hit_cli.merge ........................................................................... FAILED (CODE 1)\nmisc/hit_cli.diff/vanilla .................................................................... FAILED (CODE 1)\nmisc/hit_cli.diff/color ...................................................................... FAILED (CODE 1)\nmisc/hit_cli.diff/verbose .................................................................... FAILED (CODE 1)\nmisc/hit_cli.diff/verbose_color .............................................................. FAILED (CODE 1)\nmisc/hit_cli.diff/common ..................................................................... FAILED (CODE 1)\n\nAny ideas on how to solve this? Is this even relevant?",
          "url": "https://github.com/idaholab/moose/discussions/22760",
          "updatedAt": "2023-01-03T23:19:26Z",
          "publishedAt": "2022-11-19T14:44:13Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis could be. Could you please paste the failure log for each test?\nYou may regenerate it quicker with\n./run_tests --failed-tests\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22760#discussioncomment-4184454",
                  "updatedAt": "2022-11-19T14:54:01Z",
                  "publishedAt": "2022-11-19T14:54:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "felixcrazzolara"
                          },
                          "bodyText": "Hello Guillaume\nThank you for your fast response. This is the output of './run_tests --failed-tests':\nmisc/hit_cli.find/parameter_exists: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/parameter_exists: Running command: ./hit_wrapper.py gold/parameter_exists find Kernels/\\*/variable input1.i input2.i\nmisc/hit_cli.find/parameter_exists: Failed to locate hit executable.\nmisc/hit_cli.find/parameter_exists: \nmisc/hit_cli.find/parameter_exists: ################################################################################\nmisc/hit_cli.find/parameter_exists: Tester failed, reason: CODE 1\nmisc/hit_cli.find/parameter_exists: \nmisc/hit_cli.find/parameter_exists ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/parameter_does_not_exist: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/parameter_does_not_exist: Running command: ./hit_wrapper.py gold/parameter_does_not_exist find -v Kernels/\\*/variable input1.i input2.i\nmisc/hit_cli.find/parameter_does_not_exist: Failed to locate hit executable.\nmisc/hit_cli.find/parameter_does_not_exist: \nmisc/hit_cli.find/parameter_does_not_exist: ################################################################################\nmisc/hit_cli.find/parameter_does_not_exist: Tester failed, reason: CODE 1\nmisc/hit_cli.find/parameter_does_not_exist: \nmisc/hit_cli.find/parameter_does_not_exist ........................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/positive_pattern: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/positive_pattern: Running command: ./hit_wrapper.py gold/positive_pattern find Kernels/\\*/variable=u input1.i\nmisc/hit_cli.find/positive_pattern: Failed to locate hit executable.\nmisc/hit_cli.find/positive_pattern: \nmisc/hit_cli.find/positive_pattern: ################################################################################\nmisc/hit_cli.find/positive_pattern: Tester failed, reason: CODE 1\nmisc/hit_cli.find/positive_pattern: \nmisc/hit_cli.find/positive_pattern ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/negative_pattern: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/negative_pattern: Running command: ./hit_wrapper.py gold/positive_pattern find Kernels/\\*/variable!=v input1.i\nmisc/hit_cli.find/negative_pattern: Failed to locate hit executable.\nmisc/hit_cli.find/negative_pattern: \nmisc/hit_cli.find/negative_pattern: ################################################################################\nmisc/hit_cli.find/negative_pattern: Tester failed, reason: CODE 1\nmisc/hit_cli.find/negative_pattern: \nmisc/hit_cli.find/negative_pattern ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/additional_pattern: Running command: ./hit_wrapper.py gold/additional_pattern find -p type=DirichletBC -- \\*/value input1.i input2.i\nmisc/hit_cli.find/additional_pattern: Failed to locate hit executable.\nmisc/hit_cli.find/additional_pattern: \nmisc/hit_cli.find/additional_pattern: ################################################################################\nmisc/hit_cli.find/additional_pattern: Tester failed, reason: CODE 1\nmisc/hit_cli.find/additional_pattern: \nmisc/hit_cli.find/additional_pattern .............................. [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern_negative: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.find/additional_pattern_negative: Running command: ./hit_wrapper.py gold/additional_pattern_negative find -p type!=DirichletBC -- \\*/value input1.i input2.i\nmisc/hit_cli.find/additional_pattern_negative: Failed to locate hit executable.\nmisc/hit_cli.find/additional_pattern_negative: \nmisc/hit_cli.find/additional_pattern_negative: ################################################################################\nmisc/hit_cli.find/additional_pattern_negative: Tester failed, reason: CODE 1\nmisc/hit_cli.find/additional_pattern_negative: \nmisc/hit_cli.find/additional_pattern_negative ..................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.merge: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.merge: Running command: ./hit_wrapper.py gold/merge merge -output - input1.i input2.i\nmisc/hit_cli.merge: Failed to locate hit executable.\nmisc/hit_cli.merge: \nmisc/hit_cli.merge: ################################################################################\nmisc/hit_cli.merge: Tester failed, reason: CODE 1\nmisc/hit_cli.merge: \nmisc/hit_cli.merge ................................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/vanilla: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.diff/vanilla: Running command: ./hit_wrapper.py gold/diff_vanilla diff input1.i input2.i\nmisc/hit_cli.diff/vanilla: Failed to locate hit executable.\nmisc/hit_cli.diff/vanilla: \nmisc/hit_cli.diff/vanilla: ################################################################################\nmisc/hit_cli.diff/vanilla: Tester failed, reason: CODE 1\nmisc/hit_cli.diff/vanilla: \nmisc/hit_cli.diff/vanilla ......................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/color: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.diff/color: Running command: ./hit_wrapper.py gold/diff_color diff -color input1.i input2.i\nmisc/hit_cli.diff/color: Failed to locate hit executable.\nmisc/hit_cli.diff/color: \nmisc/hit_cli.diff/color: ################################################################################\nmisc/hit_cli.diff/color: Tester failed, reason: CODE 1\nmisc/hit_cli.diff/color: \nmisc/hit_cli.diff/color ........................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/verbose: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.diff/verbose: Running command: ./hit_wrapper.py gold/diff_verbose diff -v input1.i input2.i\nmisc/hit_cli.diff/verbose: Failed to locate hit executable.\nmisc/hit_cli.diff/verbose: \nmisc/hit_cli.diff/verbose: ################################################################################\nmisc/hit_cli.diff/verbose: Tester failed, reason: CODE 1\nmisc/hit_cli.diff/verbose: \nmisc/hit_cli.diff/verbose ......................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/verbose_color: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.diff/verbose_color: Running command: ./hit_wrapper.py gold/diff_verbose_color diff -v -color input1.i input2.i\nmisc/hit_cli.diff/verbose_color: Failed to locate hit executable.\nmisc/hit_cli.diff/verbose_color: \nmisc/hit_cli.diff/verbose_color: ################################################################################\nmisc/hit_cli.diff/verbose_color: Tester failed, reason: CODE 1\nmisc/hit_cli.diff/verbose_color: \nmisc/hit_cli.diff/verbose_color ................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/common: Working Directory: /home/felix/git/moose/test/tests/misc/hit_cli\nmisc/hit_cli.diff/common: Running command: ./hit_wrapper.py gold/diff_common diff -common input1.i input2.i\nmisc/hit_cli.diff/common: Failed to locate hit executable.\nmisc/hit_cli.diff/common: \nmisc/hit_cli.diff/common: ################################################################################\nmisc/hit_cli.diff/common: Tester failed, reason: CODE 1\nmisc/hit_cli.diff/common: \nmisc/hit_cli.diff/common .......................................... [previous results: CODE 1] FAILED (CODE 1)\n\n\nFinal Test Results:\n--------------------------------------------------------------------------------------------------------------\nmisc/hit_cli.find/parameter_exists ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/parameter_does_not_exist ........................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/positive_pattern ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/negative_pattern ................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern .............................. [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.find/additional_pattern_negative ..................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.merge ................................................ [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/vanilla ......................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/color ........................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/verbose ......................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/verbose_color ................................... [previous results: CODE 1] FAILED (CODE 1)\nmisc/hit_cli.diff/common .......................................... [previous results: CODE 1] FAILED (CODE 1)\n--------------------------------------------------------------------------------------------------------------\nRan 12 tests in 2.8 seconds. Average test time 0.0 seconds, maximum test time 0.0 seconds.\n0 passed, 0 skipped, 0 pending, 12 FAILED",
                          "url": "https://github.com/idaholab/moose/discussions/22760#discussioncomment-4187651",
                          "updatedAt": "2022-11-20T10:09:45Z",
                          "publishedAt": "2022-11-20T10:09:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It seems the hit (input file parser) executable did not build.\nYou can try to rebuild moose, see if it builds it this time\nYou can also build it directly in moose/framework/contrib/hit",
                          "url": "https://github.com/idaholab/moose/discussions/22760#discussioncomment-4189057",
                          "updatedAt": "2022-11-20T16:06:53Z",
                          "publishedAt": "2022-11-20T16:06:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Maohua10"
                          },
                          "bodyText": "Hi Guillaume, I also had some failed tests, although most of the test succeeded...\nDo you maybe what can be wrong? Thank you in advance!",
                          "url": "https://github.com/idaholab/moose/discussions/22760#discussioncomment-4437914",
                          "updatedAt": "2022-12-17T14:45:08Z",
                          "publishedAt": "2022-12-17T14:45:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "These are consistent with issues with the hit parser. Can you paste the log for the tests instead of the summary please",
                          "url": "https://github.com/idaholab/moose/discussions/22760#discussioncomment-4438114",
                          "updatedAt": "2022-12-17T15:38:39Z",
                          "publishedAt": "2022-12-17T15:38:38Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to define the grain boundary area between grains",
          "author": {
            "login": "Nuwanted"
          },
          "bodyText": "Dear MOOSE experts,\nRecently, I wanted to simulate the evolution of the void in the polycrystalline material, and different nonconservative order parameters are used to represent different grains. When I use the block function to distinguish different grains and give them different surface mobility, void cannot evolve. Why? Is it because the grain boundary area is not defined?\nAny suggestions or recommendations to fix the problem would be greatly appreciated.",
          "url": "https://github.com/idaholab/moose/discussions/22870",
          "updatedAt": "2023-01-03T23:59:18Z",
          "publishedAt": "2022-12-05T12:33:25Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@permcody",
                  "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4312906",
                  "updatedAt": "2022-12-05T12:46:27Z",
                  "publishedAt": "2022-12-05T12:46:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "Bumping @permcody again.",
                          "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4361613",
                          "updatedAt": "2022-12-10T07:11:36Z",
                          "publishedAt": "2022-12-10T07:11:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "permcody"
                  },
                  "bodyText": "I'm not sure I understand exactly what you are doing here. Are you starting from some of our polycrystal examples or tests? We have a robust capability that allows you to identify each grain separately so that you can apply different attributes to each grain, which affect the Cahn-Hillard equations, which in turn impact your grain evolution. Normally in phase-field, we don't directly define the grain boundary area. Those quantities are calculated as by-product of solving the phase-field equations. We have a VectorPostprocessor that can inspect your converged solution and can calculate those quantities. I recommend you take a look at the examples here: https://github.com/idaholab/moose/tree/next/modules/phase_field/examples\nand perhaps the integration tests as well: https://github.com/idaholab/moose/tree/next/modules/phase_field/test/tests",
                  "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4402802",
                  "updatedAt": "2022-12-14T18:13:46Z",
                  "publishedAt": "2022-12-14T18:13:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Nuwanted"
                          },
                          "bodyText": "Thank you for your reply, I mean that I use two nonconservative variables eta1 and eta2 to represent two different grains. The internal variable value of the grain is 1, the external variable value is 0, and the grain boundary changes from 1 to 0. I want to distinguish different grains by variable values. Some of my code is as follows:\nInputParameters\nANisotropicForth::validParams()\n{\nParams.addRequiredCoupledVar(\"nop1\", \"nonconservtion Order parameter 1 \");\nParams.addRequiredCoupledVar(\"nop2\", \"nonconservtion Order parameter 2 \");\nreturn Params;\nreturn Params;\n}\nANisotropicForth::ANisotropicForth(const InputParameters & Parameters)\n: Material(Parameters),\n// Get the parameters from the input file\n_nop1(coupledValue(\"nop1\")),\n_nop2(coupledValue(\"nop2\"))\nif (0 < _nop1 < 1 & _nop2 = 0 & _nop1 = 0)\n{\n// Calculate  function of mobility\n\t_fun[_qp] = ((_delta1 * std::pow(cos(_j1 * (angle + _theta0 * libMesh::pi / 180)), 2.0) + 1.0) / (1.0 + _delta1));\n\nNop1 and nop2 represent eta1 and eta2 respectively. When I compile, Moose prompts me that nop does not match the<symbol. Why?",
                          "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4410170",
                          "updatedAt": "2022-12-15T13:26:36Z",
                          "publishedAt": "2022-12-15T13:26:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I've never written 0 < _nop1 < 1 in C++. Is that allowed?\nThis is definitely problematic:\nif (..... _nop2 = 0)\nit should be ==\nBut it does not make sense to check if nop1 is between 0 and 1, excluding 0, and at the same time nop1 =0 . These are mutually exclusive",
                          "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4410771",
                          "updatedAt": "2022-12-15T14:43:13Z",
                          "publishedAt": "2022-12-15T14:42:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "permcody"
                          },
                          "bodyText": "0 < _nop1 < 1 is an expression, but definitely not the one you want for any language. Your compiler should be screaming at you. Please fix your logic and see if that fixes your issue. You need to split that expression into two expressions. Also \"&\" should be \"&&\". I count no fewer than 6 bugs in that one line of code!",
                          "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4411950",
                          "updatedAt": "2022-12-15T17:02:26Z",
                          "publishedAt": "2022-12-15T17:02:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Nuwanted"
                          },
                          "bodyText": "Sorry, I am not familiar with the writing of C language, I will carefully modify my code, thank you very much for your reply.",
                          "url": "https://github.com/idaholab/moose/discussions/22870#discussioncomment-4437303",
                          "updatedAt": "2022-12-17T11:54:37Z",
                          "publishedAt": "2022-12-17T11:54:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Printout of Jacobian/Residual",
          "author": {
            "login": "joe61vette"
          },
          "bodyText": "I am trying to debug an app.  The contributions to the residuals from my kernels appear to be correct.  I am using AD to form the jacobian.  I did run  analyzejacobian and got \"No errors detected.  :-)\".  [of course, thanks to the AD system]\nBut something must not be quite right as I don't get the same results as for a hand calculation. I have seen a Moose developer show a printout of the jacobian for a small test problem (see below).  How can I do this?\n  SVD: condition number 2.441843322518e+11, 0 of 9 singular values are (nearly) zero\n  SVD: singular values:\n         1.501529298631e+06   1.038973912264e+06   3.701408259763e+05   4.668696900287e+01   1.192502051978e+01  \n         2.869699441978e+00   8.516552976210e-06   7.377570511006e-06   6.149163153854e-06  \n  0 Linear |R| = 2.824152e-04\n  1 Linear |R| = 4.153350e-13\n\nMat Object: () 1 MPI process\ntype: seqaij\nrow 0: (0, 583.966)  (1, 0.000186027)  (2, 0.000510781)  (3, -581.157)  (4, -0.000186357)  (5, 0.499837)\nrow 1: (0, 4221.37)  (1, 0.00139813)  (2, 0.0180354)  (3, -4224.11)  (4, -0.00135452)  (5, 3.63304)\nrow 2: (0, -833398.)  (1, -0.267009)  (2, 1437.37)  (3, 832664.)  (4, 0.267006)  (5, -716.151)\nrow 3: (0, -581.162)  (1, -0.000186357)  (2, -0.500163)  (3, 1165.65)  (4, 0.000372714)  (5, 0.00032579)  (6, -581.154)  (7, -0.000186357)  (8, 0.499837)\nrow 4: (0, -4233.51)  (1, -0.00136985)  (2, -3.64972)  (3, 8457.57)  (4, 0.00275771)  (5, 0.0166714)  (6, -4224.07)  (7, -0.00135452)  (8, 3.63302)\nrow 5: (0, -833558.)  (1, -0.26775)  (2, -717.614)  (3, 883.188)  (4, 0.000743158)  (5, 1437.09)  (6, 832654.)  (7, 0.267005)  (8, -716.147)\nrow 6: (3, -581.157)  (4, -0.000186357)  (5, -0.500163)  (6, 1165.14)  (7, 0.000372715)  (8, 0.499976)\nrow 7: (3, -4233.46)  (4, -0.00136985)  (5, -3.64971)  (6, 8453.85)  (7, 0.0027577)  (8, 3.64832)\nrow 8: (3, -833547.)  (4, -0.267749)  (5, -717.609)  (6, 1600.23)  (7, 0.000743599)  (8, 721.21)\nThanks,\nJoe Kelly",
          "url": "https://github.com/idaholab/moose/discussions/22961",
          "updatedAt": "2022-12-16T00:02:52Z",
          "publishedAt": "2022-12-14T14:36:15Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Joe\nThe flags at play here:\nThe svd monitor for the condition number\npetsc_options = '-pc_svd_monitor'\npetsc_options_iname = '-pc_type'\npetsc_options_value = 'svd'\n\nand this other petsc_option(s) for the matrix printout (you must use Newton method for that one, use pmat for PJFNK)\n-ksp_view_mat\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4401444",
                  "updatedAt": "2022-12-14T15:31:01Z",
                  "publishedAt": "2022-12-14T15:30:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "THANKS!!  That worked great.  But could you please explain a little.  I understand the jacobian matrix and it matches what I expected.  But what does the 'condition number' mean?  Mine is 10^21.\nAlso, what are the 'singular values'?   I get:\nSVD: condition number 7.113204853455e+20, 3 of 7 singular values are (nearly) zero\nSVD: singular values: 1.623154264692e-21\nSVD: singular values: 8.796004189038e-01\nAnd finally, with\nsolve_type = 'NEWTON'\npetsc_options = '-pc_svd_monitor -ksp_view_mat'\npetsc_options_iname = '-pc_type -pc_factor_shift_type -pc_factor_shift_amount'\npetsc_options_value = 'svd              NONZERO               1e-10'\nwhere svd replaced lu in petsc_options_value, my test problem CONVERGED!  Whereas I was getting a linear iteration failure.  Not only did it converge, it gave the correct answer.  So, what should my pets options be?\nThanks again,\nJoe",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4401677",
                          "updatedAt": "2022-12-14T15:54:43Z",
                          "publishedAt": "2022-12-14T15:54:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The condition number is the ratio of the first two largest eigenvalues (or smallest, I m likely getting confused with neutronics keff right here, no time to google I have a meeting) of the matrix. see below\n10^21 is very severely ill conditioned. We can get that down a little bit with scaling often, but at these heights it s usually a modeling issue like a missing boundary condition creating a null space.\nThe number of singular values is often tied to the number of dofs that are not well-posed.\nsvd is more of a debugging tool, it can barely be used (extremely slow) above 1k dofs.\nMoving forward if the matrix is only 7 by 7, the matrix print out should let you examine it in matlab or python. There is something wrong with it, making the inversion difficult. @lindsayad do you know of some resources for that?",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4401805",
                          "updatedAt": "2022-12-14T18:37:13Z",
                          "publishedAt": "2022-12-14T16:07:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Looking at it now.  There is something definitely wrong with the matrix.  Lot's for me to understand here as I am trying a hybrid rDG/CG scheme.  So velocity is essentially FVM while pressure is CG.  So, a 3 element model has 3 velocities and 4 pressures.\nThanks so much Guillaume.  I'll mark this as answered.",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4401837",
                          "updatedAt": "2022-12-14T16:11:45Z",
                          "publishedAt": "2022-12-14T16:11:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The condition number is the ratio of largest and smallest singular values",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4402708",
                          "updatedAt": "2022-12-14T17:59:28Z",
                          "publishedAt": "2022-12-14T17:59:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Since we always use the same matrix for the Jacobian and preconditioner, the -ksp_view_pmat option can be used for both NEWTON and PJFNK",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4402715",
                          "updatedAt": "2022-12-14T18:00:08Z",
                          "publishedAt": "2022-12-14T18:00:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I would be worried about LBB stability of a scheme in which you have more pressure dofs than velocity dofs. For incompressible flow the pressure is a Lagrange multiplier enforcing the divergence free constraint ... if you have more constraint dofs than primal dofs then I could easily see producing linearly dependent rows in your matrix",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4402730",
                          "updatedAt": "2022-12-14T18:02:28Z",
                          "publishedAt": "2022-12-14T18:02:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "oh yeah my bad I was thinking of the dominance ratio for some reason.",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4404646",
                          "updatedAt": "2022-12-14T22:53:35Z",
                          "publishedAt": "2022-12-14T22:53:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "The test problem is a simple one.  Three elements & 1 D single-phase.  No flow, just a stagnant liquid column to check pressure and gravity kernels.  Two variables, Vx and p.  Vx is a constant monomial at the cell-center.  P is first order gauss. So there are 4 nodes and hence 4 pressures. This is the hybrid scheme described in the paper Alex referenced.  But one of the pressures is at the outlet and hence is covered by a Dirichlet bc.  So, I have 2 eqs x 3 elements and 6 unknowns.\nThere is a problem with my jacobian.  I must have a mistake somewhere in my rDG flux kernels.  Although the contribution of the mass & momentum advection terms to the element/neighbor residuals are correct and have their correct AD derivatives, somehow those terms don\u2019t show up in the jacobian.  Indeed I have a row that is all zeros.  No wonder lu couldn\u2019t solve it.  I am amazed that svd (whatever it is) can solve it.\nI have an incompressible fluid, so the mass eq residuals are only fns of the velocity.  For momentum, due to zero velocity, the advection terms are zero and so the momentum residual is only a fn of the pressure gradient.  In other words, no diagonal terms whatsoever. Pretty severe test.  Lots of meetings today but hopefully some time to figure out why the derivatives of the mass eq residuals (advection so deriv is just the density) don\u2019t make it into jacobian.\nThanks for the help.  I like the idea of this hybrid scheme though making it 2nd order for a 3D problem will take a lot of work.  For now, simple 1st order upwind.\nOne more question, is it possible to printout the Residual vector?  Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4409895",
                          "updatedAt": "2022-12-15T12:52:27Z",
                          "publishedAt": "2022-12-15T12:52:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think it's possible to print the residual vector using vector tagging. I ll dig out an example",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4410814",
                          "updatedAt": "2022-12-15T14:47:57Z",
                          "publishedAt": "2022-12-15T14:47:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "joe61vette"
                          },
                          "bodyText": "Thanks Guillaume.  Small correction in the above. My pressure variable is First/Lagrange.  It is the quadrature that is First/Gauss.",
                          "url": "https://github.com/idaholab/moose/discussions/22961#discussioncomment-4411406",
                          "updatedAt": "2022-12-15T16:00:07Z",
                          "publishedAt": "2022-12-15T16:00:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "NAFEMS Benchmark T3",
          "author": {
            "login": "makeclean"
          },
          "bodyText": "Hi All\nI'm sure I'm doing something super dumb, but I cannot get MOOSE Heat Conduction to agree with the NAFEMS T3 benchmark, initially I thought I was doing something wrong with a Kelvin conversion, but I shifted to C and I see the same problem.\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 10000\n  ny = 1\n  nz = 1\n  xmin = 0.0\n  xmax = 0.1\n  ymin = 0.0\n  ymax = 0.01\n  zmin = 0.0\n  zmax = 0.01\n  elem_type = HEX8\n[]\n\n[Variables]\n  [temp]\n    initial_condition = 0\n    order = FIRST\n  []\n[]\n\n[Kernels]\n  [heat]\n    type = ADHeatConduction\n    variable = temp\n  []\n[]\n\n[Functions]\n  [bc_func]\n    type = ParsedFunction\n    value = '100*(sin(pi*t/40))'\n  []\n[]\n\n[BCs]\n  [dceb]\n    type = ADFunctionDirichletBC\n    boundary = 'right'\n    variable = temp\n    function = bc_func\n  []\n  [ab]\n    type = ADDirichletBC\n    variable = temp\n    boundary = 'left' \n    value = 0 # 0 C\n  []\n[]\n\n[Kernels]\n  [isotropic-heat]\n    type = ADHeatConduction\n    variable = temp\n  []\n  [heat-dt]\n    type = ADHeatConductionTimeDerivative\n    variable = temp\n  []\n[]\n\n[Materials]\n  [density]\n    type = ADGenericConstantMaterial\n    prop_names = 'density'\n    prop_values = '7200.0'\n  []\n  [copper-heat]\n    type = ADHeatConductionMaterial\n    temp = temp\n    thermal_conductivity_temperature_function = '35.0'\n    specific_heat_temperature_function = '440.5'\n  []\n[]\n\n[Executioner]\n  automatic_scaling = true\n  type = Transient\n  solve_type = NEWTON\n  start_time = 0\n  end_time = 32\n  dt = 1\n  petsc_options = '-snes_converged_reason'\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre boomeramg'\n  line_search = none\n[]\n\n[Postprocessors]\n  [value_1.25]\n    type = PointValue\n    variable = temp\n    point = '0.08 0.0 0.0'\n  []\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nEven with a ridiculous mesh density I get 47.7 instead of 36.6, can someone spot my obvious mistake?",
          "url": "https://github.com/idaholab/moose/discussions/22964",
          "updatedAt": "2022-12-15T16:05:39Z",
          "publishedAt": "2022-12-14T21:47:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "maxnezdyur"
                  },
                  "bodyText": "You have two kernels of type = ADHeatConduction. I think you want to get rid of one of them.",
                  "url": "https://github.com/idaholab/moose/discussions/22964#discussioncomment-4404391",
                  "updatedAt": "2022-12-14T22:02:06Z",
                  "publishedAt": "2022-12-14T22:02:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "You're quite right, removing that fixes the issue - face palm! @GiudGiud any reason why MOOSE doesn't error or warn when you have a kernel in twice with the same type? Is there a use case where one would want to be able to have the same kernel in with the same definition twice?",
                          "url": "https://github.com/idaholab/moose/discussions/22964#discussioncomment-4404707",
                          "updatedAt": "2022-12-14T23:09:23Z",
                          "publishedAt": "2022-12-14T23:09:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you split a momentum diffusion term in molecular + turbulent diffusion I could see one use the same kernel to represent both\nSame for multiple reaction terms, a species reaction with multiple species or having multiple sources\nThe solution here is to use actions instead of specifying your kernels in the input file.\nThere s a thermo-mechanical action\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/22964#discussioncomment-4404801",
                          "updatedAt": "2022-12-14T23:32:27Z",
                          "publishedAt": "2022-12-14T23:32:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "makeclean"
                          },
                          "bodyText": "In those cases would they literally be the sample kernel instanciated twice with the same variable?",
                          "url": "https://github.com/idaholab/moose/discussions/22964#discussioncomment-4408946",
                          "updatedAt": "2022-12-15T10:48:27Z",
                          "publishedAt": "2022-12-15T10:48:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The same kernel with the same variable but not the same parameters",
                          "url": "https://github.com/idaholab/moose/discussions/22964#discussioncomment-4411464",
                          "updatedAt": "2022-12-15T16:05:40Z",
                          "publishedAt": "2022-12-15T16:05:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Convergence Issue: Nonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0",
          "author": {
            "login": "batodon"
          },
          "bodyText": "Hello,\nI\u2019m getting the following nonlinear convergence error when running a PorousFlow steady-state simulation. Although I previously simulated a \u2018different\u2019 version of this model successfully.\nNonlinear solve did not converge due to DIVERGED_FNORM_NAN iterations 0\n Solve Did NOT Converge!\n\nAnd so, I tried simulating the same problem in a transient state, and I got this error:\n*** ERROR ***\nThe following error occurred in the object \"TimeStepper\", of type \"IterationAdaptiveDT\".\n\nSolve failed and timestep already at dtmin, cannot continue!\n\nI\u2019ve read previous discussions about this issue, but none seem to work. I\u2019m guessing the problem is with my Timestepper, specifically my tolerances (I may be wrong). Please, help. Here is my input file for the steady state. Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/22965",
          "updatedAt": "2022-12-15T00:00:11Z",
          "publishedAt": "2022-12-14T22:46:39Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "batodon"
                  },
                  "bodyText": "Please ignore this ticket. I found the bug! Thanks.",
                  "url": "https://github.com/idaholab/moose/discussions/22965#discussioncomment-4404919",
                  "updatedAt": "2022-12-14T23:59:42Z",
                  "publishedAt": "2022-12-14T23:59:42Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Time itterations in transfer",
          "author": {
            "login": "philipJFpfahl"
          },
          "bodyText": "Hey,\nI have a master-app in which I do fluid dynamics with the INSFV module and a sub-app in which I calculate the particle concentration using FE.\nNow I transfer with MultiAppShapeEvaluationTransfer the concentration to my parent app and back. It seems like I can't get the timing to work. I need some transfer like this:\n\nSo I want the sub-app to run a full-time step. Then the master app should pull the concentration. Do advection with it and then finish the time step by pushing it to the sub-app. The sub-app should start a new time step with the newly pushed concentration.\nBut this transfer like this\n[Transfers]\n  [pull_C]\n    type = MultiAppShapeEvaluationTransfer\n    from_multi_app = Subapp\n    source_variable = C\n    variable = C\n    execute_on = TIMESTEP_INITIAL\n  []\n  [push_C]\n    type = MultiAppShapeEvaluationTransfer\n    fto_multi_app = Subapp\n    source_variable = C\n    variable = C\n    execute_on = TIMESTEP_END\n  []\n[]\n\nSeems not to work. At least the solution is non-physical.\nI do the advection with\n  [C_time]\n    type = FVTimeKernel\n    variable = C\n  []\n  [C_advection]\n    type = INSFVScalarFieldAdvection\n    variable = C\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n  []\n\nand I initialize C with\n[Variables]\n  [C]\n    type = INSFVScalarFieldVariable\n  []\n[]\n\nSome insights I have:\n-The solution converges most of the time if I \"just\" pull and push C to from to the sub-app, but does not give a physical answer.\n-It seems to work fine if I do only pull from the sub-app and execute_on = TIMESTEP_END.\n-The advection works fine on its own when I pull.\nI am happy about any ideas and all suggestions.\nAll the best,\nPhilip",
          "url": "https://github.com/idaholab/moose/discussions/22901",
          "updatedAt": "2022-12-14T17:03:58Z",
          "publishedAt": "2022-12-06T21:36:35Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis parameter seems mispelled\nfto_multi_app = Subapp\nalso this execute_on does not exist? It should be timestep_begin maybe?\n[Transfers]\n  [pull_C]\n    execute_on = TIMESTEP_INITIAL\n\nIn general, for multiphysics iterations you want to execute the transfers on the same execute_on as the multiapp. Here you should have both on timestep_end.\nAny other execution schedule is for custom schemes and advanced use.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4327206",
                  "updatedAt": "2022-12-06T21:41:00Z",
                  "publishedAt": "2022-12-06T21:40:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nyes the comments are correct.\nit shoudhave been:\n[Transfers]\n  [pull_C]\n    execute_on = TIMESTEP_BEGIN\n\nand to_multi_app = Subapp.\nI don't understand. What does MOOSE do, when the push and pull commands are at the same time?\nIn what order are the apps acting on the variable?\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4327550",
                          "updatedAt": "2022-12-06T22:41:45Z",
                          "publishedAt": "2022-12-06T22:41:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You may turn on verbose_multiapps = true in the Problem to see what moose is doing\nIt goes:\ntransfer to multiapp\nrun multiapp\ntransfer from multiapp",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4327575",
                          "updatedAt": "2022-12-06T22:46:49Z",
                          "publishedAt": "2022-12-06T22:46:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nI checked and you are completly right. There is an other issue with the transfer and the kernel we discussed in here. I will make a separate discussion about that.\nMeanwhile, thank you a lot!\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4344552",
                          "updatedAt": "2022-12-08T15:44:49Z",
                          "publishedAt": "2022-12-08T15:44:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "philipJFpfahl"
                  },
                  "bodyText": "Hey,\nI dont know if I should make a new discussion about this, but it still fits here.\nSo I want to do a fluid simulation with FiniteVolumes and advect a concentration within this simulation.\nIn a FiniteElement simulation, I want to scale the concentration over time. A minimal working example is shown below as master and sub.\nI can combine the two scripts into one FV simulation for this simple example. This is not possible for my purposes, since the meshes will be different sizes, but it shows, how the final solution should be. The script is also shown below.\nMy questions:\n-How do I tell moose that it should scale the concentration in one app and then advect it in the other?\nI think it should also be the same solution it both apps.\n-Am I using the right transfers or should I use different ones?\n-What is the correct execute_on?\nif I just use TIMESTEP_END the concentration becomes zero everywhere.\nhere is the code:\nmaster:\nrho = 2000\nmu = 50 \ncp = 3750\nk = 100\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    xmax = 2.0\n    ymin = 0\n    ymax = 2.0\n    nx = 50\n    ny = 50\n  []\n  [pin]\n    type = ExtraNodesetGenerator\n    input = gen\n    new_boundary = 'pin'\n    nodes = '0'\n  []\n[]\n\nvelocity_interp_method = 'rc'\nadvected_interp_method = 'average'\n[GlobalParams]\n  rhie_chow_user_object = 'rc'\n[]\n\n[UserObjects]\n  [rc]\n    type = INSFVRhieChowInterpolator\n    u = u\n    v = v\n    pressure = pressure\n  []\n[]\n\n[Variables]\n  [u]\n    type = INSFVVelocityVariable\n  []\n  [v]\n    type = INSFVVelocityVariable\n  []\n  [pressure]\n    type = INSFVPressureVariable\n  []\n  [lambda]\n    family = SCALAR\n    order = FIRST\n  []\n  [C]\n    type = INSFVScalarFieldVariable\n  []\n[]\n\n\n[AuxVariables]\n  [U]\n    order = CONSTANT\n    family = MONOMIAL\n    fv = true\n  []\n[]\n\n[AuxKernels]\n  [mag]\n    type = VectorMagnitudeAux\n    variable = U\n    x = u\n    y = v\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    advected_interp_method = ${advected_interp_method}\n    velocity_interp_method = ${velocity_interp_method}\n    rho = ${rho}\n  []\n  [mean_zero_pressure]\n    type = FVIntegralValueConstraint\n    variable = pressure\n    lambda = lambda\n  []\n\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = 'u'\n    rho = ${rho}\n    momentum_component = 'x'\n  []\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = u\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n    rho = ${rho}\n    momentum_component = 'x'\n  []\n  [u_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = u\n    mu = ${mu}\n    momentum_component = 'x'\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = u\n    momentum_component = 'x'\n    pressure = pressure\n  []\n\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = v\n    rho = ${rho}\n    momentum_component = 'y'\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = v\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n    rho = ${rho}\n    momentum_component = 'y'\n  []\n  [v_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = v\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = v\n    momentum_component = 'y'\n    pressure = pressure\n  []\n  [C_time]\n    type = FVTimeKernel\n    variable = C\n  []\n  [C_advection]\n    type = INSFVScalarFieldAdvection\n    variable = C\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n  []\n[]\n\n[FVBCs]\n  [top_x]\n    type = INSFVNoSlipWallBC\n    variable = u\n    boundary = 'top'\n    function = 'lid_function'\n  []\n\n  [no_slip_x]\n    type = INSFVNoSlipWallBC\n    variable = u\n    boundary = 'left right bottom'\n    function = 0\n  []\n\n  [no_slip_y]\n    type = INSFVNoSlipWallBC\n    variable = v\n    boundary = 'left right top bottom'\n    function = 0\n  []\n[]\n\n[Materials]\n  [functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k'\n    prop_values = '${cp} ${k}'\n  []\n[]\n\n[Functions]\n  [lid_function]\n    type = ParsedFunction\n    value = '0.5'\n  []\n[]\n\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  # Run for 100+ timesteps to reach steady state.\n\n  start_time = 0\n  dt = 0.1\n  end_time = 10\n\n  petsc_options_iname = '-pc_type -sub_pc_type -sub_pc_factor_shift_type -ksp_gmres_restart'\n  petsc_options_value = 'asm      lu           NONZERO                   200'\n  line_search = 'none'\n  nl_rel_tol = 1e-6\n  nl_max_its = 6\n  l_max_its = 200\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n[MultiApps]\n  [Sub]\n    type = TransientMultiApp\n    input_files = 'sub.i'\n    execute_on = TIMESTEP_END\n  []\n[]\n\n[Transfers]\n   [pull_C_inital]\n    type = MultiAppShapeEvaluationTransfer\n    from_multi_app = Sub\n    source_variable = Concentration\n    variable = C\n    execute_on = INITIAL\n  [] \n  [pull_C]\n    type = MultiAppShapeEvaluationTransfer\n    from_multi_app = Sub\n    source_variable = Concentration\n    variable = C\n    execute_on = TIMESTEP_BEGIN\n  []\n  [push_C]\n    type = MultiAppProjectionTransfer\n    #type = MultiAppShapeEvaluationTransfer\n    to_multi_app = Sub\n    source_variable = C\n    variable = Concentration\n    execute_on = TIMESTEP_END\n  []\n[]\n\n\nsub:\n#set mesh\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    xmax = 2\n    ymin = 0\n    ymax = 2\n    nx = 25\n    ny = 25\n  []\n[]\n\n[Variables]\n  [Concentration]\n  []\n[]\n\n\n[ICs]\n  [Initial_Power]\n    type = FunctionIC\n    variable = 'Concentration'\n    function =  C_func\n  []\n[]\n\n[Functions]\n  [C_func]\n    type =ParsedFunction    \n    value = 'exp(-((x-1)^2+(y-1)^2))'\n  []\n[]\n\n\n\n[Kernels]\n [C_time]\n    type = TimeDerivative\n    variable = Concentration\n []\n [C_force]\n    type = BodyForce\n    variable = Concentration\n    value = -0.1\n []\n[]\n\n\n[Executioner]\n  type = Transient\n  start_time = 0\n  dt = 0.1\n  end_time = 10\n  solve_type = 'PJFNK'\n[]\n\n[Outputs]\n  exodus = true\n print_nonlinear_converged_reason = false\n print_linear_converged_reason = false\n  [csv]\n    type = CSV\n    time_data = true\n  []\n[]\n\n\nSolution:\nrho = 2000\nmu = 50 \ncp = 3750\nk = 100\n\n[Mesh]\n  [gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    xmax = 2.0\n    ymin = 0\n    ymax = 2.0\n    nx = 50\n    ny = 50\n  []\n  [pin]\n    type = ExtraNodesetGenerator\n    input = gen\n    new_boundary = 'pin'\n    nodes = '0'\n  []\n[]\n\nvelocity_interp_method = 'rc'\nadvected_interp_method = 'average'\n[GlobalParams]\n  rhie_chow_user_object = 'rc'\n[]\n\n[UserObjects]\n  [rc]\n    type = INSFVRhieChowInterpolator\n    u = u\n    v = v\n    pressure = pressure\n  []\n[]\n\n[Variables]\n  [u]\n    type = INSFVVelocityVariable\n  []\n  [v]\n    type = INSFVVelocityVariable\n  []\n  [pressure]\n    type = INSFVPressureVariable\n  []\n  [lambda]\n    family = SCALAR\n    order = FIRST\n  []\n  [C]\n    type = INSFVScalarFieldVariable\n  []\n[]\n\n[AuxVariables]\n  [U]\n    order = CONSTANT\n    family = MONOMIAL\n    fv = true\n  []\n[]\n\n[AuxKernels]\n  [mag]\n    type = VectorMagnitudeAux\n    variable = U\n    x = u\n    y = v\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    advected_interp_method = ${advected_interp_method}\n    velocity_interp_method = ${velocity_interp_method}\n    rho = ${rho}\n  []\n  [mean_zero_pressure]\n    type = FVIntegralValueConstraint\n    variable = pressure\n    lambda = lambda\n  []\n\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = 'u'\n    rho = ${rho}\n    momentum_component = 'x'\n  []\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = u\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n    rho = ${rho}\n    momentum_component = 'x'\n  []\n  [u_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = u\n    mu = ${mu}\n    momentum_component = 'x'\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = u\n    momentum_component = 'x'\n    pressure = pressure\n  []\n\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = v\n    rho = ${rho}\n    momentum_component = 'y'\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = v\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n    rho = ${rho}\n    momentum_component = 'y'\n  []\n  [v_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = v\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = v\n    momentum_component = 'y'\n    pressure = pressure\n  []\n\n  [C_time]\n    type = FVTimeKernel\n    variable = C\n  []\n  [C_advection]\n    type = INSFVScalarFieldAdvection\n    variable = C\n    velocity_interp_method = ${velocity_interp_method}\n    advected_interp_method = ${advected_interp_method}\n  []\n  [C_force]\n    type = FVCoupledForce\n    variable = C\n    v = -0.1\n  []\n[]\n\n[FVBCs]\n  [top_x]\n    type = INSFVNoSlipWallBC\n    variable = u\n    boundary = 'top'\n    function = 'lid_function'\n  []\n\n  [no_slip_x]\n    type = INSFVNoSlipWallBC\n    variable = u\n    boundary = 'left right bottom'\n    function = 0\n  []\n\n  [no_slip_y]\n    type = INSFVNoSlipWallBC\n    variable = v\n    boundary = 'left right top bottom'\n    function = 0\n  []\n[]\n\n[Materials]\n  [functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k'\n    prop_values = '${cp} ${k}'\n  []\n[]\n\n[Functions]\n  [lid_function]\n    type = ParsedFunction\n    value = '0.5'\n  []\n[]\n\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  # Run for 100+ timesteps to reach steady state.\n\n  start_time = 0\n  dt = 0.1\n  end_time = 10\n\n  petsc_options_iname = '-pc_type -sub_pc_type -sub_pc_factor_shift_type -ksp_gmres_restart'\n  petsc_options_value = 'asm      lu           NONZERO                   200'\n  line_search = 'none'\n  nl_rel_tol = 1e-6\n  nl_max_its = 6\n  l_max_its = 200\n[]\n\n[Outputs]\n  exodus = true\n[]\n\n[MultiApps]\n  [Sub]\n    type = TransientMultiApp\n    input_files = 'sub.i'\n    execute_on = INITIAL\n  []\n[]\n\n[Transfers]\n   [pull_C_inital]\n    type = MultiAppShapeEvaluationTransfer\n    from_multi_app = Sub\n    source_variable = Concentration\n    variable = C\n    execute_on = INITIAL\n  [] \n[]",
                  "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4379895",
                  "updatedAt": "2022-12-12T15:10:56Z",
                  "publishedAt": "2022-12-12T15:10:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIt doesnt seem physical to just scale a concentration on every time step.\nWhy is concentration the solution of two distinct PDEs ? Can you not solve them together in a single app?\nAlso why timestep_begin for that send?\nIf you do that, you will lag the quantity in the sub app solve.\nThen since you are transferring the value back at the end of the time step, you will overwrite what you solved for C in the main app.\nSo with what you have now, you might as well not solve for C in the main app.\nMaybe change this:\n  [pull_C]\n    type = MultiAppShapeEvaluationTransfer\n    from_multi_app = Sub\n    source_variable = Concentration\n    variable = C\n    execute_on = TIMESTEP_BEGIN.  -> TIMESTEP_END\n  []\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4380587",
                  "updatedAt": "2022-12-12T16:23:49Z",
                  "publishedAt": "2022-12-12T16:23:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nAgain thank you for the fast answer.\nWell, the sub is just a minimal example to explain the problem. I attend to use it in a more complex coupled system with coarser meshes and different time scales.\nif I change:\nexecute_on = TIMESTEP_BEGIN.  -> TIMESTEP_END\n\nI \"just\" get a scaling of C in both apps.\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4380879",
                          "updatedAt": "2022-12-12T16:45:24Z",
                          "publishedAt": "2022-12-12T16:45:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Isnt that what this is meant to do?\nSo I want to do a fluid simulation with FiniteVolumes and advect a concentration within this simulation.\nIn a FiniteElement simulation, I want to scale the concentration over time. A minimal working example is shown below as master and sub.",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4381012",
                          "updatedAt": "2022-12-12T16:57:46Z",
                          "publishedAt": "2022-12-12T16:57:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Yes, the sub-app should scale it and the main-app should advect it.  As of now, it just gets scaled.\nI think this is because it gets pulled and pushed at the same time.",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4381095",
                          "updatedAt": "2022-12-12T17:07:20Z",
                          "publishedAt": "2022-12-12T17:06:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It s not at the same time. You saw the timing of the transfers, if you set both on timestep end, you should advect, transfer, \"scale\" then transfer back.\nThis transfer back replaces the current solution post-advection. The solution is then no longer the solution of an advection problem. It is the solution of the \"scaling\" problem.\nAnother thing to consider is that you have wild non-conservative projections happening when you go from finite volume to finite element and back as the shape functions are very different.",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4381119",
                          "updatedAt": "2022-12-12T17:12:49Z",
                          "publishedAt": "2022-12-12T17:09:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "if I run it with these transfers:\n[MultiApps]\n  [Sub]\n    type = TransientMultiApp\n    input_files = 'sub.i'\n    execute_on = TIMESTEP_END\n  []\n[]\n\n[Transfers]\n   [pull_C_inital]\n    type = MultiAppShapeEvaluationTransfer\n    from_multi_app = Sub\n    source_variable = Concentration\n    variable = C\n    execute_on = INITIAL\n  [] \n  [pull_C]\n    type = MultiAppShapeEvaluationTransfer\n    from_multi_app = Sub\n    source_variable = Concentration\n    variable = C\n    execute_on = TIMESTEP_END\n  []\n  [push_C]\n    type = MultiAppProjectionTransfer\n    #type = MultiAppShapeEvaluationTransfer\n    to_multi_app = Sub\n    source_variable = C\n    variable = Concentration\n    execute_on = TIMESTEP_END\n  []\n[]\n\nIt does not seem to advect and both apps just\nIf I change\nTIMESTEP_END -> TIMESTEP_BEGIN\n\nin the output, it seems like the main app advects and does not scale, and the sub-app scales, but does not advect.",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4381281",
                          "updatedAt": "2022-12-12T17:28:09Z",
                          "publishedAt": "2022-12-12T17:28:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is correct.\nI dont see why the main app would scale since it does not have kernels for that.\nSimilarly for the subapp.\nThe output of an app is the solution for the given equation. The solution of an advection problem will not look like it got scaled, even if the initial condition comes from the \"scaled\" solution",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4382582",
                          "updatedAt": "2022-12-12T19:54:40Z",
                          "publishedAt": "2022-12-12T19:54:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Well, the time steps should be independent of the history. So each time step starts with an initial condition and then develops the solution over time. So I thought, that it would be possible to start from an initial condition scale it in the sub-app, send it to the master-app and use that solution as an initial condition to advect it there, send this solution back to the sub-app and then use the advected solution as an initial condition for the next time step. That is \"tight coupling\" in my eyes.\nPlease correct me if I am wrong, I am just trying to learn!\nIf that is not possible, how do you do something like that?\nFor me, it is important to separate the two functionalities.",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4386882",
                          "updatedAt": "2022-12-13T07:34:21Z",
                          "publishedAt": "2022-12-13T07:34:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Well it only develops over a single time step in this setup. If you want to let it relax to steady state on each physics coupling iteration, a different setup will achieve that.\nThis is not typical tight coupling because you are solving for the same variable in both problems. Tight coupling is usually something like  \u00ab\u00a0solve one app for velocity and pressure, with a temperature dependent density, solve another app for temperature depending on the velocity field, iterate to convergence\u00a0\u00bb\nMaybe we should consider the approach you are taking in light of the actual physical problem you are solving. Would you mind describing it?",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4388165",
                          "updatedAt": "2022-12-13T10:19:49Z",
                          "publishedAt": "2022-12-13T10:19:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey\nMaybe we should consider the approach you are taking in light of the actual physical problem you are solving.\n\nI think that is a good idea.\nSo I try to solve the lid-driven cavity reactor problem using the PK solver developed for the SEALION project within MOOSE. Here is the paper. It focuses on a transient benchmark for MSR.\nI would like to compare the neutronics solver in this setup with other neutronics solvers. This should be within MOOSE. This is why I need a separation of the tasks.Relevant to my question is, that I do the fluid dynamics in one app and the neutronics calculation in another so that I can exchange the neutronics solver later. This is interesting for benchmarking the performance of the neutronics solver alone.\nTo the physics:\nThe concentration is in this case the concentration of the precursors. In a MSR they will be advected with the fuel and then emmit a newtron later on in the reactor at a different place. You see, they are tricky because they fit right in between the two solvers. They get advected depending on the CFD and scaled depending on the Neutronics. In the end I would like to be able to refine the number of time steps in the Neutronics app and make the mesh coarser compared to the CFD app. The chosen separation, therefore \"feels\" logical.\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4389085",
                          "updatedAt": "2022-12-13T12:17:16Z",
                          "publishedAt": "2022-12-13T12:17:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This input does something similar to what you want. You need to run it with NS module\nhttps://github.com/idaholab/virtual_test_bed/blob/devel/msr/msfr/steady/run_ns.i\nWe will upload in the near future the CNRS benchmarks, which are lid-driven cavities with precursors.\nIn this problem, there is no individual scaling equation. The precursor decay happens at the same time as the advection and must be included in the same equation",
                          "url": "https://github.com/idaholab/moose/discussions/22901#discussioncomment-4390332",
                          "updatedAt": "2022-12-13T13:49:29Z",
                          "publishedAt": "2022-12-13T13:49:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Saving a std::vector<Real> Material for postprocessing (excluding visualization)",
          "author": {
            "login": "mcacace"
          },
          "bodyText": "Dear all,\nI am wondering whether it would be possible to store a material that contains a varying in size (on run time) std::vector of Real entries for postprocessing. I see that for  RealVectorValue material the way would be to store its entries in an auxvariable (I guess for visualization) and then retrieved them via a vectorpostprocessor.\nSince I do not need to visualize my vectors (dimensions are usually greater than 3), I was thinking to directly sample all entries in a dedicated vectorpostprocessor, something along the line of ElementVariableVectorPostprocessor though working on material properties ( this would then require to extend the SampleBase class I guess).\nThe other option would be to store the list of entries into an auxvariable and then go via the ElementVariableVectorPostprocessor (though I see problems with visualization here).\nI would appreciate any feedback on my thoughts (like whether this would be doable at all).\nThanks in advance,\nmauro",
          "url": "https://github.com/idaholab/moose/discussions/22960",
          "updatedAt": "2023-01-03T22:36:36Z",
          "publishedAt": "2022-12-14T10:18:20Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUnfortunately, as the docs for the MaterialVPP say, it hasnt been written for array material properties, only for Real-valued ones. This would not be very hard to do, and we would welcome the contribution to the framework.\nIf you don't want that, you can try this hacky way, I have not tried it but I think it would work:\nYou specify output = 'exodus' in the material block that defines this array material property, then looking at the exodus you can see that a number of auxiliary variables got added to the aux system.\nYou use the names of these auxiliary variables in an ElementValueSampler to output them to CSV\nhttps://mooseframework.inl.gov/source/vectorpostprocessors/ElementValueSampler.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22960#discussioncomment-4401317",
                  "updatedAt": "2022-12-14T15:17:45Z",
                  "publishedAt": "2022-12-14T15:17:44Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "mcacace"
                  },
                  "bodyText": "@GiudGiud thanks for your feedback. About your first point, would you suggest to augment the MaterialVectorPostprocessor class? Will browse through that and see how that can be done. Thanks again",
                  "url": "https://github.com/idaholab/moose/discussions/22960#discussioncomment-4401696",
                  "updatedAt": "2022-12-14T15:56:04Z",
                  "publishedAt": "2022-12-14T15:56:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think this would make the most sense",
                          "url": "https://github.com/idaholab/moose/discussions/22960#discussioncomment-4401762",
                          "updatedAt": "2022-12-14T16:02:20Z",
                          "publishedAt": "2022-12-14T16:02:19Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "BC setting for 1D horizontal line",
          "author": {
            "login": "Joseph-0123"
          },
          "bodyText": "Dear all,\nI have a question: assuming there is a 1D horizontal line. Now I want to set BCs for the left and right boundaries of the system.  If I set two different pressures for each boundary.  I got a result for the pressure and darcy velocity. But I am wondering if the system is automatically set to open or close. If I do not set flux values (i.e., Neumann BC) at boundaries.\nThanks a lot.",
          "url": "https://github.com/idaholab/moose/discussions/22958",
          "updatedAt": "2023-02-04T07:18:28Z",
          "publishedAt": "2022-12-13T17:44:39Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Joseph-0123"
                  },
                  "bodyText": "@GiudGiud",
                  "url": "https://github.com/idaholab/moose/discussions/22958#discussioncomment-4392748",
                  "updatedAt": "2022-12-13T17:46:07Z",
                  "publishedAt": "2022-12-13T17:46:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is this for finite volume or finite element?\nIn finite volume, you ll need to use the NSFV-specific (outlet) boundary condition on pressure, and it will make the system open on both sides with pressure BCs\nNote that we have not worked on inlet+outlet pressure BCs. We ve only done velocity/mass flow inlet + pressure outlet.",
                          "url": "https://github.com/idaholab/moose/discussions/22958#discussioncomment-4392977",
                          "updatedAt": "2022-12-13T18:14:14Z",
                          "publishedAt": "2022-12-13T18:14:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "We use our finite element application. It's strange that we get open boundaries when we only set pressures for boundary conditions.",
                          "url": "https://github.com/idaholab/moose/discussions/22958#discussioncomment-4393022",
                          "updatedAt": "2022-12-13T18:20:14Z",
                          "publishedAt": "2022-12-13T18:20:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Which set of kernels are you using? INS? INSAD? THM's?",
                          "url": "https://github.com/idaholab/moose/discussions/22958#discussioncomment-4393037",
                          "updatedAt": "2022-12-13T18:22:40Z",
                          "publishedAt": "2022-12-13T18:22:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "Which set of kernels are you using? INS? INSAD? THM's?\n\nWe use the  (HydraulicKernelH and HydraulicTimeKernelH) in our application .\nOur kernels are similar to the porous-flow modules.",
                          "url": "https://github.com/idaholab/moose/discussions/22958#discussioncomment-4393127",
                          "updatedAt": "2022-12-13T18:33:11Z",
                          "publishedAt": "2022-12-13T18:33:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@WilkAndy or @cpgr will know about porous flow.\nA set pressure in fluid flow is generally not a 0 flux condition for mass/momentum",
                          "url": "https://github.com/idaholab/moose/discussions/22958#discussioncomment-4393158",
                          "updatedAt": "2022-12-13T18:37:13Z",
                          "publishedAt": "2022-12-13T18:36:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "In a 1D system you need to specify at least one Dirichlet condition to create a unique solution.\nGenerally - for most finite-element formulations - not setting a boundary condition is the same thing as setting a no-flux boundary condition.  The reason why is that when you do the integration by parts to generate a weak form you end up with a flux term on the boundary.  Leaving it out of the simulation is the same thing as setting that term to zero.",
                  "url": "https://github.com/idaholab/moose/discussions/22958#discussioncomment-4392980",
                  "updatedAt": "2022-12-13T18:14:43Z",
                  "publishedAt": "2022-12-13T18:14:43Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Joseph-0123"
                          },
                          "bodyText": "In a 1D system you need to specify at least one Dirichlet condition to create a unique solution.\nGenerally - for most finite-element formulations - not setting a boundary condition is the same thing as setting a no-flux boundary condition. The reason why is that when you do the integration by parts to generate a weak form you end up with a flux term on the boundary. Leaving it out of the simulation is the same thing as setting that term to zero.\n\nThank you. Yes, I set two pressure values for my 1D model boundaries, one for each. However, I did not set flux boundary conditions.\nAfter computation, I got the results with influx and outflux at boundaries which are not set by me. Based on your words, If we donot set the flux boundaries, the system should have boundary with no flux, meaning that is a closed system, right?",
                          "url": "https://github.com/idaholab/moose/discussions/22958#discussioncomment-4393055",
                          "updatedAt": "2022-12-13T18:24:49Z",
                          "publishedAt": "2022-12-13T18:24:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "Ah - since you set a Dirichlet BC for pressure... that means you can have flux through that boundary.  Think of it this way: you're choosing to constrain the value instead of the gradient... so you will get the specified value but the gradient (which gives you flux) will be whatever it needs to be to satisfy the PDE (i.e. not zero).",
                          "url": "https://github.com/idaholab/moose/discussions/22958#discussioncomment-4393187",
                          "updatedAt": "2022-12-13T18:43:23Z",
                          "publishedAt": "2022-12-13T18:43:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "PostProcessor \"ElementAverageMaterialProperty\" applied to \"ADParsedMaterial\"?",
          "author": {
            "login": "EdSheltonUKAEA"
          },
          "bodyText": "I would like to use the postprocessor \"ElementAverageMaterialProperty\".  But I am using AD kernels, boundary conditions, material properties, etc. including \"ADParsedMaterial\" to define the parameters I want to track in the PP.\nWhen I try to run an input file including the \"ElementAverageMaterialProperty\" PP, I get this error message.\n*** ERROR ***\nThe requested regular material property Focc_tr_def1 is declared as an AD property. Either retrieve it as an AD property with getADMaterialProperty or declare it as a regular property with declareProperty\n\nWhat changes do I need to make to my input files, and in which blocks, to do either or both of these suggested fixes?\nOr is there an equivalent PP which will work directly with the type \"ADParsedMaterial\"?\nMany thanks!",
          "url": "https://github.com/idaholab/moose/discussions/22955",
          "updatedAt": "2023-01-03T23:52:41Z",
          "publishedAt": "2022-12-13T14:02:01Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "maxnezdyur"
                  },
                  "bodyText": "Try ADElementAverageMaterialProperty.",
                  "url": "https://github.com/idaholab/moose/discussions/22955#discussioncomment-4390525",
                  "updatedAt": "2022-12-13T14:05:17Z",
                  "publishedAt": "2022-12-13T14:05:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Thanks!  I thought there must be something like this, but couldn't see it in the list here:\nhttps://mooseframework.inl.gov/source/index.html\nThis has worked!",
                          "url": "https://github.com/idaholab/moose/discussions/22955#discussioncomment-4390650",
                          "updatedAt": "2022-12-13T14:18:18Z",
                          "publishedAt": "2022-12-13T14:18:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Sorry we don\u2019t double up the documentation entries for the AD versions.",
                          "url": "https://github.com/idaholab/moose/discussions/22955#discussioncomment-4391137",
                          "updatedAt": "2022-12-13T15:08:12Z",
                          "publishedAt": "2022-12-13T15:08:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Sampler1DReal to get displaced qp values, bug?",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "I've got a two-element thermal expansion problem with a temperature gradient along x. I want to use the Sampler1DReal VPP to get the temperature, which is stored in an AuxVariable, at the displaced quadrature points. I'm doing this using an intermediate ParsedMaterial that is just the value of the temperature AuxVariable, since the VPP only accepts materials.\nThe temperature values are as expected for the VPP, but when I set use_displaced_mesh=true in the VPP, the temperature values are wrong (though the coordinates are as expected). Seems like the temperature values for the first element are just repeats of those the second element? Am I using the VPP incorrectly? (It says 1D in the name after all)\nInput file (sorry its so long)\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 2\n  ny = 1\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n\n[AuxVariables]\n  [./temp]\n    order = first\n    family = lagrange\n  [../]\n[]\n\n[Functions]\n  [./temperature_load]\n    type = ParsedFunction\n    value = t*(500.0)+300.0+100*x\n  [../]\n[]\n\n[Modules]\n  [./TensorMechanics]\n    [./Master]\n      [./all]\n        strain = finite\n        incremental = true\n        add_variables = true\n        eigenstrain_names = eigenstrain\n      [../]\n    [../]\n  [../]\n[]\n\n[AuxKernels]\n  [./tempfuncaux]\n    type = FunctionAux\n    variable = temp\n    function = temperature_load\n  [../]\n[]\n\n[BCs]\n  [./x_bot]\n    type = DirichletBC\n    variable = disp_x\n    boundary = left\n    value = 0.0\n  [../]\n  [./y_bot]\n    type = DirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0.0\n  [../]\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 2.1e5\n    poissons_ratio = 0.3\n  [../]\n  [./small_stress]\n    type = ComputeFiniteStrainElasticStress\n  [../]\n  [./thermal_expansion_strain]\n    type = ComputeThermalExpansionEigenstrain\n    stress_free_temperature = 298\n    thermal_expansion_coeff = 1.3e-5\n    temperature = temp\n    eigenstrain_name = eigenstrain\n  [../]\n  [mat]\n    type = ParsedMaterial\n    function = temp\n    args = temp\n    f_name = temperature_material\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n\n  l_max_its = 50\n  nl_max_its = 50\n  nl_rel_tol = 1e-12\n  nl_abs_tol = 1e-10\n  l_tol = 1e-9\n\n  dt = 0.0125\n  num_steps = 1\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n[]\n\n[Postprocessors]\n  [./avg_temperature]\n    type = AverageNodalVariableValue\n    variable = temp\n  [../]\n  [./max_temperature]\n    type = NodalExtremeValue\n    variable = temp\n    value_type = max\n  []\n[]\n\n[VectorPostprocessors]\n  [sampler1dreal]\n    type = Sampler1DReal\n    block = 0\n    property = temperature_material\n    sort_by = x\n  []\n  [sampler1dreal_disp]\n    type = Sampler1DReal\n    block = 0\n    property = temperature_material\n    sort_by = x\n    use_displaced_mesh = true\n  []\n[]\n\n\nVPP output:\n\n\n\nid\ntemperature_material\nx\ny\nz\n\n\n\n\n0.10566243270259\n316.81624327026\n0.10566243270259\n0.21132486540519\n0\n\n\n0.10566243270259\n316.81624327026\n0.10566243270259\n0.78867513459481\n0\n\n\n0.39433756729741\n345.68375672974\n0.39433756729741\n0.21132486540519\n0\n\n\n0.39433756729741\n345.68375672974\n0.39433756729741\n0.78867513459481\n0\n\n\n0.60566243270259\n366.81624327026\n0.60566243270259\n0.21132486540519\n0\n\n\n0.60566243270259\n366.81624327026\n0.60566243270259\n0.78867513459481\n0\n\n\n0.89433756729741\n395.68375672974\n0.89433756729741\n0.21132486540519\n0\n\n\n0.89433756729741\n395.68375672974\n0.89433756729741\n0.78867513459481\n0\n\n\n\nDisplaced VPP output:\n\n\n\nid\ntemperature_material\nx\ny\nz\n\n\n\n\n0.1056958406132\n366.81624327026\n0.1056958406132\n0.78914481344896\n0\n\n\n0.10573288589375\n366.81624327026\n0.10573288589375\n0.21145071547486\n0\n\n\n0.39446224731715\n395.68375672974\n0.39446224731715\n0.78935207603834\n0\n\n\n0.39460050218634\n395.68375672974\n0.39460050218634\n0.2115062513183\n0\n\n\n0.60597117492747\n366.81624327026\n0.60597117492747\n0.78952409424419\n0\n\n\n0.60615762034783\n366.81624327026\n0.60615762034783\n0.21155234345764\n0\n\n\n0.89505790470932\n395.68375672974\n0.89505790470932\n0.78978679413302\n0\n\n\n0.89527479957529\n395.68375672974\n0.89527479957529\n0.21162273368071\n0",
          "url": "https://github.com/idaholab/moose/discussions/22935",
          "updatedAt": "2023-01-03T23:56:46Z",
          "publishedAt": "2022-12-09T19:51:47Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe Sampler1DReal was written for 1D thermal hydraulics, which does not use displaced meshes afaik.\nThe code is not considering the displaced mesh or problem\nThe q_points are correct because use_displaced_mesh makes sure of that.\nAdapting it to use displaced mesh and problem would not be too difficult if you want to give it a try\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22935#discussioncomment-4357194",
                  "updatedAt": "2022-12-09T21:39:30Z",
                  "publishedAt": "2022-12-09T21:39:14Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "You have much more confidence in my ability than I do. Can I get a hint? I think this could be a useful capability.",
                          "url": "https://github.com/idaholab/moose/discussions/22935#discussioncomment-4357898",
                          "updatedAt": "2022-12-09T22:41:51Z",
                          "publishedAt": "2022-12-09T22:41:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "anywhere where it says problem you use getDisplacedProblem() from the FEProblem instead\nhttps://mooseframework.inl.gov/docs/doxygen/moose/classFEProblemBase.html#a6bdd4ae4d1d41245e59c8bccf35e3f94\nand if you get the mesh from the displaced problem it ll be the displaced mesh",
                          "url": "https://github.com/idaholab/moose/discussions/22935#discussioncomment-4357923",
                          "updatedAt": "2022-12-09T22:46:58Z",
                          "publishedAt": "2022-12-09T22:46:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "friedmud"
                  },
                  "bodyText": "The \"displaced\" option for PPs/VPPs works somewhat counter-intuitively:\n\n\nWith displaced_mesh = true the mesh will move across the stationary PP/VPP. (Think Lagrangian motion of a mesh moving across/through something\n\n\nWhen it's false the PP stays in the elements you put it in in the beginning (because they are not moving).  So it will effectively \"move\" with the material (because even though the displaced mesh is moving - the PP/VPP will always sample the same positions)\n\n\nJust keep in mind that it's the mesh that is displaced - not the PP/VPP",
                  "url": "https://github.com/idaholab/moose/discussions/22935#discussioncomment-4358095",
                  "updatedAt": "2022-12-09T23:12:03Z",
                  "publishedAt": "2022-12-09T23:12:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Interesting. Didn't realize that. So if you're sampling a point in space, and the mesh displaces to the right, the coordinates returned by the VPP will shift to the left because the point stayed still but the mesh moved?",
                          "url": "https://github.com/idaholab/moose/discussions/22935#discussioncomment-4359314",
                          "updatedAt": "2022-12-10T01:27:55Z",
                          "publishedAt": "2022-12-10T01:27:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "friedmud"
                          },
                          "bodyText": "Exactly.\nWell - the effect is like that.  But the sampling point stays still while the mesh moves across it.\n(Just being extra clear incase others find this and read along)",
                          "url": "https://github.com/idaholab/moose/discussions/22935#discussioncomment-4361299",
                          "updatedAt": "2022-12-10T06:25:58Z",
                          "publishedAt": "2022-12-10T06:25:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jessecarterMOOSE"
                  },
                  "bodyText": "What's the difference between _fe_problem and _subproblem?",
                  "url": "https://github.com/idaholab/moose/discussions/22935#discussioncomment-4359310",
                  "updatedAt": "2022-12-10T01:25:26Z",
                  "publishedAt": "2022-12-10T01:25:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Subproblem is an intermediate class between Problem and FEProblemBase\nI think the idea was to split routines between several levels of inheritance, as these classes are huge\nIt s also to hold some routines that may be shared between multiple types of problems.\nFor your case, they point to \"same object\" but with different class types. You get more routines available on the _subproblem\n@lindsayad or @friedmud in case I m wrong",
                          "url": "https://github.com/idaholab/moose/discussions/22935#discussioncomment-4373461",
                          "updatedAt": "2022-12-11T21:28:56Z",
                          "publishedAt": "2022-12-11T21:28:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If use_displaced_mesh = true, then _subproblem points to the displaced problem, not the finite element problem (_fe_problem). _subproblem exists because objects will either be on the undisplaced subproblem (the finite element problem) or the displaced subproblem",
                          "url": "https://github.com/idaholab/moose/discussions/22935#discussioncomment-4383889",
                          "updatedAt": "2022-12-12T21:54:21Z",
                          "publishedAt": "2022-12-12T21:54:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}