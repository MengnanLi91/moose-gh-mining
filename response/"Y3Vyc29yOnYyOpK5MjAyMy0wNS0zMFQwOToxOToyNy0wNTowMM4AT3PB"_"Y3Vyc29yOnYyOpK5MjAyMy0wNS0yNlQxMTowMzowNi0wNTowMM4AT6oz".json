{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNS0yNlQxMTowMzowNi0wNTowMM4AT6oz"
    },
    "edges": [
      {
        "node": {
          "title": "Question about Multiphysics(solving more than two equation)",
          "author": {
            "login": "bosxered"
          },
          "bodyText": "Hello Moose experts,\nI ran a transient simulation and checked my results and I noticed that it is, absolutely, physically wrong results.\nIn my opinion, something is wrong with simulation or numerical methods.\nSo, I have some questions about the Moose and FEM method.\nI tried to solve two different equations below. N and V are the variables, and a, b, c, and d are the constants.\n\nI wonder if \"My equations\" and  \"Moose's equations\" make the same results.\nIs nothing wrong with this in FEM methods? Is it a natural or obvious thing?\nIf something is wrong, how do I avoid this in Moose?\nIn my opinion, solving two different equations self-consistently(when one converges and then the other one is started to solve) is a good option if it is possible in the Moose.\nFor your information, I attached my input file below (actually solving three different equations).\n########## Global Parameters ########## \nxmax = 35\nymax = 20\n#######################################\n\n\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 35\n  ny = 60\n  nz = 0\n  xmin = 0\n  xmax = ${xmax}\n  ymin = 0\n  ymax = ${ymax}\n  zmin = 0\n  zmax = 0\n  elem_type = QUAD8\n[]\n\n[Functions]\n  [./bc_func]\n    type = PiecewiseLinear\n    data_file = './vsweep.csv'\n    format = columns\n    scale_factor = 1.0\n  [../]\n[]\n\n[Variables]\n  [./N]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  [./V]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n\n  [./T]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 300.0\n  [../]\n[]\n\n[ICs]\n  [./N_IC]\n    type = MultiBoundingBoxIC\n    corners = '0.0 0.0 0   '\n    opposite_corners = '9.0 20.0 0'\n    inside = '1.2'\n    outside = 0.0\n    variable = N\n  [../]\n[]\n\n[BCs]\n  [V_top]\n    type = FunctionDirichletBC\n    variable = V\n    function = bc_func # GND\n    boundary = 'top'\n  []\n\n  [V_bot]\n    type = DirichletBC\n    variable = V\n    value = 0.0\n    boundary = 'bottom'\n  []\n\n  [./T_top]\n    type = DirichletBC\n    boundary = top\n    variable = T\n    value = 300 #in K\n  [../]\n\n  [./T_bot]\n    type = DirichletBC\n    boundary = bottom\n    variable = T\n    value = 300 #in K\n  [../]\n[]\n\n[Kernels]\n\n  ########### Phase-field ############\n\n  [./Matdiff_D_del2_N]\n    type = MatDiffusion\n    variable = N\n    diffusivity = Diff_coeff\n  [../]\n\n  [./Matdiff_N_del2_V]\n    type = MatDiffusion\n    variable = V\n    diffusivity = eDkT_times_N\n  [../]\n\n  [./TJHS_del_N_del_V]\n    type = ThermalJouleHeatingSource\n    variable = N\n    elec = V\n    electrical_conductivity = eDkT\n    Seebeck_coefficient = 1\n  []\n\n  [./PFM_time]\n    type = TimeDerivative\n    variable = N\n  [../]\n\n  ########## Phase-field END ##########\n\n  ########## Electrical ###############\n\n  [./Matdiff_sig_del2_V]\n    type = MatDiffusion\n    variable = V\n    diffusivity = 'electrical_conductivity'\n  [../]\n\n  ########## Electrical END ###########\n\n  ###### Heat ######\n\n  [./HeatDiff]\n    type = HeatConduction\n    variable = T\n  [../]\n\n#  [./HeatTdot]\n#    type = HeatConductionTimeDerivative\n#    variable = T\n#  [../]\n\n  [./HeatSrc]\n    type = JouleHeatingSource\n    variable = T\n    elec = V\n  [../]\n\n  ##################\n\n[]\n\n[Materials]\n  [./Diff_coeff]\n    type = ParsedMaterial\n    property_name  = Diff_coeff\n    coupled_variables = 'T'\n    constant_names       = 'D0      E_A_D    kB        ' #[nm^2/s] [eV]  [eV/K]\n    constant_expressions = '2e+11   1.0      8.617e-5'\n    expression = 'D0*exp(-E_A_D/(kB*T))' #[nm^2/s]\n    outputs = exodus\n  [../]\n\n  [./eDkT_times_N]\n    type = ParsedMaterial\n    property_name = eDkT_times_N\n    coupled_variables = 'N  T'\n    constant_names       = 'kB        ' #[V/K]  [K]\n    constant_expressions = '8.617e-5'\n    material_property_names = 'Diff_coeff'\n    expression = 'Diff_coeff/(kB*T)*N' #[1/(s*V*nm)]\n    outputs = exodus\n  [../]\n\n  [./eDkT]\n    type = ParsedMaterial\n    property_name = eDkT\n    coupled_variables = 'T'\n    constant_names       = 'kB       ' #[V/K]\n    constant_expressions = '8.617e-5'\n    material_property_names = 'Diff_coeff'\n    expression = 'Diff_coeff/(kB*T)' #[nm^2/(s*V)]\n    outputs = exodus\n  [../]\n\n  [./electrical_conductivity_INS]\n    type = ParsedMaterial\n    coupled_variables = 'N E_AC_elec T'\n    property_name = 'electrical_conductivity'\n    constant_names =        'sig_H    sig_L     kB'       \n    constant_expressions =  '1.0e-6   2.860e-4  8.617' #[1/(ohm*nm)] [1/(ohm*nm)] [eV/K]\n#    material_property_names = 'h'\n#    function = '(1/cm_2_nm) * if(eta <= 0.5-w/2,Crys,if(eta<0.5+w/2, Amor + 0.5*(Crys+Amor)*(1.0+cos(pi*(eta-0.5+w/2)/w)),Amor))'  # [1/(ohm*nm)]\n#    function = '(sig_L - sig_H) * eta + sig_H'  # [1/(ohm*nm)]\n#    function = 'if(c <= 0.5-w/2, sig_H, if(c > 0.5+w/2, sig_L, sig_H + 0.5 * (sig_L-sig_H) * (1 - cos(pi/w * (c-0.5+w/2)))))'\n#    expression = 'sig_H*(1-h)+sig_L*h'\n    expression = '((sig_L-sig_H)/1.2*N+sig_H)*exp(-E_AC_elec/(kB*T))'\n    outputs = exodus\n#    block = 2\n  [../]\n\n  ####### Heat #######\n  [./k]\n    type = ParsedMaterial\n    property_name = 'thermal_conductivity'\n    coupled_variables = 'N'\n    constant_names =        'k_H      k_L'\n    constant_expressions =  '0.5e-9   57.5e-9'\n    expression = '(k_L-k_H)/1.2*N+k_H'    # W/(nm K)\n    outputs = exodus\n  [../]\n\n  ####################\n\n\n[]\n\n[AuxVariables]\n\n  ########## Electric ##########\n  [Ex]\n    order = FIRST\n    family = MONOMIAL\n  []\n\n  [Ey]\n    order = FIRST\n    family = MONOMIAL\n  []\n\n  [J]\n    family = NEDELEC_ONE\n    order = FIRST\n  []\n\n  [Jy]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [E_AC_elec]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n  ######## Electric END ########\n\n[]\n\n\n[AuxKernels]\n  ########## Electric ##########\n  [Ex_aux]\n    type = PotentialToFieldAux\n    variable = Ex\n    gradient_variable = V\n    sign = negative\n    component = x\n  []\n\n  [Ey_aux]\n    type = PotentialToFieldAux\n    variable = Ey\n    gradient_variable = V\n    sign = negative\n    component = y\n  []\n\n  [current_density]\n    type = CurrentDensity\n    variable = J\n    potential = V\n  []\n\n  [Jy]\n    type = VectorVariableComponentAux\n    variable = Jy\n    vector_variable = J\n    component = y\n  []\n\n  [E_AC_elec_aux]\n    type = ParsedAux\n    variable = E_AC_elec\n    coupled_variables = 'N'\n    constant_names = 'Nth  E_AC'\n    constant_expressions = '0.2  0.05' #[nm^-3] [eV]\n    expression = 'if(N>Nth, 0, -E_AC/Nth*N + E_AC)'\n    execute_on = 'initial linear timestep_end'\n  []\n\n  ######## Electric END ########\n[]\n\n\n\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Postprocessors]\n\n  ######## Electric #######\n\n  #  [./Resistance]\n  #    type = FunctionValuePostprocessor\n  #    function = resistance_func\n  #  [../]\n\n  [average_V]\n    type = SideAverageValue\n    variable = V\n    boundary = 'top'\n  []\n\n  [average_Jy]\n    type = SideAverageValue\n    variable = Jy\n    boundary = 'bottom'\n  []\n\n  [Current]\n    type = ParsedPostprocessor\n    function = \"if(average_Jy>0,average_Jy*${xmax}, -average_Jy*${xmax})\"\n    pp_names = average_Jy\n  []\n  ######## Electric END #######\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = 'PJFNK'\n\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre      boomeramg'\n\n  l_max_its = 30\n  l_tol = 1.0e-4\n  nl_rel_tol = 1.0e-8\n  nl_abs_tol = 1e-8\n\n  start_time = 0.0\n  end_time = 1.2\n  dt = 5e-3\n  dtmin = 1e-4\n\n  automatic_scaling = true\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  file_base = output\n\n#  [myexo]\n#    type = Exodus\n#    file_base = five\n#    interval = 5\n#    end_step = 21000\n#  []\n\n  [mymycp]\n    type = Checkpoint\n    num_files = 3\n    interval = 10\n    file_base = mycp\n  []\n\n[]\n\nSorry for bothering you guys but I am a beginner in this numerical calculation area.\nBest wishes,\nJeonghwan",
          "url": "https://github.com/idaholab/moose/discussions/24523",
          "updatedAt": "2023-05-30T13:27:45Z",
          "publishedAt": "2023-05-29T19:35:40Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou have 3 (nonlinear, in [Variables]) variables. MOOSE is actually solving 3 equations.\nIt's not mixing equations like you're suggesting. You can verify that yourself by moving some variables from [Variables] to constant [AuxVariables] and checking the equations one by one.\nI think that's the next step for you here. Making sure each equation is correct, tackling one at a time.\nPlease keep in mind that variable = in a kernel is both:\n\na way to indicate the equation that the kernel is part of\na way to indicate which variable the kernel acts on, but sometimes, for example for this object, you can make it act on another variable using a v parameter\nhttps://mooseframework.inl.gov/source/kernels/ADCoupledTimeDerivative.html\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24523#discussioncomment-6032319",
                  "updatedAt": "2023-05-29T21:47:42Z",
                  "publishedAt": "2023-05-29T21:47:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "So your answer means, I am doing wrong because I want to solve the \"red box two equations\" in my image file but I am solving the \"blue box two equations\".\nIn order to solve the red box two equations, I have to set a kernel not\n  [./Matdiff_N_del2_V]\n    type = MatDiffusion\n    variable = V\n    diffusivity = eDkT_times_N\n  [../]\n\n\nthis one, but the below one using the 'Something_new_kernel'\n  [./Matdiff_N_del2_V]\n    type = Something_new_kernel\n    variable = N\n    elec(coupled_variables) = V\n    constant = eDkT\n  [../]\n\n\nIf what I understand is correct, it makes sense!\nAm I right?",
                          "url": "https://github.com/idaholab/moose/discussions/24523#discussioncomment-6033806",
                          "updatedAt": "2023-05-30T04:05:03Z",
                          "publishedAt": "2023-05-30T04:04:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is c in your equations eDkT ?\nYou need cN as a factor to the diffusion term.\nBut yes that is one kernel you'll have to change.",
                          "url": "https://github.com/idaholab/moose/discussions/24523#discussioncomment-6037517",
                          "updatedAt": "2023-05-30T12:14:23Z",
                          "publishedAt": "2023-05-30T12:14:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Thank you very much!",
                          "url": "https://github.com/idaholab/moose/discussions/24523#discussioncomment-6038255",
                          "updatedAt": "2023-05-30T13:27:40Z",
                          "publishedAt": "2023-05-30T13:27:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Solving phase-field only in a specific block",
          "author": {
            "login": "bosxered"
          },
          "bodyText": "Hello Moose experts,\nI want to divide my system into two blocks and solve phase-field physics and Matdiffusion.\nFor all systems (both blocks), I want to solve Matdiffusion and for only one block, I want to solve phase-field physics.\nI tried but it failed and I don't know where the problem is.\nSo I tried to start from the example file(modules/phase_field/test/tests/KKS_system/kks_example_split.i) to add a block but it also failed.\n\nMaybe the same problem is the matter in my file and the corrected example file.\nHere are the corrected input file(kks_example_split.i) and error messages.\n#\n# KKS toy problem in the split form\n#\n### Global Parameters ###\nxmax = 5.0\nymax = 10.0\n\n\n#########################\n[Mesh]\n  [./gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 15\n    ny = 15\n    nz = 0\n    xmin = 0.00\n    xmax = ${xmax}\n    ymin = 0.00\n    ymax = ${ymax}\n    zmin = 0\n    zmax = 0\n    elem_type = QUAD4\n  [../]\n  [./blk0]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 0\n    bottom_left = '0.0  5.000  0.0'\n    top_right = '${xmax} 10.0000  0.0'\n    block_name = 'TE'\n    input = gen\n  [../]\n  [./blk1]\n    type = SubdomainBoundingBoxGenerator\n    block_id = 1\n    bottom_left = '0.00  0.00  0.0'\n    top_right = '${xmax} 5.00  0.0'\n    block_name = 'INS'\n    input = blk0\n  [../]\n\n[]\n\n[Variables]\n  # order parameter\n  [./eta]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  # hydrogen concentration\n  [./c]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  # chemical potential\n  [./w]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  # hydrogen phase concentration (matrix)\n  [./cm]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n  # hydrogen phase concentration (delta phase)\n  [./cd]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n\n  [./V]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  []\n[]\n\n[ICs]\n  [./eta]\n    variable = eta\n    type = SmoothCircleIC\n    x1 = 0.0\n    y1 = 0.0\n    radius = 1.5\n    invalue = 0.2\n    outvalue = 0.1\n    int_width = 0.75\n    block = 1\n  [../]\n  [./c]\n    variable = c\n    type = SmoothCircleIC\n    x1 = 0.0\n    y1 = 0.0\n    radius = 1.5\n    invalue = 0.6\n    outvalue = 0.4\n    int_width = 0.75\n    block = 1 \n  [../]\n[]\n\n\n[BCs]\n  [V_top]\n    type = DirichletBC\n    variable = V\n    value = 0.10\n    boundary = 'top'\n  []\n\n  [V_bot]\n    type = DirichletBC\n    variable = V\n    value = 0.0\n    boundary = 'bottom'\n  []\n[]\n\n[Materials]\n  # Free energy of the matrix\n  [./fm]\n    type = DerivativeParsedMaterial\n    property_name = fm\n    coupled_variables = 'cm'\n    expression = '(0.1-cm)^2'\n    outputs = exodus\n\n    block = 1 \n  [../]\n\n  # Free energy of the delta phase\n  [./fd]\n    type = DerivativeParsedMaterial\n    property_name = fd\n    coupled_variables = 'cd'\n    expression = '(0.9-cd)^2'\n    outputs = exodus\n\n    block = 1 \n  [../]\n\n  # h(eta)\n  [./h_eta]\n    type = SwitchingFunctionMaterial\n    h_order = HIGH\n    eta = eta\n    outputs = exodus\n\n    block = 1 \n  [../]\n\n  # g(eta)\n  [./g_eta]\n    type = BarrierFunctionMaterial\n    g_order = SIMPLE\n    eta = eta\n    outputs = exodus\n\n    block = 1 \n  [../]\n\n  # constant properties\n  [./constants]\n    type = GenericConstantMaterial\n    prop_names  = 'M   L   kappa'\n    prop_values = '0.7 0.7 0.4  '\n\n    block = 1 \n  [../]\n  [./electrical_conductivity_INS]\n    type = ParsedMaterial\n    coupled_variables = 'eta'\n    f_name = 'electrical_conductivity'\n    constant_names =        'sig_H  sig_L   pi        w'\n    constant_expressions =  '2.0e-9   2.0e-5  3.14159   0.15'\n    material_property_names = 'h'\n#    function = '(1/cm_2_nm) * if(eta <= 0.5-w/2,Crys,if(eta<0.5+w/2, Amor + 0.5*(Crys+Amor)*(1.0+cos(pi*(eta-0.5+w/2)/w)),Amor))'  # [1/(ohm*nm)]\n#    function = '(sig_L - sig_H) * eta + sig_H'  # [1/(ohm*nm)]\n#    function = 'if(c <= 0.5-w/2, sig_H, if(c > 0.5+w/2, sig_L, sig_H + 0.5 * (sig_L-sig_H) * (1 - cos(pi/w * (c-0.5+w/2)))))'\n    expression = 'sig_H*(1-h)+sig_L*h'\n    outputs = exodus\n    block = 1\n  [../]\n\n  [./electrical_conductivity_TE]\n    type = ParsedMaterial\n    coupled_variables = 'eta'\n    f_name = 'electrical_conductivity'\n    expression = '6.3e-2'\n    outputs = exodus\n    block = 0\n  [../]\n[]\n\n[Kernels]\n  ######## Electric START ########\n  [./CoupledLaplace_V]\n    type = MatDiffusion\n    variable = V\n    diffusivity = electrical_conductivity\n  [../]\n  ######## Electric END ##########\n\n  # enforce c = (1-h(eta))*cm + h(eta)*cd\n  [./PhaseConc]\n    type = KKSPhaseConcentration\n    ca       = cm\n    variable = cd\n    c        = c\n    eta      = eta\n    block = 1 \n  [../]\n\n  # enforce pointwise equality of chemical potentials\n  [./ChemPotVacancies]\n    type = KKSPhaseChemicalPotential\n    variable = cm\n    cb       = cd\n    fa_name  = fm\n    fb_name  = fd\n    block = 1 \n  [../]\n\n  #\n  # Cahn-Hilliard Equation\n  #\n  [./CHBulk]\n    type = KKSSplitCHCRes\n    variable = c\n    ca       = cm\n    fa_name  = fm\n    w        = w\n    block = 1 \n  [../]\n\n  [./dcdt]\n    type = CoupledTimeDerivative\n    variable = w\n    v = c\n#    block = 1 \n  [../]\n  [./ckernel]\n    type = SplitCHWRes\n    mob_name = M\n    variable = w\n    block = 1 \n  [../]\n\n  #\n  # Allen-Cahn Equation\n  #\n  [./ACBulkF]\n    type = KKSACBulkF\n    variable = eta\n    fa_name  = fm\n    fb_name  = fd\n    coupled_variables     = 'cm cd'\n    w        = 0.4\n    block = 1 \n  [../]\n  [./ACBulkC]\n    type = KKSACBulkC\n    variable = eta\n    ca       = cm\n    cb       = cd\n    fa_name  = fm\n    block = 1 \n  [../]\n  [./ACInterface]\n    type = ACInterface\n    variable = eta\n    kappa_name = kappa\n    block = 1 \n  [../]\n  [./detadt]\n    type = TimeDerivative\n    variable = eta\n#    block = 1 \n  [../]\n[]\n\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pctype -sub_pc_type -sub_pc_factor_shift_type -pc_factor_shift_type'\n  petsc_options_value = ' asm    lu          nonzero                    nonzero'\n\n  l_max_its = 100\n  nl_max_its = 100\n  num_steps = 500\n\n  dt = 0.1\n[]\n\n#\n# Precondition using handcoded off-diagonal terms\n#\n[Preconditioning]\n  [./full]\n    type = SMP\n    full = true\n  [../]\n[]\n\n\n[Outputs]\n  file_base = split\n  exodus = true\n[]\n\nLEGACY MODES ENABLED:\n This application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate diffs due to zero values being stored, and these tests should be re-golded.\n\n\nTime Step 0, time = 0\n\nTime Step 1, time = 0.1, dt = 0.1\n 0 Nonlinear |R| = 3.880270e+00\n[0]PETSC ERROR: --------------------- Error Message --------------------------------------------------------------\n[0]PETSC ERROR: Object is in wrong state\n[0]PETSC ERROR: Matrix is missing diagonal entry 865\n[0]PETSC ERROR: See https://petsc.org/release/faq/ for trouble shooting.\n[0]PETSC ERROR: Petsc Release Version 3.16.6, unknown\n[0]PETSC ERROR: test3-opt on a arch-moose named cnode26 by jjh2021 Thu May 25 02:53:47 2023\n[0]PETSC ERROR: Configure options --download-hypre=1 --with-shared-libraries=1 --download-hdf5=1 --download-hdf5-fortran-bindings=0   --with-debugging=no --download-fblaslapack=1 --download-metis=1 --download-ptscotch=1 --download-parmetis=1 --download-superlu_dist=1 --download-mumps=1 --download-scalapack=1 --download-slepc=1 --with-mpi=1 --with-openmp=1 --with-cxx-dialect=C++11 --with-fortran-bindings=0 --with-sowing=0 --with-64-bit-indices\n[0]PETSC ERROR: #1 MatILUFactorSymbolic_SeqAIJ() at /home2/users/jjh2021/lib/Moose/moose/petsc/src/mat/impls/aij/seq/aijfact.c:1697\n[0]PETSC ERROR: #2 MatILUFactorSymbolic() at /home2/users/jjh2021/lib/Moose/moose/petsc/src/mat/interface/matrix.c:6944\n[0]PETSC ERROR: #3 PCSetUp_ILU() at /home2/users/jjh2021/lib/Moose/moose/petsc/src/ksp/pc/impls/factor/ilu/ilu.c:144\n[0]PETSC ERROR: #4 PCSetUp() at /home2/users/jjh2021/lib/Moose/moose/petsc/src/ksp/pc/interface/precon.c:1017\n[0]PETSC ERROR: #5 KSPSetUp() at /home2/users/jjh2021/lib/Moose/moose/petsc/src/ksp/ksp/interface/itfunc.c:408\n[0]PETSC ERROR: #6 KSPSolve_Private() at /home2/users/jjh2021/lib/Moose/moose/petsc/src/ksp/ksp/interface/itfunc.c:852\n[0]PETSC ERROR: #7 KSPSolve() at /home2/users/jjh2021/lib/Moose/moose/petsc/src/ksp/ksp/interface/itfunc.c:1086\n[0]PETSC ERROR: #8 SNESSolve_NEWTONLS() at /home2/users/jjh2021/lib/Moose/moose/petsc/src/snes/impls/ls/ls.c:225\n[0]PETSC ERROR: #9 SNESSolve() at /home2/users/jjh2021/lib/Moose/moose/petsc/src/snes/interface/snes.c:4809\nlibMesh terminating:\nMatrix is missing diagonal entry 865\nAbort(1) on node 0 (rank 0 in comm 0): application called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n\n\nThank you always.\nBest regards,\nJeonghwan.",
          "url": "https://github.com/idaholab/moose/discussions/24478",
          "updatedAt": "2023-05-29T18:58:14Z",
          "publishedAt": "2023-05-25T06:26:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe problem is that you defined every single variable on both blocks.\nThis means that the equation for \"half\" of the variables' degrees of freedom is empty, it creates a singular system.\nPlease add block = to every variable that does not span the entire domain.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24478#discussioncomment-6000430",
                  "updatedAt": "2023-05-25T12:26:49Z",
                  "publishedAt": "2023-05-25T12:26:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Thanks for your answer!\nBut I wonder why my colleague's input file does work even if his file says that it also solves Allen-Cahn eq. only in block=0 but the block = is not shown in [Variable].\nFor your information:\nThe difference with my input file that I found is that in the [Material], there are material properties that have 'eta' as 'args' which is the variable of the phase-field kernel but defined on the block= '1 2' which the phase-field equation is not solved (Please see [./specific_heat_TE], [./density_TiN], and [electrical_conductivity_TiN] ). But I don't think it is the reason because I tried it :(\nHere is my colleague's input file.\nVoltage = 0.42\n\nxmax = 90\nymax = 63\ndelta = 3 \n\nnx = ${fparse ${xmax} / ${delta} }\nny = ${fparse ${ymax} / ${delta} }\n\n######## PFM ########\nW = 10\nkappa = 0.24\nksi = 0.8\n######## PFM ########\n\n[Mesh]\n  [./gen]\n  type = GeneratedMeshGenerator\n  dim = 2\n  elem_type = QUAD8\n  nx = ${nx}\n  ny = ${ny}\n  nz = 0\n  xmin = 0\n  xmax = ${xmax}\n  ymin = 0\n  ymax = ${ymax}\n  [../]\n\n  [./block1] # TE block 1\n    type = SubdomainBoundingBoxGenerator\n    block_id = 1\n    bottom_left = '0.0 21.0 0.0'\n    top_right = '${xmax} 63.0 0.0'\n    block_name = 'TE'\n    input = gen\n  [../]\n\n  [./block2] # BE\n    type = SubdomainBoundingBoxGenerator\n    block_id = 2\n    bottom_left = '0.0 0.0 0.0'\n    top_right = '${xmax} 21.0 0.0'\n    block_name = 'BE'\n    input = block1\n  [../]\n\n  [./block0] # Sb\n    type = SubdomainBoundingBoxGenerator\n    block_id = 0\n    bottom_left = '0.0 21.0 0.0'\n    top_right = '${xmax} 24.0 0.0'\n    block_name = 'Sb'\n    input = block2\n  [../]\n\n  [./TE_bottom]\n    type = SideSetsAroundSubdomainGenerator\n    block = 1\n    new_boundary = 'TE_bottom'\n    normal = '0 -1 0'\n    input = block0\n  [../]\n\n  [./TE_right]\n    type = SideSetsAroundSubdomainGenerator\n    block = 1\n    new_boundary = 'TE_right'\n    normal = '1 0 0'\n    input = TE_bottom\n  [../]\n\n  [./TE_left]\n    type = SideSetsAroundSubdomainGenerator\n    block = 1\n    new_boundary = 'TE_left'\n    normal = '-1 0 0'\n    input = TE_right\n  [../]\n\n  [./BE_top]\n    type = SideSetsAroundSubdomainGenerator\n    block = 2\n    new_boundary = 'BE_top'\n    normal = '0 1 0'\n    input = TE_left\n  [../]\n\n  [./BE_right]\n    type = SideSetsAroundSubdomainGenerator\n    block = 2\n    new_boundary = 'BE_right'\n    normal = '1 0 0'\n    input = BE_top\n  [../]\n\n  [./BE_left]\n    type = SideSetsAroundSubdomainGenerator\n    block = 2\n    new_boundary = 'BE_left'\n    normal = '-1 0 0'\n    input = BE_right\n  [../]\n\n  [./refine_BE]\n    type = RefineBlockGenerator\n    input = BE_left\n    block = 2\n    refinement = '1'\n  [../]\n\n  [./refine_Sb]\n    type = RefineBlockGenerator\n    input = refine_BE\n    block = 0\n    refinement = '3'\n  [../]\n[]\n\n[Functions]\n    [./parsed_function]\n        type= ParsedFunction\n        value = 'y/24*${Voltage}'\n    [../]\n\n    [./resistance_func]\n        type = ParsedFunction\n        #  value = 'if(Current<1e10, if(Current > 2e-8, Voltage/Current, 0.0), 0.0)'\n        value = 'if(t <=0.5e-9, 1e10, if(Voltage > 0.0005, if(Current > 1e-9, Voltage/Current, 1e10), 1e10))'\n        vars = 'Voltage   Current' \n        vals = 'bc_func_2 Current'\n    [../]\n\n    [./bc_func]\n        type = PiecewiseLinear\n        #  data_file = \"./pp_50ns_rp_30ns.csv\"\n        data_file = \"./pp_25ns_rp_25ns_longer.csv\"\n        #  data_file = \"./pp_steady.csv\"\n        #  data_file = \"./piecewise_linear_bc_100.csv\"\n        format = columns\n        scale_factor = 1.0\n        execute_on = 'INITIAL LINEAR'\n    [../]\n\n    [./test_func]\n        type = ConstantFunction\n        value = 2\n    [../]\n\n    [./bc_func_2]\n        type = ParsedFunction\n        value ='bc_func * if(t<999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_0 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),\n                          if(t<1999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_1 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(t<2999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_2 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)), \n                          if(t<3999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_3 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(t<4999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_4 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(t<5999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_5 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(t<6999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_6 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(t<7999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_7 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(t<8999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_8 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(t<9999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_9 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(t<10999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_10 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(t<11999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_11 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(t<12999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_12 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(t<13999e-9, if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_13 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, -0.05, 0.0)),  \n                          if(bc_func > 1e-10, (3*TE_avg + (0.95*R_cell+0.05*R_min_time) * Vp_14 / (R_l + 0.95*R_cell+0.05*R_min_time))/4, if(bc_func < -1e-10, 0.05, 0.0))))))))))))))))'\n        vals = 'TE_avg  0.4         bc_func Resistance_min_time  Resistance 1.5e4   0.47   0.618   0.718   0.818  0.918    1.018   1.118   1.218   1.318   1.418   1.518  1.618  1.718     1.818 1.918'\n        vars = 'TE_avg  V_initial   bc_func R_min_time           R_cell    R_l      Vp_0   Vp_1     Vp_2    Vp_3   Vp_4     Vp_5    Vp_6    Vp_7    Vp_8    Vp_9    Vp_10  Vp_11  Vp_12     Vp_13 Vp_14'\n    [../]\n    [./dts]\n        type = ParsedFunction\n        value = 'if(t%100e-9 < 6e-9,  0.5e-9 , if(T_max_Sb < 550 , 1e-9, if(T_max_Sb < 575, 2e-10 ,if(T_max_Sb < 600, 1e-10, if(T_max_Sb < 625, 5e-11, if(T_max_Sb < 650, 2e-11, 1e-11))))))'\n        vals = 'T_max_time T_max_Sb'\n        vars = 'T_max_time T_max_Sb'\n    [../]\n[]\n\n[Variables]\n\n  [T]\n    order = FIRST\n    family = LAGRANGE\n  []\n\n  [./V] # potential [V]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n\n  [./eta]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n\n[ICs]\n    [./eta_0]\n        type = ConstantIC\n        variable = eta\n        value = 1.0\n        block = 0\n    [../]\n\n    [./T_ic]\n        type = ConstantIC\n        variable = T\n        value = 300\n        block = '0 1 2'\n    [../]\n\n    [./V_ic_0]\n        type = FunctionIC\n        function = parsed_function\n        variable = V\n        block = '0'\n    [../]\n\n    [./V_ic_1]\n        type = ConstantIC\n        variable = V\n        value = ${Voltage}\n        block = 1\n    [../]\n\n    [./V_ic_2]\n        type = FunctionIC\n        function = '0.0'\n        variable = V\n        block = '0'\n    [../]\n\n[]\n\n\n[AuxVariables]\n\n  [Ex]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [Ey]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [J]\n    family = NEDELEC_ONE\n    order = FIRST\n  []\n\n  [Jy]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [JouleHeat_Aux]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  ######## Regarding PFM ########\n\n  [./I_N] # Nucleation rate [nm^-3*s^-1]\n    order = CONSTANT \n    family = MONOMIAL\n  [../]\n\n  [./V_G] # Growth velocity [nm/s]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n  [./log10mu] # viscosity [log(Pa s)]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  \n  [./DeltaG] # [eV/nm^3]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n  [./DeltaG_star] # nucleation barrier [eV]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n  [./DeltaG_Jpermol] # [J/mol]\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n  [./eta_element]  # for NucleationElementID\n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n\n  [./Interfacial_free_energy] # [eV/nm^2] \n    order = CONSTANT\n    family = MONOMIAL\n  [../]\n  ######## PFM END ########\n[]\n\n[Kernels]\n\n  [./heat_conduction]\n    type = HeatConduction\n    variable = T\n  [../]\n\n  [./time_derivative]\n    type = HeatConductionTimeDerivative\n    variable = T\n  [../]\n\n\n  ##### drift Joule Heating Source####\n  [./HeatSource_drift]\n    type = JouleHeatingSource\n    variable = T\n    elec = V\n    electrical_conductivity = electrical_conductivity\n    #  value = 1e3 # doesn't work\n    block = '0 2'\n  [../]\n  #################################\n\n  #### Laplace regarding V ##########\n  [./CoupledLaplace_V]\n    type = MatDiffusion\n    variable = V\n    diffusivity = electrical_conductivity\n    #  block = '0 2'\n  [../]\n  ###############################  \n\n  ########## S2 : Laplace regarding T ##############\n  [./CoupledLaplace_T]\n    type = MatDiffusion\n    variable = T\n    diffusivity = sigma_times_Seebeck_coefficient\n    #  block = '0 2'\n  [../]\n  ##############################\n\n  ######## S3 : diffusion Joule Heating Source ##############\n  [./HeatSource_diffusion]\n    type = ThermalJouleHeatingSource\n    variable = T\n    elec = V\n    electrical_conductivity = electrical_conductivity\n    Seebeck_coefficient = Seebeck_coefficient\n    #  value = 1e3 # doesn't work\n    block = '0 2'\n  [../]\n  #########################\n\n  ######## PFM ########\n\n  [./detadt]\n    type = TimeDerivative\n    variable = eta\n    block = 0\n  [../]\n\n  [./ACBulk]\n    type = AllenCahn\n    variable = eta\n    mob_name = L\n    f_name = F\n    block = 0\n  [../]\n\n  [./ACInterface]\n    type = ACInterface\n    variable = eta\n    mob_name = L\n    kappa_name = kappa\n    block = 0\n  [../]\n\n  ######## PFM END ########\n\n[]\n\n[AuxKernels]\n\n  [Ex_aux]\n    type = PotentialToFieldAux\n    variable = Ex\n    gradient_variable = V\n    sign = negative\n    component = x\n  []\n\n  [Ey_aux]\n    type = PotentialToFieldAux\n    variable = Ey\n    gradient_variable = V\n    sign = negative\n    component = y\n  []\n\n  ######### S1 ###########\n  [current_density]\n    type = CurrentDensitythermal # drift+diffusion\n    variable = J\n    potential = V\n    temperature = T\n    Seebeck_coefficient = Seebeck_coefficient\n  []\n  ##########################\n\n  [Jy]\n    type = VectorVariableComponentAux\n    variable = Jy\n    vector_variable = J\n    component = y\n    value = 1.0\n    #  value = 1e-7\n  []\n\n  [JouleHeatingHeatGeneratedAux]\n    type = JouleHeatingHeatGeneratedAux\n    elec = V\n    variable = JouleHeat_Aux\n    electrical_conductivity = electrical_conductivity\n    block = '0 2'\n  []\n\n  ######## PFM ########\n\n  [./set_Interfacial_free_energy]\n    type = InterfacialEnergyDensity\n    variable = Interfacial_free_energy\n    W = ${W}\n    kappa = ${kappa}\n    DeltaG = DeltaG\n    block = 0\n  []\n\n  [./set_DeltaG]\n    type = ParsedAux\n    variable = DeltaG\n    args = T\n    constant_names ='Melting_temp   Heat_of_fusion' # [T], [eV/nm^-3]\n    constant_expressions = '903.78  6.722'\n    function = 'Heat_of_fusion*((Melting_temp-T)/Melting_temp)*(2*T/(Melting_temp+T))'\n    execute_on = 'initial linear timestep_end'\n    block = 0\n  [../]\n\n  [./set_eta_element]\n    type = ParsedAux\n    variable = eta_element\n    args = eta\n    function = 'eta'\n    execute_on = 'initial linear timestep_end'\n    block = 0\n  [../]\n\n  [./set_DeltaGstar]\n    type = ParsedAux\n    variable = DeltaG_star\n    args = 'DeltaG Interfacial_free_energy'\n    constant_names ='pi' # [eV/nm^2], none\n    constant_expressions = '3.141592653589' \n    function = '16*pi*Interfacial_free_energy^3/(3*DeltaG^2)'\n    execute_on = 'initial linear timestep_end'\n    block = 0\n  [../]\n\n  [./set_I_N]\n    type = ParsedAux\n    variable = I_N \n    args = 'T DeltaG DeltaG_star log10mu Interfacial_free_energy'\n    constant_names =        'k_B      vm     jump_dist  pi              J_eV      m3_nm3' # [nm^3], [eV/K], [nm], [eV/nm^2], none, none, none\n    constant_expressions =  '8.617e-5 0.03   0.264      3.141592653589  6.2415e18 1e27'\n    function = '4*(1/vm)*(6*k_B*T/(3*pi*jump_dist^3*((10^log10mu)*J_eV/m3_nm3)))*((32*pi*Interfacial_free_energy^3/(3*vm*DeltaG^3))^(2/3))*sqrt(DeltaG*vm/(6*pi*k_B*T*(32*pi*Interfacial_free_energy^3/(3*vm*DeltaG^3))))*exp(-DeltaG_star/(k_B*T))'\n    execute_on = 'initial linear timestep_end'\n    block = 0\n  [../]\n\n  [./set_DeltaG_Jpermol]\n    type = ParsedAux\n    variable = DeltaG_Jpermol # [J/mol]\n    args = T \n    constant_names =        'Heat_of_fusion  Melting_temp' # [J/mol], [K]\n    constant_expressions =  '19870           903.78'      \n    function = 'Heat_of_fusion * (Melting_temp-T)/Melting_temp * (2*T/(Melting_temp+T))'\n    execute_on = 'initial linear timestep_end'\n    block = 0\n  [../]\n\n  [./set_V_G]\n    type = ParsedAux\n    variable = V_G  #[nm/sec]\n    args = 'T log10mu DeltaG_Jpermol'\n    constant_names =        'Melting_temp   k_B         pi                a       J_eV          m3_nm3 R                Tg' #[eV/K], none, [nm], none, none, [J/K*mol], [K]\n    constant_expressions =  '903.78         8.617343e-5 3.141592653589    0.264   6.241509e18   1e27   8.31446261815    394.5'\n    function = 'if(T>=1.2*Tg,(k_B*Melting_temp/(3*pi*(a^2)*((10^log10mu)*J_eV/m3_nm3)))*(1-exp(-1*DeltaG_Jpermol/(R*T))),1.4e2*(k_B*Melting_temp/(3*pi*(a^2)*(((10^log10mu)*J_eV/m3_nm3)^0.63))*(1-exp(-1*DeltaG_Jpermol/(R*T)))))'\n    execute_on = 'INITIAL LINEAR TIMESTEP_BEGIN TIMESTEP_END'\n    block = 0\n  [../]\n\n  [./set_log10mu]\n    type = ParsedAux\n    variable = log10mu \n    args = T\n    constant_names =        'W1    C1' #[K^-1],[K]\n    constant_expressions =  '0.011 1931'\n    function = '-3.243 + 1/(T*(W1*exp(-1.0*C1/T) + W1*exp(-1.0*C1/T)))'\n    execute_on = 'INITIAL TIMESTEP_BEGIN TIMESTEP_END'\n    block = 0\n  [../]\n\n  ######## PFM END ########\n\n[]\n\n\n[Materials]\n  [./Seebeck_coefficient_Sb] # [V/K] * [1/ohm cm] = [A/cm K] \n    type = ParsedMaterial\n    args = T\n    f_name = 'Seebeck_coefficient'\n    constant_names =        'C      D   uV_2_V' # SC1\n    constant_expressions =  '0.0   -55 1e-6'\n    function = 'C*(T+D)*uV_2_V' # [V/K]\n    block = 0\n    #  outputs = exodus\n  []\n\n  [./Seebeck_coefficient_TiN]\n    type = ParsedMaterial\n    args = T\n    f_name = 'Seebeck_coefficient'\n    constant_names =        'uV_2_V' #\n    constant_expressions =  '1e-6'\n    #  function = '50*uV_2_V' # [V/K] haven't found yet\n    #  function = '0.9*uV_2_V' # [uV/K] haven't found yet\n    function = '0.0' # [uV/K] haven't found yet\n    block = '1 2'\n    #  outputs = exodus\n  []\n\n  [./sigma_times_Seebeck_coefficient_Sb] # [V/K] * [1/ohm nm] = [A/nm K] \n    type = ParsedMaterial\n    args = 'eta T'\n    f_name = 'sigma_times_Seebeck_coefficient'\n    constant_names =        'S2       A       cminv_2_nminv crys                w     pi                C      D   uV_2_V' # w : eta interface range, \n    constant_expressions =  '66.66    10.325  1e-7          (1/9.402e-4)/4  0.1   3.141592653589    0.0   -55 1e-6'  # SC2\n    function = 'C*(T+D)*uV_2_V * cminv_2_nminv * if(eta <= 0.5-w/2,crys,if(eta<0.5+w/2, 1/(exp(S2*T^(-1/3)-A))/1.2 + 0.5*(crys+1/(exp(S2*T^(-1/3)-A))/1.2)*(1.0+cos(pi * (eta-0.5+w/2)/w)),1/(exp(S2*T^(-1/3)-A))/1.2))'  # [1/(ohm*cm)]\n    block = 0\n  []\n\n  [./sigma_times_Seebeck_coefficient_TiN]\n    type = ParsedMaterial\n    args = T\n    f_name = 'sigma_times_Seebeck_coefficient'\n    constant_names =        'cm_2_nm uV_2_V' # w : eta interface range, \n    constant_expressions =  '1e7     1e-6'\n    function = '0.0' # haven't found yet\n    block = '1 2'\n  []\n\n  [./thermal_conductivity_Sb]\n    type = ParsedMaterial\n    args = eta\n    f_name = 'thermal_conductivity'\n    constant_names =        'w      crys    amor    pi              cm_2_nm' # w : eta interface range, [W/cm K], [W/cm K]\n    constant_expressions =  '0.1    1.3e-2  0.27e-2 3.141592653589  1e7'\n    function = '(1/cm_2_nm) * if(eta<0.5-w/2, crys, if(eta<0.5+w/2, amor+0.5*(crys-amor)*(1.0+cos(pi*(eta-(0.5-w/2))/w)), amor))' #  [W/nm K]\n    block = 0\n  [../]\n\n  [./thermal_conductivity_TiN]\n    type = ParsedMaterial\n    f_name = 'thermal_conductivity'\n    function = '12e-9' # [W/nm K]\n    block = '1 2'\n  [../]\n\n  [./specific_heat_Sb]\n    type = ParsedMaterial\n    args = eta\n    f_name = 'specific_heat'\n    constant_names =        'w      crys    amor    pi' # w : eta interface range, [J/g K], [J/g K]\n    constant_expressions =  '0.1    0.25    0.35    3.141592653589'\n    function = 'if(eta<0.5-w/2, crys, if(eta<0.5+w/2, amor+0.5*(crys-amor)*(1.0+cos(pi*(eta-(0.5-w/2))/w)), amor))' #  [J/g K]\n    block = 0\n  [../]\n\n  [./specific_heat_TE]\n    type = ParsedMaterial\n    args = 'eta T'\n    constant_names =        'A          B           C           D           E           atomic_unit' # atomic unit [g/mol], t [K/1000]\n    constant_expressions =  '50.40716   0.596509    2.944759    -0.305012   -1.209679   61.8797'\n    f_name = 'specific_heat'\n    function = '1.2 * (1/atomic_unit) * (A+B*(T/1000)+C*(T/1000)^2+D*(T/1000)^3+E/((T/1000)^2))' # [J/mol K] to [J/g K]\n    block = '1 2'\n  [../]\n\n  [./density_Sb]\n    type = ParsedMaterial\n    args = 'eta T'\n    f_name = 'density'\n    constant_names =        'w      crys  pi                cm3_2_nm3' # [g/cm^3] [g/cm^3]\n    constant_expressions =  '0.1    6.684 3.141592653589    1e21'\n    function = '(1/cm3_2_nm3) * if(eta<0.5-w/2, crys, if(eta<0.5+w/2, (6.902-6.486*(10^(-4))*(T-273.15))+0.5*(crys-(6.902-6.486*(10^(-4))*(T-273.15)))*(1.0+cos(pi*(eta-(0.5-w/2))/w)), (6.902-6.486*(10^(-4))*(T-273.15))))' #  [J/g K]\n    block = 0\n  []\n\n  [./density_TiN]\n    type = ParsedMaterial\n    args = 'eta T'\n    f_name = 'density'\n    function = '5.4e-21' # [g/nm^3]\n    block = '1 2'\n  []\n\n  [electrical_conductivity_Sb]\n    type = ParsedMaterial\n    args = 'eta T'\n    f_name = 'electrical_conductivity'\n    constant_names =        'S2       A       cm_2_nm crys              amor    w     pi' # w : eta interface range, \n    constant_expressions =  '66.66    10.325  1e7     (1/9.402e-4)/4 0.85    0.1   3.141592653589' ############ \"final changed\"\n    function = '(1/cm_2_nm) * if(eta <= 0.5-w/2,crys,if(eta<0.5+w/2, (1/(exp(S2*T^(-1/3)-A)))/1.2 + 0.5*(crys+(1/(exp(S2*T^(-1/3)-A)))/1.2)*(1.0+cos(pi * (eta-0.5+w/2)/w)),1/(exp(S2*T^(-1/3)-A))/1.2))'  # [1/(ohm*nm)]\n    block = 0\n  []\n\n  [electrical_conductivity_TiN]\n    type = ParsedMaterial\n    args = eta\n    f_name = 'electrical_conductivity'\n    constant_names =        'cm_2_nm' # w : eta interface range, \n    constant_expressions =  '1e7    '\n    function = '(1/cm_2_nm)/200e-6' # [1/ohm cm] 6896.55\n    block = '1 2'\n  []\n\n  ######## PFM ########\n  [./kappa]\n    type = GenericConstantMaterial\n    prop_names  = 'kappa'\n    prop_values = '${kappa}' # [eV/nm]\n    block = 0\n  [../]\n\n  [./radius]\n    type = ParsedMaterial\n    args = 'DeltaG Interfacial_free_energy'\n    f_name = r\n    function = '2*Interfacial_free_energy/DeltaG'\n    block = 0\n  [../]\n\n  [./free_energy]\n    type = DerivativeParsedMaterial\n    f_name = F\n    args = 'eta DeltaG'\n    function = '${W}/4*(eta^2)*(eta-1)^2+(eta^3)*(10-15*eta+6*(eta^2))*DeltaG'\n    derivative_order = 2 \n#    block = '0 1' # Block 1\n    block = 0 \n  [../]\n\n  [./mobility]\n    type = DerivativeParsedMaterial\n    args = 'V_G DeltaG Interfacial_free_energy'\n    f_name = L\n    function = '${ksi}*V_G*(2*Interfacial_free_energy/DeltaG)/${kappa}'\n    block = 0\n  [../]\n  \n  ######## PFM END ########\n[]\n\n\n[BCs]\n  [t_top]\n    type = DirichletBC\n    variable = T\n    value = 300\n    boundary = 'top'\n  []\n\n  [V_top]\n    type = FunctionDirichletBC\n    variable = V\n    boundary = 'top'\n    function = bc_func_2\n  []\n\n  [V_bottom]\n    type = DirichletBC\n    variable = V\n    value = 0.0 # GND\n    boundary = 'bottom'\n  []\n[]\n\n[Preconditioning]\n    [./SMP]\n        type = SMP\n        full = true\n    [../]\n[]\n\n[Executioner]\n  scheme = 'bdf2'\n  type = Transient\n  solve_type = 'PJFNK'\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre      boomeramg'\n  l_tol = 1e-4\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1.0e-9\n  automatic_scaling = true # for line search convergence\n  l_max_its = 100\n  nl_max_its = 13\n  [./TimeStepper]\n    type = FunctionDT\n    function = dts\n    min_dt = 1e-14\n  [../]\n  petsc_options = -snes_linesearch_monitor\n  end_time = 40e-9\n[]\n\n[Postprocessors]\n\n  [./TE_function]\n    type= FunctionValuePostprocessor\n    function = bc_func_2\n  [../]\n\n\n  [./T_max_time]\n    type = TimeExtremeValue\n    postprocessor = T_max_Sb\n  [../]\n\n  [./Resistance]\n    type = FunctionValuePostprocessor\n    function = resistance_func\n  [../]\n\n  [./Resistance_min_time]\n    type = TimeExtremeValue\n    value_type = min\n    postprocessor = Resistance\n  [../]\n\n  [average_Jy]\n    type = SideAverageValue\n    variable = Jy\n    boundary = BE_top\n  []\n\n  [Current]\n    type = ParsedPostprocessor\n    function = \"if(average_Jy>0,average_Jy*${xmax}, -average_Jy*${xmax})\"\n    pp_names = average_Jy\n  []\n\n  ######## PFM ########\n\n  [./eta_sum]\n    type = NodalSum\n    variable = eta\n    block = 0\n    execute_on = 'INITIAL TIMESTEP_END'\n  [../]\n\n  [./X_c_PFM]\n    type = ParsedPostprocessor\n    function = '1-eta_sum/6218' # should be changed upon mesh change --> refine 3 version\n    pp_names = 'eta_sum'\n  [../]\n  [./time_step]\n    type=TimestepSize\n  [../]\n\n  [./TE_avg]\n    type = SideAverageValue\n    variable = V\n    boundary = TE_bottom\n  [../]\n  [./T_max_Sb]\n    type = NodalExtremeValue\n    variable = T\n    block = 0\n    value_type = max\n  [../]\n  [./JouleJeat_max_Sb]\n    type = ElementExtremeValue\n    variable = JouleHeat_Aux\n    value_type = max\n    block = 0\n  [../]\n\n  ######## PFM END ########\n[]\n[Outputs]\n  file_base = output\n  csv = true\n  exodus = true\n  perf_graph = true\n  [./console]\n    type = Console\n    max_rows = 10\n  [../]\n[]\n\n\nThank you, again.\nJeonghwan",
                          "url": "https://github.com/idaholab/moose/discussions/24478#discussioncomment-6001512",
                          "updatedAt": "2023-05-25T14:10:28Z",
                          "publishedAt": "2023-05-25T14:10:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If there's zeros in the matrix for some dofs, it can still be solvable but you're essentially getting lucky. Some numerical methods are able to remove the nullspace, or if you start close enough to the solution",
                          "url": "https://github.com/idaholab/moose/discussions/24478#discussioncomment-6004834",
                          "updatedAt": "2023-05-25T19:39:55Z",
                          "publishedAt": "2023-05-25T19:39:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Thank you for answering!",
                          "url": "https://github.com/idaholab/moose/discussions/24478#discussioncomment-6031489",
                          "updatedAt": "2023-05-29T18:58:05Z",
                          "publishedAt": "2023-05-29T18:58:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fragmenting a phase field problem leading to divergence",
          "author": {
            "login": "vermaprk"
          },
          "bodyText": "I have a perfectly working phase field input script that can run for 100 sec. However, when I fragment this script to run for 20 sec then resume it again to run for 20 sec. I am getting convergence issue.\nSo, my input1.i runs for ----.20 sec\nBut, my input2.i is having convergence issue at (20+1.1) sec\nBoth the files are identical just with change in input2.i as:\n# input2 file.\n[Mesh]\n  file = input1_out.e\n[]\n[Variables]\n  [w]\n    family = LAGRANGE\n    order = FIRST\n    initial_from_file_var = w\n    initial_from_file_timestep = LATEST\n  []\n  [eta]\n    family = LAGRANGE\n    order = FIRST\n    initial_from_file_var = eta\n    initial_from_file_timestep = LATEST\n  []\n  [phi]\n    family = LAGRANGE\n    order = FIRST\n    initial_from_file_var = phi\n    initial_from_file_timestep = LATEST\n  []\n  [pot]\n    family = LAGRANGE\n    order = FIRST\n    initial_from_file_var = pot\n    initial_from_file_timestep = LATEST\n  []\n[]\n\nWhat can be the source of divergence. My solver is PJFNK preconditioned with\n [Preconditioning]\n   [./SMP]\n     type = SMP\n     full = true\n     petsc_options_iname = '-pc_type -ksp_grmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\n     petsc_options_value = 'asm      121                  preonly       lu           8'\n   [../]\n []\n\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/24520",
          "updatedAt": "2023-09-12T17:50:49Z",
          "publishedAt": "2023-05-29T11:58:13Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nCan you add Problem/solve=false and look at the re-initialization to see if everything looks correct.\nDo you need to initialize aux-variables too?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24520#discussioncomment-6029005",
                  "updatedAt": "2023-05-29T12:29:27Z",
                  "publishedAt": "2023-05-29T12:29:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "I haven't initialized aux variables from last run. Is it required?\nThe following total 22 aux variables:\n  FN\n  FNF\n  G\n  P\n  c\n  dFN/deta\n  dFNF/deta\n  dFNF/dphi\n  dG/deta\n  dG/dpot\n  dG/dw\n  d^2FN/deta^2\n  d^2FNF/deta^2\n  d^2FNF/detadphi\n  d^2FNF/dphi^2\n  d^3FN/deta^3\n  d^3FNF/deta^2dphi\n  d^3FNF/deta^3\n  d^3FNF/detadphi^2\n  d^3FNF/dphi^3\n  etaminus\n  times_mat\nare added for automatic output by MaterialOutputAction.\n\n  Initializing\n    Finished Initializing Equation Systems                                               [  0.35 s] [  152 MB]\n  Finished Initializing                                                                  [  0.37 s] [  153 MB]\nFinished Setting Up                                                                      [  2.73 s] [  208 MB]\nFramework Information:\nMOOSE Version:           git commit c1b08368cd on 2023-01-12\nLibMesh Version:\nPETSc Version:           3.16.6\nSLEPc Version:           3.16.2\nCurrent Time:            Mon May 29 18:28:05 2023\nExecutable Timestamp:    Mon Apr 10 21:21:42 2023\n\nParallelism:\n  Num Processors:          1\n  Num Threads:             1\n\nMesh:\n  Parallel Type:           replicated\n  Mesh Dimension:          2\n  Spatial Dimension:       2\n  Nodes:                   40401\n  Elems:                   40000\n  Num Subdomains:          1\n\nNonlinear System:\n  Num DOFs:                161604\n  Num Local DOFs:          161604\n  Variables:               { \"w\" \"eta\" \"phi\" \"pot\" }\n  Finite Element Types:    \"LAGRANGE\"\n  Approximation Orders:    \"FIRST\"\n\nAuxiliary System:\n  Num DOFs:                880000\n  Num Local DOFs:          880000\n  Variables:               { \"FN\" \"FNF\" \"G\" \"P\" \"c\" ... \"d^3FNF/deta^3\" \"d^3FNF/detadphi^2\" \"d^3FNF/dphi^3\"\n                             \"etaminus\" \"times_mat\" }\n  Finite Element Types:    \"MONOMIAL\"\n  Approximation Orders:    \"CONSTANT\"\n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  Solver Mode:             Preconditioned JFNK\n  PETSc Preconditioner:    asm\n  MOOSE Preconditioner:    SMP\n\n\n    Finished Initializing Random Objects                                                 [  0.29 s] [  203 MB]\n  Finished Performing Initial Setup                                                      [  1.63 s] [  220 MB]\n\nTime Step 0, time = 0\n\nTime Step 1, time = 0.02, dt = 0.02\n Solve Skipped!\n\nTime Step 2, time = 0.04, dt = 0.02\n Solve Skipped!\n\nTime Step 3, time = 0.06, dt = 0.02\n Solve Skipped!\n\nTime Step 4, time = 0.08, dt = 0.02\n Solve Skipped!\n\nTime Step 5, time = 0.1, dt = 0.02\n Solve Skipped!\n\nTime Step 6, time = 0.12, dt = 0.02\n Solve Skipped!\n\nTime Step 7, time = 0.14, dt = 0.02\n Solve Skipped!\n\nTime Step 13, time = 0.26, dt = 0.02\n Solve Skipped!\n\nTime Step 14, time = 0.28, dt = 0.02\n Solve Skipped!\n\nTime Step 15, time = 0.3, dt = 0.02\n Solve Skipped!\n\nTime Step 16, time = 0.32, dt = 0.02\n Solve Skipped!\n\nTime Step 17, time = 0.34, dt = 0.02\n Solve Skipped!\n\nTime Step 18, time = 0.36, dt = 0.02\n Solve Skipped!\n\nTime Step 19, time = 0.38, dt = 0.02\n Solve Skipped!\n\nTime Step 20, time = 0.4, dt = 0.02\n Solve Skipped!\n\nTime Step 21, time = 0.42, dt = 0.02\n Solve Skipped!\n\nTime Step 22, time = 0.44, dt = 0.02\n Solve Skipped!\n\nTime Step 23, time = 0.46, dt = 0.02\n Solve Skipped!\n\nTime Step 24, time = 0.48, dt = 0.02\n Solve Skipped!\n\nTime Step 25, time = 0.5, dt = 0.02\n Solve Skipped!\n\nTime Step 26, time = 0.52, dt = 0.02\n Solve Skipped!\n\nTime Step 27, time = 0.54, dt = 0.02\n Solve Skipped!\n\nTime Step 28, time = 0.56, dt = 0.02\n Solve Skipped!\n\nTime Step 29, time = 0.58, dt = 0.02\n Solve Skipped!\n\nTime Step 30, time = 0.6, dt = 0.02\n Solve Skipped!\n\nTime Step 31, time = 0.62, dt = 0.02\n Solve Skipped!\n\nTime Step 32, time = 0.64, dt = 0.02\n Solve Skipped!\n\nTime Step 33, time = 0.66, dt = 0.02\n Solve Skipped!\n\nTime Step 34, time = 0.68, dt = 0.02\n Solve Skipped!\n\nTime Step 35, time = 0.7, dt = 0.02\n Solve Skipped!\n\nTime Step 36, time = 0.72, dt = 0.02\n Solve Skipped!\n\nTime Step 37, time = 0.74, dt = 0.02\n Solve Skipped!\n\nTime Step 38, time = 0.76, dt = 0.02\n Solve Skipped!\n\nTime Step 39, time = 0.78, dt = 0.02\n Solve Skipped!\n\nTime Step 40, time = 0.8, dt = 0.02\n Solve Skipped!\n\nTime Step 41, time = 0.82, dt = 0.02\n Solve Skipped!\n\nTime Step 42, time = 0.84, dt = 0.02\n Solve Skipped!\n\nTime Step 43, time = 0.86, dt = 0.02\n Solve Skipped!\n\nTime Step 44, time = 0.88, dt = 0.02\n Solve Skipped!\n\nTime Step 45, time = 0.9, dt = 0.02\n Solve Skipped!\n\nTime Step 46, time = 0.92, dt = 0.02\n Solve Skipped!\n\nTime Step 47, time = 0.94, dt = 0.02\n Solve Skipped!\n\nTime Step 48, time = 0.96, dt = 0.02\n Solve Skipped!\n\nTime Step 49, time = 0.98, dt = 0.02\n Solve Skipped!\n\nTime Step 50, time = 1, dt = 0.02\n Solve Skipped!\n\nTime Step 51, time = 1.02, dt = 0.02\n Solve Skipped!\n\nTime Step 52, time = 1.04, dt = 0.02\n Solve Skipped!\n\nTime Step 53, time = 1.06, dt = 0.02\n Solve Skipped!\n\nTime Step 54, time = 1.08, dt = 0.02\n Solve Skipped!\n\nTime Step 55, time = 1.1, dt = 0.02\n Solve Skipped!\n\nTime Step 56, time = 1.12, dt = 0.02\n Solve Skipped!\n\nTime Step 57, time = 1.14, dt = 0.02\n Solve Skipped!\n\nTime Step 58, time = 1.16, dt = 0.02\n Solve Skipped!\n\nTime Step 59, time = 1.18, dt = 0.02\n Solve Skipped!\n\nTime Step 60, time = 1.2, dt = 0.02\n Solve Skipped!\n\nTime Step 61, time = 1.22, dt = 0.02\n Solve Skipped!\n\nTime Step 62, time = 1.24, dt = 0.02\n Solve Skipped!\n\nTime Step 63, time = 1.26, dt = 0.02\n Solve Skipped!\n\nTime Step 64, time = 1.28, dt = 0.02\n Solve Skipped!\n\nTime Step 65, time = 1.3, dt = 0.02\n Solve Skipped!\n\nTime Step 66, time = 1.32, dt = 0.02\n Solve Skipped!\n\nTime Step 67, time = 1.34, dt = 0.02\n Solve Skipped!\n\nTime Step 68, time = 1.36, dt = 0.02\n Solve Skipped!\n\nTime Step 69, time = 1.38, dt = 0.02\n Solve Skipped!\n\nTime Step 70, time = 1.4, dt = 0.02\n Solve Skipped!\n\nTime Step 71, time = 1.42, dt = 0.02\n Solve Skipped!\n\nTime Step 72, time = 1.44, dt = 0.02\n Solve Skipped!\n\nTime Step 73, time = 1.46, dt = 0.02\n Solve Skipped!\n\nTime Step 74, time = 1.48, dt = 0.02\n Solve Skipped!\n\nTime Step 75, time = 1.5, dt = 0.02\n Solve Skipped!\n\nTime Step 76, time = 1.52, dt = 0.02\n Solve Skipped!\n\nTime Step 77, time = 1.54, dt = 0.02\n Solve Skipped!\n\nTime Step 78, time = 1.56, dt = 0.02\n Solve Skipped!\n\nTime Step 79, time = 1.58, dt = 0.02\n Solve Skipped!\n\nTime Step 80, time = 1.6, dt = 0.02\n Solve Skipped!",
                          "url": "https://github.com/idaholab/moose/discussions/24520#discussioncomment-6029236",
                          "updatedAt": "2023-05-29T13:02:29Z",
                          "publishedAt": "2023-05-29T13:02:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "For the solve=false case I wanted you to check the exodus output to see if the initialization succeeded.\nYou only need to initialize auxvariables if they are used in the calculation, and if the auxkernels that are meant to compute them are not executed early enough",
                          "url": "https://github.com/idaholab/moose/discussions/24520#discussioncomment-6030118",
                          "updatedAt": "2023-05-29T15:00:50Z",
                          "publishedAt": "2023-05-29T15:00:49Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about noise term",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nWhat is the maximum amplitude I can set in LangevinNoise kernel?\nThank you,\nBest",
          "url": "https://github.com/idaholab/moose/discussions/24517",
          "updatedAt": "2023-05-28T15:54:24Z",
          "publishedAt": "2023-05-28T15:54:23Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Why can't my simulation converge",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nMy simulation cannot converge. What is the problem with my code?\nCurrently, I have a square model, and the initial condition of this square model is c=0.0001, the free energy function is shown as below:\n\nSo, phase 0 will decompose to -1 phase and 1 phase. However, after I run the simulation, it always cannot converge.\nThis is the error message:\nerror_message.txt\nThis is my file:\nfile.txt\nHow should I change my code?\nThank you,\nBest",
          "url": "https://github.com/idaholab/moose/discussions/24512",
          "updatedAt": "2023-05-27T13:21:44Z",
          "publishedAt": "2023-05-27T02:04:46Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nTime Step 2, time = 0.00749663, dt = 0.00300763\n 0 Nonlinear |R| = \ufffd[32m8.079562e-16\ufffd[39m\n    |residual|_2 of individual variables:\n                          c: 4.60316e-16\n                          w: 6.64005e-16\n\nthis makes me think you are trying to over-converge things.\nPlease turn on automatic_scaling in the Executioner block.\nIf that does not do it, you ll have to fix the convergence criteria (nl_abs_tol)",
                  "url": "https://github.com/idaholab/moose/discussions/24512#discussioncomment-6018849",
                  "updatedAt": "2023-05-27T13:21:45Z",
                  "publishedAt": "2023-05-27T13:21:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Using an existing neural network model.",
          "author": {
            "login": "tttsss-01"
          },
          "bodyText": "I would like to use a neural network model trained on RVE results to replace stress calculations. Are there any existing codes that can assist in implementing this? Or do you have any suggestions in this regard?",
          "url": "https://github.com/idaholab/moose/discussions/24504",
          "updatedAt": "2023-05-27T08:17:44Z",
          "publishedAt": "2023-05-26T16:48:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@grmnptr added an interface to libtorch to MOOSE",
                  "url": "https://github.com/idaholab/moose/discussions/24504#discussioncomment-6013972",
                  "updatedAt": "2023-05-26T16:56:59Z",
                  "publishedAt": "2023-05-26T16:56:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "If you have a pytorch model, compile it into a torch script and call it from within moose.\nIf you have a libtorch model then that's trivial...\nHere's an example to call torch script.\n#pragma once\n\n#include <torch/script.h>\n#include \"ComputeLagrangianStressPK1.h\"\n\nclass TorchStress : public ComputeLagrangianStressPK1\n{\npublic:\n  static InputParameters validParams();\n  TorchStress(const InputParameters & parameters);\n\nprotected:\n  virtual void computeQpPK1Stress() override;\n  torch::jit::script::Module module;\n};\n#include \"TorchStress.h\"\n\nregisterMooseObject(\"fooApp\", TorchStress);\n\nInputParameters\nTorchStress::validParams()\n{\n  InputParameters params = ComputeLagrangianStressPK1::validParams();\n  params.addRequiredParam<std::string>(\"script\", \"file name of the torch script\");\n  return params;\n}\n\nTorchStress::TorchStress(const InputParameters & parameters)\n  : ComputeLagrangianStressPK1(parameters)\n{\n  std::string file_name = getParam<std::string>(\"script\");\n  module = torch::jit::load(file_name);\n}\n\nvoid\nTorchStress::computeQpPK1Stress()\n{\n  double F_vals[9] = {_F[_qp](0, 0),\n                      _F[_qp](0, 1),\n                      _F[_qp](0, 2),\n                      _F[_qp](1, 0),\n                      _F[_qp](1, 1),\n                      _F[_qp](1, 2),\n                      _F[_qp](2, 0),\n                      _F[_qp](2, 1),\n                      _F[_qp](2, 2)};\n  torch::Tensor F = torch::from_blob(F_vals, {3, 3}, {torch::kFloat64});\n  torch::Tensor P_vals = module({F}).toTensor();\n  _pk1_stress[_qp] = RankTwoTensor(P_vals.index({0, 0}).item<double>(),\n                                   P_vals.index({1, 0}).item<double>(),\n                                   P_vals.index({2, 0}).item<double>(),\n                                   P_vals.index({0, 1}).item<double>(),\n                                   P_vals.index({1, 1}).item<double>(),\n                                   P_vals.index({2, 1}).item<double>(),\n                                   P_vals.index({0, 2}).item<double>(),\n                                   P_vals.index({1, 2}).item<double>(),\n                                   P_vals.index({2, 2}).item<double>());\n}",
                  "url": "https://github.com/idaholab/moose/discussions/24504#discussioncomment-6016309",
                  "updatedAt": "2023-05-26T23:42:36Z",
                  "publishedAt": "2023-05-26T23:42:35Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "tttsss-01"
                          },
                          "bodyText": "Thank you very much, this is very helpful to me.",
                          "url": "https://github.com/idaholab/moose/discussions/24504#discussioncomment-6017695",
                          "updatedAt": "2023-05-27T08:17:45Z",
                          "publishedAt": "2023-05-27T08:17:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Q: the Global Strain method in simple Applied strain problem instead of applied stress.",
          "author": {
            "login": "Ttw0626"
          },
          "bodyText": "Dear Moose developers,\n1) Reason:\nI totally understand the applied stress simple PBC test [x y z all of periodic property] using Global Strain.\nThere are many tests and instructive examples in \" /moose/test/tests/ \" and \" /TM/test/tests/ \" and \"/combine/example\", Thanks for that.\n2) Q1:\nHowever, I wanna ask how to apply the strain-control on global excepting the calculated eigenstrain in coupled field example ?? For example, I wanna apply the volumetric e00 = 0.001 along X direction and all of directions maintain periodic.\n3) Q2:\nOr I should use Mortar periodic constraint and Lagrangian new system to do that ?\nkind regards,\nTAN",
          "url": "https://github.com/idaholab/moose/discussions/24495",
          "updatedAt": "2023-05-27T05:33:32Z",
          "publishedAt": "2023-05-26T05:58:32Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can use the new homogenization system that comes with the new Lagrangian kernels (new_system = true in the TM action). Examples are inside modules/tensor_mechanics/test/tests/lagrangian/cartesian/total/homogenization. It's a more flexible system than the original global strain system.\nThe key object is the homogenization userobject:\n[UserObjects]\n  [homogenization]\n    type = HomogenizationConstraint\n    constraint_types = 'STRAIN NONE NONE STRESS STRESS NONE STRAIN STRESS STRESS'\n    targets = '0.1 s s e s s'\n    execute_on = 'INITIAL LINEAR NONLINEAR'\n  []\n[]\nThe parameter constrain_types specifies which type of constraint you want to apply for each component. They are ordered column major IIRC. You need to specify 9 components for large deformation and 6 components for small deformation. STRAIN means you want to constrain the homogenized strain, STRESS means you want to constrain the homogenized stress, and NONE means no constraint should be applied for that component.\nAny non-NONE constraint type should correspond to a target value specified by the targets parameter. Each target is a Function. You can also specify a numeric literal. In the above example, 0.1 means you want to constrain the homogenized strain_xx to be 0.1.\nMaking the homogenization system documentation more complete is on my to-do list.",
                  "url": "https://github.com/idaholab/moose/discussions/24495#discussioncomment-6011532",
                  "updatedAt": "2023-05-26T12:56:15Z",
                  "publishedAt": "2023-05-26T12:56:15Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ttw0626"
                          },
                          "bodyText": "Thanks, gray.\nI got it, I will try.\nTAN",
                          "url": "https://github.com/idaholab/moose/discussions/24495#discussioncomment-6017160",
                          "updatedAt": "2023-05-27T05:33:32Z",
                          "publishedAt": "2023-05-27T05:33:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to access/compute second order derivates",
          "author": {
            "login": "ABallisat"
          },
          "bodyText": "Hello all,\nI am trying to implement a surface tension term within the level set module which requires computing the curvature of the interface. Explicitly, I need to calculate (ignoring constants):\nF = (grad dot grad phi)/|grad phi| * grad phi\nfor the level set variable phi. I believe I cannot get around the grad dot grad phi term when putting it in the weak form, and I cannot work out how to access it or compute it in the kernel. Is there an easy way in MOOSE to access the second order derivates?\nThanks in advance for the help,\nAlex",
          "url": "https://github.com/idaholab/moose/discussions/17183",
          "updatedAt": "2023-05-26T22:26:25Z",
          "publishedAt": "2021-03-02T12:43:32Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "If I were you I would first try really hard to see if I can \"shift\" the derivative onto the test function in the weak form. But in case you really can't:\nSee https://github.com/idaholab/moose/blob/next/modules/phase_field/include/kernels/CHInterfaceBase.h for example how to get second spatial derivatives of variable, test and trial functions.\nBut you need higher continuity, e.g. a third order hermite polynomial as your basis.\nAlternatively, you can try splitting up your weak form by introducing a new variable (just like the split form cahn hilliard equation).",
                  "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-427906",
                  "updatedAt": "2022-08-04T08:44:32Z",
                  "publishedAt": "2021-03-04T02:24:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "Thanks for the advice. I will focus for now on trying to shift the derivative onto the test function and if I can't get around it I will go into those suggestions.",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-430091",
                          "updatedAt": "2022-08-04T08:44:36Z",
                          "publishedAt": "2021-03-04T17:11:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Take a look at Elin Olsson et.al, JCP 225 (2007) 785\u2013807 paper where he has a formulation for regularized curvature. I suggest introduce a kernel to compute the curvature variable based on that formulation.\nI have implemented it in our internal MOOSE-based codes, and it works well.",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-431287",
                          "updatedAt": "2022-08-04T08:44:36Z",
                          "publishedAt": "2021-03-05T00:18:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "Thanks for that, I will take a good look and give that approach a go. Just out of interest is there any plan to incorporate that kernel into the general MOOSE distribution?",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-433886",
                          "updatedAt": "2022-08-04T08:44:36Z",
                          "publishedAt": "2021-03-05T17:02:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Yes, those codes will be eventually merged into MOOSE, maybe as a new physical module. However, the timeline is not very clear at this moment.",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-433900",
                          "updatedAt": "2022-08-11T07:53:39Z",
                          "publishedAt": "2021-03-05T17:08:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "I'm having trouble getting this to give sensible answers. For clarity, I am implementing equation 22 of that paper, using three kernels, one for each of the three integral terms and moving them all onto the same side so flipping some of the signs to get the correct residual calculations. Apply Neumann BCs to the curvature variable and level set variable (I am using the smeared heaviside function as per the first paper in that series). At the moment this is giving the following, where kappa is the curvature and k_Magnitude is the magnitude of the of gradient of the level set function (which is simply a stationary circle centred on 0.1 with radius 0.025). I know the gradient is correct but as the curvature should be the gradient of gradient, this does not seem to be correct. Am I missing something obvious or did you have to do anything in particular to get it working? I can't see what I am doing wrong...\nThanks for the help!",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-489939",
                          "updatedAt": "2022-08-11T07:53:39Z",
                          "publishedAt": "2021-03-16T17:32:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Curvature = div (normal) = div (grad_phi / ||grad_phi||)\nfor signed distance function ||grad_phi||=1\nso Curvature = div grad_phi = Lap phi.",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-494207",
                          "updatedAt": "2022-08-11T07:53:41Z",
                          "publishedAt": "2021-03-17T15:15:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "Ah that solved it, I think my understanding of the reinitialisation and the conversion to the smeared heaviside function was incorrect. Thanks again for all the help, it is greatly appreciated!",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-494656",
                          "updatedAt": "2022-08-11T07:53:41Z",
                          "publishedAt": "2021-03-17T17:00:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "alimostafavi24"
                          },
                          "bodyText": "Curvature = div (normal) = div (grad_phi / ||grad_phi||)\nfor signed distance function ||grad_phi||=1\nso Curvature = div grad_phi = Lap phi.\n\nHello,\nHere as you suggested I used a custom kernel to compute the curvature. Bu this really messed up with the speed and convergence of my model. Is there any Auxkernel that can be used here and get the curvature as an Auxvariable? and curvature is simply the laplacian of phi?\nThanks,",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-5983553",
                          "updatedAt": "2023-05-24T00:16:51Z",
                          "publishedAt": "2023-05-24T00:16:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "curvature as an Auxvariable\nyou cannot use this (without extra work) for computing the residuals though. Auxvariables do NOT carry derivative information for the Jacobian\nBut if you really want to just look at it, in the output, then you ll have to make a new auxkernel, we dont have that one.\nI can make it too if you have a week or two to wait",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-5984329",
                          "updatedAt": "2023-05-24T02:42:13Z",
                          "publishedAt": "2023-05-24T02:42:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "You may get curvatures from FE computation directly in libMesh: get_curvatures. As alluded to by @jiangwen84 it does require pre-requesting get_d2phi",
                          "url": "https://github.com/idaholab/moose/discussions/17183#discussioncomment-5984966",
                          "updatedAt": "2023-05-24T04:54:18Z",
                          "publishedAt": "2023-05-24T04:54:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about free energy function setting in one model",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi everyone,\nI have a question about setting location dependent free energy function in my model.\nI have a square model and I divided it to a 33 grid. I want to assign different free energy function on each small square in the 33 grid. How to realize this?\n\nThe free energy function's expression is shown as below, so for different free energy function, I need to change the 4 coefficients. How to realize this?\n\nThis is how I set free energy function in my file currently,\n\nThank you,\nBest",
          "url": "https://github.com/idaholab/moose/discussions/24492",
          "updatedAt": "2023-05-26T17:29:07Z",
          "publishedAt": "2023-05-26T03:12:34Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI think you'll wan to use a ParsedSubdomainGenerator to create the 3x3 grid of subdomains.\nThen you can block restrict material properties. You ll create 9 DerivativeParsedMaterial, one for each subdomain\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6011716",
                  "updatedAt": "2023-05-26T13:14:42Z",
                  "publishedAt": "2023-05-26T13:14:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "Since I don't want to change the other things, for example initial condition and boundary condition, I should just keep them as the same, right? I only need to create more free energy function and apply them to each block I want?",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013130",
                          "updatedAt": "2023-05-26T15:22:21Z",
                          "publishedAt": "2023-05-26T15:22:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Creating more subdomains will not affect BCs or ICs.\nYou can block-restrict ICs though if you wanted.",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013198",
                          "updatedAt": "2023-05-26T15:28:52Z",
                          "publishedAt": "2023-05-26T15:28:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "What is block-restrict?",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013335",
                          "updatedAt": "2023-05-26T15:43:43Z",
                          "publishedAt": "2023-05-26T15:43:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "setting block= on an object restricts it to some subdomains/block\nhttps://mooseframework.inl.gov/source/interfaces/BlockRestrictable.html",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013375",
                          "updatedAt": "2023-05-26T15:47:14Z",
                          "publishedAt": "2023-05-26T15:47:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "I want to subdivide my domain, however, I always got this error message, why is this?\ndf0d8_t_0d4_free_energy_blcok.8388765.txt\nThe following is my file:\nfile.txt\nWhat is the problem with my subdomain setting?",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013958",
                          "updatedAt": "2023-05-26T16:55:12Z",
                          "publishedAt": "2023-05-26T16:55:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You need order mesh generators like a tree with a single final point\n  [./domainx]\n    type = GeneratedMeshGenerator\n    dim = 2\n    elem_type = QUAD4\n    nx = 240\n    ny = 48\n    nz = 0\n    xmin = 0\n    xmax = 4.0\n    ymin = 0\n    ymax = 0.8\n    #zmin = 0\n    #zmax = 0\n    uniform_refine = 2\n    #nemesis = true\n    #skip_partitioning = true\n  []\n\n  [./subdomains1]\n    type = ParsedSubdomainMeshGenerator\n    input = domainx\n    combinatorial_geometry = 'x < 1 & y > 0.4'\n    block_id = 1\n  []\n  [./subdomains2]\n    type = ParsedSubdomainMeshGenerator\n    input = subdomains1\n    combinatorial_geometry = 'x < 1 & y < 0.4'\n    block_id = 2\n  []\n  [./subdomains3]\n    type = ParsedSubdomainMeshGenerator\n    input = subdomains2\n    combinatorial_geometry = 'x > 1'\n    block_id = 3\n  []\n\nsee how there's only one exit point, subdomains3",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6013986",
                          "updatedAt": "2023-05-26T16:58:37Z",
                          "publishedAt": "2023-05-26T16:58:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abc-hy"
                          },
                          "bodyText": "What is only one exit point?\nI changed the subdomain3 and the following is the changed file.\nfile.txt\nAnd I run it, but I still get that error.\nerror_message.txt\nWhy is this?",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6014117",
                          "updatedAt": "2023-05-26T17:16:35Z",
                          "publishedAt": "2023-05-26T17:16:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you draw a graph of the mesh generators, looking at the inputs, there must be only one final one",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6014213",
                          "updatedAt": "2023-05-26T17:28:11Z",
                          "publishedAt": "2023-05-26T17:28:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you can look at this page, at the gneeration / DAG part\nhttps://mooseframework.inl.gov/syntax/Mesh/",
                          "url": "https://github.com/idaholab/moose/discussions/24492#discussioncomment-6014226",
                          "updatedAt": "2023-05-26T17:29:07Z",
                          "publishedAt": "2023-05-26T17:29:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "derived class from ComputeElasticityTensorCP",
          "author": {
            "login": "selarem"
          },
          "bodyText": "Hello, I would like to input the square root of the elasticity tensor to avoid its computation for every increment at every material point.\nSo, i derived a class meComputeElasticityTensorCP from ComputeElasticityTensorCP and wrote.\n#include \"meComputeElasticityTensorCP.h\"\n\nregisterMooseObject(\"TensorMechanicsApp\", meComputeElasticityTensorCP);\n\nInputParameters\nmeComputeElasticityTensorCP::validParams()\n{\n  InputParameters params = ComputeElasticityTensorCP::validParams();\n  params.addClassDescription(\"Compute an elasticity tensor for crystal plasticity.\");\n  params.addRequiredParam<std::vector<Real>>(\"sqrtC_ijkl\", \"sqrt Stiffness tensor for material\");\n  return params;\n}\nmeComputeElasticityTensorCP::meComputeElasticityTensorCP(const InputParameters & parameters)\n  : ComputeElasticityTensorCP(parameters),\n         _sqrt_elasticity_tensor_name(_base_name + \"sqrt_elasticity_tensor\"),\n    _sqrt_elasticity_tensor(declareGenericProperty<T, is_ad>(_sqrt_elasticity_tensor_name)),\n        _sqrtCijkl(this->getParam<std::vector<Real>>(\"sqrtC_ijkl\"),\n           (RankFourTensor::FillMethod)(int)this->getParam<MooseEnum>(\"fill_method\"))\n{\n  // the base class guarantees constant in time, but in this derived class the\n  // tensor will rotate over time once plastic deformation sets in\n  // the base class performs a passive rotation, but the crystal plasticity\n  // materials use active rotation: recover unrotated _Cijkl here\n  _sqrtCijkl.rotate(_R.transpose());\n}\n\nvoid\nmeComputeElasticityTensorCP::computeQpElasticityTensor()\n{\n  // Properties assigned at the beginning of every call to material calculation\n  //  \n  // this->ComputeElasticityTensorCP::computeQpElasticityTensor();\nComputeElasticityTensorCP::computeQpElasticityTensor();\n  _sqrt_elasticity_tensor[_qp] = _sqrtCijkl;\n  _sqrt_elasticity_tensor[_qp].rotate(_crysrot[_qp]);\n}\n   \nbut when I compiled, I got:\n\nCompiling C++ (in opt mode) /opt/projects/sea/build/unity_src/materials_Unity.C...\nIn file included from /opt/projects/moose/framework/build/header_symlinks/MooseObject.h:15,\n                 from /opt/projects/moose/framework/build/header_symlinks/MaterialBase.h:13,\n                 from /opt/projects/moose/framework/build/header_symlinks/Material.h:13,\n                 from /opt/projects/moose/modules/tensor_mechanics/build/header_symlinks/ComputeStressBase.h:12,\n                 from /opt/projects/moose/modules/tensor_mechanics/build/header_symlinks/ComputePFFractureStressBase.h:12,\n                 from /opt/projects/moose/modules/tensor_mechanics/build/header_symlinks/ConcreteLinearElasticPFFractureStress.h:12,\n                 from /opt/projects/sea/src/materials/ConcreteLinearElasticPFFractureStress.C:10,\n                 from /opt/projects/sea/build/unity_src/materials_Unity.C:2:\n/opt/projects/moose/framework/build/header_symlinks/Registry.h:42:91: error: no matching function for call to 'Registry::add<meComputeElasticityTensorCP>(<brace-enclosed initializer list>)'\n   42 |           {app, #classname, \"\", \"\", nullptr, nullptr, nullptr, __FILE__, __LINE__, \"\", \"\"})\n      |                                                                                           ^\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:12:1: note: in expansion of macro 'registerMooseObject'\n   12 | registerMooseObject(\"TensorMechanicsApp\", meComputeElasticityTensorCP);\n      | ^~~~~~~~~~~~~~~~~~~\n/opt/projects/moose/framework/build/header_symlinks/Registry.h:162:15: note: candidate: 'template<class T> static char Registry::add(const RegistryEntry&)'\n  162 |   static char add(const RegistryEntry & info)\n      |               ^~~\n/opt/projects/moose/framework/build/header_symlinks/Registry.h:162:15: note:   template argument deduction/substitution failed:\nIn file included from /opt/projects/sea/build/unity_src/materials_Unity.C:3:\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:15:1: error: 'template<bool is_ad, class T> class meComputeElasticityTensorCP' used without template arguments\n   15 | meComputeElasticityTensorCP::validParams()\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:23:28: error: deduced class type 'meComputeElasticityTensorCP' in function return type\n   23 | meComputeElasticityTensorCP::meComputeElasticityTensorCP(const InputParameters & parameters)\n      |                            ^~\nIn file included from /opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:10,\n                 from /opt/projects/sea/build/unity_src/materials_Unity.C:3:\n/opt/projects/sea/build/header_symlinks/meComputeElasticityTensorCP.h:22:7: note: 'template<bool is_ad, class T> class meComputeElasticityTensorCP' declared here\n   22 | class meComputeElasticityTensorCP : public ComputeElasticityTensorCP\n      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nIn file included from /opt/projects/sea/build/unity_src/materials_Unity.C:3:\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:38:1: error: 'template<bool is_ad, class T> class meComputeElasticityTensorCP' used without template arguments\n   38 | meComputeElasticityTensorCP::computeQpElasticityTensor()\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C: In function 'void computeQpElasticityTensor()':\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:42:56: error: cannot call member function 'virtual void ComputeElasticityTensorCP::computeQpElasticityTensor()' without object\n   42 |   ComputeElasticityTensorCP::computeQpElasticityTensor();\n      |                                                        ^\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:43:3: error: '_sqrt_elasticity_tensor' was not declared in this scope\n   43 |   _sqrt_elasticity_tensor[_qp] = _sqrtCijkl;\n      |   ^~~~~~~~~~~~~~~~~~~~~~~\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:43:27: error: '_qp' was not declared in this scope\n   43 |   _sqrt_elasticity_tensor[_qp] = _sqrtCijkl;\n      |                           ^~~\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:43:34: error: '_sqrtCijkl' was not declared in this scope\n   43 |   _sqrt_elasticity_tensor[_qp] = _sqrtCijkl;\n      |                                  ^~~~~~~~~~\n/opt/projects/sea/src/materials/meComputeElasticityTensorCP.C:44:39: error: '_crysrot' was not declared in this scope\n   44 |   _sqrt_elasticity_tensor[_qp].rotate(_crysrot[_qp]);\n\nthanks for any help.\nregards,\nSab",
          "url": "https://github.com/idaholab/moose/discussions/24440",
          "updatedAt": "2023-05-30T07:58:13Z",
          "publishedAt": "2023-05-22T10:14:08Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you paste the header here as well?\nSomething is wrong with the class which makes the registering macro fail. I m not sure what yet though\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5967467",
                  "updatedAt": "2023-05-22T13:07:59Z",
                  "publishedAt": "2023-05-22T13:07:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "here is the header:\n#include \"ComputeElasticityTensor.h\"\n#include \"PropertyReadFile.h\"\n#include \"RankTwoTensor.h\"\n#include \"RotationTensor.h\"\n#include \"ComputeElasticityTensorCP.h\"\n\n/**\n * meComputeElasticityTensorCP defines an elasticity tensor material object for crystal plasticity.\n */\ntemplate <bool is_ad, typename T = RankFourTensor>\nclass meComputeElasticityTensorCP : public ComputeElasticityTensorCP\n{\npublic:\n  static InputParameters validParams();\n\n  meComputeElasticityTensorCP(const InputParameters & parameters);\n\nprotected:\n  virtual void computeQpElasticityTensor() override;\n RankFourTensor _sqrtCijkl;\n std::string _sqrt_elasticity_tensor_name;\n\n  GenericMaterialProperty<T, is_ad> & _sqrt_elasticity_tensor ;\n\n}\n\nregards,",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5986971",
                          "updatedAt": "2023-05-24T12:22:04Z",
                          "publishedAt": "2023-05-24T08:57:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nHere's your problem\nIn the header you are defining a template for a class (templated on is_ad and T, T having a default)\nand in the source you are not using the template argument.\nYou need to add the templating in the source, if you want an AD and non-AD version of the object\nOR\nremove the templating from the header\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5989281",
                          "updatedAt": "2023-05-24T12:23:42Z",
                          "publishedAt": "2023-05-24T12:23:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "Both of them do not work because I could not make the right modifications.\nIn case I want to remove the template, I would (in the header) declare the _sqrt_elasticity_tensor as a RankfourTensor as:\nRankFourTensor  & _sqrt_elasticity_tensor ;\nor something more complex ?\nand what about the constructor  line :\n_sqrt_elasticity_tensor(declareGenericProperty<T, is_ad>(_sqrt_elasticity_tensor_name)),\nI think I have to change it also, but do not know what to put instead.\nAny example or C++ doc  would be very helpful to me.\nregards,",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5990083",
                          "updatedAt": "2023-05-24T13:40:34Z",
                          "publishedAt": "2023-05-24T13:40:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Everywhere you have T you can write : RankFourTensor\nFor example, this is a valid type;\nGenericMaterialProperty<RankFourTensor, true> & _sqrt_elasticity_tensor ;",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5990165",
                          "updatedAt": "2023-05-24T13:48:06Z",
                          "publishedAt": "2023-05-24T13:48:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "i have put:\n MaterialProperty<RankFourTensor>  & _sqrt_elasticity_tensor ;\nand\n_sqrt_elasticity_tensor(declareProperty<RankFourTensor>(_sqrt_elasticity_tensor_name)),\n\nin the constructor.\nIt compiles. I will test it to see on a simple input file.\nregards,",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5990181",
                          "updatedAt": "2023-05-24T13:49:55Z",
                          "publishedAt": "2023-05-24T13:49:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "selarem"
                  },
                  "bodyText": "Hello,\nIt compiles without any problem.\nThe issue I do have now is that I have differences between:\n_elasticity_tensor and (_sqrt_elasticity_tensor * _sqrt_elasticity_tensor). Our input is :\n[./elasticity_tensor]\n    type = meComputeElasticityTensorCP\n    C_ijkl = '280000. 120000. 120000.      0.      0.      0. 280000. 120000.      0.\n      0.      0. 280000.      0.      0.      0.  80000.      0.      0.\n  80000.      0.  80000.'\n    fill_method = symmetric21\n    sqrtC_ijkl = '507.0367517  107.0367517  107.0367517    0.           0.\n   0.         507.0367517  107.0367517    0.           0.\n   0.         507.0367517    0.           0.           0.\n 282.84271247   0.           0.         282.84271247   0.\n 282.84271247 '    \n  [../]\n\nWith the tensors written in the form of 6X6 Matrices we have  : _elasticity_tensor = _sqrt_elasticity_tensor * _sqrt_elasticity_tensor\nBut not when using the operator * between two RankFourTensor in Moose.\nWe could not find the reason.\nThanks for any help.",
                  "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-5999021",
                  "updatedAt": "2023-05-26T14:18:03Z",
                  "publishedAt": "2023-05-25T09:38:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "6x6 ?\nWhile there's a lot of identical coefficients I think they are 3x3x3x3 ?",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-6000454",
                          "updatedAt": "2023-05-25T12:29:33Z",
                          "publishedAt": "2023-05-25T12:29:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "regardless, I see this rotation step for tensors\n  _sqrtCijkl.rotate(_R.transpose());\nshould that be applied to the square root?",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-6000476",
                          "updatedAt": "2023-05-25T12:31:22Z",
                          "publishedAt": "2023-05-25T12:31:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "selarem"
                          },
                          "bodyText": "Of course, the square root should be rotated as the elasticity tensor.\nWe compute the sqrt outside Moose and give it as input (sqrtC_ijkl in the .i file).\nIn our calculus of  sqrtC_ijkl coefficients, we have represented the elasticity tensor as a 6X6 Matrix in Python.\nWhen these coefs entered in Moose, we wanted to check if\n(sqrt of C)^2 == C  (which is what we seek !)\nand found that the equality (between matrices) does not hold once in tensors representation of C and sqrtC.\nthat's our issue now.\nregards",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-6008914",
                          "updatedAt": "2023-05-26T07:56:07Z",
                          "publishedAt": "2023-05-26T07:56:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@jiangwen84 will know more about tensor math and if there's a trick here",
                          "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-6011725",
                          "updatedAt": "2023-05-26T13:16:05Z",
                          "publishedAt": "2023-05-26T13:16:05Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "selarem"
                  },
                  "bodyText": "Solved. To compute the sqrt of C, the algorithm used for 6X6 matrices has\nto be modified to work with rank four tensor representation.\n\nRegards,\nSaber\n\nLe ven. 26 mai 2023, 15:16, Guillaume Giudicelli ***@***.***>\na \u00e9crit :\n\u2026\n @jiangwen84 <https://github.com/jiangwen84> will know more about tensor\n math and if there's a trick here\n\n \u2014\n Reply to this email directly, view it on GitHub\n <#24440 (reply in thread)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AFBUGDFFXNDC367BE3AST43XICUKBANCNFSM6AAAAAAYKG2U6Q>\n .\n You are receiving this because you authored the thread.Message ID:\n ***@***.***>",
                  "url": "https://github.com/idaholab/moose/discussions/24440#discussioncomment-6013527",
                  "updatedAt": "2023-05-26T16:03:06Z",
                  "publishedAt": "2023-05-26T16:03:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}