{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wOS0xNlQwMzoxOTozOC0wNTowMM4AQuev"
    },
    "edges": [
      {
        "node": {
          "title": "Can EBSDMeshGenerator be calculated using distributed mesh?",
          "author": {
            "login": "PengWei97"
          },
          "bodyText": "Hello,\nRecently, I want to use EBSD data for the large-scale phase field simulation. However, I found that setting parallel_type = distributed in EBSDMeshGenerator  of IN100-111grn.i, and it shows the following error,\n...\n*** ERROR ***\n/home/pw-moose/projects/luwu/grainGrowth/gNGs2022/ebsd_00/IN100-111grn.i:6: unused parameter 'Mesh/ebsd_mesh/parallel_type'\nThen, the details of the output to th terminal are in 01.log\nTherefore, my question is whether it is possible to use distributed mesh in EBSDMeshGenerator  to effectively reduce memory usage, or whether only replicated mesh can be used in EBSDMeshGenerator.\nAny suggestions or recommendations to fix these problems would be greatly appreciated.\nThanks\nwei peng",
          "url": "https://github.com/idaholab/moose/discussions/22135",
          "updatedAt": "2022-09-20T01:01:57Z",
          "publishedAt": "2022-09-19T11:39:34Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Parallel_type is a [Mesh] block parameter, not a [Mesh/some_generator] parameter\nLooking at the code and the tests, distributed meshes are supported for this mesh generator.\nYou can either pass this parameter at the right location or add --distributed-mesh to the command line",
                  "url": "https://github.com/idaholab/moose/discussions/22135#discussioncomment-3683464",
                  "updatedAt": "2022-09-19T17:50:33Z",
                  "publishedAt": "2022-09-19T17:50:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "PengWei97"
                          },
                          "bodyText": "Great, thank you for your reply. I solved the problem yesterday by modifying the code of EBSDMeshGenerator to set up the distributed mesh.\nwei",
                          "url": "https://github.com/idaholab/moose/discussions/22135#discussioncomment-3685608",
                          "updatedAt": "2022-09-20T00:55:02Z",
                          "publishedAt": "2022-09-20T00:55:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "nice!!",
                          "url": "https://github.com/idaholab/moose/discussions/22135#discussioncomment-3685634",
                          "updatedAt": "2022-09-20T01:01:57Z",
                          "publishedAt": "2022-09-20T01:01:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Moose example for crystal plasticity modeling under high/low cycle fatigue loading",
          "author": {
            "login": "xchengood"
          },
          "bodyText": "Dear Moose experts or users,\nAre there any developed Moose examples for crystal plasticity modeling under high/low cycle fatigue loading? My purpose is to predict the creep-fatigue life of polycrystal materials and study damage evolution. Any ideas or suggestions about that? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/22113",
          "updatedAt": "2022-09-29T17:13:20Z",
          "publishedAt": "2022-09-15T23:06:37Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "Hi @xchengood ,\nWe do not have any examples of crystal plasticity models being used in fatigue loading within the MOOSE repository currently. I do believe, however, that some research groups may their own branches with these types of models. Perhaps @ngrilli is one of these people?",
                  "url": "https://github.com/idaholab/moose/discussions/22113#discussioncomment-3657994",
                  "updatedAt": "2022-09-15T23:17:07Z",
                  "publishedAt": "2022-09-15T23:17:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "xchengood"
                          },
                          "bodyText": "Hi @sapitts. Thank you for your reply. How do I create a low or high cycle loading in Moose? If I want to build a user object, do you have any advice (e.g. base class)?\n@ngrilli, It would be helpful if you could share any built code examples about the creep-fatigue model. Thank you.",
                          "url": "https://github.com/idaholab/moose/discussions/22113#discussioncomment-3684081",
                          "updatedAt": "2022-09-19T19:32:15Z",
                          "publishedAt": "2022-09-19T19:32:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "@xchengood an example of backstress implementation is here:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/FiniteStrainCrystalPlasticityBackstress.C\nwhich you will need for cyclic fatigue I guess.\nAn example of creep implementation is here:\nhttps://github.com/ngrilli/c_pfor_am/blob/main/src/materials/CrystalPlasticityDislocationUpdate.C\nIf you tell us which specific model and material you want to implement, we can help better,\nif you are unsure where to start, a Chaboche model may be a good starting point.\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/22113#discussioncomment-3685599",
                  "updatedAt": "2022-09-20T00:53:34Z",
                  "publishedAt": "2022-09-20T00:53:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "location of temporary runtime files",
          "author": {
            "login": "WilkAndy"
          },
          "bodyText": "Hi everyone,\nWhen running MOOSE, it creates temporary files along the lines of \"tmp_jit_HOyNo6.so\".  Is it possible to specify the location of those files?\na",
          "url": "https://github.com/idaholab/moose/discussions/22101",
          "updatedAt": "2022-09-19T20:17:13Z",
          "publishedAt": "2022-09-15T02:37:13Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI dont know that you can. @dschwen will know for sure\nThere's some paramters to get rid of them, disable_fpoptimizer I think\nthey are under Advanced\nhttps://mooseframework.inl.gov/source/materials/DerivativeParsedMaterial.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22101#discussioncomment-3650176",
                  "updatedAt": "2022-09-15T04:17:29Z",
                  "publishedAt": "2022-09-15T04:17:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Thank you @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/22101#discussioncomment-3676420",
                          "updatedAt": "2022-09-18T22:57:51Z",
                          "publishedAt": "2022-09-18T22:57:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "milljm"
                          },
                          "bodyText": "May I ask why you need this? If you have the ability to control where these files are created, it may help others.\nOthers that have in the past, wished to maintain a centralized location of MOOSE source where multiple people 'build' from, yet don't have write access.",
                          "url": "https://github.com/idaholab/moose/discussions/22101#discussioncomment-3680234",
                          "updatedAt": "2022-09-19T12:28:05Z",
                          "publishedAt": "2022-09-19T12:28:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "My HPC staff asked whether this was possible, because they think that writing lots of these temporary files causes the filesystem to slowdown for everyone (I'm running many MOOSE jobs).  If i could write to another filesystem then it would help address that slowdown.\na",
                          "url": "https://github.com/idaholab/moose/discussions/22101#discussioncomment-3684387",
                          "updatedAt": "2022-09-19T20:17:14Z",
                          "publishedAt": "2022-09-19T20:17:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can MOOSE make several discrete values into a new variable?",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "I use the NodalValueSampler and get the values of the specific variable at each node in a specific 1D-block(in the form of array). Now I want to make these values into a new variable and at the same time the nodal values of the new variable are the elements of the array I get. How can achieve it?",
          "url": "https://github.com/idaholab/moose/discussions/22128",
          "updatedAt": "2022-09-29T17:13:12Z",
          "publishedAt": "2022-09-17T01:57:46Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "not sure how to do it cleanly.\nseems parsedAux wont let you use a postprocessor\nyou could put it in a VectorPostprocessor and then use this\nhttps://mooseframework.inl.gov/docs/site/source/auxkernels/VectorPostprocessorVisualizationAux.html\nbut there's got to be another way",
                  "url": "https://github.com/idaholab/moose/discussions/22128#discussioncomment-3666720",
                  "updatedAt": "2022-09-17T03:02:10Z",
                  "publishedAt": "2022-09-17T03:02:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Thanks a lot for your apply! I will have a try.And If I find some other way to achieve it I will tell you.",
                          "url": "https://github.com/idaholab/moose/discussions/22128#discussioncomment-3667166",
                          "updatedAt": "2022-09-17T07:04:16Z",
                          "publishedAt": "2022-09-17T07:04:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "@GiudGiud Hello! I notice that the VectorPostprocessorVisualizationAux reads values from a VectorPostprocessor that is producing vectors that are 'number of processors' * in length. So VectorPostprocessorVisualizationAux is used to put the value for each processor into auxiliary field. But to be honest, I'm not so familiar with the info about the processor in MOOSE. There is only one processor in my input file and what I want is to put the vector which I get from the VectorPostprocessor(NodalValueSampler) into auxiliary field.\nShould I change the source code of the VectorPostprocessorVisualizationAux to achieve my goal?",
                          "url": "https://github.com/idaholab/moose/discussions/22128#discussioncomment-3668367",
                          "updatedAt": "2022-09-17T13:08:09Z",
                          "publishedAt": "2022-09-17T13:08:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "@GiudGiud I've used the VectorPostprocessorVisualizationAux and I wrote an input file. But it shows an error:\n*** **ERROR** ***\n**The following error occurred in the object \"AuxVELADJ\", of type \"VectorPostprocessorVisualizationAux\".\nError in AuxKernel AuxVELADJ. Vector u in VectorPostprocessor VELADJ_VEC does not contain num_procs number of entries.  num_procs: 1 num_entries: 0**\nHere is my input file:\n[GlobalParams]\n  gravity = -9.8\n  transient_term = false\n[]\n\n[Mesh]\n file = 'twopipe.e'\n[]\n\n[Variables]\n  [./p]\n    order = SECOND\n    family = LAGRANGE\n    block = '1 2'\n  [../]\n  [./u]\n    order = SECOND\n    family = LAGRANGE\n    block = '1 2'\n    [./InitialCondition]\n      type = ConstantIC\n      value = 0.5\n    [../]\n  [../]\n  [./T]\n    order = SECOND\n    family = LAGRANGE\n    block = '1 2'\n    [./InitialCondition]\n      type = ConstantIC\n      value = 628\n    [../]\n  [../]\n  [./w]\n    order = SECOND\n    family = LAGRANGE\n    block = '1'\n  [../]\n[]\n\n[AuxVariables]\n  [./VELADJ]\n    family = MONOMIAL\n    order = CONSTANT\n  [../]\n  [./PRESSADJ]\n    family = MONOMIAL\n    order = CONSTANT\n  [../]\n  [./RHOADJ]\n    family = MONOMIAL\n    order = CONSTANT\n  [../]\n[]\n[AuxKernels]\n [./AuxVELADJ]\n   type = VectorPostprocessorVisualizationAux\n   vpp = VELADJ_VEC\n   vector_name = u\n   variable = VELADJ\n   execute_on = 'LINEAR NONLINEAR'\n [../]\n [./AuxPRESSADJ]\n   type = VectorPostprocessorVisualizationAux\n   vpp = PRESSADJ_VEC\n   vector_name = p\n   variable = PRESSADJ\n   execute_on = 'LINEAR NONLINEAR'\n [../]\n [./AuxRHOADJ]\n   type = VectorPostprocessorVisualizationAux\n   vpp = RHOADJ_VEC\n   vector_name = 'rho'\n   variable = RHOADJ\n   execute_on = 'LINEAR NONLINEAR'\n [../]\n[]\n\n[Kernels]\n  [./MASS_EQUATION]\n    type = mass\n    variable = p\n    vel = u\n    temp = T\n    press = p\n    block = '1 2'\n  [../]\n  [./Momentum_EQUATION]\n    type = momentum\n    variable = u\n    press = p\n    temp = T\n    vel = u\n    block = '1 2'\n   [../]\n  [./Energy_EQUATION]\n    type = energy\n    variable = T\n    vel = u\n    press = p\n    temp = T\n    value = 1.0\n    block = '1 2'\n    function = test\n  [../]\n  [./LateralMomentum_EQUATION]\n    type = lateralmomentum\n    variable = w\n    lvel = w\n    vel = u\n    temp = T\n    press = p\n    veladj = VELADJ\n    pressadj = PRESSADJ\n    rhoadj = RHOADJ\n    block = '1'\n    lk = 1\n    sk = 0.5\n    kg = 0.5\n  [../]\n[]\n\n[Functions]\n  [./test]\n    type = ParsedFunction\n    value = 1.0e8*sin(pi*x)\n  [../]\n[../]\n\n[BCs]\n  [./outlet_p]\n    type =  DirichletBC\n    boundary = '16 26'\n    variable = p\n    value = 2.0e5\n  [../]\n  [./inlet_u1]\n    type =  DirichletBC\n    boundary = '11'\n    variable = u\n    value = 1\n  [../]\n  [./inlet_u2]\n    type =  DirichletBC\n    boundary = '26'\n    variable = u\n    value = 1.5\n  [../]\n  [./inlet_T1]\n    type = DirichletBC\n    variable = T\n    boundary = '11'\n    value = 500\n  [../]\n  [./inlet_T2]\n    type = DirichletBC\n    variable = T\n    boundary = '21'\n    value = 600\n  [../]\n[]\n\n[Materials]\n  [./EM]\n    type = submaterial\n    is_sodium = true\n    constant_property = false\n    constant_f_h_property = true\n    f_coefficient = 0.01\n    diameter = 0.02\n    temp = T\n    block = '1 2'\n  [../]\n[]\n\n[Preconditioning]\n  [./FD]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[VectorPostprocessors]\n  [./VELADJ_VEC]\n    type = NodalValueSampler\n    variable = u\n    block = '2'\n    sort_by = x\n    execute_on = 'LINEAR NONLINEAR'\n  [../]\n  [./PRESSADJ_VEC]\n    type = NodalValueSampler\n    variable = p\n    block = '2'\n    sort_by = x\n    execute_on = 'LINEAR NONLINEAR'\n  [../]\n  [./RHOADJ_VEC]\n    type = Sampler1DReal\n    block = '2'\n    property = 'rho'\n    sort_by = x\n    execute_on = 'LINEAR NONLINEAR'\n  [../]\n[]\n\n[Executioner]\n  type =  Steady\n  solve_type = PJFNK\n\n  petsc_options = '-snes_converged_reason -ksp_converged_reason'\n  petsc_options_iname = '-pc_type -pc_factor_shift_type -pc_factor_mat_solver_package'\n  petsc_options_value = 'lu    NONZERO      superlu_dist'\n\n  nl_rel_tol = 1e-8\n  nl_abs_tol = 1e-12\n  nl_max_its = 100\n  l_tol = 1e-6\n  l_max_its = 50\n  line_search = 'none'\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n\nI don't know why the num_entries is 0.",
                          "url": "https://github.com/idaholab/moose/discussions/22128#discussioncomment-3673347",
                          "updatedAt": "2022-09-19T04:07:56Z",
                          "publishedAt": "2022-09-18T08:23:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "The NodalValueSampler isnt going to have 1 entry. It ll have a lot. Not sure why it s reporting 0.\nI would use a postprocessor to get the value you wasnt, then convert it to a VPP using the VectorOfPostprocessors vpp.\nAnyway, I think we may be astray here.\nYou're just trying to copy a variable into another variable right?\nBoth the ParsedAux and SelfAux can do that",
                          "url": "https://github.com/idaholab/moose/discussions/22128#discussioncomment-3677392",
                          "updatedAt": "2022-09-19T04:10:59Z",
                          "publishedAt": "2022-09-19T04:10:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Actually the \"variable\" and the \"another variable\" are from different blocks. The [Variable] and [Kernel] block in MOOSE are all block-restrictable. So I meet this problem when I try to express \"variable in another block\" in the current block. And why I have to do that is because the equation which I want to solve is semiempirical. The equation is independent of grid.\nAll in all, thank you a lot for your patience! I will try SelfAux first.",
                          "url": "https://github.com/idaholab/moose/discussions/22128#discussioncomment-3678090",
                          "updatedAt": "2022-09-19T07:07:31Z",
                          "publishedAt": "2022-09-19T07:07:30Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah ok.\nCan they be split in a different calculation using the MultiApp system?\nThis is typically how we do this.\nSelfAux would only work if they were defined on the same blocks",
                          "url": "https://github.com/idaholab/moose/discussions/22128#discussioncomment-3684271",
                          "updatedAt": "2022-09-19T19:59:33Z",
                          "publishedAt": "2022-09-19T19:59:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Issues With Running Sintering Model",
          "author": {
            "login": "ibuhari86"
          },
          "bodyText": "Hello,\nI am trying to run one of the input files from @SudiptaBiswas 2018 paper but I am running into issues.\nSince I am new to the MOOSE/GitHub environment, I started off with the first tutorial on app development, but since I am not trying to create a new application for a starter, I intended to run the input file \"sintering_test1_isomob.i\" from tests in Crow. I downloaded the crow as a zipped file, started with the creation of a new app named \"crow\" by following the first few steps of tutorial one (image 1 attached), and then pasting the content of the downloaded crow into the new crow I created. However, when I tried to execute the command cd ~/projects/babbler make -j4 it does not create the crow-opt file needed to run the app. I start to get fatal errors as seen in the second and third images.\nAny ideas what I might be missing? Or is there a better way to achieve this? Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/21523",
          "updatedAt": "2022-09-19T18:36:20Z",
          "publishedAt": "2022-07-06T22:33:04Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "SudiptaBiswas"
                  },
                  "bodyText": "Hi @ibuhari86, You will need to switch to devel branch to compile the application. Cloning the application instead of using the zip might work better.",
                  "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3095779",
                  "updatedAt": "2022-07-06T22:36:22Z",
                  "publishedAt": "2022-07-06T22:36:22Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ibuhari86"
                          },
                          "bodyText": "Hello @SudiptaBiswas,\nThank you very much for your response. I tried cloning and when I executed the same command it seemed to be compiling alright at the start but exited with one of the fatal errors I encountered above.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3095902",
                          "updatedAt": "2022-07-06T23:07:51Z",
                          "publishedAt": "2022-07-06T23:07:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "You need to switch to devel branch. Do git checkout devel before compiling.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3096053",
                          "updatedAt": "2022-07-06T23:29:49Z",
                          "publishedAt": "2022-07-06T23:27:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ibuhari86"
                          },
                          "bodyText": "I switched to devel branch, tried to compile and run into this (images 1 & 2). I had a similar issue when I was installing MOOSE for the first time, and I needed to delete idaholab from mamba list and reinstall the mamba moose environment and that solved the issue. idaholab is no linger an output of cat ~/.condarc, so I tried reinstalling the mamba package again but the error is persistent (image 3).",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3096286",
                          "updatedAt": "2022-07-07T00:30:28Z",
                          "publishedAt": "2022-07-07T00:30:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "This indicates that the libmesh is not built. Try running the libmesh update script.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3097117",
                          "updatedAt": "2022-07-07T04:38:13Z",
                          "publishedAt": "2022-07-07T04:38:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ibuhari86"
                          },
                          "bodyText": "Hi @SudiptaBiswas,\nAre you talking about this script\ncd ~/projects/moose\n./scripts/update_and_rebuild_libmesh.sh?\n\n\nIf it is, then I run it and still could not compile.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3097208",
                          "updatedAt": "2022-07-07T05:02:57Z",
                          "publishedAt": "2022-07-07T05:02:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ibuhari86"
                          },
                          "bodyText": "Now, when I run make -j4 in the moose environment (rather than base), Error 127 disappears and another (Error 1) appears as shown. ./run_tests -j8 then resulted in FAILED tests.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3097528",
                          "updatedAt": "2022-07-07T06:09:38Z",
                          "publishedAt": "2022-07-07T06:09:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "This seems like a linking error. You will have to clean your directory before rebuilding the application. Try make clobberall first within the application and you might also need to perform git clean -xfd ( caution: this will delete any unchecked files, make sure to commit any changes you might have before doing this). Then try make again. It also might be a good idea to rebuild a moose module before trying the application.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3101692",
                          "updatedAt": "2022-07-07T16:26:54Z",
                          "publishedAt": "2022-07-07T16:26:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nSo for this last error, you are missing a function definition.\nYou need to have a validParam function in all your materials, just like this (this is a kernel)\nheader:\nclass FVAdvection : public FVFluxKernel\n{\npublic:\n  static InputParameters validParams();\n...\n\nsource:\nInputParameters\nFVAdvection::validParams()\n{\n  InputParameters params = FVFluxKernel::validParams();\n  params.addClassDescription(\n      \"Residual contribution from advection operator for finite volume method.\");\n  params.addRequiredParam<RealVectorValue>(\"velocity\", \"Constant advection velocity\");\n  MooseEnum advected_interp_method(\"average upwind skewness-corrected\", \"upwind\");\n\n  params.addParam<MooseEnum>(\n      \"advected_interp_method\",\n      advected_interp_method,\n      \"The interpolation to use for the advected quantity. Options are \"\n      \"'upwind', 'average' and 'skewness-corrected', with the default being 'upwind'.\");\n  return params;\n}\n\nThe previous validParam syntax is deprecated, you need to update all of CrowApp to use the new one.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3101696",
                          "updatedAt": "2022-07-07T16:27:26Z",
                          "publishedAt": "2022-07-07T16:27:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "also you need to be more careful with the build instructions. You previously tried to build libmesh independently, but you are also trying to use the mamba install. Both methods are incompatible (except for expert users, they can be made to work together) and may lead to compiling errors.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3101711",
                          "updatedAt": "2022-07-07T16:29:00Z",
                          "publishedAt": "2022-07-07T16:28:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ibuhari86"
                          },
                          "bodyText": "This seems like a linking error. You will have to clean your directory before rebuilding the application. Try make clobberall first within the application and you might also need to perform git clean -xfd ( caution: this will delete any unchecked files, make sure to commit any changes you might have before doing this). Then try make again. It also might be a good idea to rebuild a moose module before trying the application.\n\nHi @SudiptaBiswas, by your last statement, did you mean reinstalling the MOOSE environment again from scratch? I did make clobberall and git clean -xfd but I am still getting Error 1.",
                          "url": "https://github.com/idaholab/moose/discussions/21523#discussioncomment-3102022",
                          "updatedAt": "2022-07-07T17:21:15Z",
                          "publishedAt": "2022-07-07T17:20:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A 'SplitCHParsed' is not a registered object.",
          "author": {
            "login": "FatimahDzr"
          },
          "bodyText": "Hello everyone,\nI tried to run the code 2015_10_19_FAST_2p_periodic_neckgrowth.i from SudiptaBiswas. Even though Im connected with her directory and linked my moose to GitHub, every time I tried to run the code via UBUNTU and using  ../projects/crow/crow-opt -i 2017_04_06_2p_matrxmob.i command I get this error:\n*** ERROR ***\nA 'SplitCHParsed' is not a registered object.\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\nStack frames: 22\n0: libMesh::print_trace(std::ostream&)\n1: moose::internal::mooseErrorRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >)\n2: void mooseError<std::__cxx11::basic_string<char, std::char_traits, std::allocator > >(std::__cxx11::basic_string<char, std::char_traits, std::allocator >&&)\n3: Factory::reportUnregisteredError(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&) const\n4: Factory::getValidParams(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&)\n5: MooseObjectAction::MooseObjectAction(InputParameters)\n6: AddKernelAction::AddKernelAction(InputParameters)\n7: /mnt/c/For_MOOSE/projects/moose/framework/libmoose-opt.so.0(+0x795588) [0x7fbfd3a39588]\n8: /mnt/c/For_MOOSE/projects/moose/framework/libmoose-opt.so.0(+0x795617) [0x7fbfd3a39617]\n9: ActionFactory::create(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, InputParameters&)\n10: Parser::walkRaw(std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::__cxx11::basic_string<char, std::char_traits, std::allocator >, hit::Node*)\n11: Parser::walk(std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, std::__cxx11::basic_string<char, std::char_traits, std::allocator > const&, hit::Node*)\n12: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n13: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n14: hit::Node::walk(hit::Walker*, hit::NodeType, hit::TraversalOrder)\n15: Parser::parse(std::vector<std::__cxx11::basic_string<char, std::char_traits, std::allocator >, std::allocator<std::__cxx11::basic_string<char, std::char_traits, std::allocator > > > const&)\n16: MooseApp::setupOptions()\n17: MooseApp::run()\n18: main\n19: /lib/x86_64-linux-gnu/libc.so.6(+0x29d90) [0x7fbfcc647d90]\n20: __libc_start_main\n21: ../projects/crow/crow-opt(+0x23ef) [0x5645364fd3ef]\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\nAs I understand the kernel A 'SplitCHParsed' is not a registered in my Moose library. I would be grateful if you could help me with this error and how to solve that. Is there any approach to adding a kernel to the moose library?",
          "url": "https://github.com/idaholab/moose/discussions/21946",
          "updatedAt": "2022-09-19T18:28:29Z",
          "publishedAt": "2022-08-26T17:51:30Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nso you are using Crow directly?\nyou\u2019re not hitting any error? There were issues like 2 months ago did they get addressed?\ncan you please paste the output \u00b4 ldd crow-opt\u2019\nTo see if the phase field module for linked properly\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3491235",
                  "updatedAt": "2022-08-27T23:50:07Z",
                  "publishedAt": "2022-08-27T23:50:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Also can you more simple input files with crow?",
                          "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3491240",
                          "updatedAt": "2022-08-27T23:53:04Z",
                          "publishedAt": "2022-08-27T23:53:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "FatimahDzr"
                          },
                          "bodyText": "I can run the simple examples in the moose example file but for this case, it cannot be run. I downloaded SplitCHParsed kernel and pasted it into files \"include\" and \"src\" to address this issue. It worked and apparently the code can be run but when it reached the kernel \"PolycrystalSinteringKernel\", it stopped and printed\n*** ERROR ***\n/mnt/c/moose/exp/ex10.i:81: missing required parameter 'Kernels/PolycrystalSinteringKernel/type'\nDoc String: \"A string representing the Moose Object that will be built by this Action\"\nI couldn't find that kernel yet. I'm not sure if it is a practical solution to download and put each kernel for running the problem.",
                          "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3597417",
                          "updatedAt": "2022-09-08T16:45:41Z",
                          "publishedAt": "2022-09-08T16:45:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you forgot to specify the type of the object, it s a required parameter\notherwise we dont know what the object is",
                          "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3597897",
                          "updatedAt": "2022-09-08T17:32:38Z",
                          "publishedAt": "2022-09-08T17:32:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "FatimahDzr"
                          },
                          "bodyText": "Thank you for your response, at first I tried to create my own application but every time an error appeared. So I used cloning to the Crow git. I cloned to the \"devel\" branch successfully but when I'm going to create crow-opt, this error appears :\n/home/fatimahdzr/mambaforge3/envs/moose/bin/../lib/gcc/x86_64-conda-linux-gnu/10.4.0/../../../../x86_64-conda-linux-gnu/bin/ld: /mnt/c/moose/projects/gav/lib/libCrow-opt.so: **undefined reference to `InputParameters validParams<Material>()'\ncollect2: error: ld returned 1 exit status**\n\nI would be grateful if you could help me with this error.\nRegards",
                          "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3681897",
                          "updatedAt": "2022-09-19T17:29:29Z",
                          "publishedAt": "2022-09-19T15:10:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThis is because Crow has deprecated syntax for valid parameters. see this post\nhttps://mooseframework.inl.gov/newsletter/2020_04.html#!\nWe really want someone to fix this, it keeps coming up\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21946#discussioncomment-3683701",
                          "updatedAt": "2022-09-19T18:28:29Z",
                          "publishedAt": "2022-09-19T18:28:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Type for matrix multiplication",
          "author": {
            "login": "philipJFpfahl"
          },
          "bodyText": "Hello,\nI am new to using moose, but I hope this question is not too trivial.\nI would like to weigh a variable with a pre-calculated matrix and calculate a new variable with that.\n$a=Wb$\nwhere $a$ and $b$ would be $N$ dimensional (for each mesh point) and $W$ would be $N \\times N$.\nthis is part of a coupled equation where\n$\\dot{p} = p + a$\nSo far so easy.\nNow I wanted to implement this by defining a material \"W\" and then calling this material later to be consumed by a Kernel doing the matrix multiplication.\nFirst:\nIt seems to me, that such an operation should be rather common. Is there already a module doing that?\nif not:\nHow should I implement the matrix W?\nA Material object seems like the right choice, but I only want to initialize the matrix once. So maybe it's better to write a User object doing that?\nThanks in advance\n``",
          "url": "https://github.com/idaholab/moose/discussions/21752",
          "updatedAt": "2022-09-19T08:10:20Z",
          "publishedAt": "2022-08-02T14:14:23Z",
          "category": {
            "name": "Q&A Getting Started"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou may use a RankTwoTensor to store a matrix.\nWe do have material properties of type rank two tensor.\nSee this example\nhttps://mooseframework.inl.gov/source/materials/ADGenericConstantRankTwoTensor.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3309662",
                  "updatedAt": "2022-08-02T16:40:46Z",
                  "publishedAt": "2022-08-02T16:40:46Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hello,\nthank you for the fast reply. That is, what I was looking for.\nSo I should make a material, that produces the $W$ matrix and then a kernel that consumes it?\nAnd is it possible to execute the material only at the beginning of my calculations? I tried \"execute_on = INITIAL\" but that does not seem to work for materials.\nI am asking because I am sure what the \"best\" way to do that is.\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3314354",
                          "updatedAt": "2022-08-03T08:36:05Z",
                          "publishedAt": "2022-08-03T08:36:05Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nYes for the material creating / computing it and the kernel consuming / using the value.\nI'm afraid not, we dont really support execution schedules on regular materials (only on functor materials, but we havent added the tensor overloads for these). What you could do is make it depend on copies of the variables, then if those copies are never updated the material properties would be constant.\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3316147",
                          "updatedAt": "2022-08-03T12:48:47Z",
                          "publishedAt": "2022-08-03T12:48:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hello,\nso the material object is called, whenever the kernel consumes it? That seems like a substantial computational burden if the material stays constant all the time, especially with a larger mesh. I am also not interested in the shape function of the $W$ matrix (since I already know it).\nIs it better to store the matrix as a  vector?\nIf yes, how would I generate such a vector?\nI could then use it to make the matrix multiplication in the Kernel as a loop.\nFor $N$ mesh points it would be something like this\nfor(int i =0; i < $N \\times N$; i++)\n{\na[_qp] = W[_qp * $N \\times N$ + i] b[i]\n}\nI am wondering why no one uses this kind of operation in MOOSE. Is there a better way to approach this problem?\nAnyway thanks for your help this far.\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3316321",
                          "updatedAt": "2022-08-03T13:09:34Z",
                          "publishedAt": "2022-08-03T13:09:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "If it s constant spatially then you may use the constant_on option to say that it s constant by block and that will make it only be computed once for every element / qp in the block\n\nYou may store it as a vector if you prefer, please have a look at Vector materials instead of tensors then\n\u2026\n Le 3 ao\u00fbt 2022 \u00e0 08:09, philipJFpfahl ***@***.***> a \u00e9crit :\n\n \ufeff\n Hello,\n\n so the material object is called, whenever the kernel consumes it? That seems like a substantial computational burden if the material stays constant all the time, especially with a larger mesh. I am also not interested in the shape function of the $W$ matrix (since I already know it).\n Is it better to store the matrix as a vector?\n If yes, how would I generate such a vector?\n I could then use it to make the matrix multiplication in the Kernel as a loop.\n For $N$ mesh points it would be something like this\n\n for(int i =0; i < $N \\times N$; i++)\n {\n a[_qp] = W[_qp * $N \\times N$ + i] b[i]\n }\n\n I am wondering why no one uses this kind of operation in MOOSE. Is there a better way to approach this problem?\n Anyway thanks for your help this far.\n\n Philip\n\n \u2014\n Reply to this email directly, view it on GitHub, or unsubscribe.\n You are receiving this because you commented.",
                  "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3316565",
                  "updatedAt": "2022-08-03T13:36:12Z",
                  "publishedAt": "2022-08-03T13:36:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nSo I reviewed the problem. I think there was a misunderstanding from my side of how MOOSE handles indexing.\nWhen doing the finite element method you have nodes and elements. The number of nodes is equal to the number of points in your mesh. In MOOSE you integrate over these elements. The _qp index indicates the point in the element on which the integral is supported.\nWhat I need to do has nothing to do with the integral. On each time step, I want to adjust the value of each node point. The adjustment depends on the matrix $W$ and all the other nodal points. In the sense, that the jth node is calculated like this\n$$a_j = \\sum_{k = 1}^N W_{j,k} b_k$$\nwith N nodal points.\nIn a more physical sense, that means, that every point of $a$ depends on all the other points in $b$ multiplied by a weight.\nI am sorry for my misleading question, I didn't know better. Is there a way in MOOSE to solve these kinds of problems?\nThanks again,\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3335298",
                          "updatedAt": "2022-08-05T16:28:07Z",
                          "publishedAt": "2022-08-05T16:28:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think you can do that in MOOSE, though I think you'll have to code it\nHave a be an AuxVariable, and the kernel that does this operation an AuxKernel.\nThen you ll want to access\n\na at _qp\nb at k, which will be the index in a loop from 0 to Nqp\nW at the combined index\n\nW can still be a vector or a rank two tensor, as you prefer. If it s constant, GenericConstantRankTwoTensor is still a good choice",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3339483",
                          "updatedAt": "2022-08-07T04:09:54Z",
                          "publishedAt": "2022-08-06T13:04:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey\nI had to try that. The problem remains. I can not access the full value of my Variable b in my Kernel. I checked that it is nodal. I suppose I just struggle with the indexing of $b$ in the Kernel.\nI initialize it with\nconst VariableValue & _b;\nand add it to the parameters\nparams.addRequiredCoupledVar(\"b\", \"This is text\");\n_b(coupledValue(\"b\"))\nin the for loop, I try to index it as _b[k], but it seems to contain only at _b[0] the correct value of the current qp.\nCan you give me a hint on how to access all the variable values in the Kernel?\nThank you very much,\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3349813",
                          "updatedAt": "2022-08-08T13:58:24Z",
                          "publishedAt": "2022-08-08T13:58:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "is this a Kernel or an AuxKernel?\nis this 2D or 3D?\nWhich quadrature are you specifying in the Executioner block? Or is it the default?",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3351462",
                          "updatedAt": "2022-08-08T17:26:57Z",
                          "publishedAt": "2022-08-08T17:26:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nit is in an AuxKernel, in 2D.\n[Executioner]\n  type = Transient\n  start_time = 0\n  dt = 0.01\n  num_steps = 2\n  solve_type = 'PJFNK'\n[]\n\nIs there a place where I can read up on this?\nThank you,\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3352430",
                          "updatedAt": "2022-08-08T23:45:17Z",
                          "publishedAt": "2022-08-08T19:53:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hi Philip\nSo you actually wont have access to any other qp for a nodal variable. For an elemental variable you would, all the qp values are computed for the element. But for a nodal variable, the node is a the quadrature point, so there is only one value there.\nYou could try performing this operation with an elemental variable, then projecting it to a nodal variable\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3353995",
                          "updatedAt": "2022-08-09T01:29:50Z",
                          "publishedAt": "2022-08-09T01:29:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nIs it possible, that a kernel gets only handed the nodal position in the mesh and is then able to operate (however) on that node? Therefore it would not possible to access all the nodal values in each kernel. From a parallelization perspective that makes sense, but would make my life much more difficult.\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3355971",
                          "updatedAt": "2022-08-09T08:40:48Z",
                          "publishedAt": "2022-08-09T08:40:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Yes. For nodes you only get to operate on that node, it's a single quadrature point loop basically\nFor elements you may work with all the quadrature points at once.",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3358525",
                          "updatedAt": "2022-08-09T14:16:36Z",
                          "publishedAt": "2022-08-09T14:16:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "I see. Is there a way to access the same Matrix and the same Variable, AuxVariable or vector at all individual nodes?\nThen I could do the Matrix multiplication that way.",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3358607",
                          "updatedAt": "2022-08-09T14:27:22Z",
                          "publishedAt": "2022-08-09T14:27:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "on nodes the classic way not that I know of.\n@lindsayad how could we access multiple node values at the same time? We could re-init multiple times but that s not desirable",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3359517",
                          "updatedAt": "2022-08-09T16:19:22Z",
                          "publishedAt": "2022-08-09T16:19:22Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "philipJFpfahl"
                  },
                  "bodyText": "Hey,\nI am still struggling with the implementation of the weight matrix. It seems like the order in which MOOSE addresses each node is not row by row.\nWhat I mean, is that if I have a $2 \\times 2$ grid I expect the indexing to be something like this:\n0 1  \n2 3\n\nresulting in a solution vector indexed like this (0, 1, 2, 3). For this, I would know, how to load the weight matrix.\nBut the indexing is more like this:\n0 1\n3 2\n\nresulting in (0, 1, 3, 2) as the indices for the returned solution vector.\nIs there a way, to load in (maybe a material) and have it be in the same order as the MOOSE solution vector?\nwhat I mean is that for a matrix with indexes like that:\n00 01 02 03\n10 11 12 13 \n20 21 22 23 \n30 31 32 33 \n...\n\nI would  need it to be transformed into a matrix like this:\n00 01 03 02\n10 11 13 12 \n30 31 33 32 \n20 21 23 22 \n\nNote that for $W_{j,i}$ both the $j$ and the $i$ index are \"out of order\".\nI don't have a better description. Maybe there is also a way to get the \"real\" position of the node somehow. All ideas are welcome.\nThank you,\nPhilip",
                  "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3413666",
                  "updatedAt": "2022-08-17T10:54:10Z",
                  "publishedAt": "2022-08-17T10:54:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you dump the material into an auxvariable it will be ordered similarly as other variables.\nYou may use Array aux variables for this",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3417621",
                          "updatedAt": "2022-08-17T20:08:57Z",
                          "publishedAt": "2022-08-17T20:08:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nI think that is the right path. The AuxVariabes are stored in the same \"nodal\" order as the Variables. I also found out, that  allow_renumbering = false orders the nodes in a better way. (As I would do it by hand)\nNow the problem is the following:\nI still need access to each entry in the AuxVariabes vector. So how do I do the same you showed me for Variables with AuxVariables?\nAll the best,\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3429116",
                          "updatedAt": "2022-08-19T07:24:07Z",
                          "publishedAt": "2022-08-19T07:24:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "How do you compute W? I feel like that\u2019s a very important question because maybe it would inform my question of how you would get W correctly sorted/stored into an array aux variable representation",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3429433",
                          "updatedAt": "2022-08-19T08:19:45Z",
                          "publishedAt": "2022-08-19T08:19:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "By the way somewhere in this discussion I think you asked about accessing positions. If you are in a nodal aux kernel, you have a _current_node data member which is a pointer to the current Node, which derives from Point. So dereferencing the pointer, you will have something that behaves exactly like a Point. So for instance you can access the x-coordinate like this:\n(*_current_node)(0)",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3429512",
                          "updatedAt": "2022-08-19T08:33:04Z",
                          "publishedAt": "2022-08-19T08:33:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "$W$ is the tensor product of two vectors $c \\otimes d$ with the same length as $a$.\nIn physical terms, the two vectors are scaled versions of the power shape of the reactor. This matrix is not really sparse. My idea was only to store the two vectors and then calculate the entries of $W$ in each $for$ loop. This will work fast since the problem seems memory bound. (Please correct me if I am wrong)\nI load the AuxVariables with the PropertyReadFile Object.\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3429515",
                          "updatedAt": "2022-08-19T08:33:36Z",
                          "publishedAt": "2022-08-19T08:33:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "(*_current_node)(0)\nThats a good tip. Thank you, I was just confused in which way MOOSE indexes the different points. That is also how I intend to find the current node id  _current_node -> id().\nAs I said I am just getting into MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3429589",
                          "updatedAt": "2022-08-19T08:44:55Z",
                          "publishedAt": "2022-08-19T08:44:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "Sorry for the delay @philipJFpfahl. I am currently on leave but will be back to work next Monday at which time I should be able to help more",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3475275",
                          "updatedAt": "2022-08-25T14:28:14Z",
                          "publishedAt": "2022-08-25T14:28:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Oh, thank you for checking up.\nI figured out that I can find the aux solution vector with _aux_sys.serializedSolution() but the coupled() method does not return the correct index for auxVariables. The rest should be working fine.\nAll the best and have a nice time off.",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3475543",
                          "updatedAt": "2022-08-25T14:56:43Z",
                          "publishedAt": "2022-08-25T14:56:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Hey,\nhave you found a solution to find out the right integer for the position in the aux solution vector?\nall the best\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3634671",
                          "updatedAt": "2022-09-13T11:50:08Z",
                          "publishedAt": "2022-09-13T11:50:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "I forget where we were at in the conversation. You can get the correct dof index if you use the DofObject::dof_number API. So assuming _aux_var_number = coupled(\"blah_blah\"):\nconst auto soln_vector_index = _current_node->dof_number(_aux_sys.number(), _aux_var_number, 0);\nHere I am assuming you are in a nodal aux kernel (I think that's where we arrived, but correct me if I'm wrong)",
                          "url": "https://github.com/idaholab/moose/discussions/21752#discussioncomment-3648346",
                          "updatedAt": "2022-09-14T21:02:58Z",
                          "publishedAt": "2022-09-14T21:02:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Mixing mesh elements",
          "author": {
            "login": "heinono1"
          },
          "bodyText": "This may be a simple questions that is already answered somewhere. Is it possible to use a mesh with different elements (eg tets and hexes) but arranged so that each block only contains one kind of mesh elements, but different blocks can have different kinds of elements? I know that within a block, MOOSE seems not to like mixed elements.",
          "url": "https://github.com/idaholab/moose/discussions/22122",
          "updatedAt": "2022-09-29T16:52:07Z",
          "publishedAt": "2022-09-16T18:26:43Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "yes it s very much supported\njust a detail but libmesh as well does not like mixed elements",
                  "url": "https://github.com/idaholab/moose/discussions/22122#discussioncomment-3665042",
                  "updatedAt": "2022-09-16T18:40:32Z",
                  "publishedAt": "2022-09-16T18:40:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "heinono1"
                  },
                  "bodyText": "Thanks! I thought it might be, but I wanted to make sure.",
                  "url": "https://github.com/idaholab/moose/discussions/22122#discussioncomment-3665143",
                  "updatedAt": "2022-09-16T18:55:59Z",
                  "publishedAt": "2022-09-16T18:55:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Can NOT open output file in Paraview",
          "author": {
            "login": "seongwonHam"
          },
          "bodyText": "Hello, MOOSE users.\nI have some trouble with the ParaView program.\nI can NOT open my MOOSE calculation result file in ParaView.\nGenerally, I used to drag the output file from MobaXterm's UI to paraview to check my results.\nHowever, this work doesn't work today, and I couldn't visualize my files.\nI don't know why this situation has occurred.\nAttached is a picture of the error code from Paraview.\nPlease let me know how can I solve this problem and make it normally.\n\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/22116",
          "updatedAt": "2022-09-29T16:52:22Z",
          "publishedAt": "2022-09-16T08:56:32Z",
          "category": {
            "name": "Q&A Tools"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou need to use the legacy exodus reader.\nPlease search on the forum, there's others who did this\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22116#discussioncomment-3664100",
                  "updatedAt": "2022-09-29T16:52:44Z",
                  "publishedAt": "2022-09-16T16:09:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Coupling INSFV and FVDiffusion for heat transfer through a subdomain boundary",
          "author": {
            "login": "JuliaHLee"
          },
          "bodyText": "Dear MOOSE experts,\nI am working on a micro-scale heat transport model with INSFV. As a preliminary model, I have made a 2D geometry including a domain as fluid space and a subdomain in the center as a solid block, and managed to simulate the heat transport with water flow in the fluid space. However, heat conduction in the solid did not occur. It seems, there was a problem with heat transfer between fluid and solid, even though I tried it with the \u2018PINSFVEnergyAmbientConvection\u2019 FVKernel assigned on the boundary element between the fluid and solid (please click 'input file' below). I also tried \u2018FVConvectionCorrelationInterface\u2019, but it also did work. Here is the simulation result below:\n\nIs there a way to couple INSFV and FVDiffusion through the subdomain boundary (lower dimensional element) in the center of the domain? For the heat transfer coupling variables in fluid and solid phase, which Kernel can be used? Or should I use finite element method, instead of finite volume method?\nIn addition, can I make a constant pressure difference between top and bottom boundary? I would like to assign inlet and outlet pressure for the uniform water flow from top to bottom, instead of pinning the pressure at the corner of the top boundary.\nAny suggestion and comment will be welcome.\nBest regards,\nJulia\nInput file\n\n# Water properties\nmu = 1.0E-3\nrho = 1000.0\nk = 0.598\ncp = 4186\nh_fs = 100\n\n\n# Solid properties\ncp_s = 830\nrho_s = 1680\nk_s = 3.5\np_outlet = 0\n\n[Mesh]\n  [generated_mesh]\n  type = GeneratedMeshGenerator\n  dim = 2\n  nx = 40\n  ny = 40\n  xmin = 0\n  ymin = 0\n  ymax = 0.1 \n  xmax = 0.1 \n  []\n  [subdomain1]\n    input = generated_mesh\n    type = SubdomainBoundingBoxGenerator\n    block_name = subdomain1\n    bottom_left = '0.04 0.04 0'\n    block_id = 1\n    top_right = '0.06 0.06 0'\n  []\n  [sideset]\n    input = subdomain1\n    type = SideSetsAroundSubdomainGenerator\n    block = 1\n    new_boundary = sideset\n  []\n  [solid_boundary]\n    input = sideset\n    type = LowerDBlockFromSidesetGenerator\n    sidesets = sideset\n    new_block_id = 2\n  []\n[]\n\n[GlobalParams]\n  # retain behavior at time of test creation\n  two_term_boundary_expansion = false\n  rhie_chow_user_object = 'rc'\n  advected_interp_method = 'average'\n  velocity_interp_method = 'rc'\n[]\n\n[UserObjects]\n  [rc]\n    type = INSFVRhieChowInterpolator\n    u = vel_x\n    v = vel_y\n    block = 0\n    pressure = pressure\n  []\n[]\n\n[Variables]\n  [vel_x]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [vel_y]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [pressure]\n    type = INSFVPressureVariable\n    block = 0\n  []\n  [T]\n    type = INSFVEnergyVariable\n    block = '0 2'\n    initial_condition = 283.15\n  []\n  [Ts]\n    type = INSFVEnergyVariable\n    initial_condition = 283.15\n    block = '1 2'\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    rho = ${rho}\n    block = 0\n  []\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_x\n    mu = ${mu}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_x\n    momentum_component = 'x'\n    pressure = pressure\n    block = 0\n  []\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_y\n    momentum_component = 'y'\n    pressure = pressure\n    block = 0\n  []\n  [energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = T\n    cp = ${cp}\n    rho = ${rho}\n    block = 0\n  []\n  [temp_conduction]\n    type = FVDiffusion\n    coeff = 'k'\n    variable = T\n    block = 0\n  []\n  [temp_advection]\n    type = INSFVEnergyAdvection\n    variable = T\n    block = 0\n  []\n  [solid_energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = Ts\n    cp = ${cp_s}\n    rho = ${rho_s}\n    block = 1\n  []\n  [solid_temp_conduction]\n    type = FVDiffusion\n    coeff = 'k_s'\n    variable = Ts\n    block = 1\n  []\n  [Ts_energy_convection]\n    type = PINSFVEnergyAmbientConvection\n    variable = Ts\n    is_solid = true\n    T_fluid = T\n    T_solid = Ts\n    h_solid_fluid = 'h_cv'\n    block = 2\n  []\n  [T_energy_convection]\n    type = PINSFVEnergyAmbientConvection\n    variable = T\n    is_solid = false\n    T_fluid = T\n    T_solid = Ts\n    h_solid_fluid = 'h_cv'\n    block = 2\n  []\n[]\n\n\n[FVBCs]\n  [inlet-u]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_x\n    function = 0\n  []\n  [inlet-v]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_y\n    function = -1e-4\n  []\n  [inlet_T]\n   type = FVDirichletBC\n    variable = T\n    boundary = 'top'\n    value = 303.15\n  []\n  [no-slip-u]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_x\n    function = 0\n  []\n  [no-slip-v]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_y\n    function = 0\n  []\n\n  [symmetry-u]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'x'\n  []\n  [symmetry-v]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [symmetry-p]\n    type = INSFVSymmetryPressureBC\n    boundary = 'right'\n    variable = pressure\n  []\n\n  [outlet_u]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'x'\n    rho = ${rho}\n  []\n  [outlet_v]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'y'\n    rho = ${rho}\n  []\n  [outlet_p]\n    type = INSFVOutletPressureBC\n    boundary = 'bottom'\n    variable = pressure\n    function = '${p_outlet}'\n  []\n[]\n\n[Materials]\n  [functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k'\n    prop_values = '${cp} ${k}'\n  []\n  [ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'T'\n    rho = ${rho}\n    block = 0\n  []\n  [solid_functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp_s k_s'\n    prop_values = '${cp_s} ${k_s}'\n  []\n  [solid_ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'Ts'\n    rho = ${rho_s}\n    block = 1\n  []\n  [constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'h_cv'\n    prop_values = '${h_fs}'\n    block = 2\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_pc_type -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm      100                lu           NONZERO'\n  line_search = 'none'\n  nl_rel_tol = 1e-5  #7e-13\n  dt = 10\n  end_time = 1000\n[]\n\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/22070",
          "updatedAt": "2022-09-16T08:19:44Z",
          "publishedAt": "2022-09-12T12:24:00Z",
          "category": {
            "name": "Q&A Modules: Navier-Stokes"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPINSFVEnergyAmbientConvection is for volumetric heat transfer so it wont work for heat exchange between surfaces.\nFVConvectionCorrelationInterface should have worked. How did you set it up?\nYou do not need lower dimensional elements to make this work. The interface kernel should be set on the sideset.\nI would remove this block\n  [solid_boundary]\n    input = sideset\n    type = LowerDBlockFromSidesetGenerator\n    sidesets = sideset\n    new_block_id = 2\n  []\n\nbecause these elements with no physics solved on them will impact the solver performance\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3627513",
                  "updatedAt": "2022-09-12T16:01:45Z",
                  "publishedAt": "2022-09-12T16:01:43Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "JuliaHLee"
                          },
                          "bodyText": "Hello Guillaume,\nThank you for your answer and suggestions! As you suggested, I removed the lower dimensional elements.\nWhen I tried the IFVConvectionCorrelationInterface, temperature change in the solid block occurred. However, the kernel created an additional heat flux from the sideset boundary to the fluid space, instead of reaching the temperature equilibrium between fluid and solid phase. The additional heat flux or heat sink should not happen in my model, because I have a temperature input only from the top boundary with warm water. The simulation result is below:\n\nSo, what I want is to make heat transport through the solid, and reach the temperature equilibrium between fluid and solid phase. Would this Kernel still work for it?\nMany thanks!\nHere is the input file:\n\n# Water properties\nmu = 1.0E-3\nrho = 1000.0\nk = 0.598\ncp = 4186\n\n\n\n# Solid properties\ncp_s = 830\nrho_s = 1680\nk_s = 3.5\np_outlet = 0\n\n[Mesh]\n  [generated_mesh]\n  type = GeneratedMeshGenerator\n  dim = 2\n  nx = 40\n  ny = 40\n  xmin = 0\n  ymin = 0\n  ymax = 0.1 \n  xmax = 0.1 \n  []\n  [subdomain1]\n    input = generated_mesh\n    type = SubdomainBoundingBoxGenerator\n    block_name = subdomain1\n    bottom_left = '0.04 0.04 0'\n    block_id = 1\n    top_right = '0.06 0.06 0'\n  []\n  [sideset]\n    input = subdomain1\n    type = SideSetsAroundSubdomainGenerator\n    block = 1\n    new_boundary = sideset\n  []\n[]\n\n[GlobalParams]\n  # retain behavior at time of test creation\n  two_term_boundary_expansion = false\n  rhie_chow_user_object = 'rc'\n  advected_interp_method = 'average'\n  velocity_interp_method = 'rc'\n[]\n\n[UserObjects]\n  [rc]\n    type = INSFVRhieChowInterpolator\n    u = vel_x\n    v = vel_y\n    block = 0\n    pressure = pressure\n  []\n[]\n\n[Variables]\n  [vel_x]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [vel_y]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [pressure]\n    type = INSFVPressureVariable\n    block = 0\n  []\n  [T]\n    type = INSFVEnergyVariable\n    block = 0\n    initial_condition = 283.15\n  []\n  [Ts]\n    type = INSFVEnergyVariable\n    initial_condition = 283.15\n    block = 1\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    rho = ${rho}\n    block = 0\n  []\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_x\n    mu = ${mu}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_x\n    momentum_component = 'x'\n    pressure = pressure\n    block = 0\n  []\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_y\n    momentum_component = 'y'\n    pressure = pressure\n    block = 0\n  []\n  [energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = T\n    cp = ${cp}\n    rho = ${rho}\n    block = 0\n  []\n  [temp_conduction]\n    type = FVDiffusion\n    coeff = 'k'\n    variable = T\n    block = 0\n  []\n  [temp_advection]\n    type = INSFVEnergyAdvection\n    variable = T\n    block = 0\n  []\n  [solid_energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = Ts\n    cp = ${cp_s}\n    rho = ${rho_s}\n    block = 1\n  []\n  [solid_temp_conduction]\n    type = FVDiffusion\n    coeff = 'k_s'\n    variable = Ts\n    block = 1\n  []\n[]\n\n[FVInterfaceKernels]\n  [convection]\n    type = FVConvectionCorrelationInterface\n    variable1 = T\n    variable2 = Ts\n    boundary = sideset\n    h = 50\n    T_solid = Ts\n    T_fluid = T\n    subdomain1 = 0\n    subdomain2 = 1\n    wall_cell_is_bulk = true\n  []\n[]\n\n[FVBCs]\n  [inlet-u]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_x\n    function = 0\n  []\n  [inlet-v]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_y\n    function = -1e-4\n  []\n  [inlet_T]\n   type = FVDirichletBC\n    variable = T\n    boundary = 'top'\n    value = 303.15\n  []\n  [no-slip-u]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_x\n    function = 0\n  []\n  [no-slip-v]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_y\n    function = 0\n  []\n\n  [symmetry-u]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'x'\n  []\n  [symmetry-v]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [symmetry-p]\n    type = INSFVSymmetryPressureBC\n    boundary = 'right'\n    variable = pressure\n  []\n\n  [outlet_u]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'x'\n    rho = ${rho}\n  []\n  [outlet_v]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'y'\n    rho = ${rho}\n  []\n  [outlet_p]\n    type = INSFVOutletPressureBC\n    boundary = 'bottom'\n    variable = pressure\n    function = '${p_outlet}'\n  []\n[]\n\n[Materials]\n  [functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k'\n    prop_values = '${cp} ${k}'\n  []\n  [ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'T'\n    rho = ${rho}\n    block = 0\n  []\n  [solid_functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp_s k_s'\n    prop_values = '${cp_s} ${k_s}'\n  []\n  [solid_ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'Ts'\n    rho = ${rho_s}\n    block = 1\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_pc_type -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm      100                lu           NONZERO'\n  line_search = 'none'\n  nl_rel_tol = 1e-5  #7e-13\n  dt = 10\n  end_time = 1000\n[]\n\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3636930",
                          "updatedAt": "2022-09-13T16:09:46Z",
                          "publishedAt": "2022-09-13T16:09:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It should work, we shouldnt see this heating up on one side.\nMy guess is that sideset is not consistently oriented in this mesh setup.\nCould you please use the sidesetsBetweenSubdomainGenerator to create that sideset?\nIt should be fairly straight forward",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3637605",
                          "updatedAt": "2022-09-13T17:38:53Z",
                          "publishedAt": "2022-09-13T17:38:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "JuliaHLee"
                          },
                          "bodyText": "I have replaced the sideset block with SideSetsBetweenSubdomainsGenerator. But my simulation result is the same. I guess the heat flux on one side could be due to the non-uniform water flow around the solid block.\nSo I was still thinking that I might need to deal with the interface Kernel. It seems that the flux goes only to the fluid with the Kernel. As you could see on my result above, my solid loses heat and the heat goes to the fluid. But I need the other way around, heat transfer from fluid to solid. How can I change it?",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3642524",
                          "updatedAt": "2022-09-14T08:47:28Z",
                          "publishedAt": "2022-09-14T08:47:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont understand how the fluid is hotter on the right.\nMaybe make the problem fully symmetric and look at what you get?\nThe interface kernel adds contributions to the residual of both equations so it should do what you want.\nIt does seem to influence the temperature distribution in both phases, but the contributions dont seem right",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3646940",
                          "updatedAt": "2022-09-14T17:08:51Z",
                          "publishedAt": "2022-09-14T17:08:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "JuliaHLee"
                          },
                          "bodyText": "Asymmetry is another issue, which I could not solve. I would like to make symmetric water flow, but I could not make it work. I think it is because of the pressure boundary condition, as I mentioned on my posting. The result of pressure in the fluid space is like this:\n\nShouldn't the pressure same over the top boundary, instead of the high pressure point on the corner? So I tried to make the constant pressure difference between top and bottom boundary, by using FVDirichletBC. But it did not converge, like this:\n\nInput file with changed BC\n\n# Water properties\nmu = 1.0E-3\nrho = 1000.0\nk = 0.598\ncp = 4186\n\n\n\n# Solid properties\ncp_s = 830\nrho_s = 1680\nk_s = 3.5\n\n[Mesh]\n  [generated_mesh]\n  type = GeneratedMeshGenerator\n  dim = 2\n  nx = 40\n  ny = 40\n  xmin = 0\n  ymin = 0\n  ymax = 0.1 \n  xmax = 0.1 \n  []\n  [subdomain1]\n    input = generated_mesh\n    type = SubdomainBoundingBoxGenerator\n    block_name = subdomain1\n    bottom_left = '0.04 0.04 0'\n    block_id = 1\n    top_right = '0.06 0.06 0'\n  []\n  [sideset]\n    input = subdomain1\n    type = SideSetsBetweenSubdomainsGenerator\n    primary_block = 0\n    paired_block = 1\n    new_boundary = sideset\n  []\n[]\n\n[GlobalParams]\n  # retain behavior at time of test creation\n  two_term_boundary_expansion = false\n  rhie_chow_user_object = 'rc'\n  advected_interp_method = 'average'\n  velocity_interp_method = 'rc'\n[]\n\n[UserObjects]\n  [rc]\n    type = INSFVRhieChowInterpolator\n    u = vel_x\n    v = vel_y\n    block = 0\n    pressure = pressure\n  []\n[]\n\n[Variables]\n  [vel_x]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [vel_y]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [pressure]\n    type = INSFVPressureVariable\n    block = 0\n  []\n  [T]\n    type = INSFVEnergyVariable\n    block = 0\n    initial_condition = 283.15\n  []\n  [Ts]\n    type = INSFVEnergyVariable\n    initial_condition = 283.15\n    block = 1\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    rho = ${rho}\n    block = 0\n  []\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_x\n    mu = ${mu}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_x\n    momentum_component = 'x'\n    pressure = pressure\n    block = 0\n  []\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_y\n    momentum_component = 'y'\n    pressure = pressure\n    block = 0\n  []\n  [energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = T\n    cp = ${cp}\n    rho = ${rho}\n    block = 0\n  []\n  [temp_conduction]\n    type = FVDiffusion\n    coeff = 'k'\n    variable = T\n    block = 0\n  []\n  [temp_advection]\n    type = INSFVEnergyAdvection\n    variable = T\n    block = 0\n  []\n  [solid_energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = Ts\n    cp = ${cp_s}\n    rho = ${rho_s}\n    block = 1\n  []\n  [solid_temp_conduction]\n    type = FVDiffusion\n    coeff = 'k_s'\n    variable = Ts\n    block = 1\n  []\n[]\n\n[FVInterfaceKernels]\n  [convection]\n    type = FVConvectionCorrelationInterface\n    variable1 = Ts\n    variable2 = T\n    boundary = sideset\n    h = 50\n    T_solid = T\n    T_fluid = Ts\n    subdomain1 = 1\n    subdomain2 = 0\n    wall_cell_is_bulk = true\n  []\n[]\n\n[FVBCs]\n  [inlet-u]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_x\n    function = 0\n  []\n  [inlet-v]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_y\n    function = -1e-4\n  []\n  [inlet_T]\n   type = FVDirichletBC\n    variable = T\n    boundary = 'top'\n    value = 303.15\n  []\n  [no-slip-u]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_x\n    function = 0\n  []\n  [no-slip-v]\n    type = INSFVNoSlipWallBC\n    boundary = 'left'\n    variable = vel_y\n    function = 0\n  []\n\n  [symmetry-u]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'x'\n  []\n  [symmetry-v]\n    type = INSFVSymmetryVelocityBC\n    boundary = 'right'\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [outlet_u]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'x'\n    rho = ${rho}\n  []\n  [outlet_v]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'y'\n    rho = ${rho}\n  []\n  [inlet_p]\n    type = FVDirichletBC\n    variable = pressure\n    boundary = top\n    value = 50\n  []\n  [outlet_p]\n    type = FVDirichletBC\n    variable = pressure\n    boundary = bottom\n    value = 1\n  []\n[]\n\n[Materials]\n  [functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k'\n    prop_values = '${cp} ${k}'\n  []\n  [ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'T'\n    rho = ${rho}\n    block = 0\n  []\n  [solid_functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp_s k_s'\n    prop_values = '${cp_s} ${k_s}'\n  []\n  [solid_ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'Ts'\n    rho = ${rho_s}\n    block = 1\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_pc_type -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm      100                lu           NONZERO'\n  line_search = 'none'\n  nl_rel_tol = 1e-3  #7e-13\n  dt = 10\n  end_time = 1000\n[]\n\n\n[Outputs]\n  exodus = true\n[]\n\n\nCould you please give me advice regarding the pressure boundary condition for making symmetric flow?",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3647319",
                          "updatedAt": "2022-09-14T18:09:58Z",
                          "publishedAt": "2022-09-14T18:09:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Tfluid and Tsolid are flipped with T, Ts in the parameters of the interface kernel. That could be your problem\nthe system is not symmetric because you have no-slip boundary conditions on one side and symmetric on the other side.\nSince the symmetry is handled in the boundary condition, you dont see it in the domain. You could simplify your model by having no-slip everywhere",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3650476",
                          "updatedAt": "2022-09-15T05:25:02Z",
                          "publishedAt": "2022-09-15T05:25:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "JuliaHLee"
                          },
                          "bodyText": "Thank you for the advice about BC! I have managed to make symmetric flow.\nT and Ts were flipped, while I was testing all possibilities. And now I have put them back on the right positions. However, the strange contribution of the interface Kernel remains the same.. The result is below:\n\nFor the moment, I do not really have a clue, how I can fix it. Would it be a problem with BC or the Kernel itself?\nInput file\n\n# Water properties\nmu = 1.0E-3\nrho = 1000.0\nk = 0.598\ncp = 4186\n\n\n\n# Solid properties\ncp_s = 830\nrho_s = 1680\nk_s = 3.5\np_outlet = 0\n\n[Mesh]\n  [generated_mesh]\n  type = GeneratedMeshGenerator\n  dim = 2\n  nx = 40\n  ny = 40\n  xmin = 0\n  ymin = 0\n  ymax = 0.1 \n  xmax = 0.1 \n  []\n  [subdomain1]\n    input = generated_mesh\n    type = SubdomainBoundingBoxGenerator\n    block_name = subdomain1\n    bottom_left = '0.04 0.04 0'\n    block_id = 1\n    top_right = '0.06 0.06 0'\n  []\n  [sideset]\n    input = subdomain1\n    type = SideSetsBetweenSubdomainsGenerator\n    primary_block = 0\n    paired_block = 1\n    new_boundary = sideset\n  []\n[]\n\n[GlobalParams]\n  # retain behavior at time of test creation\n  two_term_boundary_expansion = false\n  rhie_chow_user_object = 'rc'\n  advected_interp_method = 'average'\n  velocity_interp_method = 'rc'\n[]\n\n[UserObjects]\n  [rc]\n    type = INSFVRhieChowInterpolator\n    u = vel_x\n    v = vel_y\n    block = 0\n    pressure = pressure\n  []\n[]\n\n[Variables]\n  [vel_x]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [vel_y]\n    type = INSFVVelocityVariable\n    block = 0\n    initial_condition = 1e-4\n  []\n  [pressure]\n    type = INSFVPressureVariable\n    block = 0\n  []\n  [T]\n    type = INSFVEnergyVariable\n    block = 0\n    initial_condition = 283.15\n  []\n  [Ts]\n    type = INSFVEnergyVariable\n    initial_condition = 283.15\n    block = 1\n  []\n[]\n\n[FVKernels]\n  [mass]\n    type = INSFVMassAdvection\n    variable = pressure\n    rho = ${rho}\n    block = 0\n  []\n  [u_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n\n  [u_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_x\n    rho = ${rho}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_x\n    mu = ${mu}\n    momentum_component = 'x'\n    block = 0\n  []\n  [u_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_x\n    momentum_component = 'x'\n    pressure = pressure\n    block = 0\n  []\n  [v_time]\n    type = INSFVMomentumTimeDerivative\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_advection]\n    type = INSFVMomentumAdvection\n    variable = vel_y\n    rho = ${rho}\n    momentum_component = 'y'\n    block = 0\n  []\n  [v_viscosity]\n    type = INSFVMomentumDiffusion\n    variable = vel_y\n    mu = ${mu}\n    momentum_component = 'y'\n  []\n  [v_pressure]\n    type = INSFVMomentumPressure\n    variable = vel_y\n    momentum_component = 'y'\n    pressure = pressure\n    block = 0\n  []\n  [energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = T\n    cp = ${cp}\n    rho = ${rho}\n    block = 0\n  []\n  [temp_conduction]\n    type = FVDiffusion\n    coeff = 'k'\n    variable = T\n    block = 0\n  []\n  [temp_advection]\n    type = INSFVEnergyAdvection\n    variable = T\n    block = 0\n  []\n  [solid_energy_time]\n    type = INSFVEnergyTimeDerivative\n    variable = Ts\n    cp = ${cp_s}\n    rho = ${rho_s}\n    block = 1\n  []\n  [solid_temp_conduction]\n    type = FVDiffusion\n    coeff = 'k_s'\n    variable = Ts\n    block = 1\n  []\n[]\n\n[FVInterfaceKernels]\n  [convection]\n    type = FVConvectionCorrelationInterface\n    variable1 = T\n    variable2 = Ts\n    boundary = sideset\n    h = 50\n    T_solid = Ts\n    T_fluid = T\n    subdomain1 = 0\n    subdomain2 = 1\n    wall_cell_is_bulk = true\n    #bulk_distance = 0.02\n  []\n[]\n\n[FVBCs]\n  [inlet-u]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_x\n    function = 0\n  []\n  [inlet-v]\n    type = INSFVInletVelocityBC\n    boundary = 'top'\n    variable = vel_y\n    function = -1e-4\n  []\n  [inlet_T]\n   type = FVDirichletBC\n    variable = T\n    boundary = 'top'\n    value = 303.15\n  []\n  [no-slip-u]\n    type = INSFVNoSlipWallBC\n    boundary = 'left right sideset'\n    variable = vel_x\n    function = 0\n  []\n  [no-slip-v]\n    type = INSFVNoSlipWallBC\n    boundary = 'left right sideset'\n    variable = vel_y\n    function = 0\n  []\n\n  [outlet_u]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_x\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'x'\n    rho = ${rho}\n  []\n  [outlet_v]\n    type = INSFVMomentumAdvectionOutflowBC\n    variable = vel_y\n    u = vel_x\n    v = vel_y\n    boundary = 'bottom'\n    momentum_component = 'y'\n    rho = ${rho}\n  []\n  [outlet_p]\n    type = INSFVOutletPressureBC\n    boundary = 'bottom'\n    variable = pressure\n    function = '${p_outlet}'\n  []\n[]\n\n[Materials]\n  [functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp k'\n    prop_values = '${cp} ${k}'\n  []\n  [ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'T'\n    rho = ${rho}\n    block = 0\n  []\n  [solid_functor_constants]\n    type = ADGenericFunctorMaterial\n    prop_names = 'cp_s k_s'\n    prop_values = '${cp_s} ${k_s}'\n  []\n  [solid_ins_fv]\n    type = INSFVEnthalpyMaterial\n    temperature = 'Ts'\n    rho = ${rho_s}\n    block = 1\n  []\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = NEWTON\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_pc_type -sub_pc_factor_shift_type'\n  petsc_options_value = 'asm      100                lu           NONZERO'\n  line_search = 'none'\n  nl_rel_tol = 1e-3  #7e-13\n  dt = 10\n  end_time = 800\n[]\n\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3655053",
                          "updatedAt": "2022-09-15T15:24:29Z",
                          "publishedAt": "2022-09-15T15:24:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@grmnptr if you have time to have a look. Looks like a bug with our convection correlation interface. It s not used much so it would not be that shocking\nIf not I ll have time next week",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3655460",
                          "updatedAt": "2022-09-15T16:05:35Z",
                          "publishedAt": "2022-09-15T16:05:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grmnptr"
                          },
                          "bodyText": "Okay, I'll check it today.",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3655843",
                          "updatedAt": "2022-09-15T16:48:03Z",
                          "publishedAt": "2022-09-15T16:48:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "grmnptr"
                          },
                          "bodyText": "Okay, the current implementation didn't take into account the face normals. Adding that fixed the problem, will add tests and push a PR today.",
                          "url": "https://github.com/idaholab/moose/discussions/22070#discussioncomment-3656322",
                          "updatedAt": "2022-09-15T17:56:52Z",
                          "publishedAt": "2022-09-15T17:51:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}