{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNC0xMFQxMTowNjowMC0wNTowMM4ATVA5"
    },
    "edges": [
      {
        "node": {
          "title": "Reference frame for stress output under finite strain?",
          "author": {
            "login": "jessecarterMOOSE"
          },
          "bodyText": "For a finite strain calculation - what reference frame are the output stress component values in (exodus file or postprocessors)? I'm curious how this compares to Abaqus, which (by default) reports stress in the reference frame it was computed in, which could be the global or an intermediate frame depending on if a specific material orientation is used. Of course Abaqus uses different kinematics (Hughes-Winget rather than Rashid) so maybe that has something to do with it. Is there a difference when AbaqusUMATStress is used? I can follow the logic in that code but not sure if the stress gets rotated elsewhere.",
          "url": "https://github.com/idaholab/moose/discussions/24040",
          "updatedAt": "2023-04-12T20:40:19Z",
          "publishedAt": "2023-04-12T14:56:07Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "If you are using Rashid (incremental) formulation in MOOSE, then the output is Cauchy stress, i.e., respect to deformed configuration and after rotation.",
                  "url": "https://github.com/idaholab/moose/discussions/24040#discussioncomment-5593919",
                  "updatedAt": "2023-04-12T15:05:02Z",
                  "publishedAt": "2023-04-12T15:05:01Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Thanks. So in terms of code, if I'm using ComputeFiniteStrainElasticStress for example, when the stress is rotated at the end of the computeQpStress, that is the stress that gets reported? Or does stress get rotated elsewhere?",
                          "url": "https://github.com/idaholab/moose/discussions/24040#discussioncomment-5594039",
                          "updatedAt": "2023-04-12T15:13:04Z",
                          "publishedAt": "2023-04-12T15:13:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Correct. The lines 85-87 in that class rotate the stress from intermediate state (without rotation) to the final rotated state. After that, stress is finalized, and then be outputted.",
                          "url": "https://github.com/idaholab/moose/discussions/24040#discussioncomment-5594207",
                          "updatedAt": "2023-04-12T15:26:46Z",
                          "publishedAt": "2023-04-12T15:26:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "If I'm reading that code correctly, the intermediate state is the previous rotated state (old total rotation)? I think that is consistent with what is being done in AbaqusUMATStress where the stress is rotated to the current configuration at the end of the method, which will be will be used to calculate stress on the next step (stress is stateful so it is stress_old). Is that consistent throughout the different stress calculators in MOOSE?\nAlso curious what it means for stress to be finalized?",
                          "url": "https://github.com/idaholab/moose/discussions/24040#discussioncomment-5594424",
                          "updatedAt": "2023-04-12T15:45:57Z",
                          "publishedAt": "2023-04-12T15:45:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "When I say \"finalized\", I just mean it won't be modified anymore.\nThe intermediate state is the \"previous rotated state + new incremental stretch\", and the rotation matrix that applies to the intermediate state is the incremental rotation. I believe this is consistent through all. Are you using plasticity, and damage? If so, maybe you want to check the code ComputeFiniteStrainElasticStress.",
                          "url": "https://github.com/idaholab/moose/discussions/24040#discussioncomment-5594576",
                          "updatedAt": "2023-04-12T15:58:38Z",
                          "publishedAt": "2023-04-12T15:58:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "Are you using plasticity, and damage? If so, maybe you want to check the code ComputeFiniteStrainElasticStress.\n\nEventually, but just trying to start simple. Did you mean a different class to check out?",
                          "url": "https://github.com/idaholab/moose/discussions/24040#discussioncomment-5594661",
                          "updatedAt": "2023-04-12T16:07:41Z",
                          "publishedAt": "2023-04-12T16:07:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "My bad. ComputeMultipleInelasticStress",
                          "url": "https://github.com/idaholab/moose/discussions/24040#discussioncomment-5594811",
                          "updatedAt": "2023-04-12T16:18:01Z",
                          "publishedAt": "2023-04-12T16:18:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "And is it this stress value that gets used in the stress divergence calculation or is it rotated along the way?",
                          "url": "https://github.com/idaholab/moose/discussions/24040#discussioncomment-5595283",
                          "updatedAt": "2023-04-12T16:58:59Z",
                          "publishedAt": "2023-04-12T16:58:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Correct, this is the stress that is used in the stress divergence calculation, to compute residual and Jacobian for a new nonlinear iteration. After solving the nonlinear step, you will get new displacements/strain, and then repeat the same thing to update stress. It will repeat until nonlinear iteration converges.",
                          "url": "https://github.com/idaholab/moose/discussions/24040#discussioncomment-5595402",
                          "updatedAt": "2023-04-12T17:11:11Z",
                          "publishedAt": "2023-04-12T17:11:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jessecarterMOOSE"
                          },
                          "bodyText": "When should the use_finite_deform_jacobian parameter be set? Doesn't look like it gets set by the Tensor Mechanics Master Action when doing finite strain. I think it's doing a stress rotation in that case.",
                          "url": "https://github.com/idaholab/moose/discussions/24040#discussioncomment-5595683",
                          "updatedAt": "2023-04-12T17:41:41Z",
                          "publishedAt": "2023-04-12T17:41:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "use_finite_deform_jacobian is used to improve the Jacobian calculation by adding a few chain rule derivatives. The improvement is very limited, so it is not included in the action. It should not affect the results anyway. If you are using AD, you definitely do not need this option on.",
                          "url": "https://github.com/idaholab/moose/discussions/24040#discussioncomment-5595959",
                          "updatedAt": "2023-04-12T18:12:49Z",
                          "publishedAt": "2023-04-12T18:12:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Developing a new ConjugateHeatTransfer kernel with ability of calculating the thickness of corrosion layer",
          "author": {
            "login": "js-jixu"
          },
          "bodyText": "Hi, MOOSE developers. I want to develop a new InterfaceKernel which is capable of calculating conjugate heat transfer between solid and liquid.\nUnlike the original ConjugateHeatTransfer InterfaceKernel in MOOSE, the new InterfaceKernel needs to calculate the thickness of the corrosion layer at the solid-liquid interface in advance. And then use 1/h* = 1/h + \u03b4/k_corrosion to calculate the new convective heat transfer coefficient h* . Finally, h* is applied to conjugate heat transfer calculation.\nI want to study the corrosion of steel by liquid lead-bismuth eutectic (LBE). The corrosion layer often has two layers, Fe3O4 and spinel. After long-term corrosion, Fe3O4 will be washed away, leaving only spinel. The growth of spinel is not only related to the presence or absence of Fe3O4 on the outside, but also to the thickness of spinel when Fe3O4 is washed away. The thickness of corrosion layer is related to factors such as oxygen concentration(Co), time, fluid temperature, etc. I have a flow chart to show the calculation progress:\n\nThen I write a source file and header file based on the original ConjugateHeatTransfer. Here are source file and header file:\n#include \"CorrosionHeatTransfer.h\"\n\n#include \"metaphysicl/raw_type.h\"\n\nusing MetaPhysicL::raw_value;\n\nregisterMooseObject(\"HeatConductionApp\", CorrosionHeatTransfer);\n\nInputParameters\nCorrosionHeatTransfer::validParams()\n{\n  InputParameters params = InterfaceKernel::validParams();\n  params.addRequiredParam<MaterialPropertyName>(\"rho_Fe3O4\", \"Density of Fe3O4 layer\");\n  params.addRequiredParam<MaterialPropertyName>(\"rho_Spinel\", \"Density of spinel layer\");\n  params.addRequiredParam<MaterialPropertyName>(\"rho_LBE\", \"Density of LBE\");\n  params.addRequiredParam<MaterialPropertyName>(\"rho_Steel\", \"Density of Steel\");\n  params.addRequiredParam<MaterialPropertyName>(\"k_Fe3O4\", \"Thermal conductivity of Fe3O4 layer\");\n  params.addRequiredParam<MaterialPropertyName>(\"k_Spinel\", \"Thermal conductivity of spinel layer\");\n  params.addRequiredParam<MaterialPropertyName>(\"Re\", \"Reynolds number of LBE\");\n  params.addRequiredParam<MaterialPropertyName>(\"Sc\", \"Schmidt number of LBE\");\n  params.addRequiredParam<MaterialPropertyName>(\"Tb\", \"Main stream temperature of LBE\");\n  params.addRequiredParam<MaterialPropertyName>(\"htc\", \"Heat transfer coefficient of LBE and steel pipe\");\n\n  params.addRequiredParam<Real>(\"time\", \"Time of corrosion, s\");\n  params.addRequiredParam<Real>(\"Co\", \"Oxygen concentration, ppm\");\n  params.addRequiredParam<Real>(\"d\", \"Diameter of steel pipe\");\n  params.addRequiredParam<Real>(\"L\", \"Length of steel pipe\");\n  params.addParam<Real>(\"F_Fe_Fe3O4\", 0.72, \"Mass fraction of Fe in Fe3O4\");\n  params.addParam<Real>(\"F_Fe_Spinel\", 0.591, \"Mass fraction of Fe in spinel\");\n  params.addParam<Real>(\"F_Fe_Steel\", 0.9, \"Mass fraction of Fe in steel\");\n  params.addParam<Real>(\"R_PB\", 2.1, \"Pilling-Bedworth ratio\");\n  params.addParam<Real>(\"kp0\", 2.096e-5, \"Model constant for calculating oxidation constant kp, m2/s\");\n  params.addParam<Real>(\"n\", 0.27, \"Exponential factor for calculating oxidation constant kp\");\n  params.addParam<Real>(\"Q_bar\", -157802.0, \"Activation energy Q' for calculating oxidation constant kp, J/mol\");\n  params.addParam<Real>(\"R\", 8.314, \"Gas constant for calculating oxidation constant kp, J/(mol*K)\");\n  params.addParam<Real>(\"A\", 11.217, \"Constant used to calculate the solubility of Fe in steel under LBE environment\");\n  params.addParam<Real>(\"B\", -13967.2, \"Constant used to calculate the solubility of Fe in steel under LBE environment\");\n\n  params.addRequiredCoupledVar(\"T_fluid\",\n                               \"The fluid temperature. It is not always identical to neighbor_var, \"\n                               \"e.g. when the fluid heat equation is solved for internal energy\");\n  params.addRequiredCoupledVar(\"delta_Fe3O4\", \"The thickness of Fe3O4\");\n  params.addRequiredCoupledVar(\"delta_Spinel\", \"The thickness of Spinel\");\n  params.addRequiredCoupledVar(\"htc_asterisk\", \"Heat transfer coefficient with corrosion thermal resistance\");\n\n  params.addRequiredParam<PostprocessorName>(\"delta_T\",\n                                             \"Loop temperature difference. \"\n                                             \"The postprocessor used to calculate the mass transfer rate Rm at the LBE/oxide interface\");\n  params.addRequiredParam<PostprocessorName>(\"T_max\",\n                                             \"Loop maximum temperature. \"\n                                             \"The postprocessor used to calculate the mass transfer rate Rm at the LBE/oxide interface\");\n\n  params.addClassDescription(\n      \"This class simulates the fluid-solid conjugate heat transfer containing \"\n      \"the oxidation-corrosion model of LBE and steel.\"\n      \"We firstly calculate the thickness of Fe3O4 and spinel based on physical properties, \"\n      \"and then integrate the thermal resistance of corrosion products into the equivalent heat transfer coefficient.\"\n      \"It should be noted that when corrosion products are generated, \"\n      \"the shell will also become thinner, which is represented by the Pilling-Bedworth ratio.\");\n\n  return params;\n}\n\nCorrosionHeatTransfer::CorrosionHeatTransfer(const InputParameters &parameters)\n    : InterfaceKernel(parameters),\n      _rho_Fe3O4(getADMaterialProperty<Real>(\"rho_Fe3O4\")),\n      _rho_Spinel(getADMaterialProperty<Real>(\"rho_Spinel\")),\n      _rho_LBE(getADMaterialProperty<Real>(\"rho_LBE\")),\n      _rho_Steel(getADMaterialProperty<Real>(\"rho_Steel\")),\n      _k_Fe3O4(getADMaterialProperty<Real>(\"k_Fe3O4\")),\n      _k_Spinel(getADMaterialProperty<Real>(\"k_Spinel\")),\n      _Re(getADMaterialProperty<Real>(\"Re\")),\n      _Sc(getADMaterialProperty<Real>(\"Sc\")),\n      _Tb(getADMaterialProperty<Real>(\"Tb\")),\n      _htc(getADMaterialProperty<Real>(\"htc\")),\n\n      _time(getParam<Real>(\"time\")),\n      _Co(getParam<Real>(\"Co\")),\n      _d(getParam<Real>(\"d\")),\n      _L(getParam<Real>(\"L\")),\n      _F_Fe_Fe3O4(getParam<Real>(\"F_Fe_Fe3O4\")),\n      _F_Fe_Spinel(getParam<Real>(\"F_Fe_Spinel\")),\n      _F_Fe_Steel(getParam<Real>(\"F_Fe_Steel\")),\n      _R_PB(getParam<Real>(\"R_PB\")),\n      _kp0(getParam<Real>(\"kp0\")),\n      _n(getParam<Real>(\"n\")),\n      _Q_bar(getParam<Real>(\"Q_bar\")),\n      _R(getParam<Real>(\"R\")),\n      _A(getParam<Real>(\"A\")),\n      _B(getParam<Real>(\"B\")),\n\n      _T_fluid(coupledValue(\"T_fluid\")),\n      _delta_Fe3O4(coupledValue(\"delta_Fe3O4\")),\n      _delta_Spinel(coupledValue(\"delta_Spinel\")),\n      _htc_asterisk(coupledValue(\"htc_asterisk\")),\n\n      _delta_T(getPostprocessorValue(\"delta_T\")),\n      _T_max(getPostprocessorValue(\"T_max\")),\n\n      _apply_element_jacobian(_var.name() == getParam<std::vector<VariableName>>(\"T_fluid\")[0])\n{\n  Real r1 = 0;\n  r1 = (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) / (_rho_Fe3O4[_qp] * _F_Fe_Fe3O4);\n  Real r2 = 0;\n  r2 = (_rho_Steel[_qp] * _F_Fe_Steel) / (_rho_Spinel[_qp] * _F_Fe_Spinel);\n  Real r3 = 0;\n  r3 = _rho_LBE[_qp] / (_rho_Spinel[_qp] * _F_Fe_Spinel);\n  Real r4 = 0;\n  r4 = _rho_LBE[_qp] / (_rho_Spinel[_qp] * _F_Fe_Fe3O4);\n  Real kp = 0;\n  kp = _kp0 * pow(_Co, _n) * exp(_Q_bar / (_R * _T_fluid[_qp]));\n  Real D_Fe = 0;\n  D_Fe = 3.97e-7 * exp(-44100 / (_R * _T_fluid[_qp]));\n  Real c_Fe_s = 0;\n  c_Fe_s = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _T_fluid[_qp]);\n  Real c_Fe_b = 0;\n  c_Fe_b = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _Tb[_qp]);\n  Real Rm = 0;\n  Rm = 0.53 * pow(_Re[_qp], 0.6) * pow(_Sc[_qp], 0.5) * pow(_d / _L, 1 / 3) * pow(_delta_T[_qp] / _T_max[_qp], 1 / 3) * (D_Fe / _d) * (c_Fe_s - c_Fe_b);\n  Real R_Fe3O4 = 0;\n  R_Fe3O4 = r4 * Rm;\n  Real t0 = 0;\n  t0 = pow(r1, 2) * kp / (4 * pow(R_Fe3O4, 2));\n  Real delta_spinel_c = 0;\n  delta_spinel_c = (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) * kp / (8 * _rho_LBE[_qp] * Rm);\n  Real delta_spinel_0 = 0;\n  delta_spinel_0 = 0.5 * pow(kp * _time, 0.5);\n\n  if (_time >= t0)\n  {\n    _delta_Fe3O4[_qp] = 0;\n    if (delta_spinel_0 >= delta_spinel_c)\n    {\n      double a = r2 * kp / 8;\n      double b = r3 * Rm;\n      double f(double x)\n      {\n        return delta_spinel_0 - (a / b) * log((a - b * x) / (a - b * delta_spinel_0)) - b * (_time - t0);\n      }\n      double x = 1e-4;\n      double tolerance = 1e-7;\n      int max_iter = 100;\n      for (int i = 0; i < max_iter; i++)\n      {\n        double y = f(x);\n        if (abs(y - x) < tolerance)\n        {\n          break;\n        }\n        x = y;\n      }\n      _delta_Spinel[_qp] = x;\n    }\n    else\n    {\n      _delta_Spinel[_qp] = delta_spinel_0 + (_time - t0) * (_rho_LBE[_qp] * Rm) / (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel);\n    }\n  }\n  else\n  {\n    _delta_Spinel[_qp] = delta_spinel_0;\n    _delta_Fe3O4[_qp] = r1 * _delta_Spinel[_qp] - r4 * Rm * _time;\n  }\n  _htc_asterisk[_qp] = 1/(1/_htc[_qp] + _delta_Fe3O4[_qp] / _k_Fe3O4[_qp] + _delta_Spinel[_qp] / _k_Spinel[_qp]);\n  return 0;\n}\n\nReal\nCorrosionHeatTransfer::computeQpResidual(Moose::DGResidualType type)\n{\n  switch (type)\n  {\n    case Moose::Element:\n      return raw_value(_htc_asterisk[_qp]) * (_T_fluid[_qp] - _neighbor_value[_qp]) * _test[_i][_qp];\n\n    case Moose::Neighbor:\n      return raw_value(_htc_asterisk[_qp]) * (_neighbor_value[_qp] - _T_fluid[_qp]) * _test_neighbor[_i][_qp];\n\n    default:\n      return 0.0;\n  }\n}\n\nReal\nCorrosionHeatTransfer::computeQpJacobian(Moose::DGJacobianType type)\n{\n  switch (type)\n  {\n    case Moose::ElementElement:\n      return _apply_element_jacobian ? raw_value(_htc_asterisk[_qp]) * _phi[_j][_qp] * _test[_i][_qp] : 0;\n\n    case Moose::NeighborNeighbor:\n      return raw_value(_htc_asterisk[_qp]) * _phi_neighbor[_j][_qp] * _test_neighbor[_i][_qp];\n\n    case Moose::NeighborElement:\n      return _apply_element_jacobian ? raw_value(_htc_asterisk[_qp]) * -_phi[_j][_qp] * _test_neighbor[_i][_qp]\n                                     : 0;\n\n    case Moose::ElementNeighbor:\n      return raw_value(_htc_asterisk[_qp]) * -_phi_neighbor[_j][_qp] * _test[_i][_qp];\n\n    default:\n      return 0.0;\n  }\n}\n\n#include \"InterfaceKernel.h\"\n\n/**\n * CorrosionHeatTransfer is an InterfaceKernel \n * used to calculate the deterioration of heat transfer caused by \n * LBE corrosion on stainless steel. \n * \n * Firstly we use corrosion model to \n * calculate the thickness of magnitude and spinel layers.\n * \n * Secondly we integrate the thermal resistance of oxide layers into\n * heat transfer coefficient.\n */\nclass CorrosionHeatTransfer : public InterfaceKernel\n{\npublic:\n  static InputParameters validParams();\n\n  CorrosionHeatTransfer(const InputParameters & parameters);\n\nprotected:\n  virtual Real computeQpResidual(Moose::DGResidualType type) override;\n  virtual Real computeQpJacobian(Moose::DGJacobianType type) override;\n\n  const ADMaterialProperty<Real> & _rho_Fe3O4;\n  const ADMaterialProperty<Real> & _rho_Spinel;\n  const ADMaterialProperty<Real> & _rho_LBE;\n  const ADMaterialProperty<Real> & _rho_Steel;\n  const ADMaterialProperty<Real> & _k_Fe3O4;\n  const ADMaterialProperty<Real> & _k_Spinel;\n  const ADMaterialProperty<Real> & _Re;\n  const ADMaterialProperty<Real> & _Sc;\n  const ADMaterialProperty<Real> & _Tb;\n  const ADMaterialProperty<Real> & _htc;\n\n  const Real _time;\n  const Real _Co;\n  const Real _d;\n  const Real _L;\n  const Real _F_Fe_Fe3O4;\n  const Real _F_Fe_Spinel;\n  const Real _F_Fe_Steel;\n  const Real _R_PB;\n  const Real _kp0;\n  const Real _n;\n  const Real _Q_bar;\n  const Real _R;\n  const Real _A;\n  const Real _B;\n\n  const VariableValue & _T_fluid;\n  const VariableValue & _delta_Fe3O4;\n  const VariableValue & _delta_Spinel;\n  const VariableValue & _htc_asterisk;\n\n  const PostprocessorValue & _delta_T;\n  const PostprocessorValue & _T_max;\n\n  /// Element Jacobian is only applied if variable = T_fluid\n  const bool _apply_element_jacobian;\n};\n\nWhen I compile it, it reports lots of errors:\nCreating Unity /home/jixu/projects/moltres/moose/modules/heat_conduction/build/unity_src/interfacekernels_Unity.C\nCompiling C++ (in opt mode) /home/jixu/projects/moltres/moose/modules/heat_conduction/build/unity_src/interfacekernels_Unity.C...\nIn file included from /home/jixu/projects/moltres/moose/modules/heat_conduction/build/unity_src/interfacekernels_Unity.C:3:\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C: In constructor 'CorrosionHeatTransfer::CorrosionHeatTransfer(const InputParameters&)':\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:103:74: error: cannot convert 'MetaPhysicL::DividesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, false, void>::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>'} to 'libMesh::Real' {aka 'double'} in assignment\n  103 | Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) / (_rho_Fe3O4[_qp] * _F_Fe_Fe3O4);\n      | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                                             |\n      |                                                             MetaPhysicL::DividesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, false, void>::supertype {aka MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>}\n\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:105:40: error: cannot convert 'MetaPhysicL::DividesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, false, void>::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>'} to 'libMesh::Real' {aka 'double'} in assignment\n  105 |   r2 = (_rho_Steel[_qp] * _F_Fe_Steel) / (_rho_Spinel[_qp] * _F_Fe_Spinel);\n      |        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                        |\n      |                                        MetaPhysicL::DividesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, false, void>::supertype {aka MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>}\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:107:22: error: cannot convert 'MetaPhysicL::DividesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, false, void>::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>'} to 'libMesh::Real' {aka 'double'} in assignment\n  107 |   r3 = _rho_LBE[_qp] / (_rho_Spinel[_qp] * _F_Fe_Spinel);\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:109:22: error: cannot convert 'MetaPhysicL::DividesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, false, void>::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>'} to 'libMesh::Real' {aka 'double'} in assignment\n  109 |   r4 = _rho_LBE[_qp] / (_rho_Spinel[_qp] * _F_Fe_Fe3O4);\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:117:38: error: cannot convert 'MetaPhysicL::MultipliesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, double, true, void>::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>'} to 'libMesh::Real' {aka 'double'} in assignment\n  117 |   c_Fe_b = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _Tb[_qp]);\n      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~\n      |                                      |\n      |                                      MetaPhysicL::MultipliesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, double, true, void>::supertype {aka MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>}\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:119:91: error: invalid types 'const PostprocessorValue {aka const double}[unsigned int]' for array subscript\n  119 | 6) * pow(_Sc[_qp], 0.5) * pow(_d / _L, 1 / 3) * pow(_delta_T[_qp] / _T_max[_qp], 1 / 3) * (D_Fe / _d) * (c_Fe_s - c_Fe_b);\n      |                                                             ^\n\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:119:105: error: invalid types 'const PostprocessorValue {aka const double}[unsigned int]' for array subscript\n  119 | qp], 0.5) * pow(_d / _L, 1 / 3) * pow(_delta_T[_qp] / _T_max[_qp], 1 / 3) * (D_Fe / _d) * (c_Fe_s - c_Fe_b);\n      |                                                             ^\n\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:125:91: error: cannot convert 'MetaPhysicL::DividesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, false, void>::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>'} to 'libMesh::Real' {aka 'double'} in assignment\n  125 | [_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) * kp / (8 * _rho_LBE[_qp] * Rm);\n      | ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~\n      |                                                             |\n      |                                                             MetaPhysicL::DividesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, false, void>::supertype {aka MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>}\n\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:131:23: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_delta_Fe3O4)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  131 |     _delta_Fe3O4[_qp] = 0;\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:137:7: error: a function-definition is not allowed here before '{' token\n  137 |       {\n      |       ^\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:145:20: error: 'f' was not declared in this scope\n  145 |         double y = f(x);\n      |                    ^\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:152:26: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_delta_Spinel)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  152 |       _delta_Spinel[_qp] = x;\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:134:14: warning: unused variable 'a' [-Wunused-variable]\n  134 |       double a = r2 * kp / 8;\n      |              ^\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:135:14: warning: unused variable 'b' [-Wunused-variable]\n  135 |       double b = r3 * Rm;\n      |              ^\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:156:26: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_delta_Spinel)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  156 |       _delta_Spinel[_qp] = delta_spinel_0 + (_time - t0) * (_rho_LBE[_qp] * Rm) / (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel);\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:161:24: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_delta_Spinel)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  161 |     _delta_Spinel[_qp] = delta_spinel_0;\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:162:23: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_delta_Fe3O4)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  162 |     _delta_Fe3O4[_qp] = r1 * _delta_Spinel[_qp] - r4 * Rm * _time;\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:164:22: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_htc_asterisk)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  164 |   _htc_asterisk[_qp] = 1/(1/_htc[_qp] + _delta_Fe3O4[_qp] / _k_Fe3O4[_qp] + _delta_Spinel[_qp] / _k_Spinel[_qp]);\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:165:10: error: returning a value from a constructor\n  165 |   return 0;\n      |          ^\nmake: *** [/home/jixu/projects/moltres/moose/framework/build.mk:145: /home/jixu/projects/moltres/moose/modules/heat_conduction/build/unity_src/interfacekernels_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1\n\nThe most common error is error: cannot convert 'MetaPhysicL::DividesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, false, void>::supertype' {aka 'MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>'} to 'libMesh::Real' {aka 'double'} in assignment and MetaPhysicL::DividesType<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>, false, void>::supertype {aka MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<200> >, true>}.\nDo you have any solutions for these errors\uff1f",
          "url": "https://github.com/idaholab/moose/discussions/23956",
          "updatedAt": "2023-04-16T07:02:52Z",
          "publishedAt": "2023-04-04T11:58:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat's happening is that you have a whole bunch of implicit conversions from ADReal quantities (that carry derivatives) to Real (just a number).\nThis is not allowed and usually undesirable, as anything using AD downstream will miss out on the derivatives.\nJust convert all these intermediate variables into ADReal\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5520404",
                  "updatedAt": "2023-04-04T12:33:11Z",
                  "publishedAt": "2023-04-04T12:15:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "I convert all intermediate variables into ADReal and I have modified these parts:\n  ADReal r1 = (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) / (_rho_Fe3O4[_qp] * _F_Fe_Fe3O4);\n  ADReal r2 = (_rho_Steel[_qp] * _F_Fe_Steel) / (_rho_Spinel[_qp] * _F_Fe_Spinel);\n  ADReal r3 = _rho_LBE[_qp] / (_rho_Spinel[_qp] * _F_Fe_Spinel);\n  ADReal r4 = _rho_LBE[_qp] / (_rho_Spinel[_qp] * _F_Fe_Fe3O4);\n  ADReal kp = _kp0 * pow(_Co, _n) * exp(_Q_bar / (_R * _T_fluid[_qp]));\n  ADReal D_Fe = 3.97e-7 * exp(-44100 / (_R * _T_fluid[_qp]));\n  ADReal c_Fe_s = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _T_fluid[_qp]);\n  ADReal c_Fe_b = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _Tb[_qp]);\n  ADReal Rm = 0.53 * pow(_Re[_qp], 0.6) * pow(_Sc[_qp], 0.5) * pow(_d / _L, 1 / 3) * pow(_delta_T[_qp] / _T_max[_qp], 1 / 3) * (D_Fe / _d) * (c_Fe_s - c_Fe_b);\n  ADReal R_Fe3O4 = r4 * Rm;\n  ADReal t0 = pow(r1, 2) * kp / (4 * pow(R_Fe3O4, 2));\n  ADReal delta_spinel_c = (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) * kp / (8 * _rho_LBE[_qp] * Rm);\n  ADReal delta_spinel_0 = 0.5 * pow(kp * _time, 0.5);\n\nMany previous errors have been successfully resolved. Sadly there are also many errors:\nCreating Unity /home/jixu/projects/moltres/moose/modules/heat_conduction/build/unity_src/interfacekernels_Unity.C\nCompiling C++ (in opt mode) /home/jixu/projects/moltres/moose/modules/heat_conduction/build/unity_src/interfacekernels_Unity.C...\nIn file included from /home/jixu/projects/moltres/moose/modules/heat_conduction/build/unity_src/interfacekernels_Unity.C:3:\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C: In constructor 'CorrosionHeatTransfer::CorrosionHeatTransfer(const InputParameters&)':\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:110:98: error: invalid types 'const PostprocessorValue {aka const double}[unsigned int]' for array subscript\n  110 |   ADReal Rm = 0.53 * pow(_Re[_qp], 0.6) * pow(_Sc[_qp], 0.5) * pow(_d / _L, 1 / 3) * pow(_delta_T[_qp] / _T_max[_qp], 1 / 3) * (D_Fe / _d) * (c_Fe_s - c_Fe_b);\n      |                                                                                                  ^\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:110:112: error: invalid types 'const PostprocessorValue {aka const double}[unsigned int]' for array subscript\n  110 |   ADReal Rm = 0.53 * pow(_Re[_qp], 0.6) * pow(_Sc[_qp], 0.5) * pow(_d / _L, 1 / 3) * pow(_delta_T[_qp] / _T_max[_qp], 1 / 3) * (D_Fe / _d) * (c_Fe_s - c_Fe_b);\n      |                                                                                                                ^\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:118:23: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_delta_Fe3O4)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  118 |     _delta_Fe3O4[_qp] = 0;\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:124:7: error: a function-definition is not allowed here before '{' token\n  124 |       {\n      |       ^\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:132:20: error: 'f' was not declared in this scope\n  132 |         double y = f(x);\n      |                    ^\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:139:26: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_delta_Spinel)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  139 |       _delta_Spinel[_qp] = x;\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:143:26: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_delta_Spinel)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  143 |       _delta_Spinel[_qp] = delta_spinel_0 + (_time - t0) * (_rho_LBE[_qp] * Rm) / (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel);\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:148:24: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_delta_Spinel)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  148 |     _delta_Spinel[_qp] = delta_spinel_0;\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:149:23: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_delta_Fe3O4)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  149 |     _delta_Fe3O4[_qp] = r1 * _delta_Spinel[_qp] - r4 * Rm * _time;\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:151:22: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_htc_asterisk)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  151 |   _htc_asterisk[_qp] = 1/(1/_htc[_qp] + _delta_Fe3O4[_qp] / _k_Fe3O4[_qp] + _delta_Spinel[_qp] / _k_Spinel[_qp]);\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:152:10: error: returning a value from a constructor\n  152 |   return 0;\n      |          ^\nmake: *** [/home/jixu/projects/moltres/moose/framework/build.mk:145: /home/jixu/projects/moltres/moose/modules/heat_conduction/build/unity_src/interfacekernels_Unity.x86_64-conda-linux-gnu.opt.lo] Error 1\n\nThe full code of source file is:\n#include \"CorrosionHeatTransfer.h\"\n\n#include \"metaphysicl/raw_type.h\"\n\nusing MetaPhysicL::raw_value;\n\nregisterMooseObject(\"HeatConductionApp\", CorrosionHeatTransfer);\n\nInputParameters\nCorrosionHeatTransfer::validParams()\n{\n  InputParameters params = InterfaceKernel::validParams();\n  params.addRequiredParam<MaterialPropertyName>(\"rho_Fe3O4\", \"Density of Fe3O4 layer\");\n  params.addRequiredParam<MaterialPropertyName>(\"rho_Spinel\", \"Density of spinel layer\");\n  params.addRequiredParam<MaterialPropertyName>(\"rho_LBE\", \"Density of LBE\");\n  params.addRequiredParam<MaterialPropertyName>(\"rho_Steel\", \"Density of Steel\");\n  params.addRequiredParam<MaterialPropertyName>(\"k_Fe3O4\", \"Thermal conductivity of Fe3O4 layer\");\n  params.addRequiredParam<MaterialPropertyName>(\"k_Spinel\", \"Thermal conductivity of spinel layer\");\n  params.addRequiredParam<MaterialPropertyName>(\"Re\", \"Reynolds number of LBE\");\n  params.addRequiredParam<MaterialPropertyName>(\"Sc\", \"Schmidt number of LBE\");\n  params.addRequiredParam<MaterialPropertyName>(\"Tb\", \"Main stream temperature of LBE\");\n  params.addRequiredParam<MaterialPropertyName>(\"htc\", \"Heat transfer coefficient of LBE and steel pipe\");\n\n  params.addRequiredParam<Real>(\"time\", \"Time of corrosion, s\");\n  params.addRequiredParam<Real>(\"Co\", \"Oxygen concentration, ppm\");\n  params.addRequiredParam<Real>(\"d\", \"Diameter of steel pipe\");\n  params.addRequiredParam<Real>(\"L\", \"Length of steel pipe\");\n  params.addParam<Real>(\"F_Fe_Fe3O4\", 0.72, \"Mass fraction of Fe in Fe3O4\");\n  params.addParam<Real>(\"F_Fe_Spinel\", 0.591, \"Mass fraction of Fe in spinel\");\n  params.addParam<Real>(\"F_Fe_Steel\", 0.9, \"Mass fraction of Fe in steel\");\n  params.addParam<Real>(\"R_PB\", 2.1, \"Pilling-Bedworth ratio\");\n  params.addParam<Real>(\"kp0\", 2.096e-5, \"Model constant for calculating oxidation constant kp, m2/s\");\n  params.addParam<Real>(\"n\", 0.27, \"Exponential factor for calculating oxidation constant kp\");\n  params.addParam<Real>(\"Q_bar\", -157802.0, \"Activation energy Q' for calculating oxidation constant kp, J/mol\");\n  params.addParam<Real>(\"R\", 8.314, \"Gas constant for calculating oxidation constant kp, J/(mol*K)\");\n  params.addParam<Real>(\"A\", 11.217, \"Constant used to calculate the solubility of Fe in steel under LBE environment\");\n  params.addParam<Real>(\"B\", -13967.2, \"Constant used to calculate the solubility of Fe in steel under LBE environment\");\n\n  params.addRequiredCoupledVar(\"T_fluid\",\n                               \"The fluid temperature. It is not always identical to neighbor_var, \"\n                               \"e.g. when the fluid heat equation is solved for internal energy\");\n  params.addRequiredCoupledVar(\"delta_Fe3O4\", \"The thickness of Fe3O4\");\n  params.addRequiredCoupledVar(\"delta_Spinel\", \"The thickness of Spinel\");\n  params.addRequiredCoupledVar(\"htc_asterisk\", \"Heat transfer coefficient with corrosion thermal resistance\");\n\n  params.addRequiredParam<PostprocessorName>(\"delta_T\",\n                                             \"Loop temperature difference. \"\n                                             \"The postprocessor used to calculate the mass transfer rate Rm at the LBE/oxide interface\");\n  params.addRequiredParam<PostprocessorName>(\"T_max\",\n                                             \"Loop maximum temperature. \"\n                                             \"The postprocessor used to calculate the mass transfer rate Rm at the LBE/oxide interface\");\n\n  params.addClassDescription(\n      \"This class simulates the fluid-solid conjugate heat transfer containing \"\n      \"the oxidation-corrosion model of LBE and steel.\"\n      \"We firstly calculate the thickness of Fe3O4 and spinel based on physical properties, \"\n      \"and then integrate the thermal resistance of corrosion products into the equivalent heat transfer coefficient.\"\n      \"It should be noted that when corrosion products are generated, \"\n      \"the shell will also become thinner, which is represented by the Pilling-Bedworth ratio.\");\n\n  return params;\n}\n\nCorrosionHeatTransfer::CorrosionHeatTransfer(const InputParameters &parameters)\n    : InterfaceKernel(parameters),\n      _rho_Fe3O4(getADMaterialProperty<Real>(\"rho_Fe3O4\")),\n      _rho_Spinel(getADMaterialProperty<Real>(\"rho_Spinel\")),\n      _rho_LBE(getADMaterialProperty<Real>(\"rho_LBE\")),\n      _rho_Steel(getADMaterialProperty<Real>(\"rho_Steel\")),\n      _k_Fe3O4(getADMaterialProperty<Real>(\"k_Fe3O4\")),\n      _k_Spinel(getADMaterialProperty<Real>(\"k_Spinel\")),\n      _Re(getADMaterialProperty<Real>(\"Re\")),\n      _Sc(getADMaterialProperty<Real>(\"Sc\")),\n      _Tb(getADMaterialProperty<Real>(\"Tb\")),\n      _htc(getADMaterialProperty<Real>(\"htc\")),\n\n      _time(getParam<Real>(\"time\")),\n      _Co(getParam<Real>(\"Co\")),\n      _d(getParam<Real>(\"d\")),\n      _L(getParam<Real>(\"L\")),\n      _F_Fe_Fe3O4(getParam<Real>(\"F_Fe_Fe3O4\")),\n      _F_Fe_Spinel(getParam<Real>(\"F_Fe_Spinel\")),\n      _F_Fe_Steel(getParam<Real>(\"F_Fe_Steel\")),\n      _R_PB(getParam<Real>(\"R_PB\")),\n      _kp0(getParam<Real>(\"kp0\")),\n      _n(getParam<Real>(\"n\")),\n      _Q_bar(getParam<Real>(\"Q_bar\")),\n      _R(getParam<Real>(\"R\")),\n      _A(getParam<Real>(\"A\")),\n      _B(getParam<Real>(\"B\")),\n\n      _T_fluid(coupledValue(\"T_fluid\")),\n      _delta_Fe3O4(coupledValue(\"delta_Fe3O4\")),\n      _delta_Spinel(coupledValue(\"delta_Spinel\")),\n      _htc_asterisk(coupledValue(\"htc_asterisk\")),\n\n      _delta_T(getPostprocessorValue(\"delta_T\")),\n      _T_max(getPostprocessorValue(\"T_max\")),\n\n      _apply_element_jacobian(_var.name() == getParam<std::vector<VariableName>>(\"T_fluid\")[0])\n{\n  ADReal r1 = (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) / (_rho_Fe3O4[_qp] * _F_Fe_Fe3O4);\n  ADReal r2 = (_rho_Steel[_qp] * _F_Fe_Steel) / (_rho_Spinel[_qp] * _F_Fe_Spinel);\n  ADReal r3 = _rho_LBE[_qp] / (_rho_Spinel[_qp] * _F_Fe_Spinel);\n  ADReal r4 = _rho_LBE[_qp] / (_rho_Spinel[_qp] * _F_Fe_Fe3O4);\n  ADReal kp = _kp0 * pow(_Co, _n) * exp(_Q_bar / (_R * _T_fluid[_qp]));\n  ADReal D_Fe = 3.97e-7 * exp(-44100 / (_R * _T_fluid[_qp]));\n  ADReal c_Fe_s = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _T_fluid[_qp]);\n  ADReal c_Fe_b = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _Tb[_qp]);\n  ADReal Rm = 0.53 * pow(_Re[_qp], 0.6) * pow(_Sc[_qp], 0.5) * pow(_d / _L, 1 / 3) * pow(_delta_T[_qp] / _T_max[_qp], 1 / 3) * (D_Fe / _d) * (c_Fe_s - c_Fe_b);\n  ADReal R_Fe3O4 = r4 * Rm;\n  ADReal t0 = pow(r1, 2) * kp / (4 * pow(R_Fe3O4, 2));\n  ADReal delta_spinel_c = (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) * kp / (8 * _rho_LBE[_qp] * Rm);\n  ADReal delta_spinel_0 = 0.5 * pow(kp * _time, 0.5);\n\n  if (_time >= t0)\n  {\n    _delta_Fe3O4[_qp] = 0;\n    if (delta_spinel_0 >= delta_spinel_c)\n    {\n      ADReal a = r2 * kp / 8;\n      ADReal b = r3 * Rm;\n      double f(double x)\n      {\n        return delta_spinel_0 - (a / b) * log((a - b * x) / (a - b * delta_spinel_0)) - b * (_time - t0);\n      }\n      double x = 1e-4;\n      double tolerance = 1e-7;\n      int max_iter = 100;\n      for (int i = 0; i < max_iter; i++)\n      {\n        double y = f(x);\n        if (abs(y - x) < tolerance)\n        {\n          break;\n        }\n        x = y;\n      }\n      _delta_Spinel[_qp] = x;\n    }\n    else\n    {\n      _delta_Spinel[_qp] = delta_spinel_0 + (_time - t0) * (_rho_LBE[_qp] * Rm) / (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel);\n    }\n  }\n  else\n  {\n    _delta_Spinel[_qp] = delta_spinel_0;\n    _delta_Fe3O4[_qp] = r1 * _delta_Spinel[_qp] - r4 * Rm * _time;\n  }\n  _htc_asterisk[_qp] = 1/(1/_htc[_qp] + _delta_Fe3O4[_qp] / _k_Fe3O4[_qp] + _delta_Spinel[_qp] / _k_Spinel[_qp]);\n  return 0;\n}\n\nReal\nCorrosionHeatTransfer::computeQpResidual(Moose::DGResidualType type)\n{\n  switch (type)\n  {\n    case Moose::Element:\n      return raw_value(_htc_asterisk[_qp]) * (_T_fluid[_qp] - _neighbor_value[_qp]) * _test[_i][_qp];\n\n    case Moose::Neighbor:\n      return raw_value(_htc_asterisk[_qp]) * (_neighbor_value[_qp] - _T_fluid[_qp]) * _test_neighbor[_i][_qp];\n\n    default:\n      return 0.0;\n  }\n}\n\nReal\nCorrosionHeatTransfer::computeQpJacobian(Moose::DGJacobianType type)\n{\n  switch (type)\n  {\n    case Moose::ElementElement:\n      return _apply_element_jacobian ? raw_value(_htc_asterisk[_qp]) * _phi[_j][_qp] * _test[_i][_qp] : 0;\n\n    case Moose::NeighborNeighbor:\n      return raw_value(_htc_asterisk[_qp]) * _phi_neighbor[_j][_qp] * _test_neighbor[_i][_qp];\n\n    case Moose::NeighborElement:\n      return _apply_element_jacobian ? raw_value(_htc_asterisk[_qp]) * -_phi[_j][_qp] * _test_neighbor[_i][_qp]\n                                     : 0;\n\n    case Moose::ElementNeighbor:\n      return raw_value(_htc_asterisk[_qp]) * -_phi_neighbor[_j][_qp] * _test[_i][_qp];\n\n    default:\n      return 0.0;\n  }\n}",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5520605",
                          "updatedAt": "2023-04-04T12:38:19Z",
                          "publishedAt": "2023-04-04T12:37:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "_delta_T[_qp] should be _delta_T\nyou dont need to index into postprocessor values, it s a single value",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5520673",
                          "updatedAt": "2023-04-04T12:43:53Z",
                          "publishedAt": "2023-04-04T12:43:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thank you, Guillaume. I've fixed this bug. Many times, I am just a moose user, not a developer. Actually this is my first time writing MooseApp, so I will make many beginner mistakes\ud83d\ude22. Thank you for patience of fixing bug for me.\nI want to store the calculated thickness in an variable(or something else, I initially wanted to store it in an variable), so I write _delta_Spinel[_qp] = delta_spinel_0 + (_time - t0) * (_rho_LBE[_qp] * Rm) / (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel);(line 143). But it reports error like:\n/home/jixu/projects/moltres/moose/modules/heat_conduction/src/interfacekernels/CorrosionHeatTransfer.C:143:26: error: assignment of read-only location '(&((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::_delta_Spinel)->MooseArray<double>::operator[](((CorrosionHeatTransfer*)this)->CorrosionHeatTransfer::<anonymous>.InterfaceKernelTempl<double>::<anonymous>.InterfaceKernelBase::_qp)'\n  143 |       _delta_Spinel[_qp] = delta_spinel_0 + (_time - t0) * (_rho_LBE[_qp] * Rm) / (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel);\n\nI now realize that perhaps I cannot store the calculated thickness in the Variable[_qp] . Is there any way to solve this problem?",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5520773",
                          "updatedAt": "2023-04-04T12:53:55Z",
                          "publishedAt": "2023-04-04T12:53:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yeah you cant write to:\n  const VariableValue & _delta_Spinel;\nfirst because it's const, and second because an interface kernel isnt meant to write variables.\nyou could use a material property, except this is an interface kernel not a Material.\nDo you really need to save this quantitiy?>",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5520815",
                          "updatedAt": "2023-04-04T12:58:33Z",
                          "publishedAt": "2023-04-04T12:58:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Yeah, the thickness of corrosion layer is very important, because it reports the degree of corrosion. I have two ideas:\n\n\nI think I can start by writing a Material called CorrosionLayerThickness. CorrosionLayerThickness can use some physical properties to calculate the thickness of the corrosion layer and store it. Then I will write another InterfaceKernel called CorrosionConjugateHeatTransfer. CorrosionConjugateHeatTransfer calculates htc_asterisk based on CorrosionLayerThickness and the original htc firstly and uses htc_asterisk to do conjugate heat tansfer calculation\u3002\n\n\nI still complete the two tasks in 1 in one InterfaceKernel. I use something that can store values to store the calculated thickness of the corrosion layer. Does moose have any kernels can store the calculated values? The subsequent calculations will be done step by step.\n\n\nWhich method do you recommend?",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5521117",
                          "updatedAt": "2023-04-04T13:40:30Z",
                          "publishedAt": "2023-04-04T13:23:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the thickness material property can then be used in the interface kernel directly or in an htc material property",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5521358",
                          "updatedAt": "2023-04-04T13:41:11Z",
                          "publishedAt": "2023-04-04T13:41:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "OK, I'll work on it. Is there a Material in MOOSE that has done similar things for reference? I think I'll be more effecitive if I can find a Material which using some physical properties (coupled with variables, postprocessors or materials) to calculate a new material property. I want to learn some writing methods of objects from the Material, because I still don't have much experience in writing kernels.",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5521537",
                          "updatedAt": "2023-04-04T13:57:18Z",
                          "publishedAt": "2023-04-04T13:57:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I have two additional comments:\n\nDon't do qp dependent calculations in the constructor body.\nThe postprocessor delta_T could lead to inaccurate derivatives if you use ADInterfaceKernel. If it's non-AD remember it may give you nonlocal Jacobian.",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5521883",
                          "updatedAt": "2023-04-04T14:26:33Z",
                          "publishedAt": "2023-04-04T14:26:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Thank you for kind suggestions, Gary. I'll pay particular attention to your advice.",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5522231",
                          "updatedAt": "2023-04-04T14:54:42Z",
                          "publishedAt": "2023-04-04T14:54:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Hi, developers.\nI came across this auxkernel today and thought it was very similar to what I want to achieve. So I wrote two auxkernels. One is to calculate thickness of Fe3O4 and the other is to calculate thickness of spinel.  Let\u2019s discuss Fe3O4CorrosionLayerThicknessAux for simplicity\u2019s sake.\nThe source file and header file are here:\n#include \"Fe3O4CorrosionLayerThicknessAux.h\"\n\n#include \"metaphysicl/raw_type.h\"\n\nregisterMooseObject(\"MooseApp\", Fe3O4CorrosionLayerThicknessAux);\n\nInputParameters\nFe3O4CorrosionLayerThicknessAux::validParams()\n{\n  InputParameters params = AuxKernel::validParams();\n  params.addRequiredParam<MaterialPropertyName>(\"rho_Fe3O4\", \"Density of Fe3O4 layer\");\n  params.addRequiredParam<MaterialPropertyName>(\"rho_Spinel\", \"Density of spinel layer\");\n  params.addRequiredParam<MaterialPropertyName>(\"rho_LBE\", \"Density of LBE\");\n  params.addRequiredParam<MaterialPropertyName>(\"rho_Steel\", \"Density of Steel\");\n  params.addRequiredParam<MaterialPropertyName>(\"k_Fe3O4\", \"Thermal conductivity of Fe3O4 layer\");\n  params.addRequiredParam<MaterialPropertyName>(\"k_Spinel\", \"Thermal conductivity of spinel layer\");\n\n  params.addRequiredParam<Real>(\"time\", \"Time of corrosion, s\");\n  params.addRequiredParam<Real>(\"Co\", \"Oxygen concentration, ppm\");\n  params.addRequiredParam<Real>(\"d\", \"Diameter of steel pipe\");\n  params.addRequiredParam<Real>(\"L\", \"Length of steel pipe\");\n  params.addParam<Real>(\"F_Fe_Fe3O4\", 0.72, \"Mass fraction of Fe in Fe3O4\");\n  params.addParam<Real>(\"F_Fe_Spinel\", 0.591, \"Mass fraction of Fe in spinel\");\n  params.addParam<Real>(\"F_Fe_Steel\", 0.9, \"Mass fraction of Fe in steel\");\n  params.addParam<Real>(\"R_PB\", 2.1, \"Pilling-Bedworth ratio\");\n  params.addParam<Real>(\"kp0\", 2.096e-5, \"Model constant for calculating oxidation constant kp, m2/s\");\n  params.addParam<Real>(\"n\", 0.27, \"Exponential factor for calculating oxidation constant kp\");\n  params.addParam<Real>(\"Q_bar\", -157802.0, \"Activation energy Q' for calculating oxidation constant kp, J/mol\");\n  params.addParam<Real>(\"R\", 8.314, \"Gas constant for calculating oxidation constant kp, J/(mol*K)\");\n  params.addParam<Real>(\"A\", 11.217, \"Constant used to calculate the solubility of Fe in steel under LBE environment\");\n  params.addParam<Real>(\"B\", -13967.2, \"Constant used to calculate the solubility of Fe in steel under LBE environment\");\n\n  params.addRequiredCoupledVar(\"temperature\",\n                               \"The temperature used to calculate the properties of Fe3O4 corrosion layer\");\n  params.addRequiredCoupledVar(\"T_main_stream\",\n                               \"Temperature used to calculate the Fe concentration 'c_Fe_b' in LBE\");\n  params.addRequiredCoupledVar(\"Re\", \"Reynolds number\");\n  params.addRequiredCoupledVar(\"Sc\", \"Schmidt number\");\n\n  params.addRequiredParam<PostprocessorName>(\"delta_T\",\n                                             \"Loop temperature difference. \"\n                                             \"The postprocessor used to calculate the mass transfer rate Rm at the LBE/oxide interface\");\n  params.addRequiredParam<PostprocessorName>(\"T_max\",\n                                             \"Loop maximum temperature. \"\n                                             \"The postprocessor used to calculate the mass transfer rate Rm at the LBE/oxide interface\");\n\n  params.addClassDescription(\n      \"This class calculates the thickness of Fe3O4 and spinel based on physical properties.\");\n\n  return params;\n}\n\nFe3O4CorrosionLayerThicknessAux::Fe3O4CorrosionLayerThicknessAux(const InputParameters & parameters)\n  : AuxKernel(parameters),\n    _rho_Fe3O4(getADMaterialProperty<Real>(\"rho_Fe3O4\")),\n    _rho_Spinel(getADMaterialProperty<Real>(\"rho_Spinel\")),\n    _rho_LBE(getADMaterialProperty<Real>(\"rho_LBE\")),\n    _rho_Steel(getADMaterialProperty<Real>(\"rho_Steel\")),\n    _k_Fe3O4(getADMaterialProperty<Real>(\"k_Fe3O4\")),\n    _k_Spinel(getADMaterialProperty<Real>(\"k_Spinel\")),\n\n    _time(getParam<Real>(\"time\")),\n    _Co(getParam<Real>(\"Co\")),\n    _d(getParam<Real>(\"d\")),\n    _L(getParam<Real>(\"L\")),\n    _F_Fe_Fe3O4(getParam<Real>(\"F_Fe_Fe3O4\")),\n    _F_Fe_Spinel(getParam<Real>(\"F_Fe_Spinel\")),\n    _F_Fe_Steel(getParam<Real>(\"F_Fe_Steel\")),\n    _R_PB(getParam<Real>(\"R_PB\")),\n    _kp0(getParam<Real>(\"kp0\")),\n    _n(getParam<Real>(\"n\")),\n    _Q_bar(getParam<Real>(\"Q_bar\")),\n    _R(getParam<Real>(\"R\")),\n    _A(getParam<Real>(\"A\")),\n    _B(getParam<Real>(\"B\")),\n\n    _temperature(coupledValue(\"temperature\")),\n    _T_main_stream(coupledValue(\"T_main_stream\")),\n    _Re(coupledValue(\"Re\")),\n    _Sc(coupledValue(\"Sc\")),\n\n    _delta_T(getPostprocessorValue(\"delta_T\")),\n    _T_max(getPostprocessorValue(\"T_max\"))\n{\n}\n\nADReal\nFe3O4CorrosionLayerThicknessAux::computeValue()\n{\n  ADReal r1 = (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) / (_rho_Fe3O4[_qp] * _F_Fe_Fe3O4);\n  ADReal r4 = _rho_LBE[_qp] / (_rho_Fe3O4[_qp] * _F_Fe_Fe3O4);\n  ADReal kp = _kp0 * pow(_Co, _n) * exp(_Q_bar / (_R * _temperature[_qp]));\n  ADReal D_Fe = 3.97e-7 * exp(-44100 / (_R * _temperature[_qp]));\n  ADReal c_Fe_s = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _temperature[_qp]);\n  ADReal c_Fe_b = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _T_main_stream[_qp]);\n  ADReal Rm = 0.53 * pow(_Re[_qp], 0.6) * pow(_Sc[_qp], 0.5) * pow(_d / _L, 1 / 3) * pow(_delta_T / _T_max, 1 / 3) * (D_Fe / _d) * (c_Fe_s - c_Fe_b);\n  ADReal R_Fe3O4 = r4 * Rm;\n  ADReal t0 = pow(r1, 2) * kp / (4 * pow(R_Fe3O4, 2));\n  ADReal delta_Fe3O4 = 0;\n  ADReal delta_Spinel = 0;\n\n  if (_time >= t0)\n  {\n    delta_Fe3O4 = 0;\n  }\n  else\n  {\n    delta_Spinel = 0.5 * pow(kp * _time, 0.5);\n    delta_Fe3O4 = r1 * delta_Spinel - r4 * Rm * _time;\n  }\n\n  return -MetaPhysicL::raw_value(delta_Fe3O4);\n}\n\n#pragma once\n\n#include \"AuxKernel.h\"\n\nclass Fe3O4CorrosionLayerThicknessAux : public AuxKernel\n{\npublic:\n  static InputParameters validParams();\n\n  Fe3O4CorrosionLayerThicknessAux(const InputParameters & parameters);\n\nprotected:\n  virtual Real computeValue() override;\n\n  const ADMaterialProperty<Real> & _rho_Fe3O4;\n  const ADMaterialProperty<Real> & _rho_Spinel;\n  const ADMaterialProperty<Real> & _rho_LBE;\n  const ADMaterialProperty<Real> & _rho_Steel;\n  const ADMaterialProperty<Real> & _k_Fe3O4;\n  const ADMaterialProperty<Real> & _k_Spinel;\n\n  const Real _time;\n  const Real _Co;\n  const Real _d;\n  const Real _L;\n  const Real _F_Fe_Fe3O4;\n  const Real _F_Fe_Spinel;\n  const Real _F_Fe_Steel;\n  const Real _R_PB;\n  const Real _kp0;\n  const Real _n;\n  const Real _Q_bar;\n  const Real _R;\n  const Real _A;\n  const Real _B;\n\n  const PostprocessorValue & _delta_T;\n  const PostprocessorValue & _T_max;\n\n  const VariableValue & _temperature;\n  const VariableValue & _T_main_stream;\n  const VariableValue & _Re;\n  const VariableValue & _Sc;\n};\n\nWhen I compiled those, there're some errors:\nChecking if header needs updating: /home/jixu/projects/moltres/moose/framework/include/base/MooseRevision.h...\nCreating Unity /home/jixu/projects/moltres/moose/framework/build/unity_src/auxkernels_Unity.C\nCompiling C++ (in opt mode) /home/jixu/projects/moltres/moose/framework/build/unity_src/auxkernels_Unity.C...\nIn file included from /home/jixu/projects/moltres/moose/framework/src/auxkernels/Fe3O4CorrosionLayerThicknessAux.C:1,\n                 from /home/jixu/projects/moltres/moose/framework/build/unity_src/auxkernels_Unity.C:24:\n/home/jixu/projects/moltres/moose/framework/build/header_symlinks/Fe3O4CorrosionLayerThicknessAux.h: In constructor 'Fe3O4CorrosionLayerThicknessAux::Fe3O4CorrosionLayerThicknessAux(const InputParameters&)':\n/home/jixu/projects/moltres/moose/framework/build/header_symlinks/Fe3O4CorrosionLayerThicknessAux.h:43:25: warning: 'Fe3O4CorrosionLayerThicknessAux::_Sc' will be initialized after [-Wreorder]\n   43 |   const VariableValue & _Sc;\n      |                         ^~~\n/home/jixu/projects/moltres/moose/framework/build/header_symlinks/Fe3O4CorrosionLayerThicknessAux.h:37:30: warning:   'const PostprocessorValue& Fe3O4CorrosionLayerThicknessAux::_delta_T' [-Wreorder]\n   37 |   const PostprocessorValue & _delta_T;\n      |                              ^~~~~~~~\nIn file included from /home/jixu/projects/moltres/moose/framework/build/unity_src/auxkernels_Unity.C:24:\n/home/jixu/projects/moltres/moose/framework/src/auxkernels/Fe3O4CorrosionLayerThicknessAux.C:53:1: warning:   when initialized here [-Wreorder]\n   53 | Fe3O4CorrosionLayerThicknessAux::Fe3O4CorrosionLayerThicknessAux(const InputParameters & parameters)\n      | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nLinking Library /home/jixu/projects/moltres/moose/framework/libmoose-opt.la...\n\nIs there any way to fix those bugs? @GiudGiud\nHi, @hugary1995 .\n\nDon't do qp dependent calculations in the constructor body.\n\nI need to generate some intermediate variables and determine if the time is greater than t0, so I wrote those:\nReal\nFe3O4CorrosionLayerThicknessAux::computeValue()\n{\n  ADReal r1 = (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) / (_rho_Fe3O4[_qp] * _F_Fe_Fe3O4);\n  ADReal r4 = _rho_LBE[_qp] / (_rho_Fe3O4[_qp] * _F_Fe_Fe3O4);\n  ADReal kp = _kp0 * pow(_Co, _n) * exp(_Q_bar / (_R * _temperature[_qp]));\n  ADReal D_Fe = 3.97e-7 * exp(-44100 / (_R * _temperature[_qp]));\n  ADReal c_Fe_s = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _temperature[_qp]);\n  ADReal c_Fe_b = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _T_main_stream[_qp]);\n  ADReal Rm = 0.53 * pow(_Re[_qp], 0.6) * pow(_Sc[_qp], 0.5) * pow(_d / _L, 1 / 3) * pow(_delta_T / _T_max, 1 / 3) * (D_Fe / _d) * (c_Fe_s - c_Fe_b);\n  ADReal R_Fe3O4 = r4 * Rm;\n  ADReal t0 = pow(r1, 2) * kp / (4 * pow(R_Fe3O4, 2));\n  ADReal delta_Fe3O4 = 0;\n  ADReal delta_Spinel = 0;\n\n  if (_time >= t0)\n  {\n    delta_Fe3O4 = 0;\n  }\n  else\n  {\n    delta_Spinel = 0.5 * pow(kp * _time, 0.5);\n    delta_Fe3O4 = r1 * delta_Spinel - r4 * Rm * _time;\n  }\n\n  return -MetaPhysicL::raw_value(delta_Fe3O4);\n}\n\nDo you think it's reasonable?",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5532036",
                          "updatedAt": "2023-04-05T12:58:47Z",
                          "publishedAt": "2023-04-05T12:58:46Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "To fix the lambda function you just need to specify the quantities that are defined outside of it, and must be used inside of the function definition, inside the brackets [ ]",
                  "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5543275",
                  "updatedAt": "2023-04-06T12:37:50Z",
                  "publishedAt": "2023-04-06T12:37:49Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "To fix the lambda function you just need to specify the quantities that are defined outside of it, and must be used inside of the function definition, inside the brackets [ ]\n\nI modified the lambda function and it's compiled without errors! After I compiled ADFe3O4CorrosionLayerThicknessMaterial sucessfully I'll add the spinel part. Here is my new code in SpinelCorrosionLayerThicknessAux to calculate thickness of spinel:\nReal\nSpinelCorrosionLayerThicknessAux::computeValue()\n{\n  ADReal r1 = (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) / (_rho_Fe3O4[_qp] * _F_Fe_Fe3O4);\n  ADReal r2 = (_rho_Steel[_qp] * _F_Fe_Steel) / (_rho_Spinel[_qp] * _F_Fe_Spinel);\n  ADReal r3 = _rho_LBE[_qp] / (_rho_Spinel[_qp] * _F_Fe_Spinel);\n  ADReal r4 = _rho_LBE[_qp] / (_rho_Fe3O4[_qp] * _F_Fe_Fe3O4);\n  ADReal kp = _kp0 * pow(_Co, _n) * exp(_Q_bar / (_R * _temperature[_qp]));\n  ADReal D_Fe = 3.97e-7 * exp(-44100 / (_R * _temperature[_qp]));\n  ADReal c_Fe_s = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _temperature[_qp]);\n  ADReal c_Fe_b = pow(_Co, 4 / 3) * exp(_A) * exp(_B / _T_main_stream[_qp]);\n  ADReal Rm = 0.53 * pow(_Re[_qp], 0.6) * pow(_Sc[_qp], 0.5) * pow(_d / _L, 1 / 3) * pow(_delta_T / _T_max, 1 / 3) * (D_Fe / _d) * (c_Fe_s - c_Fe_b);\n  ADReal R_Fe3O4 = r4 * Rm;\n  ADReal t0 = pow(r1, 2) * kp / (4 * pow(R_Fe3O4, 2));\n  ADReal delta_spinel_c = (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel) * kp / (8 * _rho_LBE[_qp] * Rm);\n  ADReal delta_spinel_0 = 0.5 * pow(kp * _time, 0.5);\n  ADReal delta_Fe3O4 = 0;\n  ADReal delta_Spinel = 0;\n  ADReal a = r2 * kp / 8;\n  ADReal b = r3 * Rm;\n  ADReal corrosion_time = _time;\n\n  if (_time >= t0)\n  {\n    delta_Fe3O4 = 0;\n    if (delta_spinel_0 >= delta_spinel_c)\n    {\n      auto f = [&delta_spinel_0, &a, &b, &corrosion_time , &t0](double x) {return delta_spinel_0 - (a / b) * log((a - b * x) / (a - b * delta_spinel_0)) - b * (corrosion_time  - t0); };\n      double x = 1e-4;\n      double tolerance = 1e-7;\n      int max_iter = 100;\n      for (int i = 0; i < max_iter; i++)\n      {\n        if (abs(f(x) - x) < tolerance)\n        {\n          break;\n        }\n        x == f(x);\n      }\n      delta_Spinel = x;\n    }\n    else\n    {\n      delta_Spinel = delta_spinel_0 + (_time - t0) * (_rho_LBE[_qp] * Rm) / (_rho_Steel[_qp] * _F_Fe_Steel - _rho_Spinel[_qp] * _F_Fe_Spinel);\n    }\n  }\n  else\n  {\n    delta_Spinel = delta_spinel_0;\n    delta_Fe3O4 = r1 * delta_Spinel - r4 * Rm * _time;\n  }\n\n  return -MetaPhysicL::raw_value(delta_Spinel);\n}",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5543962",
                          "updatedAt": "2023-04-06T13:50:12Z",
                          "publishedAt": "2023-04-06T13:50:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Is there an AuxKernel in MOOSE that is capable of obtaining Material property? I've found ADMaterialRealAux . But it computes the volume-averaged quantity over the element. So it only supports elemental auxvariable. I want to find an AuxKernel that supports nodal auxvariable.",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5553560",
                          "updatedAt": "2023-04-07T13:38:51Z",
                          "publishedAt": "2023-04-07T13:38:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There's no such thing as nodal material properties because nodes can be shared between blocks, so we wouldnt know which definition of a block-restricted material property to use for the node\nwhy do you need this? If it s an auxkernel it s probably for output right?",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5553733",
                          "updatedAt": "2023-04-07T14:02:50Z",
                          "publishedAt": "2023-04-07T14:02:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "why do you need this? If it s an auxkernel it s probably for output right?\n\nI want to get LayeredAverage value of material properties. I find that I can use ADMaterialRealAux to obtain the value of material property and use LayeredAverage to get LayeredAverage value of material property.\nThe page of ADMaterialRealAux writes that The AD system currently does not support auxiliary variables. If you convert material properties, which do support automatic differentiation, to auxiliary variables, the derivatives will be ignored.  Does it mean that I'll get imprecise value if I use ADMaterialRealAux to obtain the value of ADMaterial property?",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5553920",
                          "updatedAt": "2023-04-07T14:27:58Z",
                          "publishedAt": "2023-04-07T14:27:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is this going to be part of the solve? eg does it come in the equations, and you need to be able to get the derivatives with regards to the nonlinear variables?\nIt's not imprecise, the value is correct, it s just that auxiliary variables do not carry derivative information",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5554888",
                          "updatedAt": "2023-04-07T16:26:19Z",
                          "publishedAt": "2023-04-07T16:26:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "Is this going to be part of the solve? eg does it come in the equations, and you need to be able to get the derivatives with regards to the nonlinear variables?\n\nI only need the values of the auxvariable and don't need its derivatives, so I think ADMaterialRealAux can meet my needs.\nI want to calcluate the thickness of corrosion layer on the interface of solid-fluid. So I set the boundary parameter rather than block parameter in ADLBECorrosionLayerThicknessMaterial:\n  [corrosion_thickness]\n    type = ADLBECorrosionLayerThicknessMaterial\n    rho_Fe3O4 = rho_Fe3O4\n    rho_Spinel = rho_Spinel\n    rho_LBE = rho_LBE\n    rho_Steel = rho_Steel\n    k_Fe3O4 = k_Fe3O4\n    k_Spinel = k_Spinel\n    time = ${time}\n    Co = ${Co}\n    d = ${d}\n    L = ${L}\n    temperature = Tf\n    T_main_stream = Tf_main_stream\n    Re = ave_Re\n    Sc = ave_Sc\n    delta_T = delta_fluid_Tf\n    T_max = max_fluid_Tf\n    # block = fluid\n    boundary = interface_wall\n    output_properties = 'thickness_of_Fe3O4 thickness_of_Spinel oxide_constant diffusion_Fe concentration_Fe_s concentration_Fe_b removal removal_Fe3O4'\n    outputs = exodus\n  []\n\n\nI have two problem:\n\n\nI want to know that will MOOSE use the fluid temperature on interface when I set temperature = Tf?\n\n\nAnd when I finished the calculation, the terminal reported that :\n\n\n*** ERROR ***\nThe following error occurred in the object \"ins_ad_object_tracker\", of type \"INSADObjectTracker\".\n\nThe requested sub_id is not a key in INSADObjectTracker::_block_id_to_params. Please contact a Moose developer to fix this bug.\n\nAnd moose failed to write the results into exudus file. Why does this happen?",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5592048",
                          "updatedAt": "2023-04-12T12:26:44Z",
                          "publishedAt": "2023-04-12T12:26:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I want to know that will MOOSE use the fluid temperature on interface when I set temperature = Tf?\n\nwhen this material property gets evaluated, it will be computed for every quadrature point related to its evaluation. And when doing so, if you use adCoupledValue(\"temperature\") in the code, it will use the fluid temperature.\nI m not familiar with the INSADObjectTracker. Did you add one to your INSAD simulation?\nIs your material deriving from the INSADMaterial base class??",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5592736",
                          "updatedAt": "2023-04-12T13:29:52Z",
                          "publishedAt": "2023-04-12T13:29:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "when this material property gets evaluated, it will be computed for every quadrature point related to its evaluation. And when doing so, if you use adCoupledValue(\"temperature\") in the code, it will use the fluid temperature.\n\nThank you for explanation, I already understand what you mean.\n\nDid you add one to your INSAD simulation? Is your material deriving from the INSADMaterial base class?\n\nMy material is coupled with Tf and Tf is calculated by INSADKernels. But my material isn't coupled with any INSADMaterial and doesn't take part in INSAD simulation. I can show you the material blocks related to my material:\n  [corrosion_thickness]\n    type = ADLBECorrosionLayerThicknessMaterial\n    rho_Fe3O4 = rho_Fe3O4\n    rho_Spinel = rho_Spinel\n    rho_LBE = rho_LBE\n    rho_Steel = rho_Steel\n    k_Fe3O4 = k_Fe3O4\n    k_Spinel = k_Spinel\n    time = ${time}\n    Co = ${Co}\n    d = ${d}\n    L = ${L}\n    temperature = Tf\n    T_main_stream = Tf_main_stream\n    Re = ave_Re\n    Sc = ave_Sc\n    delta_T = delta_cool_Tf\n    T_max = max_cool_Tf\n    boundary = interface_wall\n    output_properties = 'thickness_of_Fe3O4 thickness_of_Spinel oxide_constant diffusion_Fe concentration_Fe_s concentration_Fe_b removal removal_Fe3O4'\n    outputs = exodus\n  []\n  [rho_Fe3O4_mat]\n    type = ADParsedMaterial\n    f_name = rho_Fe3O4\n    function = '0.005170'\n    boundary = interface_wall\n    output_properties = 'rho_Fe3O4'\n    outputs = exodus\n  []\n  [rho_Spinel_mat]\n    type = ADParsedMaterial\n    f_name = rho_Spinel\n    function = '0.003640'\n    boundary = interface_wall\n    output_properties = 'rho_Spinel'\n    outputs = exodus\n  []\n  [rho_LBE_mat]\n    type = ADParsedMaterial\n    f_name = rho_LBE\n    function = '(11096 - 1.3236 * Tf) * 1e-6'\n    args = 'Tf'\n    boundary = interface_wall\n    output_properties = 'rho_LBE'\n    outputs = exodus\n  []\n  [rho_Steel_mat]\n    type = ADParsedMaterial\n    f_name = rho_Steel\n    function = '(7830.853 - 0.212046 * Tf - 1.011373e-4 * pow(Tf,2)) * 1e-6'\n    args = 'Tf'\n    boundary = interface_wall\n    output_properties = 'rho_Steel'\n    outputs = exodus\n  []\n  [k_Fe3O4_mat]\n    type = ADParsedMaterial\n    f_name = k_Fe3O4\n    function = '(4.23 - 1.37e-3 * Tf) * 1e-2' # W/(cm*K) \n    args = 'Tf'\n    boundary = interface_wall\n    output_properties = 'k_Fe3O4'\n    outputs = exodus\n  []\n  [k_Spinel_mat]\n    type = ADParsedMaterial\n    f_name = k_Spinel\n    function = '50.78 * pow(Tf, -0.36) * 1e-2' # W/(cm*K) \n    args = 'Tf'\n    boundary = interface_wall\n    output_properties = 'k_Spinel'\n    outputs = exodus\n  []\n\nThe header file I used in my material's header file is Material.h, I don't know whether it relates to INSADMaterial base class.",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5593003",
                          "updatedAt": "2023-04-12T13:54:12Z",
                          "publishedAt": "2023-04-12T13:54:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Ok that makes sense.\nINSADMaterial are special materials in charge of computing the residual & jacobian for the AD implementation of INS (INSAD).\nWere you getting this effort before using this material?\nWhat if you replace this material with a simple constant using a Parsedmaterial for now?",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5593039",
                          "updatedAt": "2023-04-12T13:57:17Z",
                          "publishedAt": "2023-04-12T13:57:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "js-jixu"
                          },
                          "bodyText": "What if you replace this material with a simple constant using a Parsedmaterial for now?\n\nI commented my material, and I calculated a ParsedMaterial with a simple constant at the interface:\n  [rho_LBE_mat]\n    type = ParsedMaterial\n    f_name = rho_LBE\n    # function = '(11096 - 1.3236 * Tf) * 1e-6'\n    function = '11096 * 1e-6'\n    # args = 'Tf'\n    boundary = interface_wall\n    # block = 'fluid'\n    output_properties = 'rho_LBE'\n    outputs = exodus\n  []\n\nHowever, it still reports the same error\ud83d\ude25:\n*** ERROR ***\nThe following error occurred in the object \"ins_ad_object_tracker\", of type \"INSADObjectTracker\".\n\nThe requested sub_id is not a key in INSADObjectTracker::_block_id_to_params. Please contact a Moose developer to fix this bug.\n\nThe biggest problem is that I can only use material on block, while I can't use the material on the boundary. Do you know why this happens?",
                          "url": "https://github.com/idaholab/moose/discussions/23956#discussioncomment-5593520",
                          "updatedAt": "2023-04-12T14:36:36Z",
                          "publishedAt": "2023-04-12T14:36:35Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Changing timestepper type during a solve.",
          "author": {
            "login": "EdSheltonUKAEA"
          },
          "bodyText": "Is there a way to change timestepper type during a solve?  E.g. start with a FunctionDT for exactly defined time steps, and then allow an IterationAdaptive timestepper to take over at a defined point.\nstart_time and end_time in the Transient Executioner block apply to all settings, not just the timestepper.\nCan this be done using TimePeriod controls?  If so, how are these cross-referenced between the Executioner and Controls blocks?\nOr can sub-blocks with appropriate start and end times be specified within the main Executioners block (similar to defining sub-blocks for a stitched mesh)?\nI can't seem to find any specific examples of the syntax showing how to do these if they are possible.\nAlternatively, do the parameters \"time_t\" and \"time_dt\" allow some specific timestep values to be set within an IterationAdaptiveDT timestepper?  Is there an example of this syntax?\nThese two previous questions and answers seem to have related information, but are for more specific cases reacting to values obtained during a solve:\n#23344\n#23414\nI'm trying to set up some defined times at the start of a solve, so this should be much simpler (I think).",
          "url": "https://github.com/idaholab/moose/discussions/24028",
          "updatedAt": "2023-04-12T13:25:34Z",
          "publishedAt": "2023-04-11T10:18:35Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nNot currently. You currently cannot build two timesteppers.\nHowever @MengnanLi91 is designing a composition time stepper that will bring a lot of flexibility to this, and will less you specify more than one time stepper.\nSee #23961\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24028#discussioncomment-5580691",
                  "updatedAt": "2023-04-11T13:06:43Z",
                  "publishedAt": "2023-04-11T13:06:42Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "OK.  Thanks for this.  This should be a useful addition.\nIn the meantime is there an example using the parameters \"time_t\" and \"time_dt\" in the existing IterationAdaptiveDT timestepper?  I'm not sure if these will help me do what I want.",
                          "url": "https://github.com/idaholab/moose/discussions/24028#discussioncomment-5580855",
                          "updatedAt": "2023-04-11T13:23:07Z",
                          "publishedAt": "2023-04-11T13:23:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There's an example here\n(modules/tensor_mechanics/test/tests/anisotropic_elastoplasticity/ad_uniaxial_x.i)\ndoes it work as expected?",
                          "url": "https://github.com/idaholab/moose/discussions/24028#discussioncomment-5580891",
                          "updatedAt": "2023-04-11T13:25:50Z",
                          "publishedAt": "2023-04-11T13:25:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "Unfortunately, this isn't doing what I'd hoped for.  I expected the \"time_dt\" values to be default time step values which are applied after each corresponding \"time_t\" value.  But this isn't what happened.\nIt might easier to explain what I'd like to happen.\nInitially, up to t = 600, I'd like the equivalent of this FunctionDT:\n\ntype = FunctionDT\nfunction = 'if(t<60, 6, 30)'\n\nThen after this, from t = 600:\n\ntype = IterationAdaptiveDT\ndt = 24\ncutback_factor = 0.5\ngrowth_factor = 2\n\n\nSo the timestep could be cut back to 12, 6 (or smaller), but if possible it will grow, maybe applying a maximum value of 192 (or larger depending on circumstances).\nI tried to do a version of this using:\n\n[TimeStepper]\ntype = IterationAdaptiveDT\ndt = 6\ncutback_factor = 0.5\ngrowth_factor = 2\ntime_t = '0 60 600 624'\ntime_dt = '6 30 6 24'\n[]\n\nAnd I got this set of time values up to 600.  So the time step is growing and shrinking by factors which aren't 2 or 0.5.\n\ntime\n0\n6\n14.4\n26.16\n42.624\n60\n90\n118.6667\n146.0593\n172.2344\n197.2462\n221.1464\n243.9843\n265.8072\n286.6602\n306.5865\n325.6271\n343.8214\n361.2071\n377.8201\n393.6948\n408.8639\n423.3589\n437.2096\n450.4447\n463.0916\n475.1764\n486.7241\n497.7586\n508.3027\n518.3781\n528.0058\n537.2055\n545.9964\n554.3965\n562.4234\n570.0934\n577.4226\n584.426\n591.1182\n597.513\n600\n\nAbove 600, it did move between, 3, 6, 12 and 24.  But wouldn't go above 24.  So I have misunderstood what the array of values specified in the parameters do.\nCan what I want be achieved using:\n\nforce_step_every_function_point\ntimestep_limiting_function\nmax_function_change",
                          "url": "https://github.com/idaholab/moose/discussions/24028#discussioncomment-5582124",
                          "updatedAt": "2023-04-11T15:03:11Z",
                          "publishedAt": "2023-04-11T15:03:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Use this as the limiting function\n'if(t<60, 6, 30)'\nthen once you are done with limiting, just use another if to make it blow away\nif(t<600, if(t<60, 6, 30),    10000000)",
                          "url": "https://github.com/idaholab/moose/discussions/24028#discussioncomment-5584554",
                          "updatedAt": "2023-04-11T19:05:02Z",
                          "publishedAt": "2023-04-11T19:05:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "It says:\n\n*** ERROR ***\nThe following error occurred in the object \"TimeStepper\", of type \"IterationAdaptiveDT\".\ntimestep_limiting_function must be a PiecewiseBase function\n\nSo it doesn't seem I can use a ParsedFunction with nested ifs.\nMy broader query was why the timestep increased and decreased by factors other than the specified 2 and 0.5, and then didn't increase to higher timestep values even though the model was solving OK.",
                          "url": "https://github.com/idaholab/moose/discussions/24028#discussioncomment-5589962",
                          "updatedAt": "2023-04-12T08:41:43Z",
                          "publishedAt": "2023-04-12T08:41:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "EdSheltonUKAEA"
                          },
                          "bodyText": "I've found a way to do it.\nI couldn't use \"ifs\" with a timestep_limiting_function, but I can with a timestep_limiting_postprocessor using a parsed function.\nSo this TimeStepper block and associated PPs do something like what I wanted.\n\n[TimeStepper] # Sub-block to vary default timestep during different stages of solve.\ntype = IterationAdaptiveDT\noptimal_iterations = 6\niteration_window = 3\nlinear_iteration_ratio = 3\ngrowth_factor = 2\ncutback_factor = 0.5\ndt = 6\ntimestep_limiting_postprocessor = P999_tslim_pp\n[]\n\n\n[Postprocessors]\n[P999_tslim_pp]\ntype = ParsedPostprocessor\nfunction = 'if(t<60, 6,\nif(t<540, 60,\nif(t<660, 6, 1536)))'\npp_names = 'P998_dummy_pp'\nuse_t = true\n[]\n[P998_dummy_pp]\ntype = EmptyPostprocessor\n[]\n[]\n\nThe timesteps are controlled up to 660s, and held at 6s for 600s +/- 60s where I'm changing something in my model.\nThen after 660s the brakes are taken off and the full adaptive timestep capability is allowed to let rip.",
                          "url": "https://github.com/idaholab/moose/discussions/24028#discussioncomment-5590690",
                          "updatedAt": "2023-04-12T09:54:20Z",
                          "publishedAt": "2023-04-12T09:54:19Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah I m glad you found a way. I think we will be able to do this easier in the future with the CompositionDT.\nBest,\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24028#discussioncomment-5592698",
                          "updatedAt": "2023-04-12T13:25:30Z",
                          "publishedAt": "2023-04-12T13:25:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "the following blocks (ids) do not exist on the mesh",
          "author": {
            "login": "Ating24"
          },
          "bodyText": "After compiling, I drew a grid myself and imported it into MOOSE for calculation. However, the following error occurred during runtime\uff1a\n\n/mnt/d/projects/hc/hc.i:41: (Materials/example/block):\n    the following blocks (ids) do not exist on the mesh: solid-hex (65535)\n\napplication called MPI_Abort(MPI_COMM_WORLD, 1) - process 0\n[unset]: write_line error; fd=-1 buf=:cmd=abort exitcode=1\n:\nsystem msg for write_line failure : Bad file descriptor\n\n\nHere is my i file\uff1a\n[Mesh]\n  file = cube.exo\n  \n[]\n[Variables]\n  [./heatc]\n    order = FIRST\n    family = LAGRANGE\n  [../]\n[]\n[Kernels]\n  [./diff]\n    type = rechuandao \n    variable = heatc \n  \n  [../]\n  [./conv]\n    type = shijianpiandao\n    variable = heatc\n    \n  [../]\n[]\n[BCs]\n  [./bottom] \n    type = DirichletBC\n    variable = heatc\n    boundary = 'bottom' # This must match a named boundary in the mesh file\n    value = 300\n  [../]\n\n  [./top] \n    type = DirichletBC\n    variable = heatc\n    boundary = 'top' # This must match a named boundary in the mesh file\n    value = 1000\n  [../]\n[]\n[Materials]\n  [./example]\n    type = hmaterial\n    block = 'solid-hex'\n    k=1\n    cp=500\n    density=1000\n    \n  [../]\n # [./example1]\n  #  type = hmaterial\n   # block = 'solid-hex'\n   # k=10\n    #cp=600\n    #density=2000\n  #[../]\n[]\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  num_steps = 10\n  dt = 1\n[]\n[Outputs]\n  exodus = true # Output Exodus format\n[]\n\n\n\nThe grid body I created using pointwise is named solid, and when I use paraviw to view the grid file, the blocks ID is solid hex",
          "url": "https://github.com/idaholab/moose/discussions/24036",
          "updatedAt": "2023-04-12T01:48:09Z",
          "publishedAt": "2023-04-12T00:23:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you either\n\nrun your input with --mesh-only in the command line and paste the output here\nuse a FileMeshGenerator instead of just file= then use the show_info parameter and paste the output here\nThank you!\n\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24036#discussioncomment-5586833",
                  "updatedAt": "2023-04-12T00:29:46Z",
                  "publishedAt": "2023-04-12T00:29:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ating24"
                          },
                          "bodyText": "Sorry, as I just learned MOOSE, I don't quite understand what you're saying about how to operate it",
                          "url": "https://github.com/idaholab/moose/discussions/24036#discussioncomment-5586870",
                          "updatedAt": "2023-04-12T00:38:14Z",
                          "publishedAt": "2023-04-12T00:38:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "./xx-opt -i xxx.i --mesh-only",
                          "url": "https://github.com/idaholab/moose/discussions/24036#discussioncomment-5587205",
                          "updatedAt": "2023-04-12T01:48:10Z",
                          "publishedAt": "2023-04-12T01:48:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Whether the finite element order is different in generating the preprocessing matrix and solving the equation\uff1f",
          "author": {
            "login": "Moyiqi"
          },
          "bodyText": "Hello everyone! May I ask a question?\nI have an idea to use linear finite element to generate preprocessing matrix M and quadratic element to solve it, but I don't know whether this idea can be realized in moose or petsc? How can I do that?\nLily",
          "url": "https://github.com/idaholab/moose/discussions/24029",
          "updatedAt": "2023-04-12T01:05:17Z",
          "publishedAt": "2023-04-11T14:03:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "So you want your M and J to represent a first order basis and second order basis respectively? If that is what you're asking, this is not currently possible in MOOSE. We supply the same matrix for both M and J",
                  "url": "https://github.com/idaholab/moose/discussions/24029#discussioncomment-5583770",
                  "updatedAt": "2023-04-11T17:41:11Z",
                  "publishedAt": "2023-04-11T17:41:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Moyiqi"
                          },
                          "bodyText": "Thank you for your help!\nLily",
                          "url": "https://github.com/idaholab/moose/discussions/24029#discussioncomment-5587001",
                          "updatedAt": "2023-04-12T01:05:18Z",
                          "publishedAt": "2023-04-12T01:05:17Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Piecewise Bilinear Interpolation of Variable Values",
          "author": {
            "login": "AndrewFalkowski"
          },
          "bodyText": "Hello,\nI am wondering if there is a way to compute a piecewise bilinear output based on variables other than spatial coordinates and time? I have a boundary that varies as a function of pressure and time; however, the variation cannot be defined with an analytical expression and must be interpolated. Using a function BC that pulls a value from a PiecewiseBilinear function seems like the right approach, but I don't think there is a way to interpolate within PiecewiseBilinear with quantities other than space and time as it is currently written. Is there a way to accomplish this without writing a custom kernel?",
          "url": "https://github.com/idaholab/moose/discussions/24031",
          "updatedAt": "2023-04-29T02:51:49Z",
          "publishedAt": "2023-04-11T19:54:00Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nTypically, variable dependence is not for Functions. Functions are pre-determined functions of time and space.\nYou ll want to look at a material property instead. If it s just for output (and only output) you can consider an auxkernel too.\nIf the dependencies are simple, you can use a ParsedMaterial.\nIf they are complicated, you ll want to code but there are good utilities for performing these operations\nThese utilities are shared across different systems. In PiecewiseBilinear function, you can look at the _bilinear_interp member of the class, it s something you can create in your custom material to do the interpolations\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24031#discussioncomment-5585153",
                  "updatedAt": "2023-04-11T20:05:07Z",
                  "publishedAt": "2023-04-11T20:05:05Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "[PorousFlow] Volume fraction and BCs",
          "author": {
            "login": "1runer"
          },
          "bodyText": "Hi,\nI currently use PorousFlow with volume flow using GlobalParams multiply_by_density = false.\nMy problem is 1 phase - 2 component flow, pore pressure and a tracer.\nI want to inject a constant volume flow of a mixture at an inlet, so for example 1 m3/s with volume fraction component_0 = 0.1 (tracer) and component_1 = 0.9 (pore pressure), and I'm not sure which BCs to apply and which 'use_' options to put there.\nUnlike most kernels, PorousFlowSink doesn't provide the 'multiply_by_density = false' option and I'm not sure if it's even needed there. So the explanation on the homepage is not quite clear to me.\n[GlobalParams]\n  PorousFlowDictator = dictator\n  gravity = '0 0 -9.81'\n  multiply_by_density = false        # make it volumetric\n[]\n[BCs]\n  [pout]\n    type = DirichletBC # ensure outlet on model top \n    variable = pp\n    boundary = outlet_area\n    value = 0\n  []\n  [flow_inj]\n    type = PorousFlowSink  # constant tracer injection; vol. flow rate = 1 m3/s with 0.1 tracer vol concentration\n    boundary = 'inlet_area'\n    variable = pp\n    flux_function = '-0.9' # inlet area is 1x1 m, so q(inj)= 1m/s\n    use_relperm = true \n    fluid_phase = 0\n []\n [comp_inj]\n    type = PorousFlowSink\n    boundary = 'inlet_area'\n    variable = volfrac0\n    flux_function = '-0.1'\n    use_relperm = true\n    fluid_phase = 0\n  []\n[]\n\nI am unsure if I am even on the right track with this approach?\nBest regards",
          "url": "https://github.com/idaholab/moose/discussions/24001",
          "updatedAt": "2023-04-29T02:52:02Z",
          "publishedAt": "2023-04-06T19:31:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe porousFlowSink contributes : function * test * local relative permeability.\nSo as long as the function is in the same units as your variables, and you are consistent about using the relative permeability, I think you are on the right track.\n@WilkAndy the function parameter description says the unit is kg.m^-2.s^-1. Is this still true when in 'volume flow' with multiply_by_density = false everywhere else?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24001#discussioncomment-5553041",
                  "updatedAt": "2023-04-07T12:20:57Z",
                  "publishedAt": "2023-04-07T12:20:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Great question @1runer .    When you use multiply_by_density = false, the flux_function of PorousFlowSink is measured in m^3.m^-2.s^-1.\nPlease think carefully about whether you want to use multiply_by_density = false.  Eg, quoting from PorousFlowFullySaturated:\n\"When not multiply by density, in many situations the sum of Eq. (1) will imply a Laplace equation such 0=\u2207(k(\u2207P\u2212\u03c1g)), that is a steady-state distribution for the porepressure. In addition, care must be taken when using other parts of PorousFlow, for instance, the PorousFlowMass Postprocessor is coded to record fluid mass, not fluid volume\"",
                  "url": "https://github.com/idaholab/moose/discussions/24001#discussioncomment-5573818",
                  "updatedAt": "2023-04-10T20:09:45Z",
                  "publishedAt": "2023-04-10T20:09:45Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "1runer"
                          },
                          "bodyText": "Thanks @WilkAndy  and @GiudGiud  for the confirmation.\nThe idea is that it is rather common in the literature and also in other codes to calculate component transport and saturation in volume fractions and accordingly most material properties or mixing equations are designed for volume flow. I am aware that for the dissolution of salts and gases it is somewhat different considering molar masses etc.\n\"Eq. (1) PorousFlowFullySaturated will imply a Laplace equation such 0=\u2207(k(\u2207P\u2212\u03c1g))\"\nMy very naive (and probably stupid) question: what are the practical implications for the results or simulation of multiplying both sides of the equation by 1 rather than the fluid density? For convergence reasons this is understandable. Is there further literature regarding this?",
                          "url": "https://github.com/idaholab/moose/discussions/24001#discussioncomment-5584371",
                          "updatedAt": "2023-04-13T18:48:36Z",
                          "publishedAt": "2023-04-11T18:45:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Performance Graph",
          "author": {
            "login": "philipJFpfahl"
          },
          "bodyText": "Hello,\nI want to do a runtime measurement of my main app and I am only concerned about the performance of the main app. Is it possible to measure only the main app runtime and memory usage, without the contribution of the sub-apps or do I have to change the main-sub structure of my application?\nAll the best\nPhilip",
          "url": "https://github.com/idaholab/moose/discussions/24009",
          "updatedAt": "2023-04-11T15:49:04Z",
          "publishedAt": "2023-04-09T10:28:43Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nUse the perf_graph in the main app and manually substract the multiapps portion from the total.\nYou should be able to get the multiapps share in the main app, but if not, then use the perf graph in the subapp as well.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24009#discussioncomment-5563957",
                  "updatedAt": "2023-04-09T12:21:33Z",
                  "publishedAt": "2023-04-09T12:21:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I'd try that. I've never done it so please let us know how it goes",
                          "url": "https://github.com/idaholab/moose/discussions/24009#discussioncomment-5563960",
                          "updatedAt": "2023-04-09T12:21:52Z",
                          "publishedAt": "2023-04-09T12:21:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Okay, that was also my first idea.\nSo I have a main app and I am only interested in the time it takes to calculate one timestep within the main app. The sub-app only loads data and does mesh translation, which I do not want to measure.\nSo I look at the\n|                                   Section                                  | Calls |   Self(s)  |   Avg(s)   |    %   | Mem(MB) |  Total(s)  |   Avg(s)   |    %   | Mem(MB) |\n\n|     MooseApp::execute                                                      |     1 |      0.000 |      0.000 |   0.00 |       0 |     42.512 |     42.512 |  98.74 |      38 |\n|       MooseApp::executeExecutioner                                         |     1 |      0.007 |      0.007 |   0.02 |       1 |     42.512 |     42.512 |  98.74 |      38 |\n|         Transient::PicardSolve                                             |     3 |      0.030 |      0.010 |   0.07 |       4 |     41.416 |     13.805 |  96.20 |      24 |\n\n\nand divide it by the number of time steps: 41.416s / 4timestep ~ 10s/timestep.\nI assume that in this measurement the runtime of the Transient::PicardSolve of my sub-app is included, but not the time it takes to set up the sub-app. Then I can subtract\nsub-app0: |                                 Section                                | Calls |   Self(s)  |   Avg(s)   |    %   | Mem(MB) |  Total(s)  |   Avg(s)   |    %   | Mem(MB) |\n\nsub-app0: |   Transient::PicardSolve                                               |     3 |      0.004 |      0.001 |   0.01 |       0 |      1.982 |      0.661 |   4.62 |      -5 |\n\n\nResulting in a runtime of ~ 41.416s / 4timestep-1.982s /4timestep ~ 9.5s/timestep.\nShould I consider more of the execution time?\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/24009#discussioncomment-5564115",
                          "updatedAt": "2023-04-09T13:00:50Z",
                          "publishedAt": "2023-04-09T13:00:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This seems fine to ignore the setup tasks.\nIf you are trying to draw conclusions from this, you ll like want to execute these timings on several independent runs btw\nthey can vary from one execution to the other",
                          "url": "https://github.com/idaholab/moose/discussions/24009#discussioncomment-5564760",
                          "updatedAt": "2023-04-09T15:18:36Z",
                          "publishedAt": "2023-04-09T15:18:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Thank you. That helps a lot.\nYes this will need to be automated so that I can do several runs with several settings. Is there a Python tool for reading out the PerfGraf JSON file?\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/24009#discussioncomment-5564776",
                          "updatedAt": "2023-04-09T15:22:42Z",
                          "publishedAt": "2023-04-09T15:22:41Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@loganharbour any tips\nWe dont distribute one afaik, though i m sure there's something to read JSON files in python",
                          "url": "https://github.com/idaholab/moose/discussions/24009#discussioncomment-5564832",
                          "updatedAt": "2023-04-09T15:32:45Z",
                          "publishedAt": "2023-04-09T15:32:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Okay, now I am confused :)\nI think that the  Performance Graph does some sort of double bookkeeping. Here are both the Performance Graph:\nFor the sub-app\nsub0: Performance Graph:\nsub0: --------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nsub0: |                                Section                               | Calls |   Self(s)  |   Avg(s)   |    %   | Mem(MB) |  Total(s)  |   Avg(s)   |    %   | Mem(MB) \nsub0: | SealionTestApp (sub0)                                                |     1 |     42.861 |     42.861 |  93.55 |      17 |     45.815 |     45.815 | 100.00 |     111 |\nsub0: |   Transient::PicardSolve                                             |     3 |      0.003 |      0.001 |   0.01 |       0 |      1.612 |      0.537 |   3.52 |      -5 |\n\nAnd for the main-app\nPerformance Graph:\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n|                                 Section                                | Calls |   Self(s)  |   Avg(s)   |    %   | Mem(MB) |  Total(s)  |   Avg(s)   |    %   | Mem(MB) |\n| SealionTestApp (main)                                                  |     1 |      0.005 |      0.005 |   0.01 |       2 |     45.975 |     45.975 | 100.00 |     137 |\n\n|     Transient::PicardSolve                                             |     3 |      0.026 |      0.009 |   0.06 |       3 |     44.296 |     14.765 |  96.35 |      24 |\n\n\nFirst of all my main app should be the heaviest part of the calculation. So that got me confused. Then I ran it by changing the number of nodes in the main-app while keeping the sub-app constant.\nThat results in the Performance Graph of the sub-app appearing to \"run\" faster.\nsub0: Performance Graph:\nsub0: --------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nsub0: |                                Section                               | Calls |   Self(s)  |   Avg(s)   |    %   | Mem(MB) |  Total(s)  |   Avg(s)   |    %   | Mem(MB) |\nsub0: --------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nsub0: | SealionTestApp (sub0)                                                |     1 |      0.367 |      0.367 |  11.63 |       2 |      3.154 |      3.154 | 100.00 |      97 |\n\nSo I assume that the performance graphs are not truly separated?\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/24009#discussioncomment-5565713",
                          "updatedAt": "2023-04-09T19:15:07Z",
                          "publishedAt": "2023-04-09T19:15:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This line is not\nsub0: | SealionTestApp (sub0)                                                |     1 |     42.861 |     42.861 |  93.55 |      17 |     45.815 |     45.815 | 100.00 |     111 |\n\nbut this line is\nsub0: |   Transient::PicardSolve                                             |     3 |      0.003 |      0.001 |   0.01 |       0 |      1.612 |      0.537 |   3.52 |      -5 |\n\nthe perf graph takes differences between start and end points. It s pretty simple. PicardSolve is solidly inside the MultiApp, however the first line of the graph is simply a counter started at the app initialization",
                          "url": "https://github.com/idaholab/moose/discussions/24009#discussioncomment-5565781",
                          "updatedAt": "2023-04-09T19:31:17Z",
                          "publishedAt": "2023-04-09T19:31:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "Ahh, I see.\nSo the main app Transient::PicardSolve tells me the total time spent on Transient::PicardSolve and the sub app Transient::PicardSolve tells me the time the sub app spends there.\nThe first lines just tell me how long the main app needed to initialize the sub app.\nThank you\nPhilip",
                          "url": "https://github.com/idaholab/moose/discussions/24009#discussioncomment-5565869",
                          "updatedAt": "2023-04-09T20:02:21Z",
                          "publishedAt": "2023-04-09T20:02:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "First line is closer to the entire simulation time actually\nAnd PicardSolve in the main app includes the subapp run time",
                          "url": "https://github.com/idaholab/moose/discussions/24009#discussioncomment-5565886",
                          "updatedAt": "2023-04-09T20:09:32Z",
                          "publishedAt": "2023-04-09T20:09:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "philipJFpfahl"
                          },
                          "bodyText": "\"First line is closer to the entire simulation time actually\"\nyes, I meant the difference between the two.\n\"And PicardSolve in the main app includes the subapp run time\"\nThe PicardSolve subapp run time?",
                          "url": "https://github.com/idaholab/moose/discussions/24009#discussioncomment-5565908",
                          "updatedAt": "2023-04-09T20:16:33Z",
                          "publishedAt": "2023-04-09T20:16:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Copy mesh to sub app when using mortar contact",
          "author": {
            "login": "lyyc199586"
          },
          "bodyText": "Hi all, I am trying to use mortar contact in the main app and phase field in the sub app. I want to copy the mesh to the sub app and tried the option clone_parent_mesh=true but get an error:\n*** ERROR ***\nWe should be adding geometric rms so early that we haven't set our MeshBase yet\n\nI wonder what is the correct setting to copy mesh to the sub app.\nhere is part of my input files\uff1a\nmain.i\n[MultiApps]\n  [fracture]\n    type = TransientMultiApp\n    input_files = fracture.i\n    cli_args = 'E=${E};K=${K};G=${G};Lambda=${Lambda};Gc=${Gc};l=${l};sigma_ts=${sigma_ts};sigma_cs=${sigma_cs};delta=${delta}'\n    execute_on = 'TIMESTEP_END'\n    clone_parent_mesh = true\n  []\n[]\n\n[Transfers]\n  [from_d]\n    type = MultiAppCopyTransfer\n    from_multi_app = fracture\n    variable = 'd'\n    source_variable = 'd'\n  []\n  [to_psie_active]\n    type = MultiAppCopyTransfer\n    to_multi_app = fracture\n    variable = 'disp_x disp_y strain_zz psie_active'\n    source_variable = 'disp_x disp_y strain_zz psie_active'\n  []\n[]\n\n[Mesh]\n  coord_type = XYZ\n  [fmg]\n    type = FileMeshGenerator\n    file = '../mesh/disk_mortar_flat.msh'\n    ### for recover\n    # use_for_exodus_restart = true\n    # file = './out/solid_R14.5_ts10_cs80_l0.25_delta25.e'\n  []\n  patch_size = 10\n  patch_update_strategy = always\n[]\n\nsub.i\n[Mesh]\n  coord_type = XYZ\n  [fmg]\n    type = FileMeshGenerator\n    file = '../mesh/disk_mortar_flat.msh'\n    ### for recover\n    # use_for_exodus_restart = true\n    # file = './out/solid_R14.5_ts10_cs80_l0.25_delta25.e'\n  []\n  # # patch_update_strategy = auto\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24016",
          "updatedAt": "2023-04-14T18:42:44Z",
          "publishedAt": "2023-04-10T14:23:38Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nJust dont use clone_parent_mesh.\nIt doesnt save anything, you can just create the mesh in the subapp the same way as the main app\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24016#discussioncomment-5571133",
                  "updatedAt": "2023-04-10T14:26:21Z",
                  "publishedAt": "2023-04-10T14:26:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "should I also use the same patch_size and patch_update_strategy in sub app?",
                          "url": "https://github.com/idaholab/moose/discussions/24016#discussioncomment-5571235",
                          "updatedAt": "2023-04-10T14:38:03Z",
                          "publishedAt": "2023-04-10T14:38:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "weirdly, even if I use the same mesh setting:\n[Mesh]\n  coord_type = XYZ\n  [fmg]\n    type = FileMeshGenerator\n    file = '../mesh/disk_mortar_flat.msh'\n    ### for recover\n    # use_for_exodus_restart = true\n    # file = './out/solid_R14.5_ts10_cs80_l0.25_delta25.e'\n  []\n  patch_size = 10\n  patch_update_strategy = always\n[]\n\nI still get an error in copy transfer:\nThe following error occurred in the object \"to_psie_active\", of type \"MultiAppCopyTransfer\".\n\nThe meshes must be identical to utilize MultiAppDofCopyTransfer::transfer.\ufffd[39m",
                          "url": "https://github.com/idaholab/moose/discussions/24016#discussioncomment-5571283",
                          "updatedAt": "2023-04-10T14:44:28Z",
                          "publishedAt": "2023-04-10T14:43:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "the meshes must be identical. Is the patching changing the mesh differently in either mesh?",
                          "url": "https://github.com/idaholab/moose/discussions/24016#discussioncomment-5571292",
                          "updatedAt": "2023-04-10T14:45:10Z",
                          "publishedAt": "2023-04-10T14:45:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "no I am using the same patch_size = 10 patch_update_strategy = always",
                          "url": "https://github.com/idaholab/moose/discussions/24016#discussioncomment-5571309",
                          "updatedAt": "2023-04-10T14:47:19Z",
                          "publishedAt": "2023-04-10T14:47:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "kk. Just use a shape evaluation transfer. It wont complain",
                          "url": "https://github.com/idaholab/moose/discussions/24016#discussioncomment-5571425",
                          "updatedAt": "2023-04-10T15:03:06Z",
                          "publishedAt": "2023-04-10T15:03:06Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "THe meshes must be different in some way. I m not familiar with patch_update enough to know why",
                          "url": "https://github.com/idaholab/moose/discussions/24016#discussioncomment-5571430",
                          "updatedAt": "2023-04-10T15:03:34Z",
                          "publishedAt": "2023-04-10T15:03:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "ok, I will try, thanks",
                          "url": "https://github.com/idaholab/moose/discussions/24016#discussioncomment-5571462",
                          "updatedAt": "2023-04-10T15:07:34Z",
                          "publishedAt": "2023-04-10T15:07:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If you are using the Contact action, by default you will be adding additional mesh generators from there, unless you set generate_mortar_mesh = false. To use that option, you would have to have already added the lower dimensional blocks necessary for mortar yourself",
                          "url": "https://github.com/idaholab/moose/discussions/24016#discussioncomment-5572294",
                          "updatedAt": "2023-04-10T16:48:27Z",
                          "publishedAt": "2023-04-10T16:48:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Running input files in serial with same mesh and latest variables of previous file as IC",
          "author": {
            "login": "vermaprk"
          },
          "bodyText": "Hello\nI am writing a bash script to run moose input files in serial mode. The variable values from last time step of previous input file are fed as initial condition for the next input file. However, I am getting a warning as follows. (detailed transition from previous to next moose input run is also pasted below)\n\ufffd[31mLEGACY MODES ENABLED:\ufffd[39m\n This application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate diffs due to zero values being stored, and these tests should be re-golded.\n\ufffd[39m\n\nThe initial value at time = 200 on the next input file is showing as zero. However, next time step onwards it begins with the latest run of previous initial conditions. How to get same value at time = 200 for both previous and next input runs.\n\nTime Step 100, time = 200, dt = 2\n 0 Nonlinear |R| = \ufffd[32m8.287613e-06\ufffd[39m\n      0 Linear |R| = \ufffd[32m8.287613e-06\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.606129e-10\ufffd[39m\n      2 Linear |R| = \ufffd[32m1.035618e-16\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m1.606132e-10\ufffd[39m\n      0 Linear |R| = \ufffd[32m1.606132e-10\ufffd[39m\n      1 Linear |R| = \ufffd[32m9.524315e-17\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m1.551636e-17\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+\n| time           | min            |\n+----------------+----------------+\n:                :                :\n|   1.720000e+02 |   5.492681e+02 |\n|   1.740000e+02 |   5.505736e+02 |\n|   1.760000e+02 |   5.518855e+02 |\n|   1.780000e+02 |   5.532034e+02 |\n|   1.800000e+02 |   5.545270e+02 |\n|   1.820000e+02 |   5.558560e+02 |\n|   1.840000e+02 |   5.571900e+02 |\n|   1.860000e+02 |   5.585288e+02 |\n|   1.880000e+02 |   5.598719e+02 |\n|   1.900000e+02 |   5.612191e+02 |\n|   1.920000e+02 |   5.625701e+02 |\n|   1.940000e+02 |   5.639246e+02 |\n|   1.960000e+02 |   5.652823e+02 |\n|   1.980000e+02 |   5.666430e+02 |\n|   2.000000e+02 |   5.680064e+02 |\n+----------------+----------------+\n\nFramework Information:\nMOOSE Version:           git commit c1b08368cd on 2023-01-12\nLibMesh Version:         \nPETSc Version:           3.16.6\nSLEPc Version:           3.16.2\nCurrent Time:            Mon Apr 10 19:21:57 2023\nExecutable Timestamp:    Thu Mar 30 11:38:28 2023\n\nParallelism:\n  Num Processors:          1\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          1\n  Spatial Dimension:       1\n  Nodes:                   201\n  Elems:                   200\n  Num Subdomains:          1\n\nNonlinear System:\n  Num DOFs:                201\n  Num Local DOFs:          201\n  Variables:               \"c\" \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  Solver Mode:             Preconditioned JFNK\n\n\ufffd[31mLEGACY MODES ENABLED:\ufffd[39m\n This application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate diffs due to zero values being stored, and these tests should be re-golded.\n\ufffd[39m\n\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+\n| time           | min            |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+\n\n\nTime Step 1, time = 2, dt = 2\n 0 Nonlinear |R| = \ufffd[32m8.250601e-06\ufffd[39m\n      0 Linear |R| = \ufffd[32m8.250601e-06\ufffd[39m\n      1 Linear |R| = \ufffd[32m1.624315e-10\ufffd[39m\n      2 Linear |R| = \ufffd[32m1.042984e-16\ufffd[39m\n 1 Nonlinear |R| = \ufffd[32m1.624317e-10\ufffd[39m\n      0 Linear |R| = \ufffd[32m1.624317e-10\ufffd[39m\n      1 Linear |R| = \ufffd[32m9.705998e-17\ufffd[39m\n 2 Nonlinear |R| = \ufffd[32m1.479135e-17\ufffd[39m\n\ufffd[32m Solve Converged!\ufffd[39m\n\nPostprocessor Values:\n+----------------+----------------+\n| time           | min            |\n+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |\n|   2.000000e+00 |   5.693723e+02 |\n+----------------+----------------+\n\n\nTime Step 2, time = 4, dt = 2",
          "url": "https://github.com/idaholab/moose/discussions/24015",
          "updatedAt": "2023-04-10T16:06:02Z",
          "publishedAt": "2023-04-10T13:59:29Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou just need to modify the app file in src/base/.C and add in the parameters:\n  params.set<bool>(\"use_legacy_material_output\") = false;\nthis will remove the notice\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24015#discussioncomment-5570969",
                  "updatedAt": "2023-04-10T14:06:20Z",
                  "publishedAt": "2023-04-10T14:06:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Thanks. The warning in turned off now. But still at the first step of next file run the post processor values are show as 0.000000e+00.\nShouldn't it show the value of the latest step from the previous run file?\nPostprocessor Values:\n+----------------+----------------+\n| time           | min            |\n+----------------+----------------+\n|   2.000000e+02 |   0.000000e+00 |\n|   2.020000e+02 |   5.693723e+02 |\n+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/24015#discussioncomment-5571878",
                          "updatedAt": "2023-04-10T16:03:07Z",
                          "publishedAt": "2023-04-10T15:58:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you ll need to execute the postprocessor on INITIAL for that\nexecute_on = 'INITIAL TIMESTEP_END' for example",
                          "url": "https://github.com/idaholab/moose/discussions/24015#discussioncomment-5571920",
                          "updatedAt": "2023-04-10T16:02:23Z",
                          "publishedAt": "2023-04-10T16:02:22Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "vermaprk"
                          },
                          "bodyText": "Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/24015#discussioncomment-5571945",
                          "updatedAt": "2023-04-10T16:06:01Z",
                          "publishedAt": "2023-04-10T16:06:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}