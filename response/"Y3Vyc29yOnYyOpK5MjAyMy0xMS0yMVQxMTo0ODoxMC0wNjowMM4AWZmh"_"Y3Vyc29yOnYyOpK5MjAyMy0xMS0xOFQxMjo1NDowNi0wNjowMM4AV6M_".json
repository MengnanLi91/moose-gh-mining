{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0xMS0xOFQxMjo1NDowNi0wNjowMM4AV6M_"
    },
    "edges": [
      {
        "node": {
          "title": "Initial stresss and boundary condition implementation - PorousFlow",
          "author": {
            "login": "anupkgeos"
          },
          "bodyText": "Hi,\nConsidering the following scenario (Top and RIght BCs),\n\n\n\nhow to implement a free-to-move boundary on top?  2)  initial stress and right boundary for displacement variable are implemented as:\n\nInitial Stress Condition :\nMaterial:\n   [ini_strain]\n     type = ComputeEigenstrainFromInitialStress\n     initial_stress = 'sxx0 0 0  0 syy0 0  0 0 0'\n     eigenstrain_name = 'ini_strain'\n   []\n\nBoundary:\n  [right_u]\n   type = Pressure\n   boundary = right\n   variable = disp_x\n   component = 0\n   function = '0.7*2260*10*y'  # sigma_h = 0.7*sigma_v (total stress, compressive)\n   use_displaced_mesh = false\n []\n\nFunctions:\ngravity = -9.81\nsolid_density = 2260\nfluid_density = 1059\nporosity0 = 0.1\n[Functions]\n  [p0]\n    type = ParsedFunction\n    expression = '0.1e6 - 9.81e3 * y' # -ve y 9.81 MPa/km = 9.81e6/1000m = 9.81e3Pa/m\n    execute_on = INITIAL\n  []\n  [sxx0]\n    type = ParsedFunction\n    expression = '-0.7*${gravity} * y * (${solid_density} - ${fluid_density}) * (1.0 - ${porosity0})'  # initial effective stress that should result from weight force\n  []\n  [syy0]\n    type = ParsedFunction\n    expression = '-${gravity} * y * (${solid_density} - ${fluid_density}) * (1.0 - ${porosity0})'  # initial effective stress that should result from weight force\n  []\n[]\n\nwith this implementation, I am getting a very high displacement value. Can someone please help me with what is wrong here? thanks!",
          "url": "https://github.com/idaholab/moose/discussions/26104",
          "updatedAt": "2023-11-23T01:03:55Z",
          "publishedAt": "2023-11-20T09:30:52Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "josebastiase"
                  },
                  "bodyText": "Hi,\nFor me at least, is easier if you link a minimal example.\nYou can set a free displacement boundary just not setting any mechanical condition in that boundary.\nI would set the load at the boundaries as total stress\n  [load]\n    type = FunctionNeumannBC\n    variable = disp_x\n    function = whatever\n    boundary = right\n  []\n\nhope it helps...",
                  "url": "https://github.com/idaholab/moose/discussions/26104#discussioncomment-7633164",
                  "updatedAt": "2023-11-21T17:02:28Z",
                  "publishedAt": "2023-11-21T17:02:27Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Rename nodesets",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Hi all,\nI am using GeneratedMeshGenerator to create a 3D mesh. I want the names of the generated sidesets to differ from their corresponding side sets.\nThe only way I can see to do this is by renaming all the node sets using BoundingBoxNodeSetGenerator, but that is a tedious solution. Is there a straightforward way to do this?\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/26042",
          "updatedAt": "2023-11-21T16:43:53Z",
          "publishedAt": "2023-11-13T16:40:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "Yea I don't have a great solution for you. @roystgnr we might consider adding an option to create different IDs for the sidesets/nodesets in build_cube?",
                  "url": "https://github.com/idaholab/moose/discussions/26042#discussioncomment-7557998",
                  "updatedAt": "2023-11-13T19:44:50Z",
                  "publishedAt": "2023-11-13T19:44:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you can use the ParsedGenerateSideset with the restriction options to fairly easily rename sidesets.\nIf you prefer renaming the sideset, feel free to modify ParsedGenerateSideset into a ParsedGenerateNodeset (make a new object that is) and we're happy to see this in the framework",
                          "url": "https://github.com/idaholab/moose/discussions/26042#discussioncomment-7589558",
                          "updatedAt": "2023-11-16T15:32:51Z",
                          "publishedAt": "2023-11-16T15:32:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Got it, thanks!",
                          "url": "https://github.com/idaholab/moose/discussions/26042#discussioncomment-7602995",
                          "updatedAt": "2023-11-17T20:27:13Z",
                          "publishedAt": "2023-11-17T20:27:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "We have writable BoundaryInfo::sideset_name(), BoundaryInfo::nodeset_name(), etc. accessors.  In general I'm in favor of requiring user code to make n calls to foo(); bar(); baz(); rather than adding 2\u207f API options for foo_bar_baz(); vs foo_baz(); vs ... etc., especially in cases like this where the optional calls are O(1).\nFor user input decks, on the other hand, there's something to be said for more brevity.  A GeneratedMeshGenerator option to override the default naming might be a good idea.",
                          "url": "https://github.com/idaholab/moose/discussions/26042#discussioncomment-7632955",
                          "updatedAt": "2023-11-21T16:43:54Z",
                          "publishedAt": "2023-11-21T16:43:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Coupling MOOSE and PHREEQC for reservoir reactive fluid flow.",
          "author": {
            "login": "Keshi-23"
          },
          "bodyText": "Hi,\nI would like to understand and get expert guidance on how I can couple the MOOSE PorousFlow module with phreeqc for modeling reactive fluid flow.\n@GiudGiud @cpgr\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/26109",
          "updatedAt": "2023-11-21T15:38:31Z",
          "publishedAt": "2023-11-20T18:05:51Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "cpgr"
                  },
                  "bodyText": "I've never tried this, and have never used phreeqc. Can you give me an idea of what you are trying to do?",
                  "url": "https://github.com/idaholab/moose/discussions/26109#discussioncomment-7624748",
                  "updatedAt": "2023-11-21T00:24:42Z",
                  "publishedAt": "2023-11-21T00:24:41Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "josebastiase"
                  },
                  "bodyText": "I don't think that is possible right now, but I know some people at the GFZ who are working exactly on this.\nIt seems like you need to output variables from both codes after each time step and update the boundary conditions to have sequential loose coupling between the codes (a co-simulation). This is possible in MOOSE with a Userobject; just add it to your PorousFlow app. I have done it with other codes.\nAn option for COMSOL is CPqPy.\nIf you know C++, you can also fully couple the codes by linking both libraries together, but this is definitely harder.\nFinally, it's probably better if you use Geochemistry. As native MOOSE code, it will likely be faster, and the MOOSE team has put a lot of effort into making MultyApps smooth and very functional. You can definitely benefit from that capacity too.\nI hope it helps.",
                  "url": "https://github.com/idaholab/moose/discussions/26109#discussioncomment-7632077",
                  "updatedAt": "2023-11-21T15:38:32Z",
                  "publishedAt": "2023-11-21T15:38:31Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to disable the computing of inactivate element",
          "author": {
            "login": "ZoeyChen1993"
          },
          "bodyText": "Hi, I am using the element activate method in additive manufacturing, could anyone tell me if is there a way to disable the computing of the inactivate element, which means, the problem will not be solved in the element before it is activated?",
          "url": "https://github.com/idaholab/moose/discussions/26079",
          "updatedAt": "2023-11-21T03:53:08Z",
          "publishedAt": "2023-11-16T14:55:45Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "grmnptr"
                  },
                  "bodyText": "I firmly believe that we don't use inactive elements when we compute residuals and jacobians. Maybe you could share why you think we do.",
                  "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7589299",
                  "updatedAt": "2023-11-16T15:08:34Z",
                  "publishedAt": "2023-11-16T15:08:33Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "ZoeyChen1993"
                          },
                          "bodyText": "yes, actually the inactive elements belong to a block and the activate elements belong to another block, when I don't specify any kernel to the inactive block, output always suggests that there must be at least one kernel associated with this block, which means it has to be computed.",
                          "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7589360",
                          "updatedAt": "2023-11-16T15:14:24Z",
                          "publishedAt": "2023-11-16T15:14:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is a simple coverage check troubleshooting.\nYou can add in the problem: kernel_coverage_check = false to skip this\nThen you should either print the matrix or look at the condition number if you believe there are active elements with no kernels there will be a bunch of 0s to deal with in the matrix",
                          "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7590274",
                          "updatedAt": "2023-11-16T16:42:32Z",
                          "publishedAt": "2023-11-16T16:42:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zx1987"
                  },
                  "bodyText": "Hi Peter @grmnptr and Guillaum @GiudGiud : We may not describe what we want to do clearly, so please allow me to use a MWE to demonstrate what we want to achieve. Say we want to simulate a heat conduction problem of a filament of ink being deposited onto a hot plate. We only want to solve the heat conduction problem in the ink. I have block 0 for air, 1 for ink, and use element activation to change air elements into ink elements, and desire to let the newly activated ink elements have an initial ink temperature. We tried the following:\nCase 1: I only define variable T Temperature in the ink block, and diffusion and HeatConductionTimeDerivative kernels in the ink block. It will report the error \"Each subdomain must contain at least one Kernel\" indicating that I need to define a kernel in the air domain.\nCase 2: I define the variable Temperature  in both the air and ink block, and I need to define a kernel for the temperature in the Air domain. To make sure I get the correct initial condition for the newly activated elements, I just used a HeatConductionTimeDerivative for the air. Because this kernel is just a time derivative, so it is enforcing the air domain solve \\dot T=0, meaning it will maintain an initial temperature after solving. Even though this gives me what I need, it is making the system much larger and with extra costs. I checked kernel_coverage_check = false, but it is for the entire domain, not just an air block. Is there a way to just enforce this for a block? I want to exclude the air elements from our calculation before being activated to be ink. Thanks.\nBest,\nXiang",
                  "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7623689",
                  "updatedAt": "2023-11-20T22:11:36Z",
                  "publishedAt": "2023-11-20T21:02:34Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Do case 1 with kernel_coverage_check = false to get the reduced matrix\nYou want to block restrict the variable to the domain you are solving in to get the least DOFs to solve",
                          "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7623782",
                          "updatedAt": "2023-11-20T21:15:08Z",
                          "publishedAt": "2023-11-20T21:15:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Hi Guillaum @GiudGiud: that works! Thanks.\nBest,\nXiang",
                          "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7624219",
                          "updatedAt": "2023-11-20T22:23:47Z",
                          "publishedAt": "2023-11-20T22:23:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Hi Guillaum @GiudGiud: As I move forward, I have a new question as below:\nBecause my air domain does not have T variable now, and I want like to initialize the T of the newly activated ink elements to be a specified value T0. Noticed the mentioning of the apply_initial_conditions, together with an example under test/tests/userobjects/element_subdomain_modifier/initial_condition.i on this page.\nThe example on this page is for AuxVariable IC but I need to do IC for the variable, so I created the following AuxAVariables as the initial condition for those newly activated ink elements,\n[AuxVariables]\n  [dist] #-- this is for element activation use\n  []\n    [ICT] #-- initial condition for T of the newly activated ink element\n      type = ConstantIC\n      value = 30\n    []\n[]\n\nI then created an auxkernel to change the Temperature in the newly activated ink to be the value stored in the above AuxVariable ICT as below:\n[AuxKernels]\n  [dist]\n    type = ParsedAux\n    variable = dist\n    expression = 'sqrt((x-t*0.001)^2+(y-0.0)^2)'\n    use_xyzt = true\n    execute_on = 'TIMESTEP_BEGIN'\n  []\n\n  [InitialT]\n    type = ConstantICAux\n    variable = Temperature\n    coupled = ICT\n    block = 1\n  []\n[]\n\nI also created a ConstantICAux.C, by mimicking the provided StatefulAux.C with the source code below:\n#include \"ConstantICAux.h\"\n\nregisterMooseObject(\"ArmyAntsApp\",ConstantICAux);\n\nInputParameters\nConstantICAux::validParams()\n{\n  InputParameters params = AuxKernel::validParams();\n  params.addRequiredCoupledVar(\"coupled\", \"Coupled Value for Calculation\");\n  return params;\n}\n\nConstantICAux::ConstantICAux(const InputParameters & parameters)\n  : AuxKernel(parameters),\n    _coupled(coupled(\"coupled\")),\n    _coupled_val_old(coupledValueOld(\"coupled\"))\n{\n}\n\nReal\nConstantICAux::computeValue()\n{\n  return _coupled;\n}\n\nThis does not seem to be correct as it has reported error message: \"Task add_aux_variable is not registered to build InitialCondition derived objects\". Could you comment whether this thinking is correct or should I do something different? Or if there is an example for specifying IC for Variables instead of AuxVariables?\nThanks.\nXiang",
                          "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7624537",
                          "updatedAt": "2023-11-20T23:48:47Z",
                          "publishedAt": "2023-11-20T23:42:28Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThis is not correct\n[AuxVariables]\n  [dist] #-- this is for element activation use\n  []\n    [ICT] #-- initial condition for T of the newly activated ink element\n      type = ConstantIC\n      value = 30\n    []\n[]\n\nA constantIC should not be created within an auxvariable directly. Did you mean this?\nThis creates an auxiliary variable T and its initial condition. If you already have T as a nonlinear variable, see below\n[AuxVariables]\n  [dist] #-- this is for element activation use\n  []\n  [T] # creates a new T variable \n    [IC]  #-- initial condition for T of the newly activated ink element, might be [InitialCondition] actually\n      type = ConstantIC\n      value = 30\n    []\n  []\n[]\n\nor maybe this (can be defined for either an aux or a nonlinear variable\n[ICs]\n    [T_IC]  #-- initial condition for T of the newly activated ink element\n      type = ConstantIC\n      variable = T\n      value = 30\n    []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7625050",
                          "updatedAt": "2023-11-21T01:18:47Z",
                          "publishedAt": "2023-11-21T01:14:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Is T a nonlinear or an auxiliary variable?\nAlso keep in mind the auxkernel will execute all the time, so it will set the values again and again.\nI m not sure if you are trying to stay at this initialized value",
                          "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7625108",
                          "updatedAt": "2023-11-21T01:25:54Z",
                          "publishedAt": "2023-11-21T01:25:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Hi Guillaum @GiudGiud for further looking into this.  T is already a nonliner variable that exists in block 1, and I was trying to initialize the T in the newly activated elements (activated from block 0 to be in block 1, which do not have T defined before activation) for only ONCE right after activation. So I should not use AuxVariable in this case based on your comments.  When the simulation starts, the initial ink has T01=20 C, and the newly activated ink needs to be initiated to a different value T02=30 C. So the use of\n[ICs]\n    [T_IC]  #-- initial condition for T of the newly activated ink element\n      type = ConstantIC\n      variable = T\n      value = 30\n    []\n[]\n\nwill not work as it will also set the initial condition of the ink at the start of the simulation to be 30 C.\nSo to be clear, I was trying to initialize the newly activated ink elements with a temperature value that I can define in the input file. Note that the elements do not have T defined before activation, and the temperature value to be initialized at the time of activation could be different from the initial condition of the ink elements that exist at the start of the simulation. Any further comments? Thanks.\nXiang",
                          "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7625341",
                          "updatedAt": "2023-11-21T02:14:59Z",
                          "publishedAt": "2023-11-21T02:00:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "At this point I feel you should either:\n\nmodify the code to create a new option for initialization of new elements in a block (from some other variable for example, that has a different name, is defined everywhere and just stays constant)\ndefine T all over the domain and take the penalty in terms of DOFs. Those DOFs will have a very simple equation to solve so it may not be too bad?",
                          "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7625445",
                          "updatedAt": "2023-11-21T02:16:52Z",
                          "publishedAt": "2023-11-21T02:16:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "or new idea. A little bit of a hack but it should work\n\nYou use T_IC for the ink at 30C for new elements\nand instead of an IC you use a transfer to override the IC and set the initial ink at 20 C.\nYou can just create a dummy MultiApp simulation that just has a constant field on a mesh (could even be a 1x1 square if you have a constant field, and interpolate from that 1x1 cell mesh) and does not much more",
                          "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7625464",
                          "updatedAt": "2023-11-21T02:19:17Z",
                          "publishedAt": "2023-11-21T02:19:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "zx1987"
                          },
                          "bodyText": "Hi Guillaum @GiudGiud: thanks for all the input, and I will first attempt to define T all over the domain, and create another initialization option.",
                          "url": "https://github.com/idaholab/moose/discussions/26079#discussioncomment-7625947",
                          "updatedAt": "2023-11-21T03:53:09Z",
                          "publishedAt": "2023-11-21T03:53:08Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "enforce initial velocity",
          "author": {
            "login": "lyyc199586"
          },
          "bodyText": "In elastodynamic simulations (variable: displacement), is there a way to enforce the initial velocity (not displacement) to some boundary?",
          "url": "https://github.com/idaholab/moose/discussions/26111",
          "updatedAt": "2023-11-20T19:45:29Z",
          "publishedAt": "2023-11-20T19:23:12Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "maxnezdyur"
                  },
                  "bodyText": "Depending on how you set up your simulation, if you are using the NewmarkVelAux and a velocity AuxVariable then you should be able to set the initial condition on the velocity variable. I think you just need to make sure the NewmarkVelAux only runs on Timestep_End and not Linear.  Option 2, use the PresetVelocity BC, and then use controls to turn it off after a small amount of time. It won't be exactly an initial condition but may work in cases were you have some wiggle room with timing.",
                  "url": "https://github.com/idaholab/moose/discussions/26111#discussioncomment-7623071",
                  "updatedAt": "2023-11-20T19:34:33Z",
                  "publishedAt": "2023-11-20T19:34:32Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "I will try Option 2 first, thanks max!",
                          "url": "https://github.com/idaholab/moose/discussions/26111#discussioncomment-7623156",
                          "updatedAt": "2023-11-20T19:45:30Z",
                          "publishedAt": "2023-11-20T19:45:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "outputing radial and tangential strain for an \"xy\" coordinate problem",
          "author": {
            "login": "afcij"
          },
          "bodyText": "I am doing a 2D tensor mechanics problem on a circular mesh. I have to use Cartesian coordinates (disp_x disp_y), but I need to output radial stress and strain. Using the tensor mechanics master action does not give the correct values for radial stress and strain. I can use the CylindricalRankTwoAux to transform the stress tensor:\n  (aux variables defined above)\n  [./radial_stress]\n    type = CylindricalRankTwoAux\n    variable = radial_stress\n    rank_two_tensor = stress\n    index_j = 0\n    index_i = 0\n    center_point = '0 0 0'\n  [../]\n  [./hoop_stress] \n    type = CylindricalRankTwoAux\n    variable = hoop_stress\n    rank_two_tensor = stress\n    index_j = 1\n    index_i = 1\n    center_point = '0 0 0'\n  [../]\n\nI thought I would be able to do the same for strain. However, I can't find the \"rank_two_tensor\" name for strain. Can anyone help me with finding this name, or find another method to get radial strain? Here is how I have set up my master action and stress calculation:\n  [Modules]\n    [./TensorMechanics]\n      [./Master]\n        [./All]\n          add_variables = true\n          strain = SMALL\n          additional_generate_output = 'stress_xx stress_yy strain_xx strain_yy'\n          eigenstrain_names = 'thermal_eigenstrain'\n          material_output_order = CONSTANT\n          material_output_family = MONOMIAL\n        [../]\n      [../]\n    [../]\n  []\n [Materials]\n  [./stress]\n    type = ComputeLinearElasticStress\n  [../]\n[]",
          "url": "https://github.com/idaholab/moose/discussions/26112",
          "updatedAt": "2023-11-20T19:33:21Z",
          "publishedAt": "2023-11-20T19:30:46Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@gambka",
                  "url": "https://github.com/idaholab/moose/discussions/26112#discussioncomment-7623065",
                  "updatedAt": "2023-11-20T19:33:22Z",
                  "publishedAt": "2023-11-20T19:33:21Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "compile auto quit due to some reasons",
          "author": {
            "login": "hhy2022"
          },
          "bodyText": "Hello,\nToday, I attempted to update MOOSE, but for reasons unknown, the compilation process terminated on its own. Suspecting issues with the update, I proceeded to reinstall the entire MOOSE software, yet the problem persisted. During my attempt to test the MOOSE installation using the command make -j , the computer became unresponsive, and subsequently, the terminal automatically closed.\nI am uncertain whether this is a problem with my computer or if I missed an important update. I was wondering if you might have insights into the issue.\nMany tanks for any help.",
          "url": "https://github.com/idaholab/moose/discussions/26108",
          "updatedAt": "2023-11-20T19:02:26Z",
          "publishedAt": "2023-11-20T17:01:29Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you reduce the number for make -j ? Try make -j 2\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/26108#discussioncomment-7621875",
                  "updatedAt": "2023-11-20T17:09:41Z",
                  "publishedAt": "2023-11-20T17:09:40Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hhy2022"
                          },
                          "bodyText": "Sure. I used to use  make -j 4 and it worked. I can try make -j 2\nBy the way, is there any default one by  make -j?",
                          "url": "https://github.com/idaholab/moose/discussions/26108#discussioncomment-7622085",
                          "updatedAt": "2023-11-20T17:31:20Z",
                          "publishedAt": "2023-11-20T17:31:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I m thinking you are running out of memory with -j4",
                          "url": "https://github.com/idaholab/moose/discussions/26108#discussioncomment-7622164",
                          "updatedAt": "2023-11-20T17:39:24Z",
                          "publishedAt": "2023-11-20T17:39:23Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hhy2022"
                          },
                          "bodyText": "I employed make -j 2, and it proved effective. However, all the tests resulted in failure. After consulting the forum, I discovered some helpful solutions and now all the installation should work well. Thank you very much for your help.\nI recall that before the update, using make -j was sufficient for successful outcomes. Now, it appears that specifying it as make -j 2 is necessary. The exact issue remains uncertain to me. While it functions adequately, the process is somewhat sluggish, consuming more than one hour for the compilation and testing of the MOOSE installation. Is this solely a concern with my computer? Perhaps upgrading to a more advanced system is in order.",
                          "url": "https://github.com/idaholab/moose/discussions/26108#discussioncomment-7622718",
                          "updatedAt": "2023-11-20T18:48:47Z",
                          "publishedAt": "2023-11-20T18:48:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I dont know what make -j defaults too. The manual says\n  -j [N], --jobs[=N]          Allow N jobs at once; infinite jobs with no arg.\n\nbetter computer is always good for running simulations if you are considering upgrading",
                          "url": "https://github.com/idaholab/moose/discussions/26108#discussioncomment-7622742",
                          "updatedAt": "2023-11-20T18:52:10Z",
                          "publishedAt": "2023-11-20T18:52:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hhy2022"
                          },
                          "bodyText": "OK. Thank you very much for your help.",
                          "url": "https://github.com/idaholab/moose/discussions/26108#discussioncomment-7622841",
                          "updatedAt": "2023-11-20T19:02:26Z",
                          "publishedAt": "2023-11-20T19:02:26Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Integrating Current Density to Compute Current",
          "author": {
            "login": "jsevic"
          },
          "bodyText": "Hello,\nWe have thin film structure, 2D at the moment, and have defined an AuxKernel that computes the vector current density. Our objective is to compute current over an edge boundary versus time.\nI have been tried some of the post-processor integrators, such as FunctionSideIntegral and SideIntegration, and it's not clear to me I am getting what I expected. This was brought up in a previous thread #20280.\nDo we need an Aux Kernel that computes current over time?\nAny suggestions thx!",
          "url": "https://github.com/idaholab/moose/discussions/26034",
          "updatedAt": "2023-11-20T17:02:08Z",
          "publishedAt": "2023-11-11T15:28:58Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "I would use a SideIntegralVariablePostprocessor",
                  "url": "https://github.com/idaholab/moose/discussions/26034#discussioncomment-7556524",
                  "updatedAt": "2023-11-13T17:04:31Z",
                  "publishedAt": "2023-11-13T17:04:31Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jsevic"
                          },
                          "bodyText": "Hello thanks I tried that and evidently it's looking for a scalar. Since my current density is computed as a vector do I need to form the dot product with the normal for the current through the boundary?",
                          "url": "https://github.com/idaholab/moose/discussions/26034#discussioncomment-7557601",
                          "updatedAt": "2023-11-13T18:53:56Z",
                          "publishedAt": "2023-11-13T18:53:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "yes, sorry I missed that it was a vector. That makes sense!",
                          "url": "https://github.com/idaholab/moose/discussions/26034#discussioncomment-7558060",
                          "updatedAt": "2023-11-13T19:53:57Z",
                          "publishedAt": "2023-11-13T19:53:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so this is effectively an advective flux\nhttps://mooseframework.inl.gov/source/postprocessors/SideAdvectiveFluxIntegral.html\none thing though is that the postprocessing will only be correct if the discretization in the postprocessor and the kernels / BCs are the same",
                          "url": "https://github.com/idaholab/moose/discussions/26034#discussioncomment-7589484",
                          "updatedAt": "2023-11-16T15:26:18Z",
                          "publishedAt": "2023-11-16T15:26:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "will only be correct\n\nThere's nuance here. For finite elements, as an example, if you use Dirichlet BCs then you no longer enforce global conservation and consequently a flux measured by a postprocessor might appear \"wrong\". However, it is still correct within finite element approximation error.\nFor a finite volume discretization, yes you should ensure that your forms in your postprocessor exactly match what's going on in the finite volume kernels/bcs",
                          "url": "https://github.com/idaholab/moose/discussions/26034#discussioncomment-7590697",
                          "updatedAt": "2023-11-16T17:22:10Z",
                          "publishedAt": "2023-11-16T17:22:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "jsevic"
                  },
                  "bodyText": "Thanks using SideIntegralVariablePostprocessor works and I also used the AuxKernel VectorVariableMagnitudeAux to compute the magnitude of our current density, and the test cases produce what we expected.",
                  "url": "https://github.com/idaholab/moose/discussions/26034#discussioncomment-7621813",
                  "updatedAt": "2023-11-20T17:01:59Z",
                  "publishedAt": "2023-11-20T17:01:58Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "As the damage index increases, indicating more damage, the effective stiffness of each spring element in the creep model decreases?",
          "author": {
            "login": "deyantian18"
          },
          "bodyText": "Dear Community Members,\nI have developed a model that incorporates elasticity, creep model by KV, and damage evolution calculated by energy, and I am interested in understanding whether the evolution of damage affects the creep parameters (e.g. weaken the spring's stiffness in the viscoelasticity model). as my understanding, when the material is in a inleastic-deformed status, the stress is only generated by the elastic strain (\u03c3 = C * (\u03b5_total - \u03b5_ine - \u03b5_eigen) = C * \u03b5_e) . But when a damage evolution model is added, the damage index is only affect on the elasticity to calculate the stress or affect both the elasticity and elasticity (the creep modulus ) in creep?\nhere is the input file for material:\n[./burgers]\ntype = GeneralizedKelvinVoigtModel\ncreep_modulus = '11000 20000'\ncreep_viscosity = '15 6000'\npoisson_ratio = 0.2\nyoung_modulus = 11000\ndriving_eigenstrain = ini_stress\n[../]\n[./strain]\ntype = ComputeIncrementalSmallStrain\ndisplacements = 'disp_x disp_y disp_z'\neigenstrain_names = ini_stress\n[../]\n[./stress]\ntype = ComputeMultipleInelasticStress\ninelastic_models = 'creep'\nperform_finite_strain_rotations = false\ntangent_operator='nonlinear'\ndamage_model= damage\n[../]\n[./creep]\ntype = LinearViscoelasticStressUpdate\n[../]\n[./damage]\ntype = Tian_AccuDamageByEnergy\n-\n-\n--\n[../]\nmany thanks.",
          "url": "https://github.com/idaholab/moose/discussions/26070",
          "updatedAt": "2023-11-20T14:51:14Z",
          "publishedAt": "2023-11-15T16:05:39Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "bwspenc"
                  },
                  "bodyText": "The damage model only has the effect of decreasing the stress computed from the elastic strain, so the damaged stress calculation would look like: \u03c3 = (1-d) * C * (\u03b5_total - \u03b5_ine - \u03b5_eigen) = (1-d) * C * \u03b5_e\nAlso, it's important to note that at the beginning of the inelastic calculation, we undo the application of damage on the stress from the previous step, so we go through the whole calculation of creep as if there were no damage. Since in the end the stress gets scaled down due to damage, the elastic stiffness as well as the stiffnesses of the springs in the creep model effectively get decreased by the same amount.",
                  "url": "https://github.com/idaholab/moose/discussions/26070#discussioncomment-7579613",
                  "updatedAt": "2023-11-15T17:24:30Z",
                  "publishedAt": "2023-11-15T17:24:29Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "There are only a couple of places in the code where damage shows up in the inelastic calculation. This is where the stress is modified for damage at the end of the current stress calculation:\n\n  \n    \n      moose/modules/tensor_mechanics/src/materials/ComputeMultipleInelasticStressBase.C\n    \n    \n         Line 213\n      in\n      ed69223\n    \n  \n  \n    \n\n        \n          \n           _damage_model->updateStressForDamage(_stress[_qp]); \n        \n    \n  \n\n\nThis is where we use the undamaged stress from the old step:\n\n  \n    \n      moose/modules/tensor_mechanics/src/materials/ComputeMultipleInelasticStress.C\n    \n    \n         Line 84\n      in\n      ed69223\n    \n  \n  \n    \n\n        \n          \n           _stress[_qp] = _undamaged_stress_old + _elasticity_tensor[_qp] * elastic_strain_increment;",
                          "url": "https://github.com/idaholab/moose/discussions/26070#discussioncomment-7579648",
                          "updatedAt": "2023-11-15T17:28:49Z",
                          "publishedAt": "2023-11-15T17:28:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "deyantian18"
                          },
                          "bodyText": "Hi bwspenc,\nThank you very much. I need a bit of help understanding something in the ComputeMultipleInelasticStress module. Before the damage model starts, we have only elasticity and viscoelasticity. I've noticed that the stiffness (secant modulus=stress/strain) output shows some degradation over time because of viscoelasticity. Could you explain why this happens?\nAlso, 'The damage model only has the effect of decreasing the stress computed from the elastic strain' here the elastic strain is mean the pure elasticity not including the spring's elasticity in the creep model?  just use Young's modulus instead?\nThanks a lot for your help with this.\nBest,\nDeyan",
                          "url": "https://github.com/idaholab/moose/discussions/26070#discussioncomment-7580977",
                          "updatedAt": "2023-11-15T20:23:02Z",
                          "publishedAt": "2023-11-15T20:23:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "Yes, you're right that there should be an apparent decrease in stiffness due to viscoelasticity even before you consider damage. That is because the accumulation of inelastic strain makes the material less stiff than it would be if it were purely elastic.\nWhat I meant in that statement about the stress computed from the elastic strain is that all the inelastic models compute elastic and inelastic strains. The stress after computing inelastic response, but before damage, is computed as C * \u03b5_e. That elastic strain is reduced from what it would be in a purely elastic model because of the inelastic strain. The stiffness of the springs in the units of the Kelvin Voigt model will affect the inelastic strain that you get from the creep model.",
                          "url": "https://github.com/idaholab/moose/discussions/26070#discussioncomment-7581833",
                          "updatedAt": "2023-11-15T23:05:34Z",
                          "publishedAt": "2023-11-15T22:31:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "deyantian18"
                          },
                          "bodyText": "Hello bwspenc,\nis that okay if I use this math formulation to represent the stiffness degradation process for elastic model and inelastic model when there is a damage model ?\n\nmany thanks,\nDeyan",
                          "url": "https://github.com/idaholab/moose/discussions/26070#discussioncomment-7588153",
                          "updatedAt": "2023-11-16T13:18:39Z",
                          "publishedAt": "2023-11-16T13:18:39Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "I assume those Es are the constants for the K-V model, right? It might be correct depending on how you use them in the rest of the formulation. I think I would personally be inclined to use the undamaged versions of them in the formulation, and then use the equation at the top of your list to show how the stress is modified for damage.",
                          "url": "https://github.com/idaholab/moose/discussions/26070#discussioncomment-7591337",
                          "updatedAt": "2023-11-16T18:19:59Z",
                          "publishedAt": "2023-11-16T18:19:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bwspenc"
                          },
                          "bodyText": "You might find this report helpful for its description of the K-V model: https://doi.org/10.2172/1460224\nIt doesn't touch on how to tie that with damage, though.",
                          "url": "https://github.com/idaholab/moose/discussions/26070#discussioncomment-7591369",
                          "updatedAt": "2023-11-16T18:24:22Z",
                          "publishedAt": "2023-11-16T18:24:22Z",
                          "isAnswer": true
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "deyantian18"
                  },
                  "bodyText": "Thank you very much, Ben Spencer,\nI read this file you provided, it is very helpful to understand the creep implementation in MOOSE.\nI still have a problem with the stiffness tensor calculation from the file if combined with damage model,\n\n\nthe C_eq is an apparent stiffness tensor associated with C_0 and C_i for first spring of the chain and i spring in the tensor.\nThe C_E is the true elasticity tensor of the material which equal to the the first spring in the chain (eq9):\n\nthe C_eq ^(n+1) is time-dependent parameter, which results in changing with accumulation of inelastic strain in creep. If we add the damage model  with decreasing the stress: \u03c3 = (1-d) * C * (\u03b5_total - \u03b5_ine - \u03b5_eigen), there the C (= C_eq ) is changing with the time? but affect independently only on stress, even the stressupdate is about to calculate the inelastic strain related.\nMany thanks,\nDeyan",
                  "url": "https://github.com/idaholab/moose/discussions/26070#discussioncomment-7620413",
                  "updatedAt": "2023-11-20T14:51:11Z",
                  "publishedAt": "2023-11-20T14:51:11Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "7 DOF Beam",
          "author": {
            "login": "andrey1887"
          },
          "bodyText": "Hello. I want to try to implement line element with 7 degree of freedom in each node. 7-th degree will consider warping of cross-section. Besides of this, bimoment must be calculated. I have a stiffness matrix of this element in explicit form. Does existing capabilities of MOOSE can help to discribe this problem ? Thank you for suggestions.\n\n\n\noose/assets/114737834/855d0cfc-6071-413e-8a02-c8b5f4d6981c)",
          "url": "https://github.com/idaholab/moose/discussions/25754",
          "updatedAt": "2023-11-18T18:54:06Z",
          "publishedAt": "2023-10-16T19:22:34Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cbolisetti @roystgnr @dschwen\nThe answer is no, but it could be developed, in libmesh",
                  "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7298703",
                  "updatedAt": "2023-10-17T01:29:20Z",
                  "publishedAt": "2023-10-17T01:29:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Thank you for answer. Will you take a some link to information or example how to do it.\nThere is supposed subsequent interaction between MOOSE and libmesh isn't it? Is MOOSE still used if we use libmesh?\n@cbolisetti @roystgnr @dschwen @GiudGiud",
                          "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7301171",
                          "updatedAt": "2023-10-17T08:16:00Z",
                          "publishedAt": "2023-10-17T08:15:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You can use libmesh without moose.\nHowever moose provides you with a friendlier setup, post processing capabilities and a lot of pre existing equation implementations.",
                          "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7303364",
                          "updatedAt": "2023-10-17T12:13:08Z",
                          "publishedAt": "2023-10-17T12:13:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "@GiudGiud do you have some example of using libmesh with moose ?",
                          "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7303716",
                          "updatedAt": "2023-10-17T12:52:35Z",
                          "publishedAt": "2023-10-17T12:52:35Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "All of moose relies on libmesh as the backend.",
                          "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7303751",
                          "updatedAt": "2023-10-17T12:56:51Z",
                          "publishedAt": "2023-10-17T12:56:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "All of moose relies on libmesh as the backend.",
                          "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7303753",
                          "updatedAt": "2023-10-17T12:57:02Z",
                          "publishedAt": "2023-10-17T12:57:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "All of moose relies on libmesh as the backend.",
                          "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7303796",
                          "updatedAt": "2023-10-17T13:00:49Z",
                          "publishedAt": "2023-10-17T13:00:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "roystgnr"
                          },
                          "bodyText": "You can get 7 degrees of freedom per node (on a 2-node element, I assume?  \"all line elements have 2 nodes\" isn't true) by adding seven (default, LAGRANGE) variables to your system.  After that?  If your stiffness matrix comes from an integral form, you can write a new Kernel object for it and overload computeQpResidual() or computeQpJacobian(); if it doesn't have an integral representation then you can overload computeResidual() and computeJacobian() instead.",
                          "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7304522",
                          "updatedAt": "2023-10-17T14:04:36Z",
                          "publishedAt": "2023-10-17T14:04:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "@roystgnr , Thank you for answer. So, do I need additional development in libmesh?",
                          "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7305023",
                          "updatedAt": "2023-10-17T14:44:46Z",
                          "publishedAt": "2023-10-17T14:44:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cbolisetti"
                          },
                          "bodyText": "I think you can do this in MOOSE without libmesh development. The current beam element implementation is almost completely in MOOSE and doesn't use much libmesh (@bwspenc please correct me if I am wrong). There are a couple of options here:\n\nYou could do a quick and dirty implementation like @roystgnr described (for the case where the stiffness matrix is not in an integral form, which is your scenario, I think). We already have a template you can start with in MASTODON in the material called LinearSpring, which can be used with line elements. This material implements a simple, diagonal stiffness matrix for a 6-dof line element. This can be extended to the stiffness matrix you provided above. I actually recommend this method to begin with. (Note that in MOOSE, we create the mesh with line elements, assign appropriate number of DOFs, and then use the Materials to model it as a beam, truss, or a spring. This is different from traditional structural engineering software.)\nYou could also extend the current beam element implementation in ComputeBeamElasticity and StressDivergenceBeam objects. This is less straightforward, since this implementation is based on a 6-dof assumption.",
                          "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7305650",
                          "updatedAt": "2023-10-17T15:46:38Z",
                          "publishedAt": "2023-10-17T15:43:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "andrey1887"
                          },
                          "bodyText": "Thank you, @cbolisetti. Is this method (using MASTODON) suitable for the case when matrix elements are specified explicity?\nIf yes, then do i need to install BlackBear with it?",
                          "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7306413",
                          "updatedAt": "2023-10-17T16:55:16Z",
                          "publishedAt": "2023-10-17T16:55:16Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "andrey1887"
                  },
                  "bodyText": "Help me please. Is it possible to use use stiffness matrix in this form \ninstead of 6x6 matrix defined in:\nComputeIncrementalBeamStrain::computeStiffnessMatrix()\n{\n  const Real youngs_modulus = _material_stiffness[0](0);\n  const Real shear_modulus = _material_stiffness[0](1);\n\n  const Real A_avg = (_area[0] + _area[1]) / 2.0;\n  const Real Iy_avg = (_Iy[0] + _Iy[1]) / 2.0;\n  const Real Iz_avg = (_Iz[0] + _Iz[1]) / 2.0;\n  Real Ix_avg = (_Ix[0] + _Ix[1]) / 2.0;\n  if (!_has_Ix)\n    Ix_avg = Iy_avg + Iz_avg;\n\n  // K = |K11 K12|\n  //     |K21 K22|\n\n  // relation between translational displacements at node 0 and translational forces at node 0\n  RankTwoTensor K11_local;\n  K11_local.zero();\n  K11_local(0, 0) = youngs_modulus * A_avg / _original_length[0];\n  K11_local(1, 1) = shear_modulus * A_avg / _original_length[0];\n  K11_local(2, 2) = shear_modulus * A_avg / _original_length[0];\n  _K11[0] = _total_rotation[0].transpose() * K11_local * _total_rotation[0];\n\n  // relation between displacements at node 0 and rotational moments at node 0\n  RankTwoTensor K21_local;\n  K21_local.zero();\n  K21_local(2, 1) = shear_modulus * A_avg * 0.5;\n  K21_local(1, 2) = -shear_modulus * A_avg * 0.5;\n  _K21[0] = _total_rotation[0].transpose() * K21_local * _total_rotation[0];\n\n  // relation between rotations at node 0 and rotational moments at node 0\n  RankTwoTensor K22_local;\n  K22_local.zero();\n  K22_local(0, 0) = shear_modulus * Ix_avg / _original_length[0];\n  K22_local(1, 1) = youngs_modulus * Iz_avg / _original_length[0] +\n                    shear_modulus * A_avg * _original_length[0] / 4.0;\n  K22_local(2, 2) = youngs_modulus * Iy_avg / _original_length[0] +\n                    shear_modulus * A_avg * _original_length[0] / 4.0;\n  _K22[0] = _total_rotation[0].transpose() * K22_local * _total_rotation[0];\n\n  // relation between rotations at node 0 and rotational moments at node 1\n  RankTwoTensor K22_local_cross = -K22_local;\n  K22_local_cross(1, 1) += 2.0 * shear_modulus * A_avg * _original_length[0] / 4.0;\n  K22_local_cross(2, 2) += 2.0 * shear_modulus * A_avg * _original_length[0] / 4.0;\n  _K22_cross[0] = _total_rotation[0].transpose() * K22_local_cross * _total_rotation[0];\n\n  // relation between displacements at node 0 and rotational moments at node 1\n  _K21_cross[0] = -_K21[0];",
                  "url": "https://github.com/idaholab/moose/discussions/25754#discussioncomment-7607853",
                  "updatedAt": "2023-11-18T18:54:07Z",
                  "publishedAt": "2023-11-18T18:54:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}