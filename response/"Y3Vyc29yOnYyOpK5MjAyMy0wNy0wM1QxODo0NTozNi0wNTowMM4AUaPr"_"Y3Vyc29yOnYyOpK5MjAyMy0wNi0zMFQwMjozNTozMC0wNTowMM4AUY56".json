{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNi0zMFQwMjozNTozMC0wNTowMM4AUY56"
    },
    "edges": [
      {
        "node": {
          "title": "Usage of crystal plasticity models in the context of global strain approach",
          "author": {
            "login": "abarun22"
          },
          "bodyText": "Dear all,\nFurther to my work on integrating the micro-structural model with a larger scale component models, progress was made earlier in enabling global strain approach to solve the micro-scale model. The link here #18380 can be referred for an understanding of the related work.  The material model however was not based upon a crystal plasticity considerations and so my recent work has focussed on selecting the appropriate finite strain CP models in MOOSE that can realistically model the constitutive behaviour at this scale. I fiddled around with \"FiniteStrainCrystalPlasticity\" based objects and get them to work along with other material modules supporting the strain periodicity implementation. I have not been successful in running the computation and the following error occurs during the stage where the material modules are referenced.\n\n*** ERROR ***\nOne or more Material Properties were not supplied on block 0:\ndeformation_gradient\n\nThe following input structure has been used.\n\n[Mesh]\n[generated_mesh]\ntype = GeneratedMeshGenerator\ndim = 3\nnx = 5\nny = 5\nnz = 5\n[]\n[cnode]\ntype = ExtraNodesetGenerator\ncoord = '0.0 0.0 0.0'\nnew_boundary = 100\ninput = generated_mesh\n[]\n[]\n[Variables]\n[./u_x]\nblock = 0\n[../]\n[./u_y]\nblock = 0\n[../]\n[./u_z]\nblock = 0\n[../]\n[./global_strain]\norder = SIXTH\nfamily = SCALAR\n[../]\n[]\n[AuxVariables]\n[./disp_x]\nblock = 0\n[../]\n[./disp_y]\nblock = 0\n[../]\n[./disp_z]\nblock = 0\n[../]\n[./s00]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./s11]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./e00]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[./e11]\norder = CONSTANT\nfamily = MONOMIAL\nblock = 0\n[../]\n[]\n[AuxKernels]\n[./disp_x]\ntype = GlobalDisplacementAux\nvariable = disp_x\nscalar_global_strain = global_strain\nglobal_strain_uo = global_strain_uo\ncomponent = 0\nblock = 0\n[../]\n[./disp_y]\ntype = GlobalDisplacementAux\nvariable = disp_y\nscalar_global_strain = global_strain\nglobal_strain_uo = global_strain_uo\ncomponent = 1\nblock = 0\n[../]\n[./disp_z]\ntype = GlobalDisplacementAux\nvariable = disp_z\nscalar_global_strain = global_strain\nglobal_strain_uo = global_strain_uo\ncomponent = 2\nblock = 0\n[../]\n[./s00]\ntype = RankTwoAux\nvariable = s00\nrank_two_tensor = stress\nindex_i = 0\nindex_j = 0\nblock = 0\n[../]\n[./s11]\ntype = RankTwoAux\nvariable = s11\nrank_two_tensor = stress\nindex_i = 1\nindex_j = 1\nblock = 0\n[../]\n[./e00]\ntype = RankTwoAux\nvariable = e00\nrank_two_tensor = total_strain\nindex_i = 0\nindex_j = 0\nblock = 0\n[../]\n[./e11]\ntype = RankTwoAux\nvariable = e11\nrank_two_tensor = total_strain\nindex_i = 1\nindex_j = 1\nblock = 0\n[../]\n[]\n[GlobalParams]\ndisplacements = 'u_x u_y u_z'\nblock = 0\n[]\n[Kernels]\n[./TensorMechanics]\n[../]\n[]\n[ScalarKernels]\n[./global_strain]\ntype = GlobalStrain\nvariable = global_strain\nglobal_strain_uo = global_strain_uo\n[../]\n[]\n[BCs]\n[./Periodic]\n[./all]\nauto_direction = 'x y z'\nvariable = ' u_x u_y u_z'\n[../]\n[../]\nfix center point location\n[./centerfix_x]\ntype = DirichletBC\nboundary = 100\nvariable = u_x\nvalue = 0\n[../]\n[./centerfix_y]\ntype = DirichletBC\nboundary = 100\nvariable = u_y\nvalue = 0\n[../]\n[./centerfix_z]\ntype = DirichletBC\nboundary = 100\nvariable = u_z\nvalue = 0\n[../]\n[]\n[Materials]\n[./crysp]\ntype = FiniteStrainCrystalPlasticity\nblock = 0\ngtol = 1e-2\nslip_sys_file_name = input_slip_sys.txt\nnss = 12\nnum_slip_sys_flowrate_props = 2 #Number of properties in a slip system\nflowprops = '1 4 0.001 0.1 5 8 0.001 0.1 9 12 0.001 0.1'\nhprops = '1.0 541.5 60.8 109.8 2.5'\ngprops = '1 4 60.8 5 8 60.8 9 12 60.8'\ntan_mod_type = exact\ngen_random_stress_flag = false\nmaximum_substep_iteration = 2\n[../]\n[./elasticity_tensor]\ntype = ComputeElasticityTensorCP\nblock = 0\nC_ijkl = '1.684e5 1.214e5 1.214e5 1.684e5 1.214e5 1.684e5 0.754e5 0.754e5 0.754e5'\nfill_method = symmetric9\n[../]\n[./strain]\ntype = ComputeSmallStrain\nglobal_strain = global_strain\nblock = 0\n[../]\n[./global_strain]\ntype = ComputeGlobalStrain\nscalar_global_strain = global_strain\nglobal_strain_uo = global_strain_uo\nblock = 0\n[../]\n[./stress]\ntype = ComputeLinearElasticStress\nblock = 0\n[../]\n[]\n[UserObjects]\n[./global_strain_uo]\ntype = GlobalStrainUserObject\napplied_stress_tensor = '5e9 0 0 0 0 0'\nexecute_on = 'Initial Linear Nonlinear'\n[../]\n[]\n[Postprocessors]\n[./l2err_e00]\ntype = ElementL2Error\nvariable = e00\nfunction = 0.07142857 #strain_xx = C1111/sigma_xx\n[../]\n[./l2err_e11]\ntype = ElementL2Error\nvariable = e11\nfunction = -0.071428570.33 #strain_yy = -nustrain_xx\n[../]\n[]\n[Preconditioning]\n[./SMP]\ntype = SMP\nfull = true\n[../]\n[]\n[Executioner]\ntype = Transient\nscheme = bdf2\nsolve_type = 'PJFNK'\nline_search = basic\npetsc_options_iname = '-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\npetsc_options_value = 'asm         31   preonly   lu      1'\nl_max_its = 30\nnl_max_its = 12\nnl_rel_tol = 1.0e-10\nnum_steps = 1\ndt = 0.01\n[]\n[Outputs]\nexodus = true\n[]\n\nI am pretty sure that i am missing certain modules here that are vital in bridging these entities together. Could anybody advise me on the right way to address the material behaviour for the problems one might enounter in crsytal plasticity simulations in the context of a RVE model solved by a global strain approach?\nKind regards,\nArun",
          "url": "https://github.com/idaholab/moose/discussions/18776",
          "updatedAt": "2023-07-03T16:42:23Z",
          "publishedAt": "2021-09-06T16:22:19Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "Hi Arun,\nWe'd recommend that you use the newer material-based Compute Multiple Crystal Plasticity Stress system. The material constitutive model, Crystal Plasticity Kalidini Update will replicate the functionality used in your input file. The ComputeMultipleCrystalPlasticityStress system is being actively developed while the FiniteStrainCrystalPlasticity is not.\nWith any of our MOOSE crystal plasticity classes, one must supply an incremental strain calculator class, usually ComputeFiniteStrain. The error you are seeing occurs because only the incremental strain calculator classes provide the deformation gradient, and ComputeSmallStrain is a total strain calculator class which does not compute a deformation gradient. Please see the regression test input file here as an example.\nI would also recommend the use of the TensorMechanicsMaster action, if it will work well with the GlobalStrain. @SudiptaBiswas  and @dschwen  would you please provide guidance here?\nBest Regards,\nStephanie",
                  "url": "https://github.com/idaholab/moose/discussions/18776#discussioncomment-1291588",
                  "updatedAt": "2022-06-16T19:01:45Z",
                  "publishedAt": "2021-09-07T15:09:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "GlobalStrain approach works with TensormechanicsMasterAction. Here is an example, https://github.com/idaholab/moose/blob/next/modules/tensor_mechanics/test/tests/global_strain/global_strain_action.i.",
                          "url": "https://github.com/idaholab/moose/discussions/18776#discussioncomment-1297225",
                          "updatedAt": "2022-06-16T19:01:45Z",
                          "publishedAt": "2021-09-08T16:29:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Hi Stephanie, Sudipta,\nThanks for the suggestions. I went further ahead with ComputeMultipleCrystalPlasticityStress and the kalidindi crystal plasticity model and also included TensormechanicsMasterAction. I've removed the GlobalStrain inside the master block just to make sure it does not mix up with ComputeGlobalStrain.  This looks quite reasonable, however throws the following error.\n\n*** ERROR ***\nThe following error occurred in the object \"MOOSE Problem\", of type \"FEProblem\".\n\nThe following material properties are declared on block 0 by multiple materials:\n  Material Property             Material Objects\n  mechanical_strain             strain stress_div_strain\n  total_strain                  strain stress_div_strain\n\nLooks like mutiple materials are trying to define the strain properties, which might need some trimming here. Here is the updated input commands for your reference.\n\n[Mesh]\n  [generated_mesh]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 5\n    ny = 5\n    nz = 5\n  []\n  [cnode]\n    type = ExtraNodesetGenerator\n    coord = '0.0 0.0 0.0'\n    new_boundary = 100\n    input = generated_mesh\n  []\n[]\n[GlobalParams]\n  displacements = 'u_x u_y u_z'\n  block = 0\n[]\n[Variables]\n  [./u_x]\n    block = 0\n  [../]\n  [./u_y]\n    block = 0\n  [../]\n  [./u_z]\n    block = 0\n  [../]\n  [./global_strain]\n    order = SIXTH\n    family = SCALAR\n  [../]\n[]\n\n[AuxVariables]\n  [./disp_x]\n    block = 0\n  [../]\n  [./disp_y]\n    block = 0\n  [../]\n  [./disp_z]\n    block = 0\n  [../]\n  [./s00]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  [../]\n  [./s11]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  [../]\n  [./e00]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  [../]\n  [./e11]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  [../]\n[]\n\n[AuxKernels]\n  [./disp_x]\n    type = GlobalDisplacementAux\n    variable = disp_x\n    scalar_global_strain = global_strain\n    global_strain_uo = global_strain_uo\n    component = 0\n    block = 0\n  [../]\n  [./disp_y]\n    type = GlobalDisplacementAux\n    variable = disp_y\n    scalar_global_strain = global_strain\n    global_strain_uo = global_strain_uo\n    component = 1\n    block = 0\n  [../]\n  [./disp_z]\n    type = GlobalDisplacementAux\n    variable = disp_z\n    scalar_global_strain = global_strain\n    global_strain_uo = global_strain_uo\n    component = 2\n    block = 0\n  [../]\n  [./s00]\n    type = RankTwoAux\n    variable = s00\n    rank_two_tensor = stress\n    index_i = 0\n    index_j = 0\n    block = 0\n  [../]\n  [./s11]\n    type = RankTwoAux\n    variable = s11\n    rank_two_tensor = stress\n    index_i = 1\n    index_j = 1\n    block = 0\n  [../]\n  [./e00]\n    type = RankTwoAux\n    variable = e00\n    rank_two_tensor = total_strain\n    index_i = 0\n    index_j = 0\n    block = 0\n  [../]\n  [./e11]\n    type = RankTwoAux\n    variable = e11\n    rank_two_tensor = total_strain\n    index_i = 1\n    index_j = 1\n    block = 0\n  [../]\n[]\n\n[ScalarKernels]\n  [./global_strain]\n    type = GlobalStrain\n    variable = global_strain\n    global_strain_uo = global_strain_uo\n  [../]\n[]\n\n[Modules]\n  [./TensorMechanics]\n    # Master action for generating the tensor mechanics kernels, variables,\n    # strain calculation material, and the auxilliary system for visualization\n    [./Master]\n      [./stress_div]\n        strain = SMALL\n        add_variables = true\n        global_strain = global_strain #global strain contribution\n        generate_output = 'strain_xx strain_xy strain_yy stress_xx stress_xy\n                           stress_yy vonmises_stress'\n      [../]\n    [../]\n  [../]\n[]\n\n[BCs]\n  [./Periodic]\n    [./all]\n      auto_direction = 'x y z'\n      variable = ' u_x u_y u_z'\n    [../]\n  [../]\n\n  [./centerfix_x]\n    type = DirichletBC\n    boundary = 100\n    variable = u_x\n    value = 0\n  [../]\n  [./centerfix_y]\n    type = DirichletBC\n    boundary = 100\n    variable = u_y\n    value = 0\n  [../]\n  [./centerfix_z]\n    type = DirichletBC\n    boundary = 100\n    variable = u_z\n    value = 0\n  [../]\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensorConstantRotationCP\n    C_ijkl = '1.684e5 1.214e5 1.214e5 1.684e5 1.214e5 1.684e5 0.754e5 0.754e5 0.754e5'\n    fill_method = symmetric9\n  [../]\n  [./stress]\n    type = ComputeMultipleCrystalPlasticityStress\n    crystal_plasticity_models = 'trial_xtalpl'\n    tan_mod_type = exact\n  [../]\n  [./trial_xtalpl]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = input_slip_sys.txt\n    tan_mod_type = exact\n  [../]\n  [./strain]\n    type = ComputeFiniteStrain\n    block = 0\n    displacements = 'u_x u_y u_z'\n  [../]\n  [./global_strain]\n    type = ComputeGlobalStrain\n    scalar_global_strain = global_strain\n    global_strain_uo = global_strain_uo\n    block = 0\n  [../]\n[]\n\n[UserObjects]\n  [./global_strain_uo]\n    type = GlobalStrainUserObject\n    applied_stress_tensor = '5e9 0 0 0 0 0'\n    execute_on = 'Initial Linear Nonlinear'\n  [../]\n[]\n\n[Postprocessors]\n  [./l2err_e00]\n    type = ElementL2Error\n    variable = e00\n    function = 0.07142857 #strain_xx = C1111/sigma_xx\n  [../]\n  [./l2err_e11]\n    type = ElementL2Error\n    variable = e11\n    function = -0.07142857*0.33 #strain_yy = -nu*strain_xx\n  [../]\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = 'PJFNK'\n\n  line_search = basic\n\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'asm         31   preonly   lu      1'\n\n  l_max_its = 30\n  nl_max_its = 12\n\n  nl_rel_tol = 1.0e-10\n  num_steps = 1\n  dt = 0.01\n[]\n\n[Outputs]\n  exodus = true\n[]\n\nAny suggestions here will be highly appreciated.\nKind regards,\nArun",
                          "url": "https://github.com/idaholab/moose/discussions/18776#discussioncomment-1303210",
                          "updatedAt": "2022-06-16T19:01:48Z",
                          "publishedAt": "2021-09-09T18:34:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sapitts"
                          },
                          "bodyText": "Hi Arun,\nOnly a couple of quick modifications to your input file ought to be all that's required to get your simulation running:\n\nRemove the entire strain block, because this class is created by the TensorMechanics master action\n\n[./strain]\n  type = ComputeFiniteStrain\n  block = 0\n  displacements = 'u_x u_y u_z'\n[../]\n\n\nChange the strain setting in the TensorMechanics master action from strain = SMALL to strain = FINITE. This modification will create the ComputeFiniteStrain class from 1. automatically\n\nBest Regards,\nStephanie",
                          "url": "https://github.com/idaholab/moose/discussions/18776#discussioncomment-1303344",
                          "updatedAt": "2022-06-16T19:02:01Z",
                          "publishedAt": "2021-09-09T18:59:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Hi Stephanie,\nThanks for the suggestion. That indeed worked. The computation however would not converge. Could be a trick thing to solve given that the original model (one without CPFE material models) runs OK.  Please find here the execution log where the computation could not seem to get past the first time step.\n\n(base) abalasub@freia013> ../../../submodel-opt -i sub_gs_uniaxial_CPFE.i | tee -a run.log\n\n\n*** Warning, This code is deprecated and will be removed in future versions:\nThe parameter 'use_legacy_dirichlet_bc' is no longer valid.\n\nAll Dirichlet boundary conditions are preset by default.\n\nRemove said parameter in main to remove this deprecation warning.\nStack frames: 11\n0: libMesh::print_trace(std::ostream&)\n1: void moose::internal::mooseDeprecatedStream >, char const (&) [62], char const (&) [59], char const (&) [26], std::__cxx11::basic_string, std::allocator > const&, char const (&) [37]>(libMesh::BasicOStreamProxy >&, bool, char const (&) [62], char const (&) [59], char const (&) [26], std::__cxx11::basic_string, std::allocator > const&, char const (&) [37])\n2: MooseApp::MooseApp(InputParameters)\n3: submodelTestApp::submodelTestApp(InputParameters)\n4: /home/abalasub/Working/Projects/submodel_repo/test/lib/libsubmodel_test-opt.so.0(+0xb0d8) [0x7fb7d98170d8]\n5: std::shared_ptr buildApp(InputParameters const&)\n6: AppFactory::createShared(std::__cxx11::basic_string, std::allocator > const&, std::__cxx11::basic_string, std::allocator > const&, InputParameters, ompi_communicator_t*)\n7: AppFactory::createAppShared(std::__cxx11::basic_string, std::allocator > const&, int, char**, ompi_communicator_t*)\n8: ../../../submodel-opt() [0x4023b2]\n9: __libc_start_main\n10: ../../../submodel-opt() [0x402658]\n\n\nFramework Information:\nMOOSE Version:           git commit 626b041 on 2021-09-05\nLibMesh Version:         ffab5c914090ad625645faa1bb4251d6b46f1c26\nPETSc Version:           3.15.1\nSLEPc Version:           3.15.1\nCurrent Time:            Fri Sep 10 15:50:38 2021\nExecutable Timestamp:    Thu Sep  9 12:15:47 2021\n\nParallelism:\n  Num Processors:          1\n  Num Threads:             1\n\nMesh:\n  Parallel Type:           replicated\n  Mesh Dimension:          3\n  Spatial Dimension:       3\n  Nodes:                   216\n  Elems:                   125\n  Num Subdomains:          1\n\nNonlinear System:\n  Num DOFs:                654\n  Num Local DOFs:          654\n  Variables:               { \"u_x\" \"u_y\" \"u_z\" } \"global_strain\"\n  Finite Element Types:    \"LAGRANGE\" \"SCALAR\"\n  Approximation Orders:    \"FIRST\" \"SIXTH\"\n\nAuxiliary System:\n  Num DOFs:                2023\n  Num Local DOFs:          2023\n  Variables:               { \"disp_x\" \"disp_y\" \"disp_z\" } { \"s00\" \"s11\" \"e00\" \"e11\" } { \"strain_xx\" \"strain_xy\"\n                             \"strain_yy\" \"stress_xx\" \"stress_xy\" \"stress_yy\" \"vonmises_stress\" }\n  Finite Element Types:    \"LAGRANGE\" \"MONOMIAL\" \"MONOMIAL\"\n  Approximation Orders:    \"FIRST\" \"CONSTANT\" \"CONSTANT\"\n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             ConstantDT\n  Solver Mode:             Preconditioned JFNK\n  MOOSE Preconditioner:    SMP\n\nLEGACY MODES ENABLED:\n This application uses the legacy material output option: material properties are output only on TIMESTEP_END, not INITIAL. To remove this message, set 'use_legacy_material_output' to false in this application. If there are gold output files that contain material property output for which output occurs on INITIAL, then these will generate diffs due to zero values being stored, and these tests should be re-golded.\n\n\n\n*** Warning ***\n/home/abalasub/Working/Projects/submodel_repo/problem/Multiapps/full_solve_multiapp_1/sub_gs_uniaxial_CPFE.i:211: unused parameter 'Materials/trial_xtalpl/tan_mod_type'\n\n\nTime Step 0, time = 0\n\nPostprocessor Values:\n+----------------+----------------+----------------+\n| time           | l2err_e00      | l2err_e11      |\n+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+----------------+\n\n\nScalar Variable Values:\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n| time           | global_strain_0| global_strain_1| global_strain_2| global_strain_3| global_strain_4| global_strain_5|\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n+----------------+----------------+----------------+----------------+----------------+----------------+----------------+\n\n\nTime Step 1, time = 0.01, dt = 0.01\n 0 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 1 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 2 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 3 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 4 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 5 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 6 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 7 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 8 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 9 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n10 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n11 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n12 Nonlinear |R| = 5.000000e+09\nNonlinear solve did not converge due to DIVERGED_MAX_IT iterations 12\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nTime Step 1, time = 0.005, dt = 0.005\n 0 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 1 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 2 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 3 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 4 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 5 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 6 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 7 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 8 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 9 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n10 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n11 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n12 Nonlinear |R| = 5.000000e+09\nNonlinear solve did not converge due to DIVERGED_MAX_IT iterations 12\n Solve Did NOT Converge!\nAborting as solve did not converge\n\nTime Step 1, time = 0.0025, dt = 0.0025\n 0 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 1 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 2 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 3 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 4 Nonlinear |R| = 5.000000e+09\n      0 Linear |R| = 5.000000e+09\n      1 Linear |R| = 5.000000e+09\n  Linear solve did not converge due to DIVERGED_BREAKDOWN iterations 1\n 5 Nonlinear |R| = 5.000000e+09\n\nThe global strains are possibly not tied to other objects of the material model in a correct manner i suppose. Probably we are missing some thing here.\nKind regards,\nArun",
                          "url": "https://github.com/idaholab/moose/discussions/18776#discussioncomment-1307426",
                          "updatedAt": "2022-10-03T01:28:52Z",
                          "publishedAt": "2021-09-10T15:04:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "SudiptaBiswas"
                          },
                          "bodyText": "Does the model converge without the global strain? The global strain approach was not tested with the crystal plasticity model before, we might need modifications regarding calculating global strain incrementally.",
                          "url": "https://github.com/idaholab/moose/discussions/18776#discussioncomment-1329168",
                          "updatedAt": "2022-10-03T05:13:19Z",
                          "publishedAt": "2021-09-14T17:48:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Hi Sudipta,\nYes the computation runs OK without global strain approach. Here are the trimmed input commands sans the global strain modules.\nAs you said, we might need the modifications for incremental global strain. I really do not have much idea how long the implementation would take. Do you reckon if this can be done quickly?\n\n[Mesh]\n  [generated_mesh]\n    type = GeneratedMeshGenerator\n    dim = 3\n    nx = 5\n    ny = 5\n    nz = 5\n  []\n  [cnode]\n    type = ExtraNodesetGenerator\n    coord = '0.0 0.0 0.0'\n    new_boundary = 100\n    input = generated_mesh\n  []\n[]\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  block = 0\n[]\n\n[AuxVariables]\n  [./s00]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  [../]\n  [./s11]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  [../]\n  [./e00]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  [../]\n  [./e11]\n    order = CONSTANT\n    family = MONOMIAL\n    block = 0\n  [../]\n[]\n\n[AuxKernels]\n  [./s00]\n    type = RankTwoAux\n    variable = s00\n    rank_two_tensor = stress\n    index_i = 0\n    index_j = 0\n    block = 0\n  [../]\n  [./s11]\n    type = RankTwoAux\n    variable = s11\n    rank_two_tensor = stress\n    index_i = 1\n    index_j = 1\n    block = 0\n  [../]\n  [./e00]\n    type = RankTwoAux\n    variable = e00\n    rank_two_tensor = total_strain\n    index_i = 0\n    index_j = 0\n    block = 0\n  [../]\n  [./e11]\n    type = RankTwoAux\n    variable = e11\n    rank_two_tensor = total_strain\n    index_i = 1\n    index_j = 1\n    block = 0\n  [../]\n[]\n\n[Modules]\n  [./TensorMechanics]\n    # Master action for generating the tensor mechanics kernels, variables,\n    # strain calculation material, and the auxilliary system for visualization\n    [./Master]\n      [./stress_div]\n        strain = FINITE\n        add_variables = true\n        displacements = 'disp_x disp_y disp_z'\n        generate_output = 'strain_xx strain_xy strain_yy stress_xx stress_xy\n                           stress_yy vonmises_stress'\n      [../]\n    [../]\n  [../]\n[]\n\n[BCs]\n  [./symmy]\n    type = DirichletBC\n    variable = disp_y\n    boundary = bottom\n    value = 0\n  [../]\n  [./symmx]\n    type = DirichletBC\n    variable = disp_x\n    boundary = left\n    value = 0\n  [../]\n  [./symmz]\n    type = DirichletBC\n    variable = disp_z\n    boundary = back\n    value = 0\n  [../]\n  [./tdisp]\n    type = FunctionDirichletBC\n    variable = disp_z\n    boundary = front\n    function = '0.01*t'\n  [../]\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeElasticityTensorConstantRotationCP\n    C_ijkl = '1.684e5 1.214e5 1.214e5 1.684e5 1.214e5 1.684e5 0.754e5 0.754e5 0.754e5'\n    fill_method = symmetric9\n    euler_angle_1 = 120.0\n    euler_angle_2 = 125.264\n    euler_angle_3 =  45.0\n  [../]\n\n  [./stress]\n    type = ComputeMultipleCrystalPlasticityStress\n    crystal_plasticity_models = 'trial_xtalpl'\n    tan_mod_type = exact\n  [../]\n  [./trial_xtalpl]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = input_slip_sys.txt\n    tan_mod_type = exact\n  [../]\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = 'PJFNK'\n\n  line_search = basic\n\n  petsc_options_iname = '-pc_type -ksp_gmres_restart -sub_ksp_type -sub_pc_type -pc_asm_overlap'\n  petsc_options_value = 'asm         31   preonly   lu      1'\n\n  l_max_its = 30\n  nl_max_its = 12\n\n  nl_rel_tol = 1.0e-10\n  num_steps = 5\n  dt = 0.01\n[]\n\n[Outputs]\n  exodus = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18776#discussioncomment-1332471",
                          "updatedAt": "2022-10-03T05:13:19Z",
                          "publishedAt": "2021-09-15T09:58:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Hi Sudipta,\nI am keen to drive this forward. At the moment i do not have much idea about the extent of modifications needed for the work (global strain in incremental setting) and so its hard for me to arrive at an approximate time estimate. You might be in a better position to address the requirements and come up with a time frame. Probably you could initiate proceedings and show me the path, i could then see if the implmentation can be taken up parallel to my current work.",
                          "url": "https://github.com/idaholab/moose/discussions/18776#discussioncomment-1395656",
                          "updatedAt": "2022-10-03T05:13:28Z",
                          "publishedAt": "2021-09-28T11:34:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "abarun22"
                          },
                          "bodyText": "Hi Sudipta,\nTime has come for me to work on this piece of activity again. What i need from you at this stage is some minimal advise on how to enable the strains calculated by the global strain modules in an incremental manner, so that it blends nicely with the other computation modules, working under a time stepping set up.\nI look forward to hear your response.\nThanks and regards,\nArun",
                          "url": "https://github.com/idaholab/moose/discussions/18776#discussioncomment-6345876",
                          "updatedAt": "2023-07-03T16:42:24Z",
                          "publishedAt": "2023-07-03T16:42:23Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "restart simultations with adaptive mesh",
          "author": {
            "login": "lyyc199586"
          },
          "bodyText": "A general queation about restart/ recover: is it possible to restart a simulation with adaptive mesh?",
          "url": "https://github.com/idaholab/moose/discussions/24890",
          "updatedAt": "2023-07-03T16:24:49Z",
          "publishedAt": "2023-07-03T16:19:15Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "Yes, it is.",
                  "url": "https://github.com/idaholab/moose/discussions/24890#discussioncomment-6345732",
                  "updatedAt": "2023-07-03T16:22:54Z",
                  "publishedAt": "2023-07-03T16:22:54Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "Great! how to do that? do I have to specify the exodus file? (like exodus.e-s001)",
                          "url": "https://github.com/idaholab/moose/discussions/24890#discussioncomment-6345744",
                          "updatedAt": "2023-07-03T16:24:49Z",
                          "publishedAt": "2023-07-03T16:24:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Gradual relaxation of dirichlet BCs",
          "author": {
            "login": "Edward-Eth"
          },
          "bodyText": "Hi, I am running a plastic simulation driven by a tip displacement, which due to the finite strain implementation, is applied gradually over a few time steps, which works nicely. At the end of the simulation I need to be able to release this BC, to example resultant permanent deformation, however, just as instantly applying the tip load leads to issues with the finite strain implementation, instantly releasing it also causes divergence on the final step.\nHow would I gradually release the load? This is not equivalent to gradually dropping the tip displacement to 0 which would be simple, but rather removing the enforcement in a way that doesn't resulting a shock change that destabilises the model\nThis is my current input:\n[Mesh]\n  [GenerateBeam]\n    type = GeneratedMeshGenerator\n    dim = 3\n    elem_type = HEX8\n    xmax = 500\n    ymax = 25\n    zmax = 25\n    nx = 100\n    ny = 5\n    nz = 5\n  []\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n  large_kinematics = true\n[]\n\n[Variables]\n  [disp_x]\n  []\n  [disp_y]\n  []\n  [disp_z]\n  []\n[]\n\n[AuxVariables]\n  [vonMises]\n    family = MONOMIAL\n    order = CONSTANT\n    [AuxKernel]\n      type = RankTwoScalarAux\n      rank_two_tensor = cauchy_stress\n      variable = vonmises\n      scalar_type = VonMisesStress\n      execute_on = timestep_end\n    []\n  []\n  [plasticStrain]\n    family = MONOMIAL\n    order = CONSTANT\n    [AuxKernel]\n      type = MaterialRealAux\n      property = effective_plastic_strain\n      variable = plasticStrain\n      execute_on = 'TIMESTEP_END'\n    []\n  []\n  [totalStrain]\n    family = MONOMIAL\n    order = CONSTANT\n    [AuxKernel]\n      type = RankTwoScalarAux\n      variable = totalStrain\n      scalar_type = L2norm\n      rank_two_tensor = total_strain\n      execute_on = 'TIMESTEP_END'\n    []\n  []\n[]\n\n[Kernels]\n  [sdx]\n    type = TotalLagrangianStressDivergence\n    variable = disp_x\n    component = 0\n  []\n  [sdy]\n    type = TotalLagrangianStressDivergence\n    variable = disp_y\n    component = 1\n  []\n  [sdz]\n    type = TotalLagrangianStressDivergence\n    variable = disp_z\n    component = 2\n  []\n[]\n\n[Materials]\n  [Elasticity]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 110000\n    shear_modulus = 42000\n  []\n  [flow_stress]\n    type = DerivativeParsedMaterial\n    f_name = flow_stress\n    function = '850+275*(effective_plastic_strain+0.0001)^0.21'\n    material_property_names = 'effective_plastic_strain'\n    additional_derivative_symbols = 'effective_plastic_strain'\n    derivative_order = 2\n    compute = false\n  []\n  [plasticStress]\n    type = ComputeSimoHughesJ2PlasticityStress\n    flow_stress_material = flow_stress\n  []\n  [Strain]\n    type = ComputeLagrangianStrain\n  []\n[]\n\n[BCs]\n  [Fixed_X]\n    type = DirichletBC\n    boundary = 'left'\n    value = 0\n    variable = disp_x\n  []\n  [Fixed_Y]\n    type = DirichletBC\n    boundary = 'left'\n    value = 0\n    variable = disp_y\n  []\n  [Fixed_Z]\n    type = DirichletBC\n    boundary = 'left'\n    value = 0\n    variable = disp_z\n  []\n  [Tip_Displacement]\n    type = FunctionDirichletBC\n    boundary = 'right'\n    variable = disp_z\n    function = t*50\n    preset = false\n  []\n[]\n\n[Controls]\n  [TimePeriod]\n    type = TimePeriod\n    enable_objects = 'BCs::Tip_Displacement'\n    start_time = '0'\n    end_time = '1.0'\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  dt = 0.1\n\n  end_time = 1.1\n\n  automatic_scaling = true\n  solve_type = 'NEWTON'\n\n  nl_abs_tol = 5e-13\n  nl_rel_tol = 1e-08\n\n  line_search = none\n\n  petsc_options_iname = '-pc_type  -pc_hypre_type'\n  petsc_options_value = 'hypre   boomeramg'\n\n  [Predictor]\n    type = SimplePredictor\n    scale = 1\n  []\n\n[]\n\n[Postprocessors]\n  [Stress]\n    type = PointValue\n    point = '5 25 25'\n    variable = vonMises\n  []\n  [TotalStrain]\n    type = PointValue\n    point = '5 25 25'\n    variable = totalStrain\n  []\n  [PlasticStrain]\n    type = PointValue\n    point = '5 25 25'\n    variable = plasticStrain\n  []\n[]\n\n[Outputs]\n  [Exodus]\n    type = Exodus\n  []\n  [Performance]\n    type = PerfGraphOutput\n  []\n[]",
          "url": "https://github.com/idaholab/moose/discussions/22891",
          "updatedAt": "2023-07-03T15:17:33Z",
          "publishedAt": "2022-12-06T10:59:39Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Restart is what you need here. When you restart the simulation, replace the Dirichlet BC with a Neumann BC. The value of the Neumann BC will initially match the reaction force from the previous simulation on the boundary, then ramp down the Neumann BC over time.",
                  "url": "https://github.com/idaholab/moose/discussions/22891#discussioncomment-4322732",
                  "updatedAt": "2022-12-06T12:37:35Z",
                  "publishedAt": "2022-12-06T12:37:34Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "j-bowhay"
                          },
                          "bodyText": "@hugary1995 how do you ensure the Neumann BC initially matches the reaction force?",
                          "url": "https://github.com/idaholab/moose/discussions/22891#discussioncomment-6282158",
                          "updatedAt": "2023-06-26T13:15:17Z",
                          "publishedAt": "2023-06-26T13:15:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "In the first simulation, you can tag the residual vector and output it to an auxvariable. In the second simulation, you can apply a NeumannBC whose values are coupled to the previously saved auxvariable.",
                          "url": "https://github.com/idaholab/moose/discussions/22891#discussioncomment-6282583",
                          "updatedAt": "2023-06-26T13:54:22Z",
                          "publishedAt": "2023-06-26T13:54:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "j-bowhay"
                          },
                          "bodyText": "@hugary1995 thanks for the answer, please could you clarify what you mean by 'tag the residual vector'?",
                          "url": "https://github.com/idaholab/moose/discussions/22891#discussioncomment-6282655",
                          "updatedAt": "2023-06-26T14:02:38Z",
                          "publishedAt": "2023-06-26T14:02:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Sure. I was referring to the Tagging System (https://mooseframework.inl.gov/framework_development/tagging.html).\nDoFs associated with constraints (e.g. Dirichlet BCs) will have non-zero residual upon convergence. Such residual is the reaction force you want to apply in the restart simulation. You can \"tag\" a system vector which stores the residuals, and then use a TagVectorAux to output the tagged vector to auxvariables.\nTake a look at the example at modules/tensor_mechanics/test/tests/torque_reaction/torque_reaction.i.",
                          "url": "https://github.com/idaholab/moose/discussions/22891#discussioncomment-6282844",
                          "updatedAt": "2023-06-26T14:19:37Z",
                          "publishedAt": "2023-06-26T14:19:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "j-bowhay"
                          },
                          "bodyText": "Thanks @hugary1995. I want to validate that I have setup the tagging correctly by comparing to the SidesetReaction postprocessor. Should I be able to integrate saved_x, for example, over the sideset to get the same value?",
                          "url": "https://github.com/idaholab/moose/discussions/22891#discussioncomment-6283597",
                          "updatedAt": "2023-06-26T15:33:33Z",
                          "publishedAt": "2023-06-26T15:33:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yes, they should match. If not we should investigate.",
                          "url": "https://github.com/idaholab/moose/discussions/22891#discussioncomment-6283684",
                          "updatedAt": "2023-06-26T15:43:03Z",
                          "publishedAt": "2023-06-26T15:43:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "j-bowhay"
                          },
                          "bodyText": "@hugary1995 Interestingly using the SideIntegralVariablePostprocessor to integrate over the sideset doesn't seem to quite give the same result. I have modified the test input file as bellow:\n# Scalar torque reaction\n\n# This test computes the sum of the torques acting on a ten element 2D bar mesh\n# and is intended to replicate the classical wrench problem from statics.\n# A displacement in the y along the right face is applied to the bar end to create\n# a shear force along the bar end. The rotation origin default (the global origin)\n# and the axis of rotation direction vector used to compute the torque reaction\n# is set to (0, 0, 1) out of the plane.\n# Torque is calculated for the two nodes on the left of the bar. For the bottom\n# node on the right, the torque/ moment lever is the x coordinate value, and for\n# the top node on the right the torque lever is the hypotenuse of the x and y\n# coordinates.  The expected sum of the torque reaction is just over 37.\n\n[GlobalParams]\n  order = FIRST\n  family = LAGRANGE\n  displacements = 'disp_x disp_y'\n[]\n\n[Mesh]\n  type = GeneratedMesh\n  dim = 2\n  nx = 10\n  ny = 10\n  xmax = 1\n  ymax = 1\n[]\n\n[Problem]\n  extra_tag_vectors = 'ref'\n[]\n\n[AuxVariables]\n  [saved_x]\n  []\n  [saved_y]\n  []\n[]\n\n[AuxKernels]\n  [saved_x]\n    type = TagVectorAux\n    vector_tag = 'ref'\n    v = 'disp_x'\n    variable = 'saved_x'\n  []\n  [saved_y]\n    type = TagVectorAux\n    vector_tag = 'ref'\n    v = 'disp_y'\n    variable = 'saved_y'\n  []\n[]\n\n[Modules/TensorMechanics/Master]\n  [master]\n    strain = FINITE\n    generate_output = 'stress_xx stress_yy'\n    add_variables = true\n    extra_vector_tags = 'ref'\n  []\n[]\n\n[BCs]\n  [./left_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = left\n    value = 0.0\n  [../]\n  [./left_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = left\n    value = 0.0\n  [../]\n  [./right_shear_y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = right\n    function = '0.001*t'\n  [../]\n[]\n\n[Materials]\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 207000\n    poissons_ratio = 0.3\n  []\n  [stress]\n    type = ComputeFiniteStrainElasticStress\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  line_search = 'none'\n\n  l_max_its = 30\n  nl_max_its = 20\n  nl_abs_tol = 1e-12\n  nl_rel_tol = 1e-10\n  l_tol = 1e-8\n\n  start_time = 0.0\n  dt = 0.5\n\n  end_time = 1\n  num_steps = 2\n[]\n\n[Postprocessors]\n  [react_y]\n    type = SidesetReaction\n    direction = '0 1 0'\n    stress_tensor = stress\n    boundary = right\n  []\n  [tagged_calc]\n    type = SideIntegralVariablePostprocessor\n    variable = saved_y\n    boundary = right\n  []\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n[]\n\nThis gives an answer out by ~10x which is the number of elements in the y direction:\nPostprocessor Values:\n+----------------+----------------+----------------+\n| time           | react_y        | tagged_calc    |\n+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-01 |   1.589230e+01 |   1.588031e+00 |\n|   1.000000e+00 |   3.178462e+01 |   3.176061e+00 |\n+----------------+----------------+----------------+",
                          "url": "https://github.com/idaholab/moose/discussions/22891#discussioncomment-6290431",
                          "updatedAt": "2023-06-27T08:09:00Z",
                          "publishedAt": "2023-06-27T08:08:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Can you try NodalSum instead of SideIntegralVariablePostprocessor?",
                          "url": "https://github.com/idaholab/moose/discussions/22891#discussioncomment-6290447",
                          "updatedAt": "2023-06-27T08:10:26Z",
                          "publishedAt": "2023-06-27T08:10:26Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "j-bowhay"
                          },
                          "bodyText": "Thanks, nodal sum gives approximately the same answer.\nPostprocessor Values:\n+----------------+----------------+----------------+\n| time           | react_y        | tagged_calc    |\n+----------------+----------------+----------------+\n|   0.000000e+00 |   0.000000e+00 |   0.000000e+00 |\n|   5.000000e-01 |   1.589230e+01 |   1.605956e+01 |\n|   1.000000e+00 |   3.178462e+01 |   3.211911e+01 |\n+----------------+----------------+----------------+\n\nWhat causes this difference? I was under the impression from the docs that SidesetReaction was an integral not a sum.",
                          "url": "https://github.com/idaholab/moose/discussions/22891#discussioncomment-6290487",
                          "updatedAt": "2023-06-27T08:14:54Z",
                          "publishedAt": "2023-06-27T08:14:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "j-bowhay"
                          },
                          "bodyText": "@hugary1995 apologies another question, if I use automatic scaling in my executioner the residuals are scaled and hence are different to the SidesetReaction post processor. Does this matter for coupling to a NeumannBC?",
                          "url": "https://github.com/idaholab/moose/discussions/22891#discussioncomment-6291839",
                          "updatedAt": "2023-06-27T10:04:58Z",
                          "publishedAt": "2023-06-27T10:04:58Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A problem with 'ADSoretCoeffTest' in \"Misc\" Modules",
          "author": {
            "login": "sinaheidari22"
          },
          "bodyText": "Hello everyone,\nHappy new year to you,\nI was trying to run 'ad_thermo_diffusion.i'  input file which is available in this address: modules/misc/test/tests/kernels/thermo_diffusion/ad_thermo_diffusion.i\nI got this error:\n\n*** ERROR ***A 'ADSoretCoeffTest' is not a registered object.\nIf you are trying to find this object in a dynamically linked library, make sure thatthe library can be found either in your \"Problem/library_path\" parameter or in the MOOSE_LIBRARY_PATH environment variable.\n\n====================================================\nCan you please advise on that,\nThank you in advance.",
          "url": "https://github.com/idaholab/moose/discussions/16605",
          "updatedAt": "2023-07-03T08:01:53Z",
          "publishedAt": "2021-01-03T18:20:42Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHappy New Year to you too!\nI think ADSoretCoeffTest is a test object, so a regular moose executable might not be linked to a library that contains it.\nWhich executable are you using to run this test? The one built in the misc folder?\nIf this material object is the one you need, you can just move the source code in modules/misc/test/src/materials/ADSoretCoeffTest.C to modules/misc/src/materials/ADSoretCoeffTest.C, same for the header. Then it will be compiled in the module.\nBest,\nGuillaume\nEDIT See logan's answer",
                  "url": "https://github.com/idaholab/moose/discussions/16605#discussioncomment-259134",
                  "updatedAt": "2022-07-18T19:59:29Z",
                  "publishedAt": "2021-01-04T00:45:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sinaheidari22"
                          },
                          "bodyText": "Thank you for your reply.",
                          "url": "https://github.com/idaholab/moose/discussions/16605#discussioncomment-260416",
                          "updatedAt": "2022-07-18T19:59:38Z",
                          "publishedAt": "2021-01-04T16:22:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "You can use an application\u2019s test objects by passing the --allow-test-objects command line flag when you call the executable.\nTest objects are meant to be used in testing only. If you wish to use them in a production environment, we recommend creating your own application and creating an object specific for your needs.",
                  "url": "https://github.com/idaholab/moose/discussions/16605#discussioncomment-260226",
                  "updatedAt": "2022-07-18T19:59:38Z",
                  "publishedAt": "2021-01-04T15:11:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sinaheidari22"
                          },
                          "bodyText": "Thank you for your reply, I did like that and had successful run.",
                          "url": "https://github.com/idaholab/moose/discussions/16605#discussioncomment-260424",
                          "updatedAt": "2022-07-18T19:59:37Z",
                          "publishedAt": "2021-01-04T16:24:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ZJYZXH"
                          },
                          "bodyText": "Hello, I have such a mistake in the program I created, how should I solve it?",
                          "url": "https://github.com/idaholab/moose/discussions/16605#discussioncomment-1699937",
                          "updatedAt": "2022-07-18T19:59:37Z",
                          "publishedAt": "2021-11-25T12:11:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Please create your own discussions post. And paste the error message there. If it s the same object missing, it s the same solution Logan wrote down here",
                          "url": "https://github.com/idaholab/moose/discussions/16605#discussioncomment-1700047",
                          "updatedAt": "2022-07-18T19:59:38Z",
                          "publishedAt": "2021-11-25T12:26:25Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "aaaaaaqing"
                          },
                          "bodyText": "i cant understand \uff0cwhat should we do",
                          "url": "https://github.com/idaholab/moose/discussions/16605#discussioncomment-6341519",
                          "updatedAt": "2023-07-03T08:01:54Z",
                          "publishedAt": "2023-07-03T08:01:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Not a registered object error",
          "author": {
            "login": "mohbarka"
          },
          "bodyText": "Good mooring Moose community,\nI am trying to create  a new  kernel for coupled  Moisture chloride diffusion in concrete and. when I run the  example  I get this error\n** ERROR ***\nA 'ConcreteMoistureTimeIntegration' is not a registered object.\nIf you are trying to find this object in a dynamically linked library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable\nCan anyone have any idea what could be wrong?  below show what I have  in both C ,and f files\nThank you!\nC file\n#include \"ConcreteMoistureTimeIntegration.h\"\n#include \"Material.h\"\nregisterMooseObject(\"MooseTestApp\", ConcreteMoistureTimeIntegration);\ntemplate <>\nInputParameters\nvalidParams()\n{\nInputParameters params = validParams();\nreturn params;\n}\nh file\n#pragma once\n#include \"TimeDerivative.h\"\n// Forward Declaration\nclass ConcreteMoistureTimeIntegration;\ntemplate <>\nInputParameters validParams();",
          "url": "https://github.com/idaholab/moose/discussions/16921",
          "updatedAt": "2023-07-03T07:14:14Z",
          "publishedAt": "2021-02-08T17:12:51Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "aeslaughter"
                  },
                  "bodyText": "You are registering to \"MooseTestApp\", but you should be registering it to the application you created.\nhttps://mooseframework.inl.gov/getting_started/new_users.html",
                  "url": "https://github.com/idaholab/moose/discussions/16921#discussioncomment-355557",
                  "updatedAt": "2022-07-01T23:16:35Z",
                  "publishedAt": "2021-02-10T06:51:18Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aaaaaaqing"
                          },
                          "bodyText": "cant understand u say\uff0cwhat should we do",
                          "url": "https://github.com/idaholab/moose/discussions/16921#discussioncomment-6341150",
                          "updatedAt": "2023-07-03T07:14:31Z",
                          "publishedAt": "2023-07-03T07:14:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Restart with deformed and pre-stressed body",
          "author": {
            "login": "feltner515"
          },
          "bodyText": "Hi Moose forum!\nI am having issues with utilizing restart in the context of the tensor mechanics module of moose. Basically, my goal is to begin with a simulation where an elastic indenter is driven into an elasto-plastic substrate. This works no problem. The state of the substrate at the end of simulation 1 should be the initial condition in simulation 2, where the original indenter is deleted and replaced with another indenter at a different position and of a different size. I can project the stress, strain, and displacement information from simulation 1 onto simulation 2 by using auxvariables and variables respectively, but as soon as the simulation begins, the substrate reverts to a stress free state, but remains displaced. I think that I am missing some initialization within either the tensor mechanics master kernel or the plasticity auxkernels, but am having trouble finding where the issue is. Any help would be greatly appreciated!\nTwoDIndenter.zip\nThank you\nLangdon",
          "url": "https://github.com/idaholab/moose/discussions/24760",
          "updatedAt": "2023-07-03T03:28:29Z",
          "publishedAt": "2023-06-21T15:58:16Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Hi Langdon, elastoplasticity has history dependent internal variables such as the plastic strain. If you don't initialize the plastic strain in the second simulation properly, the substrate will become elastic and reverts to a (nearly) stress free state.",
                  "url": "https://github.com/idaholab/moose/discussions/24760#discussioncomment-6266215",
                  "updatedAt": "2023-06-23T21:27:52Z",
                  "publishedAt": "2023-06-23T21:27:52Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "feltner515"
                          },
                          "bodyText": "Hello and thank you for your response! Within the tensor mechanics master kernel, are the elastic and plastic strain stored as separate auxiliary variables that I can make sure are written to the exodus file? I couldn't find in the documentation a convenient way to initialize those as separate entities.",
                          "url": "https://github.com/idaholab/moose/discussions/24760#discussioncomment-6266407",
                          "updatedAt": "2023-06-23T22:04:03Z",
                          "publishedAt": "2023-06-23T22:04:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nThey are not written to the exodus file, which is why you need to use the Checkpoint restart instead of the exodus one\nUse checkpoint = true in [Outputs]\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24760#discussioncomment-6266468",
                          "updatedAt": "2023-06-23T22:20:41Z",
                          "publishedAt": "2023-06-23T22:20:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "feltner515"
                          },
                          "bodyText": "Got it, but is there a way I can make the checkpoint work with changing the size and location of the indenter from simulation-to-simulation? My understanding is that the checkpoint restart does not play with changing the mesh. I suppose I can re-break the mesh into blocks and rescale the mesh of the indenter and translate it at each time-step. Do you think this is the easiest course of action?",
                          "url": "https://github.com/idaholab/moose/discussions/24760#discussioncomment-6266488",
                          "updatedAt": "2023-06-23T22:24:33Z",
                          "publishedAt": "2023-06-23T22:24:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "no not currently. Checkpoint cannot be used if the mesh is changed.\nYou will have to try to restart in the same mesh, then modify the mesh",
                          "url": "https://github.com/idaholab/moose/discussions/24760#discussioncomment-6266513",
                          "updatedAt": "2023-06-23T22:32:48Z",
                          "publishedAt": "2023-06-23T22:32:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "feltner515"
                          },
                          "bodyText": "Got it, thank you very much for your time!",
                          "url": "https://github.com/idaholab/moose/discussions/24760#discussioncomment-6266544",
                          "updatedAt": "2023-06-23T22:41:32Z",
                          "publishedAt": "2023-06-23T22:41:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yeah, that's why I didn't mention checkpoint at first... I think you are in the right direction. My suggestion for you is to save all history dependent data as auxvariables, and then restart the simulation (with a different indenter location) and manually reinitialize those data from the auxvariables.\nTo output properties into exodus, add \"outputs = exodus\" in every material object. It sounds like you already know how to read those variables back in in the subsequent simulation. The final challenge is to modify the source code to \"reinitialize\" the data. The method you need to modify is called initQpStatefulProperties.",
                          "url": "https://github.com/idaholab/moose/discussions/24760#discussioncomment-6266581",
                          "updatedAt": "2023-06-23T22:51:18Z",
                          "publishedAt": "2023-06-23T22:51:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "feltner515"
                          },
                          "bodyText": "Understood. So is the goal of editing initQpStatefulProperties to make sure that the auxvariables I initialize are properly recognized by the kernel as the initial conditions for the computation?",
                          "url": "https://github.com/idaholab/moose/discussions/24760#discussioncomment-6266644",
                          "updatedAt": "2023-06-23T23:10:33Z",
                          "publishedAt": "2023-06-23T23:10:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "ya, you'll want to\n\ncouple the appropriate auxvariables to the material object and\ninitialize the values of the history dependent material property using the values of the auxvariables (which are reloaded from the previous simulation).\n\nThere may be quite many properties to initialize this way, now that I think more about it...\nNow, let's change the topic entirely. There is indeed a way that checkpoint-restart may work for you. The trick is to modify the mesh at run time (that's actually what @GiudGiud was suggesting -- now I understand). So in theory you should be able to\n\nCreate a mesh that has the substrate + the first indenter + the second indenter\nIn the first simulation, activate the first indenter and deactivate the second indenter.\nIn the second simulation, start from the latest checkpoint, deactivate the first indenter and activate the second indenter.\n\nThe way to \"activate/deactivate\" an indenter (or in other words, part of the mesh) at run time is using the element subdomain modifiers. There is one object called CoupledVarThresholdElementSubdomainModifer that you can play with.",
                          "url": "https://github.com/idaholab/moose/discussions/24760#discussioncomment-6266722",
                          "updatedAt": "2023-06-23T23:32:22Z",
                          "publishedAt": "2023-06-23T23:32:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I am very interested to learn whether this element subdomain modifier works for you -- keep me posted. Once it works, I'd like to add an animation to our homepage gallery if you okay with sharing.",
                          "url": "https://github.com/idaholab/moose/discussions/24760#discussioncomment-6266733",
                          "updatedAt": "2023-06-23T23:35:41Z",
                          "publishedAt": "2023-06-23T23:35:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "feltner515"
                          },
                          "bodyText": "That sounds like the way to go! I will do some reading up on that object and try it out. Thank you for all of your help gentlemen!",
                          "url": "https://github.com/idaholab/moose/discussions/24760#discussioncomment-6266736",
                          "updatedAt": "2023-06-23T23:36:41Z",
                          "publishedAt": "2023-06-23T23:36:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to obtain material properties from three time steps ago?",
          "author": {
            "login": "tttsss-01"
          },
          "bodyText": "getMaterialPropertyOld and getMaterialPropertyOlder can retrieve material properties from the previous one and two time steps, respectively. How can I obtain material properties from three time steps ago or even earlier?",
          "url": "https://github.com/idaholab/moose/discussions/24884",
          "updatedAt": "2023-07-06T04:11:51Z",
          "publishedAt": "2023-07-02T02:19:49Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI m afraid we dont have that one!\nYou could hack it though.\nUse a material property which's sole job is to store the old property of another material property.\nThen older for that one gives you the 3x old of the one you care about.\n@lindsayad for awareness\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24884#discussioncomment-6339056",
                  "updatedAt": "2023-07-02T23:44:28Z",
                  "publishedAt": "2023-07-02T23:44:27Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "loganharbour"
                  },
                  "bodyText": "We can actually do this with #24673 (merged) and a small change to what the max state allowed is (currently \"older\"))\nWhat is the use case here? Why do you need such old properties?",
                  "url": "https://github.com/idaholab/moose/discussions/24884#discussioncomment-6339947",
                  "updatedAt": "2023-07-03T03:26:03Z",
                  "publishedAt": "2023-07-03T03:26:03Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about ADPenaltyConstraint",
          "author": {
            "login": "TheGreatCid"
          },
          "bodyText": "Hi all,\nI am trying to fix an issue I am having with the ADPenaltyConstraint type. I generated an MWE to display the issue.\nI generate two square meshes, which are then combined using CombinerGenerator. I apply a displacement BC to the top of one of the meshes and fix the bottom of the other. The meshes are held together by two ADPenaltyConstaint blocks. One for the x displacement and one for the y displacement. The Y displacement seems to hold fine between the two, but the x direction seems to be fixed between the domains, as pictured below. The middle of the sample should contract due to the Poisson effect, but that is not what I am seeing.\n\nHere is the input file\nE = 207e3\n\npenalty = 1e8\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n[Mesh] \n  [bot]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 4\n    ny = 4\n    xmax = 1\n    ymax = 1\n  []\n  [block_bot]\n    type = RenameBlockGenerator\n    input = bot\n    old_block = 0\n    new_block = 'bot_block'\n  []\n  [rename_bot]\n    type = RenameBoundaryGenerator\n    input = block_bot\n    old_boundary = 'top'\n    new_boundary = 'bot_top'\n  []\n  [mid]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 4\n    ny = 4\n    ymin = 1\n    xmax = 1\n    ymax = 2\n    boundary_id_offset = 10\n  []\n  [rename_mid]\n    type = RenameBoundaryGenerator\n    input = mid\n    old_boundary = 'bottom'\n    new_boundary = 'mid_bottom'\n  []\n  [combine]\n    type = CombinerGenerator\n    inputs = 'rename_bot rename_mid'\n  []\n  [secondary]\n    type = LowerDBlockFromSidesetGenerator\n    input = combine\n    sidesets = 'mid_bottom'\n    new_block_id = 102\n    new_block_name = \"secondary\"\n  []\n  [primary]\n    type = LowerDBlockFromSidesetGenerator\n    input = secondary\n    sidesets = 'bot_top'\n    new_block_id = 103\n    new_block_name = \"primary\"\n  []\n[]\n[Constraints]\n  [mortar_x1]\n    type = ADPenaltyEqualValueConstraint\n    secondary_boundary = 'mid_bottom'\n    primary_boundary = 'bot_top'\n    primary_subdomain = 'primary'\n    secondary_subdomain = 'secondary'\n    secondary_variable = disp_x\n    penalty_value = ${penalty}\n    use_displaced_mesh = True\n  []\n  [mortar_y1]\n    type = ADPenaltyEqualValueConstraint\n    secondary_boundary = 'mid_bottom'\n    primary_boundary = 'bot_top'\n    primary_subdomain = 'primary'\n    secondary_subdomain = 'secondary'\n    secondary_variable = disp_y\n    penalty_value = ${penalty}\n    use_displaced_mesh = True\n  []\n[]\n\n[BCs]\n  [fix_bot]\n    type = ADDirichletBC\n    variable = disp_y\n    value = 0\n    boundary = bottom\n    preset = false\n  []\n  [fix_left]\n    type = ADDirichletBC\n    variable = disp_x\n    value = 0\n    boundary = bottom\n    preset = false\n  []\n  [func]\n    type = ADFunctionDirichletBC\n    variable = disp_y\n    boundary = top\n    function = '0.1*t'\n    preset = false\n  []\n[]\n[Modules/TensorMechanics/DynamicMaster]\n  [all]\n    add_variables = true\n    strain = SMALL\n    incremental = true\n    generate_output = 'stress_yy stress_xx stress_xy stress_yz'\n    use_automatic_differentiation = true\n    decomposition_method = EigenSolution\n    density = 7000\n  []\n[]\n\n[Materials]\n\n  [elasticity_tensor]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = ${E}\n    poissons_ratio = 0.3\n  []\n  [stress]\n    type = ADComputeLinearElasticStress\n  []\n[]\n[Executioner]\n  type = Transient\n  end_time = 3000\n  line_search = none\n  solve_type = NEWTON\n  dtmin = 1e-20\n  nl_max_its = 25\n  nl_rel_tol = 1e-15\n  nl_abs_tol = 1e-10\n\n  [TimeStepper]\n    type = ConstantDT\n    dt = 0.1\n  []\n  [TimeIntegrator]\n    type = NewmarkBeta\n  []\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n  automatic_scaling = true\n\n[]\n[Outputs]\n  print_linear_residuals = false\n  exodus = true\n  interval = 1\n[]\n\nAny insight would be much appreciated. Thank you!",
          "url": "https://github.com/idaholab/moose/discussions/24860",
          "updatedAt": "2023-06-30T12:33:30Z",
          "publishedAt": "2023-06-29T13:29:02Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@recuero",
                  "url": "https://github.com/idaholab/moose/discussions/24860#discussioncomment-6316233",
                  "updatedAt": "2023-06-29T14:47:10Z",
                  "publishedAt": "2023-06-29T14:47:10Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "recuero"
                  },
                  "bodyText": "It seems you are using those constraints in a dynamic setting. I don't believe we have tested (thought about) that particular application. Two recommendations:\n\nRun the same problem without dynamics and assess the behavior you describe\nMake sure your sidesets are properly named. I was trying to check your results and got that sideset 3 and 13 have the same name 'left' in Paraview.",
                  "url": "https://github.com/idaholab/moose/discussions/24860#discussioncomment-6319532",
                  "updatedAt": "2023-06-29T21:35:13Z",
                  "publishedAt": "2023-06-29T21:35:12Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "I modified the input file to exclude inertia effects as well as ensure all sidesets are unique, however, I still see the same behavior.\nIt seems like the way the mortar constraint is enforced does not allow the mortar boundaries to contract.\nE = 207e3\n\npenalty = 1e8\n[GlobalParams]\n  displacements = 'disp_x disp_y'\n[]\n[Mesh]\n  [bot]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 4\n    ny = 4\n    xmax = 1\n    ymax = 1\n  []\n  [block_bot]\n    type = RenameBlockGenerator\n    input = bot\n    old_block = 0\n    new_block = 'bot_block'\n  []\n  [rename_bot]\n    type = RenameBoundaryGenerator\n    input = block_bot\n    old_boundary = 'top'\n    new_boundary = 'bot_top'\n  []\n  [mid]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 4\n    ny = 4\n    ymin = 1\n    xmax = 1\n    ymax = 2\n    boundary_id_offset = 10\n  []\n  [rename_mid]\n    type = RenameBoundaryGenerator\n    input = mid\n    old_boundary = 'bottom left right top'\n    new_boundary = 'mid_bottom left_mid right_mid top_mid'\n  []\n  [combine]\n    type = CombinerGenerator\n    inputs = 'rename_bot rename_mid'\n  []\n  [secondary]\n    type = LowerDBlockFromSidesetGenerator\n    input = combine\n    sidesets = 'mid_bottom'\n    new_block_id = 102\n    new_block_name = \"secondary\"\n  []\n  [primary]\n    type = LowerDBlockFromSidesetGenerator\n    input = secondary\n    sidesets = 'bot_top'\n    new_block_id = 103\n    new_block_name = \"primary\"\n  []\n[]\n[Constraints]\n  [mortar_x1]\n    type = ADPenaltyEqualValueConstraint\n    secondary_boundary = 'mid_bottom'\n    primary_boundary = 'bot_top'\n    primary_subdomain = 'primary'\n    secondary_subdomain = 'secondary'\n    secondary_variable = disp_x\n    penalty_value = ${penalty}\n    use_displaced_mesh = True\n  []\n  [mortar_y1]\n    type = ADPenaltyEqualValueConstraint\n    secondary_boundary = 'mid_bottom'\n    primary_boundary = 'bot_top'\n    primary_subdomain = 'primary'\n    secondary_subdomain = 'secondary'\n    secondary_variable = disp_y\n    penalty_value = ${penalty}\n    use_displaced_mesh = True\n  []\n[]\n\n[BCs]\n  [fix_bot]\n    type = ADDirichletBC\n    variable = disp_y\n    value = 0\n    boundary = bottom\n    preset = false\n  []\n  [fix_left]\n    type = ADDirichletBC\n    variable = disp_x\n    value = 0\n    boundary = bottom\n    preset = false\n  []\n  [func]\n    type = ADFunctionDirichletBC\n    variable = disp_y\n    boundary = top_mid\n    function = '0.1*t'\n    preset = false\n  []\n[]\n[Modules/TensorMechanics/Master]\n  [all]\n    add_variables = true\n    strain = SMALL\n    incremental = true\n    generate_output = 'stress_yy stress_xx stress_xy stress_yz'\n    use_automatic_differentiation = true\n    decomposition_method = EigenSolution\n    #density = 7000\n  []\n[]\n\n[Materials]\n\n  [elasticity_tensor]\n    type = ADComputeIsotropicElasticityTensor\n    youngs_modulus = ${E}\n    poissons_ratio = 0.3\n  []\n  [stress]\n    type = ADComputeLinearElasticStress\n  []\n[]\n[Executioner]\n  type = Transient\n  end_time = 3000\n  line_search = none\n  solve_type = NEWTON\n  dtmin = 1e-20\n  nl_max_its = 25\n  nl_rel_tol = 1e-15\n  nl_abs_tol = 1e-10\n\n  [TimeStepper]\n    type = ConstantDT\n    dt = 0.1\n  []\n  [TimeIntegrator]\n    type = NewmarkBeta\n  []\n  petsc_options_iname = '-pc_type'\n  petsc_options_value = 'lu'\n  automatic_scaling = true\n\n[]\n[Outputs]\n  file_base = '/home/det12/projects/DavidRac/localexodus/torsion/moosephysics'\n  print_linear_residuals = false\n  exodus = true\n  interval = 1\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/24860#discussioncomment-6319638",
                          "updatedAt": "2023-06-29T21:56:22Z",
                          "publishedAt": "2023-06-29T21:56:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "recuero"
                          },
                          "bodyText": "You need to block restrict your physics (and remove your TimeIntegrator from the executioner to be consistent)\ngreat_cid.txt",
                          "url": "https://github.com/idaholab/moose/discussions/24860#discussioncomment-6320802",
                          "updatedAt": "2023-06-30T02:02:27Z",
                          "publishedAt": "2023-06-30T02:02:25Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "The block restricted physics fixed it for me. Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/24860#discussioncomment-6325531",
                          "updatedAt": "2023-06-30T12:33:02Z",
                          "publishedAt": "2023-06-30T12:33:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "TheGreatCid"
                          },
                          "bodyText": "Also, it seems to hold up fine after I added dynamics back in",
                          "url": "https://github.com/idaholab/moose/discussions/24860#discussioncomment-6325534",
                          "updatedAt": "2023-06-30T12:33:31Z",
                          "publishedAt": "2023-06-30T12:33:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "CSV file",
          "author": {
            "login": "nourriahi"
          },
          "bodyText": "Hello everyone,\nI am trying to use lineValuesampler to get a csv file for 80 timesteps between 0s and 3e-3s, I couldn't manage to get this, I am only obtaining for the first timestep.\n[VectorPostprocessors]                                  \n  [t_sampler]\n    type = LineValueSampler\n    variable = temperature\n    start_point = '500 500 0'\n    end_point = '500 500 100'\n    num_points = 80\n    sort_by = z\n  []\n[]\n\n[Outputs]\n  exodus = true\n\n  [csv]\n    type = CSV                                                          \n    file_base = excel/additive_manufacturing_temperature_profile_output_100w\n    start_time = 0.0\n    end_time = 3e-3\n    interval = 80\n  []\n[]\n\nThanks,",
          "url": "https://github.com/idaholab/moose/discussions/24836",
          "updatedAt": "2023-06-30T12:28:30Z",
          "publishedAt": "2023-06-27T18:27:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Interval = 80 does not do what you think.\nIt triggers output every 80 time steps, not 80 times within the start/end time window",
                  "url": "https://github.com/idaholab/moose/discussions/24836#discussioncomment-6297254",
                  "updatedAt": "2023-06-27T19:06:38Z",
                  "publishedAt": "2023-06-27T19:06:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "nourriahi"
                  },
                  "bodyText": "Hello,\nI took your suggestions into consideration and I made the required changes, but I am still having one csv file with only one timestep (final\nI guess), ideally I want to have a csv file with various times (interval=2)\n[Outputs]\nexodus = true\n[csv]\ntype = CSV                                                          # Extraction of data in the form of a CSV FILE\nfile_base = excel/additive_manufacturing_temperature_profile_output_100w\nstart_time = 0.0\nend_time = 3e-3\ninterval = 2\nexecute_on = final\n[]\n[]",
                  "url": "https://github.com/idaholab/moose/discussions/24836#discussioncomment-6324603",
                  "updatedAt": "2023-06-30T10:35:07Z",
                  "publishedAt": "2023-06-30T10:35:07Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "This is because you are using an execute_on of FINAl. This only executes once, at the end of the simulation\nYou want to use an execute on of tomestep end",
                          "url": "https://github.com/idaholab/moose/discussions/24836#discussioncomment-6325502",
                          "updatedAt": "2023-06-30T12:28:31Z",
                          "publishedAt": "2023-06-30T12:28:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Any solutions for better convergence in sharp feature?",
          "author": {
            "login": "bosxered"
          },
          "bodyText": "Hello, Moose Experts.\nI am suffering from a bad convergence situation.\nIn my opinion, It is because of the sharp feature of temperature(T) in my system.\nThe temperature profile in my system changes quite steeply.\n\nIt stopped with aborting at step 61 by cutting timestep to 1e-13 (sec) but in step 60, dt was 1e-3 (sec).\nOn the 'top' and 'bottom', Dirichlet boundary conditions, T=300K is applied.\nFor your information, I've attached the input file below.\n########## Global Parameters ########## \nxmax = 20\nymax = 5\n\nNmax = 1.0\n######################################\n\n\n\n[Mesh]\n  [./gen]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 40\n    ny = 20\n    nz = 0\n    xmin = 0\n    xmax = ${xmax}\n    ymin = 0\n    ymax = ${ymax}\n    zmin = 0\n    zmax = 0\n    elem_type = QUAD8\n\n  []\n\n[]\n\n[Functions]\n  [./bc_func]\n    type = PiecewiseLinear\n    data_file = './vsweep.csv'\n    format = columns\n    scale_factor = 1.0\n  [../]\n[]\n\n[Variables]\n  [./N]\n    order = FIRST\n    family = LAGRANGE\n    #block = 2\n  [../]\n\n  [./V]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 0.0\n  [../]\n\n  [./T]\n    order = FIRST\n    family = LAGRANGE\n    initial_condition = 300.0\n  [../]\n[]\n\n[ICs]\n  [./N_IC]\n    type = MultiBoundingBoxIC\n    corners = '0.0 0.0 0   '\n    opposite_corners = '5.0 5.0 0'\n    inside = '${Nmax}'\n    outside = 0.0\n    variable = N\n    #block = 2\n  [../]\n[]\n\n[BCs]\n  [V_top]\n    type = FunctionDirichletBC\n    variable = V\n    function = bc_func # GND\n    boundary = 'top'\n  []\n\n  [V_bot]\n    type = DirichletBC\n    variable = V\n    value = 0.0\n    boundary = 'bottom'\n  []\n\n  [./T_top]\n    type = DirichletBC\n    boundary = top\n    variable = T\n    value = 300 #in K\n  [../]\n\n  [./T_bot]\n    type = DirichletBC\n    boundary = bottom\n    variable = T\n    value = 300 #in K\n  [../]\n[]\n\n[Kernels]\n\n  ########### Phase-field ############\n\n  [./Matdiff_D_del2_N]\n    type = MatDiffusion\n    variable = N\n    diffusivity = Diff_coeff\n    #block = 2\n  [../]\n\n\n  [./Nernst]\n    type = NernstElec\n    variable = N\n    elec = V\n    eDkT = eDkT\n    #block = 2\n  [../]\n\n\n  [./PFM_time]\n    type = TimeDerivative\n    variable = N\n    #block = 2 \n  [../]\n\n  ########## Phase-field END ##########\n\n  ########## Electrical ###############\n\n  [./Matdiff_sig_del2_V]\n    type = MatDiffusion\n    variable = V\n    diffusivity = 'electrical_conductivity'\n  [../]\n\n  ########## Electrical END ###########\n\n  ###### Heat ######\n\n  [./HeatDiff]\n    type = HeatConduction\n    variable = T\n  [../]\n\n  [./HeatSrc]\n    type = JouleHeatingSource\n    variable = T\n    elec = V\n  [../]\n\n  ##################\n[]\n\n\n\n\n\n[Materials]\n  [./Diff_coeff]\n    type = ParsedMaterial\n    property_name  = Diff_coeff\n    coupled_variables = 'T'\n    constant_names       = 'D0     E_A_D    kB        ' #[nm^2/s]  [eV/K]  [K]\n    constant_expressions = '2e+11  1.0      8.617e-5'\n    expression = 'D0*exp(-E_A_D/(kB*T))' #[nm^2/s]\n    outputs = exodus\n    #block = 2\n  [../]\n\n  [./eDkT]\n    type = ParsedMaterial\n    property_name = eDkT\n    coupled_variables = 'T'\n    constant_names       = 'kB       ' #[V/K]\n    constant_expressions = '8.617e-5'\n    material_property_names = 'Diff_coeff'\n    expression = 'Diff_coeff/(kB*T)' #[nm^2/(s*V)]\n    outputs = exodus\n    #block = 2\n  [../]\n\n  [./electrical_conductivity_INS]\n    type = ParsedMaterial\n    coupled_variables = 'N E_AC_elec T'\n    property_name = 'electrical_conductivity'\n    constant_names =        'sig_H    sig_L     kB'       \n    constant_expressions =  '1.0e-7   9.4e-5  8.617e-5' #[1/(ohm*nm)] [1/(ohm*nm)] [eV/K]\n#    material_property_names = 'h'\n#    function = '(1/cm_2_nm) * if(eta <= 0.5-w/2,Crys,if(eta<0.5+w/2, Amor + 0.5*(Crys+Amor)*(1.0+cos(pi*(eta-0.5+w/2)/w)),Amor))'  # [1/(ohm*nm)]\n#    function = 'if(c <= 0.5-w/2, sig_H, if(c > 0.5+w/2, sig_L, sig_H + 0.5 * (sig_L-sig_H) * (1 - cos(pi/w * (c-0.5+w/2)))))'\n#    expression = 'sig_H*(1-h)+sig_L*h'\n    expression = 'if(N<0, sig_H*exp(-E_AC_elec/(kB*T)), if(N>${Nmax}, sig_L*exp(-E_AC_elec/(kB*T)),((sig_L-sig_H)/${Nmax}*N+sig_H)*exp(-E_AC_elec/(kB*T))))'\n#    expression = 'if(N<0, sig_H*exp(-E_AC_elec/(kB*T)), ((sig_L-sig_H)/1.2*N+sig_H)*exp(-E_AC_elec/(kB*T)))'\n    outputs = exodus\n    #block = 2\n#    tol_names = 'N'\n#    tol_values = '0.01'\n  [../]\n\n\n  ####### Heat #######\n  [./k_INS]\n    type = ParsedMaterial\n    property_name = 'thermal_conductivity'\n    coupled_variables = 'N'\n    constant_names =        'k_H      k_L'\n    constant_expressions =  '0.12e-9  57.5e-9'\n    expression = 'if(N<0, k_H, if(N>${Nmax}, k_L, (k_L-k_H)/${Nmax}*N+k_H))'    # W/(nm K)\n#    expression = 'if(N<0, k_H, (k_L-k_H)/1.2*N+k_H)'    # W/(nm K)\n    outputs = exodus\n    #block = 2\n  [../]\n\n  ####################\n\n[]\n\n[AuxVariables]\n\n  ########## Electric ##########\n  [Ex]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [Ey]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [J]\n    family = NEDELEC_ONE\n    order = FIRST\n  []\n\n  [Jy]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [E_AC_elec]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  [Jy_times_x]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n\n  ######## Electric END ########\n\n[]\n\n\n[AuxKernels]\n  ########## Electric ##########\n  [Ex_aux]\n    type = PotentialToFieldAux\n    variable = Ex\n    gradient_variable = V\n    sign = negative\n    component = x\n  []\n\n  [Ey_aux]\n    type = PotentialToFieldAux\n    variable = Ey\n    gradient_variable = V\n    sign = negative\n    component = y\n  []\n\n  [current_density]\n    type = CurrentDensity\n    variable = J\n    potential = V\n  []\n\n  [Jy]\n    type = VectorVariableComponentAux\n    variable = Jy\n    vector_variable = J\n    component = y\n  []\n\n  [E_AC_elec_aux]\n    type = ParsedAux\n    variable = E_AC_elec\n    coupled_variables = 'N'\n    constant_names = 'Nth  E_AC'\n    constant_expressions = '0.5  0.05' #[nm^-3] [eV]\n    expression = 'if(N>Nth, -0.006, if(N<0, E_AC, -E_AC/Nth*N + E_AC))'\n    execute_on = 'initial linear timestep_end'\n    #block = 2\n  []\n\n  [Jy_times_x]\n    type = ParsedAux\n    variable = Jy_times_x\n    coupled_variables = 'Jy'\n    use_xyzt = true\n    expression = 'Jy*x'\n#    boundary = 'BE_top'\n    boundary = bottom\n  []\n\n  ######## Electric END ########\n[]\n\n[Postprocessors]\n\n  ######## Electric #######\n\n  [average_V]\n    type = SideAverageValue\n    variable = V\n    boundary = 'top'\n  []\n\n  [average_Jy]\n    type = SideAverageValue\n    variable = Jy\n#    boundary = 'BE_top'\n    boundary = bottom\n  []\n\n  [Int_Jy_x_dx]\n    type = SideIntegralVariablePostprocessor\n#    boundary = 'BE_top'\n\n    boundary = bottom\n    variable = Jy_times_x\n  []\n\n  [Current]\n    type = ParsedPostprocessor\n    constant_names = 'pi'\n    constant_expressions = '3.14'\n    function = \"if(Int_Jy_x_dx>0,Int_Jy_x_dx*2*pi,-Int_Jy_x_dx*2*pi)\" \n    pp_names = Int_Jy_x_dx\n  []\n\n\n  ######## Electric END #######\n\n  [Timestepsize]\n    type = TimestepSize\n  []\n\n  [Max_T]\n    type = NodalExtremeValue\n    variable = T\n  []\n    \n    \n\n[]\n\n[Debug]\n  show_var_residual_norms = true\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  scheme = bdf2\n  solve_type = 'PJFNK'\n\n  petsc_options_iname = '-pc_type -pc_hypre_type'\n  petsc_options_value = 'hypre      boomeramg'\n\n  l_max_its = 50\n  nl_max_its = 50\n\n  l_tol = 1.0e-4\n  nl_rel_tol = 1.0e-8\n  nl_abs_tol = 1e-8\n\n  [./TimeStepper]\n    type = IterationAdaptiveDT\n    growth_factor = 1.5\n    cutback_factor = 0.5\n    optimal_iterations = 5\n    dt = 1e-4\n  [../]\n  \n#  [./Adaptivity]\n#    interval = 2\n#    refine_fraction = 0.2\n#    coarsen_fraction = 0.3\n#    max_h_level = 3\n#  [../]\n\n\n  dtmin = 1e-13\n  dtmax = 1.0e-2\n\n  start_time = 0.0\n  end_time = 0.7\n\n  automatic_scaling = true\n  compute_scaling_once = false\n[]\n\n[Outputs]\n  exodus = true\n  csv = true\n  file_base = output\n\n  [myexo]\n    type = Exodus\n    file_base = half\n    interval = 2\n#    start_step = 4340 \n  []\n\n  [mymycp]\n    type = Checkpoint\n    num_files = 10\n    interval = 50\n    file_base = mycp\n  []\n[]\n\nI tried more fine mesh (also applying adaptivity) to solve this problem but it doesn't work.\nCould you guys recommend for the convergence?\nThank you.\nBest wishes,\nJeonghwan.",
          "url": "https://github.com/idaholab/moose/discussions/24835",
          "updatedAt": "2023-06-30T07:35:33Z",
          "publishedAt": "2023-06-27T17:54:18Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nShould there be boundary conditions on N?\nShould the solution be symmetric along the X axis?\nDo the solutions for V and N look reasonable?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24835#discussioncomment-6298430",
                  "updatedAt": "2023-06-27T22:03:28Z",
                  "publishedAt": "2023-06-27T22:02:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There's a general page for troubleshooting here\nhttps://mooseframework.inl.gov/help/troubleshooting.html",
                          "url": "https://github.com/idaholab/moose/discussions/24835#discussioncomment-6298438",
                          "updatedAt": "2023-06-27T22:03:53Z",
                          "publishedAt": "2023-06-27T22:03:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "Hello\n\nfor N, the Neumann boundary condition ((del)N = 0) is considered so that I have not imposed additional BC because, as far as I know, the default BC in the MOOSE is Neumann boundary condition ((del)u = 0).\nDo You mean the X-axis? No. I applied BC for V on top, time-varying voltage (Dirichlet Boundary Condition), and on the bottom, 0 (DBC). so that there cannot be symmetry along the X-axis. Maybe there can be Y-axis symmetry. To be clear, I assumed cylindrical symmetry but I haven't used coord_type = RZ because I thought XY coordinate system is enough. Can coord_type = RZ attribute to better convergence?\nYes. For other parameters and system length, I compared the results with one from publicated paper and they look quite similar. Here is the comparison. The first row is from the paper and the second row is my simulation results.\n\n\nAlso, in this simulation, there was a bad convergence situation, too, beyond 1.1V due to (maybe) high temperature and steeply changed temperature(T).",
                          "url": "https://github.com/idaholab/moose/discussions/24835#discussioncomment-6301910",
                          "updatedAt": "2023-06-28T08:08:32Z",
                          "publishedAt": "2023-06-28T08:08:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "1 OK\n2: if you want to simulate a cylindrical geometry, coord_type is a must.\nHowever, if you are wanting to just try XY, and solve a XY problem instead of a cylindrical one, then you can do that without the coord_type\nyou could remove compute_scaling_once = false. This could be computing bad scaling factors on a time step, causing it to fail\nThe trends are close for the results but the values for V and T seem different, especially the extrema? Or is this a plotting artefact?",
                          "url": "https://github.com/idaholab/moose/discussions/24835#discussioncomment-6305054",
                          "updatedAt": "2023-06-29T03:35:39Z",
                          "publishedAt": "2023-06-28T13:34:53Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "bosxered"
                          },
                          "bodyText": "The results may be a little bit different from the ones from the paper because the system is a little bit different.\nThe paper includes elastic energy to calculate the strain effect and the mesh size would be also different.\nAnyway, removing \"compute_scaling_once = false.\" works for my system.\nThank you so much!!",
                          "url": "https://github.com/idaholab/moose/discussions/24835#discussioncomment-6322674",
                          "updatedAt": "2023-06-30T07:36:34Z",
                          "publishedAt": "2023-06-30T07:35:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}