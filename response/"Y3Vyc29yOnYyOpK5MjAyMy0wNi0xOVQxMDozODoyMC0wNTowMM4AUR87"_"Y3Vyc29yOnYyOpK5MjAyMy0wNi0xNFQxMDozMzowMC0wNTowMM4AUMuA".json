{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMy0wNi0xNFQxMDozMzowMC0wNTowMM4AUMuA"
    },
    "edges": [
      {
        "node": {
          "title": "Applying Force/Pressure parallel to boundary",
          "author": {
            "login": "TheBEllis"
          },
          "bodyText": "Apologies, I'm sure this question must have been asked before but I can't seem to find it on the discussions page. I am trying to do a really simple beam bending problem in 3D. This problem is shown in the picture below. The blue end is fixed, and the red end has a load applied parallel to the surface, pulling the end of the beam down in the negative Z direction. I can't seem to identify the correct boundary condition to use for the force. I have tried using the Pressure BC, but as the Z component of the normal is initially 0, I don't think it will work? I have tried using it having set the component/displacements manually and I can't seem to model the correct behavior. Below is my input file, it's just a simple linear mechanics problem. Any help is much appreciated:)\n\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[Mesh]\n  file = ../myBeam_3.e\n  boundary_id = '1 2 3'\n[]\n\n[Modules/TensorMechanics/Master]\n  [./block1]\n    strain = SMALL\n    add_variables = true\n  [../]\n[]\n\n[Materials]\n  [./elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    lambda = 50\n    shear_modulus = 50\n  [../]\n  [./stress]\n    type = ComputeLinearElasticStress\n  [../]\n[]\n\n[BCs]\n  [./zero_disp_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 1\n    value = 0.0\n  [../]\n\n  [./zero_disp_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 1\n    value = 0.0\n  [../]\n\n  [./zero_disp_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 1\n    value = 0.0\n  [../]\n\n# here lies the confusion\n  [Pressure]\n    [Push]\n      factor = 0.1\n      boundary = 2\n    []\n  []\n[]\n\n[Preconditioning]\n  [./SMP]\n    type = SMP\n    full = true\n  [../]\n[]\n\n[Executioner]\n  type = Steady\n\n  solve_type = 'NEWTON'\n\n  petsc_options = '-snes_ksp_ew'\n  petsc_options_iname = '-pc_type -sub_pc_type -pc_asm_overlap -ksp_gmres_restart'\n  petsc_options_value = 'asm lu 1 101'\n[]\n\n[Outputs]\n  exodus = true\n  #perf_graph = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/23377",
          "updatedAt": "2023-06-24T19:48:55Z",
          "publishedAt": "2023-02-08T10:47:34Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Let's start from the simple case. If the deformation is small enough (or equivalently the shear traction is a conservative force in the sense that it does not follow the deformation of the beam), the shear traction will always be in the (-y) direction, so all you need is a NeumannBC or its variants.\nIf the deformation is large enough such that the \"the shear traction is always in the (-y) direction\" assumption is no longer good, things get a little more complicated, but not too bad. You'll first need to figure out the tangential direction along the side of the beam, call it (t), then apply the traction as tau = f t, where tau is the traction vector, f is the magnitude of the force, and (t) is the unit vector pointing in the tangential direction. In the input file, you will then need several (2 in 2D, 3 in 3D) instances of the BC to account for contributions from different components of the traction vector tau.\nHowever, the more complicated case requires some code development, and I don't see an existing object in the tensor mechanics module that can do it for you. If you decide to write a pull request to MOOSE, I'm happy to guide you along the way.",
                  "url": "https://github.com/idaholab/moose/discussions/23377#discussioncomment-4905519",
                  "updatedAt": "2023-02-08T14:03:29Z",
                  "publishedAt": "2023-02-08T14:03:28Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "I am in a similar situation... should I look at the code for Pressure BC?",
                          "url": "https://github.com/idaholab/moose/discussions/23377#discussioncomment-6201123",
                          "updatedAt": "2023-06-16T21:06:15Z",
                          "publishedAt": "2023-06-16T21:06:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It won't hurt.\nWhich case is your simulation in?\nYou may want to open your own discussions topic btw, it will have greater visibility",
                          "url": "https://github.com/idaholab/moose/discussions/23377#discussioncomment-6207425",
                          "updatedAt": "2023-06-18T04:45:50Z",
                          "publishedAt": "2023-06-18T04:45:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lyyc199586"
                          },
                          "bodyText": "LOL, you'are right, let me open another discussion",
                          "url": "https://github.com/idaholab/moose/discussions/23377#discussioncomment-6209052",
                          "updatedAt": "2023-06-18T12:17:03Z",
                          "publishedAt": "2023-06-18T12:17:02Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A random integer used in all poins",
          "author": {
            "login": "liang-tech"
          },
          "bodyText": "I want to create a new material that genterate a random integer in every time step. And this integer can be used in all points (_q_point[_qp]). Can anyone give me suggestion\uff1f\nFor example, I try to rewrite the DiscreteNucleation material. As shown in the folllowing codes, 'eta_i' is the generated random integer. However, it is found that 'eta_i ' is not  the same constant for all points (_q_point[_qp]) in one time step .\nMy codes in the .C file:\n#include \"NisosDiscreteNucleationEta.h\"\n#include \"DiscreteNucleationMap.h\"\n\n#include \"libmesh/quadrature.h\"\n\nregisterMooseObject(\"nisosApp\", NisosDiscreteNucleationEta);\n\nInputParameters\nNisosDiscreteNucleationEta::validParams()\n{\n  InputParameters params = DerivativeFunctionMaterialBase::validParams();\n  params.addClassDescription(\"Free energy contribution for nucleating discrete particles\");\n  params.addRequiredCoupledVar(\"op_names\",\n                               \"List of variables to force to a target concentration value\");\n  params.addRequiredParam<UserObjectName>(\"map\", \"DiscreteNucleationMap user object\");\n  params.addRequiredParam<std::vector<Real>>(\"op_values\", \"List of target concentration values\");\n  params.addParam<Real>(\"threshold\", 0.1, \"The threshold to dertermine the grain order parameter of nuclei\");\n  params.addParam<Real>(\"penalty\", 20.0, \"Penalty factor for enforcing the target concentrations\");\n  MooseEnum penalty_mode(\"MATCH MIN MAX\", \"MATCH\");\n  params.addParam<MooseEnum>(\n      \"penalty_mode\",\n      penalty_mode,\n      \"Match the target concentration or take it as a minimum or maximum concentration target\");\n  return params;\n}\n\nNisosDiscreteNucleationEta::NisosDiscreteNucleationEta(const InputParameters & params)\n  : DerivativeFunctionMaterialBase(params),\n    _nvar(coupledComponents(\"op_names\")),\n    _op_index(_nvar),\n    _op_values(getParam<std::vector<Real>>(\"op_values\")),\n    _threshold(getParam<Real>(\"threshold\")),\n    _penalty(getParam<Real>(\"penalty\")),\n    _penalty_mode(getParam<MooseEnum>(\"penalty_mode\")),\n    _map(getUserObject<DiscreteNucleationMap>(\"map\"))\n{\n  // get libMesh variable numbers\n  for (unsigned int i = 0; i < _nvar; ++i)\n    _op_index[i] = argIndex(coupled(\"op_names\", i));\n}\n\nvoid\nNisosDiscreteNucleationEta::computeProperties()\n{\n  // check if a nucleation event list is available for the current element\n  const std::vector<Real> & nucleus = _map.nuclei(_current_elem);\n\n  Real eta_i = rand()%(_nvar);\n\n  // calculate penalty\n  for (_qp = 0; _qp < _qrule->n_points(); ++_qp)\n  {\n\n    //eta_i = 0;\n    // clear penalty value\n    if (_prop_F)\n      (*_prop_F)[_qp] = 0.0;\n\n    for (unsigned int i = 0; i < _nvar; ++i)\n    {\n      const unsigned ii = _op_index[i];\n\n      // modify the penalty magnitude with the nucleus mask\n      const Real penalty = _penalty * nucleus[_qp];\n\n      // deviation from the target concentration\n      Real dc = 0;\n      Real dd = 0;\n      if (eta_i == i)\n      {  dc = (*_args[ii])[_qp] - _op_values[i];\n         dd = 1;\n      }\n\n      // ignore above/below target values for min/max modes respectively\n      if ((_penalty_mode == 1 && dc > 0.0) || (_penalty_mode == 2 && dc < 0.0))\n        dc = 0.0;\n\n      // build free energy correction\n      if (_prop_F)\n        (*_prop_F)[_qp] += dc * dc * penalty;\n\n      // first derivative\n      if (_prop_dF[ii])\n        (*_prop_dF[ii])[_qp] = 2.0 * dc * penalty;\n      for (unsigned int jj = ii; jj < _nvar; ++jj)\n      {\n        if (_prop_d2F[ii][jj])\n          (*_prop_d2F[ii][jj])[_qp] = 2.0 * dd * penalty;\n      }\n    }\n  }\n}",
          "url": "https://github.com/idaholab/moose/discussions/24722",
          "updatedAt": "2023-06-24T19:47:17Z",
          "publishedAt": "2023-06-17T03:39:50Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou could keep an attribute like : _t_last_generated that is the time step you last generated the integer and\nanother attribute that is _random_integer that you only update once per timestep\nSo something like, in computeQpProperties:\nif (_t != _t_last_generated)\n{\n  _random_integer = rand()%(_nvar);\n  _t = _t_last_generated;\n}\n\nthen use _random_integer everywhere, it will only get updated once per timestep",
                  "url": "https://github.com/idaholab/moose/discussions/24722#discussioncomment-6207414",
                  "updatedAt": "2023-06-18T04:43:02Z",
                  "publishedAt": "2023-06-18T04:43:02Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "liang-tech"
                          },
                          "bodyText": "Thank you very much",
                          "url": "https://github.com/idaholab/moose/discussions/24722#discussioncomment-6207718",
                          "updatedAt": "2023-06-18T06:55:35Z",
                          "publishedAt": "2023-06-18T06:55:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Material property and initial Aux variable values from an input (ASCII) file",
          "author": {
            "login": "chakra34"
          },
          "bodyText": "Hi Moose community,\nI wanted to ask if there is a way to provide the value of material properties as an input file. For example I have a cylindrical geometry where I want to provide the temperature field, Young's modulus and Poisson's ratio from an input file that has the mesh coordinates and the corresponding values of these material properties and temperature (treated as an aux variable for this purpose).\nIs there already something in MOOSE which allows to do this?\nThanks,\nBest,\nAritra",
          "url": "https://github.com/idaholab/moose/discussions/24679",
          "updatedAt": "2023-06-24T22:18:10Z",
          "publishedAt": "2023-06-13T20:46:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo those properties are solely a function of space?\nIf so:\nThis Function\nhttps://mooseframework.inl.gov/source/functions/PiecewiseConstantFromCSV.html\nthen this material\nhttps://mooseframework.inl.gov/source/materials/GenericFunctionMaterial.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6167717",
                  "updatedAt": "2023-06-13T21:02:39Z",
                  "publishedAt": "2023-06-13T21:02:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Thanks for the reply! I guess I am a bit confused on how we are incorporating this information. As an example I had a csv file with x,y,z coordinates and the temperature and I wanted to use this as the function value for the temperature aux variable.\nSo first few rows of my csv file looks like:\n\n\n\n\n\n\n<style>\n\n</style>\n\n\n\n\n\n5.00E-02\n5.22E-02\n5.22E-02\n10.439\n\n\n\n\n0.1\n5.22E-02\n5.22E-02\n10.439\n\n\n0.15\n5.22E-02\n5.22E-02\n10.439\n\n\n0.2\n5.22E-02\n5.22E-02\n10.439\n\n\n0.25\n5.22E-02\n5.22E-02\n10.439\n\n\n0.3\n5.22E-02\n5.22E-02\n10.439\n\n\n0.35\n5.22E-02\n5.22E-02\n10.439\n\n\n0.4\n5.22E-02\n5.22E-02\n10.439\n\n\n0.45\n5.22E-02\n5.22E-02\n10.439\n\n\n0.5\n5.22E-02\n5.22E-02\n10.439\n\n\n0.55\n5.22E-02\n5.22E-02\n10.439\n\n\n0.6\n5.22E-02\n5.22E-02\n10.439\n\n\n0.65\n5.22E-02\n5.22E-02\n10.439\n\n\n0.7\n5.22E-02\n5.22E-02\n10.439\n\n\n0.75\n5.22E-02\n5.22E-02\n10.439\n\n\n0.8\n5.22E-02\n5.22E-02\n10.439\n\n\n0.85\n5.22E-02\n5.22E-02\n10.439\n\n\n0.9\n5.22E-02\n5.22E-02\n10.439\n\n\n0.95\n5.22E-02\n5.22E-02\n10.439\n\n\n5.00E-02\n5.21E-02\n0.10439\n20.878\n\n\n0.1\n5.21E-02\n0.10439\n20.878\n\n\n\n\n\nthe first 3 are the X,Y,Z coordinates and the last column is the temperature of a box geometry with coordinates ranging from [0,1]m in all X,Y, and Z direction.\nSo to do this I used the \"nearest\" and used the following:\n[UserObjects]\n[reader_nearest]\ntype = PropertyReadFile\nprop_file_name = 'temperature_ansys_modified.csv'\nread_type = 'voronoi'\nnprop = 1\nnvoronoi = 1\n[]\n[]\n[Functions]\n[temp_nearest]\ntype = PiecewiseConstantFromCSV\nread_prop_user_object = 'reader_nearest'\nread_type = 'voronoi'\ncolumn_number = '3'\n[]\n[]\nAnd added in the temperature aux variable:\n[AuxKernels]\n[set_temp]\nvariable = temp\ntype = FunctionAux\nfunction = temp_nearest #temp_function\n[]\n[]\nBut I don't see the temperature getting input.\nMeanwhile, I was also looking at the PropertyReadFile.C but and saw some \"voronoi\" options which I am not sure what to do when I don't have a polygonized grain structure but rather a simple block geometry.",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6178853",
                          "updatedAt": "2023-06-14T20:09:30Z",
                          "publishedAt": "2023-06-14T20:09:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this is wrong\nnvoronoi = 1\n\nyou have plenty of nearest point regions, you need to have the number of CSV rows as the nvoronoi",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6178889",
                          "updatedAt": "2023-06-14T20:14:49Z",
                          "publishedAt": "2023-06-14T20:14:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Tried but it did not work. I am attaching the full input file:\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 20\n  ny = 20\n  nz = 20\n  xmin = 0.0\n  xmax = 1.0\n  ymin = 0.0\n  ymax = 1.0\n  zmin = 0.0\n  zmax = 1.0\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[UserObjects]\n  [reader_nearest]\n    type = PropertyReadFile\n    prop_file_name = 'temperature_ansys_modified.csv'\n    read_type = 'voronoi'\n    nprop = 1\n    nvoronoi = 9261\n  []\n[]\n\n[Functions]\n  [./topfunc]\n    type = ParsedFunction\n    value = '1e-4*t' # ramped displacement BC\n  [../]\n\n  [temp_nearest]\n    type = PiecewiseConstantFromCSV\n    read_prop_user_object = 'reader_nearest'\n    read_type = 'voronoi'\n    column_number = '3'\n  []\n  \n[]\n\n[BCs]\n\n  [./bot_fix_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0\n  [../]\n\n  [./top_disp_y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = 'top'\n    function = topfunc\n  [../]\n\n  [./left_fix_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left'\n    value = 0\n  [../]\n\n  [./front_fix_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'front'\n    value = 0\n  [../]\n\n[]\n\n[Modules/TensorMechanics/Master/All]\n  strain = FINITE\n  incremental = true\n  add_variables = true\n  temperature = temp\n  eigenstrain_names = eigenstrain  \n  generate_output = 'stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx'\n  use_automatic_differentiation = false\n[]\n[Materials]\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 150e9\n    poissons_ratio = 0.3\n  []\n\n  [./stress]\n    type = ComputeFiniteStrainElasticStress\n  [../]\n\n  [./thermal_expansion_strain]\n    type = ComputeThermalExpansionEigenstrain\n    thermal_expansion_coeff = 1.0e-4\n    stress_free_temperature = 100.0\n    temperature = temp\n    eigenstrain_name = eigenstrain\n  [../]\n\n[]\n\n\n[AuxVariables]\n  [temp]\n    order  = FIRST\n    family = LAGRANGE\n  []\n\n[]\n\n[AuxKernels]\n  [set_temp]\n     variable = temp\n     type = FunctionAux\n     function = temp_nearest \n  []\n[]\n\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = 'Newton'\n\n  start_time = 0.0\n  dt    = 0.1\n  dtmax = 1.0\n  dtmin = 1e-31\n  nl_abs_tol = 1e-6\n  end_time = 0.1\n []\n\n[Outputs]\n  print_linear_residuals = true\n  perf_graph = true\n  csv = true\n  [./out]\n    type = Exodus\n    elemental_as_nodal = true\n  [../]\n  [./console]\n    type = Console\n    max_rows = 100\n  [../]\n[]\n\nAnd my csv file has 9261 rows which are the total number of nodes in my block.",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6179106",
                          "updatedAt": "2023-06-14T21:16:30Z",
                          "publishedAt": "2023-06-14T20:44:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "what does it look like now?",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6179342",
                          "updatedAt": "2023-06-14T21:16:21Z",
                          "publishedAt": "2023-06-14T21:16:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "The temperature is still zero",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6179383",
                          "updatedAt": "2023-06-14T21:22:16Z",
                          "publishedAt": "2023-06-14T21:22:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "variable = temp\n     type = FunctionAux\n     function = temp_nearest \n     execute_on = INITIAL\n  []\n\nor even better, use a FunctionIC",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6179424",
                          "updatedAt": "2023-06-14T21:30:38Z",
                          "publishedAt": "2023-06-14T21:30:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "the execute_on = Initial did not work (still getting zero temp); will try FunctionIC next",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6179454",
                          "updatedAt": "2023-06-14T21:36:22Z",
                          "publishedAt": "2023-06-14T21:36:22Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "Hi @GiudGiud I tried IC, but it seems it is not even reading anything from the input file, and I am still getting zero temperatures. I am attaching the input file and the csv, could you please see if there is something wrong with the csv format ?\ntemperature_ansys_modified.csv\nThe corresponding MOOSE input:\n[Mesh]\n  type = GeneratedMesh\n  dim = 3\n  nx = 20\n  ny = 20\n  nz = 20\n  xmin = 0.0\n  xmax = 1.0\n  ymin = 0.0\n  ymax = 1.0\n  zmin = 0.0\n  zmax = 1.0\n[]\n\n[GlobalParams]\n  displacements = 'disp_x disp_y disp_z'\n[]\n\n[UserObjects]\n  [reader_nearest]\n    type = PropertyReadFile\n    prop_file_name = 'temperature_ansys_modified.csv'\n    read_type = 'voronoi'\n    nprop = 1\n    nvoronoi = 9261\n  []\n[]\n\n[Functions]\n  [./topfunc]\n    type = ParsedFunction\n    value = '1e-4*t' # ramped displacement BC\n  [../]\n\n  [temp_nearest]\n    type = PiecewiseConstantFromCSV\n    read_prop_user_object = 'reader_nearest'\n    read_type = 'voronoi'\n    column_number = '3'\n  []\n  \n[]\n\n[BCs]\n\n  [./bot_fix_y]\n    type = DirichletBC\n    variable = disp_y\n    boundary = 'bottom'\n    value = 0\n  [../]\n\n  [./top_disp_y]\n    type = FunctionDirichletBC\n    variable = disp_y\n    boundary = 'top'\n    function = topfunc\n  [../]\n\n  [./left_fix_x]\n    type = DirichletBC\n    variable = disp_x\n    boundary = 'left'\n    value = 0\n  [../]\n\n  [./front_fix_z]\n    type = DirichletBC\n    variable = disp_z\n    boundary = 'front'\n    value = 0\n  [../]\n\n[]\n\n[ICs]\n  [nearest]\n    type = FunctionIC\n    variable = 'temp'\n    function = 'temp_nearest'\n  []\n\n[]\n\n\n[Modules/TensorMechanics/Master/All]\n  strain = FINITE\n  incremental = true\n  add_variables = true\n  temperature = temp\n  eigenstrain_names = eigenstrain  \n  generate_output = 'stress_xx stress_yy stress_zz stress_xy stress_yz stress_zx'\n  use_automatic_differentiation = false\n[]\n[Materials]\n  [elasticity_tensor]\n    type = ComputeIsotropicElasticityTensor\n    youngs_modulus = 150e9\n    poissons_ratio = 0.3\n  []\n\n  [./stress]\n    type = ComputeFiniteStrainElasticStress\n  [../]\n\n  [./thermal_expansion_strain]\n    type = ComputeThermalExpansionEigenstrain\n    thermal_expansion_coeff = 1.0e-4\n    stress_free_temperature = 100.0\n    temperature = temp\n    eigenstrain_name = eigenstrain\n  [../]\n\n[]\n\n\n[AuxVariables]\n  [temp]\n    order  = FIRST\n    family = LAGRANGE\n  []\n\n[]\n\n\n[Preconditioning]\n  [smp]\n    type = SMP\n    full = true\n  []\n[]\n\n[Executioner]\n  type = Transient\n\n  solve_type = 'Newton'\n\n  start_time = 0.0\n  dt    = 0.1\n  dtmax = 1.0\n  dtmin = 1e-31\n  nl_abs_tol = 1e-6\n  end_time = 0.1\n []\n\n[Outputs]\n  print_linear_residuals = true\n  perf_graph = true\n  csv = true\n  [./out]\n    type = Exodus\n    elemental_as_nodal = true\n  [../]\n  [./console]\n    type = Console\n    max_rows = 100\n  [../]\n[]\n\n\nDoes something seem off ?",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6186126",
                          "updatedAt": "2023-06-15T16:35:01Z",
                          "publishedAt": "2023-06-15T13:01:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Hello\nSorry for the delay.\nSomething is off indeed, only the first column is being read.\nI ll try to fix this\nGuillaume",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6190313",
                          "updatedAt": "2023-06-15T20:23:21Z",
                          "publishedAt": "2023-06-15T20:23:20Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "chakra34"
                          },
                          "bodyText": "No worries at all @GiudGiud ! Thank you so much for looking into it!! Really appreciate it!\n-Aritra",
                          "url": "https://github.com/idaholab/moose/discussions/24679#discussioncomment-6190566",
                          "updatedAt": "2023-06-15T21:00:53Z",
                          "publishedAt": "2023-06-15T21:00:52Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Changing boundary condition",
          "author": {
            "login": "deepakbiitk"
          },
          "bodyText": "Hello MOOSE users,\nI am solving heat equation in a rectangular domain, In my left, bottom and top boundary I have insulated bc and in the right boundary I have convection bc for few time steps after which I would like to change it to DirichletBC for the rest of my simulation. Is it possible to achieve in a single input file or do I need to use the restart feature?\nThanks,\nDeepak",
          "url": "https://github.com/idaholab/moose/discussions/24715",
          "updatedAt": "2023-06-16T01:23:29Z",
          "publishedAt": "2023-06-15T23:58:44Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nPlease see this thread\n#24596\nYou ll want to use the Control system to try to do this.\nIf it doesnt work, then restart will be the way\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24715#discussioncomment-6191524",
                  "updatedAt": "2023-06-16T00:07:37Z",
                  "publishedAt": "2023-06-16T00:07:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "deepakbiitk"
                          },
                          "bodyText": "Hi Guillaume,\nUse of control system worked  in this case. I appreciate your suggestion.\nDeepak",
                          "url": "https://github.com/idaholab/moose/discussions/24715#discussioncomment-6191856",
                          "updatedAt": "2023-06-16T01:23:27Z",
                          "publishedAt": "2023-06-16T01:23:27Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "An advection simulation problem",
          "author": {
            "login": "Wolke926"
          },
          "bodyText": "I'm a new MOOSE user currently trying to use an advection kernel to simulate a simple rigid body motion process for a sphere. The result I expect is that the ball does not change its shape and moves to the right, but the result is that the shape of the sphere changes and it appears to diffuse. Thank you very much for someone who can answer my question.\nThe source code has been put here.\n[Mesh]\n  [gen_mesh]\n    type = GeneratedMeshGenerator\n    dim = 2\n    xmin = 0\n    xmax = 20\n    ymin = 0\n    ymax = 20\n    nx = 40\n    ny = 40\n  []\n[]\n\n[Variables]\n  [c]\n  []\n[]\n\n[ICs]\n\n  [./c]\n    type = SpecifiedSmoothCircleIC           \n    invalue = 1.0\n    outvalue = 0.0\n    int_width = 2.0\n    x_positions = '4 '\n    y_positions = '4 '\n    z_positions = '0.0 '\n    radii       = '2' \n    variable = c\n    [../]\n  \n[]\n\n[Kernels]\n  [advection]\n    type = ConservativeAdvection\n    variable = c\n    velocity = '2 0 0'\n    upwinding_type = full\n  []\n\n  [time]\n    type = TimeDerivative\n    variable = c\n  []\n[]\n\n[BCs]\n [./allow_mass_out]\n  type = OutflowBC\n  boundary = right\n  variable = c\n  velocity = '2 0 0'\n[../]\n   [./injection_left]\n    type = InflowBC\n    boundary = left\n    variable = c\n    velocity = '2 0 0'\n    inlet_conc = 0\n  [../]\n[]\n\n[Executioner]\n  type = Transient\n  petsc_options = '-snes_converged_reason'\n  num_steps = 30\n  dt = 0.2\n  nl_rel_tol = 1e-12\n[]\n\n[Outputs]\n  exodus = true\n[]",
          "url": "https://github.com/idaholab/moose/discussions/24451",
          "updatedAt": "2023-06-24T19:48:40Z",
          "publishedAt": "2023-05-23T15:45:06Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis is probably just some numerical diffusivity from the upwinding scheme.\nCould you please try to refine the mesh to quantify the effect on the shape of the advected object?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5980390",
                  "updatedAt": "2023-05-23T16:22:37Z",
                  "publishedAt": "2023-05-23T16:22:36Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "Thanks for your reply, I just tried to refine the mesh, but the result doesn't change. Do you think it is related to the boundary condition I am using?",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5981180",
                          "updatedAt": "2023-05-23T17:49:11Z",
                          "publishedAt": "2023-05-23T17:49:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "maybe from the coarse time scheme then?\ncan you try bdf2 for the scheme and/or a finer time grid",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5981338",
                          "updatedAt": "2023-05-23T18:08:43Z",
                          "publishedAt": "2023-05-23T18:08:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "I modified the time step to be smaller (dt = 0.05) and added TimeIntegrator bdf2. This time the result has been improved, but there is still a tendency to diffuse. Should I delete the unwinding term to avoid the numerical diffusivity? Is Full upwinding necessary for advection/convection problems?",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5981816",
                          "updatedAt": "2023-05-23T19:07:45Z",
                          "publishedAt": "2023-05-23T19:07:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "If the solution is sufficiently smooth then upwinding is not necessary. TVD schemes are meant to provide upwinding when necessary and fall back to second order central differencing/averaging when the solution is sufficiently smooth",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5982076",
                          "updatedAt": "2023-05-23T19:42:20Z",
                          "publishedAt": "2023-05-23T19:42:19Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "You could try with upwinding_type = none and see whether you experience any oscillations",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5982081",
                          "updatedAt": "2023-05-23T19:43:13Z",
                          "publishedAt": "2023-05-23T19:43:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Wolke926"
                          },
                          "bodyText": "I tried, the illustration looks even better, the diffusion almost disappears, although one side of the sphere shape shows some oscillations.",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5982357",
                          "updatedAt": "2023-05-23T20:26:11Z",
                          "publishedAt": "2023-05-23T20:26:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "that's the trade-off. You could try to introduce something like min-mod or van Leer into that class if you wanted to see whether you could get a better blend",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5982368",
                          "updatedAt": "2023-05-23T20:28:16Z",
                          "publishedAt": "2023-05-23T20:28:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "You can also check some capabilities in Level set module which deals with pure advection equations.\nSee https://mooseframework.inl.gov/modules/level_set/example_circle.html",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5982399",
                          "updatedAt": "2023-05-23T20:33:11Z",
                          "publishedAt": "2023-05-23T20:33:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "ABallisat"
                          },
                          "bodyText": "It sounds like you are trying to advect a sharp interface (the edge of the sphere) which is a notoriously difficult problem. As @jiangwen84 pointed out Level Set is a good bet, and probably your best bet if you just want to advect an interface. You will have to accept the trade off cost of doing some reinitialisation (either PDE based or fast marching, I have done both in MOOSE). You could also look at a Volume of Fluid/Solid approach and then you will need some stabilisation scheme, for example look at KT stabilisation in the Porous Flow module (not sure if that can be used outside of porous flow easily), there are lots of other methods but no golden bullet. Do you need to couple the rigid body motion with other physics?\nIf you want something that works straight out of the box for pure advection, the level set module is the best place to start.",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5986508",
                          "updatedAt": "2023-05-24T08:11:10Z",
                          "publishedAt": "2023-05-24T08:11:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "We also have pure scalar advection implemented using finite-volume/rDG through the FVAdvection finite volume kernel. I am adding more interpolation types in #24468 (previously only upwind and weighted averaging)",
                          "url": "https://github.com/idaholab/moose/discussions/24451#discussioncomment-5992360",
                          "updatedAt": "2023-05-24T16:52:42Z",
                          "publishedAt": "2023-05-24T16:52:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Broken mesh from xda files",
          "author": {
            "login": "favinom"
          },
          "bodyText": "Hi all,\nI am trying to do the following:\n\ncall BreakMeshByBlockGenerator on a mesh\nsave the mesh in an xda file\nread the mesh from the xda file in another script\n\nThe problem is that the mesh read from xda does not \"see\" the interfaces.\nI think this is due to the fact that the neighboring map has been lost in the xda file.\nIs there a way to read a broken mesh with the correct interfaces?\nThanks\nMarco",
          "url": "https://github.com/idaholab/moose/discussions/24700",
          "updatedAt": "2023-06-24T22:09:45Z",
          "publishedAt": "2023-06-15T07:34:03Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nxda might be losing some information\nLet's check by trying with another mesh format type : exodus for example\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24700#discussioncomment-6188217",
                  "updatedAt": "2023-06-19T17:43:49Z",
                  "publishedAt": "2023-06-15T16:14:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Moving Heat Source",
          "author": {
            "login": "nourriahi"
          },
          "bodyText": "Hello everyone,\nI am using 3d heat conduction module with ellipsoid path function to generate a moving heat source that moves along my y axis in function of time, unfortunately the heat source is stable and fixed only in one position. any suggestions how to make the heat source mobile in the y direction?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/24704",
          "updatedAt": "2023-06-15T15:31:43Z",
          "publishedAt": "2023-06-15T14:53:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "nourriahi"
                  },
                  "bodyText": "it works now, I needed to increase the speed of the heat source",
                  "url": "https://github.com/idaholab/moose/discussions/24704#discussioncomment-6187770",
                  "updatedAt": "2023-06-15T15:31:10Z",
                  "publishedAt": "2023-06-15T15:31:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "moose not stop at the last step",
          "author": {
            "login": "wangzhaohao"
          },
          "bodyText": "Today i use a timestep like this\n[Executioner]\n   type = Transient\n   slove_type = 'PJFNK'\n   dt = 0.01\n   end_time = 200\n[]\n\nthe slove Converage.show bellow\nbut, the weird thing happend\n\nwhat is the reason?\nThanks for you help.",
          "url": "https://github.com/idaholab/moose/discussions/24701",
          "updatedAt": "2023-06-15T12:45:05Z",
          "publishedAt": "2023-06-15T12:16:59Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can slightly increase the timestep_tolerance. See https://mooseframework.inl.gov/source/executioners/Transient.html",
                  "url": "https://github.com/idaholab/moose/discussions/24701#discussioncomment-6185827",
                  "updatedAt": "2023-06-15T12:32:12Z",
                  "publishedAt": "2023-06-15T12:32:11Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "wangzhaohao"
                  },
                  "bodyText": "I increase the timstep_tolerance  it works. Thanks!",
                  "url": "https://github.com/idaholab/moose/discussions/24701#discussioncomment-6185969",
                  "updatedAt": "2023-06-15T12:45:06Z",
                  "publishedAt": "2023-06-15T12:45:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Array kernel with coupled array variable",
          "author": {
            "login": "gabburgio"
          },
          "bodyText": "Hello everybody,\nAs the title says, I've been trying to implement an array kernel with coupled array variable (this would describe the production of delayed neutrons in radiation transport, the coupled array variable containing the concentration of the various precursor groups, and the array variable being the multigroup neutron flux).\nI am encountering some difficulties with adding the dependency to the coupled array variable.\nThis is what my class looks like:\n\n#include \"PrecursorDecay.h\"\n\nregisterMooseObject(\"pertApp\", PrecursorDecay);\n\nInputParameters\nPrecursorDecay::validParams()\n{\n  InputParameters params = ArrayKernel::validParams();\n  params.addRequiredParam<MaterialPropertyName>(\n      \"decay_constants\",\n      \"The array containing the values of the decay constants of the various groups.\");\n  params.addRequiredParam<MaterialPropertyName>(\n      \"delayed_spectrum\",\n      \"The array containing the average (multigroup) energy spectrum of delayed neutrons.\");\n\n  params.addRequiredCoupledVar(\"concentrations\",\n                               \"The array variable holding the concentrations of the precursors\");\n  \n  return params;\n}\n\nPrecursorDecay::PrecursorDecay(const InputParameters & parameters)\n  : ArrayKernel(parameters),\n    _decay_constants(&getMaterialProperty<RealEigenVector>(\"decay_constants\")),\n    _delayed_spectrum(&getMaterialProperty<RealEigenVector>(\"delayed_spectrum\")),\n    MooseVariableInterface<RealEigenVector>(\n        this, false, \"concentrations\", Moose::VarKindType::VAR_ANY, Moose::VarFieldType::VAR_FIELD_ARRAY),\n    _concentrations(coupledArrayValue(\"concentrations\"))    \n\n{\n  addMooseVariableDependency(\"The mooseVariableField associated with the _concentrations variable\" );\n}\n\n\nvoid\nPrecursorDecay::computeQpResidual(RealEigenVector & residual)\n{\nresidual.noalias() = ((*_decay_constants)[_qp].dot(_concentrations[_qp]) * (*_delayed_spectrum)[_qp])\n* _test[_i][_qp];\n}\n\n\n\n\nI don't really understand how to reference the mooseVariableField associated with the _concentrations variable, and my attemps to do so enounter an error:\nwarning: direct base 'MooseVariableInterface<Eigen::Matrix<double, -1, 1> >' inaccessible in 'PrecursorDecay' due to ambiguity [-Winaccessible-base]\n    9 | class PrecursorDecay : public ArrayKernel,\n      |       ^~~~~~~~~~~~~~\nIn file included from /u/halle/burgio/home_at/projects/pert/build/unity_src/kernels_Unity.C:2:\n/u/halle/burgio/home_at/projects/pert/src/kernels/PrecursorDecay.C: In constructor 'PrecursorDecay::PrecursorDecay(const InputParameters&)':\n/u/halle/burgio/home_at/projects/pert/src/kernels/PrecursorDecay.C:31:91: error: 'MooseVariableInterface<Eigen::Matrix<double, -1, 1> >' is an ambiguous base of 'PrecursorDecay'\n\n\n\n\nWhich should be due to the fact that there already is a MooseVariableInterface for the array variable that is naturally associated with the array kernel I'm trying to extend.\nAny advice on how to fix this?\nThanks",
          "url": "https://github.com/idaholab/moose/discussions/24685",
          "updatedAt": "2023-06-14T17:00:49Z",
          "publishedAt": "2023-06-14T14:59:17Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nCan you please paste your header as well?\nI wonder if \"ambiguous base\" is just pointing to a diamond inheritance issue\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6176439",
                  "updatedAt": "2023-06-14T15:29:14Z",
                  "publishedAt": "2023-06-14T15:29:13Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "gabburgio"
                  },
                  "bodyText": "Of course, here it is:\n#pragma once\n\n#include \"ArrayKernel.h\"\n#include \"MooseVariableInterface.h\"\n\n\n\nclass PrecursorDecay : public ArrayKernel,\n                      public MooseVariableInterface<RealEigenVector>\n{\npublic:\n  static InputParameters validParams();\n\n  PrecursorDecay(const InputParameters & parameters);\n\nprotected:\n  virtual void computeQpResidual(RealEigenVector & residual) override;\n  \n  const MaterialProperty<RealEigenVector> * const _decay_constants;\n  const MaterialProperty<RealEigenVector> * const _delayed_spectrum;\n  \n\n  const ArrayVariableValue & _concentrations;\n\n  \n};",
                  "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6176488",
                  "updatedAt": "2023-06-14T15:33:23Z",
                  "publishedAt": "2023-06-14T15:33:22Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so if you look at the Array kernel header you can see this:\nclass ArrayKernel : public KernelBase, public MooseVariableInterface<RealEigenVector>\n\nso your PrecursorDecay is inheriting the MooseVariableInterface<RealEigenVector> twice, and that's disallowed (called diamond inheritance)\njust do:\nclass PrecursorDecay : public ArrayKernel",
                          "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6176579",
                          "updatedAt": "2023-06-14T15:41:08Z",
                          "publishedAt": "2023-06-14T15:41:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gabburgio"
                          },
                          "bodyText": "Thanks for the pointer.\nBy doing that, I get the error:\n\nerror: type 'MooseVariableInterface<Eigen::Matrix<double, -1, 1> >' is not a direct base of 'PrecursorDecay'\n   26 |     MooseVariableInterface<RealEigenVector>(\n\n\nWhich is why I had added it in the first place.\nI now understand why it shouldn't be there, but not why I still get this error (I assume I should be able to instantiate an object of a class simply by including the header).\nDoes it have anything to do with the fact that I'm not assigning the MooseVariableInterface to some class attribute?\nThanks for your time",
                          "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6177354",
                          "updatedAt": "2023-06-14T16:50:01Z",
                          "publishedAt": "2023-06-14T16:50:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "PrecursorDecay::PrecursorDecay(const InputParameters & parameters)\n  : ArrayKernel(parameters),\n    _decay_constants(&getMaterialProperty<RealEigenVector>(\"decay_constants\")),\n    _delayed_spectrum(&getMaterialProperty<RealEigenVector>(\"delayed_spectrum\")),\n    _concentrations(coupledArrayValue(\"concentrations\"))    \n\n\nyou need to remove it from the constructor like this too",
                          "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6177369",
                          "updatedAt": "2023-06-14T16:51:29Z",
                          "publishedAt": "2023-06-14T16:51:29Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gabburgio"
                          },
                          "bodyText": "Of course, thanks a lot!",
                          "url": "https://github.com/idaholab/moose/discussions/24685#discussioncomment-6177437",
                          "updatedAt": "2023-06-14T17:00:50Z",
                          "publishedAt": "2023-06-14T17:00:49Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to apply a LineLoad on a line or at a boundary",
          "author": {
            "login": "salaudeen-ya"
          },
          "bodyText": "Hello,\nI know there is a way of applying a point load as a Dirac force in MOOSE. But is there a way of applying a line load that can or can not be applied on nodes?",
          "url": "https://github.com/idaholab/moose/discussions/24669",
          "updatedAt": "2023-06-23T16:11:20Z",
          "publishedAt": "2023-06-13T16:05:35Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhich dimension is the mesh/system?\nIs the line on the boundary or inside the domain?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6166068",
                  "updatedAt": "2023-06-13T17:10:21Z",
                  "publishedAt": "2023-06-13T17:10:20Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "I need it for any dimension. I would be needing it for both inside the domain, and on a boundary",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6166194",
                          "updatedAt": "2023-06-13T17:22:13Z",
                          "publishedAt": "2023-06-13T17:22:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "So 2D and 3D?\nFor a boundary, then you can use boundary conditions to apply a load on a line in 2D",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6166204",
                          "updatedAt": "2023-06-13T17:24:00Z",
                          "publishedAt": "2023-06-13T17:23:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "salaudeen-ya"
                          },
                          "bodyText": "Thank you.\nHow about inside a domain?",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6166621",
                          "updatedAt": "2023-06-13T18:19:03Z",
                          "publishedAt": "2023-06-13T18:19:02Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "good question\n@cpgr @rpodgorney do you ever do that for porous flow?",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6167351",
                          "updatedAt": "2023-06-13T20:05:33Z",
                          "publishedAt": "2023-06-13T20:05:32Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "cpgr"
                          },
                          "bodyText": "Can you make an internal 'boundary' using ExtraNodesetGenerator and then apply a BC internally? I've done that before.",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6168173",
                          "updatedAt": "2023-06-13T22:27:45Z",
                          "publishedAt": "2023-06-13T22:27:43Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "rpodgorney"
                          },
                          "bodyText": "I\u2019ve never used a line, tagging @lynnmunday as he may have other approaches for this",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6175421",
                          "updatedAt": "2023-06-14T13:58:34Z",
                          "publishedAt": "2023-06-14T13:58:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lynnmunday"
                          },
                          "bodyText": "You can specify a series of load points as coordinates in a reporter and then use the https://mooseframework.inl.gov/source/dirackernels/ReporterPointSource.html\nYou can read the points into the reporterPointSource from a csv file.",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6176348",
                          "updatedAt": "2023-06-14T15:20:52Z",
                          "publishedAt": "2023-06-14T15:20:51Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Can you distribute the line load into a series of load points? If so, you can either use @lynnmunday 's Reporter approach, or directly provide a vector of points in the DiracKernel.",
                          "url": "https://github.com/idaholab/moose/discussions/24669#discussioncomment-6176483",
                          "updatedAt": "2023-06-14T15:33:00Z",
                          "publishedAt": "2023-06-14T15:33:00Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}