{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNC0wNS0yNFQxNjoyNjo0My0wNTowMM4AZnaq"
    },
    "edges": [
      {
        "node": {
          "title": "Evaluating dispersion curves for phononic crystals using MOOSE",
          "author": {
            "login": "adhithya96"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello,\nI have worked on a small code in C++ to evaluate the dispersion diagram for a square plate. This includes implementing the Bloch boundary condition and solving the eigenvalue problem. I have used Eigen library to do this. This following is the github link to my code. Bloch2D\nFor the past few months, I have been trying to implement the same in MOOSE but was unable to navigate through MOOSE codebase. I don't think I can implement this without help from MOOSE team. Is this something that you are looking for ?",
          "url": "https://github.com/idaholab/moose/discussions/27669",
          "updatedAt": "2024-05-28T17:55:33Z",
          "publishedAt": "2024-05-20T04:33:04Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@laagesen @dschwen",
                  "url": "https://github.com/idaholab/moose/discussions/27669#discussioncomment-9496179",
                  "updatedAt": "2024-05-20T13:00:10Z",
                  "publishedAt": "2024-05-20T13:00:05Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Hello, this is something that might be useful for a pending project that we put in an application for funding on. Do you have a paper, book or other reference that describes the governing equations?",
                          "url": "https://github.com/idaholab/moose/discussions/27669#discussioncomment-9496893",
                          "updatedAt": "2024-05-20T14:04:54Z",
                          "publishedAt": "2024-05-20T14:04:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adhithya96"
                          },
                          "bodyText": "Yes. This is the paper I used to implement the code.\nImplementation of Bloch boundary condition.pdf\nFor validation I used the test case from this paper.\nValidation.pdf",
                          "url": "https://github.com/idaholab/moose/discussions/27669#discussioncomment-9498381",
                          "updatedAt": "2024-05-20T16:01:59Z",
                          "publishedAt": "2024-05-20T16:01:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "laagesen"
                          },
                          "bodyText": "Have you checked out the eigenvalue problem documentation in MOOSE already?\nhttps://mooseframework.inl.gov/source/problems/EigenProblem.html\nThis is outside my area of expertise but seems like a good starting point. Have a look and if this doesn't answer your question we may want to contact one of the people who works on reactor physics, which is what this capability was developed for.",
                          "url": "https://github.com/idaholab/moose/discussions/27669#discussioncomment-9498811",
                          "updatedAt": "2024-05-20T16:46:58Z",
                          "publishedAt": "2024-05-20T16:46:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "adhithya96"
                          },
                          "bodyText": "Yes. I spent around two months trying to figure out how to implement it in MOOSE.\nCouple of places where I was not able to figure out how to solve the problem are\n\nThe eigenvalue problem is used for diffusion equation while the problem is a vector valued function with plane strain assumption for 2D. I wasn't sure if the tensor mechanics module was coupled with the eigenvalue problem.\nImplementation using this methodology required me to modify the global mass and stiffness matrix by multiplying it with constraint matrix. I couldn't find a way to access the global matrices. Even in the MOOSE code the element matrices were added to the appropriate entries in the global matrices.\nThe mesh is duplicated for taking the real and imaginary parts. I tried to mimic this by considering four dofs in one node but the assembly for this case is different from the normal fe assembly because of the imaginary components.\nThe global mass and stiffness matrix needs to be constructed only once. Only the constraint matrix depends on the wave number which is varied to get the reduced matrices and get eigenvalues.",
                          "url": "https://github.com/idaholab/moose/discussions/27669#discussioncomment-9498942",
                          "updatedAt": "2024-05-20T17:03:02Z",
                          "publishedAt": "2024-05-20T17:02:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "laagesen"
                  },
                  "bodyText": "For #1, I think the reactor physics people use this for groups of neutrons with different energies, so there is probably a solution. Would someone from that area be able to help here, maybe @loganharbour or @YaqiWang or @jortensi ?",
                  "url": "https://github.com/idaholab/moose/discussions/27669#discussioncomment-9499316",
                  "updatedAt": "2024-05-20T17:48:05Z",
                  "publishedAt": "2024-05-20T17:48:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "adhithya96"
                          },
                          "bodyText": "I am extending the above code to evaluate dispersion curves for phononic crystals with holes as well using XFEM.\nIt would be nice to contribute to the MOOSE framework.",
                          "url": "https://github.com/idaholab/moose/discussions/27669#discussioncomment-9584125",
                          "updatedAt": "2024-05-28T17:55:34Z",
                          "publishedAt": "2024-05-28T17:55:33Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Compute norm of a material gradient",
          "author": {
            "login": "josebastiase"
          },
          "bodyText": "Hi all,\nI am studying the impact of material properties on my simulation results. Specifically, I want to evaluate how variations in the material properties affect the outcomes. To achieve this, I plan to use the norm of the gradient of the material property across the simulation space as a proxy measure.\nMathematically, I am considering the expression:\n\u2225\u2207E\u22252\nwhere E represents the Young's modulus, which is assigned to the elements and stored in an auxiliary variable (AuxVar). The goal is to compute this gradient norm within my simulation to analyze the effect of spatial variations in Young's modulus.\nCould anyone suggest the easiest way to compute this within my simulation?\nThanks in advance,\nJose",
          "url": "https://github.com/idaholab/moose/discussions/27716",
          "updatedAt": "2024-05-28T10:07:34Z",
          "publishedAt": "2024-05-28T08:50:24Z",
          "category": {
            "name": "Q&A Modules: Porous Flow"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you want the average or the max of the norm of the gradient of the material property, then you want to create a new postprocessor\nIf you want to look at a field representing this quantity locally then use an auxiliary kernel.\nThere may already be a pre implemented version of this. It's unlikely though given that there are two operations applied. If you don't want to write new code you could see if each operation can be applied separately to different auxiliary variables, in a chain\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27716#discussioncomment-9578462",
                  "updatedAt": "2024-05-28T09:11:26Z",
                  "publishedAt": "2024-05-28T09:11:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "josebastiase"
                          },
                          "bodyText": "Thanks. Yes, I want to compute the field, so in my case, I would need to work with Auxiliary variables and kernels.\nIf I understood correctly I need to assign one aux kernel for each derivative in x,y,z and a final one to compute the gradient.\nIs there a way to directly compute the gradient in one direction with an auxiliary kernel?",
                          "url": "https://github.com/idaholab/moose/discussions/27716#discussioncomment-9578653",
                          "updatedAt": "2024-05-28T09:31:38Z",
                          "publishedAt": "2024-05-28T09:31:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I think there is a gradientAux\nMaybe functorGradientAux that would work",
                          "url": "https://github.com/idaholab/moose/discussions/27716#discussioncomment-9579206",
                          "updatedAt": "2024-05-28T10:07:35Z",
                          "publishedAt": "2024-05-28T10:07:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Best module for dynamic fracture nucleation and propagation without a notch in the geometry",
          "author": {
            "login": "miraboreasumr"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nXFEM, Peridynamics or Phase Field, consider coupling with flow\nEdited: able to output the porosity, permeability change after the fracturing",
          "url": "https://github.com/idaholab/moose/discussions/27654",
          "updatedAt": "2024-05-28T03:08:24Z",
          "publishedAt": "2024-05-17T03:03:57Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@bwspenc or @laagesen\nI would guess peridynamics",
                  "url": "https://github.com/idaholab/moose/discussions/27654#discussioncomment-9465092",
                  "updatedAt": "2024-05-17T03:42:59Z",
                  "publishedAt": "2024-05-17T03:42:59Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "miraboreasumr"
                          },
                          "bodyText": "more suggestions?",
                          "url": "https://github.com/idaholab/moose/discussions/27654#discussioncomment-9552902",
                          "updatedAt": "2024-05-25T03:25:54Z",
                          "publishedAt": "2024-05-25T03:25:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "@gambka",
                          "url": "https://github.com/idaholab/moose/discussions/27654#discussioncomment-9554778",
                          "updatedAt": "2024-05-25T09:57:05Z",
                          "publishedAt": "2024-05-25T09:57:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "gambka"
                          },
                          "bodyText": "Is this a 3D or 2D geometry? I think any approaches would work but Peridynamics may have some difficulties coupling to flow given that it is a bond based formulation and not a finite element formulation like XFEM and phase-field. That being said I am not aware of any coupling of these methods to flow in MOOSE. In terms of the quantities of interest those would not be computed directly and you would need to add postprocessors to extract that information.",
                          "url": "https://github.com/idaholab/moose/discussions/27654#discussioncomment-9554836",
                          "updatedAt": "2024-05-25T10:12:47Z",
                          "publishedAt": "2024-05-25T10:12:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "If you are asking which approach is more appropriate for your problem,  you should read papers to understand each method's pros and cons.  If you would like to know the muturity of each method implementation in moose to handle dynamic fracture,  pf>pd>xfem.\nEven without notch,  you need to inreduce initial flaw,  e.g purturb property or have gemomtry defect",
                          "url": "https://github.com/idaholab/moose/discussions/27654#discussioncomment-9555258",
                          "updatedAt": "2024-05-25T11:49:17Z",
                          "publishedAt": "2024-05-25T11:49:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "miraboreasumr"
                          },
                          "bodyText": "That being said I am not aware of any coupling of these methods to flow in MOOSE.\n\nThanks, sorry I didn't get this \"That being said I am not aware of any coupling of these methods to flow in MOOSE.\" They are not coupled?",
                          "url": "https://github.com/idaholab/moose/discussions/27654#discussioncomment-9571712",
                          "updatedAt": "2024-05-27T15:25:57Z",
                          "publishedAt": "2024-05-27T15:25:57Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "If you define multiple equations in the same input file. they will naturally be fully coupled.\nWe are not aware of any work doing this before\nI dont expect coupling to flow simulations through porosity to be challenging numerically? Maybe it will be right at the formation of cracks.\nEdit: there has been a lot of work in moose in having equations being defined on a domain that grows or shrinks. The flow equations could be active only on part of the domain, where the porosity is such that flow is possible",
                          "url": "https://github.com/idaholab/moose/discussions/27654#discussioncomment-9573741",
                          "updatedAt": "2024-05-28T09:13:13Z",
                          "publishedAt": "2024-05-27T20:54:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "miraboreasumr"
                          },
                          "bodyText": "If you are asking which approach is more appropriate for your problem, you should read papers to understand each method's pros and cons. If you would like to know the muturity of each method implementation in moose to handle dynamic fracture, pf>pd>xfem.\nEven without notch, you need to inreduce initial flaw, e.g purturb property or have gemomtry defect\n\nThanks, just want to clear, when you mentioned geometry defect, does Bazilian test belong to this?",
                          "url": "https://github.com/idaholab/moose/discussions/27654#discussioncomment-9575410",
                          "updatedAt": "2024-05-28T03:08:25Z",
                          "publishedAt": "2024-05-28T03:08:24Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How should I couple two external programs based on MOOSE?",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nI want to couple two external programs based on MOOSE, but I don't know exactly how to do it. Should it be done through dynamic linking? How can I control the parameters that I want to couple? Are there any specific examples I can refer to?\nEthan",
          "url": "https://github.com/idaholab/moose/discussions/27713",
          "updatedAt": "2024-05-27T13:45:38Z",
          "publishedAt": "2024-05-27T13:41:28Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nOne of the best examples of coupling external codes is the cardinal code. You can find in on GitHub on the neams-th-coe repository\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27713#discussioncomment-9570718",
                  "updatedAt": "2024-05-27T13:43:51Z",
                  "publishedAt": "2024-05-27T13:43:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "OK. Thank you Giud",
                          "url": "https://github.com/idaholab/moose/discussions/27713#discussioncomment-9570731",
                          "updatedAt": "2024-05-27T13:45:36Z",
                          "publishedAt": "2024-05-27T13:45:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to Deal with the Interfaces Between Different Materials",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nIn a comment on one of my previous questions, @lindsayad told me (thanks again) that\n\nThe traditional moose material system has no support for nodal material property evaluation. The on-the-fly functor system does allow nodal evaluations, but it requires the user to specify a subdomain ID. This is to eliminate ambiguity about how to evaluate potentially discontinuous properties at subdomain interfaces.\n\nHowever, in MOOSE's continuous finite element calculations, each face is executed only once, even though internal faces are shared by two elements. Once a face has been executed in one element, it will not be executed in the neighboring element. If a face is on the interface between different subdomains, wouldn't it only use the material data from one subdomain for its calculations?\ntemplate <typename RangeType>\nbool\nThreadedElementLoopBase<RangeType>::shouldComputeInternalSide(const Elem & elem,\n                                                              const Elem & neighbor) const\n{\n  auto level = [this](const auto & elem_arg)\n  {\n    if (_mesh.doingPRefinement())\n      return elem_arg.p_level();\n    else\n      return elem_arg.level();\n  };\n  const auto elem_id = elem.id(), neighbor_id = neighbor.id();\n  const auto elem_level = level(elem), neighbor_level = level(neighbor);\n\n  // When looping over elements and then sides, we need to make sure that we do not duplicate\n  // effort, e.g. if a face is shared by element 1 and element 2, then we do not want to do compute\n  // work both when we are visiting element 1 *and* then later when visiting element 2. Our rule is\n  // to only compute when we are visiting the element that has the lower element id when element and\n  // neighbor are of the same adaptivity level, and then if they are not of the same level, then\n  // we only compute when we are visiting the finer element\n  return (neighbor.active() && (neighbor_level == elem_level) && (elem_id < neighbor_id)) ||\n         (neighbor_level < elem_level);\n}\n\nThis seems unreasonable. I'm curious how MOOSE handles this situation. Does anyone have insights? Thank you for your attention.",
          "url": "https://github.com/idaholab/moose/discussions/27711",
          "updatedAt": "2024-05-29T10:26:37Z",
          "publishedAt": "2024-05-26T13:25:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nFor faces we actually do have support for material property evaluations.\nYou use the getMaterialProperty and getNeighborMaterialProperty\nThe material property is computed for the current element side quadratures points (index with qp) and same thing for the neighbor element on the other side of the face\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27711#discussioncomment-9564519",
                  "updatedAt": "2024-05-26T23:16:24Z",
                  "publishedAt": "2024-05-26T23:16:24Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Fully implict simulation of multi-parts 1D pipe flow",
          "author": {
            "login": "Bearunner"
          },
          "bodyText": "Dear all.\nI want to use our 1D single-phase and compressible pipe flow simulator (i.e., mass and momentum equations) to simulate the following processes where fluid flows from one vertical pipe into 2 horizontal pipes.\nHow can I use the known pressure boundaries at P1, P2 and P3 to directly simulate/slove the pipe flow here?\nWe don't want to use the MultiApp method due to its time-consuming interations.\nThanks a lot.\nB",
          "url": "https://github.com/idaholab/moose/discussions/27712",
          "updatedAt": "2024-05-26T23:12:26Z",
          "publishedAt": "2024-05-26T20:06:14Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can use the thermal hydraulics module for this. I m sure there is an example of a separating pipe. Maybe if you could please have a look at the junctions tests and examples for this\nIf you cannot find it @joshuahansel can help\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27712#discussioncomment-9564514",
                  "updatedAt": "2024-05-26T23:12:26Z",
                  "publishedAt": "2024-05-26T23:12:26Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to implement CMFD on continuous FEM",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi, everyone.\nI want to implement CMFD (Coarse Mesh Finite Difference method) on CFEM (Continuous Finite Element Method), i.e. the transport calculations are based on the CFEM method. However, there are shared Nodes between different elements of the CFEM mesh, so when accelerating the transport fluxes based on the results of the coarse mesh, there is a question of which Elem the Node should be based on to do the scaling of its fluxes? For example, a Node may be shared by four Elems, and their scaling ratios are 1, 2, 3, and 4 respectively, how should the flux scaling ratio of this Node be determined?\nThank you for your attention. Hopefully someone can give advice.",
          "url": "https://github.com/idaholab/moose/discussions/27643",
          "updatedAt": "2024-05-29T10:28:17Z",
          "publishedAt": "2024-05-16T13:19:41Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI would suggest to blend the 4 ratios together.\nAt convergence, all scaling ratios will be 1 so it wont matter.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27643#discussioncomment-9458347",
                  "updatedAt": "2024-05-16T13:38:51Z",
                  "publishedAt": "2024-05-16T13:38:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you for your response. I tried using the average ratio, but it still didn't work. I tested it, and the program runs correctly if I add the DGKernel, but it fails when I remove it. I think this might be because using the average ratio disrupts the local consistency between the coarse and fine meshes. After this processing, the flux at this node doesn't reach its ideal value for all four elements.",
                          "url": "https://github.com/idaholab/moose/discussions/27643#discussioncomment-9552325",
                          "updatedAt": "2024-05-25T00:15:34Z",
                          "publishedAt": "2024-05-25T00:15:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "From this perspective, CFEM and CMFD are incompatible. I'm ready to give up. Thank you again for your advice.",
                          "url": "https://github.com/idaholab/moose/discussions/27643#discussioncomment-9552330",
                          "updatedAt": "2024-05-25T00:17:43Z",
                          "publishedAt": "2024-05-25T00:17:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "@YaqiWang @jthano do you guys do CMFD with CFEM?",
                  "url": "https://github.com/idaholab/moose/discussions/27643#discussioncomment-9551481",
                  "updatedAt": "2024-05-24T20:40:45Z",
                  "publishedAt": "2024-05-24T20:40:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you for your attention, but I'm ready to give up. I have tried using the average ratio, but it still didn't work. I tested it, and the program runs correctly if I add the DGKernel, but it fails when I remove it. I think this might be because using the average ratio disrupts the local consistency between the coarse and fine meshes. After this processing, the flux at this node doesn't reach its ideal value for all four elements. From this perspective, CFEM and CMFD are incompatible.",
                          "url": "https://github.com/idaholab/moose/discussions/27643#discussioncomment-9552346",
                          "updatedAt": "2024-05-25T00:20:53Z",
                          "publishedAt": "2024-05-25T00:20:52Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "No. It is possible (https://www.tandfonline.com/doi/abs/10.13182/NSE12-50). We typically do fine mesh diffusion acceleration with CFEM (https://www.tandfonline.com/doi/abs/10.13182/NSE12-83). We do CMFD typically with DFEM (https://doi.org/10.1016/j.anucene.2024.110365).",
                          "url": "https://github.com/idaholab/moose/discussions/27643#discussioncomment-9559198",
                          "updatedAt": "2024-05-26T04:11:47Z",
                          "publishedAt": "2024-05-26T04:06:30Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you for the reminder. I will carefully study the content of these articles.",
                          "url": "https://github.com/idaholab/moose/discussions/27643#discussioncomment-9560958",
                          "updatedAt": "2024-05-26T12:21:21Z",
                          "publishedAt": "2024-05-26T12:21:21Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to find out which elements the node (dof) is on",
          "author": {
            "login": "hityyds"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nhi,\nI need to do different things to solutions of different elements, but in continuous finite element method, different elements will share some degrees of freedom (dof), which will result in some solutions being manipulated multiple times. I need to know which elements each Node or dof belongs to, and then do special handling as appropriate. So how can I get these messages when the pointer to the Node or dof is known?\nThank you very much for your attention and I would quite appreciate it if you have any suggestion!",
          "url": "https://github.com/idaholab/moose/discussions/27626",
          "updatedAt": "2024-05-26T03:02:57Z",
          "publishedAt": "2024-05-15T12:36:11Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nA loop on nodes instead of elements will prevent this double modification, at least for lagrange variables.\nNodes inherit from the DofInterface, you can get the dof of each variable using the dof_number(variable, system) routine.\nAlternatively, you can work with the DoFMap directly\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27626#discussioncomment-9445474",
                  "updatedAt": "2024-05-15T12:48:04Z",
                  "publishedAt": "2024-05-15T12:48:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thank you for your reply. Now I do want to handle it that way, but I need to know which element each Node is on before I can do the corresponding calculation operation. The coefficients in the calculation depend on which element it is on.",
                          "url": "https://github.com/idaholab/moose/discussions/27626#discussioncomment-9445616",
                          "updatedAt": "2024-05-15T13:01:19Z",
                          "publishedAt": "2024-05-15T13:01:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "there is a node_to_elem_map you can get from the mesh to help with that",
                          "url": "https://github.com/idaholab/moose/discussions/27626#discussioncomment-9445796",
                          "updatedAt": "2024-05-15T13:15:35Z",
                          "publishedAt": "2024-05-15T13:15:34Z",
                          "isAnswer": true
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "This seems to be exactly what I need, thank you so much for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/27626#discussioncomment-9446039",
                          "updatedAt": "2024-05-15T13:32:18Z",
                          "publishedAt": "2024-05-15T13:32:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "@hityyds please mark this as answered if this answered your question. I will note that we do not assign a node an element owner. As you know several elements can share a given node; we do not pick any of them as the node \"owner\"",
                          "url": "https://github.com/idaholab/moose/discussions/27626#discussioncomment-9551500",
                          "updatedAt": "2024-05-24T20:43:30Z",
                          "publishedAt": "2024-05-24T20:43:29Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "@lindsayad I apologize, I thought I had already marked it as answered. Thank you for the reminder. Regarding whether a node has an element owner, I'm curious how moose assigns material data to nodes at the interfaces of different materials.",
                          "url": "https://github.com/idaholab/moose/discussions/27626#discussioncomment-9552220",
                          "updatedAt": "2024-05-24T23:47:17Z",
                          "publishedAt": "2024-05-24T23:47:16Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The traditional moose material system has no support for nodal material property evaluation. The on-the-fly functor system does allow nodal evaluations, but it requires the user to specify a subdomain ID. This is to eliminate ambiguity about how to evaluate potentially discontinuous properties at subdomain interfaces",
                          "url": "https://github.com/idaholab/moose/discussions/27626#discussioncomment-9557288",
                          "updatedAt": "2024-05-25T17:50:10Z",
                          "publishedAt": "2024-05-25T17:50:09Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hityyds"
                          },
                          "bodyText": "Thanks for your detailed explanation!",
                          "url": "https://github.com/idaholab/moose/discussions/27626#discussioncomment-9559046",
                          "updatedAt": "2024-05-26T03:02:58Z",
                          "publishedAt": "2024-05-26T03:02:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Format of PETSc syntax for use in MOOSE",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "Given the following PETSc syntax:\n-da_refine 5 -snes_monitor -ksp_monitor -snes_view -pc_type mg\nHow would I form the above syntax in MOOSE using \"  petsc_options_iname =, and\npetsc_options_value = \" ?",
          "url": "https://github.com/idaholab/moose/discussions/27426",
          "updatedAt": "2024-05-24T22:25:13Z",
          "publishedAt": "2024-04-20T17:47:10Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAny option that goes in pairs gets split between those two parameters (for example -pc_type lu)\nAny option that stands alone (for example -ksp_view_pmat or -snes_monitor) goes in the 'petsc_options=' parameter\nOr you can drop everything on the command line\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27426#discussioncomment-9176096",
                  "updatedAt": "2024-04-20T20:57:40Z",
                  "publishedAt": "2024-04-20T20:08:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "lindsayad"
                  },
                  "bodyText": "We do not use PETSc DMDA (or DMPlex), so -da_refine will not do anything (you should see it show up in the options left table). Additionally we do not have support for coarsening for our DM implementation, so -pc_type mg will not get you anywhere. For instance if you pass -pc_type mg -pc_mg_levels 2 to a MOOSE simulation, you will get this error\n 0 Nonlinear |R| = 3.082207e+00\n[0]PETSC ERROR: --------------------- Error Message --------------------------------------------------------------\n[0]PETSC ERROR: No support for this operation for this object type\n[0]PETSC ERROR: No method coarsen for DM of type libmesh",
                  "url": "https://github.com/idaholab/moose/discussions/27426#discussioncomment-9551959",
                  "updatedAt": "2024-05-24T22:24:21Z",
                  "publishedAt": "2024-05-24T22:24:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "The most we've done in our finite element stack with respect to geometric multigrid is libMesh/libmesh#2047",
                          "url": "https://github.com/idaholab/moose/discussions/27426#discussioncomment-9551979",
                          "updatedAt": "2024-05-24T22:25:13Z",
                          "publishedAt": "2024-05-24T22:25:13Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to make a subclass that can take a modified FEProblemSolve::solve() into it?",
          "author": {
            "login": "Traiwit"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi guys,\nso I have modified FEProblemSolve::solve() in MOOSE folder (/moose_beh/moose/framework/src/executioners/FEProblemSolve.C)\nsuch that it moves on to the next step even if the simulation step isn't converged\nbool\nFEProblemSolve::solve()\n{\n  // This loop is for nonlinear multigrids (developed by Alex)\n  for (MooseIndex(_num_grid_steps) grid_step = 0; grid_step <= _num_grid_steps; ++grid_step)\n  {\n    _problem.solve(_nl.number());\n\n    if (_problem.shouldSolve())\n    {\n      if (_problem.converged(_nl.number()))\n        _console << COLOR_GREEN << \" Solve Converged!\" << COLOR_DEFAULT << std::endl;\n      else\n      {\n        _console << COLOR_RED << \" Solve Did NOT Converge!\" << COLOR_DEFAULT << std::endl;\n        // return false;\n      }\n    }\n    else\n      _console << COLOR_GREEN << \" Solve Skipped!\" << COLOR_DEFAULT << std::endl;\n\n    if (grid_step != _num_grid_steps)\n      _problem.uniformRefine();\n  }\n  // return _problem.converged(_nl.number());\n  return true;\n}\n\nbut I don't want this to be part of the main MOOSE code, I want MOOSE code to remain clean, and do everything in my own app.\nI want to make a subclass that does exactly the same thing as, let's call it 'TransientMod'. How do I bring this modified FEProblemSolve::solve() into it?\nI checked doxegen and i dont see the connection between  Transient.C and FEProblemSolve.C at all.\nHowever, they are in the same folder (src/executioners) in MOOSE main src.\nKind regards,\nTraiwit",
          "url": "https://github.com/idaholab/moose/discussions/27695",
          "updatedAt": "2024-05-24T21:26:43Z",
          "publishedAt": "2024-05-23T01:09:25Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou can either make a new problem class and specify in the s problem block to use it\nOr you can wait a month or so and we will introduce customized convergence objects. These will let you do what you want. The decision on whether something is converged or not will no longer belong to the problem but to a convergence system, of which you will be able to make custom classes\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/27695#discussioncomment-9528568",
                  "updatedAt": "2024-05-23T01:21:33Z",
                  "publishedAt": "2024-05-23T01:21:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Traiwit"
                          },
                          "bodyText": "wow customized convergence objects sounds awesome to me! I can live with this for now.\nThank you @GiudGiud!\nKind regards,\nTrai",
                          "url": "https://github.com/idaholab/moose/discussions/27695#discussioncomment-9528613",
                          "updatedAt": "2024-05-23T01:26:01Z",
                          "publishedAt": "2024-05-23T01:25:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "This line in Transient.C sets up _fixed_point_solve->setInnerSolve(_feproblem_solve);. You can build an object with your modified FEProblemSolve in you TransientMod and set it as the inner object of the existing _fixed_point_solve.",
                          "url": "https://github.com/idaholab/moose/discussions/27695#discussioncomment-9551722",
                          "updatedAt": "2024-05-24T21:27:05Z",
                          "publishedAt": "2024-05-24T21:26:43Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}