{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMS0wNi0yMVQxMzo0MTo0Ni0wNTowMM4ANB5N"
    },
    "edges": [
      {
        "node": {
          "title": "_grad_test variable type using ADKernel? I'm getting an error saying multiplication is an invalid operation.",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "Hi, I'm completely new to Moose. I was following the tutorial posted to YouTube and modifying things here and there, but I'm having trouble computing the residual for a simple diffusion equation. What I have is very similar to the DarcyPressure.C tutorial, but the error message I get says the multiplication \"*\" operand is invalid. Below is the very simple kernel I'm trying to implement:\n`\n#include \"FlowNet.h\"\n#include \"DerivativeMaterialInterface.h\"\nregisterMooseObject(\"farmApp\", FlowNet);\nInputParameters\nFlowNet::validParams()\n{\nInputParameters params = ADKernel::validParams();\nparams.addClassDescription(\"Calculate flow potential under flownet\");\nreturn params;\n}\nFlowNet::FlowNet(const InputParameters & parameters)\n: DerivativeMaterialInterface(parameters),\n_permeability(getMaterialPropertyByName<Real>(\"permeability\"))\n\n{\n}\nADReal\nFlowNet::computeQpResidual()\n{\n/// isotropic permeability\nconst auto & k = _permeability;\nreturn k * _grad_test[_i][_qp] * _grad_u[_qp];\n\n}\n`\nwith the error message:\nerror: no match for 'operator*' (operand types are 'const MaterialProperty' and 'const value_type' {aka 'const libMesh::VectorValue<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, long unsigned int, MetaPhysicL::NWrapper<50> >, true> >'})\nI am also aware that if I use the \"ADKernelGrad\" then I won't need to explicitly add \"_grad_test\" myself, but I wanted to do it with ADKernel.",
          "url": "https://github.com/idaholab/moose/discussions/18146",
          "updatedAt": "2022-11-10T21:02:26Z",
          "publishedAt": "2021-06-23T05:31:55Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "k is a material property right?\nSo it'd be k[_qp] not k to get the value at the quadrature point",
                  "url": "https://github.com/idaholab/moose/discussions/18146#discussioncomment-908248",
                  "updatedAt": "2022-11-10T21:02:31Z",
                  "publishedAt": "2021-06-23T06:06:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "Yes, its a scalar value for the permeability. Would it still be k[_qp] in that case? I don't see how, since it is a single value. I tried it though, and it worked! But I'm not sure why.\nThe example on the tutorial also left it as is (didn't index the quadrature point). (https://youtu.be/2tJwBsYaLaI @3:49:19) mark.",
                          "url": "https://github.com/idaholab/moose/discussions/18146#discussioncomment-908303",
                          "updatedAt": "2022-11-10T21:02:40Z",
                          "publishedAt": "2021-06-23T06:30:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Well in the header for that source file, you can see if it s a scalar (Real or ADReal) or a MaterialProperty\nYou may set it as a scalar in the input file, but MOOSE can convert scalars to material properties when needed",
                          "url": "https://github.com/idaholab/moose/discussions/18146#discussioncomment-908310",
                          "updatedAt": "2022-11-10T21:02:43Z",
                          "publishedAt": "2021-06-23T06:32:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "richmondodufisan"
                          },
                          "bodyText": "I see. That makes sense. Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18146#discussioncomment-908316",
                          "updatedAt": "2022-11-10T21:02:45Z",
                          "publishedAt": "2021-06-23T06:33:51Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "stochastictool - transient_outputs",
          "author": {
            "login": "purepuremilk-zz"
          },
          "bodyText": "Hello, I am running a transient problem with stochastictool. In my transient input file, I have a vectorprocessor that dumps vectors at every time step, which gives me 100 CSVs if I am having 100 steps and output as CSVs. My postprocessor looks like:\n[VectorPostprocessors] [T_sample] type = LineValueSampler num_points = 100 start_point = '0 0.5 -2.5' end_point =   '0 0.5 2.5' variable = T sort_by = z [] []\nNow I am using stochastictool to sample the boundary conditions and would like to gather outputs all transient data from each sample. I am currently using 'Reporter' and 'Transfers'. Meanwhile, I used JSON output as instructed in issue #17895. However, I am having only one vector for each sample instead of all 100 steps in the JSON file. What should I do to output all 100 steps for each sample? Follows are my code for 'Reporter', 'Transfers', and 'Outputs'\n[Transfers] [data] type = SamplerReporterTransfer multi_app = runner execute_on = 'timestep_end' sampler = hypercube stochastic_reporter = storage from_reporter = 'T_sample/z T_sample/T' [] [] [Reporters] [storage] type = StochasticReporter execute_on = 'timestep_end' [] [] [Outputs] [out] type = JSON execute_system_information_on = none [] []",
          "url": "https://github.com/idaholab/moose/discussions/18139",
          "updatedAt": "2022-06-14T20:22:32Z",
          "publishedAt": "2021-06-22T18:32:54Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "If you are using SamplerFullSolveMultiApp, this capability is not available, although we are actively working on it. Another option is to use SamplerTransientMultiApp, but you will need to have a constant time step defined in the main input. This will perform the transfer and output at each time step.",
                  "url": "https://github.com/idaholab/moose/discussions/18139#discussioncomment-907269",
                  "updatedAt": "2023-09-14T14:19:45Z",
                  "publishedAt": "2021-06-22T21:56:09Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "This will also cause a significant slow down because the simulations need to stop at every time step. I think we will be doing some work in this area soon(ish).",
                          "url": "https://github.com/idaholab/moose/discussions/18139#discussioncomment-907521",
                          "updatedAt": "2023-09-14T14:19:49Z",
                          "publishedAt": "2021-06-22T23:44:34Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Variable for use Only in Boundary Condition",
          "author": {
            "login": "AngeloCass"
          },
          "bodyText": "Hello,\nI am wondering if there is a way to have a variable that exists only in a boundary condition and does not require use in a kernel. This variable only exists at the surface or 'top' of the domain or 'mesh'. The variable is coupled with two others in the governing equation. Optimally, I would like to solve for this value only on the surface and neglect it elsewhere. I have not found an effective way to do this. If anyone could provide information on how I may accomplish this, it would be much appreciated.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/18141",
          "updatedAt": "2023-02-16T22:48:39Z",
          "publishedAt": "2021-06-22T19:53:53Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "You can define a block for your sideset/nodeset of interest, then claim the variable to be block-restricted, i.e.\n[Variables]\n  [u]\n    block = top\n  []\n[]\n\nYou may or may not need to turn off the kernel coverage check depending on your setup.",
                  "url": "https://github.com/idaholab/moose/discussions/18141#discussioncomment-907394",
                  "updatedAt": "2023-02-16T22:48:47Z",
                  "publishedAt": "2021-06-22T22:48:49Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "WilkAndy"
                          },
                          "bodyText": "Perhaps LowerDBlockFromSidesetGenerator or ParsedSubdomainMeshGenerator will be of use.  @hugary1995 is suggesting you'll have to include the following in your input file\n[Problem]\n  kernel_coverage_check = false\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/18141#discussioncomment-907419",
                          "updatedAt": "2023-02-16T22:48:41Z",
                          "publishedAt": "2021-06-22T22:57:42Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Symmetry Condition for Plane not Aligned with Cartesian Planes",
          "author": {
            "login": "elementx54"
          },
          "bodyText": "I've got a cylindrical mesh that has a symmetry wedge from 0 to 72 degrees. I'd like to use symmetric boundary conditions to avoid having to simulate the entire cylinder. I understand how to set displacements to zero for symmetric conditions when a symmetry plane is orthogonal to the displacement axis in Cartesian coordinates\nSo my question, is there a boundary condition for tensor mechanics that will allow me to set symmetry displacement conditions on my 72 degree surface whose symmetry plane is not orthogonal to any Cartesian displacement?\nMy geometry is 3D with features that do not allow it to be 2D, 1D, 2D RZ, or 1D RZ.\nThanks!",
          "url": "https://github.com/idaholab/moose/discussions/18135",
          "updatedAt": "2022-08-21T11:30:14Z",
          "publishedAt": "2021-06-22T10:57:57Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "Take a look at inclined no disp BCs https://mooseframework.inl.gov/syntax/BCs/InclinedNoDisplacementBC/index.html",
                  "url": "https://github.com/idaholab/moose/discussions/18135#discussioncomment-906166",
                  "updatedAt": "2022-08-21T11:30:14Z",
                  "publishedAt": "2021-06-22T16:45:16Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "elementx54"
                          },
                          "bodyText": "I tried that with a penalty of 1e9 and my surface did not stay in the plane. Do I just need a higher penalty? Can you put in too high of a penalty?",
                          "url": "https://github.com/idaholab/moose/discussions/18135#discussioncomment-906833",
                          "updatedAt": "2022-08-21T11:30:14Z",
                          "publishedAt": "2021-06-22T19:40:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Most likely yes. But this could also happen if your penalty is too high. I would start with a penalty that is 1x~100x the young's modulus. Automatic scaling also helps to some extent.\nWell, this is the common problem with penalty methods. I remember someone was developing a Nitsche's version, but I don't know the current status of that.",
                          "url": "https://github.com/idaholab/moose/discussions/18135#discussioncomment-907402",
                          "updatedAt": "2022-08-21T11:30:14Z",
                          "publishedAt": "2021-06-22T22:52:10Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "MultiApps - multi core questions",
          "author": {
            "login": "MatiasAllay"
          },
          "bodyText": "Hi MOOSE,\nI'm currently running a simulation using Multiapps. The mode is batch-reset and as a sampler I'm using a CSVSampler that has only two columns but many rows. I'm also using MultiAppCommandLineControl to change materials parameters as it was suggested here #18046. My problem now is that even though I'm using multiple cores when I call the simulation, for each simulation MOOSE is only using one core for each \"multiapp\" (and running one \"multiapp\" at time). Any advice in how can I force MOOSE to use all the available cores?\nCheers,\nMatias",
          "url": "https://github.com/idaholab/moose/discussions/18098",
          "updatedAt": "2022-05-31T08:24:16Z",
          "publishedAt": "2021-06-16T13:59:41Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "jiangwen84"
                  },
                  "bodyText": "By default, each multiapp  uses 1 processor. You can set min_procs_per_app in your MultiApp block  to use multiple processors for each multiapp.",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-878538",
                  "updatedAt": "2022-06-05T05:32:44Z",
                  "publishedAt": "2021-06-16T14:30:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nHave you tried using the min_procs_per_app and min_procs_per_row parameters?\nSee documentation there https://mooseframework.inl.gov/source/multiapps/SamplerFullSolveMultiApp.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-878539",
                  "updatedAt": "2022-06-05T05:32:44Z",
                  "publishedAt": "2021-06-16T14:30:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MatiasAllay"
                  },
                  "bodyText": "Hi MOOSE,\nThanks for your help! I added  min_procs_per_app in my MultiApps block and also min_procs_per_row in my Samplers block as is suggested in the documentation (https://mooseframework.inl.gov/source/multiapps/SamplerFullSolveMultiApp.html) and I set it with the number of processors I want to use, but nothing happens (simulation still runs with one processor although MOOSE \"blocks\" all the available processors).\nAny idea of what else could I try?\nThanks!!\nMatias",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-881763",
                  "updatedAt": "2022-06-05T05:32:45Z",
                  "publishedAt": "2021-06-17T07:19:01Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "aeslaughter"
                          },
                          "bodyText": "@zachmprince Might have some insight into what is happening, if I recall he implemented this capability.",
                          "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-883574",
                          "updatedAt": "2022-06-11T18:57:54Z",
                          "publishedAt": "2021-06-17T14:18:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MatiasAllay"
                          },
                          "bodyText": "Hi @aeslaughter how could we proceed? Shall we move this issue somewhere else? Thanks.",
                          "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-897406",
                          "updatedAt": "2022-06-11T18:57:54Z",
                          "publishedAt": "2021-06-21T11:58:36Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "Thanks for your help! I added min_procs_per_app in my MultiApps block and also min_procs_per_row in my Samplers block as is suggested in the documentation (https://mooseframework.inl.gov/source/multiapps/SamplerFullSolveMultiApp.html) and I set it with the number of processors I want to use, but nothing happens (simulation still runs with one processor although MOOSE \"blocks\" all the available processors).\n\nCould you post the multiapp block of your input file?  I went through SamplerFullSolveMultiApp, but  I did not see anything special.",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-898329",
                  "updatedAt": "2022-06-11T18:57:54Z",
                  "publishedAt": "2021-06-21T14:56:45Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "zachmprince"
                  },
                  "bodyText": "Apologies, I just noticed this discussion. I created an input using a SamplerCSV. You can find the main and sub inputs here. It seemed to work fine with min_procs_per_app and using mpiexec -n 4. It would be helpful to see your input though.",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-898668",
                  "updatedAt": "2022-06-11T18:58:34Z",
                  "publishedAt": "2021-06-21T16:02:12Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "MatiasAllay"
                  },
                  "bodyText": "Hi all,\nThanks for your kind reply. Thanks @zachmprince for the example. I missed the StochasticTools block in my subApp:\n[StochasticTools]\n[]\nNow my simulation seems to run fine!\nThanks\nMatias",
                  "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-899344",
                  "updatedAt": "2022-06-11T18:58:38Z",
                  "publishedAt": "2021-06-21T18:01:18Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "zachmprince"
                          },
                          "bodyText": "Be careful with that syntax. If you use that, the problem won't actually solve. I put that in my sub app input because I'm just testing the partitioning and not solving a problem.",
                          "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-900265",
                          "updatedAt": "2022-06-11T18:58:40Z",
                          "publishedAt": "2021-06-21T23:46:01Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "MatiasAllay"
                          },
                          "bodyText": "You are right... I got excited that my simulation was running fast with  [StochasticTools] in the subApp that I didn't noticed that nothing was happening :(. But today I tried running your example and I got an updated warning, so I updated and now seems to work fine!\nThanks again!\nMatias",
                          "url": "https://github.com/idaholab/moose/discussions/18098#discussioncomment-905386",
                          "updatedAt": "2022-06-11T18:58:39Z",
                          "publishedAt": "2021-06-22T14:27:01Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Surplus E files after executing s3_decomp.i",
          "author": {
            "login": "rl3fz"
          },
          "bodyText": "Hello, I've executed the 's3_decomp.i' file for spinodal decomposition (Step 3 of the phase field tutorial), but in addition to the corresponding file (of type E), 82 other files (of type E-S002, E-S003, E-S004, etc.) were created.\n\nThis didn't happen in previous steps, and by process of elimination the added files seem to be a result of the changes to the mesh and executioner blocks for adaptive meshing.\nIs this supposed to happen? I don't see any difference in mesh quality between the E-S002 file and the E-S083 files, so I'm not sure why they would be necessary in the first place. If this shouldn't happen, advice on preventing it would be greatly appreciated.\n\nI'm also not sure whether I should be using the [./elapsed] or [./active_time] postprocessor to determine the time spent on the simulation. They both seem to work fine, but if one is outdated or has another use, I would appreciate any info here too (I couldn't find documentation for either).",
          "url": "https://github.com/idaholab/moose/discussions/18076",
          "updatedAt": "2023-03-28T15:47:47Z",
          "publishedAt": "2021-06-11T21:14:35Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GregVernon"
                  },
                  "bodyText": "Exodus doesn't (yet) support dynamic mesh topology within a single Exodus file, instead they create a new \"state\" Exodus file (the e-sXXX files) if the mesh connectivity (topology) changes.  Dynamic mesh topology is often caused by using mesh-adaptivity.  ParaView is able to recognize these \"extra\" Exodus files as being sequential so this shouldn't affect visualization in ParaView, if that's a concern.\nYou can find out more about the dynamic topology and Exodus from the SEACAS project page here.",
                  "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-860369",
                  "updatedAt": "2023-03-28T15:47:47Z",
                  "publishedAt": "2021-06-11T22:41:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-905197",
                          "updatedAt": "2023-03-28T15:47:47Z",
                          "publishedAt": "2021-06-22T13:58:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "ngrilli"
                  },
                  "bodyText": "Dear @rl3fz\nYes, it's normal.\nThat happens also if you use element elimination methods that modify the mesh,\nfor instance the one described here:\nhttps://arxiv.org/abs/2105.13257\nand the test cases here:\nhttps://github.com/idaholab/moose/tree/next/test/tests/userobjects/element_subdomain_modifier\nIf you open the main .e file in paraview, the one without -s*,\nall the time steps will be automatically accessible in paraview.\nJust don't delete the -s* files .\nBest Regards,\nNicol\u00f2",
                  "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-865273",
                  "updatedAt": "2023-03-28T15:47:51Z",
                  "publishedAt": "2021-06-13T15:43:33Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-905196",
                          "updatedAt": "2023-03-28T15:47:51Z",
                          "publishedAt": "2021-06-22T13:57:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Wrt to the postprocessors you should use, the PerfGraphData should have all you need for timing your application.\nNote that [./elapsed] or [./active_time] are just the name of the objects, they can be set to anything. What matters for you is the type of the object",
                  "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-900082",
                  "updatedAt": "2023-03-28T15:47:51Z",
                  "publishedAt": "2021-06-21T22:01:16Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rl3fz"
                          },
                          "bodyText": "Thank you!",
                          "url": "https://github.com/idaholab/moose/discussions/18076#discussioncomment-905200",
                          "updatedAt": "2023-03-28T15:47:51Z",
                          "publishedAt": "2021-06-22T13:58:30Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Use of CoupledPenaltyInterfaceDiffusion with vectors",
          "author": {
            "login": "TLWise"
          },
          "bodyText": "I am using the CoupledPenaltyInterfaceDiffusion interface kernel with velocity which is defined as a LAGRANGE_VEC, I have defined the velocity components  (vel_x, vel_y) as AuxKernels. During execution of the code an error is displayed for the variables (velocity, vel_x, vel_y) that I am attempting to use within CoupledPenaltyInterfaceDiffusion. The error indicates that neither of these variables is of the nonlinear type expected by the Kernel. Is there a way to transform these values for use in the CoupledPenaltyInterfaceDiffusion interface kernel?",
          "url": "https://github.com/idaholab/moose/discussions/18068",
          "updatedAt": "2021-07-08T00:48:53Z",
          "publishedAt": "2021-06-11T12:21:24Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi\nThe CoupledPenaltyInterfaceDiffusion expects a non vector variable. You will have to either recode this interface kernel to use a vector variable or use 3 non linear variables for each component of velocity.\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18068#discussioncomment-900075",
                  "updatedAt": "2021-06-21T21:56:33Z",
                  "publishedAt": "2021-06-21T21:56:19Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Get some statistic date from moose in phaseFiled/grain growth model",
          "author": {
            "login": "zengfy-hust"
          },
          "bodyText": "Hello Moose experts:\nI recently get the data i want from moose .however ,except for the visulize file (.e)file .I can also get avg_grain_volume  etc,however ,Can I get the data of each grain's diameter  evlove with time  \uff1f Thank you .",
          "url": "https://github.com/idaholab/moose/discussions/18066",
          "updatedAt": "2021-06-23T09:27:36Z",
          "publishedAt": "2021-06-11T03:14:42Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat kind of object is this avg_grain_volume? If it s a post processor, then it s stored as a global variable in the exodus file and you can view it in paraview\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18066#discussioncomment-900058",
                  "updatedAt": "2021-06-21T21:51:35Z",
                  "publishedAt": "2021-06-21T21:51:21Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Continuity in secondary domain from mesh file input",
          "author": {
            "login": "AnthonyB08"
          },
          "bodyText": "Hi all,\nI am trying to import a mesh file of a pipe with some thickness. This then becomes a two-domain problem. Block id, 3, is the inner volume of the pipe, while block Id 4 is the thickness of the pipe. The interface between the two domains is side set 13 and   12. I would like to impose continuity between the domains, which will require merging these side sets to form an interface or implement a continuity boundary condition at these side sets.\nSide set :13 Block Id =3\n\nSide set :12 Block Id =4",
          "url": "https://github.com/idaholab/moose/discussions/17991",
          "updatedAt": "2023-02-02T17:42:38Z",
          "publishedAt": "2021-06-02T23:24:41Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "AnthonyB08"
                  },
                  "bodyText": "P.S The inner domain was hidden for best illustration. See the mesh of the Side Set depicted as orange.",
                  "url": "https://github.com/idaholab/moose/discussions/17991#discussioncomment-818345",
                  "updatedAt": "2023-02-02T17:42:17Z",
                  "publishedAt": "2021-06-03T00:32:00Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "jiangwen84"
                          },
                          "bodyText": "Potentially, you can use glued contact to enforce the continuity of two blocks. However, it would be much easier to create conforming mesh for two blocks, any reason that you can not do it using your meshing tools?",
                          "url": "https://github.com/idaholab/moose/discussions/17991#discussioncomment-821598",
                          "updatedAt": "2023-02-02T17:42:17Z",
                          "publishedAt": "2021-06-03T15:55:06Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AnthonyB08"
                          },
                          "bodyText": "It is quite a lengthy progress until I can get meshio , from python, to work. I design and mesh my domains in Ansys Fluent. Then import it into Coreform to export as a .e (exodus file). I have glued the two interfaces together but it is then only reading a single block (domain).\n\nI will have to read around.",
                          "url": "https://github.com/idaholab/moose/discussions/17991#discussioncomment-821966",
                          "updatedAt": "2023-02-02T17:42:17Z",
                          "publishedAt": "2021-06-03T17:23:09Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hi Anthony\nYou could use a Parsed meshgenerator to separate the two blocks in moose\nhttps://mooseframework.inl.gov/source/meshgenerators/ParsedSubdomainMeshGenerator.html\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/17991#discussioncomment-900042",
                  "updatedAt": "2023-02-02T17:42:19Z",
                  "publishedAt": "2021-06-21T21:46:55Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Transfer material parameters to a Sub-App (MultiApps)",
          "author": {
            "login": "LabrosV"
          },
          "bodyText": "Hi all,\nIn my main app, I declare a Material Property, which is different at each quadrature point (and can be considered as a history variable).\nWhen I needed to use a staggered scheme between 2 coupled fields, I used the MultiApp system to do so. The aforementioned history variable is requested in the sub app but it cannot be transferred based on other posts I read here. I managed to convert this Material Property into AuxVariable (that can be transferred) using MaterialRealAux but this approach makes this history variable constant throughout the element in the sub-app.\nQuestions:\n\n\nHow can I convert this material property into AuxVariable with higher order (not constant)? Please consider that I want to be able to run my code in a cluster (so higher order approximations at element level (i.e. the MONOMIAL option with high order) cannot be used because they cannot run in parallel).\n\n\nI created an AuxKernel which returns an AuxVariable based on the values of the Material Property. However, I think this solution is wrong because this kernel must run on a nodal variable and not material property. Can I use an AuxKernel to convert the data? Any suggestion for a Postprocessor method that I have overlooked?\n\n\nShould I change my implementation in the main app and declare an AuxVariable instead of a Material Property? Then, it will be easier to transfer it.\n\n\nAny alternative ways to implement a staggered scheme without using the MultiApps system? Maybe a field-split solver in the executioner?\n\n\nAnswers to any of these questions are much appreciated.\nThanks,\nLabros",
          "url": "https://github.com/idaholab/moose/discussions/18104",
          "updatedAt": "2022-07-08T08:04:20Z",
          "publishedAt": "2021-06-17T02:03:56Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nTransferring to AuxVariables is the right thing to do here. However, using a higher order AuxVariable and essentially projecting the material property may not have been implemented. @fdkong worked on projections for transfers, which is a similar issue, he should be able to tell us more.\nAuxKernels are the right way to copy MaterialProperties onto an AuxKernel. Postprocessors will only process like one value for the whole domain.\nIf that is an option, I think it would work. Then you will avoid the projection issue.\nField split executioner is an option but it s not really staggered. Please let us know how that goes if you try it. Multiapp is the easier option for staggering.\nbest,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/18104#discussioncomment-898633",
                  "updatedAt": "2022-07-08T08:04:19Z",
                  "publishedAt": "2021-06-21T15:53:51Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "fdkong"
                  },
                  "bodyText": "How can I convert this material property into AuxVariable with higher order (not constant)? Please consider that I want to be able to run my code in a cluster (so higher order approximations at element level (i.e. the MONOMIAL option with high order) cannot be used because they cannot run in parallel).\n\nWhat error messages you saw when using higher order variables?  MaterialRealAux should work with  higher order variables and it will do projections.\n\nI created an AuxKernel which returns an AuxVariable based on the values of the Material Property. However, I think this solution is wrong because this kernel must run on a nodal variable and not material property. Can I use an AuxKernel to convert the data? Any suggestion for a Postprocessor method that I have overlooked?\n\nYes, but  MaterialRealAux should do right things for you. AuxKernels can run on either nodal variables or elemental variables.\n\nShould I change my implementation in the main app and declare an AuxVariable instead of a Material Property? Then, it will be easier to transfer it.\n\nThis option will work, but it is not necessary if your code already with materials.\n\nAny alternative ways to implement a staggered scheme without using the MultiApps system? Maybe a field-split solver in the executioner?\n\nA field-split solver  is a preconditioner, and it does not fit well for your purpose here.\nHowever, even you have a high order variable using, and the current implementation of transfers does not work well with high order variables yet. We have a PR here #17417 for enabling high-order variable transfers",
                  "url": "https://github.com/idaholab/moose/discussions/18104#discussioncomment-899497",
                  "updatedAt": "2022-07-08T08:04:19Z",
                  "publishedAt": "2021-06-21T18:41:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}