{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyNS0wMi0wN1QxMzoyMzo0Mi0wNjowMM4AeIgc"
    },
    "edges": [
      {
        "node": {
          "title": "question about running moose",
          "author": {
            "login": "HPL001"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHello, I run Moose from the command line with the following command. Mine uses WSL mode to install (installed on disk D) and run Moose. I now want to save the output file to another disk (J disk), how should I modify my command?\nmpiexec -n 88 ./combined-opt -i Fe_iso.i Outputs/file_base='./datas/Fe/01/out'",
          "url": "https://github.com/idaholab/moose/discussions/29840",
          "updatedAt": "2025-02-09T18:57:53Z",
          "publishedAt": "2025-02-08T03:21:40Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis looks like a fine way to do it.\nThe file base will let you change the output directory\n./ would be the local path not the absolute path.",
                  "url": "https://github.com/idaholab/moose/discussions/29840#discussioncomment-12100466",
                  "updatedAt": "2025-02-09T19:02:19Z",
                  "publishedAt": "2025-02-08T03:28:38Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "HPL001"
                          },
                          "bodyText": "But now my commands can only be output in this directory, if I want to change the output disk, I use this code\uff0c\nOutputs/file_base='/mnt/J/datas/Fe/01/out'\nstill in the original directory output.",
                          "url": "https://github.com/idaholab/moose/discussions/29840#discussioncomment-12100488",
                          "updatedAt": "2025-02-08T03:31:49Z",
                          "publishedAt": "2025-02-08T03:31:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You could do this with ../ to back out of the current directory. We dont support absolute paths there afaik",
                          "url": "https://github.com/idaholab/moose/discussions/29840#discussioncomment-12110511",
                          "updatedAt": "2025-02-09T18:57:54Z",
                          "publishedAt": "2025-02-09T18:57:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Boundary Conditions in different direction",
          "author": {
            "login": "YuanxinXiao"
          },
          "bodyText": "Hi @GiudGiud\n\nI want to impose a Dirichlet bc that follows the rod, but the direction of the rod is 45 degrees from the coordinate system x and y axes, so I multiply cos(45) in front of the disp_x of the FunctionDirichletBC, but I get the following error, is there any way can help me to realize it\uff1f\ncode:\n[topx]\ntype = FunctionDirichletBC\nvariable = cos(45)* disp_x\nboundary = 'frontbar_rightside_1'\nfunction = '-1e-3sin(t)'\n[]\n[botx]\ntype = FunctionDirichletBC\nvariable = cos(45) * disp_x\nboundary = 'frontbar_leftside_1'\nfunction = '1e-3t'\n[]\nerror:\nexpected '=' after parameter name '*', got 'd'\ufffd",
          "url": "https://github.com/idaholab/moose/discussions/29842",
          "updatedAt": "2025-02-09T06:00:48Z",
          "publishedAt": "2025-02-08T18:23:59Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nvariable expects a name, not an expression so this variable = cos(45)* disp_x is not allowed.\nWhat you have to do is set 4 BCs here:\n\n1 for disp_x on frontbar_rightside_1 with cos(45) times the displacement (note that cos(45) might be wrong, best use sqrt(2)/2)\n1 for disp_y on frontbar_rightside_1 with sin(45) times the displacement (note that sin(45) might be wrong, best use sqrt(2)/2\nsame for the other boundary",
                  "url": "https://github.com/idaholab/moose/discussions/29842#discussioncomment-12106102",
                  "updatedAt": "2025-02-09T01:05:04Z",
                  "publishedAt": "2025-02-09T01:05:03Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "YuanxinXiao"
                          },
                          "bodyText": "Thank you very much, as you said I applied x and y directions separately and multiplied their components in function and they worked well!\n[topy]\ntype = FunctionDirichletBC\nvariable = disp_y\nboundary = 'frontbar_rightside_1 '\nfunction = '-2e-2sin(0.05pit)sqrt(2)/2'\n[]\n[boty]\ntype = FunctionDirichletBC\nvariable = disp_y\nboundary = 'frontbar_leftside_1'\nfunction = '2e-2sin(0.05pit)sqrt(2)/2'\n[]\n[topx]\ntype = FunctionDirichletBC\nvariable = disp_x\nboundary = 'frontbar_rightside_1 '\nfunction = '-2e-2sin(0.05pit)sqrt(2)/2'\n[]\n[botx]\ntype = FunctionDirichletBC\nvariable = disp_x\nboundary = ' frontbar_leftside_1'\nfunction = '2e-2sin(0.05pi*t)*sqrt(2)/2'\n[]\nBut then I am facing a second problem, when I compress this rod on the ab-plane, the rod bends as shown in the picture, and I want to avoid this phenomenon. Before when the bar was parallel to the x-axis of the coordinate system, I always controlled disp_y = 0 for bc1 and bc2 to avoid this deformation, but now that the bar has a 45-degree pinch foot to the coordinate axis, I can't get the bar to contract freely in the direction of pressure by simply setting disp_y = 0 or disp_x = 0. Do you have a good method to make the bar not only straight but also free to contract?",
                          "url": "https://github.com/idaholab/moose/discussions/29842#discussioncomment-12106700",
                          "updatedAt": "2025-02-09T05:01:32Z",
                          "publishedAt": "2025-02-09T05:01:31Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "if you could use a dirichletBC to achieve what you want in the non-inclined case, you should be able to use this bc in the inclined case\nhttps://mooseframework.inl.gov/source/bcs/PenaltyInclinedNoDisplacementBC.html",
                          "url": "https://github.com/idaholab/moose/discussions/29842#discussioncomment-12106868",
                          "updatedAt": "2025-02-09T06:00:49Z",
                          "publishedAt": "2025-02-09T06:00:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Large Deformation Formulation",
          "author": {
            "login": "drebbel1z"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nIs it possible to point me to some tutorials that will explain moose's large deformation formulation? I am trying to understand the formulation but haven't found enough details around the documentation. I would appreciate any leads. Thank you.",
          "url": "https://github.com/idaholab/moose/discussions/29823",
          "updatedAt": "2025-02-08T16:45:32Z",
          "publishedAt": "2025-02-06T16:25:06Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nthe summary of all our strain models are here\nhttps://mooseframework.inl.gov/modules/solid_mechanics/Strains.html\nwe are adding more dynamics capability if that's what you're looking for",
                  "url": "https://github.com/idaholab/moose/discussions/29823#discussioncomment-12084199",
                  "updatedAt": "2025-02-06T16:29:52Z",
                  "publishedAt": "2025-02-06T16:29:51Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "drebbel1z"
                  },
                  "bodyText": "Hi,\nAssuming I am using the finite strain formulation for isotropic plasticity, will this still be using the additive decomposition of strains or will it swtich to multiplicative decomposition?",
                  "url": "https://github.com/idaholab/moose/discussions/29823#discussioncomment-12103655",
                  "updatedAt": "2025-02-08T15:23:11Z",
                  "publishedAt": "2025-02-08T15:21:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "I don't think we do multiplicative decomposition. Do you have a page that references it in moose so I can read up on it?",
                          "url": "https://github.com/idaholab/moose/discussions/29823#discussioncomment-12103773",
                          "updatedAt": "2025-02-08T15:43:35Z",
                          "publishedAt": "2025-02-08T15:43:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "drebbel1z"
                          },
                          "bodyText": "I did not find a page on it. I just wanted to confirm because the isotropic plasticity page is written in additive decomposition. Can I still use this when the strains are finite?",
                          "url": "https://github.com/idaholab/moose/discussions/29823#discussioncomment-12104114",
                          "updatedAt": "2025-02-08T16:45:33Z",
                          "publishedAt": "2025-02-08T16:45:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Control system",
          "author": {
            "login": "mdh23rct"
          },
          "bodyText": "Dear all,\nI am having a physical problem to be solved. I describe the problem:\n\nFirst, I would introduce new phase nuclei in the parent micro-structure.\nNext, let the nuclei grow for 10 s, generating new grain boundaries.\nAfter 10 s, I will introduce new phase nuclei in the updated microstructure.\n\nThese three steps will repeat at 10 s intervals of 3000 s physical computation time. My question is can I use the control system to recycle these three steps every 10 s interval without writing the control block 300 times?\nThanks.",
          "url": "https://github.com/idaholab/moose/discussions/29796",
          "updatedAt": "2025-02-08T14:38:26Z",
          "publishedAt": "2025-02-03T10:15:51Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nSo you plan to have all kernels defined from the start but only have a few active at the beginning and increasingly turn them on with the Control system?\nI think this is possible. I would recommend however:\n\nwrite an action to define the 300 sets of kernels, variables and whatever is tracking the grain boundaries\nwrite a custom control (rather than having 300 control objects at each of the 300 times) that works with all the previously created objects.",
                  "url": "https://github.com/idaholab/moose/discussions/29796#discussioncomment-12044614",
                  "updatedAt": "2025-02-03T16:31:48Z",
                  "publishedAt": "2025-02-03T16:31:48Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "@GiudGiud\nThe control system looks like this:\n\"[c1]\ntype = TimePeriod\nenable_objects = 'BCs::rot_x BCs::rot_y'\ndisable_objects = 'BCs::rot_x90 BCs::rot_y90 BCs::press'\nstart_time = '0'\nend_time = '10'\n[]\n[c2]\ntype = TimePeriod\nenable_objects = 'BCs::rot_x90 BCs::rot_y90 BCs::press'\ndisable_objects = 'BCs::rot_x BCs::rot_y '\nstart_time = '10'\nend_time = '20'\n[]\"\nI have to repeat [c1] and [c2] 300 times sequentially. The question is how to do that? Any suggestion how the custom control could look like?\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/29796#discussioncomment-12052874",
                          "updatedAt": "2025-02-04T09:34:44Z",
                          "publishedAt": "2025-02-04T09:34:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "you can use a python script to write the 300 controls.\nOR\nyou create a new control objects. Something like:\n[c_all]\n  type = TimesSequentialControl. (this is a new name, does not exist)\n  enable_objects_of_prefix = BCs::rot_x\n  disable_objects_of_prefix = BCs::rot_x\n  start_times = 'start_times'\n  end_times = 'end_times'\n[]\n\nand you can use the Times to define the time points\n[Times]\n  [start_times]\n    type = TimeIntervalTimes\n    start_time = 0\n    end_time = ${fparse 300 * 90}\n    time_interval = 90\n  []\n  [end_times]\n    type = TimeIntervalTimes\n    start_time = 90\n    end_time = ${fparse 90 + 300 * 90}\n    time_interval = 90\n  []\n[]\n\nThe TimesSequentialControl would look a little bit like the TimesEnableControl",
                          "url": "https://github.com/idaholab/moose/discussions/29796#discussioncomment-12056962",
                          "updatedAt": "2025-02-04T16:16:35Z",
                          "publishedAt": "2025-02-04T16:16:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "@GiudGiud I am having this issue:\n\"*** ERROR ***\nA 'TimesEnableControl' is not a registered object.\nIf you are trying to find this object in a dynamically loaded library, make sure that\nthe library can be found either in your \"Problem/library_path\" parameter or in the\nMOOSE_LIBRARY_PATH environment variable.\"\nI looked at the moose phase_field src folder. There, the control folder is missing.\nWhere to find the source file of TimeEnableControl?\nThanks.",
                          "url": "https://github.com/idaholab/moose/discussions/29796#discussioncomment-12081636",
                          "updatedAt": "2025-02-06T12:54:44Z",
                          "publishedAt": "2025-02-06T12:54:43Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "hello\nhow old is your version of MOOSE?\nTimesEnableControl has existed for a couple of months now\nhttps://mooseframework.inl.gov/source/controls/TimesEnableControl.html\n\nWhere to find the source file of TimeEnableControl?\n\nit s in framework/src/controls",
                          "url": "https://github.com/idaholab/moose/discussions/29796#discussioncomment-12084424",
                          "updatedAt": "2025-02-06T16:51:42Z",
                          "publishedAt": "2025-02-06T16:51:42Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "@GiudGiud more than a year old. If I update moose, will the problem be solved?",
                          "url": "https://github.com/idaholab/moose/discussions/29796#discussioncomment-12084469",
                          "updatedAt": "2025-02-06T16:55:47Z",
                          "publishedAt": "2025-02-06T16:55:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes",
                          "url": "https://github.com/idaholab/moose/discussions/29796#discussioncomment-12084486",
                          "updatedAt": "2025-02-06T16:57:23Z",
                          "publishedAt": "2025-02-06T16:57:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "@GiudGiud I updated the moose folder. However it has messed up the whole moose installation. The applications are not working anymore.",
                          "url": "https://github.com/idaholab/moose/discussions/29796#discussioncomment-12085512",
                          "updatedAt": "2025-02-06T18:36:05Z",
                          "publishedAt": "2025-02-06T18:36:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "it's not just updating the folders. You need to update libmesh/petsc, then moose, then the applications. Everything has to be consistent.\nYou could consider just starting a fresh install if you have already muddled some steps",
                          "url": "https://github.com/idaholab/moose/discussions/29796#discussioncomment-12085925",
                          "updatedAt": "2025-02-06T19:22:07Z",
                          "publishedAt": "2025-02-06T19:22:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "mdh23rct"
                          },
                          "bodyText": "@GiudGiud yes, started a new installation. However solving environment taking forever! Any suggestion how to accelerate it? trying to install moose-dev =2024.12.23",
                          "url": "https://github.com/idaholab/moose/discussions/29796#discussioncomment-12086566",
                          "updatedAt": "2025-02-06T20:32:11Z",
                          "publishedAt": "2025-02-06T20:32:10Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "create a new conda environment too.\nalso update conda because installing. conda update conda",
                          "url": "https://github.com/idaholab/moose/discussions/29796#discussioncomment-12086574",
                          "updatedAt": "2025-02-06T20:33:31Z",
                          "publishedAt": "2025-02-06T20:33:29Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "co-sintering in moose",
          "author": {
            "login": "abc-hy"
          },
          "bodyText": "Hi,\nI was wondering if moose has a way to implement co-sintering of two types of materials. Currently, I only found there is a GrandPotentialTensorMaterial that can deal with one type of material's sintering, because I can only input one type of material's property values. Does anyone know how to input two types of materials and can run the co-sintering of the two materials in moose?\nThank you very much.\nBest,",
          "url": "https://github.com/idaholab/moose/discussions/29841",
          "updatedAt": "2025-02-08T14:17:36Z",
          "publishedAt": "2025-02-08T14:17:35Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": []
          }
        }
      },
      {
        "node": {
          "title": "Voronoi tessellation",
          "author": {
            "login": "sidharthsarmah"
          },
          "bodyText": "Hi @GiudGiud ,\nI want to create a voronoi tessellation of a steel sample and perform diffusion modelling. It has different types of grains and grain boundaries, I dont find lot of text related to VT in MOOSE, can you please suggest.",
          "url": "https://github.com/idaholab/moose/discussions/29558",
          "updatedAt": "2025-02-08T00:49:20Z",
          "publishedAt": "2024-12-17T02:33:15Z",
          "category": {
            "name": "Q&A Modules: Phase field"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThere are plenty of options. See the PropertyReadFile to be able to load data using a voronoi distribution. Then once this data is in a FUnction you can use it to assign subdomains, (through FunctionAux + CoupledVarSubdomainModifier), to assign material properties (using the same PropertyReadFile) etc",
                  "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11587926",
                  "updatedAt": "2024-12-17T02:37:25Z",
                  "publishedAt": "2024-12-17T02:37:23Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Does that mean I have to generate the coordinates using another code and use the coordinates as input in MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11588245",
                          "updatedAt": "2024-12-17T03:35:01Z",
                          "publishedAt": "2024-12-17T03:35:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "There might be a random voronoi generator in moose. Look through the ICs in phase field maybe",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11588400",
                          "updatedAt": "2024-12-17T04:08:14Z",
                          "publishedAt": "2024-12-17T04:08:13Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud, I will need some help on it, as this is the first I am working on VT:\n\n\nUsing Python, I created a VT which looks something like this, and gives me x and y coordinates of the vertices:\n\n\nNow, this goes into the MOOSE right?\n\n\nIf so, how do I obtain the finite element of each grains in MOOSE?\n\n\nOr do I need to create a meshed of each tessellation in ABAQUS (by inserting the python generated VT as inputs) and then input the generated mesh from ABAQUS in MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11612827",
                          "updatedAt": "2024-12-22T05:26:32Z",
                          "publishedAt": "2024-12-19T04:04:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Now, this goes into the MOOSE right?\n\nYou can load the coordinate in a PropertyReadFile in Voronoi mode yes\n\nIf so, how do I obtain the finite element of each grains in MOOSE?\n\nin phase field, I have seen overlaying the VT on top of a Cartesian mesh instead. Then assign elements based on the VT\n\nOr do I need to create a meshed of each tessellation in ABAQUS (by inserting the python generated VT as inputs) and then input the generated mesh from ABAQUS in MOOSE?\n\nThis works! Just do whatever works imo",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11613036",
                          "updatedAt": "2024-12-19T04:59:24Z",
                          "publishedAt": "2024-12-19T04:59:23Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "@GiudGiud , can you suggest if there are other ways (library/ software) to mesh the generate VT cells from Python which can be inserted into MOOSE?",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11613088",
                          "updatedAt": "2024-12-19T05:08:48Z",
                          "publishedAt": "2024-12-19T05:08:47Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "Hi @GiudGiud . Also, this is one example I found in MOOSE, its does not align with the grain but rather is just x, y coord in MOOSE.\nmodules/phase_field/test/tests/initial_conditions/PolycrystalVoronoiIC_periodic.i\nDoes that mean I have to mesh it somewhere else and insert it in MOOSE:",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11613507",
                          "updatedAt": "2024-12-22T05:26:42Z",
                          "publishedAt": "2024-12-19T06:29:27Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Does that mean I have to mesh it somewhere else and insert it in MOOSE:\n\nIf you dont like how they do it in phase field, then yes.\nAlternatively, we do have the capability to generate 2D tetrahedral meshes\nhttps://mooseframework.inl.gov/source/meshgenerators/XYDelaunayGenerator.html\nIf you could input the boundaries of the VT, you could use that to generate the mesh.\nYou could also make an integrated capability (loads the VT then meshes it) by creating a new mesh generator",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11617677",
                          "updatedAt": "2024-12-19T13:47:27Z",
                          "publishedAt": "2024-12-19T13:47:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "can you suggest if there are other ways (library/ software) to mesh the generate VT cells from Python which can be inserted into MOOSE?\n\nI am sure there are hundreds of python packages to generate VTs. This is a very common model",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11617697",
                          "updatedAt": "2024-12-19T13:47:56Z",
                          "publishedAt": "2024-12-19T13:47:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "sidharthsarmah"
                          },
                          "bodyText": "hi @GiudGiud thanks, lets say I am doing a diffusion problem along the grain (cL, DL) and grain boundary (cBG, DGB).\nif I use these kernels, how will MOOSE determine whether I am solving eqn 1 or 2, ie the two PDE together or separately?",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11619365",
                          "updatedAt": "2024-12-22T05:26:58Z",
                          "publishedAt": "2024-12-19T16:11:00Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Are these equations supposed to be block restricted?",
                          "url": "https://github.com/idaholab/moose/discussions/29558#discussioncomment-11619393",
                          "updatedAt": "2024-12-19T16:13:40Z",
                          "publishedAt": "2024-12-19T16:13:39Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Question about the FVFunctorRadiativeBC Boundary Condition",
          "author": {
            "login": "CadenWil"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi, this is my first time posting. I am currently learning Moose and decided to work with problems that I know the answer to.\nI have been working on recreating example problem 3.1 from the Fundamentals of Heat and Mass Transfer 6th Edition in Moose with the goal of understanding units, convective boundaries, radiative boundaries, and heat conduction. This problem is split into two parts one with water and the other with air as the cold fluid.  This is the problem statement:\n\"\"\" In Example 1.6, we calculated the heat loss rate from a human body in air and water\nenvironments. Now we consider the same conditions except that the surroundings\n(air or water) are at 10\ufffdC. To reduce the heat loss rate, the person wears special\nsporting gear (snow suit and wet suit) made from a nanostructured silica aerogel in-\nsulation with an extremely low thermal conductivity of 0.014 W/m  K. The emis-\nsivity of the outer surface of the snow and wet suits is 0.95. What thickness of aero-\ngel insulation is needed to reduce the heat loss rate to 100 W (a typical metabolic\nheat generation rate) in air and water? What are the resulting skin temperatures? \"\"\"\nThe using the variables given in the book I first focused on calculating the outer surface temperature of the insulation layer if the cold fluid was water.  This went well and I was able to get MOOSE and hand calculations to agree on the outer surface temperature of the insulation layer at 283.427\nThis is the input file I created:\n\"\"\"\n[Mesh]\n[generated]\ntype = GeneratedMeshGenerator\ndim = 2\nnx = 300\nny = 300\nxmin = 0\nxmax = 0.0091\nymax = 0.01\n[]\n[block1]\ntype = SubdomainBoundingBoxGenerator\ninput = generated\nblock_id = 1\nbottom_left = '0 0 0'\ntop_right = '0.003 0.01 0'\n[]\n[block2]\ntype = SubdomainBoundingBoxGenerator\ninput = block1\nblock_id = 2\nbottom_left = '0.003 0 0'\ntop_right = '0.0091 0.01 0'\n[]\n[]\n[Variables]\n[T]\ninitial_condition = 308.15\n[]\n[]\n[Kernels]\n[heat_conduction]\ntype = HeatConduction\nvariable = T\n[]\n[time_derivative]\ntype = HeatConductionTimeDerivative\nvariable = T\n[]\n[]\n[Materials]\n[thermal_skin]\ntype = HeatConductionMaterial\nthermal_conductivity = 0.3\nspecific_heat = 4.184\nblock = 1\n[]\n[density_skin]\ntype = GenericConstantMaterial\nprop_names = 'density'\nprop_values = 1.0\nblock = 1\n[]\n[thermal_ins]\ntype = HeatConductionMaterial\nthermal_conductivity = 0.014\nspecific_heat = 2.5\nblock = 2\n[]\n[density_ins]\ntype = GenericConstantMaterial\nprop_names = 'density'\nprop_values = 0.8\nblock = 2\n[]\n[]\n[BCs]\n[t_left]\ntype = DirichletBC\nvariable = T\nvalue = 308.15\nboundary = 'left'\n[]\n[convect_right]\ntype = ConvectiveHeatFluxBC\nvariable = T\nboundary = 'right'\nT_infinity = 283.15\nheat_transfer_coefficient = 200\n[]\n[]\n[Executioner]\ntype = Transient\nsolve_type = 'NEWTON'\npetsc_options_iname = '-pc_type -pc_factor_shift_type'\npetsc_options_value = 'lu       NONZERO'\n[TimeStepper]\ntype = IterationAdaptiveDT\ndt = 1e-3\noptimal_iterations = 6\n[]\nend_time = 5000\nnl_abs_tol = 1e-9\nnl_max_its = 50\nline_search = 'none'\nautomatic_scaling = true\noff_diagonals_in_auto_scaling = true\ncompute_scaling_once = false\n[]\n[Outputs]\nexodus = true\n[]\n\"\"\"\nI then moved to the second problem using air rather than water.  This adds a radiative boundary condition to the problem in conjunction with the convective boundary condition. I changed the necessary variables and added a FVFunctorRadiativeBC to the input.  The hand calculation indicated that the temperature would be in the ballpark of 290.18 K.  However the result of the MOOSE calculation yielded 249.12 K which is colder than the outside fluid. Below is the input file that I created.  I'm uncertain why I am getting a nonsensical answer with this input. I do get the correct answer if I instead choose to add the radiation heat transfer coefficient to the convective heat transfer coefficient in the ConvectiveHeatFluxBC and remove the FVFunctorRadiativeBC entirely.\n\"\"\"\n[Mesh]\n[generated]\ntype = GeneratedMeshGenerator\ndim = 2\nnx = 32\nny = 32\nxmin = 0\nxmax = 0.0074\nymax = 0.01\n[]\n[block1]\ntype = SubdomainBoundingBoxGenerator\ninput = generated\nblock_id = 1\nbottom_left = '0 0 0'\ntop_right = '0.003 0.1 0'\n[]\n[block2]\ntype = SubdomainBoundingBoxGenerator\ninput = block1\nblock_id = 2\nbottom_left = '0.003 0 0'\ntop_right = '0.0074 0.1 0'\n[]\n[]\n[Variables]\n[T]\ninitial_condition = 308.15\n[]\n[]\n[Kernels]\n[heat_conduction]\ntype = HeatConduction\nvariable = T\n[]\n[time_derivative]\ntype = HeatConductionTimeDerivative\nvariable = T\n[]\n[]\n[Materials]\n[thermal_skin]\ntype = HeatConductionMaterial\nthermal_conductivity = 0.3\nspecific_heat = 4.184\nblock = 1\n[]\n[density_skin]\ntype = GenericConstantMaterial\nprop_names = 'density'\nprop_values = 1.0\nblock = 1\n[]\n[thermal_ins]\ntype = HeatConductionMaterial\nthermal_conductivity = 0.014\nspecific_heat = 2.5\nblock = 2\n[]\n[density_ins]\ntype = GenericConstantMaterial\nprop_names = 'density'\nprop_values = 0.8\nblock = 2\n[]\n[]\n[BCs]\n[t_left]\ntype = DirichletBC\nvariable = T\nvalue = 308.15\nboundary = 'left'\n[]\n[convect_right]\ntype = ConvectiveHeatFluxBC\nvariable = T\nboundary = 'right'\nT_infinity = 283.15\nheat_transfer_coefficient = 2\n[]\n[Radiative_right]\n# htc/(stefan-boltzmann4T_inf^3)\ntype = FunctionRadiativeBC\nvariable = T\nboundary = 'right'\nemissivity_function = '5.9/(5.670367e-84283.15283.15283.15)'\n[]\n[]\n[Executioner]\ntype = Transient\nsolve_type = 'NEWTON'\npetsc_options_iname = '-pc_type -pc_factor_shift_type'\npetsc_options_value = 'lu       NONZERO'\n[TimeStepper]\ntype = IterationAdaptiveDT\ndt = 1e-3\noptimal_iterations = 6\n[]\nend_time = 5000\nnl_abs_tol = 1e-9\nnl_max_its = 50\nline_search = 'none'\nautomatic_scaling = true\noff_diagonals_in_auto_scaling = true\ncompute_scaling_once = false\n[]\n[Outputs]\nexodus = true\n[]\n\"\"\"\nThanks for any help that you can offer.",
          "url": "https://github.com/idaholab/moose/discussions/29838",
          "updatedAt": "2025-02-07T21:56:35Z",
          "publishedAt": "2025-02-07T21:10:53Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThe FunctionRadiativeBC has a default of 0 for the far field temperature that the surface exchanges heat with. You ll want to use the true value instead (probably around 300 or something, from the problem specifications)\nSee the T_infinity parameter here\nhttps://mooseframework.inl.gov/source/fvbcs/FVFunctorRadiativeBC.html",
                  "url": "https://github.com/idaholab/moose/discussions/29838#discussioncomment-12098931",
                  "updatedAt": "2025-02-07T21:16:10Z",
                  "publishedAt": "2025-02-07T21:14:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "CadenWil"
                          },
                          "bodyText": "Thanks you!  Adding that in gave me an answer of 290.04 K which is much closer to the 290.18 K I got from the hand calculation.",
                          "url": "https://github.com/idaholab/moose/discussions/29838#discussioncomment-12099171",
                          "updatedAt": "2025-02-07T21:56:15Z",
                          "publishedAt": "2025-02-07T21:56:14Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Interoperability between MOOSE versions (MPICH & OpenMPI)",
          "author": {
            "login": "richmondodufisan"
          },
          "bodyText": "Check these boxes if you have followed the posting rules.\n\n Q&A General is the most appropriate section for my question\n I have consulted the posting Guidelines on the Discussions front page\n I have searched the Discussions forum and my question has not been asked before\n I have searched the MOOSE website and the documentation does not answer my question\n I have formatted my post following the posting guidelines (screenshots as a last resort, triple back quotes around pasted text)\n\nQuestion\nHi,\nI recently did a fresh install of MOOSE on my laptop and noticed some custom objects I created had now been included in MOOSE (e.g NodesetGenerator), which was nice. However, the IT admins were unable to install the latest version because it apparently uses OpenMPI (not installed on our HPC) instead of MPICH now (their explanation). They had to switch back to an earlier \"development container\" (e930b1d) and the 2024-11-11 release.\nI am not really familiar with the IT side of things, so everything above is the literal explanation I was given. Ideally I'd like to develop objects for my physics on the same version, but seeing as I installed this local version of MOOSE recently (two weeks ago, in a conda environment following the website instructions), I was wondering if the versions are close enough to have no compatibility issues, and if not, how can I revert to the 2024-11-11 release?",
          "url": "https://github.com/idaholab/moose/discussions/29837",
          "updatedAt": "2025-02-07T21:09:00Z",
          "publishedAt": "2025-02-07T20:55:34Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nIf you are asking about dynamic linking loading across platforms and MPI compilers, this wont work.\nIf you are asking about developing source code on your machine, and porting it to your IT-managed platform and re-compiling it there, this will work with no issue as not that much as changed in MOOSE over two months. The APIs should be the same for 99% of the code. Most of the changes you can see summarized here:\nhttps://mooseframework.inl.gov/newsletter/2024/2024_11.html\nhttps://mooseframework.inl.gov/newsletter/2024/2024_12.html\nhttps://mooseframework.inl.gov/newsletter/2025/2025_01.html\n\nHowever, the IT admins were unable to install the latest version because it apparently uses OpenMPI (not installed on our HPC) instead of MPICH now (their explanation).\n\nDo you know how they are installing moose? With a container / docker?\nThe installation from source would work with MPICH the same way it does with OpenMPI.",
                  "url": "https://github.com/idaholab/moose/discussions/29837#discussioncomment-12098889",
                  "updatedAt": "2025-02-07T21:09:55Z",
                  "publishedAt": "2025-02-07T21:09:00Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Calculate/Measure Crack Length",
          "author": {
            "login": "rh201"
          },
          "bodyText": "Dear all,\nIn the phase-field fracture simulation, how to calculate and output the crack length to a .csv file? Or how to do it in the post-processing? Thanks.",
          "url": "https://github.com/idaholab/moose/discussions/29835",
          "updatedAt": "2025-02-07T19:29:20Z",
          "publishedAt": "2025-02-07T16:10:38Z",
          "category": {
            "name": "Q&A Modules: General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Are you using XFEM too?\nHow is the crack being simulated?",
                  "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12098093",
                  "updatedAt": "2025-02-07T19:24:31Z",
                  "publishedAt": "2025-02-07T19:24:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "rh201"
                          },
                          "bodyText": "Hi~I'm using phase-field model in MOOSE.",
                          "url": "https://github.com/idaholab/moose/discussions/29835#discussioncomment-12098129",
                          "updatedAt": "2025-02-07T19:29:21Z",
                          "publishedAt": "2025-02-07T19:29:20Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "slipsystem.C file",
          "author": {
            "login": "Emmanuel-324"
          },
          "bodyText": "I am trying to locate the sourcecode that contains the code for different types of crystal structures used in the crystal plasticity model.\nBelow is a snippet of the relevant code:\n[trial_xtalpl_phase0]\n    type = CrystalPlasticityKalidindiUpdate\n    number_slip_systems = 12\n    slip_sys_file_name = input_slip_sys.txt\n    crystal_lattice_type = BCC\n    resistance_tol = 0.01\n    r = 1.4             \n    h = 6000            \n    t_sat = 598.5        \n    gss_a = 1.5         \n    ao = 0.001           \n    xm = 0.017             \n    gss_initial = 400\n    base_name = phase0\n  []\n\nBelow is also the CrystalPlasticityKalidindiUpdate.C\n//* This file is part of the MOOSE framework\n//* https://www.mooseframework.org\n//*\n//* All rights reserved, see COPYRIGHT for full restrictions\n//* https://github.com/idaholab/moose/blob/master/COPYRIGHT\n//*\n//* Licensed under LGPL 2.1, please see LICENSE for details\n//* https://www.gnu.org/licenses/lgpl-2.1.html\n\n#include \"CrystalPlasticityKalidindiUpdate.h\"\n#include \"libmesh/int_range.h\"\n\nregisterMooseObject(\"SolidMechanicsApp\", CrystalPlasticityKalidindiUpdate);\n\nInputParameters\nCrystalPlasticityKalidindiUpdate::validParams()\n{\n  InputParameters params = CrystalPlasticityStressUpdateBase::validParams();\n  params.addClassDescription(\"Kalidindi version of homogeneous crystal plasticity.\");\n  params.addParam<Real>(\"r\", 1.0, \"Latent hardening coefficient\");\n  params.addParam<Real>(\"h\", 541.5, \"hardening constants\");\n  params.addParam<Real>(\"t_sat\", 109.8, \"saturated slip system strength\");\n  params.addParam<Real>(\"gss_a\", 2.5, \"coefficient for hardening\");\n  params.addParam<Real>(\"ao\", 0.001, \"slip rate coefficient\");\n  params.addParam<Real>(\"xm\", 0.1, \"exponent for slip rate\");\n  params.addParam<Real>(\"gss_initial\", 60.8, \"initial lattice friction strength of the material\");\n\n  params.addParam<MaterialPropertyName>(\n      \"total_twin_volume_fraction\",\n      \"Total twin volume fraction, if twinning is considered in the simulation\");\n\n  return params;\n}\n\nCrystalPlasticityKalidindiUpdate::CrystalPlasticityKalidindiUpdate(\n    const InputParameters & parameters)\n  : CrystalPlasticityStressUpdateBase(parameters),\n    // Constitutive values\n    _r(getParam<Real>(\"r\")),\n    _h(getParam<Real>(\"h\")),\n    _tau_sat(getParam<Real>(\"t_sat\")),\n    _gss_a(getParam<Real>(\"gss_a\")),\n    _ao(getParam<Real>(\"ao\")),\n    _xm(getParam<Real>(\"xm\")),\n    _gss_initial(getParam<Real>(\"gss_initial\")),\n\n    // resize vectors used in the consititutive slip hardening\n    _hb(_number_slip_systems, 0.0),\n    _slip_resistance_increment(_number_slip_systems, 0.0),\n\n    // resize local caching vectors used for substepping\n    _previous_substep_slip_resistance(_number_slip_systems, 0.0),\n    _slip_resistance_before_update(_number_slip_systems, 0.0),\n\n    // Twinning contributions, if used\n    _include_twinning_in_Lp(parameters.isParamValid(\"total_twin_volume_fraction\")),\n    _twin_volume_fraction_total(_include_twinning_in_Lp\n                                    ? &getMaterialPropertyOld<Real>(\"total_twin_volume_fraction\")\n                                    : nullptr)\n{\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::initQpStatefulProperties()\n{\n  CrystalPlasticityStressUpdateBase::initQpStatefulProperties();\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    _slip_resistance[_qp][i] = _gss_initial;\n    _slip_increment[_qp][i] = 0.0;\n  }\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::setInitialConstitutiveVariableValues()\n{\n  // Would also set old dislocation densities here if included in this model\n  _slip_resistance[_qp] = _slip_resistance_old[_qp];\n  _previous_substep_slip_resistance = _slip_resistance_old[_qp];\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::setSubstepConstitutiveVariableValues()\n{\n  // Would also set substepped dislocation densities here if included in this model\n  _slip_resistance[_qp] = _previous_substep_slip_resistance;\n}\n\nbool\nCrystalPlasticityKalidindiUpdate::calculateSlipRate()\n{\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    _slip_increment[_qp][i] =\n        _ao * std::pow(std::abs(_tau[_qp][i] / _slip_resistance[_qp][i]), 1.0 / _xm);\n    if (_tau[_qp][i] < 0.0)\n      _slip_increment[_qp][i] *= -1.0;\n\n    if (std::abs(_slip_increment[_qp][i]) * _substep_dt > _slip_incr_tol)\n    {\n      if (_print_convergence_message)\n        mooseWarning(\"Maximum allowable slip increment exceeded \",\n                     std::abs(_slip_increment[_qp][i]) * _substep_dt);\n\n      return false;\n    }\n  }\n  return true;\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::calculateEquivalentSlipIncrement(\n    RankTwoTensor & equivalent_slip_increment)\n{\n  if (_include_twinning_in_Lp)\n  {\n    for (const auto i : make_range(_number_slip_systems))\n      equivalent_slip_increment += (1.0 - (*_twin_volume_fraction_total)[_qp]) *\n                                   _flow_direction[_qp][i] * _slip_increment[_qp][i] * _substep_dt;\n  }\n  else // if no twinning volume fraction material property supplied, use base class\n    CrystalPlasticityStressUpdateBase::calculateEquivalentSlipIncrement(equivalent_slip_increment);\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::calculateConstitutiveSlipDerivative(\n    std::vector<Real> & dslip_dtau)\n{\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    if (MooseUtils::absoluteFuzzyEqual(_tau[_qp][i], 0.0))\n      dslip_dtau[i] = 0.0;\n    else\n      dslip_dtau[i] = _ao / _xm *\n                      std::pow(std::abs(_tau[_qp][i] / _slip_resistance[_qp][i]), 1.0 / _xm - 1.0) /\n                      _slip_resistance[_qp][i];\n  }\n}\n\nbool\nCrystalPlasticityKalidindiUpdate::areConstitutiveStateVariablesConverged()\n{\n  return isConstitutiveStateVariableConverged(_slip_resistance[_qp],\n                                              _slip_resistance_before_update,\n                                              _previous_substep_slip_resistance,\n                                              _resistance_tol);\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::updateSubstepConstitutiveVariableValues()\n{\n  // Would also set substepped dislocation densities here if included in this model\n  _previous_substep_slip_resistance = _slip_resistance[_qp];\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::cacheStateVariablesBeforeUpdate()\n{\n  _slip_resistance_before_update = _slip_resistance[_qp];\n}\n\nvoid\nCrystalPlasticityKalidindiUpdate::calculateStateVariableEvolutionRateComponent()\n{\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    // Clear out increment from the previous iteration\n    _slip_resistance_increment[i] = 0.0;\n\n    _hb[i] = _h * std::pow(std::abs(1.0 - _slip_resistance[_qp][i] / _tau_sat), _gss_a);\n    const Real hsign = 1.0 - _slip_resistance[_qp][i] / _tau_sat;\n    if (hsign < 0.0)\n      _hb[i] *= -1.0;\n  }\n\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    for (const auto j : make_range(_number_slip_systems))\n    {\n      unsigned int iplane, jplane;\n      iplane = i / 3;\n      jplane = j / 3;\n\n      if (iplane == jplane) // self vs. latent hardening\n        _slip_resistance_increment[i] +=\n            std::abs(_slip_increment[_qp][j]) * _hb[j]; // q_{ab} = 1.0 for self hardening\n      else\n        _slip_resistance_increment[i] +=\n            std::abs(_slip_increment[_qp][j]) * _r * _hb[j]; // latent hardenign\n    }\n  }\n}\n\nbool\nCrystalPlasticityKalidindiUpdate::updateStateVariables()\n{\n  // Now perform the check to see if the slip system should be updated\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    _slip_resistance_increment[i] *= _substep_dt;\n    if (_previous_substep_slip_resistance[i] < _zero_tol && _slip_resistance_increment[i] < 0.0)\n      _slip_resistance[_qp][i] = _previous_substep_slip_resistance[i];\n    else\n      _slip_resistance[_qp][i] =\n          _previous_substep_slip_resistance[i] + _slip_resistance_increment[i];\n\n    if (_slip_resistance[_qp][i] < 0.0)\n      return false;\n  }\n  return true;\n}\n\n@dschwen @sapitts Can you help me locate the code/ source for the different crystal structures(FCC, BCC, HCP) used in the model ?above.",
          "url": "https://github.com/idaholab/moose/discussions/29784",
          "updatedAt": "2025-02-07T19:23:42Z",
          "publishedAt": "2025-01-31T22:33:19Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "yes, of course. That's set by a parameter in the base class, see CrystalPlasticityStressUpdateBase.C#L34 Search through the code in that class to see how and where the lattice type is used.\nPlease note too that the Kalidindi model is hard coded for an FCC structure, as described in the documentation, Eq 3: https://mooseframework.inl.gov/source/materials/crystal_plasticity/CrystalPlasticityKalidindiUpdate.html",
                  "url": "https://github.com/idaholab/moose/discussions/29784#discussioncomment-12022849",
                  "updatedAt": "2025-01-31T22:53:45Z",
                  "publishedAt": "2025-01-31T22:53:44Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "@sapitts I tried to add a new crystal structure(specifically the DO22 structure, which is a tetragonal structure). It compiles successfully, but I just wanted to share with you if there is room for improvement or if there is something that I am missing.\nBelow are relevant snippets of the code:\nIn the CrystalPlasticityStressUpdateBase.C\nvoid\nCrystalPlasticityStressUpdateBase_abs::getSlipSystems()\n{\n  bool orthonormal_error = false;\n\n  // read in the slip system data from auxiliary text file\n  MooseUtils::DelimitedFileReader _reader(_slip_sys_file_name);\n  _reader.setFormatFlag(MooseUtils::DelimitedFileReader::FormatFlag::ROWS);\n  _reader.read();\n\n  // check the size of the input\n  if (_reader.getData().size() != _number_slip_systems)\n    paramError(\n        \"number_slip_systems\",\n        \"The number of rows in the slip system file should match the number of slip system.\");\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    // initialize to zero\n    _slip_direction[i].zero();\n    _slip_plane_normal[i].zero();\n  }\n  if (_crystal_lattice_type == CrystalLatticeType::DO22)\n    transformDO22SlipSystems(_reader);\n  else if (_crystal_lattice_type == CrystalLatticeType::HCP)\n    transformHexagonalMillerBravaisSlipSystems(_reader);\n  else if (_crystal_lattice_type == CrystalLatticeType::BCC ||\n           _crystal_lattice_type == CrystalLatticeType::FCC)\n  {\n    for (const auto i : make_range(_number_slip_systems))\n    {\n      // directly grab the raw data and scale it by the unit cell dimension\n      for (const auto j : index_range(_reader.getData(i)))\n      {\n        if (j < LIBMESH_DIM)\n          _slip_plane_normal[i](j) = _reader.getData(i)[j] / _unit_cell_dimension[j];\n        else\n          _slip_direction[i](j - LIBMESH_DIM) =\n              _reader.getData(i)[j] * _unit_cell_dimension[j - LIBMESH_DIM];\n      }\n    }\n  }\n  for (const auto i : make_range(_number_slip_systems))\n  {\n    // normalize\n    _slip_plane_normal[i] /= _slip_plane_normal[i].norm();\n    _slip_direction[i] /= _slip_direction[i].norm();\n\n    if (_crystal_lattice_type != CrystalLatticeType::HCP)\n    {\n      const auto magnitude = _slip_plane_normal[i] * _slip_direction[i];\n      if (std::abs(magnitude) > libMesh::TOLERANCE)\n      {\n        orthonormal_error = true;\n        break;\n      }\n    }\n  }\n  if (orthonormal_error)\n    mooseError(\"CrystalPlasticityStressUpdateBase_abs Error: The slip system file contains a slip \"\n               \"direction and plane normal pair that are not orthonormal in the Cartesian \"\n               \"coordinate system.\");\n}\n\nvoid CrystalPlasticityStressUpdateBase_abs::transformDO22SlipSystems(\n    const MooseUtils::DelimitedFileReader & reader)\n{\n    // Example logic for transforming DO22 slip systems \n    const unsigned int expected_columns = 6; \n    RealVectorValue temporary_slip_direction, temporary_slip_plane;\n\n    for (const auto i : make_range(_number_slip_systems))\n    {\n        // Read the slip plane and direction data from the file\n        for (const auto j : index_range(reader.getData(i)))\n        {\n            if (j < 3)\n                temporary_slip_plane(j) = reader.getData(i)[j];\n            else\n                temporary_slip_direction(j - 3) = reader.getData(i)[j];\n        }\n        // Normalize the slip direction and slip plane normal\n\n        _slip_plane_normal[i] = temporary_slip_plane / temporary_slip_plane.norm();\n        _slip_direction[i] = temporary_slip_direction / temporary_slip_direction.norm();\n    }\n\n}",
                          "url": "https://github.com/idaholab/moose/discussions/29784#discussioncomment-12088582",
                          "updatedAt": "2025-02-07T01:33:14Z",
                          "publishedAt": "2025-02-07T01:33:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "how often are getSlipSystems() and transformDO22SlipSystems() called? once at initialization right?",
                          "url": "https://github.com/idaholab/moose/discussions/29784#discussioncomment-12089334",
                          "updatedAt": "2025-02-07T03:28:38Z",
                          "publishedAt": "2025-02-07T03:28:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Emmanuel-324"
                          },
                          "bodyText": "@GiudGiud Yes.\nAlso, @sapitts @dschwen  do you have any suggestions about how to get different slip system strengths for certain slip systems? For example, out of the 12 slip systems for FCC, I specify every 4 with different slip system strengths in the input script.\nSo basically each of the 4 groupings has a different slip system in the same input script.",
                          "url": "https://github.com/idaholab/moose/discussions/29784#discussioncomment-12098088",
                          "updatedAt": "2025-02-07T19:23:42Z",
                          "publishedAt": "2025-02-07T19:23:41Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}