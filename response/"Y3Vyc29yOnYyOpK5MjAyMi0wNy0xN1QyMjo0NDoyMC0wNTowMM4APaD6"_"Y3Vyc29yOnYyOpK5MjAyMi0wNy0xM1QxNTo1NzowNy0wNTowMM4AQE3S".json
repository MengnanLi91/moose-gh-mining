{
  "discussions": {
    "pageInfo": {
      "hasNextPage": true,
      "endCursor": "Y3Vyc29yOnYyOpK5MjAyMi0wNy0xM1QxNTo1NzowNy0wNTowMM4AQE3S"
    },
    "edges": [
      {
        "node": {
          "title": "How to add the value of variable in other nodes into the kernel in the current node",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "Suppose that there are two one-dimensional curves which is divided into n elements. One is block1 and the other is block2.\nI want to add this equation into block1 and block2's kernel.\n\nw is the main variable in this equation, U(coupled variable) is the average velocity of block1 and block2, In block1, pn(coupled variable) is the pressure of block2, and in block2, pn is the pressure of block1.\nI dont know whether this can be done within moose, can anyone tell me?\nBest regards,\nEthan",
          "url": "https://github.com/idaholab/moose/discussions/21584",
          "updatedAt": "2022-07-21T07:38:26Z",
          "publishedAt": "2022-07-14T03:39:44Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nAre the elements where this coupling exists adjacent?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21584#discussioncomment-3142879",
                  "updatedAt": "2022-07-14T03:56:48Z",
                  "publishedAt": "2022-07-14T03:56:47Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "like the two 1D lines, how are they positioned?",
                          "url": "https://github.com/idaholab/moose/discussions/21584#discussioncomment-3142904",
                          "updatedAt": "2022-07-14T04:03:55Z",
                          "publishedAt": "2022-07-14T04:03:54Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "The lines are parallel and the length the number of elements are all the same. And the equation need to be solved involves two lines' parameters(in detail: line1's first element and line2's first element). In geometry, these two elements are not adjacant. The main variable(w) in this equation is like a average value in form, but it need to be obtained by solving PDE. I'm not sure if I should add this equation into some line's kernel to solve this PDE, or maybe there's any other way?",
                          "url": "https://github.com/idaholab/moose/discussions/21584#discussioncomment-3144259",
                          "updatedAt": "2022-07-14T07:46:33Z",
                          "publishedAt": "2022-07-14T07:46:33Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "We dont have \"line\" kernels, we have elemental and nodal kernels.\nIf you have sums over multiple elements that are not adjacent, it will be a little tricky to get the contributions to the Jacobian right for Newton's method. You can compute the sums using the postprocessor system, which will get you the contribution to the residual.\nwith this one for example\nhttps://mooseframework.inl.gov/source/postprocessors/ElementIntegralVariablePostprocessor.html\nCan the two lines just the same line or is there any reason they must be separate?\nIf they are the same lines with all the variables living on that same 1D mesh, it's much easier to write each variable into the other variable's equation.",
                          "url": "https://github.com/idaholab/moose/discussions/21584#discussioncomment-3149361",
                          "updatedAt": "2022-07-14T18:05:57Z",
                          "publishedAt": "2022-07-14T18:05:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Thank you for your relpy!\nThe two lines have the same variables(p, v and T) and in geometry and mesh they are same too. But the value of the variables should be different. I'm not sure if this could be called \"they are the same lines with all the variables living on that same 1D mesh\".\nSo if the two lines are the same how can I write each variable into the other variable's equation?",
                          "url": "https://github.com/idaholab/moose/discussions/21584#discussioncomment-3154633",
                          "updatedAt": "2022-07-15T08:59:14Z",
                          "publishedAt": "2022-07-15T08:59:12Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You may use the Coupleable interface to write the local variable value of each variable into the equation.\nhttps://mooseframework.inl.gov/moose/source/interfaces/Coupleable.html\nFor non local values it's more complicated. I would do a first try with an integral postprocessor. Then if that doesnt work we can explore constraints, mortar and other non-local methods",
                          "url": "https://github.com/idaholab/moose/discussions/21584#discussioncomment-3157456",
                          "updatedAt": "2022-07-15T14:50:41Z",
                          "publishedAt": "2022-07-15T14:50:40Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "OK I will have a try. Thanks for your patient solution!",
                          "url": "https://github.com/idaholab/moose/discussions/21584#discussioncomment-3167800",
                          "updatedAt": "2022-07-18T01:37:11Z",
                          "publishedAt": "2022-07-18T01:37:11Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "FEM thermal radiation",
          "author": {
            "login": "Gallasd"
          },
          "bodyText": "Hi, I want to use moose as my solver for structural optimization. The optimization problem is first to determine the governing equations.\nI study heat conduction under radiation boundaries.\nThe governing equation is the heat conduction equation, and the boundary condition is the radiation boundary, that is, the fourth power of temperature, similar to this:\n\nIf it is a convection boundary, the weighted margin method is directly used, and the integration is sufficient. For the radiation boundary, this highly nonlinear problem is very difficult to deal with by the finite element method.\nMany literatures simplify the radiation boundary to a certain extent, such as linear approximation of radiation heat transfer and equivalent heat transfer. But there must be a general simplification, because software cannot simplify equations for every simplified physical problem.\nSo I would like to ask you how moose performs finite element processing of radiation boundaries.",
          "url": "https://github.com/idaholab/moose/discussions/21595",
          "updatedAt": "2022-08-13T16:16:58Z",
          "publishedAt": "2022-07-15T14:14:31Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nMOOSE has a non-linear solver so we typically can solve these boundary conditions exactly. We have various objects for dealing with radiative heat transfer:\nhttps://mooseframework.inl.gov/source/actions/ThermalContactAction.html\nis for radiation / conduction and convection at interfaces, which may be disjoint.\nhttps://mooseframework.inl.gov/syntax/GrayDiffuseRadiation/index.html\nis for \"exact\" treatment of radiation using ray tracing. This is more expensive to set up.\nhttps://mooseframework.inl.gov/source/bcs/ADFunctionRadiativeBC.html\nhttps://mooseframework.inl.gov/source/bcs/ADInfiniteCylinderRadiativeBC.html\nare meant to have radiation boundary conditions at the outer boundary of the mesh (or of the temperature variable in the mesh)\nThey effectively implement different approximation (radiative surface shape of a plane in front or a cylinder in front respectively)\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21595#discussioncomment-3157539",
                  "updatedAt": "2022-07-15T15:01:04Z",
                  "publishedAt": "2022-07-15T15:00:59Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Gallasd"
                          },
                          "bodyText": "Hello, maybe you didn't understand my question, I hope you can read it patiently.\nQ1:I'm not sure how you deal with the radiation boundary conditions above on finite elements, such as ADFunctionRadiation. Here is a document I found that puts the effect of radiation boundaries into the stiffness matrix, simplifying this highly nonlinear question.\n\nTheoretically, the role of the radiation boundary should be in the load matrix.\nSo I would like to confirm with you how moose calculates the ADFunctionRadiation, which is a problem of the fourth power of heat flux, and whether it adopts the method used in the above literature.\nQ2: I have another question. In the calculation example provided by ADFunctionRadiation, there is such a passage:\n# If we assume that epsilon*sigma*(T_inf^4-T_s^4) is approximately equal to\n# epsilon*sigma*4*T_inf^3*(T_inf-T_s), that form is equivalent to\n# h*(T_inf-T_s), the convective flux bc. So, the radiative and convective\n# flux bcs should give nearly the same answer if the leading terms are equal.\n\nI don't understand why this can be so simplified, why T_inf can be brought up, and why there is an extra 4. In addition, is the radiation problem so simplified in moose?",
                          "url": "https://github.com/idaholab/moose/discussions/21595#discussioncomment-3160439",
                          "updatedAt": "2022-07-16T20:54:59Z",
                          "publishedAt": "2022-07-16T02:55:53Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Q1: no we dont do this approach. We form the residual with the current solution values for all variables, then either do Newton or PJFNK. Forming this load and stiffness matrix is for a custom numerical scheme\nQ2: Factorize (T_inf^4-T_s^4) by (T_inf-T_s) and look at the resulting polynomial. You can approximate T_s by T_inf in the rest of the factorization and get what the text says\nThe radiation problem is not so simplified in MOOSE, this is just a sanity check.\nYou may look at the code at your convenience to convince yourself",
                          "url": "https://github.com/idaholab/moose/discussions/21595#discussioncomment-3163397",
                          "updatedAt": "2022-07-16T21:00:44Z",
                          "publishedAt": "2022-07-16T21:00:44Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Gallasd"
                  },
                  "bodyText": "Hi, thanks for your reply.\nI learned about the radiation part of ANSYS and moose, and basically understood the principle of radiation calculation. It is found that the radiation problem for a surface, that is, the temperature without surface radiation exchange, should also be solved by the theory of Gray Diffuse Radiative Exchange.\nThis is my geometry, obviously, there is no heat radiation between the surfaces:\n\nAfter carefully studying the radiation theory in moose, I think that in moose,The radiation boundary condition becomes a constant heat flow boundary condition,here J is a constant in this equation\uff1a\n\nFor J  in the formula, calculate by the following formula:\n\nHere, through the Newton or PJFNK you mentioned, to solve the nonlinear equation system of  Equation 2.Constantly exchange information with the thermal conductivity control equation, perform iterations, and finally determine the converged J and T.\nSo Newton or PJFNK solve for the variables on the radiation boundary, not the overall variables\uff1f\nthank you for your reply\uff01",
                  "url": "https://github.com/idaholab/moose/discussions/21595#discussioncomment-3165648",
                  "updatedAt": "2022-07-17T14:01:57Z",
                  "publishedAt": "2022-07-17T14:01:56Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "It's not a local solve on the boundary, it's for all variables at the same time. The boundary temperature is converged at the same time, there is no separate treatment afaik\nThe equations for each implementation of the radiation BC are in their respective documentation. It's indeed a heat flux, but it's not constant. Most of them vary as T^4 - T_inf^4",
                          "url": "https://github.com/idaholab/moose/discussions/21595#discussioncomment-3166209",
                          "updatedAt": "2022-07-17T16:41:49Z",
                          "publishedAt": "2022-07-17T16:41:48Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to add gravity to airflow FEM simulation",
          "author": {
            "login": "brandon-barclay"
          },
          "bodyText": "Hello, I am attempting to use MOOSE to simulate radionuclide deposition with FEM, however, I am struggling to add a kernel to represent gravitational settling of the particle through the domain before it reaches the boundary. I have tried to index the gradients for the Z gradient component however the residual contribution seems to be 0. It appears that using vector variables / kernels would make this a simpler task however all of my kernels are for non vector variables so I am hoping there is a possible workaround.\nThanks for reading and for your assistance.",
          "url": "https://github.com/idaholab/moose/discussions/21495",
          "updatedAt": "2022-08-13T16:17:21Z",
          "publishedAt": "2022-07-04T18:27:16Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWhat does the equation look like for this problem? And which term is the gravitational settling?\nVector variables/kernels are never required, they're only done for simplicity or efficiency\nHappy 4th,\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21495#discussioncomment-3080783",
                  "updatedAt": "2022-07-04T23:56:56Z",
                  "publishedAt": "2022-07-04T23:56:56Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "brandon-barclay"
                          },
                          "bodyText": "I have attached the weak form of the equation I am attempting to model, with the deposition term highlighted.\nThank you for your interest in helping me solve this problem.",
                          "url": "https://github.com/idaholab/moose/discussions/21495#discussioncomment-3086668",
                          "updatedAt": "2022-07-05T17:00:19Z",
                          "publishedAt": "2022-07-05T17:00:18Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "so what do you have for computeQpResidual currently?\nI would see something like:\n-_nu_s[_qp] * _test[_i][_qp] * _grad_C[2][_qp]\n\nnu_s being a material property and _grad_C being obtained using the coupledGradient method",
                          "url": "https://github.com/idaholab/moose/discussions/21495#discussioncomment-3088308",
                          "updatedAt": "2022-07-05T23:17:25Z",
                          "publishedAt": "2022-07-05T23:17:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "brandon-barclay"
                          },
                          "bodyText": "This is almost exactly what I had tried to use, however, I get an error stating\nerror: type 'const libMesh::VectorValue<MetaPhysicL::DualNumber<double, MetaPhysicL::SemiDynamicSparseNumberArray<double, unsigned long long, MetaPhysicL::NWrapper<53>>, true>>' does not provide a subscript operator\n  return _settling_velocity[_qp] * _test[_i][_qp] * _grad_u[2][_qp];",
                          "url": "https://github.com/idaholab/moose/discussions/21495#discussioncomment-3102414",
                          "updatedAt": "2022-07-07T20:11:30Z",
                          "publishedAt": "2022-07-07T18:25:04Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ok so probably the [2] is wrong. maybe it's (2) or maybe it s at a different position",
                          "url": "https://github.com/idaholab/moose/discussions/21495#discussioncomment-3103056",
                          "updatedAt": "2022-07-07T20:25:50Z",
                          "publishedAt": "2022-07-07T20:25:49Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "brandon-barclay"
                          },
                          "bodyText": "I was able to get it to work with _grad_u[_qp](2) - thanks for your help!",
                          "url": "https://github.com/idaholab/moose/discussions/21495#discussioncomment-3103064",
                          "updatedAt": "2022-07-07T20:27:46Z",
                          "publishedAt": "2022-07-07T20:27:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "ah weird. I ll try to remember. I m used to grad_phi[_j][_qp] and grad_test[_i][_qp], didnt know it was flipped for the variables",
                          "url": "https://github.com/idaholab/moose/discussions/21495#discussioncomment-3103075",
                          "updatedAt": "2022-07-07T20:30:08Z",
                          "publishedAt": "2022-07-07T20:30:08Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "lindsayad"
                          },
                          "bodyText": "grad_phi and grad_test are two dimensional arrays of 3-vectors (gradients) indexed by shape function, quadrature point, and finally spatial dimension. grad_u is a one-dimensional array of 3-vectors (gradients) without the shape function index, so indexed first by quadrature point and then by spatial dimension",
                          "url": "https://github.com/idaholab/moose/discussions/21495#discussioncomment-3163622",
                          "updatedAt": "2022-07-16T23:35:07Z",
                          "publishedAt": "2022-07-16T23:34:40Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "A question about self define kernel",
          "author": {
            "login": "wangzhaohao"
          },
          "bodyText": "Hi, everyone! I want to define a PDE which form is\n$\\bigtriangledown \\bigtriangledown C +\\bigtriangledown (\\frac{640C}{T^{2}}\\bigtriangledown T) =0$\nand the bcs is\n$\\bigtriangledown C = 0   (x =0)$\n$C =1.6 (x=1)$\nI define three kernels ConcentrationConvectionSource ConcentrationConvectionTemp ConcentrationDiffusionTemp\nand a .i file\nconcentration_back.i\nthey are all follow.\nhttps://github.com/wangzhaohao/termite2/tree/main/termite2\n\n\nbut the result is different with Finite Difference, I meet this problem so long,but i can't find the wrong, so who can give me some advice, Thanks for your help!\nhao",
          "url": "https://github.com/idaholab/moose/discussions/21587",
          "updatedAt": "2022-08-13T16:18:00Z",
          "publishedAt": "2022-07-14T13:20:22Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nI took a quick look. In concentration.i you set DirichletBC instead of a NeumannBC on the left boundary\n  [left]\n    type = DirichletBC\n    variable = concentration\n    boundary = left\n    value = 0\n  []\n\nthis isnt the result shown in your post either.\nInstead of sharing a zip of your folder, please create a github repo, share the link here and tell us which inputs should reproduce the problem here.\nAlso is temperature just fixed?\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3149115",
                  "updatedAt": "2022-07-14T17:29:48Z",
                  "publishedAt": "2022-07-14T17:29:48Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "the.i file is concentration_back.i, not the concontration.i",
                          "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3150881",
                          "updatedAt": "2022-07-14T23:33:51Z",
                          "publishedAt": "2022-07-14T23:33:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "that input has kernels for an auxvariable (temp), which shouldnt even be allowed, and doesnt converge well.",
                          "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3151031",
                          "updatedAt": "2022-07-15T00:06:59Z",
                          "publishedAt": "2022-07-15T00:06:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "https://github.com/wangzhaohao/termite2/tree/main/termite2\nthis is my code on github. the auxkernel is used for i just want to give a\nT = -1500xx+2000\nI follow the Thermal Expansion, which give temp (also a auxvariable) by auxkernel.",
                          "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3151074",
                          "updatedAt": "2022-07-15T00:19:50Z",
                          "publishedAt": "2022-07-15T00:19:45Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "WilkAndy"
                  },
                  "bodyText": "Have you got one equation and two unknowns (C and T)?",
                  "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3150242",
                  "updatedAt": "2022-07-14T20:46:10Z",
                  "publishedAt": "2022-07-14T20:46:06Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "the variable T is give as auxvariable.",
                          "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3150878",
                          "updatedAt": "2022-07-14T23:32:35Z",
                          "publishedAt": "2022-07-14T23:32:32Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "YaqiWang"
                  },
                  "bodyText": "Is the PJFNK solve converged? What makes you think you FD solution is accurate? How big is the difference between FD and your FEM solution?",
                  "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3152394",
                  "updatedAt": "2022-07-15T05:19:37Z",
                  "publishedAt": "2022-07-15T05:19:37Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "there is no warning. and i think the FD solution is accurate is that when i set the bcs\nx = 0, C = 0\nx = 1, C = 1.6\n\n\n\nthere have analytical solution. the FD solution satisfy, but the FEM is not.  so i guess there is something wrong about myself define kernels.",
                          "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3156625",
                          "updatedAt": "2022-07-15T13:09:15Z",
                          "publishedAt": "2022-07-15T13:09:14Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "YaqiWang"
                          },
                          "bodyText": "This does not make sense. If your temperature is constant, its gradient is zero and all the three kernels coupling the temperature have zero contributions to the residual, so only the diffusion kernel and two Dirichlet bcs left, you should get a linear solution from 0 to 1.6.",
                          "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3159281",
                          "updatedAt": "2022-07-15T20:01:24Z",
                          "publishedAt": "2022-07-15T20:01:24Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Temperature is constant in time, it has a spatial profile",
                          "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3159898",
                          "updatedAt": "2022-07-15T22:31:46Z",
                          "publishedAt": "2022-07-15T22:31:46Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "wangzhaohao"
                          },
                          "bodyText": "so i think there is somthing which i don't  notice in my self define kernel",
                          "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3161246",
                          "updatedAt": "2022-07-16T08:42:55Z",
                          "publishedAt": "2022-07-16T08:42:55Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "to debug you will want to take it step by step.\nThe problem is easy enough that you can replace each kernel one by one to make sure they are correct. When you reproduce the analytical solution for a simplified problem, you can consider the objects currently in use are correct, and investigate the others.\nAnother option is to replace your kernels with framework ones, which are already correct.\nFor example you may use ADMatDiffusion\nhttps://mooseframework.inl.gov/source/kernels/ADMatDiffusion.html\nwith a ParsedMaterialProperty (use the AD version) for your diffusion term\nhttps://mooseframework.inl.gov/source/materials/ParsedMaterial.html\nIn any case you will want to remove the kernels acting on an auxiliary variable",
                          "url": "https://github.com/idaholab/moose/discussions/21587#discussioncomment-3163369",
                          "updatedAt": "2022-07-16T20:46:16Z",
                          "publishedAt": "2022-07-16T20:46:15Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Output of shear stress in CrystalPlasticitySlipRateGS",
          "author": {
            "login": "Aayush-T"
          },
          "bodyText": "Hello everyone,\nI am working on FiniteStrainUOBasedCP and CrystalPlasticitySlipRateGSS. I wanted the shear stress variable \"tau\" in CrystalPlasticitySlipRateGSS as output for all slip systems, so I tried to make tau from local to global variable, but it gives this error.\nTHE PROBLEM VARIABLE AND FUNCTION IS IN BOLD\nOnly showing the added portion in \"CrystalPlasticitySlipRateGSS\" file for better clarity and easy understanding.\nLike this:\n.h file\n#pragma once\n\n#include \"CrystalPlasticitySlipRate.h\"\n#include \"RankTwoTensor.h\"\n\n/**\n * Phenomenological constitutive model slip rate userobject class.\n */\nclass CrystalPlasticitySlipRateGSS : public CrystalPlasticitySlipRate\n{\n\nprotected:\n\n  **DenseVector<Real> _shear_stress;**\n};\n\nand, in C file as\n\n#include \"CrystalPlasticitySlipRateGSS.h\"\n\n#include <fstream>\n\nregisterMooseObject(\"TensorMechanicsApp\", CrystalPlasticitySlipRateGSS);\n\nInputParameters\nCrystalPlasticitySlipRateGSS::validParams()\n{\n.........\n}\n\nCrystalPlasticitySlipRateGSS::CrystalPlasticitySlipRateGSS(const InputParameters & parameters)\n  : CrystalPlasticitySlipRate(parameters),\n    .........,\n    **_shear_stress(_variable_size)**\n{\n  if (_slip_sys_flow_prop_file_name.length() != 0)\n    readFileFlowRateParams();\n  else\n    getFlowRateParams();\n}\n\nbool\nCrystalPlasticitySlipRateGSS::calcSlipRate(unsigned int qp, Real dt, std::vector<Real> & val) const\n{\n  DenseVector<Real> tau(_variable_size);\n\n  for (unsigned int i = 0; i < _variable_size; ++i)\n    tau(i) = _pk2[qp].doubleContraction(_flow_direction[qp][i]);\n\n  \n   **for (unsigned int i = 0; i < _variable_size; ++i)**\n     **_shear_stress(i) = _pk2[qp].doubleContraction(_flow_direction[qp][i]);**\n\n\n  for (unsigned int i = 0; i < _variable_size; ++i)\n  {\n    val[i] = _a0(i) * std::pow(std::abs(tau(i) / _mat_prop_state_var[qp][i]), 1.0 / _xm(i)) *\n             std::copysign(1.0, tau(i));\n    if (std::abs(val[i] * dt) > _slip_incr_tol)\n    {\n#ifdef DEBUG\n      mooseWarning(\"Maximum allowable slip increment exceeded \", std::abs(val[i]) * dt);\n#endif\n      return false;\n    }\n  }\n\n  return true;\n}\n\nBut it gives following error.\n\nI am also adding the changes I made in the CrystalPlasticitySlipRateGSS",
          "url": "https://github.com/idaholab/moose/discussions/21507",
          "updatedAt": "2022-07-15T14:28:25Z",
          "publishedAt": "2022-07-05T18:19:52Z",
          "category": {
            "name": "Q&A Modules: Solid mechanics"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "hello\nYou made calcSlipRate a const function but you are assigning a value to one of the class member variable.\nThis is not allowed, as declaring a function const means it may not modify any of the class attributes.\nYou need to remove the const function attribute\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21507#discussioncomment-3088375",
                  "updatedAt": "2022-07-05T23:39:47Z",
                  "publishedAt": "2022-07-05T23:39:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Aayush-T"
                          },
                          "bodyText": "Hi, thanks for quick response. In this case, this is how this function should be defined(as the file is from MOOSEFRAMEWORK), otherwise it will lead to constitutive failure error in the file. I tried that.\nI also tried a few more things such as trying to define a new function in the C file, but now is the problem of how to call that new function in the file. Moreover, I have doubts about how to get the output of a DenseVector in the csv when it is not defined as a material property.\n#include \"CrystalPlasticitySlipRateGSS.h\"\n\n#include <fstream>\n\nregisterMooseObject(\"TensorMechanicsApp\", CrystalPlasticitySlipRateGSS);\n\nInputParameters\nCrystalPlasticitySlipRateGSS::validParams()\n{\n.......\n}\n\nCrystalPlasticitySlipRateGSS::CrystalPlasticitySlipRateGSS(const InputParameters & parameters)\n  : CrystalPlasticitySlipRate(parameters),\n    ...................,\n    _shear_stress(_variable_size)\n{\n  if (_slip_sys_flow_prop_file_name.length() != 0)\n    readFileFlowRateParams();\n  else\n    getFlowRateParams();\n}\n\n **void\n CrystalPlasticitySlipRateGSS::CalcTau(unsigned int qp)\n{\n  for (unsigned int i = 0; i < _variable_size; ++i)\n    _shear_stress(i) = _pk2[qp].doubleContraction(_flow_direction[qp][i]);\n    printf(\"%f\\n\", _shear_stress(0));\n}**\n\nbool\nCrystalPlasticitySlipRateGSS::calcSlipRate(unsigned int qp, Real dt, std::vector<Real> & val) const\n{\n  DenseVector<Real> tau(_variable_size);\n\n  for (unsigned int i = 0; i < _variable_size; ++i)\n    tau(i) = _pk2[qp].doubleContraction(_flow_direction[qp][i]);\n\n  for (unsigned int i = 0; i < _variable_size; ++i)\n  {\n    val[i] = _a0(i) * std::pow(std::abs(tau(i) / _mat_prop_state_var[qp][i]), 1.0 / _xm(i)) *\n             std::copysign(1.0, tau(i));\n    if (std::abs(val[i] * dt) > _slip_incr_tol)\n    {\n#ifdef DEBUG\n      mooseWarning(\"Maximum allowable slip increment exceeded \", std::abs(val[i]) * dt);\n#endif\n      return false;\n    }\n  }\n\n  return true;\n}",
                          "url": "https://github.com/idaholab/moose/discussions/21507#discussioncomment-3090665",
                          "updatedAt": "2022-07-15T14:24:37Z",
                          "publishedAt": "2022-07-06T08:40:11Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "You ll need to mark_shear_stress as mutable if you want to modify it in a const function",
                          "url": "https://github.com/idaholab/moose/discussions/21507#discussioncomment-3094915",
                          "updatedAt": "2022-07-06T19:39:26Z",
                          "publishedAt": "2022-07-06T19:39:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "sapitts"
                  },
                  "bodyText": "Hi @Aayush-T,\nHave you considered using the material-based \"Update\" crystal plasticity classes (documentation page here: https://mooseframework.inl.gov/source/materials/crystal_plasticity/ComputeMultipleCrystalPlasticityStress.html ) instead of the older user object based system? The newer material-based system offers several advantages including significant simulation speedup, more robust substepping capabilities, and, cruicial for your application, the ability to easily output material properties like the shear stress and slip system strength.\nYou can read more about the specific Kalidindi model you are using on the documentation page here: https://mooseframework.inl.gov/source/materials/crystal_plasticity/CrystalPlasticityKalidindiUpdate.html. To then output the resolved shear stress in your output file, add the following to your input file:\n[AuxVariables]\n  [resolved_shear_stress_0]\n    order = CONSTANT\n    family = MONOMIAL\n  []\n[]\n\n[AuxKernels]\n  [tau_0]\n    type = MaterialStdVectorAux\n    variable = resolved_shear_stress_0\n    property = applied_shear_stress\n    index = 0\n    execute_on = timestep_end\n  []\n[]\n\n[Postprocessors]\n  [tau_0]\n    type = ElementAverageValue\n    variable = resolved_shear_stress_0\n  []\n[]\n\nThis example shows the necessary input file additions for the 0th slip system, and the pattern is the same for the other slip systems.\nHope this helps!",
                  "url": "https://github.com/idaholab/moose/discussions/21507#discussioncomment-3122887",
                  "updatedAt": "2022-07-11T16:29:19Z",
                  "publishedAt": "2022-07-11T16:29:19Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Aayush-T"
                          },
                          "bodyText": "Hi, thanks for the response. Yes, this new method seems better than older user object based system, but since most of development done by me is on that, so I wanted to do it in the UserObjectBased Class only. This discussion gave me a better understanding on how to implement it.\nThanks a lot.",
                          "url": "https://github.com/idaholab/moose/discussions/21507#discussioncomment-3157253",
                          "updatedAt": "2022-07-15T14:28:26Z",
                          "publishedAt": "2022-07-15T14:28:25Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Aayush-T"
                  },
                  "bodyText": "Hi everyone, thanks. I did it by defining rss as material property in FiniteStrainUOBasedCP and calculating it in calcResidual function in FiniteStrainUOBasedCP itself. The output can be taken in the same way as defined above.\nIt was an easy way to do it for user object based method.\nAdding it here for further reference in case anyone needs it.\nFiniteStrainUObasedCP::calcResidual()\n{\nRankTwoTensor iden(RankTwoTensor::initIdentity), ce, ee, ce_pk2, eqv_slip_incr, pk2_new;\n\ngetSlipRates();\nif (_err_tol)\nreturn;\n\nfor (unsigned int i = 0; i < _num_uo_slip_rates; ++i)\n{\nfor (unsigned int j = 0; j < _uo_slip_rates[i]->variableSize(); ++j)\n{\neqv_slip_incr += (_flow_direction[i])[_qp][j] * (_mat_prop_slip_rates[i])[_qp][j] * _dt;\n_rss_output[_qp][j] = _pk2[_qp].doubleContraction((*_flow_direction[i])[_qp][j]);\n}\n}\n\neqv_slip_incr = iden - eqv_slip_incr;\n_fp_inv = _fp_old_inv * eqv_slip_incr;\n_fe = _dfgrd_tmp * _fp_inv;\n\nce = _fe.transpose() * _fe;\nee = ce - iden;\nee*= 0.5;\n\npk2_new = _elasticity_tensor[_qp] * ee;\n\n_resid = _pk2[_qp] - pk2_new;\n}\n\nThanks and Regards,\nAayush",
                  "url": "https://github.com/idaholab/moose/discussions/21507#discussioncomment-3157218",
                  "updatedAt": "2022-07-15T14:52:27Z",
                  "publishedAt": "2022-07-15T14:25:32Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Cyclic dependency detected in object ordering",
          "author": {
            "login": "echo1115"
          },
          "bodyText": "Hello,\nIn recent days, I updated the MOOSE version on my computer. However, when i run my previous working case, it fails now and shows \"Cyclic dependency detected in object ordering \" :\n\ni noted that it is a new function added in MOOSE  (moose/framework/src/loops/ComputeInitialConditionThread.C) . Does anyone knows why my case fails now?\nBesides, the error information reported many materials which are not dependency acturally. For example,  it shows \"fuel_eigen_strain -> SiC_hc\" ,but there is no calling relationship between them.",
          "url": "https://github.com/idaholab/moose/discussions/21524",
          "updatedAt": "2022-07-14T17:39:23Z",
          "publishedAt": "2022-07-07T07:22:52Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "hugary1995"
                  },
                  "bodyText": "If a material object A requests a material property declared in another material object B, then A depends on B. There are other ways of introducing dependency, but this is most likely your case.\nThis error signals poorly designed code. You have three options:\n\nReorganize/redesign the material objects\nSuppress the error, either by turning off the dependency check (I'm not sure if that's possible), or by reverting back to an earlier version of moose.\nIn some cases, cyclic dependency can be fixed by making some materials discrete.",
                  "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3100107",
                  "updatedAt": "2022-07-07T12:43:10Z",
                  "publishedAt": "2022-07-07T12:43:10Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@hugary1995 Thanks for your reply. I\u2018m now simulating the themo-mechanical behaviors of an object which has multilayer structures.\n\nEach structure is a separate block (block 1 to 5).  In each separate block, i defined its material objects of HeatConduction and TensorMechanics. However,  the error information shows when calculating the strain of block 1 (fuel), it calls the material property in block 3 (SiC). The error in calculating stress is similar.\nI noted in my source code when calculating the strain of block 1 (fuel_eigen_strain), it shouled get the material property \"density\" from its HeatConductionMaterial (kernel_hc).  Acturally the material property \"density\" is also declared in other blocks.\nI wonder if Moose's new function (moose/framework/src/loops/ComputeInitialConditionThread.C)  considers these \"density\" to be the same, even although the block is specified in the input file.",
                          "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3100737",
                          "updatedAt": "2022-07-07T14:46:01Z",
                          "publishedAt": "2022-07-07T14:13:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "You can debug it by adding the following snippet to your input file:\n[Debug]\n  show_material_props = true\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3101101",
                          "updatedAt": "2022-07-07T15:04:59Z",
                          "publishedAt": "2022-07-07T15:04:59Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@hugary1995 @GiudGiud Thanks for your reply. I added the [Debug], the properties of each Subdomain(block) and the error information are presented below.  I didn't find the cause the problem, maybe you can give me more advice. Thanks a lot!\nActive Materials:\n    Subdomain:  (1)\n      Material Name:       bu\n      Property Names:      \"burnup\" \"burnup_atom\" \"fission_rate\" \n      Material Name:       fgr\n      Property Names:      \"Kr_FGR\" \"Xe_FGR\" \"sum_FGP\" \"total_FGR\" \n      Material Name:       kernel_hc\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       kernel_Ev\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       fuel_eigen_strain\n      Property Names:      \"densification_strain\" \"densification_strain_scalar\" \"fuel_eign_strain\" \"swell_strain\" \n                             \"swell_strain_scalar\" \"thermal_strain\" \"thermal_strain_scalar\" \n      Material Name:       fuel_strain\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       kernel_elastic_stress\n      Property Names:      \"Jacobian_mult\" \"elastic_strain\" \"rotation_total\" \"stress\" \n    Subdomain:  (2)\n      Material Name:       buffer_hc\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       buffer_Ev\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       buffer_EigenStrain\n      Property Names:      \"buffer_eigen\" \"swell_strain\" \"thermal_strain\" \n      Material Name:       buffer_strain\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       buffer_creep\n      Property Names:      \"Leadingcoefficient\" \"cosAlpha\" \"creep_constant\" \"creep_rate\" \"creep_strain\" \n                             \"creepbuffer\" \"stress_delta\" \n      Material Name:       buffer_stress\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n    Subdomain:  (3)\n      Material Name:       PyC_hc\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       Baf\n      Property Names:      \"BAF\" \n      Material Name:       PyC_Ev\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       PyC_EigenStrain\n      Property Names:      \"pyc_eigen\" \"swell_rad\" \"swell_strain\" \"swell_tan\" \"swell_vol\" \"thermal_expansion_coeff00\" \n                             \"thermal_expansion_coeff11\" \"thermal_strain\" \n      Material Name:       pyc_strain\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       creep_pyc\n      Property Names:      \"Leadingcoefficient\" \"cosAlpha\" \"creep_constant\" \"creep_rate\" \"creep_strain\" \n                             \"creeppyc\" \"stress_delta\" \n      Material Name:       pyc_stress\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n    Subdomain:  (4)\n      Material Name:       SiC_hc\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       sic_ev\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       sic_EigenStrain\n      Property Names:      \"sic_coeff00\" \"sic_coeff11\" \"sic_eigen\" \"sic_sat_swell_strain\" \"swell_mat\" \n                             \"swell_strain\" \"thermal_strain\" \n      Material Name:       sic_strain\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       creep_sic\n      Property Names:      \"creep_rate\" \"creep_strain\" \"creepsic\" \n      Material Name:       sic_stress\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n      Material Name:       sic_weibullFialure\n      Property Names:      \"Weibull_failure_probability\" \n    Subdomain:  (5)\n      Material Name:       PyC_hc\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       Baf\n      Property Names:      \"BAF\" \n      Material Name:       PyC_Ev\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       PyC_EigenStrain\n      Property Names:      \"pyc_eigen\" \"swell_rad\" \"swell_strain\" \"swell_tan\" \"swell_vol\" \"thermal_expansion_coeff00\" \n                             \"thermal_expansion_coeff11\" \"thermal_strain\" \n      Material Name:       pyc_strain\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       creep_pyc\n      Property Names:      \"Leadingcoefficient\" \"cosAlpha\" \"creep_constant\" \"creep_rate\" \"creep_strain\" \n                             \"creeppyc\" \"stress_delta\" \n      Material Name:       pyc_stress\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n\n    Active Face Materials:\n    Subdomain:  (1)\n      Material Name:       bu_face\n      Property Names:      \"burnup\" \"burnup_atom\" \"fission_rate\" \n      Material Name:       fgr_face\n      Property Names:      \"Kr_FGR\" \"Xe_FGR\" \"sum_FGP\" \"total_FGR\" \n      Material Name:       kernel_hc_face\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       kernel_Ev_face\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       fuel_eigen_strain_face\n      Property Names:      \"densification_strain\" \"densification_strain_scalar\" \"fuel_eign_strain\" \"swell_strain\" \n                             \"swell_strain_scalar\" \"thermal_strain\" \"thermal_strain_scalar\" \n      Material Name:       fuel_strain_face\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       kernel_elastic_stress_face\n      Property Names:      \"Jacobian_mult\" \"elastic_strain\" \"rotation_total\" \"stress\" \n    Subdomain:  (2)\n      Material Name:       buffer_hc_face\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       buffer_Ev_face\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       buffer_EigenStrain_face\n      Property Names:      \"buffer_eigen\" \"swell_strain\" \"thermal_strain\" \n      Material Name:       buffer_strain_face\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       buffer_creep_face\n      Property Names:      \"Leadingcoefficient\" \"cosAlpha\" \"creep_constant\" \"creep_rate\" \"creep_strain\" \n                             \"creepbuffer\" \"stress_delta\" \n      Material Name:       buffer_stress_face\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n    Subdomain:  (3)\n      Material Name:       PyC_hc_face\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       Baf_face\n      Property Names:      \"BAF\" \n      Material Name:       PyC_Ev_face\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       PyC_EigenStrain_face\n      Property Names:      \"pyc_eigen\" \"swell_rad\" \"swell_strain\" \"swell_tan\" \"swell_vol\" \"thermal_expansion_coeff00\" \n                             \"thermal_expansion_coeff11\" \"thermal_strain\" \n      Material Name:       pyc_strain_face\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       creep_pyc_face\n      Property Names:      \"Leadingcoefficient\" \"cosAlpha\" \"creep_constant\" \"creep_rate\" \"creep_strain\" \n                             \"creeppyc\" \"stress_delta\" \n      Material Name:       pyc_stress_face\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n    Subdomain:  (4)\n      Material Name:       SiC_hc_face\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       sic_ev_face\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       sic_EigenStrain_face\n      Property Names:      \"sic_coeff00\" \"sic_coeff11\" \"sic_eigen\" \"sic_sat_swell_strain\" \"swell_mat\" \n                             \"swell_strain\" \"thermal_strain\" \n      Material Name:       sic_strain_face\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       creep_sic_face\n      Property Names:      \"creep_rate\" \"creep_strain\" \"creepsic\" \n      Material Name:       sic_stress_face\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n      Material Name:       sic_weibullFialure_face\n      Property Names:      \"Weibull_failure_probability\" \n    Subdomain:  (5)\n      Material Name:       PyC_hc_face\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       Baf_face\n      Property Names:      \"BAF\" \n      Material Name:       PyC_Ev_face\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       PyC_EigenStrain_face\n      Property Names:      \"pyc_eigen\" \"swell_rad\" \"swell_strain\" \"swell_tan\" \"swell_vol\" \"thermal_expansion_coeff00\" \n                             \"thermal_expansion_coeff11\" \"thermal_strain\" \n      Material Name:       pyc_strain_face\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       creep_pyc_face\n      Property Names:      \"Leadingcoefficient\" \"cosAlpha\" \"creep_constant\" \"creep_rate\" \"creep_strain\" \n                             \"creeppyc\" \"stress_delta\" \n      Material Name:       pyc_stress_face\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n\nActive Neighboring Materials:\n    Subdomain:  (1)\n      Material Name:       bu_neighbor\n      Property Names:      \"burnup\" \"burnup_atom\" \"fission_rate\" \n      Material Name:       fgr_neighbor\n      Property Names:      \"Kr_FGR\" \"Xe_FGR\" \"sum_FGP\" \"total_FGR\" \n      Material Name:       kernel_hc_neighbor\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       kernel_Ev_neighbor\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       fuel_eigen_strain_neighbor\n      Property Names:      \"densification_strain\" \"densification_strain_scalar\" \"fuel_eign_strain\" \"swell_strain\" \n                             \"swell_strain_scalar\" \"thermal_strain\" \"thermal_strain_scalar\" \n      Material Name:       fuel_strain_neighbor\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       kernel_elastic_stress_neighbor\n      Property Names:      \"Jacobian_mult\" \"elastic_strain\" \"rotation_total\" \"stress\" \n    Subdomain:  (2)\n      Material Name:       buffer_hc_neighbor\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       buffer_Ev_neighbor\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       buffer_EigenStrain_neighbor\n      Property Names:      \"buffer_eigen\" \"swell_strain\" \"thermal_strain\" \n      Material Name:       buffer_strain_neighbor\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       buffer_creep_neighbor\n      Property Names:      \"Leadingcoefficient\" \"cosAlpha\" \"creep_constant\" \"creep_rate\" \"creep_strain\" \n                             \"creepbuffer\" \"stress_delta\" \n      Material Name:       buffer_stress_neighbor\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n    Subdomain:  (3)\n      Material Name:       PyC_hc_neighbor\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       Baf_neighbor\n      Property Names:      \"BAF\" \n      Material Name:       PyC_Ev_neighbor\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       PyC_EigenStrain_neighbor\n      Property Names:      \"pyc_eigen\" \"swell_rad\" \"swell_strain\" \"swell_tan\" \"swell_vol\" \"thermal_expansion_coeff00\" \n                             \"thermal_expansion_coeff11\" \"thermal_strain\" \n      Material Name:       pyc_strain_neighbor\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       creep_pyc_neighbor\n      Property Names:      \"Leadingcoefficient\" \"cosAlpha\" \"creep_constant\" \"creep_rate\" \"creep_strain\" \n                             \"creeppyc\" \"stress_delta\" \n      Material Name:       pyc_stress_neighbor\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n    Subdomain:  (4)\n      Material Name:       SiC_hc_neighbor\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       sic_ev_neighbor\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       sic_EigenStrain_neighbor\n      Property Names:      \"sic_coeff00\" \"sic_coeff11\" \"sic_eigen\" \"sic_sat_swell_strain\" \"swell_mat\" \n                             \"swell_strain\" \"thermal_strain\" \n      Material Name:       sic_strain_neighbor\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       creep_sic_neighbor\n      Property Names:      \"creep_rate\" \"creep_strain\" \"creepsic\" \n      Material Name:       sic_stress_neighbor\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n      Material Name:       sic_weibullFialure_neighbor\n      Property Names:      \"Weibull_failure_probability\" \n    Subdomain:  (5)\n      Material Name:       PyC_hc_neighbor\n      Property Names:      \"density\" \"specific_heat\" \"thermal_conductivity\" \"thermal_conductivity_dT\" \n                             \n      Material Name:       Baf_neighbor\n      Property Names:      \"BAF\" \n      Material Name:       PyC_Ev_neighbor\n      Property Names:      \"effective_stiffness\" \"elasticity_tensor\" \"poissons_ratio_output\" \"youngs_modulus_output\" \n                             \n      Material Name:       PyC_EigenStrain_neighbor\n      Property Names:      \"pyc_eigen\" \"swell_rad\" \"swell_strain\" \"swell_tan\" \"swell_vol\" \"thermal_expansion_coeff00\" \n                             \"thermal_expansion_coeff11\" \"thermal_strain\" \n      Material Name:       pyc_strain_neighbor\n      Property Names:      \"deformation_gradient\" \"mechanical_strain\" \"rotation_increment\" \"strain_increment\" \n                             \"strain_rate\" \"total_strain\" \n      Material Name:       creep_pyc_neighbor\n      Property Names:      \"Leadingcoefficient\" \"cosAlpha\" \"creep_constant\" \"creep_rate\" \"creep_strain\" \n                             \"creeppyc\" \"stress_delta\" \n      Material Name:       pyc_stress_neighbor\n      Property Names:      \"Jacobian_mult\" \"combined_inelastic_strain\" \"elastic_strain\" \"material_timestep_limit\" \n                             \"rotation_total\" \"stress\" \n\nActive Boundary Materials:\n    Boundary: Buffer_outer (1)\n      Material Name:       thermal_contact_gap_value\n      Property Names:      \"contact_conductance\" \"gap_conductance\" \"gap_conductance_dT\" \"gap_conductivity\" \n                             \"gap_gas_temp\" \"gap_width\" \"gas_conductance\" \"mixture_conductivity\" \"radiation_conductance\" \n                             \n    Boundary: IPyC_inner (2)\n      Material Name:       thermal_contact_gap_value_master\n      Property Names:      \"contact_conductance\" \"gap_conductance\" \"gap_conductance_dT\" \"gap_conductivity\" \n                             \"gap_gas_temp\" \"gap_width\" \"gas_conductance\" \"mixture_conductivity\" \"radiation_conductance\" \n                             \n\n\n\n*** Warning, This code is deprecated and will be removed in future versions:\nThe parameter component is deprecated.\nThis parameter is no longer necessary\ufffd[39m\n\n  Finished Initializing                                                                  [\ufffd[33m  5.09 s\ufffd[39m] [\ufffd[33m   15 MB\ufffd[39m]\nFinished Setting Up                                                                      [\ufffd[33m 32.21 s\ufffd[39m] [\ufffd[33m   60 MB\ufffd[39m]\nFramework Information:\nMOOSE Version:           git commit 6640a9a on 2022-05-06\nLibMesh Version:         \nPETSc Version:           3.16.5\nSLEPc Version:           3.16.2\nCurrent Time:            Thu Jul  7 23:24:28 2022\nExecutable Timestamp:    Thu Jul  7 20:55:31 2022\n\nParallelism:\n  Num Processors:          64\n  Num Threads:             1\n\nMesh: \n  Parallel Type:           replicated\n  Mesh Dimension:          3\n  Spatial Dimension:       3\n  Nodes:                   \n    Total:                 3837\n    Local:                 138\n    Min/Max/Avg:           15/138/59\n  Elems:                   \n    Total:                 4680\n    Local:                 66\n    Min/Max/Avg:           63/88/73\n  Num Subdomains:          5\n  Num Partitions:          64\n  Partitioner:             metis\n\nNonlinear System:\n  Num DOFs:                15348\n  Num Local DOFs:          552\n  Variables:               { \"temp\" \"disp_x\" \"disp_y\" \"disp_z\" } \n  Finite Element Types:    \"LAGRANGE\" \n  Approximation Orders:    \"FIRST\" \n\nAuxiliary System:\n  Num DOFs:                132348\n  Num Local DOFs:          2202\n  Variables:               { \"fission_rate\" \"bu\" \"bu_atom\" \"fast_neutron_fluence\" \"baf\" ... \"h_radiation\" \n                             \"h_contact\" \"mixture_conductivity\" \"gap_width_mechanical\" \"thermal_conductivity\" \n                             } \"rad_disp\" { \"Weibull_failure_probability\" \"Weibull_failure_pbAux\" } { \"penetration\" \n                             \"contact_pressure\" \"nodal_area_pellet_clad_mechanical\" } { \"qpoint_penetration\" \n                             \"paired_temp\" } \n  Finite Element Types:    \"MONOMIAL\" \"LAGRANGE\" \"MONOMIAL\" \"LAGRANGE\" \"MONOMIAL\" \n  Approximation Orders:    \"CONSTANT\" \"FIRST\" \"CONSTANT\" \"FIRST\" \"CONSTANT\" \n\nExecution Information:\n  Executioner:             Transient\n  TimeStepper:             IterationAdaptiveDT\n  Solver Mode:             Preconditioned JFNK\n  MOOSE Preconditioner:    SMP\n\n\n\n*** ERROR ***\nCyclic dependency detected in object ordering:\nkernel_hc -> bu\nfuel_eigen_strain -> bu\nfuel_eigen_strain -> buffer_hc\nfuel_eigen_strain -> PyC_hc\nfuel_eigen_strain -> SiC_hc\nfuel_eigen_strain -> kernel_hc\nfuel_strain -> fuel_eigen_strain\nkernel_elastic_stress -> kernel_Ev\nkernel_elastic_stress -> sic_ev\nkernel_elastic_stress -> sic_strain\nkernel_elastic_stress -> buffer_Ev\nkernel_elastic_stress -> PyC_Ev\nkernel_elastic_stress -> pyc_strain\nkernel_elastic_stress -> fuel_strain\nkernel_elastic_stress -> buffer_strain\nbuffer_Ev -> buffer_hc\nbuffer_Ev -> PyC_hc\nbuffer_Ev -> SiC_hc\nbuffer_Ev -> kernel_hc\nbuffer_EigenStrain -> buffer_hc\nbuffer_EigenStrain -> PyC_hc\nbuffer_EigenStrain -> SiC_hc\nbuffer_EigenStrain -> kernel_hc\nbuffer_strain -> buffer_EigenStrain\nbuffer_stress -> buffer_hc\nbuffer_stress -> PyC_hc\nbuffer_stress -> SiC_hc\nbuffer_stress -> kernel_Ev\nbuffer_stress -> sic_ev\nbuffer_stress -> kernel_hc\nbuffer_stress -> sic_strain\nbuffer_stress -> buffer_Ev\nbuffer_stress -> PyC_Ev\nbuffer_stress -> pyc_strain\nbuffer_stress -> fuel_strain\nbuffer_stress -> buffer_strain\nbuffer_stress -> kernel_elastic_stress\nbuffer_stress -> pyc_stress\nbuffer_stress -> sic_stress\nPyC_Ev -> buffer_hc\nPyC_Ev -> PyC_hc\nPyC_Ev -> SiC_hc\nPyC_Ev -> Baf\nPyC_Ev -> kernel_hc\nPyC_EigenStrain -> Baf\npyc_strain -> PyC_EigenStrain\npyc_stress -> buffer_hc\npyc_stress -> PyC_hc\npyc_stress -> SiC_hc\npyc_stress -> kernel_Ev\npyc_stress -> sic_ev\npyc_stress -> kernel_hc\npyc_stress -> sic_strain\npyc_stress -> buffer_Ev\npyc_stress -> PyC_Ev\npyc_stress -> pyc_strain\npyc_stress -> fuel_strain\npyc_stress -> buffer_strain\npyc_stress -> kernel_elastic_stress\npyc_stress -> buffer_stress\nsic_strain -> sic_EigenStrain",
                          "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3101471",
                          "updatedAt": "2022-07-07T15:52:49Z",
                          "publishedAt": "2022-07-07T15:52:48Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Looking at the first few lines, there s a cycle between bu, kernel_hc and fuel_eigen_strain.\nI think you need to fix either\n-kernel_hc to not depend on bu\n-fuel_eigen_strain to not depend on bu OR on kernel_hc",
                          "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3101505",
                          "updatedAt": "2022-07-07T15:58:07Z",
                          "publishedAt": "2022-07-07T15:58:07Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@GiudGiud\nFrom the error infomation,\nkernel_hc -> bu\nfuel_eigen_strain -> bu\nfuel_eigen_strain -> kernel_hc\n\nthe bu doesn't depend on fuel_eigen_strain  or kernel_hc, so i think it is not a cycle.",
                          "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3101658",
                          "updatedAt": "2022-07-07T16:21:38Z",
                          "publishedAt": "2022-07-07T16:21:37Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "umm good point, this just force this ordering:\nfuel_eigen_strain -> kernel_hc -> bu\nok so the cycle is elsewhere",
                          "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3101671",
                          "updatedAt": "2022-07-07T16:23:04Z",
                          "publishedAt": "2022-07-07T16:23:03Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@GiudGiud In each block's HeatConductionMaterial (kernel_hc, buffer_hc, PyC_hc, SiC_hc), I declared  material property  with the same name, for example,  the densities of kernel, buffer, PyC and SiC  are all declared as \"density\".  When  calculating  fuel_eigen_strain in block 1, it should get the \"density\" declared in kernel_hc (block 1).\nfuel_eigen_strain -> kernel_hc\n\nI wonder if this new-added dependency checking function considers the \"density\" also get from other blocks, even although the block is specified in the input file. So it also shows:\nfuel_eigen_strain -> buffer_hc\nfuel_eigen_strain -> PyC_hc\nfuel_eigen_strain -> SiC_hc",
                          "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3101864",
                          "updatedAt": "2022-07-07T16:52:34Z",
                          "publishedAt": "2022-07-07T16:52:34Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "yes if the material property has the same name everywhere it is considered to be the same material property. So this creates dependencies nevermind me I m being dumb",
                          "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3101893",
                          "updatedAt": "2022-07-08T03:07:03Z",
                          "publishedAt": "2022-07-07T16:56:50Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@GiudGiud When using old version of MOOSE, we often declare he material property with the same name for different blocks, for example, \"density\", \"thermal_conductivity\" . It would not error  because the block is specified in the input file.\nAnd it is convenient. When caring about the property \"density\", we just need to create an AuxVariable \"density\" in the input file instead of creating many AuxVariable \"density1\" \"density2\" \"density3\" \"density4\" \"density5\" for each block.\nHowever, this new-added dependency checking function can not identify different blocks, so it may cause the cyclic dependency error report.",
                          "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3102111",
                          "updatedAt": "2022-07-07T17:34:58Z",
                          "publishedAt": "2022-07-07T17:34:58Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "I'd be surprised if the cyclic dependency checker isn't run per subdomain.",
                          "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3102407",
                          "updatedAt": "2022-07-07T18:24:08Z",
                          "publishedAt": "2022-07-07T18:24:07Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nWe have just added stronger dependency resolving, as well as this nice print-out of all the dependencies, which is why you are only seeing this now.\nDid you copy the entire log here? It seems we are not seeing the cycle??\nAlso please dont post screenshots. You should copy the log in triple quotes instead\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3101373",
                  "updatedAt": "2022-07-07T15:38:39Z",
                  "publishedAt": "2022-07-07T15:38:39Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "echo1115"
                          },
                          "bodyText": "@GiudGiud Thanks for your reply. the error log and the  properties of each Subdomain(block) are presented in #21524 (reply in thread)",
                          "url": "https://github.com/idaholab/moose/discussions/21524#discussioncomment-3101495",
                          "updatedAt": "2022-07-07T15:56:53Z",
                          "publishedAt": "2022-07-07T15:56:53Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Error when reading second order (tet10) tetgen mesh files.",
          "author": {
            "login": "Edward-Eth"
          },
          "bodyText": "I've noticed that when attempting to read a tetgen mesh generated with the -o2 flag (second order elements), MOOSE seems to incorrectly identify the elements, leading to a totally garbled mesh. I have included the poly file to allow others to recreate the bug I am seeing easily.\nWhen I run the command:\ntetgen -p plate.poly -M\nI get a standard tet4 mesh, which when loaded into moose and viewed in exodus looks like this:\n\nWhen I instead run the command:\ntetgen -p plate.poly -M -o2\nI get a tet10 mesh, which when loaded into MOOSE and viewed in exodus looks like this:\n\n\nThis obviously renders the mesh totally unusable in MOOSE. I have tried setting allow_renumbering = false in case that was causing the issue, but have had no luck.\n\nPoly File\n# <Number of nodes> <Number of dimensions>\n12 3 0 0\n1 0.00000000000000000000 0.00000000000000000000 0.50000000000000000000\n2 20.00000000000000000000 0.00000000000000000000 0.50000000000000000000\n3 20.00000000000000000000 20.00000000000000000000 0.50000000000000000000\n4 0.00000000000000000000 20.00000000000000000000 0.50000000000000000000\n5 0.00000000000000000000 0.00000000000000000000 0.00000000000000000000\n6 20.00000000000000000000 0.00000000000000000000 0.00000000000000000000\n7 20.00000000000000000000 20.00000000000000000000 0.00000000000000000000\n8 0.00000000000000000000 20.00000000000000000000 0.00000000000000000000\n9 0.00000000000000000000 0.00000000000000000000 -0.50000000000000000000\n10 20.00000000000000000000 0.00000000000000000000 -0.50000000000000000000\n11 20.00000000000000000000 20.00000000000000000000 -0.50000000000000000000\n12 0.00000000000000000000 20.00000000000000000000 -0.50000000000000000000\n\n# <Number of facets> <Boundary markers 0 or 1>\n11\n1 0\n4 1 2 3 4 \n1 0\n4 5 6 7 8 \n1 0\n4 1 2 6 5 \n1 0\n4 2 3 7 6 \n1 0\n4 3 4 8 7 \n1 0\n4 4 1 5 8 \n1 0\n4 5 6 10 9 \n1 0\n4 6 7 11 10 \n1 0\n4 7 8 12 11 \n1 0\n4 8 5 9 12 \n1 0\n4 9 10 11 12 \n\n# <Number of holes>\n0\n\n# Region Attributes\n0\n\n</details.",
          "url": "https://github.com/idaholab/moose/discussions/21574",
          "updatedAt": "2022-07-14T15:27:43Z",
          "publishedAt": "2022-07-13T13:49:42Z",
          "category": {
            "name": "Q&A Meshing"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "Edward-Eth"
                  },
                  "bodyText": "Libmesh says it supports tet10, so I think this is an issue in MOOSE somewhere, but it could be something breaking down in libmesh.",
                  "url": "https://github.com/idaholab/moose/discussions/21574#discussioncomment-3139187",
                  "updatedAt": "2022-07-13T16:04:30Z",
                  "publishedAt": "2022-07-13T16:04:30Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": []
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "Edward-Eth"
                  },
                  "bodyText": "I have raised this with the libmesh developers and we have found that it was an issue in libmesh's mapping of tetgen nodes to nodes within libmesh. The mapping required to make tetgen files work currently is described here: libMesh/libmesh#3337\nHopefully this will get fixed at some point but until then tetgen's simple text file based format means it's easy to write a script to edit the file after generation so that moose will read it correctly.",
                  "url": "https://github.com/idaholab/moose/discussions/21574#discussioncomment-3148162",
                  "updatedAt": "2022-07-14T15:27:42Z",
                  "publishedAt": "2022-07-14T15:27:41Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Diffusion Controlled Evaporation with Displacement / Node Deactivation Approach",
          "author": {
            "login": "AndrewFalkowski"
          },
          "bodyText": "I am looking to model a diffusion controlled evaporation process with mass loss resulting in uniform material recession at the surface; however, I am struggling to come up with a good approach for modeling the recession and shifting of the boundary position with material loss? A coupled displacement condition seems overly complicated and might create errors arising from the displaced mesh. Alternatively, I was considering node deactivation, but I am not sure how to then shift the applied boundary condition.\nIf I could get some advice on an approach to this, that would be great!",
          "url": "https://github.com/idaholab/moose/discussions/21443",
          "updatedAt": "2022-08-13T16:08:23Z",
          "publishedAt": "2022-06-28T15:30:38Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "@cticenhour @aeslaughter  I think would have had a similar challenge with additive manufacturing (boundary advancing instead of receding)",
                  "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3041294",
                  "updatedAt": "2022-06-28T15:39:46Z",
                  "publishedAt": "2022-06-28T15:39:46Z",
                  "isAnswer": false,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "cticenhour"
                          },
                          "bodyText": "I've not done any manufacturing modeling where I've manipulated the mesh, but @SudiptaBiswas and @dewenyushu has done work in additive manufacturing modeling specifically.",
                          "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3041327",
                          "updatedAt": "2022-06-28T15:43:31Z",
                          "publishedAt": "2022-06-28T15:43:31Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              },
              {
                "node": {
                  "author": {
                    "login": "dewenyushu"
                  },
                  "bodyText": "This looks like something that can be done with the element subdomain modifier, e.g., CoupledVarThresholdElementSubdomainModifier\nTo use it, you will need to define two subdomains in your input. One is the 'active' subdomain containing the elements that belongs to the fluid ('active') material. The other one is the 'dummy' subdomain which contains the elements that belongs to the gas ('loss') material.\nMeanwhile, if you do not solve anything for the evaporated phase, the kernels and materials blocks need to be block-restricted, i.e., defined only in the 'active' subdomain.\nThe evaporation of material can be modeled by moving the elements from the 'active' subdomain to the 'dummy' subdomain. This can be taken care of by the CoupledVarThresholdElementSubdomainModifier. You will need to couple it with the variable that represents the material loss (e.g., density) and specify a threshold value, below which the element is treated as belonging to the loss material thus can be moved to a 'dummy' subdomain. If you specify the moving_boundary_name, in the CoupledVarThresholdElementSubdomainModifier, the boundary between the fluid and gas phases should be updated correspondingly.",
                  "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3041674",
                  "updatedAt": "2022-06-28T16:23:18Z",
                  "publishedAt": "2022-06-28T16:23:17Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "AndrewFalkowski"
                          },
                          "bodyText": "Thank you, this was very helpful! If I am not interested in solving for the gas phase, what would be the best approach for nullifying the influence of variables now in the dummy blocks?",
                          "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3123636",
                          "updatedAt": "2022-07-11T18:38:23Z",
                          "publishedAt": "2022-07-11T18:38:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "You should be able to use the NullKernel for the dummy blocks for this purpose. Make sure that you have all your kernels properly defined in corresponding subdomains by including the block = '<block_ids>' in every kernel.",
                          "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3123845",
                          "updatedAt": "2022-07-11T19:18:16Z",
                          "publishedAt": "2022-07-11T19:18:15Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "Either that or you block-restrict the variables out of the dummy blocks.",
                          "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3125027",
                          "updatedAt": "2022-07-12T00:07:57Z",
                          "publishedAt": "2022-07-12T00:07:56Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "GiudGiud"
                          },
                          "bodyText": "this later approach will be cheaper because the matrix will be smaller.",
                          "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3125028",
                          "updatedAt": "2022-07-12T00:08:19Z",
                          "publishedAt": "2022-07-12T00:08:17Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Yeah, I agree with @GiudGiud  - just to add that you may need to turn off kernel_coverage_check and/or material_coverage_check if you go with the later.",
                          "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3130425",
                          "updatedAt": "2022-07-12T15:32:38Z",
                          "publishedAt": "2022-07-12T15:32:36Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AndrewFalkowski"
                          },
                          "bodyText": "Block restriction seems like the right move.\nI have also noticed that the defined boundary seems to persist at the original location even when the moving_boundary_name option is supplied. The result, when opened in paraview, shows two boundaries of the same name, one at the original location and the other at the dummy domain interface. Furthermore, it appears that boundary condition property at the dummy domain interface inherits from the persistent one - i.e. the flux at the interface falls to zero. I couldn't find an example in the MOOSE test files that moves a pre-existing boundary (only one that creates a new one), so I am unsure if this is a bug or an issue with my implementation.",
                          "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3130901",
                          "updatedAt": "2022-07-12T16:29:50Z",
                          "publishedAt": "2022-07-12T16:29:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "dewenyushu"
                          },
                          "bodyText": "Glad that it works to some degree.\nWould you mind sharing some screen shots to illustrate the issue?",
                          "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3139210",
                          "updatedAt": "2022-07-13T16:07:49Z",
                          "publishedAt": "2022-07-13T16:07:44Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "AndrewFalkowski"
                          },
                          "bodyText": "Yes, after poking around more it seems the issue is the the boundary condition no longer applies to the new boundary defined by the user object. Here I am tracking the boundary condition value over time and note that the flux (defined by simple Neumann condition) falls to zero once the boundary is moved - creating a natural (zero flux) boundary condition at the new, moved, boundary. I suspect that the original boundary condition is set to a quadrature point and needs to be updated with the moving boundary.\n\nI have included a simplified input file that illustrates the behavior below:\n[Mesh]\n  [geo]\n    type = GeneratedMeshGenerator\n    dim = 2\n    nx = 100\n    ny = 100\n    xmin = 0\n    xmax = 1\n    ymin = 0\n    ymax = 1\n  []\n  [material_domain]\n    input = geo\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0 0 0'\n    block_id = 1\n    block_name = material\n    top_right = '0.5 1 0'\n  []\n  [void_domain]\n    input = material_domain\n    type = SubdomainBoundingBoxGenerator\n    bottom_left = '0.5 0 0'\n    block_id = 2\n    block_name = void\n    top_right = '1 1 0'\n  []\n  [interface]\n    type = SideSetsBetweenSubdomainsGenerator\n    input = void_domain\n    primary_block = 1\n    paired_block = 2\n    new_boundary = 'phase_interface'\n  []\n[]\n[UserObjects]\n  [material_recession] # object controlling the subdomain shift\n    type = CoupledVarThresholdElementSubdomainModifier\n    coupled_var = phi\n    block = 1\n    criterion_type = BELOW\n    threshold = 9\n    subdomain_id = 2\n    moving_boundary_name = 'phase_interface'\n    execute_on = 'INITIAL TIMESTEP_BEGIN'\n  []\n[]\n[Variables]\n  [phi]\n    block = 'material'\n  []\n[]\n[AuxVariables]\n  [flux_out]\n    block = 'material'\n  []\n[]\n[Kernels]\n  [mass_diffusion]\n    type = ADMatDiffusion\n    variable = phi\n    diffusivity = 1e-5\n    block = 'material'\n  []\n  [mass_diffusion_time]\n    type = ADTimeDerivative\n    variable = phi\n    block = 'material'\n  []\n[]\n[BCs]\n  [flux]\n    type = NeumannBC\n    boundary = 'phase_interface'\n    variable = phi\n    value = -1.5e-3\n    save_in = flux_out\n  []\n[]\n[ICs]\n  [init_phi]\n    type = ConstantIC\n    block = 'material'\n    value = 10\n    variable = phi\n  []\n[]\n\n[Problem]\n  coord_type = XYZ\n  kernel_coverage_check = false\n[]\n\n[Executioner]\n  type = Transient\n  solve_type = 'PJFNK'\n  scheme = 'crank-nicolson'\n  start_time = 0.0\n  end_time = 30\n  dt = 1\n[]\n\n[Postprocessors]\n  [surface_flux]\n    type = ElementExtremeValue\n    variable = flux_out\n    block = 'material'\n  []\n[]\n\n[Outputs]\n  [exo]\n    type = Exodus\n    output_material_properties = false\n    file_base = 'problems/outputs/flux_experiment'\n  []\n[]",
                          "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3139961",
                          "updatedAt": "2022-07-13T17:52:46Z",
                          "publishedAt": "2022-07-13T17:52:45Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Yeah, I pulled down your example, and I can confirm that the NeumannBC is still looping over the original sideset after the phase_interface has been updated.\nBTW, why is this marked as answered, again?",
                          "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3140420",
                          "updatedAt": "2022-07-13T19:11:24Z",
                          "publishedAt": "2022-07-13T19:11:21Z",
                          "isAnswer": false
                        }
                      },
                      {
                        "node": {
                          "author": {
                            "login": "hugary1995"
                          },
                          "bodyText": "Okay, I think I know what's going on. We didn't add the neighbor side to the boundary info. I'll have a PR up momentarily.",
                          "url": "https://github.com/idaholab/moose/discussions/21443#discussioncomment-3140679",
                          "updatedAt": "2022-07-13T20:01:29Z",
                          "publishedAt": "2022-07-13T20:01:28Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "Confusion about some basic concepts",
          "author": {
            "login": "Ethan-xj"
          },
          "bodyText": "Hi all, I'm just starting to use moose.\nI want to know the definition and relationship of node, element and block.\nCould anyone kindly teach me?\nBest regards,\nEthan",
          "url": "https://github.com/idaholab/moose/discussions/21583",
          "updatedAt": "2022-07-21T07:38:35Z",
          "publishedAt": "2022-07-14T02:56:30Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nThis page might help\nhttps://mooseframework.inl.gov/source/mesh/MooseMesh.html\nin general any good book about finite-elements will be really helpful for these concepts\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21583#discussioncomment-3142876",
                  "updatedAt": "2022-07-14T03:56:07Z",
                  "publishedAt": "2022-07-14T03:56:06Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": [
                      {
                        "node": {
                          "author": {
                            "login": "Ethan-xj"
                          },
                          "bodyText": "Thank you for your reply!",
                          "url": "https://github.com/idaholab/moose/discussions/21583#discussioncomment-3143982",
                          "updatedAt": "2022-07-14T07:16:57Z",
                          "publishedAt": "2022-07-14T07:16:57Z",
                          "isAnswer": false
                        }
                      }
                    ]
                  }
                }
              }
            ]
          }
        }
      },
      {
        "node": {
          "title": "How to transfer a Variable to a ArrayVariableAux  component",
          "author": {
            "login": "snugook1108"
          },
          "bodyText": "How to transfer a Variable to a ArrayVariableAux  component using MultiApp.\nI would like to ask you about a Variable to transfer to a ArrayVariableAux component using MultiApp.",
          "url": "https://github.com/idaholab/moose/discussions/21577",
          "updatedAt": "2022-08-13T16:05:42Z",
          "publishedAt": "2022-07-13T18:10:47Z",
          "category": {
            "name": "Q&A General"
          },
          "comments": {
            "edges": [
              {
                "node": {
                  "author": {
                    "login": "GiudGiud"
                  },
                  "bodyText": "Hello\nYou will indeed want to transfer to a regular variable then use the BuildArrayVariableAux to move it to the array variable\nhttps://mooseframework.inl.gov/source/auxkernels/BuildArrayVariableAux.html\nWe dont have support for transfers to and from array variables directly currently, though by the end of the summer it ll be increased a lot\nGuillaume",
                  "url": "https://github.com/idaholab/moose/discussions/21577#discussioncomment-3141007",
                  "updatedAt": "2022-07-13T20:57:41Z",
                  "publishedAt": "2022-07-13T20:57:07Z",
                  "isAnswer": true,
                  "replies": {
                    "edges": []
                  }
                }
              }
            ]
          }
        }
      }
    ]
  }
}